{"version":3,"file":"js/6930.e446bcb7.js","mappings":"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","sources":["webpack://@openeo/web-editor/./node_modules/xml-utils/count-substring.js","webpack://@openeo/web-editor/./node_modules/xml-utils/get-attribute.js","webpack://@openeo/web-editor/./node_modules/ol/xml.js","webpack://@openeo/web-editor/./node_modules/xml-utils/index-of-match.js","webpack://@openeo/web-editor/./node_modules/xml-utils/index-of-match-end.js","webpack://@openeo/web-editor/./node_modules/xml-utils/find-tag-by-name.js","webpack://@openeo/web-editor/./node_modules/xml-utils/find-tags-by-name.js"],"sourcesContent":["function countSubstring(string, substring) {\n  const pattern = new RegExp(substring, \"g\");\n  const match = string.match(pattern);\n  return match ? match.length : 0;\n}\n\nmodule.exports = countSubstring;\nmodule.exports.default = countSubstring;\n","function getAttribute(tag, attributeName, options) {\n  const debug = (options && options.debug) || false;\n  if (debug) console.log(\"[xml-utils] getting \" + attributeName + \" in \" + tag);\n\n  const xml = typeof tag === \"object\" ? tag.outer : tag;\n\n  // only search for attributes in the opening tag\n  const opening = xml.slice(0, xml.indexOf(\">\") + 1);\n\n  const quotechars = ['\"', \"'\"];\n  for (let i = 0; i < quotechars.length; i++) {\n    const char = quotechars[i];\n    const pattern = attributeName + \"\\\\=\" + char + \"([^\" + char + \"]*)\" + char;\n    if (debug) console.log(\"[xml-utils] pattern:\", pattern);\n\n    const re = new RegExp(pattern);\n    const match = re.exec(opening);\n    if (debug) console.log(\"[xml-utils] match:\", match);\n    if (match) return match[1];\n  }\n}\n\nmodule.exports = getAttribute;\nmodule.exports.default = getAttribute;\n","/**\n * @module ol/xml\n */\nimport {extend} from './array.js';\n\n/**\n * When using {@link module:ol/xml.makeChildAppender} or\n * {@link module:ol/xml.makeSimpleNodeFactory}, the top `objectStack` item needs\n * to have this structure.\n * @typedef {Object} NodeStackItem\n * @property {Element} node Node.\n */\n\n/**\n * @typedef {function(Element, Array<*>): void} Parser\n */\n\n/**\n * @typedef {function(Element, *, Array<*>): void} Serializer\n */\n\n/**\n * @type {string}\n */\nexport const XML_SCHEMA_INSTANCE_URI =\n  'http://www.w3.org/2001/XMLSchema-instance';\n\n/**\n * @param {string} namespaceURI Namespace URI.\n * @param {string} qualifiedName Qualified name.\n * @return {Element} Node.\n */\nexport function createElementNS(namespaceURI, qualifiedName) {\n  return getDocument().createElementNS(namespaceURI, qualifiedName);\n}\n\n/**\n * Recursively grab all text content of child nodes into a single string.\n * @param {Node} node Node.\n * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line\n * breaks.\n * @return {string} All text content.\n * @api\n */\nexport function getAllTextContent(node, normalizeWhitespace) {\n  return getAllTextContent_(node, normalizeWhitespace, []).join('');\n}\n\n/**\n * Recursively grab all text content of child nodes into a single string.\n * @param {Node} node Node.\n * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line\n * breaks.\n * @param {Array<string>} accumulator Accumulator.\n * @private\n * @return {Array<string>} Accumulator.\n */\nexport function getAllTextContent_(node, normalizeWhitespace, accumulator) {\n  if (\n    node.nodeType == Node.CDATA_SECTION_NODE ||\n    node.nodeType == Node.TEXT_NODE\n  ) {\n    if (normalizeWhitespace) {\n      accumulator.push(String(node.nodeValue).replace(/(\\r\\n|\\r|\\n)/g, ''));\n    } else {\n      accumulator.push(node.nodeValue);\n    }\n  } else {\n    let n;\n    for (n = node.firstChild; n; n = n.nextSibling) {\n      getAllTextContent_(n, normalizeWhitespace, accumulator);\n    }\n  }\n  return accumulator;\n}\n\n/**\n * @param {Object} object Object.\n * @return {boolean} Is a document.\n */\nexport function isDocument(object) {\n  return 'documentElement' in object;\n}\n\n/**\n * @param {Element} node Node.\n * @param {?string} namespaceURI Namespace URI.\n * @param {string} name Attribute name.\n * @return {string} Value\n */\nexport function getAttributeNS(node, namespaceURI, name) {\n  return node.getAttributeNS(namespaceURI, name) || '';\n}\n\n/**\n * Parse an XML string to an XML Document.\n * @param {string} xml XML.\n * @return {Document} Document.\n * @api\n */\nexport function parse(xml) {\n  return new DOMParser().parseFromString(xml, 'application/xml');\n}\n\n/**\n * Make an array extender function for extending the array at the top of the\n * object stack.\n * @param {function(this: T, Node, Array<*>): (Array<*>|undefined)} valueReader Value reader.\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeArrayExtender(valueReader, thisArg) {\n  return (\n    /**\n     * @param {Node} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function (node, objectStack) {\n      const value = valueReader.call(\n        thisArg !== undefined ? thisArg : this,\n        node,\n        objectStack,\n      );\n      if (value !== undefined) {\n        const array = /** @type {Array<*>} */ (\n          objectStack[objectStack.length - 1]\n        );\n        extend(array, value);\n      }\n    }\n  );\n}\n\n/**\n * Make an array pusher function for pushing to the array at the top of the\n * object stack.\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeArrayPusher(valueReader, thisArg) {\n  return (\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function (node, objectStack) {\n      const value = valueReader.call(\n        thisArg !== undefined ? thisArg : this,\n        node,\n        objectStack,\n      );\n      if (value !== undefined) {\n        const array = /** @type {Array<*>} */ (\n          objectStack[objectStack.length - 1]\n        );\n        array.push(value);\n      }\n    }\n  );\n}\n\n/**\n * Make an object stack replacer function for replacing the object at the\n * top of the stack.\n * @param {function(this: T, Node, Array<*>): *} valueReader Value reader.\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeReplacer(valueReader, thisArg) {\n  return (\n    /**\n     * @param {Node} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function (node, objectStack) {\n      const value = valueReader.call(\n        thisArg !== undefined ? thisArg : this,\n        node,\n        objectStack,\n      );\n      if (value !== undefined) {\n        objectStack[objectStack.length - 1] = value;\n      }\n    }\n  );\n}\n\n/**\n * Make an object property pusher function for adding a property to the\n * object at the top of the stack.\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\n * @param {string} [property] Property.\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeObjectPropertyPusher(valueReader, property, thisArg) {\n  return (\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function (node, objectStack) {\n      const value = valueReader.call(\n        thisArg !== undefined ? thisArg : this,\n        node,\n        objectStack,\n      );\n      if (value !== undefined) {\n        const object = /** @type {!Object} */ (\n          objectStack[objectStack.length - 1]\n        );\n        const name = property !== undefined ? property : node.localName;\n        let array;\n        if (name in object) {\n          array = object[name];\n        } else {\n          array = [];\n          object[name] = array;\n        }\n        array.push(value);\n      }\n    }\n  );\n}\n\n/**\n * Make an object property setter function.\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\n * @param {string} [property] Property.\n * @param {T} [thisArg] The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeObjectPropertySetter(valueReader, property, thisArg) {\n  return (\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function (node, objectStack) {\n      const value = valueReader.call(\n        thisArg !== undefined ? thisArg : this,\n        node,\n        objectStack,\n      );\n      if (value !== undefined) {\n        const object = /** @type {!Object} */ (\n          objectStack[objectStack.length - 1]\n        );\n        const name = property !== undefined ? property : node.localName;\n        object[name] = value;\n      }\n    }\n  );\n}\n\n/**\n * Create a serializer that appends nodes written by its `nodeWriter` to its\n * designated parent. The parent is the `node` of the\n * {@link module:ol/xml~NodeStackItem} at the top of the `objectStack`.\n * @param {function(this: T, Node, V, Array<*>): void} nodeWriter Node writer.\n * @param {T} [thisArg] The object to use as `this` in `nodeWriter`.\n * @return {Serializer} Serializer.\n * @template T, V\n */\nexport function makeChildAppender(nodeWriter, thisArg) {\n  return function (node, value, objectStack) {\n    nodeWriter.call(\n      thisArg !== undefined ? thisArg : this,\n      node,\n      value,\n      objectStack,\n    );\n    const parent = /** @type {NodeStackItem} */ (\n      objectStack[objectStack.length - 1]\n    );\n    const parentNode = parent.node;\n    parentNode.appendChild(node);\n  };\n}\n\n/**\n * Create a serializer that calls the provided `nodeWriter` from\n * {@link module:ol/xml.serialize}. This can be used by the parent writer to have the\n * `nodeWriter` called with an array of values when the `nodeWriter` was\n * designed to serialize a single item. An example would be a LineString\n * geometry writer, which could be reused for writing MultiLineString\n * geometries.\n * @param {function(this: T, Element, V, Array<*>): void} nodeWriter Node writer.\n * @param {T} [thisArg] The object to use as `this` in `nodeWriter`.\n * @return {Serializer} Serializer.\n * @template T, V\n */\nexport function makeArraySerializer(nodeWriter, thisArg) {\n  let serializersNS, nodeFactory;\n  return function (node, value, objectStack) {\n    if (serializersNS === undefined) {\n      serializersNS = {};\n      const serializers = {};\n      serializers[node.localName] = nodeWriter;\n      serializersNS[node.namespaceURI] = serializers;\n      nodeFactory = makeSimpleNodeFactory(node.localName);\n    }\n    serialize(serializersNS, nodeFactory, value, objectStack);\n  };\n}\n\n/**\n * Create a node factory which can use the `keys` passed to\n * {@link module:ol/xml.serialize} or {@link module:ol/xml.pushSerializeAndPop} as node names,\n * or a fixed node name. The namespace of the created nodes can either be fixed,\n * or the parent namespace will be used.\n * @param {string} [fixedNodeName] Fixed node name which will be used for all\n *     created nodes. If not provided, the 3rd argument to the resulting node\n *     factory needs to be provided and will be the nodeName.\n * @param {string} [fixedNamespaceURI] Fixed namespace URI which will be used for\n *     all created nodes. If not provided, the namespace of the parent node will\n *     be used.\n * @return {function(*, Array<*>, string=): (Node|undefined)} Node factory.\n */\nexport function makeSimpleNodeFactory(fixedNodeName, fixedNamespaceURI) {\n  return (\n    /**\n     * @param {*} value Value.\n     * @param {Array<*>} objectStack Object stack.\n     * @param {string} [newNodeName] Node name.\n     * @return {Node} Node.\n     */\n    function (value, objectStack, newNodeName) {\n      const context = /** @type {NodeStackItem} */ (\n        objectStack[objectStack.length - 1]\n      );\n      const node = context.node;\n      let nodeName = fixedNodeName;\n      if (nodeName === undefined) {\n        nodeName = newNodeName;\n      }\n\n      const namespaceURI =\n        fixedNamespaceURI !== undefined ? fixedNamespaceURI : node.namespaceURI;\n      return createElementNS(namespaceURI, /** @type {string} */ (nodeName));\n    }\n  );\n}\n\n/**\n * A node factory that creates a node using the parent's `namespaceURI` and the\n * `nodeName` passed by {@link module:ol/xml.serialize} or\n * {@link module:ol/xml.pushSerializeAndPop} to the node factory.\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\nexport const OBJECT_PROPERTY_NODE_FACTORY = makeSimpleNodeFactory();\n\n/**\n * Create an array of `values` to be used with {@link module:ol/xml.serialize} or\n * {@link module:ol/xml.pushSerializeAndPop}, where `orderedKeys` has to be provided as\n * `key` argument.\n * @param {Object<string, *>} object Key-value pairs for the sequence. Keys can\n *     be a subset of the `orderedKeys`.\n * @param {Array<string>} orderedKeys Keys in the order of the sequence.\n * @return {Array<*>} Values in the order of the sequence. The resulting array\n *     has the same length as the `orderedKeys` array. Values that are not\n *     present in `object` will be `undefined` in the resulting array.\n */\nexport function makeSequence(object, orderedKeys) {\n  const length = orderedKeys.length;\n  const sequence = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    sequence[i] = object[orderedKeys[i]];\n  }\n  return sequence;\n}\n\n/**\n * Create a namespaced structure, using the same values for each namespace.\n * This can be used as a starting point for versioned parsers, when only a few\n * values are version specific.\n * @param {Array<string>} namespaceURIs Namespace URIs.\n * @param {T} structure Structure.\n * @param {Object<string, T>} [structureNS] Namespaced structure to add to.\n * @return {Object<string, T>} Namespaced structure.\n * @template T\n */\nexport function makeStructureNS(namespaceURIs, structure, structureNS) {\n  structureNS = structureNS !== undefined ? structureNS : {};\n  let i, ii;\n  for (i = 0, ii = namespaceURIs.length; i < ii; ++i) {\n    structureNS[namespaceURIs[i]] = structure;\n  }\n  return structureNS;\n}\n\n/**\n * Parse a node using the parsers and object stack.\n * @param {Object<string, Object<string, Parser>>} parsersNS\n *     Parsers by namespace.\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @param {*} [thisArg] The object to use as `this`.\n */\nexport function parseNode(parsersNS, node, objectStack, thisArg) {\n  let n;\n  for (n = node.firstElementChild; n; n = n.nextElementSibling) {\n    const parsers = parsersNS[n.namespaceURI];\n    if (parsers !== undefined) {\n      const parser = parsers[n.localName];\n      if (parser !== undefined) {\n        parser.call(thisArg, n, objectStack);\n      }\n    }\n  }\n}\n\n/**\n * Push an object on top of the stack, parse and return the popped object.\n * @param {T} object Object.\n * @param {Object<string, Object<string, Parser>>} parsersNS\n *     Parsers by namespace.\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @param {*} [thisArg] The object to use as `this`.\n * @return {T} Object.\n * @template T\n */\nexport function pushParseAndPop(object, parsersNS, node, objectStack, thisArg) {\n  objectStack.push(object);\n  parseNode(parsersNS, node, objectStack, thisArg);\n  return /** @type {T} */ (objectStack.pop());\n}\n\n/**\n * Walk through an array of `values` and call a serializer for each value.\n * @param {Object<string, Object<string, Serializer>>} serializersNS\n *     Namespaced serializers.\n * @param {function(this: T, *, Array<*>, (string|undefined)): (Node|undefined)} nodeFactory\n *     Node factory. The `nodeFactory` creates the node whose namespace and name\n *     will be used to choose a node writer from `serializersNS`. This\n *     separation allows us to decide what kind of node to create, depending on\n *     the value we want to serialize. An example for this would be different\n *     geometry writers based on the geometry type.\n * @param {Array<*>} values Values to serialize. An example would be an array\n *     of {@link module:ol/Feature~Feature} instances.\n * @param {Array<*>} objectStack Node stack.\n * @param {Array<string>} [keys] Keys of the `values`. Will be passed to the\n *     `nodeFactory`. This is used for serializing object literals where the\n *     node name relates to the property key. The array length of `keys` has\n *     to match the length of `values`. For serializing a sequence, `keys`\n *     determines the order of the sequence.\n * @param {T} [thisArg] The object to use as `this` for the node factory and\n *     serializers.\n * @template T\n */\nexport function serialize(\n  serializersNS,\n  nodeFactory,\n  values,\n  objectStack,\n  keys,\n  thisArg,\n) {\n  const length = (keys !== undefined ? keys : values).length;\n  let value, node;\n  for (let i = 0; i < length; ++i) {\n    value = values[i];\n    if (value !== undefined) {\n      node = nodeFactory.call(\n        thisArg !== undefined ? thisArg : this,\n        value,\n        objectStack,\n        keys !== undefined ? keys[i] : undefined,\n      );\n      if (node !== undefined) {\n        serializersNS[node.namespaceURI][node.localName].call(\n          thisArg,\n          node,\n          value,\n          objectStack,\n        );\n      }\n    }\n  }\n}\n\n/**\n * @param {O} object Object.\n * @param {Object<string, Object<string, Serializer>>} serializersNS\n *     Namespaced serializers.\n * @param {function(this: T, *, Array<*>, (string|undefined)): (Node|undefined)} nodeFactory\n *     Node factory. The `nodeFactory` creates the node whose namespace and name\n *     will be used to choose a node writer from `serializersNS`. This\n *     separation allows us to decide what kind of node to create, depending on\n *     the value we want to serialize. An example for this would be different\n *     geometry writers based on the geometry type.\n * @param {Array<*>} values Values to serialize. An example would be an array\n *     of {@link module:ol/Feature~Feature} instances.\n * @param {Array<*>} objectStack Node stack.\n * @param {Array<string>} [keys] Keys of the `values`. Will be passed to the\n *     `nodeFactory`. This is used for serializing object literals where the\n *     node name relates to the property key. The array length of `keys` has\n *     to match the length of `values`. For serializing a sequence, `keys`\n *     determines the order of the sequence.\n * @param {T} [thisArg] The object to use as `this` for the node factory and\n *     serializers.\n * @return {O|undefined} Object.\n * @template O, T\n */\nexport function pushSerializeAndPop(\n  object,\n  serializersNS,\n  nodeFactory,\n  values,\n  objectStack,\n  keys,\n  thisArg,\n) {\n  objectStack.push(object);\n  serialize(serializersNS, nodeFactory, values, objectStack, keys, thisArg);\n  return /** @type {O|undefined} */ (objectStack.pop());\n}\n\nlet xmlSerializer_ = undefined;\n\n/**\n * Register a XMLSerializer. Can be used  to inject a XMLSerializer\n * where there is no globally available implementation.\n *\n * @param {XMLSerializer} xmlSerializer A XMLSerializer.\n * @api\n */\nexport function registerXMLSerializer(xmlSerializer) {\n  xmlSerializer_ = xmlSerializer;\n}\n\n/**\n * @return {XMLSerializer} The XMLSerializer.\n */\nexport function getXMLSerializer() {\n  if (xmlSerializer_ === undefined && typeof XMLSerializer !== 'undefined') {\n    xmlSerializer_ = new XMLSerializer();\n  }\n  return xmlSerializer_;\n}\n\nlet document_ = undefined;\n\n/**\n * Register a Document to use when creating nodes for XML serializations. Can be used\n * to inject a Document where there is no globally available implementation.\n *\n * @param {Document} document A Document.\n * @api\n */\nexport function registerDocument(document) {\n  document_ = document;\n}\n\n/**\n * Get a document that should be used when creating nodes for XML serializations.\n * @return {Document} The document.\n */\nexport function getDocument() {\n  if (document_ === undefined && typeof document !== 'undefined') {\n    document_ = document.implementation.createDocument('', '', null);\n  }\n  return document_;\n}\n","function indexOfMatch(xml, pattern, startIndex) {\n  const re = new RegExp(pattern);\n  const match = re.exec(xml.slice(startIndex));\n  if (match) return startIndex + match.index;\n  else return -1;\n}\n\nmodule.exports = indexOfMatch;\nmodule.exports.default = indexOfMatch;\n","function indexOfMatchEnd(xml, pattern, startIndex) {\n  const re = new RegExp(pattern);\n  const match = re.exec(xml.slice(startIndex));\n  if (match) return startIndex + match.index + match[0].length - 1;\n  else return -1;\n}\n\nmodule.exports = indexOfMatchEnd;\nmodule.exports.default = indexOfMatchEnd;\n","const indexOfMatch = require(\"./index-of-match.js\");\nconst indexOfMatchEnd = require(\"./index-of-match-end.js\");\nconst countSubstring = require(\"./count-substring.js\");\n\nfunction findTagByName(xml, tagName, options) {\n  const debug = (options && options.debug) || false;\n  const nested = !(options && typeof options.nested === false);\n\n  const startIndex = (options && options.startIndex) || 0;\n\n  if (debug) console.log(\"[xml-utils] starting findTagByName with\", tagName, \" and \", options);\n\n  const start = indexOfMatch(xml, `\\<${tagName}[ \\n\\>\\/]`, startIndex);\n  if (debug) console.log(\"[xml-utils] start:\", start);\n  if (start === -1) return undefined;\n\n  const afterStart = xml.slice(start + tagName.length);\n\n  let relativeEnd = indexOfMatchEnd(afterStart, \"^[^<]*[ /]>\", 0);\n\n  const selfClosing = relativeEnd !== -1 && afterStart[relativeEnd - 1] === \"/\";\n  if (debug) console.log(\"[xml-utils] selfClosing:\", selfClosing);\n\n  if (selfClosing === false) {\n    // check if tag has subtags with the same name\n    if (nested) {\n      let startIndex = 0;\n      let openings = 1;\n      let closings = 0;\n      while ((relativeEnd = indexOfMatchEnd(afterStart, \"[ /]\" + tagName + \">\", startIndex)) !== -1) {\n        const clip = afterStart.substring(startIndex, relativeEnd + 1);\n        openings += countSubstring(clip, \"<\" + tagName + \"[ \\n\\t>]\");\n        closings += countSubstring(clip, \"</\" + tagName + \">\");\n        // we can't have more openings than closings\n        if (closings >= openings) break;\n        startIndex = relativeEnd;\n      }\n    } else {\n      relativeEnd = indexOfMatchEnd(afterStart, \"[ /]\" + tagName + \">\", 0);\n    }\n  }\n\n  const end = start + tagName.length + relativeEnd + 1;\n  if (debug) console.log(\"[xml-utils] end:\", end);\n  if (end === -1) return undefined;\n\n  const outer = xml.slice(start, end);\n  // tag is like <gml:identifier codeSpace=\"OGP\">urn:ogc:def:crs:EPSG::32617</gml:identifier>\n\n  let inner;\n  if (selfClosing) {\n    inner = null;\n  } else {\n    inner = outer.slice(outer.indexOf(\">\") + 1, outer.lastIndexOf(\"<\"));\n  }\n\n  return { inner, outer, start, end };\n}\n\nmodule.exports = findTagByName;\nmodule.exports.default = findTagByName;\n","const findTagByName = require(\"./find-tag-by-name.js\");\n\nfunction findTagsByName(xml, tagName, options) {\n  const tags = [];\n  const debug = (options && options.debug) || false;\n  const nested = options && typeof options.nested === \"boolean\" ? options.nested : true;\n  let startIndex = (options && options.startIndex) || 0;\n  let tag;\n  while ((tag = findTagByName(xml, tagName, { debug, startIndex }))) {\n    if (nested) {\n      startIndex = tag.start + 1 + tagName.length;\n    } else {\n      startIndex = tag.end;\n    }\n    tags.push(tag);\n  }\n  if (debug) console.log(\"findTagsByName found\", tags.length, \"tags\");\n  return tags;\n}\n\nmodule.exports = findTagsByName;\nmodule.exports.default = findTagsByName;\n"],"names":["countSubstring","string","substring","pattern","RegExp","match","length","module","exports","getAttribute","tag","attributeName","options","debug","console","log","xml","outer","opening","slice","indexOf","quotechars","i","char","re","exec","createElementNS","namespaceURI","qualifiedName","getDocument","getAllTextContent","node","normalizeWhitespace","getAllTextContent_","join","accumulator","nodeType","Node","CDATA_SECTION_NODE","TEXT_NODE","push","String","nodeValue","replace","n","firstChild","nextSibling","isDocument","object","parse","DOMParser","parseFromString","makeArrayPusher","valueReader","thisArg","objectStack","value","call","undefined","this","array","makeObjectPropertyPusher","property","name","localName","makeObjectPropertySetter","makeSimpleNodeFactory","fixedNodeName","fixedNamespaceURI","newNodeName","context","nodeName","makeStructureNS","namespaceURIs","structure","structureNS","ii","parseNode","parsersNS","firstElementChild","nextElementSibling","parsers","parser","pushParseAndPop","pop","document_","document","implementation","createDocument","indexOfMatch","startIndex","index","indexOfMatchEnd","findTagByName","tagName","nested","start","afterStart","relativeEnd","selfClosing","openings","closings","clip","end","inner","lastIndexOf","findTagsByName","tags"],"sourceRoot":""}
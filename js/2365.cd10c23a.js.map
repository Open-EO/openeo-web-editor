{"version":3,"file":"js/2365.cd10c23a.js","mappings":"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","sources":["webpack://@openeo/web-editor/./node_modules/ol/reproj/Triangulation.js","webpack://@openeo/web-editor/./node_modules/ol/reproj/common.js","webpack://@openeo/web-editor/./node_modules/ol/reproj/Tile.js","webpack://@openeo/web-editor/./node_modules/ol/reproj/DataTile.js"],"sourcesContent":["/**\n * @module ol/reproj/Triangulation\n */\nimport {\n  boundingExtent,\n  createEmpty,\n  extendCoordinate,\n  getArea,\n  getBottomLeft,\n  getBottomRight,\n  getTopLeft,\n  getTopRight,\n  getWidth,\n  intersects,\n} from '../extent.js';\nimport {getTransform} from '../proj.js';\nimport {modulo} from '../math.js';\n\n/**\n * Single triangle; consists of 3 source points and 3 target points.\n * @typedef {Object} Triangle\n * @property {Array<import(\"../coordinate.js\").Coordinate>} source Source.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} target Target.\n */\n\n/**\n * Maximum number of subdivision steps during raster reprojection triangulation.\n * Prevents high memory usage and large number of proj4 calls (for certain\n * transformations and areas). At most `2*(2^this)` triangles are created for\n * each triangulated extent (tile/image).\n * @type {number}\n */\nconst MAX_SUBDIVISION = 10;\n\n/**\n * Maximum allowed size of triangle relative to world width. When transforming\n * corners of world extent between certain projections, the resulting\n * triangulation seems to have zero error and no subdivision is performed. If\n * the triangle width is more than this (relative to world width; 0-1),\n * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.\n * @type {number}\n */\nconst MAX_TRIANGLE_WIDTH = 0.25;\n\n/**\n * @classdesc\n * Class containing triangulation of the given target extent.\n * Used for determining source data and the reprojection itself.\n */\nclass Triangulation {\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../extent.js\").Extent} targetExtent Target extent to triangulate.\n   * @param {import(\"../extent.js\").Extent} maxSourceExtent Maximal source extent that can be used.\n   * @param {number} errorThreshold Acceptable error (in source units).\n   * @param {?number} destinationResolution The (optional) resolution of the destination.\n   */\n  constructor(\n    sourceProj,\n    targetProj,\n    targetExtent,\n    maxSourceExtent,\n    errorThreshold,\n    destinationResolution,\n  ) {\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     * @private\n     */\n    this.sourceProj_ = sourceProj;\n\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     * @private\n     */\n    this.targetProj_ = targetProj;\n\n    /** @type {!Object<string, import(\"../coordinate.js\").Coordinate>} */\n    let transformInvCache = {};\n    const transformInv = getTransform(this.targetProj_, this.sourceProj_);\n\n    /**\n     * @param {import(\"../coordinate.js\").Coordinate} c A coordinate.\n     * @return {import(\"../coordinate.js\").Coordinate} Transformed coordinate.\n     * @private\n     */\n    this.transformInv_ = function (c) {\n      const key = c[0] + '/' + c[1];\n      if (!transformInvCache[key]) {\n        transformInvCache[key] = transformInv(c);\n      }\n      return transformInvCache[key];\n    };\n\n    /**\n     * @type {import(\"../extent.js\").Extent}\n     * @private\n     */\n    this.maxSourceExtent_ = maxSourceExtent;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.errorThresholdSquared_ = errorThreshold * errorThreshold;\n\n    /**\n     * @type {Array<Triangle>}\n     * @private\n     */\n    this.triangles_ = [];\n\n    /**\n     * Indicates that the triangulation crosses edge of the source projection.\n     * @type {boolean}\n     * @private\n     */\n    this.wrapsXInSource_ = false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.canWrapXInSource_ =\n      this.sourceProj_.canWrapX() &&\n      !!maxSourceExtent &&\n      !!this.sourceProj_.getExtent() &&\n      getWidth(maxSourceExtent) >= getWidth(this.sourceProj_.getExtent());\n\n    /**\n     * @type {?number}\n     * @private\n     */\n    this.sourceWorldWidth_ = this.sourceProj_.getExtent()\n      ? getWidth(this.sourceProj_.getExtent())\n      : null;\n\n    /**\n     * @type {?number}\n     * @private\n     */\n    this.targetWorldWidth_ = this.targetProj_.getExtent()\n      ? getWidth(this.targetProj_.getExtent())\n      : null;\n\n    const destinationTopLeft = getTopLeft(targetExtent);\n    const destinationTopRight = getTopRight(targetExtent);\n    const destinationBottomRight = getBottomRight(targetExtent);\n    const destinationBottomLeft = getBottomLeft(targetExtent);\n    const sourceTopLeft = this.transformInv_(destinationTopLeft);\n    const sourceTopRight = this.transformInv_(destinationTopRight);\n    const sourceBottomRight = this.transformInv_(destinationBottomRight);\n    const sourceBottomLeft = this.transformInv_(destinationBottomLeft);\n\n    /*\n     * The maxSubdivision controls how many splittings of the target area can\n     * be done. The idea here is to do a linear mapping of the target areas\n     * but the actual overall reprojection (can be) extremely non-linear. The\n     * default value of MAX_SUBDIVISION was chosen based on mapping a 256x256\n     * tile size. However this function is also called to remap canvas rendered\n     * layers which can be much larger. This calculation increases the maxSubdivision\n     * value by the right factor so that each 256x256 pixel area has\n     * MAX_SUBDIVISION divisions.\n     */\n    const maxSubdivision =\n      MAX_SUBDIVISION +\n      (destinationResolution\n        ? Math.max(\n            0,\n            Math.ceil(\n              Math.log2(\n                getArea(targetExtent) /\n                  (destinationResolution * destinationResolution * 256 * 256),\n              ),\n            ),\n          )\n        : 0);\n\n    this.addQuad_(\n      destinationTopLeft,\n      destinationTopRight,\n      destinationBottomRight,\n      destinationBottomLeft,\n      sourceTopLeft,\n      sourceTopRight,\n      sourceBottomRight,\n      sourceBottomLeft,\n      maxSubdivision,\n    );\n\n    if (this.wrapsXInSource_) {\n      let leftBound = Infinity;\n      this.triangles_.forEach(function (triangle, i, arr) {\n        leftBound = Math.min(\n          leftBound,\n          triangle.source[0][0],\n          triangle.source[1][0],\n          triangle.source[2][0],\n        );\n      });\n\n      // Shift triangles to be as close to `leftBound` as possible\n      // (if the distance is more than `worldWidth / 2` it can be closer.\n      this.triangles_.forEach((triangle) => {\n        if (\n          Math.max(\n            triangle.source[0][0],\n            triangle.source[1][0],\n            triangle.source[2][0],\n          ) -\n            leftBound >\n          this.sourceWorldWidth_ / 2\n        ) {\n          const newTriangle = [\n            [triangle.source[0][0], triangle.source[0][1]],\n            [triangle.source[1][0], triangle.source[1][1]],\n            [triangle.source[2][0], triangle.source[2][1]],\n          ];\n          if (newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2) {\n            newTriangle[0][0] -= this.sourceWorldWidth_;\n          }\n          if (newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2) {\n            newTriangle[1][0] -= this.sourceWorldWidth_;\n          }\n          if (newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2) {\n            newTriangle[2][0] -= this.sourceWorldWidth_;\n          }\n\n          // Rarely (if the extent contains both the dateline and prime meridian)\n          // the shift can in turn break some triangles.\n          // Detect this here and don't shift in such cases.\n          const minX = Math.min(\n            newTriangle[0][0],\n            newTriangle[1][0],\n            newTriangle[2][0],\n          );\n          const maxX = Math.max(\n            newTriangle[0][0],\n            newTriangle[1][0],\n            newTriangle[2][0],\n          );\n          if (maxX - minX < this.sourceWorldWidth_ / 2) {\n            triangle.source = newTriangle;\n          }\n        }\n      });\n    }\n\n    transformInvCache = {};\n  }\n\n  /**\n   * Adds triangle to the triangulation.\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n   * @private\n   */\n  addTriangle_(a, b, c, aSrc, bSrc, cSrc) {\n    this.triangles_.push({\n      source: [aSrc, bSrc, cSrc],\n      target: [a, b, c],\n    });\n  }\n\n  /**\n   * Adds quad (points in clock-wise order) to the triangulation\n   * (and reprojects the vertices) if valid.\n   * Performs quad subdivision if needed to increase precision.\n   *\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} d The target d coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} dSrc The source d coordinate.\n   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.\n   * @private\n   */\n  addQuad_(a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {\n    const sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);\n    const sourceCoverageX = this.sourceWorldWidth_\n      ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_\n      : null;\n    const sourceWorldWidth = /** @type {number} */ (this.sourceWorldWidth_);\n\n    // when the quad is wrapped in the source projection\n    // it covers most of the projection extent, but not fully\n    const wrapsX =\n      this.sourceProj_.canWrapX() &&\n      sourceCoverageX > 0.5 &&\n      sourceCoverageX < 1;\n\n    let needsSubdivision = false;\n\n    if (maxSubdivision > 0) {\n      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {\n        const targetQuadExtent = boundingExtent([a, b, c, d]);\n        const targetCoverageX =\n          getWidth(targetQuadExtent) / this.targetWorldWidth_;\n        needsSubdivision =\n          targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n      }\n      if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {\n        needsSubdivision =\n          sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n      }\n    }\n\n    if (!needsSubdivision && this.maxSourceExtent_) {\n      if (\n        isFinite(sourceQuadExtent[0]) &&\n        isFinite(sourceQuadExtent[1]) &&\n        isFinite(sourceQuadExtent[2]) &&\n        isFinite(sourceQuadExtent[3])\n      ) {\n        if (!intersects(sourceQuadExtent, this.maxSourceExtent_)) {\n          // whole quad outside source projection extent -> ignore\n          return;\n        }\n      }\n    }\n\n    let isNotFinite = 0;\n\n    if (!needsSubdivision) {\n      if (\n        !isFinite(aSrc[0]) ||\n        !isFinite(aSrc[1]) ||\n        !isFinite(bSrc[0]) ||\n        !isFinite(bSrc[1]) ||\n        !isFinite(cSrc[0]) ||\n        !isFinite(cSrc[1]) ||\n        !isFinite(dSrc[0]) ||\n        !isFinite(dSrc[1])\n      ) {\n        if (maxSubdivision > 0) {\n          needsSubdivision = true;\n        } else {\n          // It might be the case that only 1 of the points is infinite. In this case\n          // we can draw a single triangle with the other three points\n          isNotFinite =\n            (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) +\n            (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) +\n            (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) +\n            (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);\n          if (\n            isNotFinite != 1 &&\n            isNotFinite != 2 &&\n            isNotFinite != 4 &&\n            isNotFinite != 8\n          ) {\n            return;\n          }\n        }\n      }\n    }\n\n    if (maxSubdivision > 0) {\n      if (!needsSubdivision) {\n        const center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];\n        const centerSrc = this.transformInv_(center);\n\n        let dx;\n        if (wrapsX) {\n          const centerSrcEstimX =\n            (modulo(aSrc[0], sourceWorldWidth) +\n              modulo(cSrc[0], sourceWorldWidth)) /\n            2;\n          dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);\n        } else {\n          dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];\n        }\n        const dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];\n        const centerSrcErrorSquared = dx * dx + dy * dy;\n        needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;\n      }\n      if (needsSubdivision) {\n        if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {\n          // split horizontally (top & bottom)\n          const bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];\n          const bcSrc = this.transformInv_(bc);\n          const da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];\n          const daSrc = this.transformInv_(da);\n\n          this.addQuad_(\n            a,\n            b,\n            bc,\n            da,\n            aSrc,\n            bSrc,\n            bcSrc,\n            daSrc,\n            maxSubdivision - 1,\n          );\n          this.addQuad_(\n            da,\n            bc,\n            c,\n            d,\n            daSrc,\n            bcSrc,\n            cSrc,\n            dSrc,\n            maxSubdivision - 1,\n          );\n        } else {\n          // split vertically (left & right)\n          const ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\n          const abSrc = this.transformInv_(ab);\n          const cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];\n          const cdSrc = this.transformInv_(cd);\n\n          this.addQuad_(\n            a,\n            ab,\n            cd,\n            d,\n            aSrc,\n            abSrc,\n            cdSrc,\n            dSrc,\n            maxSubdivision - 1,\n          );\n          this.addQuad_(\n            ab,\n            b,\n            c,\n            cd,\n            abSrc,\n            bSrc,\n            cSrc,\n            cdSrc,\n            maxSubdivision - 1,\n          );\n        }\n        return;\n      }\n    }\n\n    if (wrapsX) {\n      if (!this.canWrapXInSource_) {\n        return;\n      }\n      this.wrapsXInSource_ = true;\n    }\n\n    // Exactly zero or one of *Src is not finite\n    // The triangles must have the diagonal line as the first side\n    // This is to allow easy code in reproj.s to make it straight for broken\n    // browsers that can't handle diagonal clipping\n    if ((isNotFinite & 0xb) == 0) {\n      this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);\n    }\n    if ((isNotFinite & 0xe) == 0) {\n      this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);\n    }\n    if (isNotFinite) {\n      // Try the other two triangles\n      if ((isNotFinite & 0xd) == 0) {\n        this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);\n      }\n      if ((isNotFinite & 0x7) == 0) {\n        this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);\n      }\n    }\n  }\n\n  /**\n   * Calculates extent of the `source` coordinates from all the triangles.\n   *\n   * @return {import(\"../extent.js\").Extent} Calculated extent.\n   */\n  calculateSourceExtent() {\n    const extent = createEmpty();\n\n    this.triangles_.forEach(function (triangle, i, arr) {\n      const src = triangle.source;\n      extendCoordinate(extent, src[0]);\n      extendCoordinate(extent, src[1]);\n      extendCoordinate(extent, src[2]);\n    });\n\n    return extent;\n  }\n\n  /**\n   * @return {Array<Triangle>} Array of the calculated triangles.\n   */\n  getTriangles() {\n    return this.triangles_;\n  }\n}\n\nexport default Triangulation;\n","/**\n * @module ol/reproj/common\n */\n\n/**\n * Default maximum allowed threshold  (in pixels) for reprojection\n * triangulation.\n * @type {number}\n */\nexport const ERROR_THRESHOLD = 0.5;\n","/**\n * @module ol/reproj/Tile\n */\nimport {ERROR_THRESHOLD} from './common.js';\n\nimport EventType from '../events/EventType.js';\nimport Tile from '../Tile.js';\nimport TileState from '../TileState.js';\nimport Triangulation from './Triangulation.js';\nimport {\n  calculateSourceExtentResolution,\n  canvasPool,\n  render as renderReprojected,\n} from '../reproj.js';\nimport {clamp} from '../math.js';\nimport {getArea, getIntersection, getWidth, wrapAndSliceX} from '../extent.js';\nimport {listen, unlistenByKey} from '../events.js';\nimport {releaseCanvas} from '../dom.js';\n\n/**\n * @typedef {function(number, number, number, number) : (import(\"../ImageTile.js\").default)} FunctionType\n */\n\n/**\n * @typedef {Object} TileOffset\n * @property {import(\"../ImageTile.js\").default} tile Tile.\n * @property {number} offset Offset.\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected tile.\n * See {@link module:ol/source/TileImage~TileImage}.\n *\n */\nclass ReprojTile extends Tile {\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n   * @param {import(\"../tilecoord.js\").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {number} gutter Gutter of the source tiles.\n   * @param {FunctionType} getTileFunction\n   *     Function returning source tiles (z, x, y, pixelRatio).\n   * @param {number} [errorThreshold] Acceptable reprojection error (in px).\n   * @param {boolean} [renderEdges] Render reprojection edges.\n   * @param {import(\"../Tile.js\").Options} [options] Tile options.\n   */\n  constructor(\n    sourceProj,\n    sourceTileGrid,\n    targetProj,\n    targetTileGrid,\n    tileCoord,\n    wrappedTileCoord,\n    pixelRatio,\n    gutter,\n    getTileFunction,\n    errorThreshold,\n    renderEdges,\n    options,\n  ) {\n    super(tileCoord, TileState.IDLE, options);\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.renderEdges_ = renderEdges !== undefined ? renderEdges : false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = pixelRatio;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = gutter;\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.sourceTileGrid_ = sourceTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.targetTileGrid_ = targetTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilecoord.js\").TileCoord}\n     */\n    this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\n\n    /**\n     * @private\n     * @type {!Array<TileOffset>}\n     */\n    this.sourceTiles_ = [];\n\n    /**\n     * @private\n     * @type {?Array<import(\"../events.js\").EventsKey>}\n     */\n    this.sourcesListenerKeys_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.sourceZ_ = 0;\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.clipExtent_ = sourceProj.canWrapX()\n      ? sourceProj.getExtent()\n      : undefined;\n\n    const targetExtent = targetTileGrid.getTileCoordExtent(\n      this.wrappedTileCoord_,\n    );\n    const maxTargetExtent = this.targetTileGrid_.getExtent();\n    let maxSourceExtent = this.sourceTileGrid_.getExtent();\n\n    const limitedTargetExtent = maxTargetExtent\n      ? getIntersection(targetExtent, maxTargetExtent)\n      : targetExtent;\n\n    if (getArea(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const sourceProjExtent = sourceProj.getExtent();\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n      }\n    }\n\n    const targetResolution = targetTileGrid.getResolution(\n      this.wrappedTileCoord_[0],\n    );\n\n    const sourceResolution = calculateSourceExtentResolution(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      targetResolution,\n    );\n\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const errorThresholdInPixels =\n      errorThreshold !== undefined ? errorThreshold : ERROR_THRESHOLD;\n\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n    this.triangulation_ = new Triangulation(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      maxSourceExtent,\n      sourceResolution * errorThresholdInPixels,\n      targetResolution,\n    );\n\n    if (this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\n    let sourceExtent = this.triangulation_.calculateSourceExtent();\n\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = clamp(\n          sourceExtent[1],\n          maxSourceExtent[1],\n          maxSourceExtent[3],\n        );\n        sourceExtent[3] = clamp(\n          sourceExtent[3],\n          maxSourceExtent[1],\n          maxSourceExtent[3],\n        );\n      } else {\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n\n    if (!getArea(sourceExtent)) {\n      this.state = TileState.EMPTY;\n    } else {\n      let worldWidth = 0;\n      let worldsAway = 0;\n      if (sourceProj.canWrapX()) {\n        worldWidth = getWidth(sourceProjExtent);\n        worldsAway = Math.floor(\n          (sourceExtent[0] - sourceProjExtent[0]) / worldWidth,\n        );\n      }\n\n      const sourceExtents = wrapAndSliceX(\n        sourceExtent.slice(),\n        sourceProj,\n        true,\n      );\n      sourceExtents.forEach((extent) => {\n        const sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(\n          extent,\n          this.sourceZ_,\n        );\n\n        for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n          for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n            const tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);\n            if (tile) {\n              const offset = worldsAway * worldWidth;\n              this.sourceTiles_.push({tile, offset});\n            }\n          }\n        }\n        ++worldsAway;\n      });\n\n      if (this.sourceTiles_.length === 0) {\n        this.state = TileState.EMPTY;\n      }\n    }\n  }\n\n  /**\n   * Get the HTML Canvas element for this tile.\n   * @return {HTMLCanvasElement} Canvas.\n   */\n  getImage() {\n    return this.canvas_;\n  }\n\n  /**\n   * @private\n   */\n  reproject_() {\n    const sources = [];\n    this.sourceTiles_.forEach((source) => {\n      const tile = source.tile;\n      if (tile && tile.getState() == TileState.LOADED) {\n        const extent = this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord);\n        extent[0] += source.offset;\n        extent[2] += source.offset;\n        const clipExtent = this.clipExtent_?.slice();\n        if (clipExtent) {\n          clipExtent[0] += source.offset;\n          clipExtent[2] += source.offset;\n        }\n        sources.push({\n          extent: extent,\n          clipExtent: clipExtent,\n          image: tile.getImage(),\n        });\n      }\n    });\n    this.sourceTiles_.length = 0;\n\n    if (sources.length === 0) {\n      this.state = TileState.ERROR;\n    } else {\n      const z = this.wrappedTileCoord_[0];\n      const size = this.targetTileGrid_.getTileSize(z);\n      const width = typeof size === 'number' ? size : size[0];\n      const height = typeof size === 'number' ? size : size[1];\n      const targetResolution = this.targetTileGrid_.getResolution(z);\n      const sourceResolution = this.sourceTileGrid_.getResolution(\n        this.sourceZ_,\n      );\n\n      const targetExtent = this.targetTileGrid_.getTileCoordExtent(\n        this.wrappedTileCoord_,\n      );\n\n      this.canvas_ = renderReprojected(\n        width,\n        height,\n        this.pixelRatio_,\n        sourceResolution,\n        this.sourceTileGrid_.getExtent(),\n        targetResolution,\n        targetExtent,\n        this.triangulation_,\n        sources,\n        this.gutter_,\n        this.renderEdges_,\n        this.interpolate,\n      );\n\n      this.state = TileState.LOADED;\n    }\n    this.changed();\n  }\n\n  /**\n   * Load not yet loaded URI.\n   */\n  load() {\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n\n      let leftToLoad = 0;\n\n      this.sourcesListenerKeys_ = [];\n      this.sourceTiles_.forEach(({tile}) => {\n        const state = tile.getState();\n        if (state == TileState.IDLE || state == TileState.LOADING) {\n          leftToLoad++;\n\n          const sourceListenKey = listen(\n            tile,\n            EventType.CHANGE,\n            function (e) {\n              const state = tile.getState();\n              if (\n                state == TileState.LOADED ||\n                state == TileState.ERROR ||\n                state == TileState.EMPTY\n              ) {\n                unlistenByKey(sourceListenKey);\n                leftToLoad--;\n                if (leftToLoad === 0) {\n                  this.unlistenSources_();\n                  this.reproject_();\n                }\n              }\n            },\n            this,\n          );\n          this.sourcesListenerKeys_.push(sourceListenKey);\n        }\n      });\n\n      if (leftToLoad === 0) {\n        setTimeout(this.reproject_.bind(this), 0);\n      } else {\n        this.sourceTiles_.forEach(function ({tile}, i, arr) {\n          const state = tile.getState();\n          if (state == TileState.IDLE) {\n            tile.load();\n          }\n        });\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  unlistenSources_() {\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\n    this.sourcesListenerKeys_ = null;\n  }\n\n  /**\n   * Remove from the cache due to expiry\n   */\n  release() {\n    if (this.canvas_) {\n      releaseCanvas(this.canvas_.getContext('2d'));\n      canvasPool.push(this.canvas_);\n      this.canvas_ = null;\n    }\n    super.release();\n  }\n}\n\nexport default ReprojTile;\n","/**\n * @module ol/reproj/DataTile\n */\nimport {ERROR_THRESHOLD} from './common.js';\n\nimport DataTile, {asArrayLike, asImageLike, toArray} from '../DataTile.js';\nimport EventType from '../events/EventType.js';\nimport TileState from '../TileState.js';\nimport Triangulation from './Triangulation.js';\nimport {\n  calculateSourceExtentResolution,\n  canvasPool,\n  render as renderReprojected,\n} from '../reproj.js';\nimport {clamp} from '../math.js';\nimport {createCanvasContext2D, releaseCanvas} from '../dom.js';\nimport {getArea, getIntersection, getWidth, wrapAndSliceX} from '../extent.js';\nimport {listen, unlistenByKey} from '../events.js';\n\n/**\n * @typedef {function(number, number, number, number) : import(\"../DataTile.js\").default} TileGetter\n */\n\n/**\n * @typedef {Object} TileOffset\n * @property {DataTile} tile Tile.\n * @property {number} offset Offset.\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n * @property {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n * @property {import(\"../proj/Projection.js\").default} targetProj Target projection.\n * @property {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n * @property {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n * @property {import(\"../tilecoord.js\").TileCoord} [wrappedTileCoord] Coordinate of the tile wrapped in X.\n * @property {number} pixelRatio Pixel ratio.\n * @property {number} gutter Gutter of the source tiles.\n * @property {TileGetter} getTileFunction Function returning source tiles (z, x, y, pixelRatio).\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n * @property {number} [errorThreshold] Acceptable reprojection error (in px).\n * @property {number} [transition=250] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected data tile.\n * See {@link module:ol/source/DataTile~DataTileSource}.\n *\n */\nclass ReprojDataTile extends DataTile {\n  /**\n   * @param {Options} options Tile options.\n   */\n  constructor(options) {\n    super({\n      tileCoord: options.tileCoord,\n      loader: () => Promise.resolve(new Uint8Array(4)),\n      interpolate: options.interpolate,\n      transition: options.transition,\n    });\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = options.pixelRatio;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = options.gutter;\n\n    /**\n     * @type {import(\"../DataTile.js\").Data}\n     * @private\n     */\n    this.reprojData_ = null;\n\n    /**\n     * @type {Error}\n     * @private\n     */\n    this.reprojError_ = null;\n\n    /**\n     * @type {import('../size.js').Size}\n     * @private\n     */\n    this.reprojSize_ = undefined;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.sourceTileGrid_ = options.sourceTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.targetTileGrid_ = options.targetTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilecoord.js\").TileCoord}\n     */\n    this.wrappedTileCoord_ = options.wrappedTileCoord || options.tileCoord;\n\n    /**\n     * @private\n     * @type {!Array<TileOffset>}\n     */\n    this.sourceTiles_ = [];\n\n    /**\n     * @private\n     * @type {?Array<import(\"../events.js\").EventsKey>}\n     */\n    this.sourcesListenerKeys_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.sourceZ_ = 0;\n\n    const sourceProj = options.sourceProj;\n    const sourceProjExtent = sourceProj.getExtent();\n    const sourceTileGridExtent = options.sourceTileGrid.getExtent();\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.clipExtent_ = sourceProj.canWrapX()\n      ? sourceTileGridExtent\n        ? getIntersection(sourceProjExtent, sourceTileGridExtent)\n        : sourceProjExtent\n      : sourceTileGridExtent;\n\n    const targetExtent = this.targetTileGrid_.getTileCoordExtent(\n      this.wrappedTileCoord_,\n    );\n    const maxTargetExtent = this.targetTileGrid_.getExtent();\n    let maxSourceExtent = this.sourceTileGrid_.getExtent();\n\n    const limitedTargetExtent = maxTargetExtent\n      ? getIntersection(targetExtent, maxTargetExtent)\n      : targetExtent;\n\n    if (getArea(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n      }\n    }\n\n    const targetResolution = this.targetTileGrid_.getResolution(\n      this.wrappedTileCoord_[0],\n    );\n\n    const targetProj = options.targetProj;\n    const sourceResolution = calculateSourceExtentResolution(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      targetResolution,\n    );\n\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const errorThresholdInPixels =\n      options.errorThreshold !== undefined\n        ? options.errorThreshold\n        : ERROR_THRESHOLD;\n\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n    this.triangulation_ = new Triangulation(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      maxSourceExtent,\n      sourceResolution * errorThresholdInPixels,\n      targetResolution,\n    );\n\n    if (this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    this.sourceZ_ = this.sourceTileGrid_.getZForResolution(sourceResolution);\n    let sourceExtent = this.triangulation_.calculateSourceExtent();\n\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = clamp(\n          sourceExtent[1],\n          maxSourceExtent[1],\n          maxSourceExtent[3],\n        );\n        sourceExtent[3] = clamp(\n          sourceExtent[3],\n          maxSourceExtent[1],\n          maxSourceExtent[3],\n        );\n      } else {\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n\n    if (!getArea(sourceExtent)) {\n      this.state = TileState.EMPTY;\n    } else {\n      let worldWidth = 0;\n      let worldsAway = 0;\n      if (sourceProj.canWrapX()) {\n        worldWidth = getWidth(sourceProjExtent);\n        worldsAway = Math.floor(\n          (sourceExtent[0] - sourceProjExtent[0]) / worldWidth,\n        );\n      }\n\n      const sourceExtents = wrapAndSliceX(\n        sourceExtent.slice(),\n        sourceProj,\n        true,\n      );\n      sourceExtents.forEach((extent) => {\n        const sourceRange = this.sourceTileGrid_.getTileRangeForExtentAndZ(\n          extent,\n          this.sourceZ_,\n        );\n        const getTile = options.getTileFunction;\n        for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n          for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n            const tile = getTile(this.sourceZ_, srcX, srcY, this.pixelRatio_);\n            if (tile) {\n              const offset = worldsAway * worldWidth;\n              this.sourceTiles_.push({tile, offset});\n            }\n          }\n        }\n        ++worldsAway;\n      });\n\n      if (this.sourceTiles_.length === 0) {\n        this.state = TileState.EMPTY;\n      }\n    }\n  }\n\n  /**\n   * Get the tile size.\n   * @return {import('../size.js').Size} Tile size.\n   */\n  getSize() {\n    return this.reprojSize_;\n  }\n\n  /**\n   * Get the data for the tile.\n   * @return {import(\"../DataTile.js\").Data} Tile data.\n   */\n  getData() {\n    return this.reprojData_;\n  }\n\n  /**\n   * Get any loading error.\n   * @return {Error} Loading error.\n   */\n  getError() {\n    return this.reprojError_;\n  }\n\n  /**\n   * @private\n   */\n  reproject_() {\n    const dataSources = [];\n    this.sourceTiles_.forEach((source) => {\n      const tile = source.tile;\n      if (!tile || tile.getState() !== TileState.LOADED) {\n        return;\n      }\n      const size = tile.getSize();\n      const gutter = this.gutter_;\n      /**\n       * @type {import(\"../DataTile.js\").ArrayLike}\n       */\n      let tileData;\n      const arrayData = asArrayLike(tile.getData());\n      if (arrayData) {\n        tileData = arrayData;\n      } else {\n        tileData = toArray(asImageLike(tile.getData()));\n      }\n      const pixelSize = [size[0] + 2 * gutter, size[1] + 2 * gutter];\n      const isFloat = tileData instanceof Float32Array;\n      const pixelCount = pixelSize[0] * pixelSize[1];\n      const DataType = isFloat ? Float32Array : Uint8Array;\n      const tileDataR = new DataType(tileData.buffer);\n      const bytesPerElement = DataType.BYTES_PER_ELEMENT;\n      const bytesPerPixel = (bytesPerElement * tileDataR.length) / pixelCount;\n      const bytesPerRow = tileDataR.byteLength / pixelSize[1];\n      const bandCount = Math.floor(\n        bytesPerRow / bytesPerElement / pixelSize[0],\n      );\n      const packedLength = pixelCount * bandCount;\n      let packedData = tileDataR;\n      if (tileDataR.length !== packedLength) {\n        packedData = new DataType(packedLength);\n        let dataIndex = 0;\n        let rowOffset = 0;\n        const colCount = pixelSize[0] * bandCount;\n        for (let rowIndex = 0; rowIndex < pixelSize[1]; ++rowIndex) {\n          for (let colIndex = 0; colIndex < colCount; ++colIndex) {\n            packedData[dataIndex++] = tileDataR[rowOffset + colIndex];\n          }\n          rowOffset += bytesPerRow / bytesPerElement;\n        }\n      }\n      const extent = this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord);\n      extent[0] += source.offset;\n      extent[2] += source.offset;\n      const clipExtent = this.clipExtent_?.slice();\n      if (clipExtent) {\n        clipExtent[0] += source.offset;\n        clipExtent[2] += source.offset;\n      }\n      dataSources.push({\n        extent: extent,\n        clipExtent: clipExtent,\n        data: new Uint8Array(packedData.buffer),\n        dataType: DataType,\n        bytesPerPixel: bytesPerPixel,\n        pixelSize: pixelSize,\n      });\n    });\n    this.sourceTiles_.length = 0;\n\n    if (dataSources.length === 0) {\n      this.state = TileState.ERROR;\n    } else {\n      const z = this.wrappedTileCoord_[0];\n      const size = this.targetTileGrid_.getTileSize(z);\n      const targetWidth = typeof size === 'number' ? size : size[0];\n      const targetHeight = typeof size === 'number' ? size : size[1];\n      const targetResolution = this.targetTileGrid_.getResolution(z);\n      const sourceResolution = this.sourceTileGrid_.getResolution(\n        this.sourceZ_,\n      );\n\n      const targetExtent = this.targetTileGrid_.getTileCoordExtent(\n        this.wrappedTileCoord_,\n      );\n\n      let dataR, dataU;\n\n      const bytesPerPixel = dataSources[0].bytesPerPixel;\n\n      const reprojs = Math.ceil(bytesPerPixel / 3);\n      for (let reproj = reprojs - 1; reproj >= 0; --reproj) {\n        const sources = [];\n        for (let i = 0, len = dataSources.length; i < len; ++i) {\n          const dataSource = dataSources[i];\n          const buffer = dataSource.data;\n          const pixelSize = dataSource.pixelSize;\n          const width = pixelSize[0];\n          const height = pixelSize[1];\n          const context = createCanvasContext2D(width, height, canvasPool);\n          const imageData = context.createImageData(width, height);\n          const data = imageData.data;\n          let offset = reproj * 3;\n          for (let j = 0, len = data.length; j < len; j += 4) {\n            data[j] = buffer[offset];\n            data[j + 1] = buffer[offset + 1];\n            data[j + 2] = buffer[offset + 2];\n            data[j + 3] = 255;\n            offset += bytesPerPixel;\n          }\n          context.putImageData(imageData, 0, 0);\n          sources.push({\n            extent: dataSource.extent,\n            clipExtent: dataSource.clipExtent,\n            image: context.canvas,\n          });\n        }\n\n        const canvas = renderReprojected(\n          targetWidth,\n          targetHeight,\n          this.pixelRatio_,\n          sourceResolution,\n          this.sourceTileGrid_.getExtent(),\n          targetResolution,\n          targetExtent,\n          this.triangulation_,\n          sources,\n          this.gutter_,\n          false,\n          false,\n          false,\n          //true,\n        );\n\n        for (let i = 0, len = sources.length; i < len; ++i) {\n          const canvas = sources[i].image;\n          const context = canvas.getContext('2d');\n          releaseCanvas(context);\n          canvasPool.push(context.canvas);\n        }\n\n        const context = canvas.getContext('2d');\n        const imageData = context.getImageData(\n          0,\n          0,\n          canvas.width,\n          canvas.height,\n        );\n\n        releaseCanvas(context);\n        canvasPool.push(canvas);\n\n        if (!dataR) {\n          dataU = new Uint8Array(\n            bytesPerPixel * imageData.width * imageData.height,\n          );\n          dataR = new dataSources[0].dataType(dataU.buffer);\n        }\n\n        const data = imageData.data;\n        let offset = reproj * 3;\n        for (let i = 0, len = data.length; i < len; i += 4) {\n          if (data[i + 3] === 255) {\n            dataU[offset] = data[i];\n            dataU[offset + 1] = data[i + 1];\n            dataU[offset + 2] = data[i + 2];\n          } else {\n            dataU[offset] = 0;\n            dataU[offset + 1] = 0;\n            dataU[offset + 2] = 0;\n          }\n          offset += bytesPerPixel;\n        }\n      }\n\n      this.reprojData_ = dataR;\n      this.reprojSize_ = [\n        Math.round(targetWidth * this.pixelRatio_),\n        Math.round(targetHeight * this.pixelRatio_),\n      ];\n      this.state = TileState.LOADED;\n    }\n    this.changed();\n  }\n\n  /**\n   * Load not yet loaded URI.\n   */\n  load() {\n    if (this.state !== TileState.IDLE && this.state !== TileState.ERROR) {\n      return;\n    }\n    this.state = TileState.LOADING;\n    this.changed();\n\n    let leftToLoad = 0;\n\n    this.sourcesListenerKeys_ = [];\n    this.sourceTiles_.forEach(({tile}) => {\n      const state = tile.getState();\n      if (state !== TileState.IDLE && state !== TileState.LOADING) {\n        return;\n      }\n      leftToLoad++;\n\n      const sourceListenKey = listen(\n        tile,\n        EventType.CHANGE,\n        function () {\n          const state = tile.getState();\n          if (\n            state == TileState.LOADED ||\n            state == TileState.ERROR ||\n            state == TileState.EMPTY\n          ) {\n            unlistenByKey(sourceListenKey);\n            leftToLoad--;\n            if (leftToLoad === 0) {\n              this.unlistenSources_();\n              this.reproject_();\n            }\n          }\n        },\n        this,\n      );\n      this.sourcesListenerKeys_.push(sourceListenKey);\n    });\n\n    if (leftToLoad === 0) {\n      setTimeout(this.reproject_.bind(this), 0);\n    } else {\n      this.sourceTiles_.forEach(function ({tile}) {\n        const state = tile.getState();\n        if (state == TileState.IDLE) {\n          tile.load();\n        }\n      });\n    }\n  }\n\n  /**\n   * @private\n   */\n  unlistenSources_() {\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\n    this.sourcesListenerKeys_ = null;\n  }\n}\n\nexport default ReprojDataTile;\n"],"names":["MAX_SUBDIVISION","MAX_TRIANGLE_WIDTH","Triangulation","constructor","sourceProj","targetProj","targetExtent","maxSourceExtent","errorThreshold","destinationResolution","this","sourceProj_","targetProj_","transformInvCache","transformInv","getTransform","transformInv_","c","key","maxSourceExtent_","errorThresholdSquared_","triangles_","wrapsXInSource_","canWrapXInSource_","canWrapX","getExtent","sourceWorldWidth_","targetWorldWidth_","destinationTopLeft","destinationTopRight","destinationBottomRight","destinationBottomLeft","sourceTopLeft","sourceTopRight","sourceBottomRight","sourceBottomLeft","maxSubdivision","Math","max","ceil","log2","addQuad_","leftBound","Infinity","forEach","triangle","i","arr","min","source","newTriangle","minX","maxX","addTriangle_","a","b","aSrc","bSrc","cSrc","push","target","d","dSrc","sourceQuadExtent","sourceCoverageX","sourceWorldWidth","wrapsX","needsSubdivision","isGlobal","targetQuadExtent","targetCoverageX","isFinite","isNotFinite","center","centerSrc","dx","centerSrcEstimX","dy","centerSrcErrorSquared","abs","bc","bcSrc","da","daSrc","ab","abSrc","cd","cdSrc","calculateSourceExtent","extent","src","getTriangles","ERROR_THRESHOLD","ReprojTile","sourceTileGrid","targetTileGrid","tileCoord","wrappedTileCoord","pixelRatio","gutter","getTileFunction","renderEdges","options","super","IDLE","renderEdges_","undefined","pixelRatio_","gutter_","canvas_","sourceTileGrid_","targetTileGrid_","wrappedTileCoord_","sourceTiles_","sourcesListenerKeys_","sourceZ_","clipExtent_","getTileCoordExtent","maxTargetExtent","limitedTargetExtent","state","EMPTY","sourceProjExtent","targetResolution","getResolution","sourceResolution","errorThresholdInPixels","triangulation_","length","getZForResolution","sourceExtent","worldWidth","worldsAway","floor","sourceExtents","slice","sourceRange","getTileRangeForExtentAndZ","srcX","srcY","minY","maxY","tile","offset","getImage","reproject_","sources","getState","LOADED","clipExtent","image","ERROR","z","size","getTileSize","width","height","interpolate","changed","load","LOADING","leftToLoad","sourceListenKey","CHANGE","e","unlistenSources_","setTimeout","bind","release","getContext","ReprojDataTile","loader","Promise","resolve","Uint8Array","transition","reprojData_","reprojError_","reprojSize_","sourceTileGridExtent","getTile","getSize","getData","getError","dataSources","tileData","arrayData","pixelSize","isFloat","Float32Array","pixelCount","DataType","tileDataR","buffer","bytesPerElement","BYTES_PER_ELEMENT","bytesPerPixel","bytesPerRow","byteLength","bandCount","packedLength","packedData","dataIndex","rowOffset","colCount","rowIndex","colIndex","data","dataType","targetWidth","targetHeight","dataR","dataU","reprojs","reproj","len","dataSource","context","imageData","createImageData","j","putImageData","canvas","getImageData","round"],"sourceRoot":""}
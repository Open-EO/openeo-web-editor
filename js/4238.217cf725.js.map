{"version":3,"file":"js/4238.217cf725.js","mappings":"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","sources":["webpack://@openeo/web-editor/./node_modules/ol-ext/control/TextButton.js","webpack://@openeo/web-editor/./node_modules/ol-ext/control/Toggle.js","webpack://@openeo/web-editor/./node_modules/ol-ext/geom/GeomUtils.js","webpack://@openeo/web-editor/./node_modules/ol-ext/geom/LineStringSplitAt.js","webpack://@openeo/web-editor/./node_modules/ol-ext/interaction/Delete.js","webpack://@openeo/web-editor/./node_modules/ol-ext/interaction/DrawHole.js","webpack://@openeo/web-editor/./node_modules/ol-ext/interaction/DrawRegular.js","webpack://@openeo/web-editor/./node_modules/ol-ext/interaction/ModifyFeature.js","webpack://@openeo/web-editor/./node_modules/ol-ext/interaction/Offset.js","webpack://@openeo/web-editor/./node_modules/ol-ext/interaction/Split.js","webpack://@openeo/web-editor/./node_modules/ol-ext/interaction/Transform.js","webpack://@openeo/web-editor/./node_modules/ol-ext/source/Vector.js","webpack://@openeo/web-editor/./node_modules/ol-ext/interaction/UndoRedo.js","webpack://@openeo/web-editor/./node_modules/ol-ext/style/defaultStyle.js","webpack://@openeo/web-editor/./node_modules/ol/geom/Circle.js","webpack://@openeo/web-editor/./node_modules/ol/interaction/Draw.js","webpack://@openeo/web-editor/./node_modules/ol/interaction/Extent.js","webpack://@openeo/web-editor/./node_modules/ol/events/SnapEvent.js","webpack://@openeo/web-editor/./node_modules/ol/interaction/Snap.js"],"sourcesContent":["/*\tCopyright (c) 2016 Jean-Marc VIGLINO,\r\nreleased under the CeCILL-B license (French BSD license)\r\n(http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).\r\n*/\r\n\r\nimport ol_control_Button from \"./Button.js\";\r\n\r\n/** A simple push button control drawn as text\r\n * @constructor\r\n * @extends {ol_control_Button}\r\n * @param {Object=} options Control options.\r\n *\t@param {String} options.className class of the control\r\n*\t@param {String} options.title title of the control\r\n*\t@param {String} options.html html to insert in the control\r\n*\t@param {function} options.handleClick callback when control is clicked (or use change:active event)\r\n*/\r\nvar ol_control_TextButton = class olcontrolTextButton extends ol_control_Button {\r\n  constructor(options) {\r\n    options = options || {};\r\n    options.className = (options.className || '') + ' ol-text-button';\r\n    super(options);\r\n  }\r\n}\r\n\r\nexport default ol_control_TextButton\r\n","/*\tCopyright (c) 2016 Jean-Marc VIGLINO,\r\n  released under the CeCILL-B license (French BSD license)\r\n  (http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).\r\n*/\r\n\r\nimport ol_control_Button from './Button.js'\r\n\r\n/** A simple toggle control\r\n * The control can be created with an interaction to control its activation.\r\n *\r\n * @constructor\r\n * @extends {ol_control_Button}\r\n * @fires change:active, change:disable\r\n * @param {Object=} options Control options.\r\n *  @param {String} options.className class of the control\r\n *  @param {String} options.title title of the control\r\n *  @param {String} options.html html to insert in the control\r\n *  @param {ol.interaction} options.interaction interaction associated with the control\r\n *  @param {bool} options.active the control is created active, default false\r\n *  @param {bool} options.disable the control is created disabled, default false\r\n *  @param {ol.control.Bar} options.bar a subbar associated with the control (drawn when active if control is nested in a ol.control.Bar)\r\n *  @param {bool} options.autoActive the control will activate when shown in an ol.control.Bar, default false\r\n *  @param {function} options.onToggle callback when control is clicked (or use change:active event)\r\n */\r\nvar ol_control_Toggle = class olcontrolToggle extends ol_control_Button {\r\n  constructor(options) {\r\n    options = options || {};\r\n\r\n    if (options.toggleFn) {\r\n      options.onToggle = options.toggleFn; // compat old version\r\n    }\r\n    options.handleClick = function () {\r\n      self.toggle();\r\n      if (options.onToggle) {\r\n        options.onToggle.call(self, self.getActive());\r\n      }\r\n    };\r\n    options.className = (options.className || '') + ' ol-toggle';\r\n    super(options);\r\n\r\n    var self = this;\r\n\r\n    this.interaction_ = options.interaction;\r\n    if (this.interaction_) {\r\n      this.interaction_.setActive(options.active);\r\n      this.interaction_.on(\"change:active\", function () {\r\n        self.setActive(self.interaction_.getActive());\r\n      });\r\n    }\r\n\r\n    this.set(\"title\", options.title);\r\n\r\n    this.set(\"autoActivate\", options.autoActivate);\r\n    if (options.bar)\r\n      this.setSubBar(options.bar);\r\n\r\n    this.setActive(options.active);\r\n    this.setDisable(options.disable);\r\n  }\r\n  /**\r\n   * Set the map instance the control is associated with\r\n   * and add interaction attached to it to this map.\r\n   * @param {_ol_Map_} map The map instance.\r\n   */\r\n  setMap(map) {\r\n    if (!map && this.getMap()) {\r\n      if (this.interaction_) {\r\n        this.getMap().removeInteraction(this.interaction_);\r\n      }\r\n      if (this.subbar_)\r\n        this.getMap().removeControl(this.subbar_);\r\n    }\r\n\r\n    super.setMap(map);\r\n\r\n    if (map) {\r\n      if (this.interaction_)\r\n        map.addInteraction(this.interaction_);\r\n      if (this.subbar_)\r\n        map.addControl(this.subbar_);\r\n    }\r\n  }\r\n  /** Get the subbar associated with a control\r\n   * @return {ol_control_Bar}\r\n   */\r\n  getSubBar() {\r\n    return this.subbar_;\r\n  }\r\n  /** Set the subbar associated with a control\r\n   * @param {ol_control_Bar} [bar] a subbar if none remove the current subbar\r\n   */\r\n  setSubBar(bar) {\r\n    var map = this.getMap();\r\n    if (map && this.subbar_)\r\n      map.removeControl(this.subbar_);\r\n    this.subbar_ = bar;\r\n    if (bar) {\r\n      this.subbar_.setTarget(this.element);\r\n      this.subbar_.element.classList.add(\"ol-option-bar\");\r\n      if (map)\r\n        map.addControl(this.subbar_);\r\n    }\r\n  }\r\n  /**\r\n   * Test if the control is disabled.\r\n   * @return {bool}.\r\n   * @api stable\r\n   */\r\n  getDisable() {\r\n    var button = this.element.querySelector(\"button\");\r\n    return button && button.disabled;\r\n  }\r\n  /** Disable the control. If disable, the control will be deactivated too.\r\n  * @param {bool} b disable (or enable) the control, default false (enable)\r\n  */\r\n  setDisable(b) {\r\n    if (this.getDisable() == b)\r\n      return;\r\n    this.element.querySelector(\"button\").disabled = b;\r\n    if (b && this.getActive())\r\n      this.setActive(false);\r\n\r\n    this.dispatchEvent({ type: 'change:disable', key: 'disable', oldValue: !b, disable: b });\r\n  }\r\n  /**\r\n   * Test if the control is active.\r\n   * @return {bool}.\r\n   * @api stable\r\n   */\r\n  getActive() {\r\n    return this.element.classList.contains(\"ol-active\");\r\n  }\r\n  /** Toggle control state active/deactive\r\n   */\r\n  toggle() {\r\n    if (this.getActive())\r\n      this.setActive(false);\r\n    else\r\n      this.setActive(true);\r\n  }\r\n  /** Change control state\r\n   * @param {bool} b activate or deactivate the control, default false\r\n   */\r\n  setActive(b) {\r\n    if (this.interaction_)\r\n      this.interaction_.setActive(b);\r\n    if (this.subbar_)\r\n      this.subbar_.setActive(b);\r\n    if (this.getActive() === b)\r\n      return;\r\n    if (b)\r\n      this.element.classList.add(\"ol-active\");\r\n    else\r\n      this.element.classList.remove(\"ol-active\");\r\n\r\n    this.dispatchEvent({ type: 'change:active', key: 'active', oldValue: !b, active: b });\r\n  }\r\n  /** Set the control interaction\r\n  * @param {_ol_interaction_} i interaction to associate with the control\r\n  */\r\n  setInteraction(i) {\r\n    this.interaction_ = i;\r\n  }\r\n  /** Get the control interaction\r\n  * @return {_ol_interaction_} interaction associated with the control\r\n  */\r\n  getInteraction() {\r\n    return this.interaction_;\r\n  }\r\n}\r\n\r\nexport default ol_control_Toggle\r\n","/*\tCopyright (c) 2016 Jean-Marc VIGLINO, \r\n  released under the CeCILL-B license (French BSD license)\r\n  (http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).\r\n\r\n  Usefull function to handle geometric operations\r\n*/\r\n\r\nimport ol_geom_LineString from 'ol/geom/LineString.js'\r\nimport ol_geom_LinearRing from 'ol/geom/LinearRing.js'\r\nimport ol_geom_MultiLineString from 'ol/geom/MultiLineString.js'\r\nimport ol_geom_MultiPoint from 'ol/geom/MultiPoint.js'\r\nimport ol_geom_MultiPolygon from 'ol/geom/MultiPolygon.js'\r\nimport ol_geom_Point from 'ol/geom/Point.js'\r\nimport ol_geom_Polygon from 'ol/geom/Polygon.js'\r\nimport ol_geom_Circle from 'ol/geom/Circle.js'\r\nimport {getCenter as ol_extent_getCenter} from 'ol/extent.js'\r\nimport {buffer as ol_extent_buffer} from 'ol/extent.js'\r\n\r\n/** Distance beetween 2 points\r\n *\tUsefull geometric functions\r\n * @param {ol.Coordinate} p1 first point\r\n * @param {ol.Coordinate} p2 second point\r\n * @return {number} distance\r\n */\r\nvar ol_coordinate_dist2d = function(p1, p2) {\r\n  var dx = p1[0]-p2[0];\r\n  var dy = p1[1]-p2[1];\r\n  return Math.sqrt(dx*dx+dy*dy);\r\n}\r\n\r\n/** 2 points are equal\r\n *\tUsefull geometric functions\r\n * @param {ol.Coordinate} p1 first point\r\n * @param {ol.Coordinate} p2 second point\r\n * @return {boolean}\r\n */\r\nvar ol_coordinate_equal = function(p1, p2) {\r\n  return (p1[0]==p2[0] && p1[1]==p2[1]);\r\n}\r\n\r\n/** Get center coordinate of a feature\r\n * @param {ol.Feature} f\r\n * @return {ol.coordinate} the center\r\n */\r\nvar ol_coordinate_getFeatureCenter = function(f) {\r\n  return ol_coordinate_getGeomCenter (f.getGeometry());\r\n};\r\n\r\n/** Get center coordinate of a geometry\r\n* @param {ol.geom.Geometry} geom\r\n* @return {ol.Coordinate} the center\r\n*/\r\nvar ol_coordinate_getGeomCenter = function(geom) {\r\n  switch (geom.getType()) {\r\n    case 'Point': \r\n      return geom.getCoordinates();\r\n    case \"MultiPolygon\":\r\n      geom = geom.getPolygon(0);\r\n      // fallthrough\r\n    case \"Polygon\":\r\n      return geom.getInteriorPoint().getCoordinates();\r\n    default:\r\n      return geom.getClosestPoint(ol_extent_getCenter(geom.getExtent()));\r\n  }\r\n};\r\n\r\n/** Offset a polyline\r\n * @param {Array<ol.Coordinate>} coords\r\n * @param {number} offset\r\n * @return {Array<ol.Coordinate>} resulting coord\r\n * @see http://stackoverflow.com/a/11970006/796832\r\n * @see https://drive.google.com/viewerng/viewer?a=v&pid=sites&srcid=ZGVmYXVsdGRvbWFpbnxqa2dhZGdldHN0b3JlfGd4OjQ4MzI5M2Y0MjNmNzI2MjY\r\n */\r\nvar ol_coordinate_offsetCoords = function (coords, offset) {\r\n  var path = [];\r\n  var N = coords.length-1;\r\n  var max = N;\r\n  var mi, mi1, li, li1, ri, ri1, si, si1, Xi1, Yi1;\r\n  var p0, p1, p2;\r\n  var isClosed = ol_coordinate_equal(coords[0],coords[N]);\r\n  if (!isClosed) {\r\n    p0 = coords[0];\r\n    p1 = coords[1];\r\n    p2 = [\r\n      p0[0] + (p1[1] - p0[1]) / ol_coordinate_dist2d(p0,p1) *offset,\r\n      p0[1] - (p1[0] - p0[0]) / ol_coordinate_dist2d(p0,p1) *offset\r\n    ];\r\n    path.push(p2);\r\n    coords.push(coords[N])\r\n    N++;\r\n    max--;\r\n  }\r\n  for (var i = 0; i < max; i++) {\r\n    p0 = coords[i];\r\n    p1 = coords[(i+1) % N];\r\n    p2 = coords[(i+2) % N];\r\n\r\n    mi = (p1[1] - p0[1])/(p1[0] - p0[0]);\r\n    mi1 = (p2[1] - p1[1])/(p2[0] - p1[0]);\r\n    // Prevent alignements\r\n    if (Math.abs(mi-mi1) > 1e-10) {\r\n      li = Math.sqrt((p1[0] - p0[0])*(p1[0] - p0[0])+(p1[1] - p0[1])*(p1[1] - p0[1]));\r\n      li1 = Math.sqrt((p2[0] - p1[0])*(p2[0] - p1[0])+(p2[1] - p1[1])*(p2[1] - p1[1]));\r\n      ri = p0[0] + offset*(p1[1] - p0[1])/li;\r\n      ri1 = p1[0] + offset*(p2[1] - p1[1])/li1;\r\n      si = p0[1] - offset*(p1[0] - p0[0])/li;\r\n      si1 = p1[1] - offset*(p2[0] - p1[0])/li1;\r\n      Xi1 = (mi1*ri1-mi*ri+si-si1) / (mi1-mi);\r\n      Yi1 = (mi*mi1*(ri1-ri)+mi1*si-mi*si1) / (mi1-mi);\r\n\r\n      // Correction for vertical lines\r\n      if(p1[0] - p0[0] == 0) {\r\n        Xi1 = p1[0] + offset*(p1[1] - p0[1])/Math.abs(p1[1] - p0[1]);\r\n        Yi1 = mi1*Xi1 - mi1*ri1 + si1;\r\n      }\r\n      if (p2[0] - p1[0] == 0 ) {\r\n        Xi1 = p2[0] + offset*(p2[1] - p1[1])/Math.abs(p2[1] - p1[1]);\r\n        Yi1 = mi*Xi1 - mi*ri + si;\r\n      }\r\n\r\n      path.push([Xi1, Yi1]);\r\n    }\r\n  }\r\n  if (isClosed) {\r\n    path.push(path[0]);\r\n  } else {\r\n    coords.pop();\r\n    p0 = coords[coords.length-1];\r\n    p1 = coords[coords.length-2];\r\n    p2 = [\r\n      p0[0] - (p1[1] - p0[1]) / ol_coordinate_dist2d(p0,p1) *offset,\r\n      p0[1] + (p1[0] - p0[0]) / ol_coordinate_dist2d(p0,p1) *offset\r\n    ];\r\n    path.push(p2);\r\n  }\r\n  return path;\r\n}\r\n\r\n/** Find the segment a point belongs to\r\n * @param {ol.Coordinate} pt\r\n * @param {Array<ol.Coordinate>} coords\r\n * @return {} the index (-1 if not found) and the segment\r\n */\r\nvar ol_coordinate_findSegment = function (pt, coords) {\r\n  for (var i=0; i<coords.length-1; i++) {\r\n    var p0 = coords[i];\r\n    var p1 = coords[i+1];\r\n    if (ol_coordinate_equal(pt, p0) || ol_coordinate_equal(pt, p1)) {\r\n      return { index:1, segment: [p0,p1] };\r\n    } else {\r\n      var d0 = ol_coordinate_dist2d(p0,p1);\r\n      var v0 = [ (p1[0] - p0[0]) / d0, (p1[1] - p0[1]) / d0 ];\r\n      var d1 = ol_coordinate_dist2d(p0,pt);\r\n      var v1 = [ (pt[0] - p0[0]) / d1, (pt[1] - p0[1]) / d1 ];\r\n      if (Math.abs(v0[0]*v1[1] - v0[1]*v1[0]) < 1e-10) {\r\n        return { index:1, segment: [p0,p1] };\r\n      }\r\n    }\r\n  }\r\n  return { index: -1 };\r\n};\r\n\r\n/**\r\n * Split a Polygon geom with horizontal lines\r\n * @param {Array<ol.Coordinate>} geom\r\n * @param {number} y the y to split\r\n * @param {number} n contour index\r\n * @return {Array<Array<ol.Coordinate>>}\r\n */\r\nvar ol_coordinate_splitH = function (geom, y, n) {\r\n  var x, abs;\r\n  var list = [];\r\n  for (var i=0; i<geom.length-1; i++) {\r\n    // Hole separator?\r\n    if (!geom[i].length || !geom[i+1].length) continue;\r\n    // Intersect\r\n    if (geom[i][1]<=y && geom[i+1][1]>y || geom[i][1]>=y && geom[i+1][1]<y) {\r\n      abs = (y-geom[i][1]) / (geom[i+1][1]-geom[i][1]);\r\n      x = abs * (geom[i+1][0]-geom[i][0]) + geom[i][0];\r\n      list.push ({ contour: n, index: i, pt: [x,y], abs: abs });\r\n    }\r\n  }\r\n  // Sort x\r\n  list.sort(function(a,b) { return a.pt[0] - b.pt[0] });\r\n  // Horizontal segment\r\n  var result = [];\r\n  for (var j=0; j<list.length-1; j += 2) {\r\n    result.push([list[j], list[j+1]])\r\n  }\r\n  return result;\r\n};\r\n\r\n/** Create a geometry given a type and coordinates */\r\nvar ol_geom_createFromType = function (type, coordinates) {\r\n  switch (type) {\r\n    case 'LineString': return new ol_geom_LineString(coordinates);\r\n    case 'LinearRing': return new ol_geom_LinearRing(coordinates);\r\n    case 'MultiLineString': return new ol_geom_MultiLineString(coordinates);\r\n    case 'MultiPoint': return new ol_geom_MultiPoint(coordinates);\r\n    case 'MultiPolygon': return new ol_geom_MultiPolygon(coordinates);\r\n    case 'Point': return new ol_geom_Point(coordinates);\r\n    case 'Polygon': return new ol_geom_Polygon(coordinates);\r\n    default:\r\n      console.error('[createFromType] Unsupported type: '+type);\r\n      return null;\r\n  }\r\n};\r\n\r\nexport {ol_geom_createFromType}\r\nexport {ol_coordinate_dist2d, ol_coordinate_equal, ol_coordinate_findSegment, ol_coordinate_getFeatureCenter, ol_coordinate_getGeomCenter, ol_coordinate_offsetCoords, ol_coordinate_splitH}\r\n\r\n/** Intersect 2 lines\r\n * @param {Arrar<ol.coordinate>} d1\r\n * @param {Arrar<ol.coordinate>} d2\r\n */\r\nvar ol_coordinate_getIntersectionPoint = function (d1, d2) {\r\n  var d1x = d1[1][0] - d1[0][0];\r\n  var d1y = d1[1][1] - d1[0][1];\r\n  var d2x = d2[1][0] - d2[0][0];\r\n  var d2y = d2[1][1] - d2[0][1];\r\n  var det = d1x * d2y - d1y * d2x;\r\n  if (det != 0) {\r\n    var k = (d1x * d1[0][1] - d1x * d2[0][1] - d1y * d1[0][0] + d1y * d2[0][0]) / det;\r\n    return [d2[0][0] + k*d2x, d2[0][1] + k*d2y];\r\n  } else {\r\n    return false;\r\n  }\r\n};\r\n\r\nexport { ol_coordinate_getIntersectionPoint }\r\n\r\nvar ol_extent_intersection;\r\n\r\n(function() {\r\n// Split at x\r\nfunction splitX(pts, x) {\r\n  var pt;\r\n  for (let i=pts.length-1; i>0; i--) {\r\n    if ((pts[i][0]>x && pts[i-1][0]<x) || (pts[i][0]<x && pts[i-1][0]>x)) {\r\n      pt = [ x, (x - pts[i][0]) / (pts[i-1][0]-pts[i][0]) * (pts[i-1][1]-pts[i][1]) + pts[i][1]];\r\n      pts.splice(i, 0, pt);\r\n    }\r\n  }\r\n}\r\n// Split at y\r\nfunction splitY(pts, y) {\r\n  var pt;\r\n  for (let i=pts.length-1; i>0; i--) {\r\n    if ((pts[i][1]>y && pts[i-1][1]<y) || (pts[i][1]<y && pts[i-1][1]>y)) {\r\n      pt = [ (y - pts[i][1]) / (pts[i-1][1]-pts[i][1]) * (pts[i-1][0]-pts[i][0]) + pts[i][0], y];\r\n      pts.splice(i, 0, pt);\r\n    }\r\n  }\r\n}\r\n\r\n/** Fast polygon intersection with an extent (used for area calculation)\r\n * @param {ol_extent_Extent} extent\r\n * @param {ol_geom_Polygon|ol_geom_MultiPolygon} polygon\r\n * @returns {ol_geom_Polygon|ol_geom_MultiPolygon|null} return null if not a polygon geometry\r\n */\r\nol_extent_intersection = function(extent, polygon) {\r\n  var poly = (polygon.getType() === 'Polygon');\r\n  if (!poly && polygon.getType() !== 'MultiPolygon') return null;\r\n  var geom = polygon.getCoordinates();\r\n  if (poly) geom = [geom];\r\n  geom.forEach(function(g) {\r\n    g.forEach(function(c) {\r\n      splitX(c, extent[0]);\r\n      splitX(c, extent[2]);\r\n      splitY(c, extent[1]);\r\n      splitY(c, extent[3]);\r\n    });\r\n  })\r\n  // Snap geom to the extent \r\n  geom.forEach(function(g) {\r\n    g.forEach(function(c) {\r\n      c.forEach(function(p) {\r\n        if (p[0]<extent[0]) p[0] = extent[0];\r\n        else if (p[0]>extent[2]) p[0] = extent[2];\r\n        if (p[1]<extent[1]) p[1] = extent[1];\r\n        else if (p[1]>extent[3]) p[1] = extent[3];\r\n      })\r\n    })\r\n  })\r\n  if (poly) {\r\n    return new ol_geom_Polygon(geom[0]);\r\n  } else {\r\n    return new ol_geom_MultiPolygon(geom);\r\n  }\r\n};\r\n})();\r\n\r\nexport { ol_extent_intersection }\r\nexport { ol_extent_intersection as extentIntersection }\r\n\r\n/** Add points along a segment\r\n * @param {ol_Coordinate} p1 \r\n * @param {ol_Coordinate} p2 \r\n * @param {number} d \r\n * @param {boolean} start include starting point, default true\r\n * @returns {Array<ol_Coordinate>}\r\n */\r\nvar ol_coordinate_sampleAt = function(p1, p2, d, start) {\r\n  var pts = [];\r\n  if (start!==false) pts.push(p1);\r\n  var dl = ol_coordinate_dist2d(p1,p2);\r\n  if (dl) {\r\n    var nb = Math.round(dl/d);\r\n    if (nb>1) {\r\n      var dx = (p2[0]-p1[0]) / nb;\r\n      var dy = (p2[1]-p1[1]) / nb;\r\n      for (var i=1; i<nb; i++) {\r\n        pts.push([p1[0] + dx*i, p1[1] + dy*i])\r\n      }\r\n    }\r\n  }\r\n  pts.push(p2);\r\n  return pts;\r\n};\r\nexport { ol_coordinate_sampleAt }\r\n\r\n/** Sample a LineString at a distance\r\n * @param {number} d\r\n * @returns {ol_geom_LineString}\r\n */\r\nol_geom_LineString.prototype.sampleAt = function(d) {\r\n  var line = this.getCoordinates();\r\n  var result = [];\r\n  for (var i=1; i<line.length; i++) {\r\n    result = result.concat(ol_coordinate_sampleAt(line[i-1], line[i], d, i===1));\r\n  }\r\n  return new ol_geom_LineString(result);\r\n};\r\n\r\n/** Sample a MultiLineString at a distance\r\n * @param {number} d\r\n * @returns {ol_geom_MultiLineString}\r\n */\r\nol_geom_MultiLineString.prototype.sampleAt = function(d) {\r\n  var lines = this.getCoordinates();\r\n  var result = [];\r\n  lines.forEach(function(p) {\r\n    var l = [];\r\n    for (var i=1; i<p.length; i++) {\r\n      l = l.concat(ol_coordinate_sampleAt(p[i-1], p[i], d, i===1));\r\n    }\r\n    result.push(l);\r\n  })\r\n  return new ol_geom_MultiLineString(result);\r\n};\r\n\r\n/** Sample a Polygon at a distance\r\n * @param {number} d\r\n * @returns {ol_geom_Polygon}\r\n */\r\nol_geom_Polygon.prototype.sampleAt = function(res) {\r\n  var poly = this.getCoordinates();\r\n  var result = [];\r\n  poly.forEach(function(p) {\r\n    var l = [];\r\n    for (var i=1; i<p.length; i++) {\r\n      l = l.concat(ol_coordinate_sampleAt(p[i-1], p[i], res, i===1));\r\n    }\r\n    result.push(l);\r\n  })\r\n  return new ol_geom_Polygon(result);\r\n};\r\n\r\n/** Sample a MultiPolygon at a distance\r\n * @param {number} res\r\n * @returns {ol_geom_MultiPolygon}\r\n */\r\nol_geom_MultiPolygon.prototype.sampleAt = function(res) {\r\n  var mpoly = this.getCoordinates();\r\n  var result = [];\r\n  mpoly.forEach(function(poly) {\r\n    var a = [];\r\n    result.push(a);\r\n    poly.forEach(function(p) {\r\n      var l = [];\r\n      for (var i=1; i<p.length; i++) {\r\n        l = l.concat(ol_coordinate_sampleAt(p[i-1], p[i], res, i===1));\r\n      }\r\n      a.push(l);\r\n    })\r\n  });\r\n  return new ol_geom_MultiPolygon(result);\r\n};\r\n\r\n/** Intersect a geometry using a circle\r\n * @param {ol_geom_Geometry} geom\r\n * @param {number} resolution circle resolution to sample the polygon on the circle, default 1\r\n * @returns {ol_geom_Geometry}\r\n */\r\nol_geom_Circle.prototype.intersection = function(geom, resolution) {\r\n  if (geom.sampleAt) {\r\n    var ext = ol_extent_buffer(this.getCenter().concat(this.getCenter()), this.getRadius());\r\n    geom = ol_extent_intersection(ext, geom);\r\n    geom = geom.simplify(resolution);\r\n    var c = this.getCenter();\r\n    var r = this.getRadius();\r\n    //var res = (resolution||1) * r / 100;\r\n    var g = geom.sampleAt(resolution).getCoordinates();\r\n    switch (geom.getType()) {\r\n      case 'Polygon': g = [g];\r\n        // fallthrough\r\n      case 'MultiPolygon': {\r\n        var hasout = false;\r\n        // var hasin = false;\r\n        var result = [];\r\n        g.forEach(function(poly) {\r\n          var a = [];\r\n          result.push(a);\r\n          poly.forEach(function(ring) {\r\n            var l = [];\r\n            a.push(l);\r\n            ring.forEach(function(p) {\r\n              var d = ol_coordinate_dist2d(c, p);\r\n              if (d > r) {\r\n                hasout = true;\r\n                l.push([\r\n                  c[0] + r / d * (p[0]-c[0]),\r\n                  c[1] + r / d * (p[1]-c[1])\r\n                ]);\r\n              } else {\r\n                // hasin = true;\r\n                l.push(p);\r\n              }\r\n            });\r\n          })\r\n        });\r\n        if (!hasout) return geom;\r\n        if (geom.getType() === 'Polygon') {\r\n          return new ol_geom_Polygon(result[0]);\r\n        } else {\r\n          return new ol_geom_MultiPolygon(result);\r\n        }\r\n      }\r\n    }\r\n  } else {\r\n    console.warn('[ol/geom/Circle~intersection] Unsupported geometry type: '+geom.getType());\r\n  }\r\n  return geom;\r\n};\r\n","import {ol_coordinate_equal} from \"./GeomUtils.js\";\r\nimport ol_geom_LineString from \"ol/geom/LineString.js\";\r\n\r\n/** Split a lineString by a point or a list of points\r\n *\tNB: points must be on the line, use getClosestPoint() to get one\r\n * @param {ol.Coordinate | Array<ol.Coordinate>} pt points to split the line\r\n * @param {Number} tol distance tolerance for 2 points to be equal\r\n */\r\nol_geom_LineString.prototype.splitAt = function(pt, tol) {\r\n  var i;\r\n  if (!pt) return [this];\r\n    if (!tol) tol = 1e-10;\r\n    // Test if list of points\r\n    if (pt.length && pt[0].length) {\r\n      var result = [this];\r\n      for (i=0; i<pt.length; i++) {\r\n        var r = [];\r\n        for (var k=0; k<result.length; k++) {\r\n          var ri = result[k].splitAt(pt[i], tol);\r\n          r = r.concat(ri);\r\n        }\r\n        result = r;\r\n      }\r\n      return result;\r\n    }\r\n    // Nothing to do\r\n    if (ol_coordinate_equal(pt,this.getFirstCoordinate())\r\n    || ol_coordinate_equal(pt,this.getLastCoordinate())) {\r\n      return [this];\r\n    }\r\n    // Get\r\n    var c0 = this.getCoordinates();\r\n    var ci=[c0[0]];\r\n    var c = [];\r\n    for (i=0; i<c0.length-1; i++) {\r\n      // Filter equal points\r\n      if (ol_coordinate_equal(c0[i],c0[i+1])) continue;\r\n      // Extremity found\r\n      if (ol_coordinate_equal(pt,c0[i+1])) {\r\n        ci.push(c0[i+1]);\r\n        c.push(new ol_geom_LineString(ci));\r\n        ci = [];\r\n      }\r\n      // Test alignement\r\n      else if (!ol_coordinate_equal(pt,c0[i])) {\r\n        var d1, d2, split=false;\r\n        if (c0[i][0] == c0[i+1][0]) {\r\n          d1 = (c0[i][1]-pt[1]) / (c0[i][1]-c0[i+1][1]);\r\n          split = (c0[i][0] == pt[0]) && (0 < d1 && d1 <= 1)\r\n        } else if (c0[i][1] == c0[i+1][1]) {\r\n          d1 = (c0[i][0]-pt[0]) / (c0[i][0]-c0[i+1][0]);\r\n          split = (c0[i][1] == pt[1]) && (0 < d1 && d1 <= 1)\r\n        } else {\r\n          d1 = (c0[i][0]-pt[0]) / (c0[i][0]-c0[i+1][0]);\r\n          d2 = (c0[i][1]-pt[1]) / (c0[i][1]-c0[i+1][1]);\r\n          split = (Math.abs(d1-d2) <= tol && 0 < d1 && d1 <= 1)\r\n        }\r\n        // pt is inside the segment > split\r\n        if (split) {\r\n          ci.push(pt);\r\n          c.push (new ol_geom_LineString(ci));\r\n          ci = [pt];\r\n        }\r\n      }\r\n      ci.push(c0[i+1]);\r\n    }\r\n    if (ci.length>1) c.push (new ol_geom_LineString(ci));\r\n    if (c.length) return c;\r\n    else return [this];\r\n}\r\n\r\n// import('ol-ext/geom/LineStringSplitAt')","/*\tCopyright (c) 2018 Jean-Marc VIGLINO, \r\n\treleased under the CeCILL-B license (French BSD license)\r\n\t(http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).\r\n*/\r\n\r\nimport ol_interaction_Select from 'ol/interaction/Select.js'\r\nimport ol_source_Vector from 'ol/source/Vector.js'\r\n\r\n/** A Select interaction to delete features on click.\r\n * @constructor\r\n * @extends {ol_interaction_Interaction}\r\n * @fires deletestart\r\n * @fires deleteend\r\n * @param {Object} options ol.interaction.Select options\r\n */\r\nvar ol_interaction_Delete = class olinteractionDelete extends ol_interaction_Select {\r\n  constructor(options) {\r\n    super(options);\r\n    this.on('select', function (e) {\r\n      this.getFeatures().clear();\r\n      this.delete(e.selected);\r\n    }.bind(this));\r\n  }\r\n  /** Get vector source of the map\r\n   * @return {Array<ol.source.Vector>}\r\n   */\r\n  _getSources(layers) {\r\n    if (!this.getMap())\r\n      return [];\r\n    if (!layers)\r\n      layers = this.getMap().getLayers();\r\n    var sources = [];\r\n    layers.forEach(function (l) {\r\n      // LayerGroup\r\n      if (l.getLayers) {\r\n        sources = sources.concat(this._getSources(l.getLayers()));\r\n      } else {\r\n        if (l.getSource && l.getSource() instanceof ol_source_Vector) {\r\n          sources.push(l.getSource());\r\n        }\r\n      }\r\n    }.bind(this));\r\n    return sources;\r\n  }\r\n  /** Delete features: remove the features from the map (from all layers in the map)\r\n   * @param {ol.Collection<ol.Feature>|Array<ol.Feature>} features The features to delete\r\n   * @api\r\n   */\r\n  delete(features) {\r\n    if (features && (features.length || features.getLength())) {\r\n      this.dispatchEvent({ type: 'deletestart', features: features });\r\n      var delFeatures = [];\r\n      // Get the sources concerned\r\n      this._getSources().forEach(function (source) {\r\n        try {\r\n          // Try to delete features in the source\r\n          features.forEach(function (f) {\r\n            source.removeFeature(f);\r\n            delFeatures.push(f);\r\n          });\r\n        } catch (e) { /* ok */ }\r\n      });\r\n      this.dispatchEvent({ type: 'deleteend', features: delFeatures });\r\n    }\r\n  }\r\n}\r\n\r\nexport default ol_interaction_Delete","/*\tCopyright (c) 2017 Jean-Marc VIGLINO, \r\n  released under the CeCILL-B license (French BSD license)\r\n  (http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).\r\n*/\r\n\r\nimport ol_geom_Polygon from 'ol/geom/Polygon.js'\r\nimport ol_geom_MultiPolygon from 'ol/geom/MultiPolygon.js'\r\nimport ol_geom_LinearRing from 'ol/geom/LinearRing.js'\r\nimport ol_interaction_Draw from 'ol/interaction/Draw.js'\r\nimport ol_interaction_Select from 'ol/interaction/Select.js'\r\n\r\n/** Interaction to draw holes in a polygon.\r\n * It fires a drawstart, drawend event when drawing the hole\r\n * and a modifystart, modifyend event before and after inserting the hole in the feature geometry.\r\n * @constructor\r\n * @extends {ol_interaction_Interaction}\r\n * @fires drawstart\r\n * @fires drawend\r\n * @fires modifystart\r\n * @fires modifyend\r\n * @param {olx.interaction.DrawHoleOptions} options extend olx.interaction.DrawOptions\r\n * \t@param {Array<ol.layer.Vector> | function | undefined} options.layers A list of layers from which polygons should be selected. Alternatively, a filter function can be provided. default: all visible layers\r\n * \t@param {Array<ol.Feature> | ol.Collection<ol.Feature> | function | undefined} options.featureFilter An array or a collection of features the interaction applies on or a function that takes a feature and a layer and returns true if the feature is a candidate\r\n * \t@param { ol.style.Style | Array<ol.style.Style> | StyleFunction | undefined }\tStyle for the selected features, default: default edit style\r\n * \t@param {function | undefined}\toptions.geometryFunction Draw interaction geometry function to customize the hole\r\n */\r\nvar ol_interaction_DrawHole = class olinteractionDrawHole extends ol_interaction_Draw {\r\n  constructor(options) {\r\n    options = options || {}\r\n    // Geometry function that test points inside the current selection\r\n    var _geometryFn = function(coordinates, geometry) {\r\n      var coord = coordinates[0].pop()\r\n      if (!this.getPolygon() || this.getPolygon().intersectsCoordinate(coord)) {\r\n        this.lastOKCoord = [coord[0], coord[1]]\r\n      }\r\n      coordinates[0].push([this.lastOKCoord[0], this.lastOKCoord[1]])\r\n  \r\n      if (geometry) {\r\n        geometry.setCoordinates([coordinates[0].concat([coordinates[0][0]])])\r\n      } else {\r\n        geometry = new ol_geom_Polygon(coordinates)\r\n      }\r\n      return geometry\r\n    }\r\n    var geomFn = options.geometryFunction\r\n    if (geomFn) {\r\n      options.geometryFunction = function (c, g, p) {\r\n        g = _geometryFn.bind(this)(c, g)\r\n        return geomFn.bind(this)(c, g, p)\r\n      }\r\n    } else {\r\n      options.geometryFunction = _geometryFn\r\n    }\r\n\r\n    // Create draw interaction\r\n    options.type = 'Polygon';\r\n    super(options)\r\n    \r\n    // Select interaction for the current feature\r\n    this._select = new ol_interaction_Select({ style: options.style })\r\n    this._select.setActive(false)\r\n\r\n    // Layer filter function\r\n    if (options.layers) {\r\n      if (typeof (options.layers) === 'function') {\r\n        this.layers_ = options.layers\r\n      } else if (options.layers.indexOf) {\r\n        this.layers_ = function (l) {\r\n          return (options.layers.indexOf(l) >= 0)\r\n        }\r\n      }\r\n    }\r\n\r\n    // Features to apply on \r\n    if (typeof (options.featureFilter) === 'function') {\r\n      this._features = options.featureFilter\r\n    } else if (options.featureFilter) {\r\n      var features = options.featureFilter\r\n      this._features = function (f) {\r\n        if (features.indexOf) {\r\n          return !!features[features.indexOf(f)]\r\n        } else {\r\n          return !!features.item(features.getArray().indexOf(f))\r\n        }\r\n      }\r\n    } else {\r\n      this._features = function () { return true }\r\n    }\r\n\r\n    // Start drawing if inside a feature\r\n    this.on('drawstart', this._startDrawing.bind(this))\r\n    // End drawing add the hole to the current Polygon\r\n    this.on('drawend', this._finishDrawing.bind(this))\r\n  }\r\n\r\n  /**\r\n   * Remove the interaction from its current map, if any,  and attach it to a new\r\n   * map, if any. Pass `null` to just remove the interaction from the current map.\r\n   * @param {ol.Map} map Map.\r\n   * @api stable\r\n   */\r\n  setMap(map) {\r\n    // Remove previous selection\r\n    if (this.getMap()) this.getMap().removeInteraction(this._select)\r\n    // Add new one\r\n    if (map) map.addInteraction(this._select)\r\n    super.setMap.call(this, map)\r\n  }\r\n  /**\r\n   * Activate/deactivate the interaction\r\n   * @param {boolean}\r\n   * @api stable\r\n   */\r\n  setActive(b) {\r\n    if (this._select) this._select.getFeatures().clear()\r\n    super.setActive.call(this, b)\r\n  }\r\n  /**\r\n   * Remove last point of the feature currently being drawn\r\n   * (test if points to remove before).\r\n   */\r\n  removeLastPoint() {\r\n    if (this._feature && this._feature.getGeometry().getCoordinates()[0].length > 2) {\r\n      super.removeLastPoint.call(this)\r\n    }\r\n  }\r\n  /**\r\n   * Get the current polygon to hole\r\n   * @return {ol.Feature}\r\n   */\r\n  getPolygon() {\r\n    return this._polygon\r\n    // return this._select.getFeatures().item(0).getGeometry();\r\n  }\r\n  /**\r\n   * Get current feature to add a hole and start drawing\r\n   * @param {ol_interaction_Draw.Event} e\r\n   * @private\r\n   */\r\n  _startDrawing(e) {\r\n    var map = this.getMap()\r\n    this._feature = e.feature\r\n    var coord = e.feature.getGeometry().getCoordinates()[0][0]\r\n    this._current = null\r\n    // Check object under the pointer\r\n    map.forEachFeatureAtPixel(\r\n      map.getPixelFromCoordinate(coord),\r\n      function (feature, layer) {\r\n        // Not yet found?\r\n        if (!this._current && this._features(feature, layer)) {\r\n          var poly = feature.getGeometry()\r\n          if (poly.getType() === \"Polygon\"\r\n            && poly.intersectsCoordinate(coord)) {\r\n            this._polygonIndex = false\r\n            this._polygon = poly\r\n            this._current = feature\r\n          } else if (poly.getType() === \"MultiPolygon\"\r\n            && poly.intersectsCoordinate(coord)) {\r\n            for (var i = 0, p; p = poly.getPolygon(i); i++) {\r\n              if (p.intersectsCoordinate(coord)) {\r\n                this._polygonIndex = i\r\n                this._polygon = p\r\n                this._current = feature\r\n                break\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }.bind(this), {\r\n      layerFilter: this.layers_\r\n    }\r\n    )\r\n    this._select.getFeatures().clear()\r\n    if (!this._current) {\r\n      this.setActive(false)\r\n      this.setActive(true)\r\n    } else {\r\n      this._select.getFeatures().push(this._current)\r\n    }\r\n  }\r\n  /**\r\n   * Stop drawing and add the sketch feature to the target feature.\r\n   * @param {ol_interaction_Draw.Event} e\r\n   * @private\r\n   */\r\n  _finishDrawing(e) {\r\n    // The feature is the hole\r\n    e.hole = e.feature\r\n    // Get the current feature\r\n    e.feature = this._select.getFeatures().item(0)\r\n    this.dispatchEvent({ type: 'modifystart', features: [this._current] })\r\n    // Create the hole\r\n    var c = e.hole.getGeometry().getCoordinates()[0]\r\n    if (c.length > 3) {\r\n      if (this._polygonIndex !== false) {\r\n        var geom = e.feature.getGeometry()\r\n        var newGeom = new ol_geom_MultiPolygon([])\r\n        for (var i = 0, pi; pi = geom.getPolygon(i); i++) {\r\n          if (i === this._polygonIndex) {\r\n            pi.appendLinearRing(new ol_geom_LinearRing(c))\r\n            newGeom.appendPolygon(pi)\r\n          } else {\r\n            newGeom.appendPolygon(pi)\r\n          }\r\n        }\r\n        e.feature.setGeometry(newGeom)\r\n      } else {\r\n        this.getPolygon().appendLinearRing(new ol_geom_LinearRing(c))\r\n      }\r\n    }\r\n    this.dispatchEvent({ type: 'modifyend', features: [this._current] })\r\n    // reset\r\n    this._feature = null\r\n    this._select.getFeatures().clear()\r\n  }\r\n  /**\r\n   * Function that is called when a geometry's coordinates are updated.\r\n   * @param {Array<ol.coordinate>} coordinates\r\n   * @param {ol_geom_Polygon} geometry\r\n   * @return {ol_geom_Polygon}\r\n   * @private\r\n   */\r\n  _geometryFn(coordinates, geometry) {\r\n    var coord = coordinates[0].pop()\r\n    if (!this.getPolygon() || this.getPolygon().intersectsCoordinate(coord)) {\r\n      this.lastOKCoord = [coord[0], coord[1]]\r\n    }\r\n    coordinates[0].push([this.lastOKCoord[0], this.lastOKCoord[1]])\r\n\r\n    if (geometry) {\r\n      geometry.setCoordinates([coordinates[0].concat([coordinates[0][0]])])\r\n    } else {\r\n      geometry = new ol_geom_Polygon(coordinates)\r\n    }\r\n    return geometry\r\n  }\r\n}\r\n\r\nexport default ol_interaction_DrawHole\r\n","/*\tCopyright (c) 2016 Jean-Marc VIGLINO, \r\n  released under the CeCILL-B license (French BSD license)\r\n  (http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).\r\n*/\r\n\r\nimport ol_interaction_Interaction from 'ol/interaction/Interaction.js'\r\nimport ol_style_Style_defaultStyle from '../style/defaultStyle.js'\r\nimport ol_Collection from 'ol/Collection.js'\r\nimport ol_layer_Vector from 'ol/layer/Vector.js'\r\nimport ol_source_Vector from 'ol/source/Vector.js'\r\nimport ol_geom_Circle from 'ol/geom/Circle.js'\r\nimport {fromCircle as ol_geom_Polygon_fromCircle} from 'ol/geom/Polygon.js'\r\nimport ol_geom_Point from 'ol/geom/Point.js'\r\nimport ol_geom_LineString from 'ol/geom/LineString.js'\r\nimport ol_geom_Polygon from 'ol/geom/Polygon.js'\r\nimport ol_Feature from 'ol/Feature.js'\r\n\r\n/** Interaction rotate\r\n * @constructor\r\n * @extends {ol_interaction_Interaction}\r\n * @fires drawstart, drawing, drawend, drawcancel\r\n * @param {olx.interaction.TransformOptions} options\r\n *  @param {Array<ol.Layer>} options.source Destination source for the drawn features\r\n *  @param {ol.Collection<ol.Feature>} options.features Destination collection for the drawn features \r\n *  @param {ol.style.Style | Array.<ol.style.Style> | ol.style.StyleFunction | undefined} options.style style for the sketch\r\n *  @param {integer} options.sides number of sides, default 0 = circle\r\n *  @param { ol.events.ConditionType | undefined } options.condition A function that takes an ol.MapBrowserEvent and returns a boolean that event should be handled. By default module:ol/events/condition.always.\r\n *  @param { ol.events.ConditionType | undefined } options.squareCondition A function that takes an ol.MapBrowserEvent and returns a boolean to draw square features. Default test shift key\r\n *  @param { ol.events.ConditionType | undefined } options.centerCondition A function that takes an ol.MapBrowserEvent and returns a boolean to draw centered features. Default check Ctrl key\r\n *  @param { bool } options.canRotate Allow rotation when centered + square, default: true\r\n *  @param { string } [options.geometryName=geometry] \r\n *  @param { number } options.clickTolerance click tolerance on touch devices, default: 6\r\n *  @param { number } options.maxCircleCoordinates Maximum number of point on a circle, default: 100\r\n */\r\nvar ol_interaction_DrawRegular = class olinteractionDrawRegular extends ol_interaction_Interaction {\r\n  constructor(options) {\r\n    options = options || {}\r\n    \r\n    super({\r\n      handleEvent: function(e) { return self.handleEvent_(e) }\r\n    })\r\n\r\n    var self = this;\r\n\r\n    this.squaredClickTolerance_ = options.clickTolerance ? options.clickTolerance * options.clickTolerance : 36\r\n    this.maxCircleCoordinates_ = options.maxCircleCoordinates || 100\r\n\r\n    // Collection of feature to transform \r\n    this.features_ = options.features\r\n    // List of layers to transform \r\n    this.source_ = options.source\r\n    // Square condition\r\n    this.conditionFn_ = options.condition\r\n    // Square condition\r\n    this.squareFn_ = options.squareCondition\r\n    // Centered condition\r\n    this.centeredFn_ = options.centerCondition\r\n    // Allow rotation when centered + square\r\n    this.canRotate_ = (options.canRotate !== false)\r\n    // Specify custom geometry name\r\n    this.geometryName_ = options.geometryName || 'geometry'\r\n\r\n    // Number of sides (default=0: circle)\r\n    this.setSides(options.sides)\r\n\r\n    // Style\r\n    var defaultStyle = ol_style_Style_defaultStyle(true)\r\n\r\n    // Create a new overlay layer for the sketch\r\n    this.sketch_ = new ol_Collection()\r\n    this.overlayLayer_ = new ol_layer_Vector({\r\n      source: new ol_source_Vector({\r\n        features: this.sketch_,\r\n        useSpatialIndex: false\r\n      }),\r\n      name: 'DrawRegular overlay',\r\n      displayInLayerSwitcher: false,\r\n      style: options.style || defaultStyle\r\n    })\r\n  }\r\n  /**\r\n   * Remove the interaction from its current map, if any,  and attach it to a new\r\n   * map, if any. Pass `null` to just remove the interaction from the current map.\r\n   * @param {ol.Map} map Map.\r\n   * @api stable\r\n   */\r\n  setMap(map) {\r\n    if (this.getMap()) this.getMap().removeLayer(this.overlayLayer_)\r\n    super.setMap(map)\r\n    this.overlayLayer_.setMap(map)\r\n  }\r\n  /**\r\n   * Activate/deactivate the interaction\r\n   * @param {boolean}\r\n   * @api stable\r\n   */\r\n  setActive(b) {\r\n    this.reset()\r\n    super.setActive(b)\r\n  }\r\n  /**\r\n   * Reset the interaction\r\n   * @api stable\r\n   */\r\n  reset() {\r\n    if (this.overlayLayer_) this.overlayLayer_.getSource().clear()\r\n    this.started_ = false\r\n  }\r\n  /**\r\n   * Set the number of sides.\r\n   * @param {int} number of sides.\r\n   * @api stable\r\n   */\r\n  setSides(nb) {\r\n    nb = parseInt(nb)\r\n    this.sides_ = nb > 2 ? nb : 0\r\n  }\r\n  /**\r\n   * Allow rotation when centered + square\r\n   * @param {bool}\r\n   * @api stable\r\n   */\r\n  canRotate(b) {\r\n    if (b === true || b === false)\r\n      this.canRotate_ = b\r\n    return this.canRotate_\r\n  }\r\n  /**\r\n   * Get the number of sides.\r\n   * @return {int} number of sides.\r\n   * @api stable\r\n   */\r\n  getSides() {\r\n    return this.sides_\r\n  }\r\n  /** Get geom of the current drawing\r\n  * @return {ol.geom.Polygon | ol.geom.Point}\r\n  */\r\n  getGeom_() {\r\n    this.overlayLayer_.getSource().clear()\r\n    if (!this.center_)\r\n      return false\r\n\r\n    var g\r\n    if (this.coord_) {\r\n      var center = this.center_\r\n      var coord = this.coord_\r\n\r\n      // Specific case: circle\r\n      var d, dmax, r, circle, centerPx\r\n      if (!this.sides_ && this.square_ && !this.centered_) {\r\n        center = [(coord[0] + center[0]) / 2, (coord[1] + center[1]) / 2]\r\n        d = [coord[0] - center[0], coord[1] - center[1]]\r\n        r = Math.sqrt(d[0] * d[0] + d[1] * d[1])\r\n        circle = new ol_geom_Circle(center, r, 'XY')\r\n        // Optimize points on the circle\r\n        centerPx = this.getMap().getPixelFromCoordinate(center)\r\n        dmax = Math.max(100, Math.abs(centerPx[0] - this.coordPx_[0]), Math.abs(centerPx[1] - this.coordPx_[1]))\r\n        dmax = Math.min(this.maxCircleCoordinates_, Math.round(dmax / 3))\r\n        return ol_geom_Polygon_fromCircle(circle, dmax, 0)\r\n      } else {\r\n        var hasrotation = this.canRotate_ && this.centered_ && this.square_\r\n        d = [coord[0] - center[0], coord[1] - center[1]]\r\n        if (this.square_ && !hasrotation) {\r\n          //var d = [coord[0] - center[0], coord[1] - center[1]];\r\n          var dm = Math.max(Math.abs(d[0]), Math.abs(d[1]))\r\n          coord = [\r\n            center[0] + (d[0] > 0 ? dm : -dm),\r\n            center[1] + (d[1] > 0 ? dm : -dm)\r\n          ]\r\n        }\r\n        r = Math.sqrt(d[0] * d[0] + d[1] * d[1])\r\n        if (r > 0) {\r\n          circle = new ol_geom_Circle(center, r, 'XY')\r\n          var a\r\n          if (hasrotation)\r\n            a = Math.atan2(d[1], d[0])\r\n          else\r\n            a = this.startAngle[this.sides_] || this.startAngle['default']\r\n\r\n          if (this.sides_) {\r\n            g = ol_geom_Polygon_fromCircle(circle, this.sides_, a)\r\n          } else {\r\n            // Optimize points on the circle\r\n            centerPx = this.getMap().getPixelFromCoordinate(this.center_)\r\n            dmax = Math.max(100, Math.abs(centerPx[0] - this.coordPx_[0]), Math.abs(centerPx[1] - this.coordPx_[1]))\r\n            dmax = Math.min(this.maxCircleCoordinates_, Math.round(dmax / (this.centered_ ? 3 : 5)))\r\n            g = ol_geom_Polygon_fromCircle(circle, dmax, 0)\r\n          }\r\n\r\n          if (hasrotation)\r\n            return g\r\n\r\n          // Scale polygon to fit extent\r\n          var ext = g.getExtent()\r\n          if (!this.centered_)\r\n            center = this.center_\r\n          else\r\n            center = [2 * this.center_[0] - this.coord_[0], 2 * this.center_[1] - this.coord_[1]]\r\n          var scx = (center[0] - coord[0]) / (ext[0] - ext[2])\r\n          var scy = (center[1] - coord[1]) / (ext[1] - ext[3])\r\n          if (this.square_) {\r\n            var sc = Math.min(Math.abs(scx), Math.abs(scy))\r\n            scx = Math.sign(scx) * sc\r\n            scy = Math.sign(scy) * sc\r\n          }\r\n          var t = [center[0] - ext[0] * scx, center[1] - ext[1] * scy]\r\n\r\n          g.applyTransform(function (g1, g2, dim) {\r\n            for (var i = 0; i < g1.length; i += dim) {\r\n              g2[i] = g1[i] * scx + t[0]\r\n              g2[i + 1] = g1[i + 1] * scy + t[1]\r\n            }\r\n            return g2\r\n          })\r\n          return g\r\n        }\r\n      }\r\n    }\r\n\r\n    // No geom => return a point\r\n    return new ol_geom_Point(this.center_)\r\n  }\r\n  /** Draw sketch\r\n  * @return {ol.Feature} The feature being drawn.\r\n  */\r\n  drawSketch_(evt) {\r\n    this.overlayLayer_.getSource().clear()\r\n    if (evt) {\r\n      this.square_ = this.squareFn_ ? this.squareFn_(evt) : evt.originalEvent.shiftKey\r\n      this.centered_ = this.centeredFn_ ? this.centeredFn_(evt) : evt.originalEvent.metaKey || evt.originalEvent.ctrlKey\r\n      var g = this.getGeom_()\r\n      if (g) {\r\n        var f = this.feature_\r\n\r\n        //f.setGeometry (g);\r\n        if (g.getType() === 'Polygon')\r\n          f.getGeometry().setCoordinates(g.getCoordinates())\r\n        this.overlayLayer_.getSource().addFeature(f)\r\n        if (this.coord_\r\n          && this.square_\r\n          && ((this.canRotate_ && this.centered_ && this.coord_) || (!this.sides_ && !this.centered_))) {\r\n          this.overlayLayer_.getSource().addFeature(new ol_Feature(new ol_geom_LineString([this.center_, this.coord_])))\r\n        }\r\n        return f\r\n      }\r\n    }\r\n  }\r\n  /** Draw sketch (Point)\r\n  */\r\n  drawPoint_(pt, noclear) {\r\n    if (!noclear)\r\n      this.overlayLayer_.getSource().clear()\r\n    this.overlayLayer_.getSource().addFeature(new ol_Feature(new ol_geom_Point(pt)))\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} evt Map browser event.\r\n   */\r\n  handleEvent_(evt) {\r\n    var dx, dy\r\n    // Event date time\r\n    this._eventTime = new Date()\r\n    switch (evt.type) {\r\n      case \"pointerdown\": {\r\n        if (this.conditionFn_ && !this.conditionFn_(evt))\r\n          break\r\n        this.downPx_ = evt.pixel\r\n        this.start_(evt)\r\n        // Test long touch\r\n        var dt = 500\r\n        this._longTouch = false\r\n        setTimeout(function () {\r\n          this._longTouch = (new Date() - this._eventTime > .9 * dt)\r\n          if (this._longTouch)\r\n            this.handleMoveEvent_(evt)\r\n        }.bind(this), dt)\r\n        break\r\n      }\r\n      case \"pointerup\": {\r\n        // Started and fisrt move\r\n        if (this.started_ && this.coord_) {\r\n          dx = this.downPx_[0] - evt.pixel[0]\r\n          dy = this.downPx_[1] - evt.pixel[1]\r\n          if (dx * dx + dy * dy <= this.squaredClickTolerance_) {\r\n            // The pointer has moved\r\n            if (this.lastEvent == \"pointermove\" || this.lastEvent == \"keydown\") {\r\n              this.end_(evt)\r\n            }\r\n\r\n            // On touch device there is no move event : terminate = click on the same point\r\n            else {\r\n              dx = this.upPx_[0] - evt.pixel[0]\r\n              dy = this.upPx_[1] - evt.pixel[1]\r\n              if (dx * dx + dy * dy <= this.squaredClickTolerance_) {\r\n                this.end_(evt)\r\n              } else {\r\n                this.handleMoveEvent_(evt)\r\n                this.drawPoint_(evt.coordinate, true)\r\n              }\r\n            }\r\n          }\r\n        }\r\n        this.upPx_ = evt.pixel\r\n        break\r\n      }\r\n      case \"pointerdrag\": {\r\n        if (this.started_) {\r\n          var centerPx = this.getMap().getPixelFromCoordinate(this.center_)\r\n          dx = centerPx[0] - evt.pixel[0]\r\n          dy = centerPx[1] - evt.pixel[1]\r\n          if (dx * dx + dy * dy <= this.squaredClickTolerance_) {\r\n            this.reset()\r\n          }\r\n        }\r\n        return !this._longTouch\r\n        // break;\r\n      }\r\n      case \"pointermove\": {\r\n        if (this.started_) {\r\n          dx = this.downPx_[0] - evt.pixel[0]\r\n          dy = this.downPx_[1] - evt.pixel[1]\r\n          if (dx * dx + dy * dy > this.squaredClickTolerance_) {\r\n            this.handleMoveEvent_(evt)\r\n            this.lastEvent = evt.type\r\n          }\r\n        }\r\n        break\r\n      }\r\n      default: {\r\n        this.lastEvent = evt.type\r\n        // Prevent zoom in on dblclick\r\n        if (this.started_ && evt.type === 'dblclick') {\r\n          //evt.stopPropagation();\r\n          return false\r\n        }\r\n        break\r\n      }\r\n    }\r\n    return true\r\n  }\r\n  /** Stop drawing.\r\n   */\r\n  finishDrawing() {\r\n    if (this.started_ && this.coord_) {\r\n      this.end_({ pixel: this.upPx_, coordinate: this.coord_ })\r\n    }\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} evt Event.\r\n   */\r\n  handleMoveEvent_(evt) {\r\n    if (this.started_) {\r\n      this.coord_ = evt.coordinate\r\n      this.coordPx_ = evt.pixel\r\n      var f = this.drawSketch_(evt)\r\n      this.dispatchEvent({\r\n        type: 'drawing',\r\n        feature: f,\r\n        pixel: evt.pixel,\r\n        startCoordinate: this.center_,\r\n        coordinate: evt.coordinate,\r\n        square: this.square_,\r\n        centered: this.centered_\r\n      })\r\n    } else {\r\n      this.drawPoint_(evt.coordinate)\r\n    }\r\n  }\r\n  /** Start an new draw\r\n   * @param {ol.MapBrowserEvent} evt Map browser event.\r\n   * @return {boolean} `false` to stop the drag sequence.\r\n   */\r\n  start_(evt) {\r\n    if (!this.started_) {\r\n      this.started_ = true\r\n      this.center_ = evt.coordinate\r\n      this.coord_ = null\r\n      var f = this.feature_ = new ol_Feature({})\r\n      f.setGeometryName(this.geometryName_ || 'geometry')\r\n      f.setGeometry(new ol_geom_Polygon([[evt.coordinate, evt.coordinate, evt.coordinate]]))\r\n      this.drawSketch_(evt)\r\n      this.dispatchEvent({ type: 'drawstart', feature: f, pixel: evt.pixel, coordinate: evt.coordinate })\r\n    } else {\r\n      this.coord_ = evt.coordinate\r\n    }\r\n  }\r\n  /** End drawing\r\n   * @param {ol.MapBrowserEvent} evt Map browser event.\r\n   * @return {boolean} `false` to stop the drag sequence.\r\n   */\r\n  end_(evt) {\r\n    this.coord_ = evt.coordinate\r\n    this.started_ = false\r\n    if (this.coord_ && (this.center_[0] !== this.coord_[0] || this.center_[1] !== this.coord_[1])) {\r\n      var f = this.feature_\r\n\r\n      f.setGeometry(this.getGeom_())\r\n      if (this.source_)\r\n        this.source_.addFeature(f)\r\n      else if (this.features_)\r\n        this.features_.push(f)\r\n      this.dispatchEvent({ type: 'drawend', feature: f, pixel: evt.pixel, coordinate: evt.coordinate, square: this.square_, centered: this.centered_ })\r\n    } else {\r\n      this.dispatchEvent({ type: 'drawcancel', feature: null, pixel: evt.pixel, coordinate: evt.coordinate, square: this.square_, centered: this.centered_ })\r\n    }\r\n\r\n    this.center_ = this.coord_ = null\r\n    this.drawSketch_()\r\n  }\r\n}\r\n\r\n/** Default start angle array for each sides\r\n*/\r\nol_interaction_DrawRegular.prototype.startAngle = {\r\n  'default':Math.PI/2,\r\n  3: -Math.PI/2,\r\n  4: Math.PI/4\r\n};\r\n\r\nexport default ol_interaction_DrawRegular\r\n","/*\tCopyright (c) 2016 Jean-Marc VIGLINO, \r\n  released under the CeCILL-B license (French BSD license)\r\n  (http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).\r\n*/\r\n\r\nimport ol_style_Style from 'ol/style/Style.js'\r\nimport ol_style_Stroke from 'ol/style/Stroke.js'\r\nimport ol_source_Vector from 'ol/source/Vector.js'\r\nimport ol_style_Fill from 'ol/style/Fill.js'\r\nimport ol_style_Circle from 'ol/style/Circle.js'\r\nimport ol_layer_Vector from 'ol/layer/Vector.js'\r\nimport ol_geom_Point from 'ol/geom/Point.js'\r\nimport ol_Feature from 'ol/Feature.js'\r\nimport ol_geom_LineString from 'ol/geom/LineString.js'\r\nimport ol_interaction_Interaction from 'ol/interaction/Interaction.js'\r\nimport {ol_coordinate_dist2d, ol_coordinate_equal} from \"../geom/GeomUtils.js\";\r\nimport {boundingExtent as ol_extent_boundingExtent} from 'ol/extent.js'\r\nimport {buffer as ol_extent_buffer} from 'ol/extent.js'\r\nimport {altKeyOnly as ol_events_condition_altKeyOnly} from 'ol/events/condition.js'\r\nimport {primaryAction as ol_events_condition_primaryAction} from 'ol/events/condition.js'\r\nimport {always as ol_events_condition_always} from 'ol/events/condition.js'\r\n\r\nimport '../geom/LineStringSplitAt.js'\r\n\r\n/** Interaction for modifying feature geometries. Similar to the core ol/interaction/Modify.\r\n * The interaction is more suitable to use to handle feature modification: only features concerned \r\n * by the modification are passed to the events (instead of all feature with ol/interaction/Modify)\r\n * - the modifystart event is fired before the feature is modified (no points still inserted)\r\n * - the modifyend event is fired after the modification\r\n * - it fires a modifying event\r\n * @constructor\r\n * @extends {ol_interaction_Interaction}\r\n * @fires modifystart\r\n * @fires modifying\r\n * @fires modifyend\r\n * @fires select\r\n * @param {*} options\r\n *\t@param {ol.source.Vector} options.source a source to modify (configured with useSpatialIndex set to true)\r\n *\t@param {ol.source.Vector|Array<ol.source.Vector>} options.sources a list of source to modify (configured with useSpatialIndex set to true)\r\n *  @param {ol.Collection.<ol.Feature>} options.features collection of feature to modify\r\n *  @param {integer} options.pixelTolerance Pixel tolerance for considering the pointer close enough to a segment or vertex for editing. Default is 10.\r\n *  @param {function|undefined} options.filter a filter that takes a feature and return true if it can be modified, default always true.\r\n *  @param {ol.style.Style | Array<ol.style.Style> | undefined} options.style Style for the sketch features.\r\n *  @param {ol.EventsConditionType | undefined} options.condition A function that takes an ol.MapBrowserEvent and returns a boolean to indicate whether that event will be considered to add or move a vertex to the sketch. Default is ol.events.condition.primaryAction.\r\n *  @param {ol.EventsConditionType | undefined} options.deleteCondition A function that takes an ol.MapBrowserEvent and returns a boolean to indicate whether that event should be handled. By default, ol.events.condition.singleClick with ol.events.condition.altKeyOnly results in a vertex deletion.\r\n *  @param {ol.EventsConditionType | undefined} options.insertVertexCondition A function that takes an ol.MapBrowserEvent and returns a boolean to indicate whether a new vertex can be added to the sketch features. Default is ol.events.condition.always\r\n *  @param {boolean} options.wrapX Wrap the world horizontally on the sketch overlay, default false\r\n */\r\nvar ol_interaction_ModifyFeature = class olinteractionModifyFeature extends ol_interaction_Interaction {\r\n  constructor(options) {\r\n    options = options || {}\r\n\r\n    var dragging, modifying\r\n    super({\r\n      handleEvent: function (e) {\r\n        switch (e.type) {\r\n          case 'pointerdown': {\r\n            dragging = this.handleDownEvent(e)\r\n            modifying = dragging || this._deleteCondition(e)\r\n            return !dragging\r\n          }\r\n          case 'pointerup': {\r\n            dragging = false\r\n            return this.handleUpEvent(e)\r\n          }\r\n          case 'pointerdrag': {\r\n            if (dragging)\r\n              return this.handleDragEvent(e)\r\n            else\r\n              return true\r\n          }\r\n          case 'pointermove': {\r\n            if (!dragging){\r\n              return this.handleMoveEvent(e)\r\n            } else {\r\n              return false\r\n            }\r\n          }\r\n          case 'singleclick':\r\n          case 'click': {\r\n            // Prevent click when modifying\r\n            return !modifying\r\n          }\r\n          default: return true\r\n        }\r\n      }\r\n    })\r\n\r\n    // Snap distance (in px)\r\n    this.snapDistance_ = options.pixelTolerance || 10\r\n    // Split tolerance between the calculated intersection and the geometry\r\n    this.tolerance_ = 1e-10\r\n    // Cursor\r\n    this.cursor_ = options.cursor\r\n\r\n    // List of source to split\r\n    this.sources_ = options.sources ? (options.sources instanceof Array) ? options.sources : [options.sources] : []\r\n    if (options.source) {\r\n      this.sources_.push(options.source)\r\n    }\r\n    if (options.features) {\r\n      this.sources_.push(new ol_source_Vector({ features: options.features }))\r\n    }\r\n    // Get all features candidate\r\n    this.filterSplit_ = options.filter || function () { return true }\r\n\r\n    this._condition = options.condition || ol_events_condition_primaryAction\r\n    this._deleteCondition = options.deleteCondition || ol_events_condition_altKeyOnly\r\n    this._insertVertexCondition = options.insertVertexCondition || ol_events_condition_always\r\n\r\n    // Default style\r\n    var sketchStyle = function () {\r\n      return [new ol_style_Style({\r\n        image: new ol_style_Circle({\r\n          radius: 6,\r\n          fill: new ol_style_Fill({ color: [0, 153, 255, 1] }),\r\n          stroke: new ol_style_Stroke({ color: '#FFF', width: 1.25 })\r\n        })\r\n      })\r\n      ]\r\n    }\r\n\r\n    // Custom style\r\n    if (options.style) {\r\n      if (typeof (options.style) === 'function') {\r\n        sketchStyle = options.style\r\n      } else {\r\n        sketchStyle = function () { return options.style }\r\n      }\r\n    }\r\n\r\n    // Create a new overlay for the sketch\r\n    this.overlayLayer_ = new ol_layer_Vector({\r\n      source: new ol_source_Vector({\r\n        useSpatialIndex: false\r\n      }),\r\n      name: 'Modify overlay',\r\n      displayInLayerSwitcher: false,\r\n      style: sketchStyle,\r\n      wrapX: options.wrapX\r\n    })\r\n\r\n  }\r\n  /**\r\n   * Remove the interaction from its current map, if any,  and attach it to a new\r\n   * map, if any. Pass `null` to just remove the interaction from the current map.\r\n   * @param {ol.Map} map Map.\r\n   * @api stable\r\n   */\r\n  setMap(map) {\r\n    if (this.getMap()) this.getMap().removeLayer(this.overlayLayer_)\r\n    super.setMap(map)\r\n    this.overlayLayer_.setMap(map)\r\n  }\r\n  /**\r\n   * Activate or deactivate the interaction + remove the sketch.\r\n   * @param {boolean} active.\r\n   * @api stable\r\n   */\r\n  setActive(active) {\r\n    super.setActive(active)\r\n    if (this.overlayLayer_) this.overlayLayer_.getSource().clear()\r\n  }\r\n  /** Change the filter function\r\n   * @param {function|undefined} options.filter a filter that takes a feature and return true if it can be modified, default always true.\r\n   */\r\n  setFilter(filter) {\r\n    if (typeof (filter) === 'function')\r\n      this.filterSplit_ = filter\r\n    else if (filter === undefined)\r\n      this.filterSplit_ = function () { return true }\r\n  }\r\n  /** Get closest feature at pixel\r\n   * @param {ol.Pixel}\r\n   * @return {*}\r\n   * @private\r\n   */\r\n  getClosestFeature(e) {\r\n    var f, c, d = this.snapDistance_ + 1\r\n    for (var i = 0; i < this.sources_.length; i++) {\r\n      var source = this.sources_[i]\r\n      f = source.getClosestFeatureToCoordinate(e.coordinate)\r\n      if (f && this.filterSplit_(f)) {\r\n        var ci = f.getGeometry().getClosestPoint(e.coordinate)\r\n        var di = ol_coordinate_dist2d(e.coordinate, ci) / e.frameState.viewState.resolution\r\n        if (di < d) {\r\n          d = di\r\n          c = ci\r\n        }\r\n        break\r\n      }\r\n    }\r\n    if (d > this.snapDistance_) {\r\n      if (this.currentFeature)\r\n        this.dispatchEvent({ type: 'select', selected: [], deselected: [this.currentFeature] })\r\n      this.currentFeature = null\r\n      return false\r\n    } else {\r\n      // Snap to node\r\n      var coord = this.getNearestCoord(c, f.getGeometry())\r\n      if (coord) {\r\n        coord = coord.coord\r\n        var p = this.getMap().getPixelFromCoordinate(coord)\r\n        if (ol_coordinate_dist2d(e.pixel, p) < this.snapDistance_) {\r\n          c = coord\r\n        }\r\n        //\r\n        if (this.currentFeature !== f)\r\n          this.dispatchEvent({ type: 'select', selected: [f], deselected: [this.currentFeature] })\r\n        this.currentFeature = f\r\n        return { source: source, feature: f, coord: c }\r\n      }\r\n    }\r\n  }\r\n  /** Get nearest coordinate in a list\r\n  * @param {ol.coordinate} pt the point to find nearest\r\n  * @param {ol.geom} coords list of coordinates\r\n  * @return {*} the nearest point with a coord (projected point), dist (distance to the geom), ring (if Polygon)\r\n  */\r\n  getNearestCoord(pt, geom) {\r\n    var i, l, p, p0, dm\r\n    switch (geom.getType()) {\r\n      case 'Point': {\r\n        return { coord: geom.getCoordinates(), dist: ol_coordinate_dist2d(geom.getCoordinates(), pt) }\r\n      }\r\n      case 'MultiPoint': {\r\n        return this.getNearestCoord(pt, new ol_geom_LineString(geom.getCoordinates()))\r\n      }\r\n      case 'LineString':\r\n      case 'LinearRing': {\r\n        var d\r\n        dm = Number.MAX_VALUE\r\n        var coords = geom.getCoordinates()\r\n        for (i = 0; i < coords.length; i++) {\r\n          d = ol_coordinate_dist2d(pt, coords[i])\r\n          if (d < dm) {\r\n            dm = d\r\n            p0 = coords[i]\r\n          }\r\n        }\r\n        return { coord: p0, dist: dm }\r\n      }\r\n      case 'MultiLineString': {\r\n        var lstring = geom.getLineStrings()\r\n        p0 = false, dm = Number.MAX_VALUE\r\n        for (i = 0; l = lstring[i]; i++) {\r\n          p = this.getNearestCoord(pt, l)\r\n          if (p && p.dist < dm) {\r\n            p0 = p\r\n            dm = p.dist\r\n            p0.ring = i\r\n          }\r\n        }\r\n        return p0\r\n      }\r\n      case 'Polygon': {\r\n        var lring = geom.getLinearRings()\r\n        p0 = false\r\n        dm = Number.MAX_VALUE\r\n        for (i = 0; l = lring[i]; i++) {\r\n          p = this.getNearestCoord(pt, l)\r\n          if (p && p.dist < dm) {\r\n            p0 = p\r\n            dm = p.dist\r\n            p0.ring = i\r\n          }\r\n        }\r\n        return p0\r\n      }\r\n      case 'MultiPolygon': {\r\n        var poly = geom.getPolygons()\r\n        p0 = false\r\n        dm = Number.MAX_VALUE\r\n        for (i = 0; l = poly[i]; i++) {\r\n          p = this.getNearestCoord(pt, l)\r\n          if (p && p.dist < dm) {\r\n            p0 = p\r\n            dm = p.dist\r\n            p0.poly = i\r\n          }\r\n        }\r\n        return p0\r\n      }\r\n      case 'GeometryCollection': {\r\n        var g = geom.getGeometries()\r\n        p0 = false\r\n        dm = Number.MAX_VALUE\r\n        for (i = 0; l = g[i]; i++) {\r\n          p = this.getNearestCoord(pt, l)\r\n          if (p && p.dist < dm) {\r\n            p0 = p\r\n            dm = p.dist\r\n            p0.geom = i\r\n          }\r\n        }\r\n        return p0\r\n      }\r\n      default: return false\r\n    }\r\n  }\r\n  /** Get arcs concerned by a modification\r\n   * @param {ol.geom} geom the geometry concerned\r\n   * @param {ol.coordinate} coord pointed coordinates\r\n   */\r\n  getArcs(geom, coord) {\r\n    var arcs = false\r\n    var coords, i, s, l, g\r\n    switch (geom.getType()) {\r\n      case 'Point': {\r\n        if (ol_coordinate_equal(coord, geom.getCoordinates())) {\r\n          arcs = {\r\n            geom: geom,\r\n            type: geom.getType(),\r\n            coord1: [],\r\n            coord2: [],\r\n            node: true\r\n          }\r\n        }\r\n        break\r\n      }\r\n      case 'MultiPoint': {\r\n        coords = geom.getCoordinates()\r\n        for (i = 0; i < coords.length; i++) {\r\n          if (ol_coordinate_equal(coord, coords[i])) {\r\n            arcs = {\r\n              geom: geom,\r\n              type: geom.getType(),\r\n              index: i,\r\n              coord1: [],\r\n              coord2: [],\r\n              node: true\r\n            }\r\n            break\r\n          }\r\n        }\r\n        break\r\n      }\r\n      case 'LinearRing':\r\n      case 'LineString': {\r\n        var p = geom.getClosestPoint(coord)\r\n        if (ol_coordinate_dist2d(p, coord) < 1.5 * this.tolerance_) {\r\n          var split\r\n          // Split the line in two\r\n          if (geom.getType() === 'LinearRing') {\r\n            g = new ol_geom_LineString(geom.getCoordinates())\r\n            split = g.splitAt(coord, this.tolerance_)\r\n          } else {\r\n            split = geom.splitAt(coord, this.tolerance_)\r\n          }\r\n          // If more than 2\r\n          if (split.length > 2) {\r\n            coords = split[1].getCoordinates()\r\n            for (i = 2; s = split[i]; i++) {\r\n              var c = s.getCoordinates()\r\n              c.shift()\r\n              coords = coords.concat(c)\r\n            }\r\n            split = [split[0], new ol_geom_LineString(coords)]\r\n          }\r\n          // Split in two\r\n          if (split.length === 2) {\r\n            var c0 = split[0].getCoordinates()\r\n            var c1 = split[1].getCoordinates()\r\n            var nbpt = c0.length + c1.length - 1\r\n            c0.pop()\r\n            c1.shift()\r\n            arcs = {\r\n              geom: geom,\r\n              type: geom.getType(),\r\n              coord1: c0,\r\n              coord2: c1,\r\n              node: (geom.getCoordinates().length === nbpt),\r\n              closed: false\r\n            }\r\n          } else if (split.length === 1) {\r\n            s = split[0].getCoordinates()\r\n            var start = ol_coordinate_equal(s[0], coord)\r\n            var end = ol_coordinate_equal(s[s.length - 1], coord)\r\n            // Move first point\r\n            if (start) {\r\n              s.shift()\r\n              if (end)\r\n                s.pop()\r\n              arcs = {\r\n                geom: geom,\r\n                type: geom.getType(),\r\n                coord1: [],\r\n                coord2: s,\r\n                node: true,\r\n                closed: end\r\n              }\r\n            } else if (end) {\r\n              // Move last point\r\n              s.pop()\r\n              arcs = {\r\n                geom: geom,\r\n                type: geom.getType(),\r\n                coord1: s,\r\n                coord2: [],\r\n                node: true,\r\n                closed: false\r\n              }\r\n            }\r\n          }\r\n        }\r\n        break\r\n      }\r\n      case 'MultiLineString': {\r\n        var lstring = geom.getLineStrings()\r\n        for (i = 0; l = lstring[i]; i++) {\r\n          arcs = this.getArcs(l, coord)\r\n          if (arcs) {\r\n            arcs.geom = geom\r\n            arcs.type = geom.getType()\r\n            arcs.lstring = i\r\n            break\r\n          }\r\n        }\r\n        break\r\n      }\r\n      case 'Polygon': {\r\n        var lring = geom.getLinearRings()\r\n        for (i = 0; l = lring[i]; i++) {\r\n          arcs = this.getArcs(l, coord)\r\n          if (arcs) {\r\n            arcs.geom = geom\r\n            arcs.type = geom.getType()\r\n            arcs.index = i\r\n            break\r\n          }\r\n        }\r\n        break\r\n      }\r\n      case 'MultiPolygon': {\r\n        var poly = geom.getPolygons()\r\n        for (i = 0; l = poly[i]; i++) {\r\n          arcs = this.getArcs(l, coord)\r\n          if (arcs) {\r\n            arcs.geom = geom\r\n            arcs.type = geom.getType()\r\n            arcs.poly = i\r\n            break\r\n          }\r\n        }\r\n        break\r\n      }\r\n      case 'GeometryCollection': {\r\n        g = geom.getGeometries()\r\n        for (i = 0; l = g[i]; i++) {\r\n          arcs = this.getArcs(l, coord)\r\n          if (arcs) {\r\n            arcs.geom = geom\r\n            arcs.g = i\r\n            arcs.typeg = arcs.type\r\n            arcs.type = geom.getType()\r\n            break\r\n          }\r\n        }\r\n        break\r\n      }\r\n      default: {\r\n        console.error('ol/interaction/ModifyFeature ' + geom.getType() + ' not supported!')\r\n        break\r\n      }\r\n    }\r\n    return arcs\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} evt Map browser event.\r\n   * @return {boolean} `true` to start the drag sequence.\r\n   */\r\n  handleDownEvent(evt) {\r\n    if (!this.getActive())\r\n      return false\r\n\r\n    // Something to move ?\r\n    var current = this.getClosestFeature(evt)\r\n\r\n    if (current && (this._condition(evt) || this._deleteCondition(evt))) {\r\n      var features = []\r\n      this.arcs = []\r\n\r\n      // Get features concerned\r\n      this.sources_.forEach(function (s) {\r\n        var extent = ol_extent_buffer(ol_extent_boundingExtent([current.coord]), this.tolerance_)\r\n        features = features.concat(features, s.getFeaturesInExtent(extent))\r\n      }.bind(this))\r\n\r\n      // Get arcs concerned\r\n      this._modifiedFeatures = []\r\n      features.forEach(function (f) {\r\n        var a = this.getArcs(f.getGeometry(), current.coord)\r\n        if (a) {\r\n          if (this._insertVertexCondition(evt) || a.node) {\r\n            a.feature = f\r\n            this._modifiedFeatures.push(f)\r\n            this.arcs.push(a)\r\n          }\r\n        }\r\n      }.bind(this))\r\n\r\n      if (this._modifiedFeatures.length) {\r\n        if (this._deleteCondition(evt)) {\r\n          return !this._removePoint(current, evt)\r\n        } else {\r\n          this.dispatchEvent({\r\n            type: 'modifystart',\r\n            coordinate: current.coord,\r\n            originalEvent: evt.originalEvent,\r\n            features: this._modifiedFeatures\r\n          })\r\n          this.handleDragEvent({\r\n            coordinate: current.coord,\r\n            originalEvent: evt.originalEvent\r\n          })\r\n          return true\r\n        }\r\n      } else {\r\n        return true\r\n      }\r\n    } else {\r\n      return false\r\n    }\r\n  }\r\n  /** Get modified features\r\n   * @return {Array<ol.Feature>} list of modified features\r\n   */\r\n  getModifiedFeatures() {\r\n    return this._modifiedFeatures || []\r\n  }\r\n  /** Removes the vertex currently being pointed.\r\n   */\r\n  removePoint() {\r\n    this._removePoint({}, {})\r\n  }\r\n  /**\r\n   * @private\r\n   */\r\n  _getModification(a) {\r\n    var coords = a.coord1.concat(a.coord2)\r\n    switch (a.type) {\r\n      case 'LineString': {\r\n        if (a.closed)\r\n          coords.push(coords[0])\r\n        if (coords.length > 1) {\r\n          if (a.geom.getCoordinates().length != coords.length) {\r\n            a.coords = coords\r\n            return true\r\n          }\r\n        }\r\n        break\r\n      }\r\n      case 'MultiLineString': {\r\n        if (a.closed)\r\n          coords.push(coords[0])\r\n        if (coords.length > 1) {\r\n          var c = a.geom.getCoordinates()\r\n          if (c[a.lstring].length != coords.length) {\r\n            c[a.lstring] = coords\r\n            a.coords = c\r\n            return true\r\n          }\r\n        }\r\n        break\r\n      }\r\n      case 'Polygon': {\r\n        if (a.closed)\r\n          coords.push(coords[0])\r\n        if (coords.length > 3) {\r\n          c = a.geom.getCoordinates()\r\n          if (c[a.index].length != coords.length) {\r\n            c[a.index] = coords\r\n            a.coords = c\r\n            return true\r\n          }\r\n        }\r\n        break\r\n      }\r\n      case 'MultiPolygon': {\r\n        if (a.closed)\r\n          coords.push(coords[0])\r\n        if (coords.length > 3) {\r\n          c = a.geom.getCoordinates()\r\n          if (c[a.poly][a.index].length != coords.length) {\r\n            c[a.poly][a.index] = coords\r\n            a.coords = c\r\n            return true\r\n          }\r\n        }\r\n        break\r\n      }\r\n      case 'GeometryCollection': {\r\n        a.type = a.typeg\r\n        var geom = a.geom\r\n        var geoms = geom.getGeometries()\r\n        a.geom = geoms[a.g]\r\n        var found = this._getModification(a)\r\n        // Restore current arc\r\n        geom.setGeometries(geoms)\r\n        a.geom = geom\r\n        a.type = 'GeometryCollection'\r\n        return found\r\n      }\r\n      default: {\r\n        //console.error('ol/interaction/ModifyFeature '+a.type+' not supported!');\r\n        break\r\n      }\r\n    }\r\n    return false\r\n  }\r\n  /** Removes the vertex currently being pointed.\r\n   * @private\r\n   */\r\n  _removePoint(current, evt) {\r\n    if (!this.arcs)\r\n      return false\r\n\r\n    this.overlayLayer_.getSource().clear()\r\n\r\n    var found = false\r\n    // Get all modifications\r\n    this.arcs.forEach(function (a) {\r\n      found = found || this._getModification(a)\r\n    }.bind(this))\r\n\r\n    // Almost one point is removed\r\n    if (found) {\r\n      this.dispatchEvent({\r\n        type: 'modifystart',\r\n        coordinate: current.coord,\r\n        originalEvent: evt.originalEvent,\r\n        features: this._modifiedFeatures\r\n      })\r\n      this.arcs.forEach(function (a) {\r\n        if (a.geom.getType() === 'GeometryCollection') {\r\n          if (a.coords) {\r\n            var geoms = a.geom.getGeometries()\r\n            geoms[a.g].setCoordinates(a.coords)\r\n            a.geom.setGeometries(geoms)\r\n          }\r\n        } else {\r\n          if (a.coords)\r\n            a.geom.setCoordinates(a.coords)\r\n        }\r\n      }.bind(this))\r\n      this.dispatchEvent({\r\n        type: 'modifyend',\r\n        coordinate: current.coord,\r\n        originalEvent: evt.originalEvent,\r\n        features: this._modifiedFeatures\r\n      })\r\n    }\r\n\r\n    this.arcs = []\r\n    return found\r\n  }\r\n  /**\r\n   * @private\r\n   */\r\n  handleUpEvent(e) {\r\n    if (!this.getActive())\r\n      return false\r\n    if (!this.arcs || !this.arcs.length)\r\n      return true\r\n\r\n    this.overlayLayer_.getSource().clear()\r\n    this.dispatchEvent({\r\n      type: 'modifyend',\r\n      coordinate: e.coordinate,\r\n      originalEvent: e.originalEvent,\r\n      features: this._modifiedFeatures\r\n    })\r\n\r\n    this.arcs = []\r\n    return true\r\n  }\r\n  /**\r\n   * @private\r\n   */\r\n  setArcCoordinates(a, coords) {\r\n    var c\r\n    switch (a.type) {\r\n      case 'Point': {\r\n        a.geom.setCoordinates(coords[0])\r\n        break\r\n      }\r\n      case 'MultiPoint': {\r\n        c = a.geom.getCoordinates()\r\n        c[a.index] = coords[0]\r\n        a.geom.setCoordinates(c)\r\n        break\r\n      }\r\n      case 'LineString': {\r\n        a.geom.setCoordinates(coords)\r\n        break\r\n      }\r\n      case 'MultiLineString': {\r\n        c = a.geom.getCoordinates()\r\n        c[a.lstring] = coords\r\n        a.geom.setCoordinates(c)\r\n        break\r\n      }\r\n      case 'Polygon': {\r\n        c = a.geom.getCoordinates()\r\n        c[a.index] = coords\r\n        a.geom.setCoordinates(c)\r\n        break\r\n      }\r\n      case 'MultiPolygon': {\r\n        c = a.geom.getCoordinates()\r\n        c[a.poly][a.index] = coords\r\n        a.geom.setCoordinates(c)\r\n        break\r\n      }\r\n      case 'GeometryCollection': {\r\n        a.type = a.typeg\r\n        var geom = a.geom\r\n        var geoms = geom.getGeometries()\r\n        a.geom = geoms[a.g]\r\n        this.setArcCoordinates(a, coords)\r\n        geom.setGeometries(geoms)\r\n        a.geom = geom\r\n        a.type = 'GeometryCollection'\r\n        break\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * @private\r\n   */\r\n  handleDragEvent(e) {\r\n    if (!this.getActive()) return false\r\n    if (!this.arcs) return true\r\n\r\n    // Show sketch\r\n    this.overlayLayer_.getSource().clear()\r\n    var p = new ol_Feature(new ol_geom_Point(e.coordinate))\r\n    this.overlayLayer_.getSource().addFeature(p)\r\n\r\n    // Nothing to do\r\n    if (!this.arcs.length) return true\r\n\r\n    // Move arcs\r\n    this.arcs.forEach(function (a) {\r\n      var coords = a.coord1.concat([e.coordinate], a.coord2)\r\n      if (a.closed) coords.push(e.coordinate)\r\n      this.setArcCoordinates(a, coords)\r\n    }.bind(this))\r\n\r\n    this.dispatchEvent({\r\n      type: 'modifying',\r\n      coordinate: e.coordinate,\r\n      originalEvent: e.originalEvent,\r\n      features: this._modifiedFeatures\r\n    })\r\n\r\n    return true\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} evt Event.\r\n   * @private\r\n   */\r\n  handleMoveEvent(e) {\r\n    if (!this.getActive()) return true\r\n\r\n    this.overlayLayer_.getSource().clear()\r\n    var current = this.getClosestFeature(e)\r\n\r\n    // Draw sketch\r\n    if (current) {\r\n      var p = new ol_Feature(new ol_geom_Point(current.coord))\r\n      this.overlayLayer_.getSource().addFeature(p)\r\n    }\r\n\r\n    // Show cursor\r\n    var element = e.map.getTargetElement()\r\n    if (this.cursor_) {\r\n      if (current) {\r\n        if (element.style.cursor != this.cursor_) {\r\n          this.previousCursor_ = element.style.cursor\r\n          element.style.cursor = this.cursor_\r\n        }\r\n      } else if (this.previousCursor_ !== undefined) {\r\n        element.style.cursor = this.previousCursor_\r\n        this.previousCursor_ = undefined\r\n      }\r\n    }\r\n    return true\r\n  }\r\n  /** Get the current feature to modify\r\n   * @return {ol.Feature}\r\n   */\r\n  getCurrentFeature() {\r\n    return this.currentFeature\r\n  }\r\n}\r\n\r\nexport default ol_interaction_ModifyFeature","/*\tCopyright (c) 2016 Jean-Marc VIGLINO, \r\n\treleased under the CeCILL-B license (French BSD license)\r\n\t(http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).\r\n*/\r\nimport ol_interaction_Pointer from 'ol/interaction/Pointer.js'\r\nimport ol_geom_LineString from 'ol/geom/LineString.js'\r\nimport ol_geom_Polygon from 'ol/geom/Polygon.js'\r\nimport {ol_coordinate_dist2d, ol_coordinate_findSegment, ol_coordinate_offsetCoords} from \"../geom/GeomUtils.js\";\r\n\r\nimport ol_style_Style_defaultStyle from '../style/defaultStyle.js'\r\n\r\n/** Offset interaction for offseting feature geometry\r\n * @constructor\r\n * @extends {ol_interaction_Pointer}\r\n * @fires offsetstart\r\n * @fires offsetting\r\n * @fires offsetend\r\n * @param {any} options\r\n *\t@param {function} [options.filter] a function that takes a feature and a layer and return true if the feature can be modified\r\n *\t@param {ol.layer.Vector | Array<ol.layer.Vector>} options.layers list of feature to transform \r\n *\t@param {ol.Collection.<ol.Feature>} options.features collection of feature to transform\r\n *\t@param {ol.source.Vector | undefined} options.source source to duplicate feature when ctrl key is down\r\n *\t@param {boolean} options.duplicate force feature to duplicate (source must be set)\r\n *  @param {ol.style.Style | Array.<ol.style.Style> | ol.style.StyleFunction | undefined} style style for the sketch\r\n */\r\nvar ol_interaction_Offset = class olinteractionOffset extends ol_interaction_Pointer {\r\n  constructor(options) {\r\n    options = options || {};\r\n\r\n    // Extend pointer\r\n    super({\r\n      handleDownEvent: function(e) { return self.handleDownEvent_(e) },\r\n      handleDragEvent: function(e) { return self.handleDragEvent_(e) },\r\n      handleMoveEvent: function(e) { return self.handleMoveEvent_(e) },\r\n      handleUpEvent: function(e) { return self.handleUpEvent_(e) },\r\n    });\r\n    var self = this;\r\n\r\n    this._filter = options.filter;\r\n    // Collection of feature to transform\r\n    this.features_ = options.features;\r\n    // List of layers to transform\r\n    this.layers_ = options.layers ? (options.layers instanceof Array) ? options.layers : [options.layers] : null;\r\n    // duplicate\r\n    this.set('duplicate', options.duplicate);\r\n    this.source_ = options.source;\r\n    // Style\r\n    this._style = (typeof (options.style) === 'function') ? options.style : function () {\r\n      if (options.style)\r\n        return options.style;\r\n      else\r\n        return ol_style_Style_defaultStyle(true);\r\n    };\r\n\r\n    // init\r\n    this.previousCursor_ = false;\r\n  }\r\n  /** Get Feature at pixel\r\n   * @param {ol.MapBrowserEvent} evt Map browser event.\r\n   * @return {any} a feature and the hit point\r\n   * @private\r\n   */\r\n  getFeatureAtPixel_(e) {\r\n    var self = this;\r\n    return this.getMap().forEachFeatureAtPixel(e.pixel,\r\n      function (feature, layer) {\r\n        var current;\r\n        if (self._filter && !self._filter(feature, layer))\r\n          return false;\r\n        // feature belong to a layer\r\n        if (self.layers_) {\r\n          for (var i = 0; i < self.layers_.length; i++) {\r\n            if (self.layers_[i] === layer) {\r\n              current = feature;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n\r\n        // feature in the collection\r\n        else if (self.features_) {\r\n          self.features_.forEach(function (f) {\r\n            if (f === feature) {\r\n              current = feature;\r\n            }\r\n          });\r\n        }\r\n\r\n        // Others\r\n        else {\r\n          current = feature;\r\n        }\r\n\r\n        // Only poygon or linestring\r\n        var typeGeom = current.getGeometry().getType();\r\n        if (current && /Polygon|LineString/.test(typeGeom)) {\r\n          if (typeGeom === 'Polygon' && current.getGeometry().getCoordinates().length > 1)\r\n            return false;\r\n          // test distance\r\n          var p = current.getGeometry().getClosestPoint(e.coordinate);\r\n          var dx = p[0] - e.coordinate[0];\r\n          var dy = p[1] - e.coordinate[1];\r\n          var d = Math.sqrt(dx * dx + dy * dy) / e.frameState.viewState.resolution;\r\n\r\n          if (d < 5) {\r\n            return {\r\n              feature: current,\r\n              hit: p,\r\n              coordinates: current.getGeometry().getCoordinates(),\r\n              geom: current.getGeometry().clone(),\r\n              geomType: typeGeom\r\n            };\r\n          } else {\r\n            return false;\r\n          }\r\n        } else {\r\n          return false;\r\n        }\r\n      }, { hitTolerance: 5 });\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} e Map browser event.\r\n   * @return {boolean} `true` to start the drag sequence.\r\n   * @private\r\n   */\r\n  handleDownEvent_(e) {\r\n    this.current_ = this.getFeatureAtPixel_(e);\r\n    if (this.current_) {\r\n      this.currentStyle_ = this.current_.feature.getStyle();\r\n      if (this.source_ && (this.get('duplicate') || e.originalEvent.ctrlKey)) {\r\n        this.current_.feature = this.current_.feature.clone();\r\n        this.current_.feature.setStyle(this._style(this.current_.feature));\r\n        this.source_.addFeature(this.current_.feature);\r\n      } else {\r\n        // Modify the current feature\r\n        this.current_.feature.setStyle(this._style(this.current_.feature));\r\n        this._modifystart = true;\r\n      }\r\n      this.dispatchEvent({ type: 'offsetstart', feature: this.current_.feature, offset: 0 });\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} e Map browser event.\r\n   * @private\r\n   */\r\n  handleDragEvent_(e) {\r\n    if (this._modifystart) {\r\n      this.dispatchEvent({ type: 'modifystart', features: [this.current_.feature] });\r\n      this._modifystart = false;\r\n    }\r\n    var p = this.current_.geom.getClosestPoint(e.coordinate);\r\n    var d = ol_coordinate_dist2d(p, e.coordinate);\r\n    var seg, v1, v2, offset;\r\n    switch (this.current_.geomType) {\r\n      case 'Polygon': {\r\n        seg = ol_coordinate_findSegment(p, this.current_.coordinates[0]).segment;\r\n        if (seg) {\r\n          v1 = [seg[1][0] - seg[0][0], seg[1][1] - seg[0][1]];\r\n          v2 = [e.coordinate[0] - p[0], e.coordinate[1] - p[1]];\r\n          if (v1[0] * v2[1] - v1[1] * v2[0] > 0) {\r\n            d = -d;\r\n          }\r\n\r\n          offset = [];\r\n          for (var i = 0; i < this.current_.coordinates.length; i++) {\r\n            offset.push(ol_coordinate_offsetCoords(this.current_.coordinates[i], i == 0 ? d : -d));\r\n          }\r\n          this.current_.feature.setGeometry(new ol_geom_Polygon(offset));\r\n        }\r\n        break;\r\n      }\r\n      case 'LineString': {\r\n        seg = ol_coordinate_findSegment(p, this.current_.coordinates).segment;\r\n        if (seg) {\r\n          v1 = [seg[1][0] - seg[0][0], seg[1][1] - seg[0][1]];\r\n          v2 = [e.coordinate[0] - p[0], e.coordinate[1] - p[1]];\r\n          if (v1[0] * v2[1] - v1[1] * v2[0] > 0) {\r\n            d = -d;\r\n          }\r\n          offset = ol_coordinate_offsetCoords(this.current_.coordinates, d);\r\n          this.current_.feature.setGeometry(new ol_geom_LineString(offset));\r\n        }\r\n        break;\r\n      }\r\n      default: {\r\n        break;\r\n      }\r\n    }\r\n    this.dispatchEvent({ type: 'offsetting', feature: this.current_.feature, offset: d, segment: [p, e.coordinate], coordinate: e.coordinate });\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} e Map browser event.\r\n   * @private\r\n   */\r\n  handleUpEvent_(e) {\r\n    if (!this._modifystart) {\r\n      this.dispatchEvent({ type: 'offsetend', feature: this.current_.feature, coordinate: e.coordinate });\r\n    }\r\n    this.current_.feature.setStyle(this.currentStyle_);\r\n    this.current_ = false;\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} e Event.\r\n   * @private\r\n   */\r\n  handleMoveEvent_(e) {\r\n    var f = this.getFeatureAtPixel_(e);\r\n    if (f) {\r\n      if (this.previousCursor_ === false) {\r\n        this.previousCursor_ = e.map.getTargetElement().style.cursor;\r\n      }\r\n      e.map.getTargetElement().style.cursor = 'pointer';\r\n    } else {\r\n      e.map.getTargetElement().style.cursor = this.previousCursor_;\r\n      this.previousCursor_ = false;\r\n    }\r\n  }\r\n}\r\n\r\nexport default ol_interaction_Offset\r\n","/*\tCopyright (c) 2016 Jean-Marc VIGLINO, \r\n  released under the CeCILL-B license (French BSD license)\r\n  (http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).\r\n*/\r\n\r\nimport ol_interaction_Interaction from 'ol/interaction/Interaction.js'\r\nimport ol_style_Style from 'ol/style/Style.js'\r\nimport ol_style_Stroke from 'ol/style/Stroke.js'\r\nimport ol_source_Vector from 'ol/source/Vector.js'\r\nimport ol_style_Fill from 'ol/style/Fill.js'\r\nimport ol_style_Circle from 'ol/style/Circle.js'\r\nimport ol_layer_Vector from 'ol/layer/Vector.js'\r\nimport ol_geom_Point from 'ol/geom/Point.js'\r\nimport ol_Feature from 'ol/Feature.js'\r\nimport ol_geom_LineString from 'ol/geom/LineString.js'\r\nimport {ol_coordinate_dist2d} from \"../geom/GeomUtils.js\";\r\nimport '../geom/LineStringSplitAt.js'\r\n\r\n/** Interaction split interaction for splitting feature geometry\r\n * @constructor\r\n * @extends {ol_interaction_Interaction}\r\n * @fires  beforesplit, aftersplit, pointermove\r\n * @param {*} \r\n *  @param {ol.source.Vector|Array<ol.source.Vector>} [options.sources] a list of source to split (configured with useSpatialIndex set to true), if none use map visible layers.\r\n *  @param {ol.Collection.<ol.Feature>} options.features collection of feature to split (instead of a list of sources)\r\n *  @param {integer} options.snapDistance distance (in px) to snap to an object, default 25px\r\n *\t@param {string|undefined} options.cursor cursor name to display when hovering an objet\r\n *  @param {function|undefined} options.filter a filter that takes a feature and return true if it can be clipped, default always split.\r\n *  @param ol_style_Style | Array<ol_style_Style> | false | undefined} options.featureStyle Style for the selected features, choose false if you don't want feature selection. By default the default edit style is used.\r\n *  @param {ol_style_Style | Array<ol_style_Style> | undefined} options.sketchStyle Style for the sektch features. \r\n *  @param {function|undefined} options.tolerance Distance between the calculated intersection and a vertex on the source geometry below which the existing vertex will be used for the split.  Default is 1e-10.\r\n */\r\nvar ol_interaction_Split = class olinteractionSplit extends ol_interaction_Interaction {\r\n  constructor(options) {\r\n    if (!options)\r\n      options = {}\r\n\r\n    super({\r\n      handleEvent: function (e) {\r\n        switch (e.type) {\r\n          case \"singleclick\":\r\n            return this.handleDownEvent(e)\r\n          case \"pointermove\":\r\n            return this.handleMoveEvent(e)\r\n          default:\r\n            return true\r\n        }\r\n        //return true;\r\n      }\r\n    })\r\n\r\n    // Snap distance (in px)\r\n    this.snapDistance_ = options.snapDistance || 25\r\n    // Split tolerance between the calculated intersection and the geometry\r\n    this.tolerance_ = options.tolerance || 1e-10\r\n    // Cursor\r\n    this.cursor_ = options.cursor\r\n\r\n    // List of source to split\r\n    this.setSources(options.sources)\r\n\r\n    if (options.features) {\r\n      if (!this.sources_) this.sources_ = [];\r\n      this.sources_.push(new ol_source_Vector({ features: options.features }))\r\n    }\r\n\r\n    // Get all features candidate\r\n    this.filterSplit_ = options.filter || function () { return true }\r\n\r\n    // Default style\r\n    var white = [255, 255, 255, 1]\r\n    var blue = [0, 153, 255, 1]\r\n    var width = 3\r\n    var fill = new ol_style_Fill({ color: 'rgba(255,255,255,0.4)' })\r\n    var stroke = new ol_style_Stroke({\r\n      color: '#3399CC',\r\n      width: 1.25\r\n    })\r\n    var sketchStyle = [\r\n      new ol_style_Style({\r\n        image: new ol_style_Circle({\r\n          fill: fill,\r\n          stroke: stroke,\r\n          radius: 5\r\n        }),\r\n        fill: fill,\r\n        stroke: stroke\r\n      })\r\n    ]\r\n    var featureStyle = [\r\n      new ol_style_Style({\r\n        stroke: new ol_style_Stroke({\r\n          color: white,\r\n          width: width + 2\r\n        })\r\n      }),\r\n      new ol_style_Style({\r\n        image: new ol_style_Circle({\r\n          radius: 2 * width,\r\n          fill: new ol_style_Fill({\r\n            color: blue\r\n          }),\r\n          stroke: new ol_style_Stroke({\r\n            color: white,\r\n            width: width / 2\r\n          })\r\n        }),\r\n        stroke: new ol_style_Stroke({\r\n          color: blue,\r\n          width: width\r\n        })\r\n      }),\r\n    ]\r\n\r\n    // Custom style\r\n    if (options.sketchStyle)\r\n      sketchStyle = options.sketchStyle instanceof Array ? options.sketchStyle : [options.sketchStyle]\r\n    if (options.featureStyle)\r\n      featureStyle = options.featureStyle instanceof Array ? options.featureStyle : [options.featureStyle]\r\n\r\n    // Create a new overlay for the sketch\r\n    this.overlayLayer_ = new ol_layer_Vector({\r\n      source: new ol_source_Vector({\r\n        useSpatialIndex: false\r\n      }),\r\n      name: 'Split overlay',\r\n      displayInLayerSwitcher: false,\r\n      style: function (f) {\r\n        if (f._sketch_)\r\n          return sketchStyle\r\n        else\r\n          return featureStyle\r\n      }\r\n    })\r\n\r\n  }\r\n  /**\r\n   * Remove the interaction from its current map, if any,  and attach it to a new\r\n   * map, if any. Pass `null` to just remove the interaction from the current map.\r\n   * @param {ol.Map} map Map.\r\n   * @api stable\r\n   */\r\n  setMap(map) {\r\n    if (this.getMap()) {\r\n      this.getMap().removeLayer(this.overlayLayer_)\r\n    }\r\n    super.setMap(map)\r\n    this.overlayLayer_.setMap(map)\r\n  }\r\n  /** Get sources to split features in\r\n   * @return {Array<ol.source.Vector>}\r\n   */\r\n  getSources() {\r\n    if (!this.sources_ && this.getMap()) {\r\n      var sources = []\r\n      var getSources = function (layers) {\r\n        layers.forEach(function (layer) {\r\n          if (layer.getVisible()) {\r\n            if (layer.getSource && layer.getSource() instanceof ol_source_Vector) {\r\n              sources.unshift(layer.getSource())\r\n            } else if (layer.getLayers) {\r\n              getSources(layer.getLayers())\r\n            }\r\n          }\r\n        })\r\n      }\r\n      getSources(this.getMap().getLayers())\r\n      return sources\r\n    }\r\n    return this.sources_ || []\r\n  }\r\n  /** Set sources to split features in\r\n   * @param {ol.source.Vector|Array<ol.source.Vector>|boolean} [sources] if not defined get all map vector sources\r\n   */\r\n  setSources(sources) {\r\n    this.sources_ = sources ? (sources instanceof Array ? sources || false : [sources]) : false\r\n  }\r\n  /** Get closest feature at pixel\r\n   * @param {ol.Pixel}\r\n   * @return {ol.feature}\r\n   * @private\r\n   */\r\n  getClosestFeature(e) {\r\n    var source, f, c, g, d = this.snapDistance_ + 1\r\n    // Look for closest point in the sources\r\n    this.getSources().forEach(function (si) {\r\n      var fi = si.getClosestFeatureToCoordinate(e.coordinate)\r\n      if (fi && fi.getGeometry().splitAt) {\r\n        var ci = fi.getGeometry().getClosestPoint(e.coordinate)\r\n        var gi = new ol_geom_LineString([e.coordinate, ci])\r\n        var di = gi.getLength() / e.frameState.viewState.resolution\r\n        if (di < d) {\r\n          source = si\r\n          d = di\r\n          f = fi\r\n          g = gi\r\n          c = ci\r\n        }\r\n      }\r\n    })\r\n    // Snap ?\r\n    if (d > this.snapDistance_) {\r\n      return false\r\n    } else {\r\n      // Snap to node\r\n      var coord = this.getNearestCoord(c, f.getGeometry().getCoordinates())\r\n      var p = this.getMap().getPixelFromCoordinate(coord)\r\n      if (ol_coordinate_dist2d(e.pixel, p) < this.snapDistance_) {\r\n        c = coord\r\n      }\r\n      //\r\n      return { source: source, feature: f, coord: c, link: g }\r\n    }\r\n  }\r\n  /** Get nearest coordinate in a list\r\n  * @param {ol.coordinate} pt the point to find nearest\r\n  * @param {Array<ol.coordinate>} coords list of coordinates\r\n  * @return {ol.coordinate} the nearest coordinate in the list\r\n  */\r\n  getNearestCoord(pt, coords) {\r\n    var d, dm = Number.MAX_VALUE, p0\r\n    for (var i = 0; i < coords.length; i++) {\r\n      d = ol_coordinate_dist2d(pt, coords[i])\r\n      if (d < dm) {\r\n        dm = d\r\n        p0 = coords[i]\r\n      }\r\n    }\r\n    return p0\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} evt Map browser event.\r\n   * @return {boolean} `true` to start the drag sequence.\r\n   */\r\n  handleDownEvent(evt) {\r\n    // Something to split ?\r\n    var current = this.getClosestFeature(evt)\r\n\r\n    if (current) {\r\n      var self = this\r\n      self.overlayLayer_.getSource().clear()\r\n      var split = current.feature.getGeometry().splitAt(current.coord, this.tolerance_)\r\n      var i\r\n      if (split.length > 1) {\r\n        var tosplit = []\r\n        for (i = 0; i < split.length; i++) {\r\n          var f = current.feature.clone()\r\n          f.setGeometry(split[i])\r\n          tosplit.push(f)\r\n        }\r\n        self.dispatchEvent({ type: 'beforesplit', original: current.feature, features: tosplit })\r\n        current.source.dispatchEvent({ type: 'beforesplit', original: current.feature, features: tosplit })\r\n        current.source.removeFeature(current.feature)\r\n        for (i = 0; i < tosplit.length; i++) {\r\n          current.source.addFeature(tosplit[i])\r\n        }\r\n        self.dispatchEvent({ type: 'aftersplit', original: current.feature, features: tosplit })\r\n        current.source.dispatchEvent({ type: 'aftersplit', original: current.feature, features: tosplit })\r\n      }\r\n    }\r\n    return false\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} evt Event.\r\n   */\r\n  handleMoveEvent(e) {\r\n    var map = e.map\r\n    this.overlayLayer_.getSource().clear()\r\n    var current = this.getClosestFeature(e)\r\n\r\n    if (current && this.filterSplit_(current.feature)) {\r\n      var p, l\r\n      // Draw sketch\r\n      this.overlayLayer_.getSource().addFeature(current.feature)\r\n      p = new ol_Feature(new ol_geom_Point(current.coord))\r\n      p._sketch_ = true\r\n      this.overlayLayer_.getSource().addFeature(p)\r\n      //\r\n      l = new ol_Feature(current.link)\r\n      l._sketch_ = true\r\n      this.overlayLayer_.getSource().addFeature(l)\r\n      // move event\r\n      this.dispatchEvent({\r\n        type: 'pointermove',\r\n        coordinate: e.coordinate,\r\n        frameState: e.frameState,\r\n        originalEvent: e.originalEvent,\r\n        map: e.map,\r\n        pixel: e.pixel,\r\n        feature: current.feature,\r\n        linkGeometry: current.link\r\n      })\r\n    } else {\r\n      this.dispatchEvent(e)\r\n    }\r\n\r\n    var element = map.getTargetElement()\r\n    if (this.cursor_) {\r\n      if (current) {\r\n        if (element.style.cursor != this.cursor_) {\r\n          this.previousCursor_ = element.style.cursor\r\n          element.style.cursor = this.cursor_\r\n        }\r\n      } else if (this.previousCursor_ !== undefined) {\r\n        element.style.cursor = this.previousCursor_\r\n        this.previousCursor_ = undefined\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport default ol_interaction_Split\r\n","import ol_style_Style from 'ol/style/Style.js'\r\nimport ol_style_Stroke from 'ol/style/Stroke.js'\r\nimport ol_source_Vector from 'ol/source/Vector.js'\r\nimport ol_style_Fill from 'ol/style/Fill.js'\r\nimport ol_layer_Vector from 'ol/layer/Vector.js'\r\nimport ol_geom_Point from 'ol/geom/Point.js'\r\nimport ol_Feature from 'ol/Feature.js'\r\nimport ol_Collection from 'ol/Collection.js'\r\nimport ol_interaction_Pointer from 'ol/interaction/Pointer.js'\r\nimport ol_style_RegularShape from 'ol/style/RegularShape.js'\r\nimport {fromExtent as ol_geom_Polygon_fromExtent} from 'ol/geom/Polygon.js'\r\nimport {boundingExtent as ol_extent_boundingExtent, buffer as ol_extent_buffer, createEmpty as ol_extent_createEmpty, extend as ol_extent_extend, getCenter as ol_extent_getCenter} from 'ol/extent.js'\r\nimport {unByKey as ol_Observable_unByKey} from 'ol/Observable.js'\r\nimport ol_geom_Polygon from 'ol/geom/Polygon.js'\r\n\r\n/** Interaction rotate\r\n * @constructor\r\n * @extends {ol_interaction_Pointer}\r\n * @fires select | rotatestart | rotating | rotateend | translatestart | translating | translateend | scalestart | scaling | scaleend\r\n * @param {any} options\r\n *  @param {function} options.filter A function that takes a Feature and a Layer and returns true if the feature may be transformed or false otherwise.\r\n *  @param {Array<ol.Layer>} options.layers array of layers to transform,\r\n *  @param {ol.Collection<ol.Feature>} options.features collection of feature to transform,\r\n *\t@param {ol.EventsConditionType|undefined} options.condition A function that takes an ol.MapBrowserEvent and a feature collection and returns a boolean to indicate whether that event should be handled. default: ol.events.condition.always.\r\n *\t@param {ol.EventsConditionType|undefined} options.addCondition A function that takes an ol.MapBrowserEvent and returns a boolean to indicate whether that event should be handled ie. the feature will be added to the transforms features. default: ol.events.condition.never.\r\n *\t@param {number | undefined} options.hitTolerance Tolerance to select feature in pixel, default 0\r\n *\t@param {bool} options.translateFeature Translate when click on feature\r\n *\t@param {bool} options.translate Can translate the feature\r\n *  @param {bool} options.translateBBox Enable translate when the user drags inside the bounding box\r\n *\t@param {bool} options.stretch can stretch the feature\r\n *\t@param {bool} options.scale can scale the feature\r\n *\t@param {bool} options.rotate can rotate the feature\r\n *\t@param {bool} options.noFlip prevent the feature geometry to flip, default false\r\n *\t@param {bool} options.selection the intraction handle selection/deselection, if not use the select prototype to add features to transform, default true\r\n *\t@param {ol.events.ConditionType | undefined} options.keepAspectRatio A function that takes an ol.MapBrowserEvent and returns a boolean to keep aspect ratio, default ol.events.condition.shiftKeyOnly.\r\n *\t@param {ol.events.ConditionType | undefined} options.modifyCenter A function that takes an ol.MapBrowserEvent and returns a boolean to apply scale & strech from the center, default ol.events.condition.metaKey or ol.events.condition.ctrlKey.\r\n *\t@param {boolean} options.enableRotatedTransform Enable transform when map is rotated\r\n *\t@param {boolean} [options.keepRectangle=false] keep rectangle when possible\r\n *  @param {number} [options.buffer] Increase the extent used as bounding box, default 0\r\n *\t@param {*} options.style list of ol.style for handles\r\n *  @param {number|Array<number>|function} [options.pointRadius=0] radius for points or a function that takes a feature and returns the radius (or [radiusX, radiusY]). If not null show handles to transform the points\r\n */\r\nvar ol_interaction_Transform = class olinteractionTransform extends ol_interaction_Pointer {\r\n  constructor(options) {\r\n    options = options || {}\r\n    // Extend pointer\r\n    super({\r\n      handleDownEvent: function(e) { return self.handleDownEvent_(e) },\r\n      handleDragEvent: function(e) { return this.handleDragEvent_(e) },\r\n      handleMoveEvent: function(e) { return this.handleMoveEvent_(e) },\r\n      handleUpEvent: function(e) { return this.handleUpEvent_(e) },\r\n    })\r\n    \r\n    var self = this\r\n    this.selection_ = new ol_Collection()\r\n\r\n    // Create a new overlay layer for the sketch\r\n    this.handles_ = new ol_Collection()\r\n    this.overlayLayer_ = new ol_layer_Vector({\r\n      source: new ol_source_Vector({\r\n        features: this.handles_,\r\n        useSpatialIndex: false,\r\n        wrapX: false // For vector editing across the -180 and 180 meridians to work properly, this should be set to false\r\n      }),\r\n      name: 'Transform overlay',\r\n      displayInLayerSwitcher: false,\r\n      // Return the style according to the handle type\r\n      style: function (feature) {\r\n        return (self.style[(feature.get('handle') || 'default') + (feature.get('constraint') || '') + (feature.get('option') || '')])\r\n      },\r\n    })\r\n\r\n    // Collection of feature to transform\r\n    this.features_ = options.features\r\n    // Filter or list of layers to transform\r\n    if (typeof (options.filter) === 'function')\r\n      this._filter = options.filter\r\n    this.layers_ = options.layers ? (options.layers instanceof Array) ? options.layers : [options.layers] : null\r\n\r\n    this._handleEvent = options.condition || function () { return true }\r\n    this.addFn_ = options.addCondition || function () { return false }\r\n    this.setPointRadius(options.pointRadius)\r\n    /* Translate when click on feature */\r\n    this.set('translateFeature', (options.translateFeature !== false))\r\n    /* Can translate the feature */\r\n    this.set('translate', (options.translate !== false))\r\n    /* Translate when click on the bounding box */\r\n    this.set('translateBBox', (options.translateBBox === true))\r\n    /* Can stretch the feature */\r\n    this.set('stretch', (options.stretch !== false))\r\n    /* Can scale the feature */\r\n    this.set('scale', (options.scale !== false))\r\n    /* Can rotate the feature */\r\n    this.set('rotate', (options.rotate !== false))\r\n    /* Keep aspect ratio */\r\n    this.set('keepAspectRatio', (options.keepAspectRatio || function (e) { return e.originalEvent.shiftKey }))\r\n    /* Modify center */\r\n    this.set('modifyCenter', (options.modifyCenter || function (e) { return e.originalEvent.metaKey || e.originalEvent.ctrlKey }))\r\n    /* Prevent flip */\r\n    this.set('noFlip', (options.noFlip || false))\r\n    /* Handle selection */\r\n    this.set('selection', (options.selection !== false))\r\n    /*  */\r\n    this.set('hitTolerance', (options.hitTolerance || 0))\r\n    /* Enable view rotated transforms */\r\n    this.set('enableRotatedTransform', (options.enableRotatedTransform || false))\r\n    /* Keep rectangle angles 90 degrees */\r\n    this.set('keepRectangle', (options.keepRectangle || false))\r\n    /* Add buffer to the feature's extent */\r\n    this.set('buffer', (options.buffer || 0))\r\n\r\n    // Force redraw when changed\r\n    this.on('propertychange', function () {\r\n      this.drawSketch_()\r\n    })\r\n\r\n    // setstyle\r\n    this.setDefaultStyle()\r\n  }\r\n  /**\r\n   * Remove the interaction from its current map, if any,  and attach it to a new\r\n   * map, if any. Pass `null` to just remove the interaction from the current map.\r\n   * @param {ol.Map} map Map.\r\n   * @api stable\r\n   */\r\n  setMap(map) {\r\n    var oldMap = this.getMap()\r\n    if (oldMap) {\r\n      var targetElement = oldMap.getTargetElement()\r\n      oldMap.removeLayer(this.overlayLayer_)\r\n      if (this.previousCursor_ && targetElement) {\r\n        targetElement.style.cursor = this.previousCursor_\r\n      }\r\n      this.previousCursor_ = undefined\r\n    }\r\n    super.setMap(map)\r\n    this.overlayLayer_.setMap(map)\r\n    if (map === null) {\r\n      this.select(null)\r\n    }\r\n    if (map !== null) {\r\n      this.isTouch = /touch/.test(map.getViewport().className)\r\n      this.setDefaultStyle()\r\n    }\r\n  }\r\n  /**\r\n   * Activate/deactivate interaction\r\n   * @param {bool}\r\n   * @api stable\r\n   */\r\n  setActive(b) {\r\n    this.select(null)\r\n    if (this.overlayLayer_) this.overlayLayer_.setVisible(b)\r\n    super.setActive(b)\r\n  }\r\n  /** Set default sketch style\r\n   * @param {Object|undefined} options\r\n   *  @param {ol_style_Stroke} stroke stroke style for selection rectangle\r\n   *  @param {ol_style_Fill} fill fill style for selection rectangle\r\n   *  @param {ol_style_Stroke} pointStroke stroke style for handles\r\n   *  @param {ol_style_Fill} pointFill fill style for handles\r\n   */\r\n  setDefaultStyle(options) {\r\n    options = options || {}\r\n    // Style\r\n    var stroke = options.pointStroke || new ol_style_Stroke({ color: [255, 0, 0, 1], width: 1 })\r\n    var strokedash = options.stroke || new ol_style_Stroke({ color: [255, 0, 0, 1], width: 1, lineDash: [4, 4] })\r\n    var fill0 = options.fill || new ol_style_Fill({ color: [255, 0, 0, 0.01] })\r\n    var fill = options.pointFill || new ol_style_Fill({ color: [255, 255, 255, 0.8] })\r\n    var circle = new ol_style_RegularShape({\r\n      fill: fill,\r\n      stroke: stroke,\r\n      radius: this.isTouch ? 12 : 6,\r\n      displacement: this.isTouch ? [24, -24] : [12, -12],\r\n      points: 15\r\n    })\r\n    // Old version with no displacement\r\n    if (!circle.setDisplacement)\r\n      circle.getAnchor()[0] = this.isTouch ? -10 : -5\r\n    var bigpt = new ol_style_RegularShape({\r\n      fill: fill,\r\n      stroke: stroke,\r\n      radius: this.isTouch ? 16 : 8,\r\n      points: 4,\r\n      angle: Math.PI / 4\r\n    })\r\n    var smallpt = new ol_style_RegularShape({\r\n      fill: fill,\r\n      stroke: stroke,\r\n      radius: this.isTouch ? 12 : 6,\r\n      points: 4,\r\n      angle: Math.PI / 4\r\n    })\r\n    function createStyle(img, stroke, fill) {\r\n      return [new ol_style_Style({ image: img, stroke: stroke, fill: fill })]\r\n    }\r\n    /** Style for handles */\r\n    this.style = {\r\n      'default': createStyle(bigpt, strokedash, fill0),\r\n      'translate': createStyle(bigpt, stroke, fill),\r\n      'rotate': createStyle(circle, stroke, fill),\r\n      'rotate0': createStyle(bigpt, stroke, fill),\r\n      'scale': createStyle(bigpt, stroke, fill),\r\n      'scale1': createStyle(bigpt, stroke, fill),\r\n      'scale2': createStyle(bigpt, stroke, fill),\r\n      'scale3': createStyle(bigpt, stroke, fill),\r\n      'scalev': createStyle(smallpt, stroke, fill),\r\n      'scaleh1': createStyle(smallpt, stroke, fill),\r\n      'scalev2': createStyle(smallpt, stroke, fill),\r\n      'scaleh3': createStyle(smallpt, stroke, fill),\r\n    }\r\n    this.drawSketch_()\r\n  }\r\n  /**\r\n   * Set sketch style.\r\n   * @param {style} style Style name: 'default','translate','rotate','rotate0','scale','scale1','scale2','scale3','scalev','scaleh1','scalev2','scaleh3'\r\n   * @param {ol.style.Style|Array<ol.style.Style>} olstyle\r\n   * @api stable\r\n   */\r\n  setStyle(style, olstyle) {\r\n    if (!olstyle)\r\n      return\r\n    if (olstyle instanceof Array)\r\n      this.style[style] = olstyle\r\n    else\r\n      this.style[style] = [olstyle]\r\n    for (var i = 0; i < this.style[style].length; i++) {\r\n      var im = this.style[style][i].getImage()\r\n      if (im) {\r\n        if (style == 'rotate') {\r\n          im.getAnchor()[0] = -5\r\n        }\r\n        if (this.isTouch)\r\n          im.setScale(1.8)\r\n      }\r\n      var tx = this.style[style][i].getText()\r\n      if (tx) {\r\n        if (style == 'rotate')\r\n          tx.setOffsetX(this.isTouch ? 14 : 7)\r\n        if (this.isTouch)\r\n          tx.setScale(1.8)\r\n      }\r\n    }\r\n    this.drawSketch_()\r\n  }\r\n  /** Get Feature at pixel\r\n   * @param {ol.Pixel}\r\n   * @return {ol.feature}\r\n   * @private\r\n   */\r\n  getFeatureAtPixel_(pixel) {\r\n    var self = this\r\n    return this.getMap().forEachFeatureAtPixel(pixel,\r\n      function (feature, layer) {\r\n        var found = false\r\n        // Overlay ?\r\n        if (!layer) {\r\n          if (feature === self.bbox_) {\r\n            if (self.get('translateBBox')) {\r\n              return { feature: feature, handle: 'translate', constraint: '', option: '' }\r\n            } else {\r\n              return false\r\n            }\r\n          }\r\n          self.handles_.forEach(function (f) {\r\n            if (f === feature)\r\n              found = true\r\n          })\r\n          if (found)\r\n            return { feature: feature, handle: feature.get('handle'), constraint: feature.get('constraint'), option: feature.get('option') }\r\n        }\r\n        // No seletion\r\n        if (!self.get('selection')) {\r\n          // Return the currently selected feature the user is interacting with.\r\n          if (self.selection_.getArray().some(function (f) { return feature === f })) {\r\n            return { feature: feature }\r\n          }\r\n          return null\r\n        }\r\n        // filter condition\r\n        if (self._filter) {\r\n          if (self._filter(feature, layer))\r\n            return { feature: feature }\r\n          else\r\n            return null\r\n        }\r\n\r\n        // feature belong to a layer\r\n        else if (self.layers_) {\r\n          for (var i = 0; i < self.layers_.length; i++) {\r\n            if (self.layers_[i] === layer)\r\n              return { feature: feature }\r\n          }\r\n          return null\r\n        }\r\n\r\n        // feature in the collection\r\n        else if (self.features_) {\r\n          self.features_.forEach(function (f) {\r\n            if (f === feature)\r\n              found = true\r\n          })\r\n          if (found)\r\n            return { feature: feature }\r\n          else\r\n            return null\r\n        }\r\n\r\n        // Others\r\n        else\r\n          return { feature: feature }\r\n      },\r\n      { hitTolerance: this.get('hitTolerance') }\r\n    ) || {}\r\n  }\r\n  /** Rotate feature from map view rotation\r\n   * @param {ol.Feature} f the feature\r\n   * @param {boolean} clone clone resulting geom\r\n   * @param {ol.geom.Geometry} rotated geometry\r\n   */\r\n  getGeometryRotateToZero_(f, clone) {\r\n    var origGeom = f.getGeometry()\r\n    var viewRotation = this.getMap().getView().getRotation()\r\n    if (viewRotation === 0 || !this.get('enableRotatedTransform')) {\r\n      return (clone) ? origGeom.clone() : origGeom\r\n    }\r\n    var rotGeom = origGeom.clone()\r\n    rotGeom.rotate(viewRotation * -1, this.getMap().getView().getCenter())\r\n    return rotGeom\r\n  }\r\n  /** Test if rectangle\r\n   * @param {ol.Geometry} geom\r\n   * @returns {boolean}\r\n   * @private\r\n   */\r\n  _isRectangle(geom) {\r\n    if (this.get('keepRectangle') && geom.getType() === 'Polygon') {\r\n      var coords = geom.getCoordinates()[0]\r\n      return coords.length === 5\r\n    }\r\n    return false\r\n  }\r\n  /** Draw transform sketch\r\n  * @param {boolean} draw only the center\r\n  */\r\n  drawSketch_(center) {\r\n    var i, f, geom\r\n    var keepRectangle = this.selection_.item(0) && this._isRectangle(this.selection_.item(0).getGeometry())\r\n    this.overlayLayer_.getSource().clear()\r\n    if (!this.selection_.getLength())\r\n      return\r\n    var viewRotation = this.getMap().getView().getRotation()\r\n    var ext = this.getGeometryRotateToZero_(this.selection_.item(0)).getExtent()\r\n    var coords\r\n    if (keepRectangle) {\r\n      coords = this.getGeometryRotateToZero_(this.selection_.item(0)).getCoordinates()[0].slice(0, 4)\r\n      coords.unshift(coords[3])\r\n    }\r\n    // Clone and extend\r\n    ext = ol_extent_buffer(ext, this.get('buffer'))\r\n    this.selection_.forEach(function (f) {\r\n      var extendExt = this.getGeometryRotateToZero_(f).getExtent()\r\n      ol_extent_extend(ext, extendExt)\r\n    }.bind(this))\r\n\r\n    var ptRadius = (this.selection_.getLength() === 1 ? this._pointRadius(this.selection_.item(0)) : 0)\r\n    if (ptRadius && !(ptRadius instanceof Array))\r\n      ptRadius = [ptRadius, ptRadius]\r\n\r\n    if (center === true) {\r\n      if (!this.ispt_) {\r\n        this.overlayLayer_.getSource().addFeature(new ol_Feature({ geometry: new ol_geom_Point(this.center_), handle: 'rotate0' }))\r\n        geom = ol_geom_Polygon_fromExtent(ext)\r\n        if (this.get('enableRotatedTransform') && viewRotation !== 0) {\r\n          geom.rotate(viewRotation, this.getMap().getView().getCenter())\r\n        }\r\n        f = this.bbox_ = new ol_Feature(geom)\r\n        this.overlayLayer_.getSource().addFeature(f)\r\n      }\r\n    } else {\r\n      if (this.ispt_) {\r\n        // Calculate extent arround the point\r\n        var p = this.getMap().getPixelFromCoordinate([ext[0], ext[1]])\r\n        if (p) {\r\n          var dx = ptRadius ? ptRadius[0] || 10 : 10\r\n          var dy = ptRadius ? ptRadius[1] || 10 : 10\r\n          ext = ol_extent_boundingExtent([\r\n            this.getMap().getCoordinateFromPixel([p[0] - dx, p[1] - dy]),\r\n            this.getMap().getCoordinateFromPixel([p[0] + dx, p[1] + dy])\r\n          ])\r\n        }\r\n      }\r\n      geom = keepRectangle ? new ol_geom_Polygon([coords]) : ol_geom_Polygon_fromExtent(ext)\r\n      if (this.get('enableRotatedTransform') && viewRotation !== 0) {\r\n        geom.rotate(viewRotation, this.getMap().getView().getCenter())\r\n      }\r\n      f = this.bbox_ = new ol_Feature(geom)\r\n      var features = []\r\n      var g = geom.getCoordinates()[0]\r\n      if (!this.ispt_ || ptRadius) {\r\n        features.push(f)\r\n        // Middle\r\n        if (!this.iscircle_ && !this.ispt_ && this.get('stretch') && this.get('scale'))\r\n          for (i = 0; i < g.length - 1; i++) {\r\n            f = new ol_Feature({ geometry: new ol_geom_Point([(g[i][0] + g[i + 1][0]) / 2, (g[i][1] + g[i + 1][1]) / 2]), handle: 'scale', constraint: i % 2 ? \"h\" : \"v\", option: i })\r\n            features.push(f)\r\n          }\r\n        // Handles\r\n        if (this.get('scale'))\r\n          for (i = 0; i < g.length - 1; i++) {\r\n            f = new ol_Feature({ geometry: new ol_geom_Point(g[i]), handle: 'scale', option: i })\r\n            features.push(f)\r\n          }\r\n        // Center\r\n        if (this.get('translate') && !this.get('translateFeature')) {\r\n          f = new ol_Feature({ geometry: new ol_geom_Point([(g[0][0] + g[2][0]) / 2, (g[0][1] + g[2][1]) / 2]), handle: 'translate' })\r\n          features.push(f)\r\n        }\r\n      }\r\n      // Rotate\r\n      if (!this.iscircle_ && this.get('rotate')) {\r\n        f = new ol_Feature({ geometry: new ol_geom_Point(g[3]), handle: 'rotate' })\r\n        features.push(f)\r\n      }\r\n      // Add sketch\r\n      this.overlayLayer_.getSource().addFeatures(features)\r\n    }\r\n\r\n  }\r\n  /** Select a feature to transform\r\n  * @param {ol.Feature} feature the feature to transform\r\n  * @param {boolean} add true to add the feature to the selection, default false\r\n  */\r\n  select(feature, add) {\r\n    if (!feature) {\r\n      if (this.selection_) {\r\n        this.selection_.clear()\r\n        this.drawSketch_()\r\n      }\r\n      return\r\n    }\r\n    if (!feature.getGeometry || !feature.getGeometry()) return\r\n    // Add to selection\r\n    if (add) {\r\n      this.selection_.push(feature)\r\n    } else {\r\n      var index = this.selection_.getArray().indexOf(feature)\r\n      this.selection_.removeAt(index)\r\n    }\r\n    this.ispt_ = (this.selection_.getLength() === 1 ? (this.selection_.item(0).getGeometry().getType() == \"Point\") : false)\r\n    this.iscircle_ = (this.selection_.getLength() === 1 ? (this.selection_.item(0).getGeometry().getType() == \"Circle\") : false)\r\n    this.drawSketch_()\r\n    this.watchFeatures_()\r\n    // select event\r\n    this.dispatchEvent({ type: 'select', feature: feature, features: this.selection_ })\r\n  }\r\n  /** Update the selection collection.\r\n  * @param {ol.Collection<ol.Feature>} features the features to transform\r\n  */\r\n  setSelection(features) {\r\n    this.selection_.clear()\r\n    features.forEach(function (feature) {\r\n      this.selection_.push(feature)\r\n    }.bind(this))\r\n\r\n    this.ispt_ = (this.selection_.getLength() === 1 ? (this.selection_.item(0).getGeometry().getType() == \"Point\") : false)\r\n    this.iscircle_ = (this.selection_.getLength() === 1 ? (this.selection_.item(0).getGeometry().getType() == \"Circle\") : false)\r\n    this.drawSketch_()\r\n    this.watchFeatures_()\r\n    // select event\r\n    this.dispatchEvent({ type: 'select', features: this.selection_ })\r\n  }\r\n  /** Watch selected features\r\n   * @private\r\n   */\r\n  watchFeatures_() {\r\n    // Listen to feature modification\r\n    if (this._featureListeners) {\r\n      this._featureListeners.forEach(function (l) {\r\n        ol_Observable_unByKey(l)\r\n      })\r\n    }\r\n    this._featureListeners = []\r\n    this.selection_.forEach(function (f) {\r\n      this._featureListeners.push(\r\n        f.on('change', function () {\r\n          if (!this.isUpdating_) {\r\n            this.drawSketch_()\r\n          }\r\n        }.bind(this))\r\n      )\r\n    }.bind(this))\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} evt Map browser event.\r\n   * @return {boolean} `true` to start the drag sequence.\r\n   * @private\r\n   */\r\n  handleDownEvent_(evt) {\r\n    if (!this._handleEvent(evt, this.selection_))\r\n      return\r\n    var sel = this.getFeatureAtPixel_(evt.pixel)\r\n    var feature = sel.feature\r\n    if (this.selection_.getLength()\r\n      && this.selection_.getArray().indexOf(feature) >= 0\r\n      && ((this.ispt_ && this.get('translate')) || this.get('translateFeature'))) {\r\n      sel.handle = 'translate'\r\n    }\r\n    if (sel.handle) {\r\n      this.mode_ = sel.handle\r\n      this.opt_ = sel.option\r\n      this.constraint_ = sel.constraint\r\n      // Save info\r\n      var viewRotation = this.getMap().getView().getRotation()\r\n      this.coordinate_ = evt.coordinate\r\n      this.pixel_ = evt.pixel\r\n      this.geoms_ = []\r\n      this.rotatedGeoms_ = []\r\n      var extent = ol_extent_createEmpty()\r\n      var rotExtent = ol_extent_createEmpty()\r\n      for (var i = 0, f; f = this.selection_.item(i); i++) {\r\n        this.geoms_.push(f.getGeometry().clone())\r\n        extent = ol_extent_extend(extent, f.getGeometry().getExtent())\r\n        if (this.get('enableRotatedTransform') && viewRotation !== 0) {\r\n          var rotGeom = this.getGeometryRotateToZero_(f, true)\r\n          this.rotatedGeoms_.push(rotGeom)\r\n          rotExtent = ol_extent_extend(rotExtent, rotGeom.getExtent())\r\n        }\r\n      }\r\n      this.extent_ = (ol_geom_Polygon_fromExtent(extent)).getCoordinates()[0]\r\n      if (this.get('enableRotatedTransform') && viewRotation !== 0) {\r\n        this.rotatedExtent_ = (ol_geom_Polygon_fromExtent(rotExtent)).getCoordinates()[0]\r\n      }\r\n      if (this.mode_ === 'rotate') {\r\n        this.center_ = this.getCenter() || ol_extent_getCenter(extent)\r\n        // we are now rotating (cursor down on rotate mode), so apply the grabbing cursor\r\n        var element = evt.map.getTargetElement()\r\n        element.style.cursor = this.Cursors.rotate0\r\n        this.previousCursor_ = element.style.cursor\r\n      } else {\r\n        this.center_ = ol_extent_getCenter(extent)\r\n      }\r\n      this.angle_ = Math.atan2(this.center_[1] - evt.coordinate[1], this.center_[0] - evt.coordinate[0])\r\n\r\n      this.dispatchEvent({\r\n        type: this.mode_ + 'start',\r\n        feature: this.selection_.item(0),\r\n        features: this.selection_,\r\n        pixel: evt.pixel,\r\n        coordinate: evt.coordinate\r\n      })\r\n      return true\r\n    }\r\n    else if (this.get('selection')) {\r\n      if (feature) {\r\n        if (!this.addFn_(evt))\r\n          this.selection_.clear()\r\n        var index = this.selection_.getArray().indexOf(feature)\r\n        if (index < 0)\r\n          this.selection_.push(feature)\r\n        else\r\n          this.selection_.removeAt(index)\r\n      } else {\r\n        this.selection_.clear()\r\n      }\r\n      this.ispt_ = this.selection_.getLength() === 1 ? (this.selection_.item(0).getGeometry().getType() == \"Point\") : false\r\n      this.iscircle_ = (this.selection_.getLength() === 1 ? (this.selection_.item(0).getGeometry().getType() == \"Circle\") : false)\r\n      this.drawSketch_()\r\n      this.watchFeatures_()\r\n      this.dispatchEvent({ type: 'select', feature: feature, features: this.selection_, pixel: evt.pixel, coordinate: evt.coordinate })\r\n      return false\r\n    }\r\n  }\r\n  /**\r\n   * Get the rotation center\r\n   * @return {ol.coordinate|undefined}\r\n   */\r\n  getCenter() {\r\n    return this.get('center')\r\n  }\r\n  /**\r\n   * Set the rotation center\r\n   * @param {ol.coordinate|undefined} c the center point, default center on the objet\r\n   */\r\n  setCenter(c) {\r\n    return this.set('center', c)\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} evt Map browser event.\r\n   * @private\r\n   */\r\n  handleDragEvent_(evt) {\r\n    if (!this._handleEvent(evt, this.features_))\r\n      return\r\n    var viewRotation = this.getMap().getView().getRotation()\r\n    var i, j, f, geometry\r\n    var pt0 = [this.coordinate_[0], this.coordinate_[1]]\r\n    var pt = [evt.coordinate[0], evt.coordinate[1]]\r\n    this.isUpdating_ = true\r\n    switch (this.mode_) {\r\n      case 'rotate': {\r\n        var a = Math.atan2(this.center_[1] - pt[1], this.center_[0] - pt[0])\r\n        if (!this.ispt) {\r\n          // var geometry = this.geom_.clone();\r\n          // geometry.rotate(a-this.angle_, this.center_);\r\n          // this.feature_.setGeometry(geometry);\r\n          for (i = 0, f; f = this.selection_.item(i); i++) {\r\n            geometry = this.geoms_[i].clone()\r\n            geometry.rotate(a - this.angle_, this.center_)\r\n            // bug: ol, bad calculation circle geom extent\r\n            if (geometry.getType() == 'Circle')\r\n              geometry.setCenterAndRadius(geometry.getCenter(), geometry.getRadius())\r\n            f.setGeometry(geometry)\r\n          }\r\n        }\r\n        this.drawSketch_(true)\r\n        this.dispatchEvent({\r\n          type: 'rotating',\r\n          feature: this.selection_.item(0),\r\n          features: this.selection_,\r\n          angle: a - this.angle_,\r\n          pixel: evt.pixel,\r\n          coordinate: evt.coordinate\r\n        })\r\n        break\r\n      }\r\n      case 'translate': {\r\n        var deltaX = pt[0] - pt0[0]\r\n        var deltaY = pt[1] - pt0[1]\r\n\r\n        //this.feature_.getGeometry().translate(deltaX, deltaY);\r\n        for (i = 0, f; f = this.selection_.item(i); i++) {\r\n          f.getGeometry().translate(deltaX, deltaY)\r\n        }\r\n        this.handles_.forEach(function (f) {\r\n          f.getGeometry().translate(deltaX, deltaY)\r\n        })\r\n\r\n        this.coordinate_ = evt.coordinate\r\n        this.dispatchEvent({\r\n          type: 'translating',\r\n          feature: this.selection_.item(0),\r\n          features: this.selection_,\r\n          delta: [deltaX, deltaY],\r\n          pixel: evt.pixel,\r\n          coordinate: evt.coordinate\r\n        })\r\n        break\r\n      }\r\n      case 'scale': {\r\n        var center = this.center_\r\n        if (this.get('modifyCenter')(evt)) {\r\n          var extentCoordinates = this.extent_\r\n          if (this.get('enableRotatedTransform') && viewRotation !== 0) {\r\n            extentCoordinates = this.rotatedExtent_\r\n          }\r\n          center = extentCoordinates[(Number(this.opt_) + 2) % 4]\r\n        }\r\n        var keepRectangle = (this.geoms_.length == 1 && this._isRectangle(this.geoms_[0]))\r\n        var stretch = this.constraint_\r\n        var opt = this.opt_\r\n\r\n        var downCoordinate = this.coordinate_\r\n        var dragCoordinate = evt.coordinate\r\n        if (this.get('enableRotatedTransform') && viewRotation !== 0) {\r\n          var downPoint = new ol_geom_Point(this.coordinate_)\r\n          downPoint.rotate(viewRotation * -1, center)\r\n          downCoordinate = downPoint.getCoordinates()\r\n\r\n          var dragPoint = new ol_geom_Point(evt.coordinate)\r\n          dragPoint.rotate(viewRotation * -1, center)\r\n          dragCoordinate = dragPoint.getCoordinates()\r\n        }\r\n\r\n        var scx = ((dragCoordinate)[0] - (center)[0]) / (downCoordinate[0] - (center)[0])\r\n        var scy = ((dragCoordinate)[1] - (center)[1]) / (downCoordinate[1] - (center)[1])\r\n        var displacementVector = [dragCoordinate[0] - downCoordinate[0], (dragCoordinate)[1] - downCoordinate[1]]\r\n\r\n        if (this.get('enableRotatedTransform') && viewRotation !== 0) {\r\n          var centerPoint = new ol_geom_Point(center)\r\n          centerPoint.rotate(viewRotation * -1, this.getMap().getView().getCenter())\r\n          center = centerPoint.getCoordinates()\r\n        }\r\n\r\n        if (this.get('noFlip')) {\r\n          if (scx < 0)\r\n            scx = -scx\r\n          if (scy < 0)\r\n            scy = -scy\r\n        }\r\n\r\n        if (this.constraint_) {\r\n          if (this.constraint_ == \"h\")\r\n            scx = 1\r\n          else\r\n            scy = 1\r\n        } else {\r\n          if (this.get('keepAspectRatio')(evt)) {\r\n            scx = scy = Math.min(scx, scy)\r\n          }\r\n        }\r\n\r\n        for (i = 0, f; f = this.selection_.item(i); i++) {\r\n          geometry = (viewRotation === 0 || !this.get('enableRotatedTransform')) ? this.geoms_[i].clone() : this.rotatedGeoms_[i].clone()\r\n          geometry.applyTransform(function (g1, g2, dim) {\r\n            if (dim < 2) return g2\r\n\r\n            if (!keepRectangle) {\r\n              for (j = 0; j < g1.length; j += dim) {\r\n                if (scx != 1)\r\n                  g2[j] = center[0] + (g1[j] - center[0]) * scx\r\n                if (scy != 1)\r\n                  g2[j + 1] = center[1] + (g1[j + 1] - center[1]) * scy\r\n              }\r\n            } else {\r\n              var pointArray = [[6], [0, 8], [2], [4]]\r\n              var pointA = [g1[0], g1[1]]\r\n              var pointB = [g1[2], g1[3]]\r\n              var pointC = [g1[4], g1[5]]\r\n              var pointD = [g1[6], g1[7]]\r\n              var pointA1 = [g1[8], g1[9]]\r\n\r\n              if (stretch) {\r\n                var base = (opt % 2 === 0) ? this._countVector(pointA, pointB) : this._countVector(pointD, pointA)\r\n                var projectedVector = this._projectVectorOnVector(displacementVector, base)\r\n                var nextIndex = opt + 1 < pointArray.length ? opt + 1 : 0\r\n                var coordsToChange = [...pointArray[opt], ...pointArray[nextIndex]]\r\n\r\n                for (j = 0; j < g1.length; j += dim) {\r\n                  g2[j] = coordsToChange.includes(j) ? g1[j] + projectedVector[0] : g1[j]\r\n                  g2[j + 1] = coordsToChange.includes(j) ? g1[j + 1] + projectedVector[1] : g1[j + 1]\r\n                }\r\n              } else {\r\n                var projectedLeft, projectedRight\r\n                switch (opt) {\r\n                  case 0:\r\n                    displacementVector = this._countVector(pointD, dragCoordinate)\r\n                    projectedLeft = this._projectVectorOnVector(displacementVector, this._countVector(pointC, pointD))\r\n                    projectedRight = this._projectVectorOnVector(displacementVector, this._countVector(pointA, pointD));\r\n                    [g2[0], g2[1]] = this._movePoint(pointA, projectedLeft);\r\n                    [g2[4], g2[5]] = this._movePoint(pointC, projectedRight);\r\n                    [g2[6], g2[7]] = this._movePoint(pointD, displacementVector);\r\n                    [g2[8], g2[9]] = this._movePoint(pointA1, projectedLeft)\r\n                    break\r\n                  case 1:\r\n                    displacementVector = this._countVector(pointA, dragCoordinate)\r\n                    projectedLeft = this._projectVectorOnVector(displacementVector, this._countVector(pointD, pointA))\r\n                    projectedRight = this._projectVectorOnVector(displacementVector, this._countVector(pointB, pointA));\r\n                    [g2[0], g2[1]] = this._movePoint(pointA, displacementVector);\r\n                    [g2[2], g2[3]] = this._movePoint(pointB, projectedLeft);\r\n                    [g2[6], g2[7]] = this._movePoint(pointD, projectedRight);\r\n                    [g2[8], g2[9]] = this._movePoint(pointA1, displacementVector)\r\n                    break\r\n                  case 2:\r\n                    displacementVector = this._countVector(pointB, dragCoordinate)\r\n                    projectedLeft = this._projectVectorOnVector(displacementVector, this._countVector(pointA, pointB))\r\n                    projectedRight = this._projectVectorOnVector(displacementVector, this._countVector(pointC, pointB));\r\n                    [g2[0], g2[1]] = this._movePoint(pointA, projectedRight);\r\n                    [g2[2], g2[3]] = this._movePoint(pointB, displacementVector);\r\n                    [g2[4], g2[5]] = this._movePoint(pointC, projectedLeft);\r\n                    [g2[8], g2[9]] = this._movePoint(pointA1, projectedRight)\r\n                    break\r\n                  case 3:\r\n                    displacementVector = this._countVector(pointC, dragCoordinate)\r\n                    projectedLeft = this._projectVectorOnVector(displacementVector, this._countVector(pointB, pointC))\r\n                    projectedRight = this._projectVectorOnVector(displacementVector, this._countVector(pointD, pointC));\r\n                    [g2[2], g2[3]] = this._movePoint(pointB, projectedRight);\r\n                    [g2[4], g2[5]] = this._movePoint(pointC, displacementVector);\r\n                    [g2[6], g2[7]] = this._movePoint(pointD, projectedLeft)\r\n                    break\r\n                }\r\n              }\r\n            }\r\n\r\n            // bug: ol, bad calculation circle geom extent\r\n            if (geometry.getType() == 'Circle') geometry.setCenterAndRadius(geometry.getCenter(), geometry.getRadius())\r\n            return g2\r\n          }.bind(this))\r\n          if (this.get('enableRotatedTransform') && viewRotation !== 0) {\r\n            //geometry.rotate(viewRotation, rotationCenter);\r\n            geometry.rotate(viewRotation, this.getMap().getView().getCenter())\r\n          }\r\n          f.setGeometry(geometry)\r\n        }\r\n        this.drawSketch_()\r\n        this.dispatchEvent({\r\n          type: 'scaling',\r\n          feature: this.selection_.item(0),\r\n          features: this.selection_,\r\n          scale: [scx, scy],\r\n          pixel: evt.pixel,\r\n          coordinate: evt.coordinate\r\n        })\r\n        break\r\n      }\r\n      default: break\r\n    }\r\n    this.isUpdating_ = false\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} evt Event.\r\n   * @private\r\n   */\r\n  handleMoveEvent_(evt) {\r\n    if (!this._handleEvent(evt, this.features_))\r\n      return\r\n    // console.log(\"handleMoveEvent\");\r\n    if (!this.mode_) {\r\n      var sel = this.getFeatureAtPixel_(evt.pixel)\r\n      var element = evt.map.getTargetElement()\r\n      if (sel.feature) {\r\n        var c = sel.handle ? this.Cursors[(sel.handle || 'default') + (sel.constraint || '') + (sel.option || '')] : this.Cursors.select\r\n\r\n        if (this.previousCursor_ === undefined) {\r\n          this.previousCursor_ = element.style.cursor\r\n        }\r\n        element.style.cursor = c\r\n      } else {\r\n        if (this.previousCursor_ !== undefined)\r\n          element.style.cursor = this.previousCursor_\r\n        this.previousCursor_ = undefined\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} evt Map browser event.\r\n   * @return {boolean} `false` to stop the drag sequence.\r\n   */\r\n  handleUpEvent_(evt) {\r\n    // remove rotate0 cursor on Up event, otherwise it's stuck on grab/grabbing\r\n    if (this.mode_ === 'rotate') {\r\n      var element = evt.map.getTargetElement()\r\n      element.style.cursor = this.Cursors.default\r\n      this.previousCursor_ = undefined\r\n    }\r\n\r\n    //dispatchEvent\r\n    this.dispatchEvent({\r\n      type: this.mode_ + 'end',\r\n      feature: this.selection_.item(0),\r\n      features: this.selection_,\r\n      oldgeom: this.geoms_[0],\r\n      oldgeoms: this.geoms_\r\n    })\r\n\r\n    this.drawSketch_()\r\n    this.mode_ = null\r\n    return false\r\n  }\r\n  /** Set the point radius to calculate handles on points\r\n   *  @param {number|Array<number>|function} [pointRadius=0] radius for points or a function that takes a feature and returns the radius (or [radiusX, radiusY]). If not null show handles to transform the points\r\n   */\r\n  setPointRadius(pointRadius) {\r\n    if (typeof (pointRadius) === 'function') {\r\n      this._pointRadius = pointRadius\r\n    } else {\r\n      this._pointRadius = function () { return pointRadius }\r\n    }\r\n  }\r\n  /** Get the features that are selected for transform\r\n   * @return ol.Collection\r\n   */\r\n  getFeatures() {\r\n    return this.selection_;\r\n  }\r\n  /**\r\n   * @private\r\n   */\r\n  _projectVectorOnVector(displacement_vector, base) {\r\n    var k = (displacement_vector[0] * base[0] + displacement_vector[1] * base[1]) / (base[0] * base[0] + base[1] * base[1]);\r\n    return [base[0] * k, base[1] * k];\r\n  }\r\n  /**\r\n   * @private\r\n   */\r\n  _countVector(start, end) {\r\n    return [end[0] - start[0], end[1] - start[1]];\r\n  }\r\n  /**\r\n   * @private\r\n   */\r\n  _movePoint(point, displacementVector) {\r\n    return [point[0]+displacementVector[0], point[1]+displacementVector[1]];\r\n  }\r\n  \r\n  \r\n}\r\n\r\n/** Cursors for transform\r\n*/\r\nol_interaction_Transform.prototype.Cursors = {\r\n  'default': 'auto',\r\n  'select': 'pointer',\r\n  'translate': 'move',\r\n  'rotate': 'move',\r\n  'rotate0': 'move',\r\n  'scale': 'nesw-resize',\r\n  'scale1': 'nwse-resize',\r\n  'scale2': 'nesw-resize',\r\n  'scale3': 'nwse-resize',\r\n  'scalev': 'ew-resize',\r\n  'scaleh1': 'ns-resize',\r\n  'scalev2': 'ew-resize',\r\n  'scaleh3': 'ns-resize'\r\n};\r\n\r\nexport default ol_interaction_Transform\r\n","import ol_source_Vector from 'ol/source/Vector.js'\r\n\r\n;(function () {\r\n  var clear = ol_source_Vector.prototype.clear;\r\n\r\n  /** Overwrite ol/source/Vector clear to fire clearstart / clearend event\r\n   */\r\n  ol_source_Vector.prototype.clear = function(opt_fast) {\r\n    this.dispatchEvent({ type: 'clearstart' });\r\n    clear.call(this, opt_fast)\r\n    this.dispatchEvent({ type: 'clearend' });\r\n  };\r\n})();\r\n","import ol_Collection from 'ol/Collection.js'\r\nimport ol_interaction_Interaction from 'ol/interaction/Interaction.js'\r\nimport ol_layer_Vector from 'ol/layer/Vector.js'\r\nimport {unByKey as ol_Observable_unByKey} from 'ol/Observable.js'\r\nimport '../source/Vector.js'\r\n\r\n/** Undo/redo interaction\r\n * @constructor\r\n * @extends {ol_interaction_Interaction}\r\n * @fires undo\r\n * @fires redo\r\n * @fires change:add\r\n * @fires change:remove\r\n * @fires change:clear\r\n * @param {Object} options\r\n *  @param {number=} options.maxLength max undo stack length (0=Infinity), default Infinity\r\n *  @param {Array<ol.Layer>} options.layers array of layers to undo/redo\r\n */\r\nvar ol_interaction_UndoRedo = class olinteractionUndoRedo extends ol_interaction_Interaction {\r\n  constructor(options) {\r\n    options = options || {}\r\n\r\n    super({\r\n      handleEvent: function () {\r\n        return true\r\n      }\r\n    })\r\n\r\n    //array of layers to undo/redo\r\n    this._layers = options.layers\r\n\r\n    this._undoStack = new ol_Collection()\r\n    this._redoStack = new ol_Collection()\r\n    // Zero level stack\r\n    this._undo = []\r\n    this._redo = []\r\n    this._undoStack.on('add', function (e) {\r\n      if (e.element.level === undefined) {\r\n        e.element.level = this._level\r\n        if (!e.element.level) {\r\n          e.element.view = {\r\n            center: this.getMap().getView().getCenter(),\r\n            zoom: this.getMap().getView().getZoom()\r\n          }\r\n          this._undo.push(e.element)\r\n        }\r\n      } else {\r\n        if (!e.element.level)\r\n          this._undo.push(this._redo.shift())\r\n      }\r\n      if (!e.element.level) {\r\n        this.dispatchEvent({\r\n          type: 'stack:add',\r\n          action: e.element\r\n        })\r\n      }\r\n      this._reduce()\r\n    }.bind(this))\r\n    this._undoStack.on('remove', function (e) {\r\n      if (!e.element.level) {\r\n        if (this._doShift) {\r\n          this._undo.shift()\r\n        } else {\r\n          if (this._undo.length)\r\n            this._redo.push(this._undo.pop())\r\n        }\r\n        if (!this._doClear) {\r\n          this.dispatchEvent({\r\n            type: 'stack:remove',\r\n            action: e.element,\r\n            shift: this._doShift\r\n          })\r\n        }\r\n      }\r\n    }.bind(this))\r\n    // Block counter\r\n    this._block = 0\r\n    this._level = 0\r\n    // Shift an undo action ?\r\n    this._doShift = false\r\n    // Start recording\r\n    this._record = true\r\n    // Custom definitions\r\n    this._defs = {}\r\n  }\r\n  /** Add a custom undo/redo\r\n   * @param {string} action the action key name\r\n   * @param {function} undoFn function called when undoing\r\n   * @param {function} redoFn function called when redoing\r\n   * @api\r\n   */\r\n  define(action, undoFn, redoFn) {\r\n    this._defs[action] = { undo: undoFn, redo: redoFn }\r\n  }\r\n  /** Get first level undo / redo length\r\n   * @param {string} [type] get redo stack length, default get undo\r\n   * @return {number}\r\n   */\r\n  length(type) {\r\n    return (type === 'redo') ? this._redo.length : this._undo.length\r\n  }\r\n  /** Set undo stack max length\r\n   * @param {number} length\r\n   */\r\n  setMaxLength(length) {\r\n    length = parseInt(length)\r\n    if (length && length < 0)\r\n      length = 0\r\n    this.set('maxLength', length)\r\n    this._reduce()\r\n  }\r\n  /** Get undo / redo size (includes all block levels)\r\n   * @param {string} [type] get redo stack length, default get undo\r\n   * @return {number}\r\n   */\r\n  size(type) {\r\n    return (type === 'redo') ? this._redoStack.getLength() : this._undoStack.getLength()\r\n  }\r\n  /** Set undo stack max size\r\n   * @param {number} size\r\n   */\r\n  setMaxSize(size) {\r\n    size = parseInt(size)\r\n    if (size && size < 0)\r\n      size = 0\r\n    this.set('maxSize', size)\r\n    this._reduce()\r\n  }\r\n  /** Reduce stack: shift undo to set size\r\n   * @private\r\n   */\r\n  _reduce() {\r\n    if (this.get('maxLength')) {\r\n      while (this.length() > this.get('maxLength')) {\r\n        this.shift()\r\n      }\r\n    }\r\n    if (this.get('maxSize')) {\r\n      while (this.length() > 1 && this.size() > this.get('maxSize')) {\r\n        this.shift()\r\n      }\r\n    }\r\n  }\r\n  /** Get first level undo / redo first level stack\r\n   * @param {string} [type] get redo stack, default get undo\r\n   * @return {Array<*>}\r\n   */\r\n  getStack(type) {\r\n    return (type === 'redo') ? this._redo : this._undo\r\n  }\r\n  /** Add a new custom undo/redo\r\n   * @param {string} action the action key name\r\n   * @param {any} prop an object that will be passed in the undo/redo functions of the action\r\n   * @param {string} name action name\r\n   * @return {boolean} true if the action is defined\r\n   */\r\n  push(action, prop, name) {\r\n    if (this._defs[action]) {\r\n      this._undoStack.push({\r\n        type: action,\r\n        name: name,\r\n        custom: true,\r\n        prop: prop\r\n      })\r\n      return true\r\n    } else {\r\n      console.warn('[UndoRedoInteraction]: \"' + action + '\" is not defined.')\r\n      return false\r\n    }\r\n  }\r\n  /** Remove undo action from the beginning of the stack.\r\n   * The action is not returned.\r\n   */\r\n  shift() {\r\n    this._doShift = true\r\n    var a = this._undoStack.removeAt(0)\r\n    this._doShift = false\r\n    // Remove all block\r\n    if (a.type === 'blockstart') {\r\n      a = this._undoStack.item(0)\r\n      while (this._undoStack.getLength() && a.level > 0) {\r\n        this._undoStack.removeAt(0)\r\n        a = this._undoStack.item(0)\r\n      }\r\n    }\r\n  }\r\n  /** Activate or deactivate the interaction, ie. records or not events on the map.\r\n   * @param {boolean} active\r\n   * @api stable\r\n   */\r\n  setActive(active) {\r\n    super.setActive(active)\r\n    this._record = active\r\n  }\r\n  /**\r\n   * Remove the interaction from its current map, if any, and attach it to a new\r\n   * map, if any. Pass `null` to just remove the interaction from the current map.\r\n   * @param {ol.Map} map Map.\r\n   * @api stable\r\n   */\r\n  setMap(map) {\r\n    if (this._mapListener) {\r\n      this._mapListener.forEach(function (l) { ol_Observable_unByKey(l) })\r\n    }\r\n    this._mapListener = []\r\n    super.setMap(map)\r\n    // Watch blocks\r\n    if (map) {\r\n      this._mapListener.push(map.on('undoblockstart', this.blockStart.bind(this)))\r\n      this._mapListener.push(map.on('undoblockend', this.blockEnd.bind(this)))\r\n    }\r\n    // Watch sources\r\n    this._watchSources()\r\n    this._watchInteractions()\r\n  }\r\n  /** Watch for changes in the map sources\r\n   * @private\r\n   */\r\n  _watchSources() {\r\n    var map = this.getMap()\r\n    // Clear listeners\r\n    if (this._sourceListener) {\r\n      this._sourceListener.forEach(function (l) { ol_Observable_unByKey(l) })\r\n    }\r\n    this._sourceListener = []\r\n\r\n    var self = this\r\n\r\n    // Ges vector layers \r\n    function getVectorLayers(layers, init) {\r\n      if (!init)\r\n        init = []\r\n      layers.forEach(function (l) {\r\n        if (l instanceof ol_layer_Vector) {\r\n          if (!self._layers || self._layers.indexOf(l) >= 0) {\r\n            init.push(l)\r\n          }\r\n        } else if (l.getLayers) {\r\n          getVectorLayers(l.getLayers(), init)\r\n        }\r\n      })\r\n      return init\r\n    }\r\n\r\n    if (map) {\r\n      // Watch the vector sources in the map \r\n      var vectors = getVectorLayers(map.getLayers())\r\n      vectors.forEach((function (l) {\r\n        var s = l.getSource()\r\n        this._sourceListener.push(s.on(['addfeature', 'removefeature'], this._onAddRemove.bind(this)))\r\n        this._sourceListener.push(s.on('clearstart', function () {\r\n          this.blockStart('clear')\r\n        }.bind(this)))\r\n        this._sourceListener.push(s.on('clearend', this.blockEnd.bind(this)))\r\n      }).bind(this))\r\n\r\n      // Watch new inserted/removed\r\n      this._sourceListener.push(map.getLayers().on(['add', 'remove'], this._watchSources.bind(this)))\r\n    }\r\n  }\r\n  /** Watch for interactions\r\n   * @private\r\n   */\r\n  _watchInteractions() {\r\n    var map = this.getMap()\r\n    // Clear listeners\r\n    if (this._interactionListener) {\r\n      this._interactionListener.forEach(function (l) { ol_Observable_unByKey(l) })\r\n    }\r\n    this._interactionListener = []\r\n\r\n    if (map) {\r\n      // Watch the interactions in the map \r\n      map.getInteractions().forEach((function (i) {\r\n        this._interactionListener.push(i.on(\r\n          ['setattributestart', 'modifystart', 'rotatestart', 'translatestart', 'scalestart', 'deletestart', 'deleteend', 'beforesplit', 'aftersplit'],\r\n          this._onInteraction.bind(this)\r\n        ))\r\n      }).bind(this))\r\n\r\n      // Watch new inserted / unwatch removed\r\n      this._interactionListener.push(map.getInteractions().on(\r\n        ['add', 'remove'],\r\n        this._watchInteractions.bind(this)\r\n      ))\r\n    }\r\n  }\r\n  /** A feature is added / removed\r\n   */\r\n  _onAddRemove(e) {\r\n    if (this._record) {\r\n      this._redoStack.clear()\r\n      this._redo.length = 0\r\n      this._undoStack.push({\r\n        type: e.type,\r\n        source: e.target,\r\n        feature: e.feature\r\n      })\r\n    }\r\n  }\r\n  /** Perform an interaction\r\n   * @private\r\n   */\r\n  _onInteraction(e) {\r\n    var fn = this._onInteraction[e.type]\r\n    if (fn)\r\n      fn.call(this, e)\r\n  }\r\n  /** Start an undo block\r\n   * @param {string} [name] name f the action\r\n   * @api\r\n   */\r\n  blockStart(name) {\r\n    this._redoStack.clear()\r\n    this._redo.length = 0\r\n    this._undoStack.push({\r\n      type: 'blockstart',\r\n      name: name\r\n    })\r\n    this._level++\r\n  }\r\n  /** End an undo block\r\n   * @api\r\n   */\r\n  blockEnd() {\r\n    this._undoStack.push({ type: 'blockend' })\r\n    this._level--\r\n  }\r\n  /** handle undo/redo\r\n   * @private\r\n   */\r\n  _handleDo(e, undo) {\r\n    // Not active\r\n    if (!this.getActive())\r\n      return\r\n\r\n    // Stop recording while undoing\r\n    this._record = false\r\n    if (e.custom) {\r\n      if (this._defs[e.type]) {\r\n        if (undo)\r\n          this._defs[e.type].undo(e.prop)\r\n        else\r\n          this._defs[e.type].redo(e.prop)\r\n      } else {\r\n        console.warn('[UndoRedoInteraction]: \"' + e.type + '\" is not defined.')\r\n      }\r\n    } else {\r\n      switch (e.type) {\r\n        case 'addfeature': {\r\n          if (undo)\r\n            e.source.removeFeature(e.feature)\r\n          else\r\n            e.source.addFeature(e.feature)\r\n          break\r\n        }\r\n        case 'removefeature': {\r\n          if (undo)\r\n            e.source.addFeature(e.feature)\r\n          else\r\n            e.source.removeFeature(e.feature)\r\n          break\r\n        }\r\n        case 'changegeometry': {\r\n          var geom = e.feature.getGeometry()\r\n          e.feature.setGeometry(e.oldGeom)\r\n          e.oldGeom = geom\r\n          break\r\n        }\r\n        case 'changeattribute': {\r\n          var newp = e.newProperties\r\n          var oldp = e.oldProperties\r\n          for (var p in oldp) {\r\n            if (oldp === undefined)\r\n              e.feature.unset(p)\r\n            else\r\n              e.feature.set(p, oldp[p])\r\n          }\r\n          e.oldProperties = newp\r\n          e.newProperties = oldp\r\n          break\r\n        }\r\n        case 'blockstart': {\r\n          this._block += undo ? -1 : 1\r\n          break\r\n        }\r\n        case 'blockend': {\r\n          this._block += undo ? 1 : -1\r\n          break\r\n        }\r\n        default: {\r\n          console.warn('[UndoRedoInteraction]: \"' + e.type + '\" is not defined.')\r\n        }\r\n      }\r\n    }\r\n\r\n    // Handle block\r\n    if (this._block < 0)\r\n      this._block = 0\r\n    if (this._block) {\r\n      if (undo)\r\n        this.undo()\r\n      else\r\n        this.redo()\r\n    }\r\n    this._record = true\r\n\r\n    // Dispatch event\r\n    this.dispatchEvent({\r\n      type: undo ? 'undo' : 'redo',\r\n      action: e\r\n    })\r\n  }\r\n  /** Undo last operation\r\n   * @api\r\n   */\r\n  undo() {\r\n    var e = this._undoStack.item(this._undoStack.getLength() - 1)\r\n    if (!e)\r\n      return\r\n    this._redoStack.push(e)\r\n    this._undoStack.pop()\r\n    this._handleDo(e, true)\r\n  }\r\n  /** Redo last operation\r\n   * @api\r\n   */\r\n  redo() {\r\n    var e = this._redoStack.item(this._redoStack.getLength() - 1)\r\n    if (!e)\r\n      return\r\n    this._undoStack.push(e)\r\n    this._redoStack.pop()\r\n    this._handleDo(e, false)\r\n  }\r\n  /** Clear undo stack\r\n   * @api\r\n   */\r\n  clear() {\r\n    this._doClear = true\r\n    this._undo.length = this._redo.length = 0\r\n    this._undoStack.clear()\r\n    this._redoStack.clear()\r\n    this._doClear = false\r\n    this.dispatchEvent({ type: 'stack:clear' })\r\n  }\r\n  /** Check if undo is avaliable\r\n   * @return {number} the number of undo\r\n   * @api\r\n   */\r\n  hasUndo() {\r\n    return this._undoStack.getLength()\r\n  }\r\n  /** Check if redo is avaliable\r\n   * @return {number} the number of redo\r\n   * @api\r\n   */\r\n  hasRedo() {\r\n    return this._redoStack.getLength()\r\n  }\r\n}\r\n\r\n/** Set attribute\r\n * @private\r\n */\r\nol_interaction_UndoRedo.prototype._onInteraction.setattributestart = function(e) {\r\n  this.blockStart(e.target.get('name') || 'setattribute');\r\n  var newp = Object.assign({}, e.properties);\r\n  e.features.forEach(function(f) {\r\n    var oldp = {};\r\n    for (var p in newp) {\r\n      oldp[p] = f.get(p);\r\n    }\r\n    this._undoStack.push({\r\n      type: 'changeattribute', \r\n      feature: f,\r\n      newProperties: newp,\r\n      oldProperties: oldp\r\n    });\r\n  }.bind(this));\r\n  this.blockEnd();\r\n};\r\n\r\nol_interaction_UndoRedo.prototype._onInteraction.rotatestart = \r\nol_interaction_UndoRedo.prototype._onInteraction.translatestart = \r\nol_interaction_UndoRedo.prototype._onInteraction.scalestart = \r\nol_interaction_UndoRedo.prototype._onInteraction.modifystart = function (e) {\r\n  this.blockStart(e.type.replace(/start$/,''));\r\n  e.features.forEach(function(m) {\r\n    this._undoStack.push({ \r\n      type: 'changegeometry', \r\n      feature: m, \r\n      oldGeom: m.getGeometry().clone() \r\n    });\r\n  }.bind(this));\r\n  this.blockEnd();\r\n};\r\n\r\n\r\n/** @private\r\n */\r\nol_interaction_UndoRedo.prototype._onInteraction.beforesplit = function() {\r\n  // Check modify before split\r\n  var l = this._undoStack.getLength();\r\n  if (l>2 \r\n    && this._undoStack.item(l-1).type === 'blockend'\r\n    && this._undoStack.item(l-2).type === 'changegeometry') {\r\n    this._undoStack.pop();\r\n  } else {\r\n    this.blockStart('split');\r\n  }\r\n};\r\nol_interaction_UndoRedo.prototype._onInteraction.deletestart = function() {\r\n  this.blockStart('delete');\r\n}\r\n\r\n\r\n/** @private\r\n */\r\nol_interaction_UndoRedo.prototype._onInteraction.aftersplit =\r\nol_interaction_UndoRedo.prototype._onInteraction.deleteend =\r\nol_interaction_UndoRedo.prototype.blockEnd;\r\n\r\nexport default ol_interaction_UndoRedo\r\n","import ol_style_Style from 'ol/style/Style.js'\r\nimport ol_style_Circle from 'ol/style/Circle.js'\r\nimport ol_style_Stroke from 'ol/style/Stroke.js'\r\nimport ol_style_Fill from 'ol/style/Fill.js'\r\n\r\nvar ol_style_Style_defaultStyle;\r\n\r\n(function() {\r\n\r\n// Style\r\nvar white = [255, 255, 255, 1];\r\nvar blue = [0, 153, 255, 1];\r\nvar width = 3;\r\n\r\nvar defaultEditStyle = [\r\n  new ol_style_Style({\r\n    stroke: new ol_style_Stroke({ color: white, width: width + 2 })\r\n  }),\r\n  new ol_style_Style({\r\n    image: new ol_style_Circle({\r\n      radius: width * 2,\r\n      fill: new ol_style_Fill({ color: blue }),\r\n      stroke: new ol_style_Stroke({ color: white, width: width / 2 })\r\n    }),\r\n    stroke: new ol_style_Stroke({ color: blue, width: width }),\r\n    fill: new ol_style_Fill({\r\n      color: [255, 255, 255, 0.5]\r\n    })\r\n  })\r\n];\r\n\r\n/**\r\n * Get the default style\r\n * @param {boolean|*} [edit] true to get editing style or a { color, fillColor } object, default get default blue style\r\n * @return {Array<ol.style.Style>}\r\n */\r\nol_style_Style_defaultStyle = function(edit) {\r\n  if (edit===true) {\r\n    return defaultEditStyle;\r\n  } else {\r\n    edit = edit || {};\r\n    var fill = new ol_style_Fill({\r\n      color: edit.fillColor || 'rgba(255,255,255,0.4)'\r\n    });\r\n    var stroke = new ol_style_Stroke({\r\n      color: edit.color || '#3399CC',\r\n      width: 1.25\r\n    });\r\n    var style = new ol_style_Style({\r\n      image: new ol_style_Circle({\r\n        fill: fill,\r\n        stroke: stroke,\r\n        radius: 5\r\n      }),\r\n      fill: fill,\r\n      stroke: stroke\r\n    });\r\n    return [ style ];\r\n  }\r\n};\r\n\r\n})();\r\n\r\nexport default ol_style_Style_defaultStyle\r\n","/**\n * @module ol/geom/Circle\n */\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {createOrUpdate, forEachCorner, intersects} from '../extent.js';\nimport {deflateCoordinate} from './flat/deflate.js';\nimport {rotate} from './flat/transform.js';\n\n/**\n * @classdesc\n * Circle geometry.\n *\n * @api\n */\nclass Circle extends SimpleGeometry {\n  /**\n   * @param {!import(\"../coordinate.js\").Coordinate} center Center.\n   *     For internal use, flat coordinates in combination with `layout` and no\n   *     `radius` are also accepted.\n   * @param {number} [radius] Radius in units of the projection.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   */\n  constructor(center, radius, layout) {\n    super();\n    if (layout !== undefined && radius === undefined) {\n      this.setFlatCoordinates(layout, center);\n    } else {\n      radius = radius ? radius : 0;\n      this.setCenterAndRadius(center, radius, layout);\n    }\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!Circle} Clone.\n   * @api\n   */\n  clone() {\n    const circle = new Circle(\n      this.flatCoordinates.slice(),\n      undefined,\n      this.layout\n    );\n    circle.applyProperties(this);\n    return circle;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    const flatCoordinates = this.flatCoordinates;\n    const dx = x - flatCoordinates[0];\n    const dy = y - flatCoordinates[1];\n    const squaredDistance = dx * dx + dy * dy;\n    if (squaredDistance < minSquaredDistance) {\n      if (squaredDistance === 0) {\n        for (let i = 0; i < this.stride; ++i) {\n          closestPoint[i] = flatCoordinates[i];\n        }\n      } else {\n        const delta = this.getRadius() / Math.sqrt(squaredDistance);\n        closestPoint[0] = flatCoordinates[0] + delta * dx;\n        closestPoint[1] = flatCoordinates[1] + delta * dy;\n        for (let i = 2; i < this.stride; ++i) {\n          closestPoint[i] = flatCoordinates[i];\n        }\n      }\n      closestPoint.length = this.stride;\n      return squaredDistance;\n    }\n    return minSquaredDistance;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @return {boolean} Contains (x, y).\n   */\n  containsXY(x, y) {\n    const flatCoordinates = this.flatCoordinates;\n    const dx = x - flatCoordinates[0];\n    const dy = y - flatCoordinates[1];\n    return dx * dx + dy * dy <= this.getRadiusSquared_();\n  }\n\n  /**\n   * Return the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.\n   * @return {import(\"../coordinate.js\").Coordinate} Center.\n   * @api\n   */\n  getCenter() {\n    return this.flatCoordinates.slice(0, this.stride);\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @protected\n   * @return {import(\"../extent.js\").Extent} extent Extent.\n   */\n  computeExtent(extent) {\n    const flatCoordinates = this.flatCoordinates;\n    const radius = flatCoordinates[this.stride] - flatCoordinates[0];\n    return createOrUpdate(\n      flatCoordinates[0] - radius,\n      flatCoordinates[1] - radius,\n      flatCoordinates[0] + radius,\n      flatCoordinates[1] + radius,\n      extent\n    );\n  }\n\n  /**\n   * Return the radius of the circle.\n   * @return {number} Radius.\n   * @api\n   */\n  getRadius() {\n    return Math.sqrt(this.getRadiusSquared_());\n  }\n\n  /**\n   * @private\n   * @return {number} Radius squared.\n   */\n  getRadiusSquared_() {\n    const dx = this.flatCoordinates[this.stride] - this.flatCoordinates[0];\n    const dy = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];\n    return dx * dx + dy * dy;\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   */\n  getType() {\n    return 'Circle';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   */\n  intersectsExtent(extent) {\n    const circleExtent = this.getExtent();\n    if (intersects(extent, circleExtent)) {\n      const center = this.getCenter();\n\n      if (extent[0] <= center[0] && extent[2] >= center[0]) {\n        return true;\n      }\n      if (extent[1] <= center[1] && extent[3] >= center[1]) {\n        return true;\n      }\n\n      return forEachCorner(extent, this.intersectsCoordinate.bind(this));\n    }\n    return false;\n  }\n\n  /**\n   * Set the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.\n   * @param {import(\"../coordinate.js\").Coordinate} center Center.\n   * @api\n   */\n  setCenter(center) {\n    const stride = this.stride;\n    const radius = this.flatCoordinates[stride] - this.flatCoordinates[0];\n    const flatCoordinates = center.slice();\n    flatCoordinates[stride] = flatCoordinates[0] + radius;\n    for (let i = 1; i < stride; ++i) {\n      flatCoordinates[stride + i] = center[i];\n    }\n    this.setFlatCoordinates(this.layout, flatCoordinates);\n    this.changed();\n  }\n\n  /**\n   * Set the center (as {@link module:ol/coordinate~Coordinate coordinate}) and the radius (as\n   * number) of the circle.\n   * @param {!import(\"../coordinate.js\").Coordinate} center Center.\n   * @param {number} radius Radius.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @api\n   */\n  setCenterAndRadius(center, radius, layout) {\n    this.setLayout(layout, center, 0);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    /** @type {Array<number>} */\n    const flatCoordinates = this.flatCoordinates;\n    let offset = deflateCoordinate(flatCoordinates, 0, center, this.stride);\n    flatCoordinates[offset++] = flatCoordinates[0] + radius;\n    for (let i = 1, ii = this.stride; i < ii; ++i) {\n      flatCoordinates[offset++] = flatCoordinates[i];\n    }\n    flatCoordinates.length = offset;\n    this.changed();\n  }\n\n  getCoordinates() {\n    return null;\n  }\n\n  setCoordinates(coordinates, layout) {}\n\n  /**\n   * Set the radius of the circle. The radius is in the units of the projection.\n   * @param {number} radius Radius.\n   * @api\n   */\n  setRadius(radius) {\n    this.flatCoordinates[this.stride] = this.flatCoordinates[0] + radius;\n    this.changed();\n  }\n\n  /**\n   * Rotate the geometry around a given coordinate. This modifies the geometry\n   * coordinates in place.\n   * @param {number} angle Rotation angle in counter-clockwise radians.\n   * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\n   * @api\n   */\n  rotate(angle, anchor) {\n    const center = this.getCenter();\n    const stride = this.getStride();\n    this.setCenter(\n      rotate(center, 0, center.length, stride, angle, anchor, center)\n    );\n    this.changed();\n  }\n}\n\n/**\n * Transform each coordinate of the circle from one coordinate reference system\n * to another. The geometry is modified in place.\n * If you do not want the geometry modified in place, first clone() it and\n * then use this function on the clone.\n *\n * Internally a circle is currently represented by two points: the center of\n * the circle `[cx, cy]`, and the point to the right of the circle\n * `[cx + r, cy]`. This `transform` function just transforms these two points.\n * So the resulting geometry is also a circle, and that circle does not\n * correspond to the shape that would be obtained by transforming every point\n * of the original circle.\n *\n * @param {import(\"../proj.js\").ProjectionLike} source The current projection.  Can be a\n *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n * @param {import(\"../proj.js\").ProjectionLike} destination The desired projection.  Can be a\n *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n * @return {Circle} This geometry.  Note that original geometry is\n *     modified in place.\n * @function\n * @api\n */\nCircle.prototype.transform;\nexport default Circle;\n","/**\n * @module ol/interaction/Draw\n */\nimport Circle from '../geom/Circle.js';\nimport Event from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport Feature from '../Feature.js';\nimport GeometryCollection from '../geom/GeometryCollection.js';\nimport InteractionProperty from './Property.js';\nimport LineString from '../geom/LineString.js';\nimport MapBrowserEvent from '../MapBrowserEvent.js';\nimport MapBrowserEventType from '../MapBrowserEventType.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport PointerInteraction from './Pointer.js';\nimport Polygon, {fromCircle, makeRegular} from '../geom/Polygon.js';\nimport VectorLayer from '../layer/Vector.js';\nimport VectorSource from '../source/Vector.js';\nimport {FALSE, TRUE} from '../functions.js';\nimport {\n  always,\n  never,\n  noModifierKeys,\n  shiftKeyOnly,\n} from '../events/condition.js';\nimport {\n  boundingExtent,\n  getBottomLeft,\n  getBottomRight,\n  getTopLeft,\n  getTopRight,\n} from '../extent.js';\nimport {clamp, squaredDistance, toFixed} from '../math.js';\nimport {createEditingStyle} from '../style/Style.js';\nimport {\n  distance,\n  squaredDistance as squaredCoordinateDistance,\n} from '../coordinate.js';\nimport {fromUserCoordinate, getUserProjection} from '../proj.js';\nimport {getStrideForLayout} from '../geom/SimpleGeometry.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../geom/Geometry.js\").Type} type Geometry type of\n * the geometries being drawn with this instance.\n * @property {number} [clickTolerance=6] The maximum distance in pixels between\n * \"down\" and \"up\" for a \"up\" event to be considered a \"click\" event and\n * actually add a point/vertex to the geometry being drawn.  The default of `6`\n * was chosen for the draw interaction to behave correctly on mouse as well as\n * on touch devices.\n * @property {import(\"../Collection.js\").default<Feature>} [features]\n * Destination collection for the drawn features.\n * @property {VectorSource} [source] Destination source for\n * the drawn features.\n * @property {number} [dragVertexDelay=500] Delay in milliseconds after pointerdown\n * before the current vertex can be dragged to its exact position.\n * @property {number} [snapTolerance=12] Pixel distance for snapping to the\n * drawing finish. Must be greater than `0`.\n * @property {boolean} [stopClick=false] Stop click, singleclick, and\n * doubleclick events from firing during drawing.\n * @property {number} [maxPoints] The number of points that can be drawn before\n * a polygon ring or line string is finished. By default there is no\n * restriction.\n * @property {number} [minPoints] The number of points that must be drawn\n * before a polygon ring or line string can be finished. Default is `3` for\n * polygon rings and `2` for line strings.\n * @property {import(\"../events/condition.js\").Condition} [finishCondition] A function\n * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether the drawing can be finished. Not used when drawing\n * POINT or MULTI_POINT geometries.\n * @property {import(\"../style/Style.js\").StyleLike|import(\"../style/flat.js\").FlatStyleLike} [style]\n * Style for sketch features.\n * @property {GeometryFunction} [geometryFunction]\n * Function that is called when a geometry's coordinates are updated.\n * @property {string} [geometryName] Geometry name to use for features created\n * by the draw interaction.\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * By default {@link module:ol/events/condition.noModifierKeys}, i.e. a click,\n * adds a vertex or deactivates freehand drawing.\n * @property {boolean} [freehand=false] Operate in freehand mode for lines,\n * polygons, and circles.  This makes the interaction always operate in freehand\n * mode and takes precedence over any `freehandCondition` option.\n * @property {import(\"../events/condition.js\").Condition} [freehandCondition]\n * Condition that activates freehand drawing for lines and polygons. This\n * function takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and\n * returns a boolean to indicate whether that event should be handled. The\n * default is {@link module:ol/events/condition.shiftKeyOnly}, meaning that the\n * Shift key activates freehand drawing.\n * @property {boolean|import(\"../events/condition.js\").Condition} [trace=false] Trace a portion of another geometry.\n * Ignored when in freehand mode.\n * @property {VectorSource} [traceSource] Source for features to trace.  If tracing is active and a `traceSource` is\n * not provided, the interaction's `source` will be used.  Tracing requires that the interaction is configured with\n * either a `traceSource` or a `source`.\n * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch\n * overlay.\n * @property {import(\"../geom/Geometry.js\").GeometryLayout} [geometryLayout='XY'] Layout of the\n * feature geometries created by the draw interaction.\n */\n\n/**\n * Coordinate type when drawing points.\n * @typedef {import(\"../coordinate.js\").Coordinate} PointCoordType\n */\n\n/**\n * Coordinate type when drawing lines.\n * @typedef {Array<import(\"../coordinate.js\").Coordinate>} LineCoordType\n */\n\n/**\n * Coordinate type when drawing polygons.\n * @typedef {Array<Array<import(\"../coordinate.js\").Coordinate>>} PolyCoordType\n */\n\n/**\n * Types used for drawing coordinates.\n * @typedef {PointCoordType|LineCoordType|PolyCoordType} SketchCoordType\n */\n\n/**\n * @typedef {Object} TraceState\n * @property {boolean} active Tracing active.\n * @property {import(\"../pixel.js\").Pixel} [startPx] The initially clicked pixel location.\n * @property {Array<TraceTarget>} [targets] Targets available for tracing.\n * @property {number} [targetIndex] The index of the currently traced target.  A value of -1 indicates\n * that no trace target is active.\n */\n\n/**\n * @typedef {Object} TraceTarget\n * @property {Array<import(\"../coordinate.js\").Coordinate>} coordinates Target coordinates.\n * @property {boolean} ring The target coordinates are a linear ring.\n * @property {number} startIndex The index of first traced coordinate.  A fractional index represents an\n * edge intersection.  Index values for rings will wrap (may be negative or larger than coordinates length).\n * @property {number} endIndex The index of last traced coordinate.  Details from startIndex also apply here.\n */\n\n/**\n * Function that takes an array of coordinates and an optional existing geometry\n * and a projection as arguments, and returns a geometry. The optional existing\n * geometry is the geometry that is returned when the function is called without\n * a second argument.\n * @typedef {function(!SketchCoordType, import(\"../geom/SimpleGeometry.js\").default,\n *     import(\"../proj/Projection.js\").default):\n *     import(\"../geom/SimpleGeometry.js\").default} GeometryFunction\n */\n\n/**\n * @typedef {'Point' | 'LineString' | 'Polygon' | 'Circle'} Mode\n * Draw mode.  This collapses multi-part geometry types with their single-part\n * cousins.\n */\n\n/**\n * @enum {string}\n */\nconst DrawEventType = {\n  /**\n   * Triggered upon feature draw start\n   * @event DrawEvent#drawstart\n   * @api\n   */\n  DRAWSTART: 'drawstart',\n  /**\n   * Triggered upon feature draw end\n   * @event DrawEvent#drawend\n   * @api\n   */\n  DRAWEND: 'drawend',\n  /**\n   * Triggered upon feature draw abortion\n   * @event DrawEvent#drawabort\n   * @api\n   */\n  DRAWABORT: 'drawabort',\n};\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/Draw~Draw} instances are\n * instances of this type.\n */\nexport class DrawEvent extends Event {\n  /**\n   * @param {DrawEventType} type Type.\n   * @param {Feature} feature The feature drawn.\n   */\n  constructor(type, feature) {\n    super(type);\n\n    /**\n     * The feature being drawn.\n     * @type {Feature}\n     * @api\n     */\n    this.feature = feature;\n  }\n}\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} coordinate The coordinate.\n * @param {Array<Feature>} features The candidate features.\n * @return {Array<TraceTarget>} The trace targets.\n */\nfunction getTraceTargets(coordinate, features) {\n  /**\n   * @type {Array<TraceTarget>}\n   */\n  const targets = [];\n\n  for (let i = 0; i < features.length; ++i) {\n    const feature = features[i];\n    const geometry = feature.getGeometry();\n    appendGeometryTraceTargets(coordinate, geometry, targets);\n  }\n\n  return targets;\n}\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} a One coordinate.\n * @param {import(\"../coordinate.js\").Coordinate} b Another coordinate.\n * @return {number} The squared distance between the two coordinates.\n */\nfunction getSquaredDistance(a, b) {\n  return squaredDistance(a[0], a[1], b[0], b[1]);\n}\n\n/**\n * @param {LineCoordType} coordinates The ring coordinates.\n * @param {number} index The index.  May be wrapped.\n * @return {import(\"../coordinate.js\").Coordinate} The coordinate.\n */\nfunction getCoordinate(coordinates, index) {\n  const count = coordinates.length;\n  if (index < 0) {\n    return coordinates[index + count];\n  }\n  if (index >= count) {\n    return coordinates[index - count];\n  }\n  return coordinates[index];\n}\n\n/**\n * Get the cumulative squared distance along a ring path.  The end index index may be \"wrapped\" and it may\n * be less than the start index to indicate the direction of travel.  The start and end index may have\n * a fractional part to indicate a point between two coordinates.\n * @param {LineCoordType} coordinates Ring coordinates.\n * @param {number} startIndex The start index.\n * @param {number} endIndex The end index.\n * @return {number} The cumulative squared distance along the ring path.\n */\nfunction getCumulativeSquaredDistance(coordinates, startIndex, endIndex) {\n  let lowIndex, highIndex;\n  if (startIndex < endIndex) {\n    lowIndex = startIndex;\n    highIndex = endIndex;\n  } else {\n    lowIndex = endIndex;\n    highIndex = startIndex;\n  }\n  const lowWholeIndex = Math.ceil(lowIndex);\n  const highWholeIndex = Math.floor(highIndex);\n\n  if (lowWholeIndex > highWholeIndex) {\n    // both start and end are on the same segment\n    const start = interpolateCoordinate(coordinates, lowIndex);\n    const end = interpolateCoordinate(coordinates, highIndex);\n    return getSquaredDistance(start, end);\n  }\n\n  let sd = 0;\n\n  if (lowIndex < lowWholeIndex) {\n    const start = interpolateCoordinate(coordinates, lowIndex);\n    const end = getCoordinate(coordinates, lowWholeIndex);\n    sd += getSquaredDistance(start, end);\n  }\n\n  if (highWholeIndex < highIndex) {\n    const start = getCoordinate(coordinates, highWholeIndex);\n    const end = interpolateCoordinate(coordinates, highIndex);\n    sd += getSquaredDistance(start, end);\n  }\n\n  for (let i = lowWholeIndex; i < highWholeIndex - 1; ++i) {\n    const start = getCoordinate(coordinates, i);\n    const end = getCoordinate(coordinates, i + 1);\n    sd += getSquaredDistance(start, end);\n  }\n\n  return sd;\n}\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} coordinate The coordinate.\n * @param {import(\"../geom/Geometry.js\").default} geometry The candidate geometry.\n * @param {Array<TraceTarget>} targets The trace targets.\n */\nfunction appendGeometryTraceTargets(coordinate, geometry, targets) {\n  if (geometry instanceof LineString) {\n    appendTraceTarget(coordinate, geometry.getCoordinates(), false, targets);\n    return;\n  }\n  if (geometry instanceof MultiLineString) {\n    const coordinates = geometry.getCoordinates();\n    for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n      appendTraceTarget(coordinate, coordinates[i], false, targets);\n    }\n    return;\n  }\n  if (geometry instanceof Polygon) {\n    const coordinates = geometry.getCoordinates();\n    for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n      appendTraceTarget(coordinate, coordinates[i], true, targets);\n    }\n    return;\n  }\n  if (geometry instanceof MultiPolygon) {\n    const polys = geometry.getCoordinates();\n    for (let i = 0, ii = polys.length; i < ii; ++i) {\n      const coordinates = polys[i];\n      for (let j = 0, jj = coordinates.length; j < jj; ++j) {\n        appendTraceTarget(coordinate, coordinates[j], true, targets);\n      }\n    }\n    return;\n  }\n  if (geometry instanceof GeometryCollection) {\n    const geometries = geometry.getGeometries();\n    for (let i = 0; i < geometries.length; ++i) {\n      appendGeometryTraceTargets(coordinate, geometries[i], targets);\n    }\n    return;\n  }\n  // other types cannot be traced\n}\n\n/**\n * @typedef {Object} TraceTargetUpdateInfo\n * @property {number} index The new target index.\n * @property {number} endIndex The new segment end index.\n */\n\n/**\n * @type {TraceTargetUpdateInfo}\n */\nconst sharedUpdateInfo = {index: -1, endIndex: NaN};\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} coordinate The coordinate.\n * @param {TraceState} traceState The trace state.\n * @param {import(\"../Map.js\").default} map The map.\n * @param {number} snapTolerance The snap tolerance.\n * @return {TraceTargetUpdateInfo} Information about the new trace target.  The returned\n * object is reused between calls and must not be modified by the caller.\n */\nfunction getTraceTargetUpdate(coordinate, traceState, map, snapTolerance) {\n  const x = coordinate[0];\n  const y = coordinate[1];\n\n  let closestTargetDistance = Infinity;\n\n  let newTargetIndex = -1;\n  let newEndIndex = NaN;\n\n  for (\n    let targetIndex = 0;\n    targetIndex < traceState.targets.length;\n    ++targetIndex\n  ) {\n    const target = traceState.targets[targetIndex];\n    const coordinates = target.coordinates;\n\n    let minSegmentDistance = Infinity;\n    let endIndex;\n    for (\n      let coordinateIndex = 0;\n      coordinateIndex < coordinates.length - 1;\n      ++coordinateIndex\n    ) {\n      const start = coordinates[coordinateIndex];\n      const end = coordinates[coordinateIndex + 1];\n      const rel = getPointSegmentRelationship(x, y, start, end);\n      if (rel.squaredDistance < minSegmentDistance) {\n        minSegmentDistance = rel.squaredDistance;\n        endIndex = coordinateIndex + rel.along;\n      }\n    }\n\n    if (minSegmentDistance < closestTargetDistance) {\n      closestTargetDistance = minSegmentDistance;\n      if (target.ring && traceState.targetIndex === targetIndex) {\n        // same target, maintain the same trace direction\n        if (target.endIndex > target.startIndex) {\n          // forward trace\n          if (endIndex < target.startIndex) {\n            endIndex += coordinates.length;\n          }\n        } else if (target.endIndex < target.startIndex) {\n          // reverse trace\n          if (endIndex > target.startIndex) {\n            endIndex -= coordinates.length;\n          }\n        }\n      }\n      newEndIndex = endIndex;\n      newTargetIndex = targetIndex;\n    }\n  }\n\n  const newTarget = traceState.targets[newTargetIndex];\n  let considerBothDirections = newTarget.ring;\n  if (traceState.targetIndex === newTargetIndex && considerBothDirections) {\n    // only consider switching trace direction if close to the start\n    const newCoordinate = interpolateCoordinate(\n      newTarget.coordinates,\n      newEndIndex\n    );\n    const pixel = map.getPixelFromCoordinate(newCoordinate);\n    if (distance(pixel, traceState.startPx) > snapTolerance) {\n      considerBothDirections = false;\n    }\n  }\n\n  if (considerBothDirections) {\n    const coordinates = newTarget.coordinates;\n    const count = coordinates.length;\n    const startIndex = newTarget.startIndex;\n    const endIndex = newEndIndex;\n    if (startIndex < endIndex) {\n      const forwardDistance = getCumulativeSquaredDistance(\n        coordinates,\n        startIndex,\n        endIndex\n      );\n      const reverseDistance = getCumulativeSquaredDistance(\n        coordinates,\n        startIndex,\n        endIndex - count\n      );\n      if (reverseDistance < forwardDistance) {\n        newEndIndex -= count;\n      }\n    } else {\n      const reverseDistance = getCumulativeSquaredDistance(\n        coordinates,\n        startIndex,\n        endIndex\n      );\n      const forwardDistance = getCumulativeSquaredDistance(\n        coordinates,\n        startIndex,\n        endIndex + count\n      );\n      if (forwardDistance < reverseDistance) {\n        newEndIndex += count;\n      }\n    }\n  }\n\n  sharedUpdateInfo.index = newTargetIndex;\n  sharedUpdateInfo.endIndex = newEndIndex;\n  return sharedUpdateInfo;\n}\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} coordinate The clicked coordinate.\n * @param {Array<import(\"../coordinate.js\").Coordinate>} coordinates The geometry component coordinates.\n * @param {boolean} ring The coordinates represent a linear ring.\n * @param {Array<TraceTarget>} targets The trace targets.\n */\nfunction appendTraceTarget(coordinate, coordinates, ring, targets) {\n  const x = coordinate[0];\n  const y = coordinate[1];\n  for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n    const start = coordinates[i];\n    const end = coordinates[i + 1];\n    const rel = getPointSegmentRelationship(x, y, start, end);\n    if (rel.squaredDistance === 0) {\n      const index = i + rel.along;\n      targets.push({\n        coordinates: coordinates,\n        ring: ring,\n        startIndex: index,\n        endIndex: index,\n      });\n      return;\n    }\n  }\n}\n\n/**\n * @typedef {Object} PointSegmentRelationship\n * @property {number} along The closest point expressed as a fraction along the segment length.\n * @property {number} squaredDistance The squared distance of the point to the segment.\n */\n\n/**\n * @type {PointSegmentRelationship}\n */\nconst sharedRel = {along: 0, squaredDistance: 0};\n\n/**\n * @param {number} x The point x.\n * @param {number} y The point y.\n * @param {import(\"../coordinate.js\").Coordinate} start The segment start.\n * @param {import(\"../coordinate.js\").Coordinate} end The segment end.\n * @return {PointSegmentRelationship} The point segment relationship.  The returned object is\n * shared between calls and must not be modified by the caller.\n */\nfunction getPointSegmentRelationship(x, y, start, end) {\n  const x1 = start[0];\n  const y1 = start[1];\n  const x2 = end[0];\n  const y2 = end[1];\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  let along = 0;\n  let px = x1;\n  let py = y1;\n  if (dx !== 0 || dy !== 0) {\n    along = clamp(((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy), 0, 1);\n    px += dx * along;\n    py += dy * along;\n  }\n\n  sharedRel.along = along;\n  sharedRel.squaredDistance = toFixed(squaredDistance(x, y, px, py), 10);\n  return sharedRel;\n}\n\n/**\n * @param {LineCoordType} coordinates The coordinates.\n * @param {number} index The index.  May be fractional and may wrap.\n * @return {import(\"../coordinate.js\").Coordinate} The interpolated coordinate.\n */\nfunction interpolateCoordinate(coordinates, index) {\n  const count = coordinates.length;\n\n  let startIndex = Math.floor(index);\n  const along = index - startIndex;\n  if (startIndex >= count) {\n    startIndex -= count;\n  } else if (startIndex < 0) {\n    startIndex += count;\n  }\n\n  let endIndex = startIndex + 1;\n  if (endIndex >= count) {\n    endIndex -= count;\n  }\n\n  const start = coordinates[startIndex];\n  const x0 = start[0];\n  const y0 = start[1];\n  const end = coordinates[endIndex];\n  const dx = end[0] - x0;\n  const dy = end[1] - y0;\n\n  return [x0 + dx * along, y0 + dy * along];\n}\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'drawabort'|'drawend'|'drawstart', DrawEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'drawabort'|'drawend'|'drawstart', Return>} DrawOnSignature\n */\n\n/**\n * @classdesc\n * Interaction for drawing feature geometries.\n *\n * @fires DrawEvent\n * @api\n */\nclass Draw extends PointerInteraction {\n  /**\n   * @param {Options} options Options.\n   */\n  constructor(options) {\n    const pointerOptions = /** @type {import(\"./Pointer.js\").Options} */ (\n      options\n    );\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n\n    super(pointerOptions);\n\n    /***\n     * @type {DrawOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {DrawOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {DrawOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.shouldHandle_ = false;\n\n    /**\n     * @type {import(\"../pixel.js\").Pixel}\n     * @private\n     */\n    this.downPx_ = null;\n\n    /**\n     * @type {ReturnType<typeof setTimeout>}\n     * @private\n     */\n    this.downTimeout_;\n\n    /**\n     * @type {number|undefined}\n     * @private\n     */\n    this.lastDragTime_;\n\n    /**\n     * Pointer type of the last pointermove event\n     * @type {string}\n     * @private\n     */\n    this.pointerType_;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.freehand_ = false;\n\n    /**\n     * Target source for drawn features.\n     * @type {VectorSource|null}\n     * @private\n     */\n    this.source_ = options.source ? options.source : null;\n\n    /**\n     * Target collection for drawn features.\n     * @type {import(\"../Collection.js\").default<Feature>|null}\n     * @private\n     */\n    this.features_ = options.features ? options.features : null;\n\n    /**\n     * Pixel distance for snapping.\n     * @type {number}\n     * @private\n     */\n    this.snapTolerance_ = options.snapTolerance ? options.snapTolerance : 12;\n\n    /**\n     * Geometry type.\n     * @type {import(\"../geom/Geometry.js\").Type}\n     * @private\n     */\n    this.type_ = /** @type {import(\"../geom/Geometry.js\").Type} */ (\n      options.type\n    );\n\n    /**\n     * Drawing mode (derived from geometry type.\n     * @type {Mode}\n     * @private\n     */\n    this.mode_ = getMode(this.type_);\n\n    /**\n     * Stop click, singleclick, and doubleclick events from firing during drawing.\n     * Default is `false`.\n     * @type {boolean}\n     * @private\n     */\n    this.stopClick_ = !!options.stopClick;\n\n    /**\n     * The number of points that must be drawn before a polygon ring or line\n     * string can be finished.  The default is 3 for polygon rings and 2 for\n     * line strings.\n     * @type {number}\n     * @private\n     */\n    this.minPoints_ = options.minPoints\n      ? options.minPoints\n      : this.mode_ === 'Polygon'\n      ? 3\n      : 2;\n\n    /**\n     * The number of points that can be drawn before a polygon ring or line string\n     * is finished. The default is no restriction.\n     * @type {number}\n     * @private\n     */\n    this.maxPoints_ =\n      this.mode_ === 'Circle'\n        ? 2\n        : options.maxPoints\n        ? options.maxPoints\n        : Infinity;\n\n    /**\n     * A function to decide if a potential finish coordinate is permissible\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.finishCondition_ = options.finishCondition\n      ? options.finishCondition\n      : TRUE;\n\n    /**\n     * @private\n     * @type {import(\"../geom/Geometry.js\").GeometryLayout}\n     */\n    this.geometryLayout_ = options.geometryLayout\n      ? options.geometryLayout\n      : 'XY';\n\n    let geometryFunction = options.geometryFunction;\n    if (!geometryFunction) {\n      const mode = this.mode_;\n      if (mode === 'Circle') {\n        /**\n         * @param {!LineCoordType} coordinates The coordinates.\n         * @param {import(\"../geom/SimpleGeometry.js\").default|undefined} geometry Optional geometry.\n         * @param {import(\"../proj/Projection.js\").default} projection The view projection.\n         * @return {import(\"../geom/SimpleGeometry.js\").default} A geometry.\n         */\n        geometryFunction = function (coordinates, geometry, projection) {\n          const circle = geometry\n            ? /** @type {Circle} */ (geometry)\n            : new Circle([NaN, NaN]);\n          const center = fromUserCoordinate(coordinates[0], projection);\n          const squaredLength = squaredCoordinateDistance(\n            center,\n            fromUserCoordinate(coordinates[coordinates.length - 1], projection)\n          );\n          circle.setCenterAndRadius(\n            center,\n            Math.sqrt(squaredLength),\n            this.geometryLayout_\n          );\n          const userProjection = getUserProjection();\n          if (userProjection) {\n            circle.transform(projection, userProjection);\n          }\n          return circle;\n        };\n      } else {\n        let Constructor;\n        if (mode === 'Point') {\n          Constructor = Point;\n        } else if (mode === 'LineString') {\n          Constructor = LineString;\n        } else if (mode === 'Polygon') {\n          Constructor = Polygon;\n        }\n        /**\n         * @param {!LineCoordType} coordinates The coordinates.\n         * @param {import(\"../geom/SimpleGeometry.js\").default|undefined} geometry Optional geometry.\n         * @param {import(\"../proj/Projection.js\").default} projection The view projection.\n         * @return {import(\"../geom/SimpleGeometry.js\").default} A geometry.\n         */\n        geometryFunction = function (coordinates, geometry, projection) {\n          if (geometry) {\n            if (mode === 'Polygon') {\n              if (coordinates[0].length) {\n                // Add a closing coordinate to match the first\n                geometry.setCoordinates(\n                  [coordinates[0].concat([coordinates[0][0]])],\n                  this.geometryLayout_\n                );\n              } else {\n                geometry.setCoordinates([], this.geometryLayout_);\n              }\n            } else {\n              geometry.setCoordinates(coordinates, this.geometryLayout_);\n            }\n          } else {\n            geometry = new Constructor(coordinates, this.geometryLayout_);\n          }\n          return geometry;\n        };\n      }\n    }\n\n    /**\n     * @type {GeometryFunction}\n     * @private\n     */\n    this.geometryFunction_ = geometryFunction;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.dragVertexDelay_ =\n      options.dragVertexDelay !== undefined ? options.dragVertexDelay : 500;\n\n    /**\n     * Finish coordinate for the feature (first point for polygons, last point for\n     * linestrings).\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    this.finishCoordinate_ = null;\n\n    /**\n     * Sketch feature.\n     * @type {Feature<import('../geom/SimpleGeometry.js').default>}\n     * @private\n     */\n    this.sketchFeature_ = null;\n\n    /**\n     * Sketch point.\n     * @type {Feature<Point>}\n     * @private\n     */\n    this.sketchPoint_ = null;\n\n    /**\n     * Sketch coordinates. Used when drawing a line or polygon.\n     * @type {SketchCoordType}\n     * @private\n     */\n    this.sketchCoords_ = null;\n\n    /**\n     * Sketch line. Used when drawing polygon.\n     * @type {Feature<LineString>}\n     * @private\n     */\n    this.sketchLine_ = null;\n\n    /**\n     * Sketch line coordinates. Used when drawing a polygon or circle.\n     * @type {LineCoordType}\n     * @private\n     */\n    this.sketchLineCoords_ = null;\n\n    /**\n     * Squared tolerance for handling up events.  If the squared distance\n     * between a down and up event is greater than this tolerance, up events\n     * will not be handled.\n     * @type {number}\n     * @private\n     */\n    this.squaredClickTolerance_ = options.clickTolerance\n      ? options.clickTolerance * options.clickTolerance\n      : 36;\n\n    /**\n     * Draw overlay where our sketch features are drawn.\n     * @type {VectorLayer}\n     * @private\n     */\n    this.overlay_ = new VectorLayer({\n      source: new VectorSource({\n        useSpatialIndex: false,\n        wrapX: options.wrapX ? options.wrapX : false,\n      }),\n      style: options.style ? options.style : getDefaultStyleFunction(),\n      updateWhileInteracting: true,\n    });\n\n    /**\n     * Name of the geometry attribute for newly created features.\n     * @type {string|undefined}\n     * @private\n     */\n    this.geometryName_ = options.geometryName;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.condition_ = options.condition ? options.condition : noModifierKeys;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.freehandCondition_;\n    if (options.freehand) {\n      this.freehandCondition_ = always;\n    } else {\n      this.freehandCondition_ = options.freehandCondition\n        ? options.freehandCondition\n        : shiftKeyOnly;\n    }\n\n    /**\n     * @type {import(\"../events/condition.js\").Condition}\n     * @private\n     */\n    this.traceCondition_;\n    this.setTrace(options.trace || false);\n\n    /**\n     * @type {TraceState}\n     * @private\n     */\n    this.traceState_ = {active: false};\n\n    /**\n     * @type {VectorSource|null}\n     * @private\n     */\n    this.traceSource_ = options.traceSource || options.source || null;\n\n    this.addChangeListener(InteractionProperty.ACTIVE, this.updateState_);\n  }\n\n  /**\n   * Toggle tracing mode or set a tracing condition.\n   *\n   * @param {boolean|import(\"../events/condition.js\").Condition} trace A boolean to toggle tracing mode or an event\n   *     condition that will be checked when a feature is clicked to determine if tracing should be active.\n   */\n  setTrace(trace) {\n    let condition;\n    if (!trace) {\n      condition = never;\n    } else if (trace === true) {\n      condition = always;\n    } else {\n      condition = trace;\n    }\n    this.traceCondition_ = condition;\n  }\n\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../Map.js\").default} map Map.\n   */\n  setMap(map) {\n    super.setMap(map);\n    this.updateState_();\n  }\n\n  /**\n   * Get the overlay layer that this interaction renders sketch features to.\n   * @return {VectorLayer} Overlay layer.\n   * @api\n   */\n  getOverlay() {\n    return this.overlay_;\n  }\n\n  /**\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may actually draw or finish the drawing.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   * @api\n   */\n  handleEvent(event) {\n    if (event.originalEvent.type === EventType.CONTEXTMENU) {\n      // Avoid context menu for long taps when drawing on mobile\n      event.originalEvent.preventDefault();\n    }\n    this.freehand_ = this.mode_ !== 'Point' && this.freehandCondition_(event);\n    let move = event.type === MapBrowserEventType.POINTERMOVE;\n    let pass = true;\n    if (\n      !this.freehand_ &&\n      this.lastDragTime_ &&\n      event.type === MapBrowserEventType.POINTERDRAG\n    ) {\n      const now = Date.now();\n      if (now - this.lastDragTime_ >= this.dragVertexDelay_) {\n        this.downPx_ = event.pixel;\n        this.shouldHandle_ = !this.freehand_;\n        move = true;\n      } else {\n        this.lastDragTime_ = undefined;\n      }\n      if (this.shouldHandle_ && this.downTimeout_ !== undefined) {\n        clearTimeout(this.downTimeout_);\n        this.downTimeout_ = undefined;\n      }\n    }\n    if (\n      this.freehand_ &&\n      event.type === MapBrowserEventType.POINTERDRAG &&\n      this.sketchFeature_ !== null\n    ) {\n      this.addToDrawing_(event.coordinate);\n      pass = false;\n    } else if (\n      this.freehand_ &&\n      event.type === MapBrowserEventType.POINTERDOWN\n    ) {\n      pass = false;\n    } else if (move && this.getPointerCount() < 2) {\n      pass = event.type === MapBrowserEventType.POINTERMOVE;\n      if (pass && this.freehand_) {\n        this.handlePointerMove_(event);\n        if (this.shouldHandle_) {\n          // Avoid page scrolling when freehand drawing on mobile\n          event.originalEvent.preventDefault();\n        }\n      } else if (\n        event.originalEvent.pointerType === 'mouse' ||\n        (event.type === MapBrowserEventType.POINTERDRAG &&\n          this.downTimeout_ === undefined)\n      ) {\n        this.handlePointerMove_(event);\n      }\n    } else if (event.type === MapBrowserEventType.DBLCLICK) {\n      pass = false;\n    }\n\n    return super.handleEvent(event) && pass;\n  }\n\n  /**\n   * Handle pointer down events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleDownEvent(event) {\n    this.shouldHandle_ = !this.freehand_;\n\n    if (this.freehand_) {\n      this.downPx_ = event.pixel;\n      if (!this.finishCoordinate_) {\n        this.startDrawing_(event.coordinate);\n      }\n      return true;\n    }\n\n    if (!this.condition_(event)) {\n      this.lastDragTime_ = undefined;\n      return false;\n    }\n\n    this.lastDragTime_ = Date.now();\n    this.downTimeout_ = setTimeout(() => {\n      this.handlePointerMove_(\n        new MapBrowserEvent(\n          MapBrowserEventType.POINTERMOVE,\n          event.map,\n          event.originalEvent,\n          false,\n          event.frameState\n        )\n      );\n    }, this.dragVertexDelay_);\n    this.downPx_ = event.pixel;\n    return true;\n  }\n\n  /**\n   * @private\n   */\n  deactivateTrace_() {\n    this.traceState_ = {active: false};\n  }\n\n  /**\n   * Activate or deactivate trace state based on a browser event.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @private\n   */\n  toggleTraceState_(event) {\n    if (!this.traceSource_ || !this.traceCondition_(event)) {\n      return;\n    }\n\n    if (this.traceState_.active) {\n      this.deactivateTrace_();\n      return;\n    }\n\n    const map = this.getMap();\n    const lowerLeft = map.getCoordinateFromPixel([\n      event.pixel[0] - this.snapTolerance_,\n      event.pixel[1] + this.snapTolerance_,\n    ]);\n    const upperRight = map.getCoordinateFromPixel([\n      event.pixel[0] + this.snapTolerance_,\n      event.pixel[1] - this.snapTolerance_,\n    ]);\n    const extent = boundingExtent([lowerLeft, upperRight]);\n    const features = this.traceSource_.getFeaturesInExtent(extent);\n    if (features.length === 0) {\n      return;\n    }\n\n    const targets = getTraceTargets(event.coordinate, features);\n    if (targets.length) {\n      this.traceState_ = {\n        active: true,\n        startPx: event.pixel.slice(),\n        targets: targets,\n        targetIndex: -1,\n      };\n    }\n  }\n\n  /**\n   * @param {TraceTarget} target The trace target.\n   * @param {number} endIndex The new end index of the trace.\n   * @private\n   */\n  addOrRemoveTracedCoordinates_(target, endIndex) {\n    // three cases to handle:\n    //  1. traced in the same direction and points need adding\n    //  2. traced in the same direction and points need removing\n    //  3. traced in a new direction\n    const previouslyForward = target.startIndex <= target.endIndex;\n    const currentlyForward = target.startIndex <= endIndex;\n    if (previouslyForward === currentlyForward) {\n      // same direction\n      if (\n        (previouslyForward && endIndex > target.endIndex) ||\n        (!previouslyForward && endIndex < target.endIndex)\n      ) {\n        // case 1 - add new points\n        this.addTracedCoordinates_(target, target.endIndex, endIndex);\n      } else if (\n        (previouslyForward && endIndex < target.endIndex) ||\n        (!previouslyForward && endIndex > target.endIndex)\n      ) {\n        // case 2 - remove old points\n        this.removeTracedCoordinates_(endIndex, target.endIndex);\n      }\n    } else {\n      // case 3 - remove old points, add new points\n      this.removeTracedCoordinates_(target.startIndex, target.endIndex);\n      this.addTracedCoordinates_(target, target.startIndex, endIndex);\n    }\n  }\n\n  /**\n   * @param {number} fromIndex The start index.\n   * @param {number} toIndex The end index.\n   * @private\n   */\n  removeTracedCoordinates_(fromIndex, toIndex) {\n    if (fromIndex === toIndex) {\n      return;\n    }\n\n    let remove = 0;\n    if (fromIndex < toIndex) {\n      const start = Math.ceil(fromIndex);\n      let end = Math.floor(toIndex);\n      if (end === toIndex) {\n        end -= 1;\n      }\n      remove = end - start + 1;\n    } else {\n      const start = Math.floor(fromIndex);\n      let end = Math.ceil(toIndex);\n      if (end === toIndex) {\n        end += 1;\n      }\n      remove = start - end + 1;\n    }\n\n    if (remove > 0) {\n      this.removeLastPoints_(remove);\n    }\n  }\n\n  /**\n   * @param {TraceTarget} target The trace target.\n   * @param {number} fromIndex The start index.\n   * @param {number} toIndex The end index.\n   * @private\n   */\n  addTracedCoordinates_(target, fromIndex, toIndex) {\n    if (fromIndex === toIndex) {\n      return;\n    }\n\n    const coordinates = [];\n    if (fromIndex < toIndex) {\n      // forward trace\n      const start = Math.ceil(fromIndex);\n      let end = Math.floor(toIndex);\n      if (end === toIndex) {\n        // if end is snapped to a vertex, it will be added later\n        end -= 1;\n      }\n      for (let i = start; i <= end; ++i) {\n        coordinates.push(getCoordinate(target.coordinates, i));\n      }\n    } else {\n      // reverse trace\n      const start = Math.floor(fromIndex);\n      let end = Math.ceil(toIndex);\n      if (end === toIndex) {\n        end += 1;\n      }\n      for (let i = start; i >= end; --i) {\n        coordinates.push(getCoordinate(target.coordinates, i));\n      }\n    }\n    if (coordinates.length) {\n      this.appendCoordinates(coordinates);\n    }\n  }\n\n  /**\n   * Update the trace.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @private\n   */\n  updateTrace_(event) {\n    const traceState = this.traceState_;\n    if (!traceState.active) {\n      return;\n    }\n\n    if (traceState.targetIndex === -1) {\n      // check if we are ready to pick a target\n      if (distance(traceState.startPx, event.pixel) < this.snapTolerance_) {\n        return;\n      }\n    }\n\n    const updatedTraceTarget = getTraceTargetUpdate(\n      event.coordinate,\n      traceState,\n      this.getMap(),\n      this.snapTolerance_\n    );\n\n    if (traceState.targetIndex !== updatedTraceTarget.index) {\n      // target changed\n      if (traceState.targetIndex !== -1) {\n        // remove points added during previous trace\n        const oldTarget = traceState.targets[traceState.targetIndex];\n        this.removeTracedCoordinates_(oldTarget.startIndex, oldTarget.endIndex);\n      }\n      // add points for the new target\n      const newTarget = traceState.targets[updatedTraceTarget.index];\n      this.addTracedCoordinates_(\n        newTarget,\n        newTarget.startIndex,\n        updatedTraceTarget.endIndex\n      );\n    } else {\n      // target stayed the same\n      const target = traceState.targets[traceState.targetIndex];\n      this.addOrRemoveTracedCoordinates_(target, updatedTraceTarget.endIndex);\n    }\n\n    // modify the state with updated info\n    traceState.targetIndex = updatedTraceTarget.index;\n    const target = traceState.targets[traceState.targetIndex];\n    target.endIndex = updatedTraceTarget.endIndex;\n\n    // update event coordinate and pixel to match end point of final segment\n    const coordinate = interpolateCoordinate(\n      target.coordinates,\n      target.endIndex\n    );\n    const pixel = this.getMap().getPixelFromCoordinate(coordinate);\n    event.coordinate = coordinate;\n    event.pixel = [Math.round(pixel[0]), Math.round(pixel[1])];\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleUpEvent(event) {\n    let pass = true;\n\n    if (this.getPointerCount() === 0) {\n      if (this.downTimeout_) {\n        clearTimeout(this.downTimeout_);\n        this.downTimeout_ = undefined;\n      }\n\n      this.handlePointerMove_(event);\n      const tracing = this.traceState_.active;\n      this.toggleTraceState_(event);\n\n      if (this.shouldHandle_) {\n        const startingToDraw = !this.finishCoordinate_;\n        if (startingToDraw) {\n          this.startDrawing_(event.coordinate);\n        }\n        if (!startingToDraw && this.freehand_) {\n          this.finishDrawing();\n        } else if (\n          !this.freehand_ &&\n          (!startingToDraw || this.mode_ === 'Point')\n        ) {\n          if (this.atFinish_(event.pixel, tracing)) {\n            if (this.finishCondition_(event)) {\n              this.finishDrawing();\n            }\n          } else {\n            this.addToDrawing_(event.coordinate);\n          }\n        }\n        pass = false;\n      } else if (this.freehand_) {\n        this.abortDrawing();\n      }\n    }\n\n    if (!pass && this.stopClick_) {\n      event.preventDefault();\n    }\n    return pass;\n  }\n\n  /**\n   * Handle move events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event A move event.\n   * @private\n   */\n  handlePointerMove_(event) {\n    this.pointerType_ = event.originalEvent.pointerType;\n    if (\n      this.downPx_ &&\n      ((!this.freehand_ && this.shouldHandle_) ||\n        (this.freehand_ && !this.shouldHandle_))\n    ) {\n      const downPx = this.downPx_;\n      const clickPx = event.pixel;\n      const dx = downPx[0] - clickPx[0];\n      const dy = downPx[1] - clickPx[1];\n      const squaredDistance = dx * dx + dy * dy;\n      this.shouldHandle_ = this.freehand_\n        ? squaredDistance > this.squaredClickTolerance_\n        : squaredDistance <= this.squaredClickTolerance_;\n      if (!this.shouldHandle_) {\n        return;\n      }\n    }\n\n    if (!this.finishCoordinate_) {\n      this.createOrUpdateSketchPoint_(event.coordinate.slice());\n      return;\n    }\n\n    this.updateTrace_(event);\n    this.modifyDrawing_(event.coordinate);\n  }\n\n  /**\n   * Determine if an event is within the snapping tolerance of the start coord.\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @param {boolean} [tracing] Drawing in trace mode (only stop if at the starting point).\n   * @return {boolean} The event is within the snapping tolerance of the start.\n   * @private\n   */\n  atFinish_(pixel, tracing) {\n    let at = false;\n    if (this.sketchFeature_) {\n      let potentiallyDone = false;\n      let potentiallyFinishCoordinates = [this.finishCoordinate_];\n      const mode = this.mode_;\n      if (mode === 'Point') {\n        at = true;\n      } else if (mode === 'Circle') {\n        at = this.sketchCoords_.length === 2;\n      } else if (mode === 'LineString') {\n        potentiallyDone =\n          !tracing && this.sketchCoords_.length > this.minPoints_;\n      } else if (mode === 'Polygon') {\n        const sketchCoords = /** @type {PolyCoordType} */ (this.sketchCoords_);\n        potentiallyDone = sketchCoords[0].length > this.minPoints_;\n        potentiallyFinishCoordinates = [\n          sketchCoords[0][0],\n          sketchCoords[0][sketchCoords[0].length - 2],\n        ];\n        if (tracing) {\n          potentiallyFinishCoordinates = [sketchCoords[0][0]];\n        } else {\n          potentiallyFinishCoordinates = [\n            sketchCoords[0][0],\n            sketchCoords[0][sketchCoords[0].length - 2],\n          ];\n        }\n      }\n      if (potentiallyDone) {\n        const map = this.getMap();\n        for (let i = 0, ii = potentiallyFinishCoordinates.length; i < ii; i++) {\n          const finishCoordinate = potentiallyFinishCoordinates[i];\n          const finishPixel = map.getPixelFromCoordinate(finishCoordinate);\n          const dx = pixel[0] - finishPixel[0];\n          const dy = pixel[1] - finishPixel[1];\n          const snapTolerance = this.freehand_ ? 1 : this.snapTolerance_;\n          at = Math.sqrt(dx * dx + dy * dy) <= snapTolerance;\n          if (at) {\n            this.finishCoordinate_ = finishCoordinate;\n            break;\n          }\n        }\n      }\n    }\n    return at;\n  }\n\n  /**\n   * @param {import(\"../coordinate\").Coordinate} coordinates Coordinate.\n   * @private\n   */\n  createOrUpdateSketchPoint_(coordinates) {\n    if (!this.sketchPoint_) {\n      this.sketchPoint_ = new Feature(new Point(coordinates));\n      this.updateSketchFeatures_();\n    } else {\n      const sketchPointGeom = this.sketchPoint_.getGeometry();\n      sketchPointGeom.setCoordinates(coordinates);\n    }\n  }\n\n  /**\n   * @param {import(\"../geom/Polygon.js\").default} geometry Polygon geometry.\n   * @private\n   */\n  createOrUpdateCustomSketchLine_(geometry) {\n    if (!this.sketchLine_) {\n      this.sketchLine_ = new Feature();\n    }\n    const ring = geometry.getLinearRing(0);\n    let sketchLineGeom = this.sketchLine_.getGeometry();\n    if (!sketchLineGeom) {\n      sketchLineGeom = new LineString(\n        ring.getFlatCoordinates(),\n        ring.getLayout()\n      );\n      this.sketchLine_.setGeometry(sketchLineGeom);\n    } else {\n      sketchLineGeom.setFlatCoordinates(\n        ring.getLayout(),\n        ring.getFlatCoordinates()\n      );\n      sketchLineGeom.changed();\n    }\n  }\n\n  /**\n   * Start the drawing.\n   * @param {import(\"../coordinate.js\").Coordinate} start Start coordinate.\n   * @private\n   */\n  startDrawing_(start) {\n    const projection = this.getMap().getView().getProjection();\n    const stride = getStrideForLayout(this.geometryLayout_);\n    while (start.length < stride) {\n      start.push(0);\n    }\n    this.finishCoordinate_ = start;\n    if (this.mode_ === 'Point') {\n      this.sketchCoords_ = start.slice();\n    } else if (this.mode_ === 'Polygon') {\n      this.sketchCoords_ = [[start.slice(), start.slice()]];\n      this.sketchLineCoords_ = this.sketchCoords_[0];\n    } else {\n      this.sketchCoords_ = [start.slice(), start.slice()];\n    }\n    if (this.sketchLineCoords_) {\n      this.sketchLine_ = new Feature(new LineString(this.sketchLineCoords_));\n    }\n    const geometry = this.geometryFunction_(\n      this.sketchCoords_,\n      undefined,\n      projection\n    );\n    this.sketchFeature_ = new Feature();\n    if (this.geometryName_) {\n      this.sketchFeature_.setGeometryName(this.geometryName_);\n    }\n    this.sketchFeature_.setGeometry(geometry);\n    this.updateSketchFeatures_();\n    this.dispatchEvent(\n      new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_)\n    );\n  }\n\n  /**\n   * Modify the drawing.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @private\n   */\n  modifyDrawing_(coordinate) {\n    const map = this.getMap();\n    const geometry = this.sketchFeature_.getGeometry();\n    const projection = map.getView().getProjection();\n    const stride = getStrideForLayout(this.geometryLayout_);\n    let coordinates, last;\n    while (coordinate.length < stride) {\n      coordinate.push(0);\n    }\n    if (this.mode_ === 'Point') {\n      last = this.sketchCoords_;\n    } else if (this.mode_ === 'Polygon') {\n      coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];\n      last = coordinates[coordinates.length - 1];\n      if (this.atFinish_(map.getPixelFromCoordinate(coordinate))) {\n        // snap to finish\n        coordinate = this.finishCoordinate_.slice();\n      }\n    } else {\n      coordinates = this.sketchCoords_;\n      last = coordinates[coordinates.length - 1];\n    }\n    last[0] = coordinate[0];\n    last[1] = coordinate[1];\n    this.geometryFunction_(\n      /** @type {!LineCoordType} */ (this.sketchCoords_),\n      geometry,\n      projection\n    );\n    if (this.sketchPoint_) {\n      const sketchPointGeom = this.sketchPoint_.getGeometry();\n      sketchPointGeom.setCoordinates(coordinate);\n    }\n    if (geometry.getType() === 'Polygon' && this.mode_ !== 'Polygon') {\n      this.createOrUpdateCustomSketchLine_(/** @type {Polygon} */ (geometry));\n    } else if (this.sketchLineCoords_) {\n      const sketchLineGeom = this.sketchLine_.getGeometry();\n      sketchLineGeom.setCoordinates(this.sketchLineCoords_);\n    }\n    this.updateSketchFeatures_();\n  }\n\n  /**\n   * Add a new coordinate to the drawing.\n   * @param {!PointCoordType} coordinate Coordinate\n   * @private\n   */\n  addToDrawing_(coordinate) {\n    const geometry = this.sketchFeature_.getGeometry();\n    const projection = this.getMap().getView().getProjection();\n    let done;\n    let coordinates;\n    const mode = this.mode_;\n    if (mode === 'LineString' || mode === 'Circle') {\n      this.finishCoordinate_ = coordinate.slice();\n      coordinates = /** @type {LineCoordType} */ (this.sketchCoords_);\n      if (coordinates.length >= this.maxPoints_) {\n        if (this.freehand_) {\n          coordinates.pop();\n        } else {\n          done = true;\n        }\n      }\n      coordinates.push(coordinate.slice());\n      this.geometryFunction_(coordinates, geometry, projection);\n    } else if (mode === 'Polygon') {\n      coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];\n      if (coordinates.length >= this.maxPoints_) {\n        if (this.freehand_) {\n          coordinates.pop();\n        } else {\n          done = true;\n        }\n      }\n      coordinates.push(coordinate.slice());\n      if (done) {\n        this.finishCoordinate_ = coordinates[0];\n      }\n      this.geometryFunction_(this.sketchCoords_, geometry, projection);\n    }\n    this.createOrUpdateSketchPoint_(coordinate.slice());\n    this.updateSketchFeatures_();\n    if (done) {\n      this.finishDrawing();\n    }\n  }\n\n  /**\n   * @param {number} n The number of points to remove.\n   */\n  removeLastPoints_(n) {\n    if (!this.sketchFeature_) {\n      return;\n    }\n    const geometry = this.sketchFeature_.getGeometry();\n    const projection = this.getMap().getView().getProjection();\n    const mode = this.mode_;\n    for (let i = 0; i < n; ++i) {\n      let coordinates;\n      if (mode === 'LineString' || mode === 'Circle') {\n        coordinates = /** @type {LineCoordType} */ (this.sketchCoords_);\n        coordinates.splice(-2, 1);\n        if (coordinates.length >= 2) {\n          this.finishCoordinate_ = coordinates[coordinates.length - 2].slice();\n          const finishCoordinate = this.finishCoordinate_.slice();\n          coordinates[coordinates.length - 1] = finishCoordinate;\n          this.createOrUpdateSketchPoint_(finishCoordinate);\n        }\n        this.geometryFunction_(coordinates, geometry, projection);\n        if (geometry.getType() === 'Polygon' && this.sketchLine_) {\n          this.createOrUpdateCustomSketchLine_(\n            /** @type {Polygon} */ (geometry)\n          );\n        }\n      } else if (mode === 'Polygon') {\n        coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];\n        coordinates.splice(-2, 1);\n        const sketchLineGeom = this.sketchLine_.getGeometry();\n        if (coordinates.length >= 2) {\n          const finishCoordinate = coordinates[coordinates.length - 2].slice();\n          coordinates[coordinates.length - 1] = finishCoordinate;\n          this.createOrUpdateSketchPoint_(finishCoordinate);\n        }\n        sketchLineGeom.setCoordinates(coordinates);\n        this.geometryFunction_(this.sketchCoords_, geometry, projection);\n      }\n\n      if (coordinates.length === 1) {\n        this.abortDrawing();\n        break;\n      }\n    }\n\n    this.updateSketchFeatures_();\n  }\n\n  /**\n   * Remove last point of the feature currently being drawn. Does not do anything when\n   * drawing POINT or MULTI_POINT geometries.\n   * @api\n   */\n  removeLastPoint() {\n    this.removeLastPoints_(1);\n  }\n\n  /**\n   * Stop drawing and add the sketch feature to the target layer.\n   * The {@link module:ol/interaction/Draw~DrawEventType.DRAWEND} event is\n   * dispatched before inserting the feature.\n   * @api\n   */\n  finishDrawing() {\n    const sketchFeature = this.abortDrawing_();\n    if (!sketchFeature) {\n      return;\n    }\n    let coordinates = this.sketchCoords_;\n    const geometry = sketchFeature.getGeometry();\n    const projection = this.getMap().getView().getProjection();\n    if (this.mode_ === 'LineString') {\n      // remove the redundant last point\n      coordinates.pop();\n      this.geometryFunction_(coordinates, geometry, projection);\n    } else if (this.mode_ === 'Polygon') {\n      // remove the redundant last point in ring\n      /** @type {PolyCoordType} */ (coordinates)[0].pop();\n      this.geometryFunction_(coordinates, geometry, projection);\n      coordinates = geometry.getCoordinates();\n    }\n\n    // cast multi-part geometries\n    if (this.type_ === 'MultiPoint') {\n      sketchFeature.setGeometry(\n        new MultiPoint([/** @type {PointCoordType} */ (coordinates)])\n      );\n    } else if (this.type_ === 'MultiLineString') {\n      sketchFeature.setGeometry(\n        new MultiLineString([/** @type {LineCoordType} */ (coordinates)])\n      );\n    } else if (this.type_ === 'MultiPolygon') {\n      sketchFeature.setGeometry(\n        new MultiPolygon([/** @type {PolyCoordType} */ (coordinates)])\n      );\n    }\n\n    // First dispatch event to allow full set up of feature\n    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWEND, sketchFeature));\n\n    // Then insert feature\n    if (this.features_) {\n      this.features_.push(sketchFeature);\n    }\n    if (this.source_) {\n      this.source_.addFeature(sketchFeature);\n    }\n  }\n\n  /**\n   * Stop drawing without adding the sketch feature to the target layer.\n   * @return {Feature<import(\"../geom/SimpleGeometry.js\").default>|null} The sketch feature (or null if none).\n   * @private\n   */\n  abortDrawing_() {\n    this.finishCoordinate_ = null;\n    const sketchFeature = this.sketchFeature_;\n    this.sketchFeature_ = null;\n    this.sketchPoint_ = null;\n    this.sketchLine_ = null;\n    this.overlay_.getSource().clear(true);\n    this.deactivateTrace_();\n    return sketchFeature;\n  }\n\n  /**\n   * Stop drawing without adding the sketch feature to the target layer.\n   * @api\n   */\n  abortDrawing() {\n    const sketchFeature = this.abortDrawing_();\n    if (sketchFeature) {\n      this.dispatchEvent(new DrawEvent(DrawEventType.DRAWABORT, sketchFeature));\n    }\n  }\n\n  /**\n   * Append coordinates to the end of the geometry that is currently being drawn.\n   * This can be used when drawing LineStrings or Polygons. Coordinates will\n   * either be appended to the current LineString or the outer ring of the current\n   * Polygon. If no geometry is being drawn, a new one will be created.\n   * @param {!LineCoordType} coordinates Linear coordinates to be appended to\n   * the coordinate array.\n   * @api\n   */\n  appendCoordinates(coordinates) {\n    const mode = this.mode_;\n    const newDrawing = !this.sketchFeature_;\n    if (newDrawing) {\n      this.startDrawing_(coordinates[0]);\n    }\n    /** @type {LineCoordType} */\n    let sketchCoords;\n    if (mode === 'LineString' || mode === 'Circle') {\n      sketchCoords = /** @type {LineCoordType} */ (this.sketchCoords_);\n    } else if (mode === 'Polygon') {\n      sketchCoords =\n        this.sketchCoords_ && this.sketchCoords_.length\n          ? /** @type {PolyCoordType} */ (this.sketchCoords_)[0]\n          : [];\n    } else {\n      return;\n    }\n\n    if (newDrawing) {\n      sketchCoords.shift();\n    }\n\n    // Remove last coordinate from sketch drawing (this coordinate follows cursor position)\n    sketchCoords.pop();\n\n    // Append coordinate list\n    for (let i = 0; i < coordinates.length; i++) {\n      this.addToDrawing_(coordinates[i]);\n    }\n\n    const ending = coordinates[coordinates.length - 1];\n    // Duplicate last coordinate for sketch drawing (cursor position)\n    this.addToDrawing_(ending);\n    this.modifyDrawing_(ending);\n  }\n\n  /**\n   * Initiate draw mode by starting from an existing geometry which will\n   * receive new additional points. This only works on features with\n   * `LineString` geometries, where the interaction will extend lines by adding\n   * points to the end of the coordinates array.\n   * This will change the original feature, instead of drawing a copy.\n   *\n   * The function will dispatch a `drawstart` event.\n   *\n   * @param {!Feature<LineString>} feature Feature to be extended.\n   * @api\n   */\n  extend(feature) {\n    const geometry = feature.getGeometry();\n    const lineString = geometry;\n    this.sketchFeature_ = feature;\n    this.sketchCoords_ = lineString.getCoordinates();\n    const last = this.sketchCoords_[this.sketchCoords_.length - 1];\n    this.finishCoordinate_ = last.slice();\n    this.sketchCoords_.push(last.slice());\n    this.sketchPoint_ = new Feature(new Point(last));\n    this.updateSketchFeatures_();\n    this.dispatchEvent(\n      new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_)\n    );\n  }\n\n  /**\n   * Redraw the sketch features.\n   * @private\n   */\n  updateSketchFeatures_() {\n    const sketchFeatures = [];\n    if (this.sketchFeature_) {\n      sketchFeatures.push(this.sketchFeature_);\n    }\n    if (this.sketchLine_) {\n      sketchFeatures.push(this.sketchLine_);\n    }\n    if (this.sketchPoint_) {\n      sketchFeatures.push(this.sketchPoint_);\n    }\n    const overlaySource = this.overlay_.getSource();\n    overlaySource.clear(true);\n    overlaySource.addFeatures(sketchFeatures);\n  }\n\n  /**\n   * @private\n   */\n  updateState_() {\n    const map = this.getMap();\n    const active = this.getActive();\n    if (!map || !active) {\n      this.abortDrawing();\n    }\n    this.overlay_.setMap(active ? map : null);\n  }\n}\n\n/**\n * @return {import(\"../style/Style.js\").StyleFunction} Styles.\n */\nfunction getDefaultStyleFunction() {\n  const styles = createEditingStyle();\n  return function (feature, resolution) {\n    return styles[feature.getGeometry().getType()];\n  };\n}\n\n/**\n * Create a `geometryFunction` for `type: 'Circle'` that will create a regular\n * polygon with a user specified number of sides and start angle instead of a\n * {@link import(\"../geom/Circle.js\").Circle} geometry.\n * @param {number} [sides] Number of sides of the regular polygon.\n *     Default is 32.\n * @param {number} [angle] Angle of the first point in counter-clockwise\n *     radians. 0 means East.\n *     Default is the angle defined by the heading from the center of the\n *     regular polygon to the current pointer position.\n * @return {GeometryFunction} Function that draws a polygon.\n * @api\n */\nexport function createRegularPolygon(sides, angle) {\n  return function (coordinates, geometry, projection) {\n    const center = fromUserCoordinate(\n      /** @type {LineCoordType} */ (coordinates)[0],\n      projection\n    );\n    const end = fromUserCoordinate(\n      /** @type {LineCoordType} */ (coordinates)[coordinates.length - 1],\n      projection\n    );\n    const radius = Math.sqrt(squaredCoordinateDistance(center, end));\n    geometry = geometry || fromCircle(new Circle(center), sides);\n\n    let internalAngle = angle;\n    if (!angle && angle !== 0) {\n      const x = end[0] - center[0];\n      const y = end[1] - center[1];\n      internalAngle = Math.atan2(y, x);\n    }\n    makeRegular(\n      /** @type {Polygon} */ (geometry),\n      center,\n      radius,\n      internalAngle\n    );\n\n    const userProjection = getUserProjection();\n    if (userProjection) {\n      geometry.transform(projection, userProjection);\n    }\n    return geometry;\n  };\n}\n\n/**\n * Create a `geometryFunction` that will create a box-shaped polygon (aligned\n * with the coordinate system axes).  Use this with the draw interaction and\n * `type: 'Circle'` to return a box instead of a circle geometry.\n * @return {GeometryFunction} Function that draws a box-shaped polygon.\n * @api\n */\nexport function createBox() {\n  return function (coordinates, geometry, projection) {\n    const extent = boundingExtent(\n      /** @type {LineCoordType} */ ([\n        coordinates[0],\n        coordinates[coordinates.length - 1],\n      ]).map(function (coordinate) {\n        return fromUserCoordinate(coordinate, projection);\n      })\n    );\n    const boxCoordinates = [\n      [\n        getBottomLeft(extent),\n        getBottomRight(extent),\n        getTopRight(extent),\n        getTopLeft(extent),\n        getBottomLeft(extent),\n      ],\n    ];\n    if (geometry) {\n      geometry.setCoordinates(boxCoordinates);\n    } else {\n      geometry = new Polygon(boxCoordinates);\n    }\n    const userProjection = getUserProjection();\n    if (userProjection) {\n      geometry.transform(projection, userProjection);\n    }\n    return geometry;\n  };\n}\n\n/**\n * Get the drawing mode.  The mode for multi-part geometries is the same as for\n * their single-part cousins.\n * @param {import(\"../geom/Geometry.js\").Type} type Geometry type.\n * @return {Mode} Drawing mode.\n */\nfunction getMode(type) {\n  switch (type) {\n    case 'Point':\n    case 'MultiPoint':\n      return 'Point';\n    case 'LineString':\n    case 'MultiLineString':\n      return 'LineString';\n    case 'Polygon':\n    case 'MultiPolygon':\n      return 'Polygon';\n    case 'Circle':\n      return 'Circle';\n    default:\n      throw new Error('Invalid type: ' + type);\n  }\n}\n\nexport default Draw;\n","/**\n * @module ol/interaction/Extent\n */\nimport Event from '../events/Event.js';\nimport Feature from '../Feature.js';\nimport MapBrowserEventType from '../MapBrowserEventType.js';\nimport Point from '../geom/Point.js';\nimport PointerInteraction from './Pointer.js';\nimport VectorLayer from '../layer/Vector.js';\nimport VectorSource from '../source/Vector.js';\nimport {always} from '../events/condition.js';\nimport {boundingExtent, getArea} from '../extent.js';\nimport {\n  closestOnSegment,\n  distance as coordinateDistance,\n  squaredDistance as squaredCoordinateDistance,\n  squaredDistanceToSegment,\n} from '../coordinate.js';\nimport {createEditingStyle} from '../style/Style.js';\nimport {fromExtent as polygonFromExtent} from '../geom/Polygon.js';\nimport {toUserExtent} from '../proj.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * Default is {@link module:ol/events/condition.always}.\n * @property {import(\"../extent.js\").Extent} [extent] Initial extent. Defaults to no\n * initial extent.\n * @property {import(\"../style/Style.js\").StyleLike} [boxStyle]\n * Style for the drawn extent box. Defaults to the `Polygon` editing style\n * documented in {@link module:ol/style/Style~Style}\n * @property {number} [pixelTolerance=10] Pixel tolerance for considering the\n * pointer close enough to a segment or vertex for editing.\n * @property {import(\"../style/Style.js\").StyleLike} [pointerStyle]\n * Style for the cursor used to draw the extent. Defaults to the `Point` editing style\n * documented in {@link module:ol/style/Style~Style}\n * @property {boolean} [wrapX=false] Wrap the drawn extent across multiple maps\n * in the X direction? Only affects visuals, not functionality.\n */\n\n/**\n * @enum {string}\n */\nconst ExtentEventType = {\n  /**\n   * Triggered after the extent is changed\n   * @event ExtentEvent#extentchanged\n   * @api\n   */\n  EXTENTCHANGED: 'extentchanged',\n};\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/Extent~Extent} instances are\n * instances of this type.\n */\nexport class ExtentEvent extends Event {\n  /**\n   * @param {import(\"../extent.js\").Extent} extent the new extent\n   */\n  constructor(extent) {\n    super(ExtentEventType.EXTENTCHANGED);\n\n    /**\n     * The current extent.\n     * @type {import(\"../extent.js\").Extent}\n     * @api\n     */\n    this.extent = extent;\n  }\n}\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'extentchanged', ExtentEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'extentchanged', Return>} ExtentOnSignature\n */\n\n/**\n * @classdesc\n * Allows the user to draw a vector box by clicking and dragging on the map.\n * Once drawn, the vector box can be modified by dragging its vertices or edges.\n * This interaction is only supported for mouse devices.\n *\n * @fires ExtentEvent\n * @api\n */\nclass Extent extends PointerInteraction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options || {};\n\n    super(/** @type {import(\"./Pointer.js\").Options} */ (options));\n\n    /***\n     * @type {ExtentOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {ExtentOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {ExtentOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * Condition\n     * @type {import(\"../events/condition.js\").Condition}\n     * @private\n     */\n    this.condition_ = options.condition ? options.condition : always;\n\n    /**\n     * Extent of the drawn box\n     * @type {import(\"../extent.js\").Extent}\n     * @private\n     */\n    this.extent_ = null;\n\n    /**\n     * Handler for pointer move events\n     * @type {function (import(\"../coordinate.js\").Coordinate): import(\"../extent.js\").Extent|null}\n     * @private\n     */\n    this.pointerHandler_ = null;\n\n    /**\n     * Pixel threshold to snap to extent\n     * @type {number}\n     * @private\n     */\n    this.pixelTolerance_ =\n      options.pixelTolerance !== undefined ? options.pixelTolerance : 10;\n\n    /**\n     * Is the pointer snapped to an extent vertex\n     * @type {boolean}\n     * @private\n     */\n    this.snappedToVertex_ = false;\n\n    /**\n     * Feature for displaying the visible extent\n     * @type {Feature}\n     * @private\n     */\n    this.extentFeature_ = null;\n\n    /**\n     * Feature for displaying the visible pointer\n     * @type {Feature<Point>}\n     * @private\n     */\n    this.vertexFeature_ = null;\n\n    if (!options) {\n      options = {};\n    }\n\n    /**\n     * Layer for the extentFeature\n     * @type {VectorLayer}\n     * @private\n     */\n    this.extentOverlay_ = new VectorLayer({\n      source: new VectorSource({\n        useSpatialIndex: false,\n        wrapX: !!options.wrapX,\n      }),\n      style: options.boxStyle\n        ? options.boxStyle\n        : getDefaultExtentStyleFunction(),\n      updateWhileAnimating: true,\n      updateWhileInteracting: true,\n    });\n\n    /**\n     * Layer for the vertexFeature\n     * @type {VectorLayer}\n     * @private\n     */\n    this.vertexOverlay_ = new VectorLayer({\n      source: new VectorSource({\n        useSpatialIndex: false,\n        wrapX: !!options.wrapX,\n      }),\n      style: options.pointerStyle\n        ? options.pointerStyle\n        : getDefaultPointerStyleFunction(),\n      updateWhileAnimating: true,\n      updateWhileInteracting: true,\n    });\n\n    if (options.extent) {\n      this.setExtent(options.extent);\n    }\n  }\n\n  /**\n   * @param {import(\"../pixel.js\").Pixel} pixel cursor location\n   * @param {import(\"../Map.js\").default} map map\n   * @return {import(\"../coordinate.js\").Coordinate|null} snapped vertex on extent\n   * @private\n   */\n  snapToVertex_(pixel, map) {\n    const pixelCoordinate = map.getCoordinateFromPixelInternal(pixel);\n    const sortByDistance = function (a, b) {\n      return (\n        squaredDistanceToSegment(pixelCoordinate, a) -\n        squaredDistanceToSegment(pixelCoordinate, b)\n      );\n    };\n    const extent = this.getExtentInternal();\n    if (extent) {\n      //convert extents to line segments and find the segment closest to pixelCoordinate\n      const segments = getSegments(extent);\n      segments.sort(sortByDistance);\n      const closestSegment = segments[0];\n\n      let vertex = closestOnSegment(pixelCoordinate, closestSegment);\n      const vertexPixel = map.getPixelFromCoordinateInternal(vertex);\n\n      //if the distance is within tolerance, snap to the segment\n      if (coordinateDistance(pixel, vertexPixel) <= this.pixelTolerance_) {\n        //test if we should further snap to a vertex\n        const pixel1 = map.getPixelFromCoordinateInternal(closestSegment[0]);\n        const pixel2 = map.getPixelFromCoordinateInternal(closestSegment[1]);\n        const squaredDist1 = squaredCoordinateDistance(vertexPixel, pixel1);\n        const squaredDist2 = squaredCoordinateDistance(vertexPixel, pixel2);\n        const dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));\n        this.snappedToVertex_ = dist <= this.pixelTolerance_;\n        if (this.snappedToVertex_) {\n          vertex =\n            squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];\n        }\n        return vertex;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent pointer move event\n   * @private\n   */\n  handlePointerMove_(mapBrowserEvent) {\n    const pixel = mapBrowserEvent.pixel;\n    const map = mapBrowserEvent.map;\n\n    let vertex = this.snapToVertex_(pixel, map);\n    if (!vertex) {\n      vertex = map.getCoordinateFromPixelInternal(pixel);\n    }\n    this.createOrUpdatePointerFeature_(vertex);\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent extent\n   * @return {Feature} extent as featrue\n   * @private\n   */\n  createOrUpdateExtentFeature_(extent) {\n    let extentFeature = this.extentFeature_;\n\n    if (!extentFeature) {\n      if (!extent) {\n        extentFeature = new Feature({});\n      } else {\n        extentFeature = new Feature(polygonFromExtent(extent));\n      }\n      this.extentFeature_ = extentFeature;\n      this.extentOverlay_.getSource().addFeature(extentFeature);\n    } else {\n      if (!extent) {\n        extentFeature.setGeometry(undefined);\n      } else {\n        extentFeature.setGeometry(polygonFromExtent(extent));\n      }\n    }\n    return extentFeature;\n  }\n\n  /**\n   * @param {import(\"../coordinate.js\").Coordinate} vertex location of feature\n   * @return {Feature} vertex as feature\n   * @private\n   */\n  createOrUpdatePointerFeature_(vertex) {\n    let vertexFeature = this.vertexFeature_;\n    if (!vertexFeature) {\n      vertexFeature = new Feature(new Point(vertex));\n      this.vertexFeature_ = vertexFeature;\n      this.vertexOverlay_.getSource().addFeature(vertexFeature);\n    } else {\n      const geometry = vertexFeature.getGeometry();\n      geometry.setCoordinates(vertex);\n    }\n    return vertexFeature;\n  }\n\n  /**\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   */\n  handleEvent(mapBrowserEvent) {\n    if (!mapBrowserEvent.originalEvent || !this.condition_(mapBrowserEvent)) {\n      return true;\n    }\n    //display pointer (if not dragging)\n    if (\n      mapBrowserEvent.type == MapBrowserEventType.POINTERMOVE &&\n      !this.handlingDownUpSequence\n    ) {\n      this.handlePointerMove_(mapBrowserEvent);\n    }\n    //call pointer to determine up/down/drag\n    super.handleEvent(mapBrowserEvent);\n    //return false to stop propagation\n    return false;\n  }\n\n  /**\n   * Handle pointer down events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleDownEvent(mapBrowserEvent) {\n    const pixel = mapBrowserEvent.pixel;\n    const map = mapBrowserEvent.map;\n\n    const extent = this.getExtentInternal();\n    let vertex = this.snapToVertex_(pixel, map);\n\n    //find the extent corner opposite the passed corner\n    const getOpposingPoint = function (point) {\n      let x_ = null;\n      let y_ = null;\n      if (point[0] == extent[0]) {\n        x_ = extent[2];\n      } else if (point[0] == extent[2]) {\n        x_ = extent[0];\n      }\n      if (point[1] == extent[1]) {\n        y_ = extent[3];\n      } else if (point[1] == extent[3]) {\n        y_ = extent[1];\n      }\n      if (x_ !== null && y_ !== null) {\n        return [x_, y_];\n      }\n      return null;\n    };\n    if (vertex && extent) {\n      const x =\n        vertex[0] == extent[0] || vertex[0] == extent[2] ? vertex[0] : null;\n      const y =\n        vertex[1] == extent[1] || vertex[1] == extent[3] ? vertex[1] : null;\n\n      //snap to point\n      if (x !== null && y !== null) {\n        this.pointerHandler_ = getPointHandler(getOpposingPoint(vertex));\n        //snap to edge\n      } else if (x !== null) {\n        this.pointerHandler_ = getEdgeHandler(\n          getOpposingPoint([x, extent[1]]),\n          getOpposingPoint([x, extent[3]])\n        );\n      } else if (y !== null) {\n        this.pointerHandler_ = getEdgeHandler(\n          getOpposingPoint([extent[0], y]),\n          getOpposingPoint([extent[2], y])\n        );\n      }\n      //no snap - new bbox\n    } else {\n      vertex = map.getCoordinateFromPixelInternal(pixel);\n      this.setExtent([vertex[0], vertex[1], vertex[0], vertex[1]]);\n      this.pointerHandler_ = getPointHandler(vertex);\n    }\n    return true; //event handled; start downup sequence\n  }\n\n  /**\n   * Handle pointer drag events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   */\n  handleDragEvent(mapBrowserEvent) {\n    if (this.pointerHandler_) {\n      const pixelCoordinate = mapBrowserEvent.coordinate;\n      this.setExtent(this.pointerHandler_(pixelCoordinate));\n      this.createOrUpdatePointerFeature_(pixelCoordinate);\n    }\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleUpEvent(mapBrowserEvent) {\n    this.pointerHandler_ = null;\n    //If bbox is zero area, set to null;\n    const extent = this.getExtentInternal();\n    if (!extent || getArea(extent) === 0) {\n      this.setExtent(null);\n    }\n    return false; //Stop handling downup sequence\n  }\n\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../Map.js\").default} map Map.\n   */\n  setMap(map) {\n    this.extentOverlay_.setMap(map);\n    this.vertexOverlay_.setMap(map);\n    super.setMap(map);\n  }\n\n  /**\n   * Returns the current drawn extent in the view projection (or user projection if set)\n   *\n   * @return {import(\"../extent.js\").Extent} Drawn extent in the view projection.\n   * @api\n   */\n  getExtent() {\n    return toUserExtent(\n      this.getExtentInternal(),\n      this.getMap().getView().getProjection()\n    );\n  }\n\n  /**\n   * Returns the current drawn extent in the view projection\n   *\n   * @return {import(\"../extent.js\").Extent} Drawn extent in the view projection.\n   * @api\n   */\n  getExtentInternal() {\n    return this.extent_;\n  }\n\n  /**\n   * Manually sets the drawn extent, using the view projection.\n   *\n   * @param {import(\"../extent.js\").Extent} extent Extent\n   * @api\n   */\n  setExtent(extent) {\n    //Null extent means no bbox\n    this.extent_ = extent ? extent : null;\n    this.createOrUpdateExtentFeature_(extent);\n    this.dispatchEvent(new ExtentEvent(this.extent_));\n  }\n}\n\n/**\n * Returns the default style for the drawn bbox\n *\n * @return {import(\"../style/Style.js\").StyleFunction} Default Extent style\n */\nfunction getDefaultExtentStyleFunction() {\n  const style = createEditingStyle();\n  return function (feature, resolution) {\n    return style['Polygon'];\n  };\n}\n\n/**\n * Returns the default style for the pointer\n *\n * @return {import(\"../style/Style.js\").StyleFunction} Default pointer style\n */\nfunction getDefaultPointerStyleFunction() {\n  const style = createEditingStyle();\n  return function (feature, resolution) {\n    return style['Point'];\n  };\n}\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} fixedPoint corner that will be unchanged in the new extent\n * @return {function (import(\"../coordinate.js\").Coordinate): import(\"../extent.js\").Extent} event handler\n */\nfunction getPointHandler(fixedPoint) {\n  return function (point) {\n    return boundingExtent([fixedPoint, point]);\n  };\n}\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} fixedP1 first corner that will be unchanged in the new extent\n * @param {import(\"../coordinate.js\").Coordinate} fixedP2 second corner that will be unchanged in the new extent\n * @return {function (import(\"../coordinate.js\").Coordinate): import(\"../extent.js\").Extent|null} event handler\n */\nfunction getEdgeHandler(fixedP1, fixedP2) {\n  if (fixedP1[0] == fixedP2[0]) {\n    return function (point) {\n      return boundingExtent([fixedP1, [point[0], fixedP2[1]]]);\n    };\n  }\n  if (fixedP1[1] == fixedP2[1]) {\n    return function (point) {\n      return boundingExtent([fixedP1, [fixedP2[0], point[1]]]);\n    };\n  }\n  return null;\n}\n\n/**\n * @param {import(\"../extent.js\").Extent} extent extent\n * @return {Array<Array<import(\"../coordinate.js\").Coordinate>>} extent line segments\n */\nfunction getSegments(extent) {\n  return [\n    [\n      [extent[0], extent[1]],\n      [extent[0], extent[3]],\n    ],\n    [\n      [extent[0], extent[3]],\n      [extent[2], extent[3]],\n    ],\n    [\n      [extent[2], extent[3]],\n      [extent[2], extent[1]],\n    ],\n    [\n      [extent[2], extent[1]],\n      [extent[0], extent[1]],\n    ],\n  ];\n}\n\nexport default Extent;\n","/**\n * @module ol/events/SnapEvent\n */\nimport Event from './Event.js';\n\n/**\n * @enum {string}\n */\nexport const SnapEventType = {\n  /**\n   * Triggered upon snapping to vertex or edge\n   * @event SnapEvent#snap\n   * @api\n   */\n  SNAP: 'snap',\n};\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/Snap~Snap} instances are instances of this\n */\nexport class SnapEvent extends Event {\n  /**\n   * @param {SnapEventType} type Type.\n   * @param {Object} options Options.\n   * @param {import(\"../coordinate.js\").Coordinate} options.vertex The snapped vertex.\n   * @param {import(\"../coordinate.js\").Coordinate} options.vertexPixel The pixel of the snapped vertex.\n   * @param {import(\"../Feature.js\").default} options.feature The feature being snapped.\n   */\n  constructor(type, options) {\n    super(type);\n    /**\n     * The Map coordinate of the snapped point.\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @api\n     */\n    this.vertex = options.vertex;\n    /**\n     * The Map pixel of the snapped point.\n     * @type {Array<number>&Array<number>}\n     * @api\n     */\n    this.vertexPixel = options.vertexPixel;\n    /**\n     * The feature closest to the snapped point.\n     * @type {import(\"../Feature.js\").default<import(\"../geom/Geometry.js\").default>}\n     * @api\n     */\n    this.feature = options.feature;\n  }\n}\n","/**\n * @module ol/interaction/Snap\n */\nimport CollectionEventType from '../CollectionEventType.js';\nimport EventType from '../events/EventType.js';\nimport PointerInteraction from './Pointer.js';\nimport RBush from '../structs/RBush.js';\nimport VectorEventType from '../source/VectorEventType.js';\nimport {FALSE, TRUE} from '../functions.js';\nimport {SnapEvent, SnapEventType} from '../events/SnapEvent.js';\nimport {boundingExtent, buffer, createEmpty} from '../extent.js';\nimport {\n  closestOnCircle,\n  closestOnSegment,\n  squaredDistance,\n} from '../coordinate.js';\nimport {fromCircle} from '../geom/Polygon.js';\nimport {\n  fromUserCoordinate,\n  getUserProjection,\n  toUserCoordinate,\n  toUserExtent,\n} from '../proj.js';\nimport {getUid} from '../util.js';\nimport {listen, unlistenByKey} from '../events.js';\n\n/**\n * @typedef {Object} Result\n * @property {import(\"../coordinate.js\").Coordinate|null} vertex Vertex.\n * @property {import(\"../pixel.js\").Pixel|null} vertexPixel VertexPixel.\n * @property {import(\"../Feature.js\").default|null} feature Feature.\n */\n\n/**\n * @typedef {Object} SegmentData\n * @property {import(\"../Feature.js\").default} feature Feature.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} segment Segment.\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../Collection.js\").default<import(\"../Feature.js\").default>} [features] Snap to these features. Either this option or source should be provided.\n * @property {boolean} [edge=true] Snap to edges.\n * @property {boolean} [vertex=true] Snap to vertices.\n * @property {number} [pixelTolerance=10] Pixel tolerance for considering the pointer close enough to a segment or\n * vertex for snapping.\n * @property {import(\"../source/Vector.js\").default} [source] Snap to features from this source. Either this option or features should be provided\n */\n\n/**\n * @param  {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} evt Event.\n * @return {import(\"../Feature.js\").default|null} Feature.\n */\nfunction getFeatureFromEvent(evt) {\n  if (\n    /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */ (evt).feature\n  ) {\n    return /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */ (evt)\n      .feature;\n  }\n  if (\n    /** @type {import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} */ (\n      evt\n    ).element\n  ) {\n    return /** @type {import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} */ (\n      evt\n    ).element;\n  }\n  return null;\n}\n\nconst tempSegment = [];\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'snap', SnapEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'snap', Return>} SnapOnSignature\n */\n\n/**\n * @classdesc\n * Handles snapping of vector features while modifying or drawing them.  The\n * features can come from a {@link module:ol/source/Vector~VectorSource} or {@link module:ol/Collection~Collection}\n * Any interaction object that allows the user to interact\n * with the features using the mouse can benefit from the snapping, as long\n * as it is added before.\n *\n * The snap interaction modifies map browser event `coordinate` and `pixel`\n * properties to force the snap to occur to any interaction that them.\n *\n * Example:\n *\n *     import Snap from 'ol/interaction/Snap.js';\n *\n *     const snap = new Snap({\n *       source: source\n *     });\n *\n *     map.addInteraction(snap);\n *\n * @fires SnapEvent\n * @api\n */\nclass Snap extends PointerInteraction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const pointerOptions = /** @type {import(\"./Pointer.js\").Options} */ (\n      options\n    );\n\n    if (!pointerOptions.handleDownEvent) {\n      pointerOptions.handleDownEvent = TRUE;\n    }\n\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n\n    super(pointerOptions);\n\n    /***\n     * @type {SnapOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {SnapOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {SnapOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @type {import(\"../source/Vector.js\").default|null}\n     * @private\n     */\n    this.source_ = options.source ? options.source : null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.vertex_ = options.vertex !== undefined ? options.vertex : true;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.edge_ = options.edge !== undefined ? options.edge : true;\n\n    /**\n     * @type {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|null}\n     * @private\n     */\n    this.features_ = options.features ? options.features : null;\n\n    /**\n     * @type {Array<import(\"../events.js\").EventsKey>}\n     * @private\n     */\n    this.featuresListenerKeys_ = [];\n\n    /**\n     * @type {Object<string, import(\"../events.js\").EventsKey>}\n     * @private\n     */\n    this.featureChangeListenerKeys_ = {};\n\n    /**\n     * Extents are preserved so indexed segment can be quickly removed\n     * when its feature geometry changes\n     * @type {Object<string, import(\"../extent.js\").Extent>}\n     * @private\n     */\n    this.indexedFeaturesExtents_ = {};\n\n    /**\n     * If a feature geometry changes while a pointer drag|move event occurs, the\n     * feature doesn't get updated right away.  It will be at the next 'pointerup'\n     * event fired.\n     * @type {!Object<string, import(\"../Feature.js\").default>}\n     * @private\n     */\n    this.pendingFeatures_ = {};\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.pixelTolerance_ =\n      options.pixelTolerance !== undefined ? options.pixelTolerance : 10;\n\n    /**\n     * Segment RTree for each layer\n     * @type {import(\"../structs/RBush.js\").default<SegmentData>}\n     * @private\n     */\n    this.rBush_ = new RBush();\n\n    /**\n     * @const\n     * @private\n     * @type {Object<string, function(Array<Array<import('../coordinate.js').Coordinate>>, import(\"../geom/Geometry.js\").default): void>}\n     */\n    this.GEOMETRY_SEGMENTERS_ = {\n      'Point': this.segmentPointGeometry_.bind(this),\n      'LineString': this.segmentLineStringGeometry_.bind(this),\n      'LinearRing': this.segmentLineStringGeometry_.bind(this),\n      'Polygon': this.segmentPolygonGeometry_.bind(this),\n      'MultiPoint': this.segmentMultiPointGeometry_.bind(this),\n      'MultiLineString': this.segmentMultiLineStringGeometry_.bind(this),\n      'MultiPolygon': this.segmentMultiPolygonGeometry_.bind(this),\n      'GeometryCollection': this.segmentGeometryCollectionGeometry_.bind(this),\n      'Circle': this.segmentCircleGeometry_.bind(this),\n    };\n  }\n\n  /**\n   * Add a feature to the collection of features that we may snap to.\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {boolean} [register] Whether to listen to the feature change or not\n   *     Defaults to `true`.\n   * @api\n   */\n  addFeature(feature, register) {\n    register = register !== undefined ? register : true;\n    const feature_uid = getUid(feature);\n    const geometry = feature.getGeometry();\n    if (geometry) {\n      const segmenter = this.GEOMETRY_SEGMENTERS_[geometry.getType()];\n      if (segmenter) {\n        this.indexedFeaturesExtents_[feature_uid] = geometry.getExtent(\n          createEmpty()\n        );\n        const segments =\n          /** @type {Array<Array<import('../coordinate.js').Coordinate>>} */ ([]);\n        segmenter(segments, geometry);\n        if (segments.length === 1) {\n          this.rBush_.insert(boundingExtent(segments[0]), {\n            feature: feature,\n            segment: segments[0],\n          });\n        } else if (segments.length > 1) {\n          const extents = segments.map((s) => boundingExtent(s));\n          const segmentsData = segments.map((segment) => ({\n            feature: feature,\n            segment: segment,\n          }));\n          this.rBush_.load(extents, segmentsData);\n        }\n      }\n    }\n\n    if (register) {\n      this.featureChangeListenerKeys_[feature_uid] = listen(\n        feature,\n        EventType.CHANGE,\n        this.handleFeatureChange_,\n        this\n      );\n    }\n  }\n\n  /**\n   * @return {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|Array<import(\"../Feature.js\").default>} Features.\n   * @private\n   */\n  getFeatures_() {\n    /** @type {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|Array<import(\"../Feature.js\").default>} */\n    let features;\n    if (this.features_) {\n      features = this.features_;\n    } else if (this.source_) {\n      features = this.source_.getFeatures();\n    }\n    return features;\n  }\n\n  /**\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   * @api\n   */\n  handleEvent(evt) {\n    const result = this.snapTo(evt.pixel, evt.coordinate, evt.map);\n    if (result) {\n      evt.coordinate = result.vertex.slice(0, 2);\n      evt.pixel = result.vertexPixel;\n      this.dispatchEvent(\n        new SnapEvent(SnapEventType.SNAP, {\n          vertex: evt.coordinate,\n          vertexPixel: evt.pixel,\n          feature: result.feature,\n        })\n      );\n    }\n    return super.handleEvent(evt);\n  }\n\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} evt Event.\n   * @private\n   */\n  handleFeatureAdd_(evt) {\n    const feature = getFeatureFromEvent(evt);\n    if (feature) {\n      this.addFeature(feature);\n    }\n  }\n\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} evt Event.\n   * @private\n   */\n  handleFeatureRemove_(evt) {\n    const feature = getFeatureFromEvent(evt);\n    if (feature) {\n      this.removeFeature(feature);\n    }\n  }\n\n  /**\n   * @param {import(\"../events/Event.js\").default} evt Event.\n   * @private\n   */\n  handleFeatureChange_(evt) {\n    const feature = /** @type {import(\"../Feature.js\").default} */ (evt.target);\n    if (this.handlingDownUpSequence) {\n      const uid = getUid(feature);\n      if (!(uid in this.pendingFeatures_)) {\n        this.pendingFeatures_[uid] = feature;\n      }\n    } else {\n      this.updateFeature_(feature);\n    }\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleUpEvent(evt) {\n    const featuresToUpdate = Object.values(this.pendingFeatures_);\n    if (featuresToUpdate.length) {\n      featuresToUpdate.forEach(this.updateFeature_.bind(this));\n      this.pendingFeatures_ = {};\n    }\n    return false;\n  }\n\n  /**\n   * Remove a feature from the collection of features that we may snap to.\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {boolean} [unlisten] Whether to unlisten to the feature change\n   *     or not. Defaults to `true`.\n   * @api\n   */\n  removeFeature(feature, unlisten) {\n    const unregister = unlisten !== undefined ? unlisten : true;\n    const feature_uid = getUid(feature);\n    const extent = this.indexedFeaturesExtents_[feature_uid];\n    if (extent) {\n      const rBush = this.rBush_;\n      const nodesToRemove = [];\n      rBush.forEachInExtent(extent, function (node) {\n        if (feature === node.feature) {\n          nodesToRemove.push(node);\n        }\n      });\n      for (let i = nodesToRemove.length - 1; i >= 0; --i) {\n        rBush.remove(nodesToRemove[i]);\n      }\n    }\n\n    if (unregister) {\n      unlistenByKey(this.featureChangeListenerKeys_[feature_uid]);\n      delete this.featureChangeListenerKeys_[feature_uid];\n    }\n  }\n\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../Map.js\").default} map Map.\n   */\n  setMap(map) {\n    const currentMap = this.getMap();\n    const keys = this.featuresListenerKeys_;\n    const features = /** @type {Array<import(\"../Feature.js\").default>} */ (\n      this.getFeatures_()\n    );\n\n    if (currentMap) {\n      keys.forEach(unlistenByKey);\n      keys.length = 0;\n      this.rBush_.clear();\n      Object.values(this.featureChangeListenerKeys_).forEach(unlistenByKey);\n      this.featureChangeListenerKeys_ = {};\n    }\n    super.setMap(map);\n\n    if (map) {\n      if (this.features_) {\n        keys.push(\n          listen(\n            this.features_,\n            CollectionEventType.ADD,\n            this.handleFeatureAdd_,\n            this\n          ),\n          listen(\n            this.features_,\n            CollectionEventType.REMOVE,\n            this.handleFeatureRemove_,\n            this\n          )\n        );\n      } else if (this.source_) {\n        keys.push(\n          listen(\n            this.source_,\n            VectorEventType.ADDFEATURE,\n            this.handleFeatureAdd_,\n            this\n          ),\n          listen(\n            this.source_,\n            VectorEventType.REMOVEFEATURE,\n            this.handleFeatureRemove_,\n            this\n          )\n        );\n      }\n      features.forEach((feature) => this.addFeature(feature));\n    }\n  }\n\n  /**\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel\n   * @param {import(\"../coordinate.js\").Coordinate} pixelCoordinate Coordinate\n   * @param {import(\"../Map.js\").default} map Map.\n   * @return {Result|null} Snap result\n   */\n  snapTo(pixel, pixelCoordinate, map) {\n    const projection = map.getView().getProjection();\n    const projectedCoordinate = fromUserCoordinate(pixelCoordinate, projection);\n\n    const box = toUserExtent(\n      buffer(\n        boundingExtent([projectedCoordinate]),\n        map.getView().getResolution() * this.pixelTolerance_\n      ),\n      projection\n    );\n\n    const segments = this.rBush_.getInExtent(box);\n    const segmentsLength = segments.length;\n    if (segmentsLength === 0) {\n      return null;\n    }\n\n    let closestVertex;\n    let minSquaredDistance = Infinity;\n    let closestFeature;\n\n    const squaredPixelTolerance = this.pixelTolerance_ * this.pixelTolerance_;\n    const getResult = () => {\n      if (closestVertex) {\n        const vertexPixel = map.getPixelFromCoordinate(closestVertex);\n        const squaredPixelDistance = squaredDistance(pixel, vertexPixel);\n        if (squaredPixelDistance <= squaredPixelTolerance) {\n          return {\n            vertex: closestVertex,\n            vertexPixel: [\n              Math.round(vertexPixel[0]),\n              Math.round(vertexPixel[1]),\n            ],\n            feature: closestFeature,\n          };\n        }\n      }\n      return null;\n    };\n\n    if (this.vertex_) {\n      for (let i = 0; i < segmentsLength; ++i) {\n        const segmentData = segments[i];\n        if (segmentData.feature.getGeometry().getType() !== 'Circle') {\n          segmentData.segment.forEach((vertex) => {\n            const tempVertexCoord = fromUserCoordinate(vertex, projection);\n            const delta = squaredDistance(projectedCoordinate, tempVertexCoord);\n            if (delta < minSquaredDistance) {\n              closestVertex = vertex;\n              minSquaredDistance = delta;\n              closestFeature = segmentData.feature;\n            }\n          });\n        }\n      }\n      const result = getResult();\n      if (result) {\n        return result;\n      }\n    }\n\n    if (this.edge_) {\n      for (let i = 0; i < segmentsLength; ++i) {\n        let vertex = null;\n        const segmentData = segments[i];\n        if (segmentData.feature.getGeometry().getType() === 'Circle') {\n          let circleGeometry = segmentData.feature.getGeometry();\n          const userProjection = getUserProjection();\n          if (userProjection) {\n            circleGeometry = circleGeometry\n              .clone()\n              .transform(userProjection, projection);\n          }\n          vertex = closestOnCircle(\n            projectedCoordinate,\n            /** @type {import(\"../geom/Circle.js\").default} */ (circleGeometry)\n          );\n        } else {\n          const [segmentStart, segmentEnd] = segmentData.segment;\n          // points have only one coordinate\n          if (segmentEnd) {\n            tempSegment[0] = fromUserCoordinate(segmentStart, projection);\n            tempSegment[1] = fromUserCoordinate(segmentEnd, projection);\n            vertex = closestOnSegment(projectedCoordinate, tempSegment);\n          }\n        }\n        if (vertex) {\n          const delta = squaredDistance(projectedCoordinate, vertex);\n          if (delta < minSquaredDistance) {\n            closestVertex = toUserCoordinate(vertex, projection);\n            minSquaredDistance = delta;\n          }\n        }\n      }\n\n      const result = getResult();\n      if (result) {\n        return result;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @private\n   */\n  updateFeature_(feature) {\n    this.removeFeature(feature, false);\n    this.addFeature(feature, false);\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/Circle.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentCircleGeometry_(segments, geometry) {\n    const projection = this.getMap().getView().getProjection();\n    let circleGeometry = geometry;\n    const userProjection = getUserProjection();\n    if (userProjection) {\n      circleGeometry = /** @type {import(\"../geom/Circle.js\").default} */ (\n        circleGeometry.clone().transform(userProjection, projection)\n      );\n    }\n    const polygon = fromCircle(circleGeometry);\n    if (userProjection) {\n      polygon.transform(projection, userProjection);\n    }\n    const coordinates = polygon.getCoordinates()[0];\n    for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      segments.push(coordinates.slice(i, i + 2));\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentGeometryCollectionGeometry_(segments, geometry) {\n    const geometries = geometry.getGeometriesArray();\n    for (let i = 0; i < geometries.length; ++i) {\n      const segmenter = this.GEOMETRY_SEGMENTERS_[geometries[i].getType()];\n      if (segmenter) {\n        segmenter(segments, geometries[i]);\n      }\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/LineString.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentLineStringGeometry_(segments, geometry) {\n    const coordinates = geometry.getCoordinates();\n    for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      segments.push(coordinates.slice(i, i + 2));\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/MultiLineString.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentMultiLineStringGeometry_(segments, geometry) {\n    const lines = geometry.getCoordinates();\n    for (let j = 0, jj = lines.length; j < jj; ++j) {\n      const coordinates = lines[j];\n      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        segments.push(coordinates.slice(i, i + 2));\n      }\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/MultiPoint.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentMultiPointGeometry_(segments, geometry) {\n    geometry.getCoordinates().forEach((point) => {\n      segments.push([point]);\n    });\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentMultiPolygonGeometry_(segments, geometry) {\n    const polygons = geometry.getCoordinates();\n    for (let k = 0, kk = polygons.length; k < kk; ++k) {\n      const rings = polygons[k];\n      for (let j = 0, jj = rings.length; j < jj; ++j) {\n        const coordinates = rings[j];\n        for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n          segments.push(coordinates.slice(i, i + 2));\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/Point.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentPointGeometry_(segments, geometry) {\n    segments.push([geometry.getCoordinates()]);\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/Polygon.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentPolygonGeometry_(segments, geometry) {\n    const rings = geometry.getCoordinates();\n    for (let j = 0, jj = rings.length; j < jj; ++j) {\n      const coordinates = rings[j];\n      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        segments.push(coordinates.slice(i, i + 2));\n      }\n    }\n  }\n}\n\nexport default Snap;\n"],"names":["ol_control_TextButton","constructor","options","className","super","ol_control_Toggle","toggleFn","onToggle","handleClick","self","toggle","call","getActive","this","interaction_","interaction","setActive","active","on","set","title","autoActivate","bar","setSubBar","setDisable","disable","setMap","map","getMap","removeInteraction","subbar_","removeControl","addInteraction","addControl","getSubBar","setTarget","element","classList","add","getDisable","button","querySelector","disabled","b","dispatchEvent","type","key","oldValue","contains","remove","setInteraction","i","getInteraction","ol_extent_intersection","ol_coordinate_dist2d","p1","p2","dx","dy","Math","sqrt","ol_coordinate_equal","ol_coordinate_offsetCoords","coords","offset","mi","mi1","li","li1","ri","ri1","si","si1","Xi1","Yi1","p0","path","N","length","max","isClosed","push","abs","pop","ol_coordinate_findSegment","pt","index","segment","d0","v0","d1","v1","splitX","pts","x","splice","splitY","y","extent","polygon","poly","getType","geom","getCoordinates","forEach","g","c","p","ol_coordinate_sampleAt","d","start","dl","nb","round","prototype","sampleAt","line","result","concat","lines","l","res","mpoly","a","intersection","resolution","ext","getCenter","getRadius","simplify","r","hasout","ring","console","warn","splitAt","tol","k","getFirstCoordinate","getLastCoordinate","c0","ci","d2","split","ol_interaction_Delete","e","getFeatures","clear","delete","selected","bind","_getSources","layers","getLayers","sources","getSource","features","getLength","delFeatures","source","f","removeFeature","ol_interaction_DrawHole","_geometryFn","coordinates","geometry","coord","getPolygon","intersectsCoordinate","lastOKCoord","setCoordinates","geomFn","geometryFunction","_select","style","layers_","indexOf","_features","featureFilter","item","getArray","_startDrawing","_finishDrawing","removeLastPoint","_feature","getGeometry","_polygon","feature","_current","forEachFeatureAtPixel","getPixelFromCoordinate","layer","_polygonIndex","layerFilter","hole","pi","newGeom","appendLinearRing","appendPolygon","setGeometry","ol_interaction_DrawRegular","handleEvent","handleEvent_","squaredClickTolerance_","clickTolerance","maxCircleCoordinates_","maxCircleCoordinates","features_","source_","conditionFn_","condition","squareFn_","squareCondition","centeredFn_","centerCondition","canRotate_","canRotate","geometryName_","geometryName","setSides","sides","defaultStyle","sketch_","overlayLayer_","useSpatialIndex","name","displayInLayerSwitcher","removeLayer","reset","started_","parseInt","sides_","getSides","getGeom_","center_","coord_","dmax","circle","centerPx","center","square_","centered_","coordPx_","min","hasrotation","dm","atan2","startAngle","getExtent","scx","scy","sc","sign","t","applyTransform","g1","g2","dim","drawSketch_","evt","originalEvent","shiftKey","metaKey","ctrlKey","feature_","addFeature","drawPoint_","noclear","_eventTime","Date","downPx_","pixel","start_","dt","_longTouch","setTimeout","handleMoveEvent_","lastEvent","end_","upPx_","coordinate","finishDrawing","startCoordinate","square","centered","setGeometryName","PI","ol_interaction_ModifyFeature","dragging","modifying","handleDownEvent","_deleteCondition","handleUpEvent","handleDragEvent","handleMoveEvent","snapDistance_","pixelTolerance","tolerance_","cursor_","cursor","sources_","Array","filterSplit_","filter","_condition","deleteCondition","_insertVertexCondition","insertVertexCondition","sketchStyle","image","radius","fill","color","stroke","width","wrapX","setFilter","undefined","getClosestFeature","getClosestFeatureToCoordinate","getClosestPoint","di","frameState","viewState","currentFeature","deselected","getNearestCoord","dist","Number","MAX_VALUE","lstring","getLineStrings","lring","getLinearRings","getPolygons","getGeometries","getArcs","s","arcs","coord1","coord2","node","shift","c1","nbpt","closed","end","typeg","error","current","getFeaturesInExtent","_modifiedFeatures","_removePoint","getModifiedFeatures","removePoint","_getModification","geoms","found","setGeometries","setArcCoordinates","getTargetElement","previousCursor_","getCurrentFeature","ol_interaction_Offset","handleDownEvent_","handleDragEvent_","handleUpEvent_","_filter","duplicate","_style","getFeatureAtPixel_","typeGeom","test","hit","clone","geomType","hitTolerance","current_","currentStyle_","getStyle","get","setStyle","_modifystart","seg","v2","ol_interaction_Split","snapDistance","tolerance","setSources","white","blue","featureStyle","_sketch_","getSources","getVisible","unshift","fi","gi","link","tosplit","original","linkGeometry","ol_interaction_Transform","selection_","handles_","_handleEvent","addFn_","addCondition","setPointRadius","pointRadius","translateFeature","translate","translateBBox","stretch","scale","rotate","keepAspectRatio","modifyCenter","noFlip","selection","enableRotatedTransform","keepRectangle","buffer","setDefaultStyle","oldMap","targetElement","select","isTouch","getViewport","setVisible","pointStroke","strokedash","lineDash","fill0","pointFill","displacement","points","setDisplacement","getAnchor","bigpt","angle","smallpt","createStyle","img","olstyle","im","getImage","setScale","tx","getText","setOffsetX","bbox_","handle","constraint","option","some","getGeometryRotateToZero_","origGeom","viewRotation","getView","getRotation","rotGeom","_isRectangle","slice","extendExt","ptRadius","_pointRadius","ispt_","getCoordinateFromPixel","iscircle_","addFeatures","removeAt","watchFeatures_","setSelection","_featureListeners","isUpdating_","sel","mode_","opt_","constraint_","coordinate_","pixel_","geoms_","rotatedGeoms_","rotExtent","extent_","rotatedExtent_","Cursors","rotate0","angle_","setCenter","j","pt0","ispt","setCenterAndRadius","deltaX","deltaY","delta","extentCoordinates","opt","downCoordinate","dragCoordinate","downPoint","dragPoint","displacementVector","centerPoint","pointArray","pointA","pointB","pointC","pointD","pointA1","base","_countVector","projectedVector","_projectVectorOnVector","nextIndex","coordsToChange","includes","projectedLeft","projectedRight","_movePoint","default","oldgeom","oldgeoms","displacement_vector","point","opt_fast","ol_interaction_UndoRedo","_layers","_undoStack","_redoStack","_undo","_redo","level","_level","view","zoom","getZoom","action","_reduce","_doShift","_doClear","_block","_record","_defs","define","undoFn","redoFn","undo","redo","setMaxLength","size","setMaxSize","getStack","prop","custom","_mapListener","blockStart","blockEnd","_watchSources","_watchInteractions","_sourceListener","getVectorLayers","init","vectors","_onAddRemove","_interactionListener","getInteractions","_onInteraction","target","fn","_handleDo","oldGeom","newp","newProperties","oldp","oldProperties","unset","hasUndo","hasRedo","setattributestart","Object","assign","properties","rotatestart","translatestart","scalestart","modifystart","replace","m","beforesplit","deletestart","aftersplit","deleteend","ol_style_Style_defaultStyle","defaultEditStyle","edit","fillColor","Circle","layout","setFlatCoordinates","flatCoordinates","applyProperties","closestPointXY","closestPoint","minSquaredDistance","squaredDistance","stride","containsXY","getRadiusSquared_","computeExtent","intersectsExtent","circleExtent","changed","setLayout","ii","setRadius","anchor","getStride","transform","DrawEventType","DRAWSTART","DRAWEND","DRAWABORT","DrawEvent","getTraceTargets","targets","appendGeometryTraceTargets","getSquaredDistance","getCoordinate","count","getCumulativeSquaredDistance","startIndex","endIndex","lowIndex","highIndex","lowWholeIndex","ceil","highWholeIndex","floor","interpolateCoordinate","sd","appendTraceTarget","polys","jj","geometries","sharedUpdateInfo","NaN","getTraceTargetUpdate","traceState","snapTolerance","closestTargetDistance","Infinity","newTargetIndex","newEndIndex","targetIndex","minSegmentDistance","coordinateIndex","rel","getPointSegmentRelationship","along","newTarget","considerBothDirections","newCoordinate","startPx","forwardDistance","reverseDistance","sharedRel","x1","y1","x2","y2","px","py","x0","y0","Draw","pointerOptions","stopDown","once","un","shouldHandle_","downTimeout_","lastDragTime_","pointerType_","freehand_","snapTolerance_","type_","getMode","stopClick_","stopClick","minPoints_","minPoints","maxPoints_","maxPoints","finishCondition_","finishCondition","geometryLayout_","geometryLayout","mode","projection","fromUserCoordinate","squaredLength","userProjection","getUserProjection","Constructor","geometryFunction_","dragVertexDelay_","dragVertexDelay","finishCoordinate_","sketchFeature_","sketchPoint_","sketchCoords_","sketchLine_","sketchLineCoords_","overlay_","getDefaultStyleFunction","updateWhileInteracting","condition_","freehandCondition_","freehand","freehandCondition","traceCondition_","setTrace","trace","traceState_","traceSource_","traceSource","addChangeListener","ACTIVE","updateState_","getOverlay","event","CONTEXTMENU","preventDefault","move","POINTERMOVE","pass","POINTERDRAG","now","clearTimeout","addToDrawing_","POINTERDOWN","getPointerCount","handlePointerMove_","pointerType","DBLCLICK","startDrawing_","deactivateTrace_","toggleTraceState_","lowerLeft","upperRight","addOrRemoveTracedCoordinates_","previouslyForward","currentlyForward","addTracedCoordinates_","removeTracedCoordinates_","fromIndex","toIndex","removeLastPoints_","appendCoordinates","updateTrace_","updatedTraceTarget","oldTarget","tracing","startingToDraw","atFinish_","abortDrawing","downPx","clickPx","modifyDrawing_","createOrUpdateSketchPoint_","at","potentiallyDone","potentiallyFinishCoordinates","sketchCoords","finishCoordinate","finishPixel","sketchPointGeom","updateSketchFeatures_","createOrUpdateCustomSketchLine_","getLinearRing","sketchLineGeom","getLayout","getFlatCoordinates","getProjection","last","done","n","sketchFeature","abortDrawing_","newDrawing","ending","extend","lineString","sketchFeatures","overlaySource","styles","createEditingStyle","Error","ExtentEventType","EXTENTCHANGED","ExtentEvent","Extent","pointerHandler_","pixelTolerance_","snappedToVertex_","extentFeature_","vertexFeature_","extentOverlay_","boxStyle","getDefaultExtentStyleFunction","updateWhileAnimating","vertexOverlay_","pointerStyle","getDefaultPointerStyleFunction","setExtent","snapToVertex_","pixelCoordinate","getCoordinateFromPixelInternal","sortByDistance","getExtentInternal","segments","getSegments","sort","closestSegment","vertex","vertexPixel","getPixelFromCoordinateInternal","pixel1","pixel2","squaredDist1","squaredDist2","mapBrowserEvent","createOrUpdatePointerFeature_","createOrUpdateExtentFeature_","extentFeature","vertexFeature","handlingDownUpSequence","getOpposingPoint","x_","y_","getPointHandler","getEdgeHandler","toUserExtent","fixedPoint","fixedP1","fixedP2","SnapEventType","SNAP","SnapEvent","Event","getFeatureFromEvent","tempSegment","Snap","Pointer","vertex_","edge_","edge","featuresListenerKeys_","featureChangeListenerKeys_","indexedFeaturesExtents_","pendingFeatures_","rBush_","RBush","GEOMETRY_SEGMENTERS_","segmentPointGeometry_","segmentLineStringGeometry_","segmentPolygonGeometry_","segmentMultiPointGeometry_","segmentMultiLineStringGeometry_","segmentMultiPolygonGeometry_","segmentGeometryCollectionGeometry_","segmentCircleGeometry_","register","feature_uid","segmenter","insert","extents","segmentsData","load","EventType","CHANGE","handleFeatureChange_","getFeatures_","snapTo","handleFeatureAdd_","handleFeatureRemove_","uid","updateFeature_","featuresToUpdate","values","unlisten","unregister","rBush","nodesToRemove","forEachInExtent","currentMap","keys","CollectionEventType","ADD","REMOVE","VectorEventType","ADDFEATURE","REMOVEFEATURE","projectedCoordinate","box","getResolution","getInExtent","segmentsLength","closestVertex","closestFeature","squaredPixelTolerance","getResult","squaredPixelDistance","segmentData","tempVertexCoord","circleGeometry","segmentStart","segmentEnd","toUserCoordinate","getGeometriesArray","polygons","kk","rings"],"sourceRoot":""}
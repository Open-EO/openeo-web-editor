{"version":3,"file":"js/2559.b3a3a773.js","mappings":"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","sources":["webpack://@openeo/web-editor/./node_modules/ol/renderer/canvas/ImageLayer.js","webpack://@openeo/web-editor/./node_modules/ol/renderer/canvas/Layer.js","webpack://@openeo/web-editor/./node_modules/ol/renderer/canvas/TileLayer.js","webpack://@openeo/web-editor/./node_modules/ol/renderer/canvas/VectorLayer.js","webpack://@openeo/web-editor/./node_modules/ol/renderer/canvas/VectorTileLayer.js","webpack://@openeo/web-editor/./node_modules/ol/renderer/vector.js","webpack://@openeo/web-editor/./node_modules/ol/renderer/webgl/Layer.js","webpack://@openeo/web-editor/./node_modules/ol/renderer/webgl/worldUtil.js","webpack://@openeo/web-editor/./node_modules/ol/renderer/webgl/PointsLayer.js","webpack://@openeo/web-editor/./node_modules/ol/renderer/webgl/TileLayerBase.js","webpack://@openeo/web-editor/./node_modules/ol/renderer/webgl/TileLayer.js"],"sourcesContent":["/**\n * @module ol/renderer/canvas/ImageLayer\n */\nimport CanvasLayerRenderer from './Layer.js';\nimport ImageState from '../../ImageState.js';\nimport ViewHint from '../../ViewHint.js';\nimport {\n  apply as applyTransform,\n  compose as composeTransform,\n} from '../../transform.js';\nimport {\n  containsCoordinate,\n  containsExtent,\n  getHeight,\n  getIntersection,\n  getWidth,\n  intersects as intersectsExtent,\n  isEmpty,\n} from '../../extent.js';\nimport {fromUserExtent} from '../../proj.js';\n\n/**\n * @classdesc\n * Canvas renderer for image layers.\n * @api\n */\nclass CanvasImageLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {import(\"../../layer/Image.js\").default} imageLayer Image layer.\n   */\n  constructor(imageLayer) {\n    super(imageLayer);\n\n    /**\n     * @protected\n     * @type {?import(\"../../Image.js\").default}\n     */\n    this.image_ = null;\n  }\n\n  /**\n   * @return {import('../../DataTile.js').ImageLike} Image.\n   */\n  getImage() {\n    return !this.image_ ? null : this.image_.getImage();\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const viewResolution = viewState.resolution;\n\n    const imageSource = this.getLayer().getSource();\n\n    const hints = frameState.viewHints;\n\n    let renderedExtent = frameState.extent;\n    if (layerState.extent !== undefined) {\n      renderedExtent = getIntersection(\n        renderedExtent,\n        fromUserExtent(layerState.extent, viewState.projection),\n      );\n    }\n\n    if (\n      !hints[ViewHint.ANIMATING] &&\n      !hints[ViewHint.INTERACTING] &&\n      !isEmpty(renderedExtent)\n    ) {\n      if (imageSource) {\n        const projection = viewState.projection;\n        const image = imageSource.getImage(\n          renderedExtent,\n          viewResolution,\n          pixelRatio,\n          projection,\n        );\n        if (image) {\n          if (this.loadImage(image)) {\n            this.image_ = image;\n          } else if (image.getState() === ImageState.EMPTY) {\n            this.image_ = null;\n          }\n        }\n      } else {\n        this.image_ = null;\n      }\n    }\n\n    return !!this.image_;\n  }\n\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray} Data at the pixel location.\n   */\n  getData(pixel) {\n    const frameState = this.frameState;\n    if (!frameState) {\n      return null;\n    }\n\n    const layer = this.getLayer();\n    const coordinate = applyTransform(\n      frameState.pixelToCoordinateTransform,\n      pixel.slice(),\n    );\n\n    const layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (!containsCoordinate(layerExtent, coordinate)) {\n        return null;\n      }\n    }\n\n    const imageExtent = this.image_.getExtent();\n    const img = this.image_.getImage();\n\n    const imageMapWidth = getWidth(imageExtent);\n    const col = Math.floor(\n      img.width * ((coordinate[0] - imageExtent[0]) / imageMapWidth),\n    );\n    if (col < 0 || col >= img.width) {\n      return null;\n    }\n\n    const imageMapHeight = getHeight(imageExtent);\n    const row = Math.floor(\n      img.height * ((imageExtent[3] - coordinate[1]) / imageMapHeight),\n    );\n    if (row < 0 || row >= img.height) {\n      return null;\n    }\n\n    return this.getImageData(img, col, row);\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState, target) {\n    const image = this.image_;\n    const imageExtent = image.getExtent();\n    const imageResolution = image.getResolution();\n    const [imageResolutionX, imageResolutionY] = Array.isArray(imageResolution)\n      ? imageResolution\n      : [imageResolution, imageResolution];\n    const imagePixelRatio = image.getPixelRatio();\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const viewCenter = viewState.center;\n    const viewResolution = viewState.resolution;\n    const scaleX =\n      (pixelRatio * imageResolutionX) / (viewResolution * imagePixelRatio);\n    const scaleY =\n      (pixelRatio * imageResolutionY) / (viewResolution * imagePixelRatio);\n\n    this.prepareContainer(frameState, target);\n\n    // desired dimensions of the canvas in pixels\n    const width = this.context.canvas.width;\n    const height = this.context.canvas.height;\n\n    const context = this.getRenderContext(frameState);\n\n    // clipped rendering if layer extent is set\n    let clipped = false;\n    let render = true;\n    if (layerState.extent) {\n      const layerExtent = fromUserExtent(\n        layerState.extent,\n        viewState.projection,\n      );\n      render = intersectsExtent(layerExtent, frameState.extent);\n      clipped = render && !containsExtent(layerExtent, frameState.extent);\n      if (clipped) {\n        this.clipUnrotated(context, frameState, layerExtent);\n      }\n    }\n\n    const img = image.getImage();\n\n    const transform = composeTransform(\n      this.tempTransform,\n      width / 2,\n      height / 2,\n      scaleX,\n      scaleY,\n      0,\n      (imagePixelRatio * (imageExtent[0] - viewCenter[0])) / imageResolutionX,\n      (imagePixelRatio * (viewCenter[1] - imageExtent[3])) / imageResolutionY,\n    );\n\n    this.renderedResolution = (imageResolutionY * pixelRatio) / imagePixelRatio;\n\n    const dw = img.width * transform[0];\n    const dh = img.height * transform[3];\n\n    if (!this.getLayer().getSource().getInterpolate()) {\n      context.imageSmoothingEnabled = false;\n    }\n\n    this.preRender(context, frameState);\n    if (render && dw >= 0.5 && dh >= 0.5) {\n      const dx = transform[4];\n      const dy = transform[5];\n      const opacity = layerState.opacity;\n      if (opacity !== 1) {\n        context.save();\n        context.globalAlpha = opacity;\n      }\n      context.drawImage(img, 0, 0, +img.width, +img.height, dx, dy, dw, dh);\n      if (opacity !== 1) {\n        context.restore();\n      }\n    }\n    this.postRender(this.context, frameState);\n\n    if (clipped) {\n      context.restore();\n    }\n    context.imageSmoothingEnabled = true;\n\n    return this.container;\n  }\n}\n\nexport default CanvasImageLayerRenderer;\n","/**\n * @module ol/renderer/canvas/Layer\n */\nimport LayerRenderer from '../Layer.js';\nimport RenderEvent from '../../render/Event.js';\nimport RenderEventType from '../../render/EventType.js';\nimport ZIndexContext from '../../render/canvas/ZIndexContext.js';\nimport {\n  apply as applyTransform,\n  compose as composeTransform,\n  create as createTransform,\n  makeInverse,\n  toString as toTransformString,\n} from '../../transform.js';\nimport {asArray} from '../../color.js';\nimport {createCanvasContext2D} from '../../dom.js';\nimport {equals} from '../../array.js';\nimport {\n  getBottomLeft,\n  getBottomRight,\n  getHeight,\n  getTopLeft,\n  getTopRight,\n  getWidth,\n} from '../../extent.js';\n\n/**\n * @type {Array<HTMLCanvasElement>}\n */\nexport const canvasPool = [];\n\n/**\n * @type {CanvasRenderingContext2D}\n */\nlet pixelContext = null;\n\nfunction createPixelContext() {\n  pixelContext = createCanvasContext2D(1, 1, undefined, {\n    willReadFrequently: true,\n  });\n}\n\n/**\n * @abstract\n * @template {import(\"../../layer/Layer.js\").default} LayerType\n * @extends {LayerRenderer<LayerType>}\n */\nclass CanvasLayerRenderer extends LayerRenderer {\n  /**\n   * @param {LayerType} layer Layer.\n   */\n  constructor(layer) {\n    super(layer);\n\n    /**\n     * @protected\n     * @type {HTMLElement}\n     */\n    this.container = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedResolution;\n\n    /**\n     * A temporary transform.  The values in this transform should only be used in a\n     * function that sets the values.\n     * @protected\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.tempTransform = createTransform();\n\n    /**\n     * The transform for rendered pixels to viewport CSS pixels.  This transform must\n     * be set when rendering a frame and may be used by other functions after rendering.\n     * @protected\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.pixelTransform = createTransform();\n\n    /**\n     * The transform for viewport CSS pixels to rendered pixels.  This transform must\n     * be set when rendering a frame and may be used by other functions after rendering.\n     * @protected\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.inversePixelTransform = createTransform();\n\n    /**\n     * @type {CanvasRenderingContext2D}\n     */\n    this.context = null;\n\n    /**\n     * @private\n     * @type {ZIndexContext}\n     */\n    this.deferredContext_ = null;\n\n    /**\n     * @type {boolean}\n     */\n    this.containerReused = false;\n\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n    this.pixelContext_ = null;\n\n    /**\n     * @protected\n     * @type {import(\"../../Map.js\").FrameState|null}\n     */\n    this.frameState = null;\n  }\n\n  /**\n   * @param {import('../../DataTile.js').ImageLike} image Image.\n   * @param {number} col The column index.\n   * @param {number} row The row index.\n   * @return {Uint8ClampedArray|null} The image data.\n   */\n  getImageData(image, col, row) {\n    if (!pixelContext) {\n      createPixelContext();\n    }\n    pixelContext.clearRect(0, 0, 1, 1);\n\n    let data;\n    try {\n      pixelContext.drawImage(image, col, row, 1, 1, 0, 0, 1, 1);\n      data = pixelContext.getImageData(0, 0, 1, 1).data;\n    } catch (err) {\n      pixelContext = null;\n      return null;\n    }\n    return data;\n  }\n\n  /**\n   * @param {import('../../Map.js').FrameState} frameState Frame state.\n   * @return {string} Background color.\n   */\n  getBackground(frameState) {\n    const layer = this.getLayer();\n    let background = layer.getBackground();\n    if (typeof background === 'function') {\n      background = background(frameState.viewState.resolution);\n    }\n    return background || undefined;\n  }\n\n  /**\n   * Get a rendering container from an existing target, if compatible.\n   * @param {HTMLElement} target Potential render target.\n   * @param {string} transform CSS Transform.\n   * @param {string} [backgroundColor] Background color.\n   */\n  useContainer(target, transform, backgroundColor) {\n    const layerClassName = this.getLayer().getClassName();\n    let container, context;\n    if (\n      target &&\n      target.className === layerClassName &&\n      (!backgroundColor ||\n        (target &&\n          target.style.backgroundColor &&\n          equals(\n            asArray(target.style.backgroundColor),\n            asArray(backgroundColor),\n          )))\n    ) {\n      const canvas = target.firstElementChild;\n      if (canvas instanceof HTMLCanvasElement) {\n        context = canvas.getContext('2d');\n      }\n    }\n    if (context && context.canvas.style.transform === transform) {\n      // Container of the previous layer renderer can be used.\n      this.container = target;\n      this.context = context;\n      this.containerReused = true;\n    } else if (this.containerReused) {\n      // Previously reused container cannot be used any more.\n      this.container = null;\n      this.context = null;\n      this.containerReused = false;\n    } else if (this.container) {\n      this.container.style.backgroundColor = null;\n    }\n    if (!this.container) {\n      container = document.createElement('div');\n      container.className = layerClassName;\n      let style = container.style;\n      style.position = 'absolute';\n      style.width = '100%';\n      style.height = '100%';\n      context = createCanvasContext2D();\n      const canvas = context.canvas;\n      container.appendChild(canvas);\n      style = canvas.style;\n      style.position = 'absolute';\n      style.left = '0';\n      style.transformOrigin = 'top left';\n      this.container = container;\n      this.context = context;\n    }\n    if (\n      !this.containerReused &&\n      backgroundColor &&\n      !this.container.style.backgroundColor\n    ) {\n      this.container.style.backgroundColor = backgroundColor;\n    }\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../extent.js\").Extent} extent Clip extent.\n   * @protected\n   */\n  clipUnrotated(context, frameState, extent) {\n    const topLeft = getTopLeft(extent);\n    const topRight = getTopRight(extent);\n    const bottomRight = getBottomRight(extent);\n    const bottomLeft = getBottomLeft(extent);\n\n    applyTransform(frameState.coordinateToPixelTransform, topLeft);\n    applyTransform(frameState.coordinateToPixelTransform, topRight);\n    applyTransform(frameState.coordinateToPixelTransform, bottomRight);\n    applyTransform(frameState.coordinateToPixelTransform, bottomLeft);\n\n    const inverted = this.inversePixelTransform;\n    applyTransform(inverted, topLeft);\n    applyTransform(inverted, topRight);\n    applyTransform(inverted, bottomRight);\n    applyTransform(inverted, bottomLeft);\n\n    context.save();\n    context.beginPath();\n    context.moveTo(Math.round(topLeft[0]), Math.round(topLeft[1]));\n    context.lineTo(Math.round(topRight[0]), Math.round(topRight[1]));\n    context.lineTo(Math.round(bottomRight[0]), Math.round(bottomRight[1]));\n    context.lineTo(Math.round(bottomLeft[0]), Math.round(bottomLeft[1]));\n    context.clip();\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @protected\n   */\n  prepareContainer(frameState, target) {\n    const extent = frameState.extent;\n    const resolution = frameState.viewState.resolution;\n    const rotation = frameState.viewState.rotation;\n    const pixelRatio = frameState.pixelRatio;\n    const width = Math.round((getWidth(extent) / resolution) * pixelRatio);\n    const height = Math.round((getHeight(extent) / resolution) * pixelRatio);\n    // set forward and inverse pixel transforms\n    composeTransform(\n      this.pixelTransform,\n      frameState.size[0] / 2,\n      frameState.size[1] / 2,\n      1 / pixelRatio,\n      1 / pixelRatio,\n      rotation,\n      -width / 2,\n      -height / 2,\n    );\n    makeInverse(this.inversePixelTransform, this.pixelTransform);\n\n    const canvasTransform = toTransformString(this.pixelTransform);\n    this.useContainer(target, canvasTransform, this.getBackground(frameState));\n\n    if (!this.containerReused) {\n      const canvas = this.context.canvas;\n      if (canvas.width != width || canvas.height != height) {\n        canvas.width = width;\n        canvas.height = height;\n      } else {\n        this.context.clearRect(0, 0, width, height);\n      }\n      if (canvasTransform !== canvas.style.transform) {\n        canvas.style.transform = canvasTransform;\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../../render/EventType.js\").default} type Event type.\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @private\n   */\n  dispatchRenderEvent_(type, context, frameState) {\n    const layer = this.getLayer();\n    if (layer.hasListener(type)) {\n      const event = new RenderEvent(\n        type,\n        this.inversePixelTransform,\n        frameState,\n        context,\n      );\n      layer.dispatchEvent(event);\n    }\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  preRender(context, frameState) {\n    this.frameState = frameState;\n    if (frameState.declutter) {\n      return;\n    }\n    this.dispatchRenderEvent_(RenderEventType.PRERENDER, context, frameState);\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  postRender(context, frameState) {\n    if (frameState.declutter) {\n      return;\n    }\n    this.dispatchRenderEvent_(RenderEventType.POSTRENDER, context, frameState);\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   */\n  renderDeferredInternal(frameState) {}\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {import('../../render/canvas/ZIndexContext.js').ZIndexContextProxy} Context.\n   */\n  getRenderContext(frameState) {\n    if (frameState.declutter && !this.deferredContext_) {\n      this.deferredContext_ = new ZIndexContext();\n    }\n    return frameState.declutter\n      ? this.deferredContext_.getContext()\n      : this.context;\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @override\n   */\n  renderDeferred(frameState) {\n    if (!frameState.declutter) {\n      return;\n    }\n    this.dispatchRenderEvent_(\n      RenderEventType.PRERENDER,\n      this.context,\n      frameState,\n    );\n    if (frameState.declutter && this.deferredContext_) {\n      this.deferredContext_.draw(this.context);\n      this.deferredContext_.clear();\n    }\n    this.renderDeferredInternal(frameState);\n    this.dispatchRenderEvent_(\n      RenderEventType.POSTRENDER,\n      this.context,\n      frameState,\n    );\n  }\n\n  /**\n   * Creates a transform for rendering to an element that will be rotated after rendering.\n   * @param {import(\"../../coordinate.js\").Coordinate} center Center.\n   * @param {number} resolution Resolution.\n   * @param {number} rotation Rotation.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {number} width Width of the rendered element (in pixels).\n   * @param {number} height Height of the rendered element (in pixels).\n   * @param {number} offsetX Offset on the x-axis in view coordinates.\n   * @protected\n   * @return {!import(\"../../transform.js\").Transform} Transform.\n   */\n  getRenderTransform(\n    center,\n    resolution,\n    rotation,\n    pixelRatio,\n    width,\n    height,\n    offsetX,\n  ) {\n    const dx1 = width / 2;\n    const dy1 = height / 2;\n    const sx = pixelRatio / resolution;\n    const sy = -sx;\n    const dx2 = -center[0] + offsetX;\n    const dy2 = -center[1];\n    return composeTransform(\n      this.tempTransform,\n      dx1,\n      dy1,\n      sx,\n      sy,\n      -rotation,\n      dx2,\n      dy2,\n    );\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    delete this.frameState;\n    super.disposeInternal();\n  }\n}\n\nexport default CanvasLayerRenderer;\n","/**\n * @module ol/renderer/canvas/TileLayer\n */\nimport CanvasLayerRenderer from './Layer.js';\nimport ImageTile from '../../ImageTile.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport {\n  apply as applyTransform,\n  compose as composeTransform,\n} from '../../transform.js';\nimport {ascending} from '../../array.js';\nimport {\n  containsCoordinate,\n  createEmpty,\n  equals,\n  getIntersection,\n  getRotatedViewport,\n  getTopLeft,\n  intersects,\n} from '../../extent.js';\nimport {fromUserExtent} from '../../proj.js';\nimport {getUid} from '../../util.js';\nimport {toSize} from '../../size.js';\n\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n * @template {import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default} [LayerType=import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default]\n * @extends {CanvasLayerRenderer<LayerType>}\n */\nclass CanvasTileLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   */\n  constructor(tileLayer) {\n    super(tileLayer);\n\n    /**\n     * Rendered extent has changed since the previous `renderFrame()` call\n     * @type {boolean}\n     */\n    this.extentChanged = true;\n\n    /**\n     * @private\n     * @type {?import(\"../../extent.js\").Extent}\n     */\n    this.renderedExtent_ = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedPixelRatio;\n\n    /**\n     * @protected\n     * @type {import(\"../../proj/Projection.js\").default}\n     */\n    this.renderedProjection = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedRevision;\n\n    /**\n     * @protected\n     * @type {!Array<import(\"../../Tile.js\").default>}\n     */\n    this.renderedTiles = [];\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.newTiles_ = false;\n\n    /**\n     * @protected\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.tmpExtent = createEmpty();\n\n    /**\n     * @private\n     * @type {import(\"../../TileRange.js\").default}\n     */\n    this.tmpTileRange_ = new TileRange(0, 0, 0, 0);\n  }\n\n  /**\n   * @protected\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {boolean} Tile is drawable.\n   */\n  isDrawableTile(tile) {\n    const tileLayer = this.getLayer();\n    const tileState = tile.getState();\n    const useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();\n    return (\n      tileState == TileState.LOADED ||\n      tileState == TileState.EMPTY ||\n      (tileState == TileState.ERROR && !useInterimTilesOnError)\n    );\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {!import(\"../../Tile.js\").default} Tile.\n   */\n  getTile(z, x, y, frameState) {\n    const pixelRatio = frameState.pixelRatio;\n    const projection = frameState.viewState.projection;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    let tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n    if (tile.getState() == TileState.ERROR) {\n      if (tileLayer.getUseInterimTilesOnError() && tileLayer.getPreload() > 0) {\n        // Preloaded tiles for lower resolutions might have finished loading.\n        this.newTiles_ = true;\n      }\n    }\n    if (!this.isDrawableTile(tile)) {\n      tile = tile.getInterimTile();\n    }\n    return tile;\n  }\n\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray} Data at the pixel location.\n   */\n  getData(pixel) {\n    const frameState = this.frameState;\n    if (!frameState) {\n      return null;\n    }\n\n    const layer = this.getLayer();\n    const coordinate = applyTransform(\n      frameState.pixelToCoordinateTransform,\n      pixel.slice(),\n    );\n\n    const layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (!containsCoordinate(layerExtent, coordinate)) {\n        return null;\n      }\n    }\n\n    const pixelRatio = frameState.pixelRatio;\n    const projection = frameState.viewState.projection;\n    const viewState = frameState.viewState;\n    const source = layer.getRenderSource();\n    const tileGrid = source.getTileGridForProjection(viewState.projection);\n    const tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);\n\n    for (\n      let z = tileGrid.getZForResolution(viewState.resolution);\n      z >= tileGrid.getMinZoom();\n      --z\n    ) {\n      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n      const tile = source.getTile(\n        z,\n        tileCoord[1],\n        tileCoord[2],\n        pixelRatio,\n        projection,\n      );\n      if (\n        !(tile instanceof ImageTile || tile instanceof ReprojTile) ||\n        (tile instanceof ReprojTile && tile.getState() === TileState.EMPTY)\n      ) {\n        return null;\n      }\n\n      if (tile.getState() !== TileState.LOADED) {\n        continue;\n      }\n\n      const tileOrigin = tileGrid.getOrigin(z);\n      const tileSize = toSize(tileGrid.getTileSize(z));\n      const tileResolution = tileGrid.getResolution(z);\n\n      const col = Math.floor(\n        tilePixelRatio *\n          ((coordinate[0] - tileOrigin[0]) / tileResolution -\n            tileCoord[1] * tileSize[0]),\n      );\n\n      const row = Math.floor(\n        tilePixelRatio *\n          ((tileOrigin[1] - coordinate[1]) / tileResolution -\n            tileCoord[2] * tileSize[1]),\n      );\n\n      const gutter = Math.round(\n        tilePixelRatio * source.getGutterForProjection(viewState.projection),\n      );\n\n      return this.getImageData(tile.getImage(), col + gutter, row + gutter);\n    }\n\n    return null;\n  }\n\n  /**\n   * @param {Object<number, Object<string, import(\"../../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n   * @param {number} zoom Zoom level.\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {boolean|void} If `false`, the tile will not be considered loaded.\n   */\n  loadedTileCallback(tiles, zoom, tile) {\n    if (this.isDrawableTile(tile)) {\n      return super.loadedTileCallback(tiles, zoom, tile);\n    }\n    return false;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    return !!this.getLayer().getSource();\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState, target) {\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const viewResolution = viewState.resolution;\n    const viewCenter = viewState.center;\n    const rotation = viewState.rotation;\n    const pixelRatio = frameState.pixelRatio;\n\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const sourceRevision = tileSource.getRevision();\n    const tileGrid = tileSource.getTileGridForProjection(projection);\n    const z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);\n    const tileResolution = tileGrid.getResolution(z);\n\n    let extent = frameState.extent;\n    const resolution = frameState.viewState.resolution;\n    const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n\n    this.prepareContainer(frameState, target);\n\n    // desired dimensions of the canvas in pixels\n    const width = this.context.canvas.width;\n    const height = this.context.canvas.height;\n\n    const layerExtent =\n      layerState.extent && fromUserExtent(layerState.extent, projection);\n    if (layerExtent) {\n      extent = getIntersection(\n        extent,\n        fromUserExtent(layerState.extent, projection),\n      );\n    }\n\n    const dx = (tileResolution * width) / 2 / tilePixelRatio;\n    const dy = (tileResolution * height) / 2 / tilePixelRatio;\n    const canvasExtent = [\n      viewCenter[0] - dx,\n      viewCenter[1] - dy,\n      viewCenter[0] + dx,\n      viewCenter[1] + dy,\n    ];\n\n    const tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\n\n    /**\n     * @type {Object<number, Object<string, import(\"../../Tile.js\").default>>}\n     */\n    const tilesToDrawByZ = {};\n    tilesToDrawByZ[z] = {};\n\n    const findLoadedTiles = this.createLoadedTileFinder(\n      tileSource,\n      projection,\n      tilesToDrawByZ,\n    );\n\n    const tmpExtent = this.tmpExtent;\n    const tmpTileRange = this.tmpTileRange_;\n    this.newTiles_ = false;\n    const viewport = rotation\n      ? getRotatedViewport(\n          viewState.center,\n          resolution,\n          rotation,\n          frameState.size,\n        )\n      : undefined;\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        if (\n          rotation &&\n          !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)\n        ) {\n          continue;\n        }\n        const tile = this.getTile(z, x, y, frameState);\n        if (this.isDrawableTile(tile)) {\n          const uid = getUid(this);\n          if (tile.getState() == TileState.LOADED) {\n            tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;\n            let inTransition = tile.inTransition(uid);\n            if (inTransition && layerState.opacity !== 1) {\n              // Skipping transition when layer is not fully opaque avoids visual artifacts.\n              tile.endTransition(uid);\n              inTransition = false;\n            }\n            if (\n              !this.newTiles_ &&\n              (inTransition || !this.renderedTiles.includes(tile))\n            ) {\n              this.newTiles_ = true;\n            }\n          }\n          if (tile.getAlpha(uid, frameState.time) === 1) {\n            // don't look for alt tiles if alpha is 1\n            continue;\n          }\n        }\n\n        const childTileRange = tileGrid.getTileCoordChildTileRange(\n          tile.tileCoord,\n          tmpTileRange,\n          tmpExtent,\n        );\n\n        let covered = false;\n        if (childTileRange) {\n          covered = findLoadedTiles(z + 1, childTileRange);\n        }\n        if (!covered) {\n          tileGrid.forEachTileCoordParentTileRange(\n            tile.tileCoord,\n            findLoadedTiles,\n            tmpTileRange,\n            tmpExtent,\n          );\n        }\n      }\n    }\n\n    const canvasScale =\n      ((tileResolution / viewResolution) * pixelRatio) / tilePixelRatio;\n\n    const context = this.getRenderContext(frameState);\n\n    // set scale transform for calculating tile positions on the canvas\n    composeTransform(\n      this.tempTransform,\n      width / 2,\n      height / 2,\n      canvasScale,\n      canvasScale,\n      0,\n      -width / 2,\n      -height / 2,\n    );\n\n    if (layerExtent) {\n      this.clipUnrotated(context, frameState, layerExtent);\n    }\n\n    if (!tileSource.getInterpolate()) {\n      context.imageSmoothingEnabled = false;\n    }\n\n    this.preRender(context, frameState);\n\n    this.renderedTiles.length = 0;\n    /** @type {Array<number>} */\n    let zs = Object.keys(tilesToDrawByZ).map(Number);\n    zs.sort(ascending);\n\n    let clips, clipZs, currentClip;\n    if (\n      layerState.opacity === 1 &&\n      (!this.containerReused ||\n        tileSource.getOpaque(frameState.viewState.projection))\n    ) {\n      zs = zs.reverse();\n    } else {\n      clips = [];\n      clipZs = [];\n    }\n    for (let i = zs.length - 1; i >= 0; --i) {\n      const currentZ = zs[i];\n      const currentTilePixelSize = tileSource.getTilePixelSize(\n        currentZ,\n        pixelRatio,\n        projection,\n      );\n      const currentResolution = tileGrid.getResolution(currentZ);\n      const currentScale = currentResolution / tileResolution;\n      const dx = currentTilePixelSize[0] * currentScale * canvasScale;\n      const dy = currentTilePixelSize[1] * currentScale * canvasScale;\n      const originTileCoord = tileGrid.getTileCoordForCoordAndZ(\n        getTopLeft(canvasExtent),\n        currentZ,\n      );\n      const originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);\n      const origin = applyTransform(this.tempTransform, [\n        (tilePixelRatio * (originTileExtent[0] - canvasExtent[0])) /\n          tileResolution,\n        (tilePixelRatio * (canvasExtent[3] - originTileExtent[3])) /\n          tileResolution,\n      ]);\n      const tileGutter =\n        tilePixelRatio * tileSource.getGutterForProjection(projection);\n      const tilesToDraw = tilesToDrawByZ[currentZ];\n      for (const tileCoordKey in tilesToDraw) {\n        const tile = /** @type {import(\"../../ImageTile.js\").default} */ (\n          tilesToDraw[tileCoordKey]\n        );\n        const tileCoord = tile.tileCoord;\n\n        // Calculate integer positions and sizes so that tiles align\n        const xIndex = originTileCoord[1] - tileCoord[1];\n        const nextX = Math.round(origin[0] - (xIndex - 1) * dx);\n        const yIndex = originTileCoord[2] - tileCoord[2];\n        const nextY = Math.round(origin[1] - (yIndex - 1) * dy);\n        const x = Math.round(origin[0] - xIndex * dx);\n        const y = Math.round(origin[1] - yIndex * dy);\n        const w = nextX - x;\n        const h = nextY - y;\n        const transition = z === currentZ;\n\n        const inTransition =\n          transition && tile.getAlpha(getUid(this), frameState.time) !== 1;\n        let contextSaved = false;\n        if (!inTransition) {\n          if (clips) {\n            // Clip mask for regions in this tile that already filled by a higher z tile\n            currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];\n            for (let i = 0, ii = clips.length; i < ii; ++i) {\n              if (z !== currentZ && currentZ < clipZs[i]) {\n                const clip = clips[i];\n                if (\n                  intersects(\n                    [x, y, x + w, y + h],\n                    [clip[0], clip[3], clip[4], clip[7]],\n                  )\n                ) {\n                  if (!contextSaved) {\n                    context.save();\n                    contextSaved = true;\n                  }\n                  context.beginPath();\n                  // counter-clockwise (outer ring) for current tile\n                  context.moveTo(currentClip[0], currentClip[1]);\n                  context.lineTo(currentClip[2], currentClip[3]);\n                  context.lineTo(currentClip[4], currentClip[5]);\n                  context.lineTo(currentClip[6], currentClip[7]);\n                  // clockwise (inner ring) for higher z tile\n                  context.moveTo(clip[6], clip[7]);\n                  context.lineTo(clip[4], clip[5]);\n                  context.lineTo(clip[2], clip[3]);\n                  context.lineTo(clip[0], clip[1]);\n                  context.clip();\n                }\n              }\n            }\n            clips.push(currentClip);\n            clipZs.push(currentZ);\n          } else {\n            context.clearRect(x, y, w, h);\n          }\n        }\n        this.drawTileImage(\n          tile,\n          frameState,\n          x,\n          y,\n          w,\n          h,\n          tileGutter,\n          transition,\n        );\n        if (clips && !inTransition) {\n          if (contextSaved) {\n            context.restore();\n          }\n          this.renderedTiles.unshift(tile);\n        } else {\n          this.renderedTiles.push(tile);\n        }\n        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);\n      }\n    }\n\n    this.renderedRevision = sourceRevision;\n    this.renderedResolution = tileResolution;\n    this.extentChanged =\n      !this.renderedExtent_ || !equals(this.renderedExtent_, canvasExtent);\n    this.renderedExtent_ = canvasExtent;\n    this.renderedPixelRatio = pixelRatio;\n    this.renderedProjection = projection;\n\n    this.manageTilePyramid(\n      frameState,\n      tileSource,\n      tileGrid,\n      pixelRatio,\n      projection,\n      extent,\n      z,\n      tileLayer.getPreload(),\n    );\n    this.scheduleExpireCache(frameState, tileSource);\n\n    this.postRender(this.context, frameState);\n\n    if (layerState.extent) {\n      context.restore();\n    }\n    context.imageSmoothingEnabled = true;\n\n    return this.container;\n  }\n\n  /**\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   */\n  drawTileImage(tile, frameState, x, y, w, h, gutter, transition) {\n    const image = this.getTileImage(tile);\n    if (!image) {\n      return;\n    }\n    const context = this.getRenderContext(frameState);\n    const uid = getUid(this);\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const alpha =\n      layerState.opacity *\n      (transition ? tile.getAlpha(uid, frameState.time) : 1);\n    const alphaChanged = alpha !== context.globalAlpha;\n    if (alphaChanged) {\n      context.save();\n      context.globalAlpha = alpha;\n    }\n    context.drawImage(\n      image,\n      gutter,\n      gutter,\n      image.width - 2 * gutter,\n      image.height - 2 * gutter,\n      x,\n      y,\n      w,\n      h,\n    );\n\n    if (alphaChanged) {\n      context.restore();\n    }\n    if (alpha !== layerState.opacity) {\n      frameState.animate = true;\n    } else if (transition) {\n      tile.endTransition(uid);\n    }\n  }\n\n  /**\n   * @return {HTMLCanvasElement} Image\n   */\n  getImage() {\n    const context = this.context;\n    return context ? context.canvas : null;\n  }\n\n  /**\n   * Get the image from a tile.\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @protected\n   */\n  getTileImage(tile) {\n    return tile.getImage();\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @protected\n   */\n  scheduleExpireCache(frameState, tileSource) {\n    if (tileSource.canExpireCache()) {\n      /**\n       * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n       * @param {import(\"../../Map.js\").default} map Map.\n       * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n       */\n      const postRenderFunction = function (tileSource, map, frameState) {\n        const tileSourceKey = getUid(tileSource);\n        if (tileSourceKey in frameState.usedTiles) {\n          tileSource.expireCache(\n            frameState.viewState.projection,\n            frameState.usedTiles[tileSourceKey],\n          );\n        }\n      }.bind(null, tileSource);\n\n      frameState.postRenderFunctions.push(\n        /** @type {import(\"../../Map.js\").PostRenderFunction} */ (\n          postRenderFunction\n        ),\n      );\n    }\n  }\n\n  /**\n   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import('../../Tile.js').default} tile Tile.\n   * @protected\n   */\n  updateUsedTiles(usedTiles, tileSource, tile) {\n    // FIXME should we use tilesToDrawByZ instead?\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in usedTiles)) {\n      usedTiles[tileSourceKey] = {};\n    }\n    usedTiles[tileSourceKey][tile.getKey()] = true;\n  }\n\n  /**\n   * Manage tile pyramid.\n   * This function performs a number of functions related to the tiles at the\n   * current zoom and lower zoom levels:\n   * - registers idle tiles in frameState.wantedTiles so that they are not\n   *   discarded by the tile queue\n   * - enqueues missing tiles\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @param {import(\"../../extent.js\").Extent} extent Extent.\n   * @param {number} currentZ Current Z.\n   * @param {number} preload Load low resolution tiles up to `preload` levels.\n   * @param {function(import(\"../../Tile.js\").default):void} [tileCallback] Tile callback.\n   * @protected\n   */\n  manageTilePyramid(\n    frameState,\n    tileSource,\n    tileGrid,\n    pixelRatio,\n    projection,\n    extent,\n    currentZ,\n    preload,\n    tileCallback,\n  ) {\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n    const wantedTiles = frameState.wantedTiles[tileSourceKey];\n    const tileQueue = frameState.tileQueue;\n    const minZoom = tileGrid.getMinZoom();\n    const rotation = frameState.viewState.rotation;\n    const viewport = rotation\n      ? getRotatedViewport(\n          frameState.viewState.center,\n          frameState.viewState.resolution,\n          rotation,\n          frameState.size,\n        )\n      : undefined;\n    let tileCount = 0;\n    let tile, tileRange, tileResolution, x, y, z;\n    for (z = minZoom; z <= currentZ; ++z) {\n      tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);\n      tileResolution = tileGrid.getResolution(z);\n      for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          if (\n            rotation &&\n            !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)\n          ) {\n            continue;\n          }\n          if (currentZ - z <= preload) {\n            ++tileCount;\n            tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n            if (tile.getState() == TileState.IDLE) {\n              wantedTiles[tile.getKey()] = true;\n              if (!tileQueue.isKeyQueued(tile.getKey())) {\n                tileQueue.enqueue([\n                  tile,\n                  tileSourceKey,\n                  tileGrid.getTileCoordCenter(tile.tileCoord),\n                  tileResolution,\n                ]);\n              }\n            }\n            if (tileCallback !== undefined) {\n              tileCallback(tile);\n            }\n          } else {\n            tileSource.useTile(z, x, y, projection);\n          }\n        }\n      }\n    }\n    tileSource.updateCacheSize(tileCount, projection);\n  }\n}\n\nexport default CanvasTileLayerRenderer;\n","/**\n * @module ol/renderer/canvas/VectorLayer\n */\nimport CanvasBuilderGroup from '../../render/canvas/BuilderGroup.js';\nimport CanvasLayerRenderer, {canvasPool} from './Layer.js';\nimport ExecutorGroup, {\n  ALL,\n  DECLUTTER,\n  NON_DECLUTTER,\n} from '../../render/canvas/ExecutorGroup.js';\nimport RenderEventType from '../../render/EventType.js';\nimport ViewHint from '../../ViewHint.js';\nimport {\n  HIT_DETECT_RESOLUTION,\n  createHitDetectionImageData,\n  hitDetect,\n} from '../../render/canvas/hitdetect.js';\nimport {\n  buffer,\n  containsExtent,\n  createEmpty,\n  getHeight,\n  getWidth,\n  intersects as intersectsExtent,\n  wrapX as wrapExtentX,\n} from '../../extent.js';\nimport {createCanvasContext2D, releaseCanvas} from '../../dom.js';\nimport {\n  defaultOrder as defaultRenderOrder,\n  getTolerance as getRenderTolerance,\n  getSquaredTolerance as getSquaredRenderTolerance,\n  renderFeature,\n} from '../vector.js';\nimport {equals} from '../../array.js';\nimport {\n  fromUserExtent,\n  getTransformFromProjections,\n  getUserProjection,\n  toUserExtent,\n  toUserResolution,\n} from '../../proj.js';\nimport {getUid} from '../../util.js';\nimport {wrapX as wrapCoordinateX} from '../../coordinate.js';\n\n/**\n * @classdesc\n * Canvas renderer for vector layers.\n * @api\n */\nclass CanvasVectorLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {import(\"../../layer/BaseVector.js\").default} vectorLayer Vector layer.\n   */\n  constructor(vectorLayer) {\n    super(vectorLayer);\n\n    /** @private */\n    this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this);\n\n    /**\n     * @type {boolean}\n     */\n    this.animatingOrInteracting_;\n\n    /**\n     * @type {ImageData|null}\n     */\n    this.hitDetectionImageData_ = null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.clipped_ = false;\n\n    /**\n     * @private\n     * @type {Array<import(\"../../Feature.js\").default>}\n     */\n    this.renderedFeatures_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedRevision_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedResolution_ = NaN;\n\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.renderedExtent_ = createEmpty();\n\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.wrappedRenderedExtent_ = createEmpty();\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedRotation_;\n\n    /**\n     * @private\n     * @type {import(\"../../coordinate\").Coordinate}\n     */\n    this.renderedCenter_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../../proj/Projection\").default}\n     */\n    this.renderedProjection_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedPixelRatio_ = 1;\n\n    /**\n     * @private\n     * @type {function(import(\"../../Feature.js\").default, import(\"../../Feature.js\").default): number|null}\n     */\n    this.renderedRenderOrder_ = null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.renderedFrameDeclutter_;\n\n    /**\n     * @private\n     * @type {import(\"../../render/canvas/ExecutorGroup\").default}\n     */\n    this.replayGroup_ = null;\n\n    /**\n     * A new replay group had to be created by `prepareFrame()`\n     * @type {boolean}\n     */\n    this.replayGroupChanged = true;\n\n    /**\n     * Clipping to be performed by `renderFrame()`\n     * @type {boolean}\n     */\n    this.clipping = true;\n\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n    this.targetContext_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.opacity_ = 1;\n  }\n\n  /**\n   * @param {ExecutorGroup} executorGroup Executor group.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {boolean} [declutterable] `true` to only render declutterable items,\n   *     `false` to only render non-declutterable items, `undefined` to render all.\n   */\n  renderWorlds(executorGroup, frameState, declutterable) {\n    const extent = frameState.extent;\n    const viewState = frameState.viewState;\n    const center = viewState.center;\n    const resolution = viewState.resolution;\n    const projection = viewState.projection;\n    const rotation = viewState.rotation;\n    const projectionExtent = projection.getExtent();\n    const vectorSource = this.getLayer().getSource();\n    const declutter = this.getLayer().getDeclutter();\n    const pixelRatio = frameState.pixelRatio;\n    const viewHints = frameState.viewHints;\n    const snapToPixel = !(\n      viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]\n    );\n    const context = this.context;\n    const width = Math.round((getWidth(extent) / resolution) * pixelRatio);\n    const height = Math.round((getHeight(extent) / resolution) * pixelRatio);\n\n    const multiWorld = vectorSource.getWrapX() && projection.canWrapX();\n    const worldWidth = multiWorld ? getWidth(projectionExtent) : null;\n    const endWorld = multiWorld\n      ? Math.ceil((extent[2] - projectionExtent[2]) / worldWidth) + 1\n      : 1;\n    let world = multiWorld\n      ? Math.floor((extent[0] - projectionExtent[0]) / worldWidth)\n      : 0;\n    do {\n      let transform = this.getRenderTransform(\n        center,\n        resolution,\n        0,\n        pixelRatio,\n        width,\n        height,\n        world * worldWidth,\n      );\n      if (frameState.declutter) {\n        transform = transform.slice(0);\n      }\n      executorGroup.execute(\n        context,\n        [context.canvas.width, context.canvas.height],\n        transform,\n        rotation,\n        snapToPixel,\n        declutterable === undefined\n          ? ALL\n          : declutterable\n            ? DECLUTTER\n            : NON_DECLUTTER,\n        declutterable\n          ? declutter && frameState.declutter[declutter]\n          : undefined,\n      );\n    } while (++world < endWorld);\n  }\n\n  /**\n   * @private\n   */\n  setDrawContext_() {\n    if (this.opacity_ !== 1) {\n      this.targetContext_ = this.context;\n      this.context = createCanvasContext2D(\n        this.context.canvas.width,\n        this.context.canvas.height,\n        canvasPool,\n      );\n    }\n  }\n\n  /**\n   * @private\n   */\n  resetDrawContext_() {\n    if (this.opacity_ !== 1) {\n      const alpha = this.targetContext_.globalAlpha;\n      this.targetContext_.globalAlpha = this.opacity_;\n      this.targetContext_.drawImage(this.context.canvas, 0, 0);\n      this.targetContext_.globalAlpha = alpha;\n      releaseCanvas(this.context);\n      canvasPool.push(this.context.canvas);\n      this.context = this.targetContext_;\n      this.targetContext_ = null;\n    }\n  }\n\n  /**\n   * Render declutter items for this layer\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   */\n  renderDeclutter(frameState) {\n    if (!this.replayGroup_ || !this.getLayer().getDeclutter()) {\n      return;\n    }\n    this.renderWorlds(this.replayGroup_, frameState, true);\n  }\n\n  /**\n   * Render deferred instructions.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   */\n  renderDeferredInternal(frameState) {\n    if (!this.replayGroup_) {\n      return;\n    }\n    this.replayGroup_.renderDeferred();\n    if (this.clipped_) {\n      this.context.restore();\n    }\n    this.resetDrawContext_();\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement|null} target Target that may be used to render content to.\n   * @return {HTMLElement|null} The rendered element.\n   */\n  renderFrame(frameState, target) {\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    this.opacity_ = layerState.opacity;\n    const viewState = frameState.viewState;\n\n    this.prepareContainer(frameState, target);\n    const context = this.context;\n\n    const replayGroup = this.replayGroup_;\n    let render = replayGroup && !replayGroup.isEmpty();\n    if (!render) {\n      const hasRenderListeners =\n        this.getLayer().hasListener(RenderEventType.PRERENDER) ||\n        this.getLayer().hasListener(RenderEventType.POSTRENDER);\n      if (!hasRenderListeners) {\n        return null;\n      }\n    }\n\n    this.setDrawContext_();\n\n    this.preRender(context, frameState);\n\n    const projection = viewState.projection;\n\n    // clipped rendering if layer extent is set\n    this.clipped_ = false;\n    if (render && layerState.extent && this.clipping) {\n      const layerExtent = fromUserExtent(layerState.extent, projection);\n      render = intersectsExtent(layerExtent, frameState.extent);\n      this.clipped_ = render && !containsExtent(layerExtent, frameState.extent);\n      if (this.clipped_) {\n        this.clipUnrotated(context, frameState, layerExtent);\n      }\n    }\n\n    if (render) {\n      this.renderWorlds(\n        replayGroup,\n        frameState,\n        this.getLayer().getDeclutter() ? false : undefined,\n      );\n    }\n\n    if (!frameState.declutter && this.clipped_) {\n      context.restore();\n    }\n\n    this.postRender(context, frameState);\n\n    if (this.renderedRotation_ !== viewState.rotation) {\n      this.renderedRotation_ = viewState.rotation;\n      this.hitDetectionImageData_ = null;\n    }\n    if (!frameState.declutter) {\n      this.resetDrawContext_();\n    }\n    return this.container;\n  }\n\n  /**\n   * Asynchronous layer level hit detection.\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../../Feature\").default>>} Promise\n   * that resolves with an array of features.\n   */\n  getFeatures(pixel) {\n    return new Promise((resolve) => {\n      if (\n        this.frameState &&\n        !this.hitDetectionImageData_ &&\n        !this.animatingOrInteracting_\n      ) {\n        const size = this.frameState.size.slice();\n        const center = this.renderedCenter_;\n        const resolution = this.renderedResolution_;\n        const rotation = this.renderedRotation_;\n        const projection = this.renderedProjection_;\n        const extent = this.wrappedRenderedExtent_;\n        const layer = this.getLayer();\n        const transforms = [];\n        const width = size[0] * HIT_DETECT_RESOLUTION;\n        const height = size[1] * HIT_DETECT_RESOLUTION;\n        transforms.push(\n          this.getRenderTransform(\n            center,\n            resolution,\n            rotation,\n            HIT_DETECT_RESOLUTION,\n            width,\n            height,\n            0,\n          ).slice(),\n        );\n        const source = layer.getSource();\n        const projectionExtent = projection.getExtent();\n        if (\n          source.getWrapX() &&\n          projection.canWrapX() &&\n          !containsExtent(projectionExtent, extent)\n        ) {\n          let startX = extent[0];\n          const worldWidth = getWidth(projectionExtent);\n          let world = 0;\n          let offsetX;\n          while (startX < projectionExtent[0]) {\n            --world;\n            offsetX = worldWidth * world;\n            transforms.push(\n              this.getRenderTransform(\n                center,\n                resolution,\n                rotation,\n                HIT_DETECT_RESOLUTION,\n                width,\n                height,\n                offsetX,\n              ).slice(),\n            );\n            startX += worldWidth;\n          }\n          world = 0;\n          startX = extent[2];\n          while (startX > projectionExtent[2]) {\n            ++world;\n            offsetX = worldWidth * world;\n            transforms.push(\n              this.getRenderTransform(\n                center,\n                resolution,\n                rotation,\n                HIT_DETECT_RESOLUTION,\n                width,\n                height,\n                offsetX,\n              ).slice(),\n            );\n            startX -= worldWidth;\n          }\n        }\n        const userProjection = getUserProjection();\n        this.hitDetectionImageData_ = createHitDetectionImageData(\n          size,\n          transforms,\n          this.renderedFeatures_,\n          layer.getStyleFunction(),\n          extent,\n          resolution,\n          rotation,\n          getSquaredRenderTolerance(resolution, this.renderedPixelRatio_),\n          userProjection ? projection : null,\n        );\n      }\n      resolve(\n        hitDetect(pixel, this.renderedFeatures_, this.hitDetectionImageData_),\n      );\n    });\n  }\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches,\n  ) {\n    if (!this.replayGroup_) {\n      return undefined;\n    }\n    const resolution = frameState.viewState.resolution;\n    const rotation = frameState.viewState.rotation;\n    const layer = this.getLayer();\n\n    /** @type {!Object<string, import(\"../Map.js\").HitMatch<T>|true>} */\n    const features = {};\n\n    /**\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     * @param {import(\"../../geom/SimpleGeometry.js\").default} geometry Geometry.\n     * @param {number} distanceSq The squared distance to the click position\n     * @return {T|undefined} Callback result.\n     */\n    const featureCallback = function (feature, geometry, distanceSq) {\n      const key = getUid(feature);\n      const match = features[key];\n      if (!match) {\n        if (distanceSq === 0) {\n          features[key] = true;\n          return callback(feature, layer, geometry);\n        }\n        matches.push(\n          (features[key] = {\n            feature: feature,\n            layer: layer,\n            geometry: geometry,\n            distanceSq: distanceSq,\n            callback: callback,\n          }),\n        );\n      } else if (match !== true && distanceSq < match.distanceSq) {\n        if (distanceSq === 0) {\n          features[key] = true;\n          matches.splice(matches.lastIndexOf(match), 1);\n          return callback(feature, layer, geometry);\n        }\n        match.geometry = geometry;\n        match.distanceSq = distanceSq;\n      }\n      return undefined;\n    };\n\n    let result;\n    const executorGroups = [this.replayGroup_];\n    const declutter = this.getLayer().getDeclutter();\n    executorGroups.some((executorGroup) => {\n      return (result = executorGroup.forEachFeatureAtCoordinate(\n        coordinate,\n        resolution,\n        rotation,\n        hitTolerance,\n        featureCallback,\n        declutter && frameState.declutter[declutter]\n          ? frameState.declutter[declutter].all().map((item) => item.value)\n          : null,\n      ));\n    });\n\n    return result;\n  }\n\n  /**\n   * Perform action necessary to get the layer rendered after new fonts have loaded\n   */\n  handleFontsChanged() {\n    const layer = this.getLayer();\n    if (layer.getVisible() && this.replayGroup_) {\n      layer.changed();\n    }\n  }\n\n  /**\n   * Handle changes in image style state.\n   * @param {import(\"../../events/Event.js\").default} event Image style change event.\n   * @private\n   */\n  handleStyleImageChange_(event) {\n    this.renderIfReadyAndVisible();\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    const vectorLayer = this.getLayer();\n    const vectorSource = vectorLayer.getSource();\n    if (!vectorSource) {\n      return false;\n    }\n\n    const animating = frameState.viewHints[ViewHint.ANIMATING];\n    const interacting = frameState.viewHints[ViewHint.INTERACTING];\n    const updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();\n    const updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();\n\n    if (\n      (this.ready && !updateWhileAnimating && animating) ||\n      (!updateWhileInteracting && interacting)\n    ) {\n      this.animatingOrInteracting_ = true;\n      return true;\n    }\n    this.animatingOrInteracting_ = false;\n\n    const frameStateExtent = frameState.extent;\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const resolution = viewState.resolution;\n    const pixelRatio = frameState.pixelRatio;\n    const vectorLayerRevision = vectorLayer.getRevision();\n    const vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();\n    let vectorLayerRenderOrder = vectorLayer.getRenderOrder();\n\n    if (vectorLayerRenderOrder === undefined) {\n      vectorLayerRenderOrder = defaultRenderOrder;\n    }\n\n    const center = viewState.center.slice();\n    const extent = buffer(\n      frameStateExtent,\n      vectorLayerRenderBuffer * resolution,\n    );\n    const renderedExtent = extent.slice();\n    const loadExtents = [extent.slice()];\n    const projectionExtent = projection.getExtent();\n\n    if (\n      vectorSource.getWrapX() &&\n      projection.canWrapX() &&\n      !containsExtent(projectionExtent, frameState.extent)\n    ) {\n      // For the replay group, we need an extent that intersects the real world\n      // (-180 to +180). To support geometries in a coordinate range from -540\n      // to +540, we add at least 1 world width on each side of the projection\n      // extent. If the viewport is wider than the world, we need to add half of\n      // the viewport width to make sure we cover the whole viewport.\n      const worldWidth = getWidth(projectionExtent);\n      const gutter = Math.max(getWidth(extent) / 2, worldWidth);\n      extent[0] = projectionExtent[0] - gutter;\n      extent[2] = projectionExtent[2] + gutter;\n      wrapCoordinateX(center, projection);\n      const loadExtent = wrapExtentX(loadExtents[0], projection);\n      // If the extent crosses the date line, we load data for both edges of the worlds\n      if (\n        loadExtent[0] < projectionExtent[0] &&\n        loadExtent[2] < projectionExtent[2]\n      ) {\n        loadExtents.push([\n          loadExtent[0] + worldWidth,\n          loadExtent[1],\n          loadExtent[2] + worldWidth,\n          loadExtent[3],\n        ]);\n      } else if (\n        loadExtent[0] > projectionExtent[0] &&\n        loadExtent[2] > projectionExtent[2]\n      ) {\n        loadExtents.push([\n          loadExtent[0] - worldWidth,\n          loadExtent[1],\n          loadExtent[2] - worldWidth,\n          loadExtent[3],\n        ]);\n      }\n    }\n\n    if (\n      this.ready &&\n      this.renderedResolution_ == resolution &&\n      this.renderedRevision_ == vectorLayerRevision &&\n      this.renderedRenderOrder_ == vectorLayerRenderOrder &&\n      this.renderedFrameDeclutter_ === !!frameState.declutter &&\n      containsExtent(this.wrappedRenderedExtent_, extent)\n    ) {\n      if (!equals(this.renderedExtent_, renderedExtent)) {\n        this.hitDetectionImageData_ = null;\n        this.renderedExtent_ = renderedExtent;\n      }\n      this.renderedCenter_ = center;\n      this.replayGroupChanged = false;\n      return true;\n    }\n\n    this.replayGroup_ = null;\n\n    const replayGroup = new CanvasBuilderGroup(\n      getRenderTolerance(resolution, pixelRatio),\n      extent,\n      resolution,\n      pixelRatio,\n    );\n\n    const userProjection = getUserProjection();\n    let userTransform;\n    if (userProjection) {\n      for (let i = 0, ii = loadExtents.length; i < ii; ++i) {\n        const extent = loadExtents[i];\n        const userExtent = toUserExtent(extent, projection);\n        vectorSource.loadFeatures(\n          userExtent,\n          toUserResolution(resolution, projection),\n          userProjection,\n        );\n      }\n      userTransform = getTransformFromProjections(userProjection, projection);\n    } else {\n      for (let i = 0, ii = loadExtents.length; i < ii; ++i) {\n        vectorSource.loadFeatures(loadExtents[i], resolution, projection);\n      }\n    }\n\n    const squaredTolerance = getSquaredRenderTolerance(resolution, pixelRatio);\n    let ready = true;\n    const render =\n      /**\n       * @param {import(\"../../Feature.js\").default} feature Feature.\n       * @param {number} index Index.\n       */\n      (feature, index) => {\n        let styles;\n        const styleFunction =\n          feature.getStyleFunction() || vectorLayer.getStyleFunction();\n        if (styleFunction) {\n          styles = styleFunction(feature, resolution);\n        }\n        if (styles) {\n          const dirty = this.renderFeature(\n            feature,\n            squaredTolerance,\n            styles,\n            replayGroup,\n            userTransform,\n            this.getLayer().getDeclutter(),\n            index,\n          );\n          ready = ready && !dirty;\n        }\n      };\n\n    const userExtent = toUserExtent(extent, projection);\n    /** @type {Array<import(\"../../Feature.js\").default>} */\n    const features = vectorSource.getFeaturesInExtent(userExtent);\n    if (vectorLayerRenderOrder) {\n      features.sort(vectorLayerRenderOrder);\n    }\n    for (let i = 0, ii = features.length; i < ii; ++i) {\n      render(features[i], i);\n    }\n    this.renderedFeatures_ = features;\n    this.ready = ready;\n\n    const replayGroupInstructions = replayGroup.finish();\n    const executorGroup = new ExecutorGroup(\n      extent,\n      resolution,\n      pixelRatio,\n      vectorSource.getOverlaps(),\n      replayGroupInstructions,\n      vectorLayer.getRenderBuffer(),\n      !!frameState.declutter,\n    );\n\n    this.renderedResolution_ = resolution;\n    this.renderedRevision_ = vectorLayerRevision;\n    this.renderedRenderOrder_ = vectorLayerRenderOrder;\n    this.renderedFrameDeclutter_ = !!frameState.declutter;\n    this.renderedExtent_ = renderedExtent;\n    this.wrappedRenderedExtent_ = extent;\n    this.renderedCenter_ = center;\n    this.renderedProjection_ = projection;\n    this.renderedPixelRatio_ = pixelRatio;\n    this.replayGroup_ = executorGroup;\n    this.hitDetectionImageData_ = null;\n\n    this.replayGroupChanged = true;\n    return true;\n  }\n\n  /**\n   * @param {import(\"../../Feature.js\").default} feature Feature.\n   * @param {number} squaredTolerance Squared render tolerance.\n   * @param {import(\"../../style/Style.js\").default|Array<import(\"../../style/Style.js\").default>} styles The style or array of styles.\n   * @param {import(\"../../render/canvas/BuilderGroup.js\").default} builderGroup Builder group.\n   * @param {import(\"../../proj.js\").TransformFunction} [transform] Transform from user to view projection.\n   * @param {boolean} [declutter] Enable decluttering.\n   * @param {number} [index] Render order index.\n   * @return {boolean} `true` if an image is loading.\n   */\n  renderFeature(\n    feature,\n    squaredTolerance,\n    styles,\n    builderGroup,\n    transform,\n    declutter,\n    index,\n  ) {\n    if (!styles) {\n      return false;\n    }\n    let loading = false;\n    if (Array.isArray(styles)) {\n      for (let i = 0, ii = styles.length; i < ii; ++i) {\n        loading =\n          renderFeature(\n            builderGroup,\n            feature,\n            styles[i],\n            squaredTolerance,\n            this.boundHandleStyleImageChange_,\n            transform,\n            declutter,\n            index,\n          ) || loading;\n      }\n    } else {\n      loading = renderFeature(\n        builderGroup,\n        feature,\n        styles,\n        squaredTolerance,\n        this.boundHandleStyleImageChange_,\n        transform,\n        declutter,\n        index,\n      );\n    }\n    return loading;\n  }\n}\n\nexport default CanvasVectorLayerRenderer;\n","/**\n * @module ol/renderer/canvas/VectorTileLayer\n */\nimport CanvasBuilderGroup from '../../render/canvas/BuilderGroup.js';\nimport CanvasExecutorGroup, {\n  DECLUTTER,\n} from '../../render/canvas/ExecutorGroup.js';\nimport CanvasTileLayerRenderer from './TileLayer.js';\nimport TileState from '../../TileState.js';\nimport ViewHint from '../../ViewHint.js';\nimport ZIndexContext from '../../render/canvas/ZIndexContext.js';\nimport {\n  HIT_DETECT_RESOLUTION,\n  createHitDetectionImageData,\n  hitDetect,\n} from '../../render/canvas/hitdetect.js';\nimport {\n  apply as applyTransform,\n  create as createTransform,\n  multiply,\n  reset as resetTransform,\n  scale,\n  scale as scaleTransform,\n  translate as translateTransform,\n} from '../../transform.js';\nimport {ascending} from '../../array.js';\nimport {\n  boundingExtent,\n  buffer,\n  containsExtent,\n  equals,\n  getIntersection,\n  getTopLeft,\n  intersects,\n} from '../../extent.js';\nimport {\n  getSquaredTolerance as getSquaredRenderTolerance,\n  renderFeature,\n} from '../vector.js';\nimport {getUid} from '../../util.js';\nimport {toSize} from '../../size.js';\nimport {wrapX} from '../../coordinate.js';\n\n/**\n * @type {!Object<string, Array<import(\"../../render/canvas.js\").BuilderType>>}\n */\nconst IMAGE_REPLAYS = {\n  'image': ['Polygon', 'Circle', 'LineString', 'Image', 'Text'],\n  'hybrid': ['Polygon', 'LineString'],\n  'vector': [],\n};\n\n/**\n * @type {!Object<string, Array<import(\"../../render/canvas.js\").BuilderType>>}\n */\nconst VECTOR_REPLAYS = {\n  'hybrid': ['Image', 'Text', 'Default'],\n  'vector': ['Polygon', 'Circle', 'LineString', 'Image', 'Text', 'Default'],\n};\n\n/**\n * @classdesc\n * Canvas renderer for vector tile layers.\n * @api\n * @extends {CanvasTileLayerRenderer<import(\"../../layer/VectorTile.js\").default>}\n */\nclass CanvasVectorTileLayerRenderer extends CanvasTileLayerRenderer {\n  /**\n   * @param {import(\"../../layer/VectorTile.js\").default} layer VectorTile layer.\n   */\n  constructor(layer) {\n    super(layer);\n\n    /** @private */\n    this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this);\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedLayerRevision_;\n\n    /**\n     * @private\n     * @type {import(\"../../transform\").Transform}\n     */\n    this.renderedPixelToCoordinateTransform_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedRotation_;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedOpacity_ = 1;\n\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.tmpTransform_ = createTransform();\n\n    /**\n     * @private\n     * @type {Array<ZIndexContext>}\n     */\n    this.tileClipContexts_ = null;\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection\").default} projection Projection.\n   * @return {boolean|undefined} Tile needs to be rendered.\n   */\n  prepareTile(tile, pixelRatio, projection) {\n    let render;\n    const state = tile.getState();\n    if (state === TileState.LOADED || state === TileState.ERROR) {\n      this.updateExecutorGroup_(tile, pixelRatio, projection);\n      if (this.tileImageNeedsRender_(tile)) {\n        render = true;\n      }\n    }\n    return render;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {!import(\"../../Tile.js\").default} Tile.\n   */\n  getTile(z, x, y, frameState) {\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const resolution = viewState.resolution;\n    const projection = viewState.projection;\n    const layer = this.getLayer();\n    const tile = layer.getSource().getTile(z, x, y, pixelRatio, projection);\n    const viewHints = frameState.viewHints;\n    const hifi = !(\n      viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]\n    );\n    if (hifi || !tile.wantedResolution) {\n      tile.wantedResolution = resolution;\n    }\n    const render = this.prepareTile(tile, pixelRatio, projection);\n    if (\n      render &&\n      (hifi || Date.now() - frameState.time < 8) &&\n      layer.getRenderMode() !== 'vector'\n    ) {\n      this.renderTileImage_(tile, frameState);\n    }\n    return super.getTile(z, x, y, frameState);\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @return {boolean} Tile is drawable.\n   */\n  isDrawableTile(tile) {\n    const layer = this.getLayer();\n    return (\n      super.isDrawableTile(tile) &&\n      (layer.getRenderMode() === 'vector'\n        ? getUid(layer) in tile.executorGroups\n        : tile.hasContext(layer))\n    );\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getTileImage(tile) {\n    return tile.getImage(this.getLayer());\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    const layerRevision = this.getLayer().getRevision();\n    if (this.renderedLayerRevision_ !== layerRevision) {\n      this.renderedLayerRevision_ = layerRevision;\n      this.renderedTiles.length = 0;\n    }\n    return super.prepareFrame(frameState);\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @private\n   */\n  updateExecutorGroup_(tile, pixelRatio, projection) {\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    const revision = layer.getRevision();\n    const renderOrder = layer.getRenderOrder() || null;\n\n    const resolution = tile.wantedResolution;\n    const builderState = tile.getReplayState(layer);\n    if (\n      !builderState.dirty &&\n      builderState.renderedResolution === resolution &&\n      builderState.renderedRevision == revision &&\n      builderState.renderedRenderOrder == renderOrder\n    ) {\n      return;\n    }\n\n    const source = layer.getSource();\n    const declutter = !!layer.getDeclutter();\n    const sourceTileGrid = source.getTileGrid();\n    const tileGrid = source.getTileGridForProjection(projection);\n    const tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n\n    const sourceTiles = source.getSourceTiles(pixelRatio, projection, tile);\n    const layerUid = getUid(layer);\n    delete tile.hitDetectionImageData[layerUid];\n    tile.executorGroups[layerUid] = [];\n    builderState.dirty = false;\n    for (let t = 0, tt = sourceTiles.length; t < tt; ++t) {\n      const sourceTile = sourceTiles[t];\n      if (sourceTile.getState() != TileState.LOADED) {\n        continue;\n      }\n      const sourceTileCoord = sourceTile.tileCoord;\n      const sourceTileExtent =\n        sourceTileGrid.getTileCoordExtent(sourceTileCoord);\n      const sharedExtent = getIntersection(tileExtent, sourceTileExtent);\n      const builderExtent = buffer(\n        sharedExtent,\n        layer.getRenderBuffer() * resolution,\n        this.tmpExtent,\n      );\n      const bufferedExtent = equals(sourceTileExtent, sharedExtent)\n        ? null\n        : builderExtent;\n      const builderGroup = new CanvasBuilderGroup(\n        0,\n        sharedExtent,\n        resolution,\n        pixelRatio,\n      );\n      const squaredTolerance = getSquaredRenderTolerance(\n        resolution,\n        pixelRatio,\n      );\n\n      /**\n       * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n       * @param {number} [index] Render order index.\n       * @this {CanvasVectorTileLayerRenderer}\n       */\n      const render = function (feature, index) {\n        let styles;\n        const styleFunction =\n          feature.getStyleFunction() || layer.getStyleFunction();\n        if (styleFunction) {\n          styles = styleFunction(feature, resolution);\n        }\n        if (styles) {\n          const dirty = this.renderFeature(\n            feature,\n            squaredTolerance,\n            styles,\n            builderGroup,\n            declutter,\n            index,\n          );\n          builderState.dirty = builderState.dirty || dirty;\n        }\n      };\n\n      const features = sourceTile.getFeatures();\n      if (renderOrder && renderOrder !== builderState.renderedRenderOrder) {\n        features.sort(renderOrder);\n      }\n      for (let i = 0, ii = features.length; i < ii; ++i) {\n        const feature = features[i];\n        if (\n          !bufferedExtent ||\n          intersects(bufferedExtent, feature.getGeometry().getExtent())\n        ) {\n          render.call(this, feature, i);\n        }\n      }\n      const executorGroupInstructions = builderGroup.finish();\n      // no need to clip when the render tile is covered by a single source tile\n      const replayExtent =\n        layer.getRenderMode() !== 'vector' &&\n        declutter &&\n        sourceTiles.length === 1\n          ? null\n          : sharedExtent;\n      const renderingReplayGroup = new CanvasExecutorGroup(\n        replayExtent,\n        resolution,\n        pixelRatio,\n        source.getOverlaps(),\n        executorGroupInstructions,\n        layer.getRenderBuffer(),\n        true,\n      );\n      tile.executorGroups[layerUid].push(renderingReplayGroup);\n    }\n    builderState.renderedRevision = revision;\n    builderState.renderedRenderOrder = renderOrder;\n    builderState.renderedResolution = resolution;\n  }\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches,\n  ) {\n    const resolution = frameState.viewState.resolution;\n    const rotation = frameState.viewState.rotation;\n    hitTolerance = hitTolerance == undefined ? 0 : hitTolerance;\n    const layer = this.getLayer();\n    const source = layer.getSource();\n    const tileGrid = source.getTileGridForProjection(\n      frameState.viewState.projection,\n    );\n\n    const hitExtent = boundingExtent([coordinate]);\n    buffer(hitExtent, resolution * hitTolerance, hitExtent);\n\n    /** @type {!Object<string, import(\"../Map.js\").HitMatch<T>|true>} */\n    const features = {};\n\n    /**\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     * @param {import(\"../../geom/SimpleGeometry.js\").default} geometry Geometry.\n     * @param {number} distanceSq The squared distance to the click position.\n     * @return {T|undefined} Callback result.\n     */\n    const featureCallback = function (feature, geometry, distanceSq) {\n      let key = feature.getId();\n      if (key === undefined) {\n        key = getUid(feature);\n      }\n      const match = features[key];\n      if (!match) {\n        if (distanceSq === 0) {\n          features[key] = true;\n          return callback(feature, layer, geometry);\n        }\n        matches.push(\n          (features[key] = {\n            feature: feature,\n            layer: layer,\n            geometry: geometry,\n            distanceSq: distanceSq,\n            callback: callback,\n          }),\n        );\n      } else if (match !== true && distanceSq < match.distanceSq) {\n        if (distanceSq === 0) {\n          features[key] = true;\n          matches.splice(matches.lastIndexOf(match), 1);\n          return callback(feature, layer, geometry);\n        }\n        match.geometry = geometry;\n        match.distanceSq = distanceSq;\n      }\n      return undefined;\n    };\n\n    const renderedTiles =\n      /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */ (\n        this.renderedTiles\n      );\n\n    let found;\n    for (let i = 0, ii = renderedTiles.length; !found && i < ii; ++i) {\n      const tile = renderedTiles[i];\n      const tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n      if (!intersects(tileExtent, hitExtent)) {\n        continue;\n      }\n\n      const layerUid = getUid(layer);\n      const executorGroups = [tile.executorGroups[layerUid]];\n      const declutter = layer.getDeclutter();\n      executorGroups.some((executorGroups) => {\n        const declutteredFeatures = declutter\n          ? frameState.declutter[declutter].all().map((item) => item.value)\n          : null;\n        for (let t = 0, tt = executorGroups.length; t < tt; ++t) {\n          const executorGroup = executorGroups[t];\n          found = executorGroup.forEachFeatureAtCoordinate(\n            coordinate,\n            resolution,\n            rotation,\n            hitTolerance,\n            featureCallback,\n            declutteredFeatures,\n          );\n          if (found) {\n            return true;\n          }\n        }\n      });\n    }\n    return found;\n  }\n\n  /**\n   * Asynchronous layer level hit detection.\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../../Feature.js\").FeatureLike>>} Promise that resolves with an array of features.\n   */\n  getFeatures(pixel) {\n    return new Promise((resolve, reject) => {\n      const layer = this.getLayer();\n      const layerUid = getUid(layer);\n      const source = layer.getSource();\n      const projection = this.renderedProjection;\n      const projectionExtent = projection.getExtent();\n      const resolution = this.renderedResolution;\n      const tileGrid = source.getTileGridForProjection(projection);\n      const coordinate = applyTransform(\n        this.renderedPixelToCoordinateTransform_,\n        pixel.slice(),\n      );\n      const tileCoord = tileGrid.getTileCoordForCoordAndResolution(\n        coordinate,\n        resolution,\n      );\n      /** @type {import(\"../../VectorRenderTile.js\").default|undefined} */\n      let tile;\n      for (let i = 0, ii = this.renderedTiles.length; i < ii; ++i) {\n        if (\n          tileCoord.toString() === this.renderedTiles[i].tileCoord.toString()\n        ) {\n          tile = /** @type {import(\"../../VectorRenderTile.js\").default} */ (\n            this.renderedTiles[i]\n          );\n          if (tile.getState() === TileState.LOADED) {\n            const extent = tileGrid.getTileCoordExtent(tile.tileCoord);\n            if (\n              source.getWrapX() &&\n              projection.canWrapX() &&\n              !containsExtent(projectionExtent, extent)\n            ) {\n              wrapX(coordinate, projection);\n            }\n            break;\n          }\n          tile = undefined;\n        }\n      }\n      if (!tile || tile.loadingSourceTiles > 0) {\n        resolve([]);\n        return;\n      }\n      const extent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n      const corner = getTopLeft(extent);\n      const tilePixel = [\n        (coordinate[0] - corner[0]) / resolution,\n        (corner[1] - coordinate[1]) / resolution,\n      ];\n      /** @type {Array<import(\"../../Feature.js\").FeatureLike>} */\n      const features = tile.getSourceTiles().reduce(function (\n        accumulator,\n        sourceTile,\n      ) {\n        return accumulator.concat(sourceTile.getFeatures());\n      }, []);\n      /** @type {ImageData|undefined} */\n      let hitDetectionImageData = tile.hitDetectionImageData[layerUid];\n      if (!hitDetectionImageData) {\n        const tileSize = toSize(\n          tileGrid.getTileSize(\n            tileGrid.getZForResolution(resolution, source.zDirection),\n          ),\n        );\n        const rotation = this.renderedRotation_;\n        const transforms = [\n          this.getRenderTransform(\n            tileGrid.getTileCoordCenter(tile.wrappedTileCoord),\n            resolution,\n            0,\n            HIT_DETECT_RESOLUTION,\n            tileSize[0] * HIT_DETECT_RESOLUTION,\n            tileSize[1] * HIT_DETECT_RESOLUTION,\n            0,\n          ),\n        ];\n        hitDetectionImageData = createHitDetectionImageData(\n          tileSize,\n          transforms,\n          features,\n          layer.getStyleFunction(),\n          tileGrid.getTileCoordExtent(tile.wrappedTileCoord),\n          tile.getReplayState(layer).renderedResolution,\n          rotation,\n        );\n        tile.hitDetectionImageData[layerUid] = hitDetectionImageData;\n      }\n      resolve(hitDetect(tilePixel, features, hitDetectionImageData));\n    });\n  }\n\n  /**\n   * Perform action necessary to get the layer rendered after new fonts have loaded\n   */\n  handleFontsChanged() {\n    const layer = this.getLayer();\n    if (layer.getVisible() && this.renderedLayerRevision_ !== undefined) {\n      layer.changed();\n    }\n  }\n\n  /**\n   * Handle changes in image style state.\n   * @param {import(\"../../events/Event.js\").default} event Image style change event.\n   * @private\n   */\n  handleStyleImageChange_(event) {\n    this.renderIfReadyAndVisible();\n  }\n\n  /**\n   * Render declutter items for this layer\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../layer/Layer.js\").State} layerState Layer state.\n   */\n  renderDeclutter(frameState, layerState) {\n    const context = this.context;\n    const alpha = context.globalAlpha;\n    context.globalAlpha = layerState.opacity;\n    const viewHints = frameState.viewHints;\n    const hifi = !(\n      viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]\n    );\n    const tiles =\n      /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */ (\n        this.renderedTiles\n      );\n    for (let i = 0, ii = tiles.length; i < ii; ++i) {\n      const tile = tiles[i];\n      const executorGroups = tile.executorGroups[getUid(this.getLayer())];\n      const declutter = this.getLayer().getDeclutter();\n      if (executorGroups) {\n        for (let j = executorGroups.length - 1; j >= 0; --j) {\n          executorGroups[j].execute(\n            this.context,\n            [this.context.canvas.width, this.context.canvas.height],\n            this.getTileRenderTransform(tile, frameState),\n            frameState.viewState.rotation,\n            hifi,\n            DECLUTTER,\n            declutter ? frameState.declutter[declutter] : undefined,\n          );\n        }\n      }\n    }\n    context.globalAlpha = alpha;\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   */\n  renderDeferredInternal(frameState) {\n    const tiles =\n      /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */ (\n        this.renderedTiles\n      );\n    const executorGroups = tiles.reduce((acc, tile, index) => {\n      tile.executorGroups[getUid(this.getLayer())].forEach((executorGroup) =>\n        acc.push({\n          executorGroup,\n          index,\n        }),\n      );\n      return acc;\n    }, []);\n\n    const executorGroupZIndexContexts = executorGroups.map(({executorGroup}) =>\n      executorGroup.getDeferredZIndexContexts(),\n    );\n    const usedZIndices = {};\n    for (let i = 0, ii = executorGroups.length; i < ii; ++i) {\n      const executorGroupZindexContext =\n        executorGroups[i].executorGroup.getDeferredZIndexContexts();\n      for (const key in executorGroupZindexContext) {\n        usedZIndices[key] = true;\n      }\n    }\n    const zIndexKeys = Object.keys(usedZIndices).sort(ascending);\n    zIndexKeys.map(Number).forEach((zIndex) => {\n      executorGroupZIndexContexts.forEach((zIndexContexts, i) => {\n        if (!zIndexContexts[zIndex]) {\n          return;\n        }\n        zIndexContexts[zIndex].forEach((zIndexContext) => {\n          const {executorGroup, index} = executorGroups[i];\n          const context = executorGroup.getRenderedContext();\n          const alpha = context.globalAlpha;\n          context.globalAlpha = this.renderedOpacity_;\n          const tileClipContext = this.tileClipContexts_[index];\n          if (tileClipContext) {\n            tileClipContext.draw(context);\n          }\n          zIndexContext.draw(context);\n          if (tileClipContext) {\n            context.restore();\n          }\n          context.globalAlpha = alpha;\n          zIndexContext.clear();\n        });\n        zIndexContexts[zIndex].length = 0;\n      });\n    });\n  }\n\n  getTileRenderTransform(tile, frameState) {\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const center = viewState.center;\n    const resolution = viewState.resolution;\n    const rotation = viewState.rotation;\n    const size = frameState.size;\n    const width = Math.round(size[0] * pixelRatio);\n    const height = Math.round(size[1] * pixelRatio);\n\n    const source = this.getLayer().getSource();\n    const tileGrid = source.getTileGridForProjection(\n      frameState.viewState.projection,\n    );\n    const tileCoord = tile.tileCoord;\n    const tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n    const worldOffset =\n      tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent)[0] - tileExtent[0];\n    const transform = multiply(\n      scale(this.inversePixelTransform.slice(), 1 / pixelRatio, 1 / pixelRatio),\n      this.getRenderTransform(\n        center,\n        resolution,\n        rotation,\n        pixelRatio,\n        width,\n        height,\n        worldOffset,\n      ),\n    );\n    return transform;\n  }\n\n  /**\n   * Render the vectors for this layer.\n   * @param {CanvasRenderingContext2D} context Target context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   */\n  postRender(context, frameState) {\n    const viewHints = frameState.viewHints;\n    const hifi = !(\n      viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]\n    );\n\n    this.renderedPixelToCoordinateTransform_ =\n      frameState.pixelToCoordinateTransform.slice();\n    this.renderedRotation_ = frameState.viewState.rotation;\n    this.renderedOpacity_ =\n      frameState.layerStatesArray[frameState.layerIndex].opacity;\n\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    const renderMode = layer.getRenderMode();\n    const alpha = context.globalAlpha;\n    context.globalAlpha = this.renderedOpacity_;\n    const declutter = layer.getDeclutter();\n    const replayTypes = declutter\n      ? VECTOR_REPLAYS[renderMode].filter((type) => !DECLUTTER.includes(type))\n      : VECTOR_REPLAYS[renderMode];\n    const viewState = frameState.viewState;\n    const rotation = viewState.rotation;\n    const tileSource = layer.getSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n    const z = tileGrid.getZForResolution(\n      viewState.resolution,\n      tileSource.zDirection,\n    );\n\n    const tiles = this.renderedTiles;\n    const clips = [];\n    const clipZs = [];\n    const tileClipContexts = [];\n    let ready = true;\n    for (let i = tiles.length - 1; i >= 0; --i) {\n      const tile = /** @type {import(\"../../VectorRenderTile.js\").default} */ (\n        tiles[i]\n      );\n      ready = ready && !tile.getReplayState(layer).dirty;\n      const executorGroups = tile.executorGroups[getUid(layer)].filter(\n        (group) => group.hasExecutors(replayTypes),\n      );\n      if (executorGroups.length === 0) {\n        continue;\n      }\n      const transform = this.getTileRenderTransform(tile, frameState);\n      const currentZ = tile.tileCoord[0];\n      let contextSaved = false;\n      // Clip mask for regions in this tile that already filled by a higher z tile\n      const currentClip = executorGroups[0].getClipCoords(transform);\n      let clipContext = context;\n      let tileClipContext;\n      if (currentClip) {\n        tileClipContext = new ZIndexContext();\n        clipContext = tileClipContext.getContext();\n        for (let j = 0, jj = clips.length; j < jj; ++j) {\n          if (z !== currentZ && currentZ < clipZs[j]) {\n            const clip = clips[j];\n            if (\n              intersects(\n                [\n                  currentClip[0],\n                  currentClip[3],\n                  currentClip[4],\n                  currentClip[7],\n                ],\n                [clip[0], clip[3], clip[4], clip[7]],\n              )\n            ) {\n              if (!contextSaved) {\n                clipContext.save();\n                contextSaved = true;\n              }\n              clipContext.beginPath();\n              // counter-clockwise (outer ring) for current tile\n              clipContext.moveTo(currentClip[0], currentClip[1]);\n              clipContext.lineTo(currentClip[2], currentClip[3]);\n              clipContext.lineTo(currentClip[4], currentClip[5]);\n              clipContext.lineTo(currentClip[6], currentClip[7]);\n              // clockwise (inner ring) for higher z tile\n              clipContext.moveTo(clip[6], clip[7]);\n              clipContext.lineTo(clip[4], clip[5]);\n              clipContext.lineTo(clip[2], clip[3]);\n              clipContext.lineTo(clip[0], clip[1]);\n              clipContext.clip();\n            }\n          }\n        }\n        clips.push(currentClip);\n        clipZs.push(currentZ);\n      }\n      for (let t = 0, tt = executorGroups.length; t < tt; ++t) {\n        const executorGroup = executorGroups[t];\n        executorGroup.execute(\n          context,\n          [context.canvas.width, context.canvas.height],\n          transform,\n          rotation,\n          hifi,\n          replayTypes,\n          frameState.declutter?.[declutter],\n        );\n      }\n      if (contextSaved) {\n        if (clipContext === context) {\n          clipContext.restore();\n        } else {\n          tileClipContexts[i] = tileClipContext;\n        }\n      }\n    }\n    context.globalAlpha = alpha;\n    this.ready = ready;\n    this.tileClipContexts_ = tileClipContexts;\n    if (!frameState.declutter) {\n      this.renderDeferredInternal(frameState);\n    }\n\n    super.postRender(context, frameState);\n  }\n\n  /**\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../../style/Style.js\").default|Array<import(\"../../style/Style.js\").default>} styles The style or array of styles.\n   * @param {import(\"../../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n   * @param {boolean} [declutter] Enable decluttering.\n   * @param {number} [index] Render order index.\n   * @return {boolean} `true` if an image is loading.\n   */\n  renderFeature(\n    feature,\n    squaredTolerance,\n    styles,\n    builderGroup,\n    declutter,\n    index,\n  ) {\n    if (!styles) {\n      return false;\n    }\n    let loading = false;\n    if (Array.isArray(styles)) {\n      for (let i = 0, ii = styles.length; i < ii; ++i) {\n        loading =\n          renderFeature(\n            builderGroup,\n            feature,\n            styles[i],\n            squaredTolerance,\n            this.boundHandleStyleImageChange_,\n            undefined,\n            declutter,\n            index,\n          ) || loading;\n      }\n    } else {\n      loading = renderFeature(\n        builderGroup,\n        feature,\n        styles,\n        squaredTolerance,\n        this.boundHandleStyleImageChange_,\n        undefined,\n        declutter,\n        index,\n      );\n    }\n    return loading;\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @return {boolean} A new tile image was rendered.\n   * @private\n   */\n  tileImageNeedsRender_(tile) {\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    if (layer.getRenderMode() === 'vector') {\n      return false;\n    }\n    const replayState = tile.getReplayState(layer);\n    const revision = layer.getRevision();\n    const resolution = tile.wantedResolution;\n    return (\n      replayState.renderedTileResolution !== resolution ||\n      replayState.renderedTileRevision !== revision\n    );\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {import(\"../../Map\").FrameState} frameState Frame state.\n   * @private\n   */\n  renderTileImage_(tile, frameState) {\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    const replayState = tile.getReplayState(layer);\n    const revision = layer.getRevision();\n    const executorGroups = tile.executorGroups[getUid(layer)];\n    replayState.renderedTileRevision = revision;\n\n    const tileCoord = tile.wrappedTileCoord;\n    const z = tileCoord[0];\n    const source = layer.getSource();\n    let pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const tileGrid = source.getTileGridForProjection(projection);\n    const tileResolution = tileGrid.getResolution(tile.tileCoord[0]);\n    const renderPixelRatio =\n      (frameState.pixelRatio / tile.wantedResolution) * tileResolution;\n    const resolution = tileGrid.getResolution(z);\n    const context = tile.getContext(layer);\n\n    // Increase tile size when overzooming for low pixel ratio, to avoid blurry tiles\n    pixelRatio = Math.round(\n      Math.max(pixelRatio, renderPixelRatio / pixelRatio),\n    );\n    const size = source.getTilePixelSize(z, pixelRatio, projection);\n    context.canvas.width = size[0];\n    context.canvas.height = size[1];\n    const renderScale = pixelRatio / renderPixelRatio;\n    if (renderScale !== 1) {\n      const canvasTransform = resetTransform(this.tmpTransform_);\n      scaleTransform(canvasTransform, renderScale, renderScale);\n      context.setTransform.apply(context, canvasTransform);\n    }\n    const tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);\n    const pixelScale = renderPixelRatio / resolution;\n    const transform = resetTransform(this.tmpTransform_);\n    scaleTransform(transform, pixelScale, -pixelScale);\n    translateTransform(transform, -tileExtent[0], -tileExtent[3]);\n    for (let i = 0, ii = executorGroups.length; i < ii; ++i) {\n      const executorGroup = executorGroups[i];\n      executorGroup.execute(\n        context,\n        [\n          context.canvas.width * renderScale,\n          context.canvas.height * renderScale,\n        ],\n        transform,\n        0,\n        true,\n        IMAGE_REPLAYS[layer.getRenderMode()],\n        null,\n      );\n    }\n    replayState.renderedTileResolution = tile.wantedResolution;\n  }\n}\n\nexport default CanvasVectorTileLayerRenderer;\n","/**\n * @module ol/renderer/vector\n */\nimport ImageState from '../ImageState.js';\nimport {getUid} from '../util.js';\n\n/**\n * Feature callback. The callback will be called with three arguments. The first\n * argument is one {@link module:ol/Feature~Feature feature} or {@link module:ol/render/Feature~RenderFeature render feature}\n * at the pixel, the second is the {@link module:ol/layer/Layer~Layer layer} of the feature and will be null for\n * unmanaged layers. The third is the {@link module:ol/geom/SimpleGeometry~SimpleGeometry} of the feature. For features\n * with a GeometryCollection geometry, it will be the first detected geometry from the collection.\n * @template T\n * @typedef {function(import(\"../Feature.js\").FeatureLike, import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>, import(\"../geom/SimpleGeometry.js\").default): T} FeatureCallback\n */\n\n/**\n * Tolerance for geometry simplification in device pixels.\n * @type {number}\n */\nconst SIMPLIFY_TOLERANCE = 0.5;\n\n/**\n * @const\n * @type {Object<import(\"../geom/Geometry.js\").Type,\n *                function(import(\"../render/canvas/BuilderGroup.js\").default, import(\"../geom/Geometry.js\").default,\n *                         import(\"../style/Style.js\").default, Object): void>}\n */\nconst GEOMETRY_RENDERERS = {\n  'Point': renderPointGeometry,\n  'LineString': renderLineStringGeometry,\n  'Polygon': renderPolygonGeometry,\n  'MultiPoint': renderMultiPointGeometry,\n  'MultiLineString': renderMultiLineStringGeometry,\n  'MultiPolygon': renderMultiPolygonGeometry,\n  'GeometryCollection': renderGeometryCollectionGeometry,\n  'Circle': renderCircleGeometry,\n};\n\n/**\n * @param {import(\"../Feature.js\").FeatureLike} feature1 Feature 1.\n * @param {import(\"../Feature.js\").FeatureLike} feature2 Feature 2.\n * @return {number} Order.\n */\nexport function defaultOrder(feature1, feature2) {\n  return parseInt(getUid(feature1), 10) - parseInt(getUid(feature2), 10);\n}\n\n/**\n * @param {number} resolution Resolution.\n * @param {number} pixelRatio Pixel ratio.\n * @return {number} Squared pixel tolerance.\n */\nexport function getSquaredTolerance(resolution, pixelRatio) {\n  const tolerance = getTolerance(resolution, pixelRatio);\n  return tolerance * tolerance;\n}\n\n/**\n * @param {number} resolution Resolution.\n * @param {number} pixelRatio Pixel ratio.\n * @return {number} Pixel tolerance.\n */\nexport function getTolerance(resolution, pixelRatio) {\n  return (SIMPLIFY_TOLERANCE * resolution) / pixelRatio;\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Builder group.\n * @param {import(\"../geom/Circle.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {number} [index] Render order index.\n */\nfunction renderCircleGeometry(builderGroup, geometry, style, feature, index) {\n  const fillStyle = style.getFill();\n  const strokeStyle = style.getStroke();\n  if (fillStyle || strokeStyle) {\n    const circleReplay = builderGroup.getBuilder(style.getZIndex(), 'Circle');\n    circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);\n    circleReplay.drawCircle(geometry, feature, index);\n  }\n  const textStyle = style.getText();\n  if (textStyle && textStyle.getText()) {\n    const textReplay = builderGroup.getBuilder(style.getZIndex(), 'Text');\n    textReplay.setTextStyle(textStyle);\n    textReplay.drawText(geometry, feature);\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} replayGroup Replay group.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {function(import(\"../events/Event.js\").default): void} listener Listener function.\n * @param {import(\"../proj.js\").TransformFunction} [transform] Transform from user to view projection.\n * @param {boolean} [declutter] Enable decluttering.\n * @param {number} [index] Render order index..\n * @return {boolean} `true` if style is loading.\n */\nexport function renderFeature(\n  replayGroup,\n  feature,\n  style,\n  squaredTolerance,\n  listener,\n  transform,\n  declutter,\n  index,\n) {\n  const loadingPromises = [];\n  const imageStyle = style.getImage();\n  if (imageStyle) {\n    let loading = true;\n    const imageState = imageStyle.getImageState();\n    if (imageState == ImageState.LOADED || imageState == ImageState.ERROR) {\n      loading = false;\n    } else {\n      if (imageState == ImageState.IDLE) {\n        imageStyle.load();\n      }\n    }\n    if (loading) {\n      loadingPromises.push(imageStyle.ready());\n    }\n  }\n  const fillStyle = style.getFill();\n  if (fillStyle && fillStyle.loading()) {\n    loadingPromises.push(fillStyle.ready());\n  }\n  const loading = loadingPromises.length > 0;\n  if (loading) {\n    Promise.all(loadingPromises).then(() => listener(null));\n  }\n  renderFeatureInternal(\n    replayGroup,\n    feature,\n    style,\n    squaredTolerance,\n    transform,\n    declutter,\n    index,\n  );\n\n  return loading;\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} replayGroup Replay group.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {import(\"../proj.js\").TransformFunction} [transform] Optional transform function.\n * @param {boolean} [declutter] Enable decluttering.\n * @param {number} [index] Render order index..\n */\nfunction renderFeatureInternal(\n  replayGroup,\n  feature,\n  style,\n  squaredTolerance,\n  transform,\n  declutter,\n  index,\n) {\n  const geometry = style.getGeometryFunction()(feature);\n  if (!geometry) {\n    return;\n  }\n  const simplifiedGeometry = geometry.simplifyTransformed(\n    squaredTolerance,\n    transform,\n  );\n  const renderer = style.getRenderer();\n  if (renderer) {\n    renderGeometry(replayGroup, simplifiedGeometry, style, feature, index);\n  } else {\n    const geometryRenderer = GEOMETRY_RENDERERS[simplifiedGeometry.getType()];\n    geometryRenderer(\n      replayGroup,\n      simplifiedGeometry,\n      style,\n      feature,\n      index,\n      declutter,\n    );\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} replayGroup Replay group.\n * @param {import(\"../geom/Geometry.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {number} [index] Render order index.\n */\nfunction renderGeometry(replayGroup, geometry, style, feature, index) {\n  if (geometry.getType() == 'GeometryCollection') {\n    const geometries =\n      /** @type {import(\"../geom/GeometryCollection.js\").default} */ (\n        geometry\n      ).getGeometries();\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      renderGeometry(replayGroup, geometries[i], style, feature, index);\n    }\n    return;\n  }\n  const replay = replayGroup.getBuilder(style.getZIndex(), 'Default');\n  replay.drawCustom(\n    /** @type {import(\"../geom/SimpleGeometry.js\").default} */ (geometry),\n    feature,\n    style.getRenderer(),\n    style.getHitDetectionRenderer(),\n    index,\n  );\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} replayGroup Replay group.\n * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [declutterBuilderGroup] Builder for decluttering.\n * @param {number} [index] Render order index.\n */\nfunction renderGeometryCollectionGeometry(\n  replayGroup,\n  geometry,\n  style,\n  feature,\n  declutterBuilderGroup,\n  index,\n) {\n  const geometries = geometry.getGeometriesArray();\n  let i, ii;\n  for (i = 0, ii = geometries.length; i < ii; ++i) {\n    const geometryRenderer = GEOMETRY_RENDERERS[geometries[i].getType()];\n    geometryRenderer(\n      replayGroup,\n      geometries[i],\n      style,\n      feature,\n      declutterBuilderGroup,\n      index,\n    );\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/LineString.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {number} [index] Render order index.\n */\nfunction renderLineStringGeometry(\n  builderGroup,\n  geometry,\n  style,\n  feature,\n  index,\n) {\n  const strokeStyle = style.getStroke();\n  if (strokeStyle) {\n    const lineStringReplay = builderGroup.getBuilder(\n      style.getZIndex(),\n      'LineString',\n    );\n    lineStringReplay.setFillStrokeStyle(null, strokeStyle);\n    lineStringReplay.drawLineString(geometry, feature, index);\n  }\n  const textStyle = style.getText();\n  if (textStyle && textStyle.getText()) {\n    const textReplay = builderGroup.getBuilder(style.getZIndex(), 'Text');\n    textReplay.setTextStyle(textStyle);\n    textReplay.drawText(geometry, feature, index);\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/MultiLineString.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {number} [index] Render order index.\n */\nfunction renderMultiLineStringGeometry(\n  builderGroup,\n  geometry,\n  style,\n  feature,\n  index,\n) {\n  const strokeStyle = style.getStroke();\n  if (strokeStyle) {\n    const lineStringReplay = builderGroup.getBuilder(\n      style.getZIndex(),\n      'LineString',\n    );\n    lineStringReplay.setFillStrokeStyle(null, strokeStyle);\n    lineStringReplay.drawMultiLineString(geometry, feature, index);\n  }\n  const textStyle = style.getText();\n  if (textStyle && textStyle.getText()) {\n    const textReplay = builderGroup.getBuilder(style.getZIndex(), 'Text');\n    textReplay.setTextStyle(textStyle);\n    textReplay.drawText(geometry, feature, index);\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {number} [index] Render order index.\n */\nfunction renderMultiPolygonGeometry(\n  builderGroup,\n  geometry,\n  style,\n  feature,\n  index,\n) {\n  const fillStyle = style.getFill();\n  const strokeStyle = style.getStroke();\n  if (strokeStyle || fillStyle) {\n    const polygonReplay = builderGroup.getBuilder(style.getZIndex(), 'Polygon');\n    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);\n    polygonReplay.drawMultiPolygon(geometry, feature, index);\n  }\n  const textStyle = style.getText();\n  if (textStyle && textStyle.getText()) {\n    const textReplay = builderGroup.getBuilder(style.getZIndex(), 'Text');\n    textReplay.setTextStyle(textStyle);\n    textReplay.drawText(geometry, feature, index);\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/Point.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {number} [index] Render order index.\n * @param {boolean} [declutter] Enable decluttering.\n */\nfunction renderPointGeometry(\n  builderGroup,\n  geometry,\n  style,\n  feature,\n  index,\n  declutter,\n) {\n  const imageStyle = style.getImage();\n  const textStyle = style.getText();\n  const hasText = textStyle && textStyle.getText();\n  /** @type {import(\"../render/canvas.js\").DeclutterImageWithText} */\n  const declutterImageWithText =\n    declutter && imageStyle && hasText ? {} : undefined;\n  if (imageStyle) {\n    if (imageStyle.getImageState() != ImageState.LOADED) {\n      return;\n    }\n    const imageReplay = builderGroup.getBuilder(style.getZIndex(), 'Image');\n    imageReplay.setImageStyle(imageStyle, declutterImageWithText);\n    imageReplay.drawPoint(geometry, feature, index);\n  }\n  if (hasText) {\n    const textReplay = builderGroup.getBuilder(style.getZIndex(), 'Text');\n    textReplay.setTextStyle(textStyle, declutterImageWithText);\n    textReplay.drawText(geometry, feature, index);\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/MultiPoint.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {number} [index] Render order index.\n * @param {boolean} [declutter] Enable decluttering.\n */\nfunction renderMultiPointGeometry(\n  builderGroup,\n  geometry,\n  style,\n  feature,\n  index,\n  declutter,\n) {\n  const imageStyle = style.getImage();\n  const hasImage = imageStyle && imageStyle.getOpacity() !== 0;\n  const textStyle = style.getText();\n  const hasText = textStyle && textStyle.getText();\n  /** @type {import(\"../render/canvas.js\").DeclutterImageWithText} */\n  const declutterImageWithText =\n    declutter && hasImage && hasText ? {} : undefined;\n  if (hasImage) {\n    if (imageStyle.getImageState() != ImageState.LOADED) {\n      return;\n    }\n    const imageReplay = builderGroup.getBuilder(style.getZIndex(), 'Image');\n    imageReplay.setImageStyle(imageStyle, declutterImageWithText);\n    imageReplay.drawMultiPoint(geometry, feature, index);\n  }\n  if (hasText) {\n    const textReplay = builderGroup.getBuilder(style.getZIndex(), 'Text');\n    textReplay.setTextStyle(textStyle, declutterImageWithText);\n    textReplay.drawText(geometry, feature, index);\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/Polygon.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {number} [index] Render order index.\n */\nfunction renderPolygonGeometry(builderGroup, geometry, style, feature, index) {\n  const fillStyle = style.getFill();\n  const strokeStyle = style.getStroke();\n  if (fillStyle || strokeStyle) {\n    const polygonReplay = builderGroup.getBuilder(style.getZIndex(), 'Polygon');\n    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);\n    polygonReplay.drawPolygon(geometry, feature, index);\n  }\n  const textStyle = style.getText();\n  if (textStyle && textStyle.getText()) {\n    const textReplay = builderGroup.getBuilder(style.getZIndex(), 'Text');\n    textReplay.setTextStyle(textStyle);\n    textReplay.drawText(geometry, feature, index);\n  }\n}\n","/**\n * @module ol/renderer/webgl/Layer\n */\nimport LayerProperty from '../../layer/Property.js';\nimport LayerRenderer from '../Layer.js';\nimport RenderEvent from '../../render/Event.js';\nimport RenderEventType from '../../render/EventType.js';\nimport WebGLHelper from '../../webgl/Helper.js';\nimport {\n  compose as composeTransform,\n  create as createTransform,\n} from '../../transform.js';\n\n/**\n * @typedef {Object} PostProcessesOptions\n * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than\n * the main canvas that will then be sampled up (useful for saving resource on blur steps).\n * @property {string} [vertexShader] Vertex shader source\n * @property {string} [fragmentShader] Fragment shader source\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process step\n */\n\n/**\n * @typedef {Object} Options\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process steps\n * @property {Array<PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n\n/**\n * @classdesc\n * Base WebGL renderer class.\n * Holds all logic related to data manipulation & some common rendering logic\n * @template {import(\"../../layer/Layer.js\").default} LayerType\n * @extends {LayerRenderer<LayerType>}\n */\nclass WebGLLayerRenderer extends LayerRenderer {\n  /**\n   * @param {LayerType} layer Layer.\n   * @param {Options} [options] Options.\n   */\n  constructor(layer, options) {\n    super(layer);\n\n    options = options || {};\n\n    /**\n     * The transform for viewport CSS pixels to rendered pixels.  This transform is only\n     * set before dispatching rendering events.\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.inversePixelTransform_ = createTransform();\n\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n    this.pixelContext_ = null;\n\n    /**\n     * @private\n     */\n    this.postProcesses_ = options.postProcesses;\n\n    /**\n     * @private\n     */\n    this.uniforms_ = options.uniforms;\n\n    /**\n     * @type {WebGLHelper}\n     * @protected\n     */\n    this.helper;\n\n    layer.addChangeListener(LayerProperty.MAP, this.removeHelper.bind(this));\n\n    this.dispatchPreComposeEvent = this.dispatchPreComposeEvent.bind(this);\n    this.dispatchPostComposeEvent = this.dispatchPostComposeEvent.bind(this);\n  }\n\n  /**\n   * @param {WebGLRenderingContext} context The WebGL rendering context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  dispatchPreComposeEvent(context, frameState) {\n    const layer = this.getLayer();\n    if (layer.hasListener(RenderEventType.PRECOMPOSE)) {\n      const event = new RenderEvent(\n        RenderEventType.PRECOMPOSE,\n        undefined,\n        frameState,\n        context,\n      );\n      layer.dispatchEvent(event);\n    }\n  }\n\n  /**\n   * @param {WebGLRenderingContext} context The WebGL rendering context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  dispatchPostComposeEvent(context, frameState) {\n    const layer = this.getLayer();\n    if (layer.hasListener(RenderEventType.POSTCOMPOSE)) {\n      const event = new RenderEvent(\n        RenderEventType.POSTCOMPOSE,\n        undefined,\n        frameState,\n        context,\n      );\n      layer.dispatchEvent(event);\n    }\n  }\n\n  /**\n   * Reset options (only handles uniforms).\n   * @param {Options} options Options.\n   */\n  reset(options) {\n    this.uniforms_ = options.uniforms;\n    if (this.helper) {\n      this.helper.setUniforms(this.uniforms_);\n    }\n  }\n\n  /**\n   * @protected\n   */\n  removeHelper() {\n    if (this.helper) {\n      this.helper.dispose();\n      delete this.helper;\n    }\n  }\n\n  /**\n   * Determine whether renderFrame should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    if (this.getLayer().getRenderSource()) {\n      let incrementGroup = true;\n      let groupNumber = -1;\n      let className;\n      for (let i = 0, ii = frameState.layerStatesArray.length; i < ii; i++) {\n        const layer = frameState.layerStatesArray[i].layer;\n        const renderer = layer.getRenderer();\n        if (!(renderer instanceof WebGLLayerRenderer)) {\n          incrementGroup = true;\n          continue;\n        }\n        const layerClassName = layer.getClassName();\n        if (incrementGroup || layerClassName !== className) {\n          groupNumber += 1;\n          incrementGroup = false;\n        }\n        className = layerClassName;\n        if (renderer === this) {\n          break;\n        }\n      }\n\n      const canvasCacheKey =\n        'map/' + frameState.mapId + '/group/' + groupNumber;\n\n      if (\n        !this.helper ||\n        !this.helper.canvasCacheKeyMatches(canvasCacheKey) ||\n        this.helper.needsToBeRecreated()\n      ) {\n        this.removeHelper();\n\n        this.helper = new WebGLHelper({\n          postProcesses: this.postProcesses_,\n          uniforms: this.uniforms_,\n          canvasCacheKey: canvasCacheKey,\n        });\n\n        if (className) {\n          this.helper.getCanvas().className = className;\n        }\n\n        this.afterHelperCreated();\n      }\n    }\n\n    return this.prepareFrameInternal(frameState);\n  }\n\n  /**\n   * @protected\n   */\n  afterHelperCreated() {}\n\n  /**\n   * Determine whether renderFrame should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   * @protected\n   */\n  prepareFrameInternal(frameState) {\n    return true;\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    this.removeHelper();\n    super.disposeInternal();\n  }\n\n  /**\n   * @param {import(\"../../render/EventType.js\").default} type Event type.\n   * @param {WebGLRenderingContext} context The rendering context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @private\n   */\n  dispatchRenderEvent_(type, context, frameState) {\n    const layer = this.getLayer();\n    if (layer.hasListener(type)) {\n      composeTransform(\n        this.inversePixelTransform_,\n        0,\n        0,\n        frameState.pixelRatio,\n        -frameState.pixelRatio,\n        0,\n        0,\n        -frameState.size[1],\n      );\n\n      const event = new RenderEvent(\n        type,\n        this.inversePixelTransform_,\n        frameState,\n        context,\n      );\n      layer.dispatchEvent(event);\n    }\n  }\n\n  /**\n   * @param {WebGLRenderingContext} context The rendering context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  preRender(context, frameState) {\n    this.dispatchRenderEvent_(RenderEventType.PRERENDER, context, frameState);\n  }\n\n  /**\n   * @param {WebGLRenderingContext} context The rendering context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  postRender(context, frameState) {\n    this.dispatchRenderEvent_(RenderEventType.POSTRENDER, context, frameState);\n  }\n}\n\nexport default WebGLLayerRenderer;\n","import {getWidth} from '../../extent.js';\n\n/**\n * Compute world params\n * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n * @param {any} layer The layer\n * @return {Array<number>} The world start, end and width.\n */\nexport function getWorldParameters(frameState, layer) {\n  const projection = frameState.viewState.projection;\n\n  const vectorSource = layer.getSource();\n  const multiWorld = vectorSource.getWrapX() && projection.canWrapX();\n  const projectionExtent = projection.getExtent();\n\n  const extent = frameState.extent;\n  const worldWidth = multiWorld ? getWidth(projectionExtent) : null;\n  const endWorld = multiWorld\n    ? Math.ceil((extent[2] - projectionExtent[2]) / worldWidth) + 1\n    : 1;\n\n  const startWorld = multiWorld\n    ? Math.floor((extent[0] - projectionExtent[0]) / worldWidth)\n    : 0;\n\n  return [startWorld, endWorld, worldWidth];\n}\n","/**\n * @module ol/renderer/webgl/PointsLayer\n */\nimport BaseVector from '../../layer/BaseVector.js';\nimport VectorEventType from '../../source/VectorEventType.js';\nimport ViewHint from '../../ViewHint.js';\nimport WebGLArrayBuffer from '../../webgl/Buffer.js';\nimport WebGLLayerRenderer from './Layer.js';\nimport WebGLRenderTarget from '../../webgl/RenderTarget.js';\nimport {ARRAY_BUFFER, DYNAMIC_DRAW, ELEMENT_ARRAY_BUFFER} from '../../webgl.js';\nimport {AttributeType, DefaultUniform} from '../../webgl/Helper.js';\nimport {WebGLWorkerMessageType} from '../../render/webgl/constants.js';\nimport {\n  apply as applyTransform,\n  create as createTransform,\n  makeInverse as makeInverseTransform,\n  multiply as multiplyTransform,\n  translate as translateTransform,\n} from '../../transform.js';\nimport {assert} from '../../asserts.js';\nimport {buffer, createEmpty, equals} from '../../extent.js';\nimport {colorDecodeId, colorEncodeId} from '../../render/webgl/utils.js';\nimport {create as createWebGLWorker} from '../../worker/webgl.js';\nimport {fromUserCoordinate, getUserProjection} from '../../proj.js';\nimport {getUid} from '../../util.js';\nimport {getWorldParameters} from './worldUtil.js';\nimport {listen, unlistenByKey} from '../../events.js';\n\n/**\n * @typedef {Object} CustomAttribute A description of a custom attribute to be passed on to the GPU, with a value different\n * for each feature.\n * @property {string} name Attribute name.\n * @property {function(import(\"../../Feature\").default, Object<string, *>):number} callback This callback computes the numerical value of the\n * attribute for a given feature (properties are available as 2nd arg for quicker access).\n */\n\n/**\n * @typedef {Object} FeatureCacheItem Object that holds a reference to a feature, its geometry and properties. Used to optimize\n * rebuildBuffers by accessing these objects quicker.\n * @property {import(\"../../Feature\").default} feature Feature\n * @property {Object<string, *>} properties Feature properties\n * @property {import(\"../../geom\").Geometry} geometry Feature geometry\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the canvas element.\n * @property {Array<CustomAttribute>} [attributes] These attributes will be read from the features in the source and then\n * passed to the GPU. The `name` property of each attribute will serve as its identifier:\n *  * In the vertex shader as an `attribute` by prefixing it with `a_`\n *  * In the fragment shader as a `varying` by prefixing it with `v_`\n * Please note that these can only be numerical values.\n * @property {string} vertexShader Vertex shader source, mandatory.\n * @property {string} fragmentShader Fragment shader source, mandatory.\n * @property {boolean} [hitDetectionEnabled] Whether shader is hit detection aware.\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process steps\n * Please note that `u_texture` is reserved for the main texture slot and `u_opacity` is reserved for the layer opacity.\n * @property {Array<import(\"./Layer\").PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n\n/**\n * @classdesc\n * WebGL vector renderer optimized for points.\n * All features will be rendered as quads (two triangles forming a square). New data will be flushed to the GPU\n * every time the vector source changes.\n *\n * You need to provide vertex and fragment shaders for rendering. This can be done using\n * {@link module:ol/webgl/ShaderBuilder~ShaderBuilder} utilities. These shaders shall expect a `a_position` attribute\n * containing the screen-space projected center of the quad, as well as a `a_index` attribute\n * whose value (0, 1, 2 or 3) indicates which quad vertex is currently getting processed (see structure below).\n *\n * To include variable attributes in the shaders, you need to declare them using the `attributes` property of\n * the options object like so:\n * ```js\n * new WebGLPointsLayerRenderer(layer, {\n *   attributes: [\n *     {\n *       name: 'size',\n *       callback: function(feature) {\n *         // compute something with the feature\n *       }\n *     },\n *     {\n *       name: 'weight',\n *       callback: function(feature) {\n *         // compute something with the feature\n *       }\n *     },\n *   ],\n *   vertexShader:\n *     // shader using attribute a_weight and a_size\n *   fragmentShader:\n *     // shader using varying v_weight and v_size\n * ```\n *\n * To enable hit detection, you must as well provide dedicated shaders using the `hitVertexShader`\n * and `hitFragmentShader` properties. These shall expect the `a_hitColor` attribute to contain\n * the final color that will have to be output for hit detection to work.\n *\n * The following uniform is used for the main texture: `u_texture`.\n * The following uniform is used for the layer opacity: `u_opacity`.\n *\n * Please note that the main shader output should have premultiplied alpha, otherwise visual anomalies may occur.\n *\n * Points are rendered as quads with the following structure:\n *\n * ```\n *   (u0, v1)      (u1, v1)\n *  [3]----------[2]\n *   |`           |\n *   |  `         |\n *   |    `       |\n *   |      `     |\n *   |        `   |\n *   |          ` |\n *  [0]----------[1]\n *   (u0, v0)      (u1, v0)\n *  ```\n *\n * This uses {@link module:ol/webgl/Helper~WebGLHelper} internally.\n *\n * @api\n */\nclass WebGLPointsLayerRenderer extends WebGLLayerRenderer {\n  /**\n   * @param {import(\"../../layer/Layer.js\").default} layer Layer.\n   * @param {Options} options Options.\n   */\n  constructor(layer, options) {\n    const uniforms = options.uniforms || {};\n    const projectionMatrixTransform = createTransform();\n    uniforms[DefaultUniform.PROJECTION_MATRIX] = projectionMatrixTransform;\n\n    super(layer, {\n      uniforms: uniforms,\n      postProcesses: options.postProcesses,\n    });\n\n    this.sourceRevision_ = -1;\n\n    this.verticesBuffer_ = new WebGLArrayBuffer(ARRAY_BUFFER, DYNAMIC_DRAW);\n    this.indicesBuffer_ = new WebGLArrayBuffer(\n      ELEMENT_ARRAY_BUFFER,\n      DYNAMIC_DRAW,\n    );\n\n    /**\n     * @private\n     */\n    this.vertexShader_ = options.vertexShader;\n\n    /**\n     * @private\n     */\n    this.fragmentShader_ = options.fragmentShader;\n\n    /**\n     * @type {WebGLProgram}\n     * @private\n     */\n    this.program_;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hitDetectionEnabled_ = options.hitDetectionEnabled ?? true;\n\n    const customAttributes = options.attributes\n      ? options.attributes.map(function (attribute) {\n          return {\n            name: 'a_prop_' + attribute.name,\n            size: 1,\n            type: AttributeType.FLOAT,\n          };\n        })\n      : [];\n\n    /**\n     * A list of attributes used by the renderer. By default only the position and\n     * index of the vertex (0 to 3) are required.\n     * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n     */\n    this.attributes = [\n      {\n        name: 'a_position',\n        size: 2,\n        type: AttributeType.FLOAT,\n      },\n      {\n        name: 'a_index',\n        size: 1,\n        type: AttributeType.FLOAT,\n      },\n    ];\n\n    if (this.hitDetectionEnabled_) {\n      this.attributes.push({\n        name: 'a_prop_hitColor',\n        size: 4,\n        type: AttributeType.FLOAT,\n      });\n      this.attributes.push({\n        name: 'a_featureUid',\n        size: 1,\n        type: AttributeType.FLOAT,\n      });\n    }\n    this.attributes.push(...customAttributes);\n\n    this.customAttributes = options.attributes ? options.attributes : [];\n\n    this.previousExtent_ = createEmpty();\n\n    /**\n     * This transform is updated on every frame and is the composition of:\n     * - invert of the world->screen transform that was used when rebuilding buffers (see `this.renderTransform_`)\n     * - current world->screen transform\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.currentTransform_ = projectionMatrixTransform;\n\n    /**\n     * This transform is updated when buffers are rebuilt and converts world space coordinates to screen space\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.renderTransform_ = createTransform();\n\n    /**\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.invertRenderTransform_ = createTransform();\n\n    /**\n     * @type {Float32Array}\n     * @private\n     */\n    this.renderInstructions_ = new Float32Array(0);\n\n    /**\n     * @type {WebGLRenderTarget}\n     * @private\n     */\n    this.hitRenderTarget_;\n\n    /**\n     * Keep track of latest message sent to worker\n     * @type {number}\n     * @private\n     */\n    this.lastSentId = 0;\n\n    /**\n     * @private\n     */\n    this.worker_ = createWebGLWorker();\n\n    this.worker_.addEventListener(\n      'message',\n      /**\n       * @param {*} event Event.\n       */\n      (event) => {\n        const received = event.data;\n        if (received.type === WebGLWorkerMessageType.GENERATE_POINT_BUFFERS) {\n          const projectionTransform = received.projectionTransform;\n          this.verticesBuffer_.fromArrayBuffer(received.vertexBuffer);\n          this.helper.flushBufferData(this.verticesBuffer_);\n          this.indicesBuffer_.fromArrayBuffer(received.indexBuffer);\n          this.helper.flushBufferData(this.indicesBuffer_);\n\n          this.renderTransform_ = projectionTransform;\n          makeInverseTransform(\n            this.invertRenderTransform_,\n            this.renderTransform_,\n          );\n          this.renderInstructions_ = new Float32Array(\n            event.data.renderInstructions,\n          );\n          if (received.id === this.lastSentId) {\n            this.ready = true;\n          }\n          this.getLayer().changed();\n        }\n      },\n    );\n\n    /**\n     * This object will be updated when the source changes. Key is uid.\n     * @type {Object<string, FeatureCacheItem>}\n     * @private\n     */\n    this.featureCache_ = {};\n\n    /**\n     * Amount of features in the cache.\n     * @type {number}\n     * @private\n     */\n    this.featureCount_ = 0;\n\n    const source = this.getLayer().getSource();\n    this.sourceListenKeys_ = [\n      listen(\n        source,\n        VectorEventType.ADDFEATURE,\n        this.handleSourceFeatureAdded_,\n        this,\n      ),\n      listen(\n        source,\n        VectorEventType.CHANGEFEATURE,\n        this.handleSourceFeatureChanged_,\n        this,\n      ),\n      listen(\n        source,\n        VectorEventType.REMOVEFEATURE,\n        this.handleSourceFeatureDelete_,\n        this,\n      ),\n      listen(\n        source,\n        VectorEventType.CLEAR,\n        this.handleSourceFeatureClear_,\n        this,\n      ),\n    ];\n    source.forEachFeature((feature) => {\n      this.featureCache_[getUid(feature)] = {\n        feature: feature,\n        properties: feature.getProperties(),\n        geometry: feature.getGeometry(),\n      };\n      this.featureCount_++;\n    });\n  }\n\n  afterHelperCreated() {\n    this.program_ = this.helper.getProgram(\n      this.fragmentShader_,\n      this.vertexShader_,\n    );\n\n    if (this.hitDetectionEnabled_) {\n      this.hitRenderTarget_ = new WebGLRenderTarget(this.helper);\n    }\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureAdded_(event) {\n    const feature = event.feature;\n    this.featureCache_[getUid(feature)] = {\n      feature: feature,\n      properties: feature.getProperties(),\n      geometry: feature.getGeometry(),\n    };\n    this.featureCount_++;\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureChanged_(event) {\n    const feature = event.feature;\n    this.featureCache_[getUid(feature)] = {\n      feature: feature,\n      properties: feature.getProperties(),\n      geometry: feature.getGeometry(),\n    };\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureDelete_(event) {\n    const feature = event.feature;\n    delete this.featureCache_[getUid(feature)];\n    this.featureCount_--;\n  }\n\n  /**\n   * @private\n   */\n  handleSourceFeatureClear_() {\n    this.featureCache_ = {};\n    this.featureCount_ = 0;\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState) {\n    const gl = this.helper.getGL();\n    this.preRender(gl, frameState);\n    const [startWorld, endWorld, worldWidth] = getWorldParameters(\n      frameState,\n      this.getLayer(),\n    );\n\n    // draw the normal canvas\n    this.renderWorlds(frameState, false, startWorld, endWorld, worldWidth);\n    this.helper.finalizeDraw(\n      frameState,\n      this.dispatchPreComposeEvent,\n      this.dispatchPostComposeEvent,\n    );\n\n    if (this.hitDetectionEnabled_) {\n      // draw the hit buffer\n      this.renderWorlds(frameState, true, startWorld, endWorld, worldWidth);\n      this.hitRenderTarget_.clearCachedData();\n    }\n\n    this.postRender(gl, frameState);\n\n    const canvas = this.helper.getCanvas();\n    return canvas;\n  }\n\n  /**\n   * Determine whether renderFrame should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrameInternal(frameState) {\n    const layer = this.getLayer();\n    const vectorSource = layer.getSource();\n    const viewState = frameState.viewState;\n    const viewNotMoving =\n      !frameState.viewHints[ViewHint.ANIMATING] &&\n      !frameState.viewHints[ViewHint.INTERACTING];\n    const extentChanged = !equals(this.previousExtent_, frameState.extent);\n    const sourceChanged = this.sourceRevision_ < vectorSource.getRevision();\n\n    if (sourceChanged) {\n      this.sourceRevision_ = vectorSource.getRevision();\n    }\n\n    if (viewNotMoving && (extentChanged || sourceChanged)) {\n      const projection = viewState.projection;\n      const resolution = viewState.resolution;\n\n      const renderBuffer =\n        layer instanceof BaseVector ? layer.getRenderBuffer() : 0;\n      const extent = buffer(frameState.extent, renderBuffer * resolution);\n      vectorSource.loadFeatures(extent, resolution, projection);\n\n      this.rebuildBuffers_(frameState);\n      this.previousExtent_ = frameState.extent.slice();\n    }\n\n    this.helper.useProgram(this.program_, frameState);\n    this.helper.prepareDraw(frameState);\n\n    // write new data\n    this.helper.bindBuffer(this.verticesBuffer_);\n    this.helper.bindBuffer(this.indicesBuffer_);\n    this.helper.enableAttributes(this.attributes);\n\n    return true;\n  }\n\n  /**\n   * Rebuild internal webgl buffers based on current view extent; costly, should not be called too much\n   * @param {import(\"../../Map\").FrameState} frameState Frame state.\n   * @private\n   */\n  rebuildBuffers_(frameState) {\n    // saves the projection transform for the current frame state\n    const projectionTransform = createTransform();\n    this.helper.makeProjectionTransform(frameState, projectionTransform);\n\n    const userProjection = getUserProjection();\n\n    const baseInstructionLength = this.hitDetectionEnabled_ ? 7 : 2; // see below\n    const singleInstructionLength =\n      baseInstructionLength + this.customAttributes.length;\n    const totalSize = singleInstructionLength * this.featureCount_;\n    if (\n      !this.renderInstructions_ ||\n      this.renderInstructions_.length !== totalSize\n    ) {\n      this.renderInstructions_ = new Float32Array(totalSize);\n    }\n\n    // loop on features to fill the buffer\n    let featureCache, geometry;\n    const tmpCoords = [];\n    const tmpColor = [];\n    let idx = -1;\n    for (const featureUid in this.featureCache_) {\n      featureCache = this.featureCache_[featureUid];\n      geometry = /** @type {import(\"../../geom\").Point} */ (\n        featureCache.geometry\n      );\n      if (!geometry || geometry.getType() !== 'Point') {\n        continue;\n      }\n      if (userProjection) {\n        const userCoords = fromUserCoordinate(\n          geometry.getFlatCoordinates(),\n          frameState.viewState.projection,\n        );\n        tmpCoords[0] = userCoords[0];\n        tmpCoords[1] = userCoords[1];\n      } else {\n        tmpCoords[0] = geometry.getFlatCoordinates()[0];\n        tmpCoords[1] = geometry.getFlatCoordinates()[1];\n      }\n      applyTransform(projectionTransform, tmpCoords);\n\n      this.renderInstructions_[++idx] = tmpCoords[0];\n      this.renderInstructions_[++idx] = tmpCoords[1];\n\n      // for hit detection, the feature uid is saved in the opacity value\n      // and the index of the opacity value is encoded in the color values\n      if (this.hitDetectionEnabled_) {\n        const hitColor = colorEncodeId(idx + 5, tmpColor);\n        this.renderInstructions_[++idx] = hitColor[0];\n        this.renderInstructions_[++idx] = hitColor[1];\n        this.renderInstructions_[++idx] = hitColor[2];\n        this.renderInstructions_[++idx] = hitColor[3];\n        this.renderInstructions_[++idx] = Number(featureUid);\n      }\n\n      // pushing custom attributes\n      for (let j = 0; j < this.customAttributes.length; j++) {\n        const value = this.customAttributes[j].callback(\n          featureCache.feature,\n          featureCache.properties,\n        );\n        this.renderInstructions_[++idx] = value;\n      }\n    }\n\n    /** @type {import('../../render/webgl/constants.js').WebGLWorkerGenerateBuffersMessage} */\n    const message = {\n      id: ++this.lastSentId,\n      type: WebGLWorkerMessageType.GENERATE_POINT_BUFFERS,\n      renderInstructions: this.renderInstructions_.buffer,\n      customAttributesSize: singleInstructionLength - 2,\n    };\n    // additional properties will be sent back as-is by the worker\n    message['projectionTransform'] = projectionTransform;\n    this.ready = false;\n    this.worker_.postMessage(message, [this.renderInstructions_.buffer]);\n    this.renderInstructions_ = null;\n  }\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches,\n  ) {\n    assert(\n      this.hitDetectionEnabled_,\n      '`forEachFeatureAtCoordinate` cannot be used on a WebGL layer if the hit detection logic has been disabled using the `disableHitDetection: true` option.',\n    );\n    if (!this.renderInstructions_ || !this.hitDetectionEnabled_) {\n      return undefined;\n    }\n\n    const pixel = applyTransform(\n      frameState.coordinateToPixelTransform,\n      coordinate.slice(),\n    );\n\n    const data = this.hitRenderTarget_.readPixel(pixel[0] / 2, pixel[1] / 2);\n    const color = [data[0] / 255, data[1] / 255, data[2] / 255, data[3] / 255];\n    const index = colorDecodeId(color);\n    const opacity = this.renderInstructions_[index];\n    const uid = Math.floor(opacity).toString();\n\n    const source = this.getLayer().getSource();\n    const feature = source.getFeatureByUid(uid);\n    if (feature) {\n      return callback(feature, this.getLayer(), null);\n    }\n    return undefined;\n  }\n\n  /**\n   * Render the world, either to the main framebuffer or to the hit framebuffer\n   * @param {import(\"../../Map.js\").FrameState} frameState current frame state\n   * @param {boolean} forHitDetection whether the rendering is for hit detection\n   * @param {number} startWorld the world to render in the first iteration\n   * @param {number} endWorld the last world to render\n   * @param {number} worldWidth the width of the worlds being rendered\n   */\n  renderWorlds(frameState, forHitDetection, startWorld, endWorld, worldWidth) {\n    let world = startWorld;\n\n    this.helper.useProgram(this.program_, frameState);\n\n    if (forHitDetection) {\n      this.hitRenderTarget_.setSize([\n        Math.floor(frameState.size[0] / 2),\n        Math.floor(frameState.size[1] / 2),\n      ]);\n      this.helper.prepareDrawToRenderTarget(\n        frameState,\n        this.hitRenderTarget_,\n        true,\n      );\n    }\n\n    this.helper.bindBuffer(this.verticesBuffer_);\n    this.helper.bindBuffer(this.indicesBuffer_);\n    this.helper.enableAttributes(this.attributes);\n\n    do {\n      this.helper.makeProjectionTransform(frameState, this.currentTransform_);\n      translateTransform(this.currentTransform_, world * worldWidth, 0);\n      multiplyTransform(this.currentTransform_, this.invertRenderTransform_);\n      this.helper.applyUniforms(frameState);\n      this.helper.applyHitDetectionUniform(forHitDetection);\n      const renderCount = this.indicesBuffer_.getSize();\n      this.helper.drawElements(0, renderCount);\n    } while (++world < endWorld);\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    this.worker_.terminate();\n    this.layer_ = null;\n    this.sourceListenKeys_.forEach(function (key) {\n      unlistenByKey(key);\n    });\n    this.sourceListenKeys_ = null;\n    super.disposeInternal();\n  }\n\n  renderDeclutter() {}\n}\n\nexport default WebGLPointsLayerRenderer;\n","/**\n * @module ol/renderer/webgl/TileLayerBase\n */\nimport LRUCache from '../../structs/LRUCache.js';\nimport ReprojDataTile from '../../reproj/DataTile.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport WebGLLayerRenderer from './Layer.js';\nimport {abstract, getUid} from '../../util.js';\nimport {create as createMat4} from '../../vec/mat4.js';\nimport {\n  createOrUpdate as createTileCoord,\n  getKey as getTileCoordKey,\n} from '../../tilecoord.js';\nimport {\n  create as createTransform,\n  reset as resetTransform,\n  rotate as rotateTransform,\n  scale as scaleTransform,\n  translate as translateTransform,\n} from '../../transform.js';\nimport {descending} from '../../array.js';\nimport {fromUserExtent} from '../../proj.js';\nimport {getIntersection, isEmpty} from '../../extent.js';\nimport {toSize} from '../../size.js';\n\nexport const Uniforms = {\n  TILE_TRANSFORM: 'u_tileTransform',\n  TRANSITION_ALPHA: 'u_transitionAlpha',\n  DEPTH: 'u_depth',\n  RENDER_EXTENT: 'u_renderExtent', // intersection of layer, source, and view extent\n  PATTERN_ORIGIN: 'u_patternOrigin',\n  RESOLUTION: 'u_resolution',\n  ZOOM: 'u_zoom',\n  GLOBAL_ALPHA: 'u_globalAlpha',\n  PROJECTION_MATRIX: 'u_projectionMatrix',\n  SCREEN_TO_WORLD_MATRIX: 'u_screenToWorldMatrix',\n};\n\n/**\n * @type {Object<string, boolean>}\n */\nconst empty = {};\n\n/**\n * Transform a zoom level into a depth value; zoom level zero has a depth value of 0.5, and increasing values\n * have a depth trending towards 0\n * @param {number} z A zoom level.\n * @return {number} A depth value.\n */\nfunction depthForZ(z) {\n  return 1 / (z + 2);\n}\n\n/**\n * @typedef {import(\"../../webgl/BaseTileRepresentation.js\").default<import(\"../../Tile.js\").default>} AbstractTileRepresentation\n */\n/**\n * @typedef {Object} TileRepresentationLookup\n * @property {Set<string>} tileIds The set of tile ids in the lookup.\n * @property {Object<number, Set<AbstractTileRepresentation>>} representationsByZ Tile representations by zoom level.\n */\n\n/**\n * @return {TileRepresentationLookup} A new tile representation lookup.\n */\nexport function newTileRepresentationLookup() {\n  return {tileIds: new Set(), representationsByZ: {}};\n}\n\n/**\n * Check if a tile is already in the tile representation lookup.\n * @param {TileRepresentationLookup} tileRepresentationLookup Lookup of tile representations by zoom level.\n * @param {import(\"../../Tile.js\").default} tile A tile.\n * @return {boolean} The tile is already in the lookup.\n */\nfunction lookupHasTile(tileRepresentationLookup, tile) {\n  return tileRepresentationLookup.tileIds.has(getUid(tile));\n}\n\n/**\n * Add a tile representation to the lookup.\n * @param {TileRepresentationLookup} tileRepresentationLookup Lookup of tile representations by zoom level.\n * @param {AbstractTileRepresentation} tileRepresentation A tile representation.\n * @param {number} z The zoom level.\n */\nfunction addTileRepresentationToLookup(\n  tileRepresentationLookup,\n  tileRepresentation,\n  z,\n) {\n  const representationsByZ = tileRepresentationLookup.representationsByZ;\n  if (!(z in representationsByZ)) {\n    representationsByZ[z] = new Set();\n  }\n  representationsByZ[z].add(tileRepresentation);\n  tileRepresentationLookup.tileIds.add(getUid(tileRepresentation.tile));\n}\n\n/**\n * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n * @param {import(\"../../extent.js\").Extent} extent The frame extent.\n * @return {import(\"../../extent.js\").Extent} Frame extent intersected with layer extents.\n */\nfunction getRenderExtent(frameState, extent) {\n  const layerState = frameState.layerStatesArray[frameState.layerIndex];\n  if (layerState.extent) {\n    extent = getIntersection(\n      extent,\n      fromUserExtent(layerState.extent, frameState.viewState.projection),\n    );\n  }\n  const source = /** @type {import(\"../../source/Tile.js\").default} */ (\n    layerState.layer.getRenderSource()\n  );\n  if (!source.getWrapX()) {\n    const gridExtent = source\n      .getTileGridForProjection(frameState.viewState.projection)\n      .getExtent();\n    if (gridExtent) {\n      extent = getIntersection(extent, gridExtent);\n    }\n  }\n  return extent;\n}\n\nexport function getCacheKey(source, tileCoord) {\n  return `${source.getKey()},${getTileCoordKey(tileCoord)}`;\n}\n\n/**\n * @typedef {Object} Options\n * @property {Object<string, import(\"../../webgl/Helper\").UniformValue>} [uniforms] Additional uniforms\n * made available to shaders.\n * @property {number} [cacheSize=512] The tile representation cache size.\n * @property {Array<import('./Layer.js').PostProcessesOptions>} [postProcesses] Post-processes definitions.\n */\n\n/**\n * @typedef {import(\"../../layer/BaseTile.js\").default} BaseLayerType\n */\n\n/**\n * @classdesc\n * Base WebGL renderer for tile layers.\n * @template {BaseLayerType} LayerType\n * @template {import(\"../../Tile.js\").default} TileType\n * @template {import(\"../../webgl/BaseTileRepresentation.js\").default<TileType>} TileRepresentation\n * @extends {WebGLLayerRenderer<LayerType>}\n */\nclass WebGLBaseTileLayerRenderer extends WebGLLayerRenderer {\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   * @param {Options} options Options.\n   */\n  constructor(tileLayer, options) {\n    super(tileLayer, {\n      uniforms: options.uniforms,\n      postProcesses: options.postProcesses,\n    });\n\n    /**\n     * The last call to `renderFrame` was completed with all tiles loaded\n     * @type {boolean}\n     */\n    this.renderComplete = false;\n\n    /**\n     * This transform converts representation coordinates to screen coordinates.\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.tileTransform_ = createTransform();\n\n    /**\n     * @type {Array<number>}\n     * @protected\n     */\n    this.tempMat4 = createMat4();\n\n    /**\n     * @type {import(\"../../TileRange.js\").default}\n     * @private\n     */\n    this.tempTileRange_ = new TileRange(0, 0, 0, 0);\n\n    /**\n     * @type {import(\"../../tilecoord.js\").TileCoord}\n     * @private\n     */\n    this.tempTileCoord_ = createTileCoord(0, 0, 0);\n\n    /**\n     * @type {import(\"../../size.js\").Size}\n     * @private\n     */\n    this.tempSize_ = [0, 0];\n\n    const cacheSize = options.cacheSize !== undefined ? options.cacheSize : 512;\n    /**\n     * @type {import(\"../../structs/LRUCache.js\").default<TileRepresentation>}\n     * @protected\n     */\n    this.tileRepresentationCache = new LRUCache(cacheSize);\n\n    /**\n     * @protected\n     * @type {import(\"../../Map.js\").FrameState|null}\n     */\n    this.frameState = null;\n\n    /**\n     * @private\n     * @type {import(\"../../proj/Projection.js\").default}\n     */\n    this.projection_ = undefined;\n  }\n\n  /**\n   * @param {Options} options Options.\n   */\n  reset(options) {\n    super.reset({\n      uniforms: options.uniforms,\n    });\n  }\n\n  /**\n   * @param {TileType} tile Tile.\n   * @return {boolean} Tile is drawable.\n   * @private\n   */\n  isDrawableTile_(tile) {\n    const tileLayer = this.getLayer();\n    const tileState = tile.getState();\n    const useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();\n    return (\n      tileState == TileState.LOADED ||\n      tileState == TileState.EMPTY ||\n      (tileState == TileState.ERROR && !useInterimTilesOnError)\n    );\n  }\n\n  /**\n   * Determine whether renderFrame should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrameInternal(frameState) {\n    if (!this.projection_) {\n      this.projection_ = frameState.viewState.projection;\n    } else if (frameState.viewState.projection !== this.projection_) {\n      this.clearCache();\n      this.projection_ = frameState.viewState.projection;\n    }\n\n    const layer = this.getLayer();\n    const source = layer.getRenderSource();\n    if (!source) {\n      return false;\n    }\n\n    if (isEmpty(getRenderExtent(frameState, frameState.extent))) {\n      return false;\n    }\n    return source.getState() === 'ready';\n  }\n\n  /**\n   * @abstract\n   * @param {import(\"../../webgl/BaseTileRepresentation.js\").TileRepresentationOptions<TileType>} options tile representation options\n   * @return {TileRepresentation} A new tile representation\n   * @protected\n   */\n  createTileRepresentation(options) {\n    return abstract();\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../extent.js\").Extent} extent The extent to be rendered.\n   * @param {number} initialZ The zoom level.\n   * @param {TileRepresentationLookup} tileRepresentationLookup The zoom level.\n   * @param {number} preload Number of additional levels to load.\n   */\n  enqueueTiles(\n    frameState,\n    extent,\n    initialZ,\n    tileRepresentationLookup,\n    preload,\n  ) {\n    const viewState = frameState.viewState;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getRenderSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n    const gutter = tileSource.getGutterForProjection(viewState.projection);\n\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n\n    const wantedTiles = frameState.wantedTiles[tileSourceKey];\n    const tileRepresentationCache = this.tileRepresentationCache;\n\n    const map = tileLayer.getMapInternal();\n    const minZ = Math.max(\n      initialZ - preload,\n      tileGrid.getMinZoom(),\n      tileGrid.getZForResolution(\n        Math.min(\n          tileLayer.getMaxResolution(),\n          map\n            ? map\n                .getView()\n                .getResolutionForZoom(Math.max(tileLayer.getMinZoom(), 0))\n            : tileGrid.getResolution(0),\n        ),\n        tileSource.zDirection,\n      ),\n    );\n    for (let z = initialZ; z >= minZ; --z) {\n      const tileRange = tileGrid.getTileRangeForExtentAndZ(\n        extent,\n        z,\n        this.tempTileRange_,\n      );\n\n      const tileResolution = tileGrid.getResolution(z);\n\n      for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          const tileCoord = createTileCoord(z, x, y, this.tempTileCoord_);\n          const cacheKey = getCacheKey(tileSource, tileCoord);\n\n          /** @type {TileRepresentation} */\n          let tileRepresentation;\n\n          /** @type {TileType} */\n          let tile;\n\n          if (tileRepresentationCache.containsKey(cacheKey)) {\n            tileRepresentation = tileRepresentationCache.get(cacheKey);\n            tile = tileRepresentation.tile;\n          }\n          if (\n            !tileRepresentation ||\n            tileRepresentation.tile.key !== tileSource.getKey()\n          ) {\n            tile = tileSource.getTile(\n              z,\n              x,\n              y,\n              frameState.pixelRatio,\n              viewState.projection,\n            );\n          }\n\n          if (lookupHasTile(tileRepresentationLookup, tile)) {\n            continue;\n          }\n\n          if (!tileRepresentation) {\n            tileRepresentation = this.createTileRepresentation({\n              tile: tile,\n              grid: tileGrid,\n              helper: this.helper,\n              gutter: gutter,\n            });\n            tileRepresentationCache.set(cacheKey, tileRepresentation);\n          } else {\n            if (this.isDrawableTile_(tile)) {\n              tileRepresentation.setTile(tile);\n            } else {\n              const interimTile = /** @type {TileType} */ (\n                tile.getInterimTile()\n              );\n              tileRepresentation.setTile(interimTile);\n            }\n          }\n\n          addTileRepresentationToLookup(\n            tileRepresentationLookup,\n            tileRepresentation,\n            z,\n          );\n\n          const tileQueueKey = tile.getKey();\n          wantedTiles[tileQueueKey] = true;\n\n          if (tile.getState() === TileState.IDLE) {\n            if (!frameState.tileQueue.isKeyQueued(tileQueueKey)) {\n              frameState.tileQueue.enqueue([\n                tile,\n                tileSourceKey,\n                tileGrid.getTileCoordCenter(tileCoord),\n                tileResolution,\n              ]);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {boolean} tilesWithAlpha True if at least one of the rendered tiles has alpha\n   * @protected\n   */\n  beforeTilesRender(frameState, tilesWithAlpha) {\n    this.helper.prepareDraw(this.frameState, !tilesWithAlpha, true);\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} If returns false, tile mask rendering will be skipped\n   * @protected\n   */\n  beforeTilesMaskRender(frameState) {\n    return false;\n  }\n\n  /**\n   * @param {TileRepresentation} tileRepresentation Tile representation\n   * @param {import(\"../../transform.js\").Transform} tileTransform Tile transform\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state\n   * @param {import(\"../../extent.js\").Extent} renderExtent Render extent\n   * @param {number} tileResolution Tile resolution\n   * @param {import(\"../../size.js\").Size} tileSize Tile size\n   * @param {import(\"../../coordinate.js\").Coordinate} tileOrigin Tile origin\n   * @param {import(\"../../extent.js\").Extent} tileExtent tile Extent\n   * @param {number} depth Depth\n   * @param {number} gutter Gutter\n   * @param {number} alpha Alpha\n   * @protected\n   */\n  renderTile(\n    tileRepresentation,\n    tileTransform,\n    frameState,\n    renderExtent,\n    tileResolution,\n    tileSize,\n    tileOrigin,\n    tileExtent,\n    depth,\n    gutter,\n    alpha,\n  ) {}\n\n  /**\n   * @param {TileRepresentation} tileRepresentation Tile representation\n   * @param {number} tileZ Tile Z\n   * @param {import(\"../../extent.js\").Extent} extent Render extent\n   * @param {number} depth Depth\n   * @protected\n   */\n  renderTileMask(tileRepresentation, tileZ, extent, depth) {}\n\n  drawTile_(\n    frameState,\n    tileRepresentation,\n    tileZ,\n    gutter,\n    extent,\n    alphaLookup,\n    tileGrid,\n  ) {\n    if (!tileRepresentation.ready) {\n      return;\n    }\n    const tile = tileRepresentation.tile;\n    const tileCoord = tile.tileCoord;\n    const tileCoordKey = getTileCoordKey(tileCoord);\n    const alpha = tileCoordKey in alphaLookup ? alphaLookup[tileCoordKey] : 1;\n\n    const tileResolution = tileGrid.getResolution(tileZ);\n    const tileSize = toSize(tileGrid.getTileSize(tileZ), this.tempSize_);\n    const tileOrigin = tileGrid.getOrigin(tileZ);\n    const tileExtent = tileGrid.getTileCoordExtent(tileCoord);\n    // tiles with alpha are rendered last to allow blending\n    const depth = alpha < 1 ? -1 : depthForZ(tileZ);\n    if (alpha < 1) {\n      frameState.animate = true;\n    }\n\n    const viewState = frameState.viewState;\n    const centerX = viewState.center[0];\n    const centerY = viewState.center[1];\n\n    const tileWidthWithGutter = tileSize[0] + 2 * gutter;\n    const tileHeightWithGutter = tileSize[1] + 2 * gutter;\n\n    const aspectRatio = tileWidthWithGutter / tileHeightWithGutter;\n\n    const centerI = (centerX - tileOrigin[0]) / (tileSize[0] * tileResolution);\n    const centerJ = (tileOrigin[1] - centerY) / (tileSize[1] * tileResolution);\n\n    const tileScale = viewState.resolution / tileResolution;\n\n    const tileCenterI = tileCoord[1];\n    const tileCenterJ = tileCoord[2];\n\n    resetTransform(this.tileTransform_);\n    scaleTransform(\n      this.tileTransform_,\n      2 / ((frameState.size[0] * tileScale) / tileWidthWithGutter),\n      -2 / ((frameState.size[1] * tileScale) / tileWidthWithGutter),\n    );\n    rotateTransform(this.tileTransform_, viewState.rotation);\n    scaleTransform(this.tileTransform_, 1, 1 / aspectRatio);\n    translateTransform(\n      this.tileTransform_,\n      (tileSize[0] * (tileCenterI - centerI) - gutter) / tileWidthWithGutter,\n      (tileSize[1] * (tileCenterJ - centerJ) - gutter) / tileHeightWithGutter,\n    );\n\n    this.renderTile(\n      /** @type {TileRepresentation} */ (tileRepresentation),\n      this.tileTransform_,\n      frameState,\n      extent,\n      tileResolution,\n      tileSize,\n      tileOrigin,\n      tileExtent,\n      depth,\n      gutter,\n      alpha,\n    );\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState) {\n    this.frameState = frameState;\n    this.renderComplete = true;\n    const gl = this.helper.getGL();\n    this.preRender(gl, frameState);\n\n    const viewState = frameState.viewState;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getRenderSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n    const gutter = tileSource.getGutterForProjection(viewState.projection);\n    const extent = getRenderExtent(frameState, frameState.extent);\n    const z = tileGrid.getZForResolution(\n      viewState.resolution,\n      tileSource.zDirection,\n    );\n\n    /**\n     * @type {TileRepresentationLookup}\n     */\n    const tileRepresentationLookup = newTileRepresentationLookup();\n\n    const preload = tileLayer.getPreload();\n    if (frameState.nextExtent) {\n      const targetZ = tileGrid.getZForResolution(\n        viewState.nextResolution,\n        tileSource.zDirection,\n      );\n      const nextExtent = getRenderExtent(frameState, frameState.nextExtent);\n      this.enqueueTiles(\n        frameState,\n        nextExtent,\n        targetZ,\n        tileRepresentationLookup,\n        preload,\n      );\n    }\n\n    this.enqueueTiles(frameState, extent, z, tileRepresentationLookup, 0);\n    if (preload > 0) {\n      setTimeout(() => {\n        this.enqueueTiles(\n          frameState,\n          extent,\n          z - 1,\n          tileRepresentationLookup,\n          preload - 1,\n        );\n      }, 0);\n    }\n\n    /**\n     * A lookup of alpha values for tiles at the target rendering resolution\n     * for tiles that are in transition.  If a tile coord key is absent from\n     * this lookup, the tile should be rendered at alpha 1.\n     * @type {Object<string, number>}\n     */\n    const alphaLookup = {};\n\n    const uid = getUid(this);\n    const time = frameState.time;\n    let blend = false;\n\n    // look for cached tiles to use if a target tile is not ready\n    for (const tileRepresentation of tileRepresentationLookup\n      .representationsByZ[z]) {\n      const tile = tileRepresentation.tile;\n      if (\n        (tile instanceof ReprojTile || tile instanceof ReprojDataTile) &&\n        tile.getState() === TileState.EMPTY\n      ) {\n        continue;\n      }\n      const tileCoord = tile.tileCoord;\n\n      if (tileRepresentation.ready) {\n        const alpha = tile.getAlpha(uid, time);\n        if (alpha === 1) {\n          // no need to look for alt tiles\n          tile.endTransition(uid);\n          continue;\n        }\n        blend = true;\n        const tileCoordKey = getTileCoordKey(tileCoord);\n        alphaLookup[tileCoordKey] = alpha;\n      }\n      this.renderComplete = false;\n\n      // first look for child tiles (at z + 1)\n      const coveredByChildren = this.findAltTiles_(\n        tileGrid,\n        tileCoord,\n        z + 1,\n        tileRepresentationLookup,\n      );\n\n      if (coveredByChildren) {\n        continue;\n      }\n\n      // next look for parent tiles\n      const minZoom = tileGrid.getMinZoom();\n      for (let parentZ = z - 1; parentZ >= minZoom; --parentZ) {\n        const coveredByParent = this.findAltTiles_(\n          tileGrid,\n          tileCoord,\n          parentZ,\n          tileRepresentationLookup,\n        );\n\n        if (coveredByParent) {\n          break;\n        }\n      }\n    }\n\n    const representationsByZ = tileRepresentationLookup.representationsByZ;\n    const zs = Object.keys(representationsByZ).map(Number).sort(descending);\n\n    const renderTileMask = this.beforeTilesMaskRender(frameState);\n\n    if (renderTileMask) {\n      for (let j = 0, jj = zs.length; j < jj; ++j) {\n        const tileZ = zs[j];\n        for (const tileRepresentation of representationsByZ[tileZ]) {\n          const tileCoord = tileRepresentation.tile.tileCoord;\n          const tileCoordKey = getTileCoordKey(tileCoord);\n          // do not render the tile mask if alpha < 1\n          if (tileCoordKey in alphaLookup) {\n            continue;\n          }\n          const tileExtent = tileGrid.getTileCoordExtent(tileCoord);\n          this.renderTileMask(\n            /** @type {TileRepresentation} */ (tileRepresentation),\n            tileZ,\n            tileExtent,\n            depthForZ(tileZ),\n          );\n        }\n      }\n    }\n\n    this.beforeTilesRender(frameState, blend);\n\n    for (let j = 0, jj = zs.length; j < jj; ++j) {\n      const tileZ = zs[j];\n      for (const tileRepresentation of representationsByZ[tileZ]) {\n        const tileCoord = tileRepresentation.tile.tileCoord;\n        const tileCoordKey = getTileCoordKey(tileCoord);\n        if (tileCoordKey in alphaLookup) {\n          continue;\n        }\n\n        this.drawTile_(\n          frameState,\n          tileRepresentation,\n          tileZ,\n          gutter,\n          extent,\n          alphaLookup,\n          tileGrid,\n        );\n      }\n    }\n\n    for (const tileRepresentation of representationsByZ[z]) {\n      const tileCoord = tileRepresentation.tile.tileCoord;\n      const tileCoordKey = getTileCoordKey(tileCoord);\n      if (tileCoordKey in alphaLookup) {\n        this.drawTile_(\n          frameState,\n          tileRepresentation,\n          z,\n          gutter,\n          extent,\n          alphaLookup,\n          tileGrid,\n        );\n      }\n    }\n\n    this.helper.finalizeDraw(\n      frameState,\n      this.dispatchPreComposeEvent,\n      this.dispatchPostComposeEvent,\n    );\n\n    const canvas = this.helper.getCanvas();\n\n    const tileRepresentationCache = this.tileRepresentationCache;\n    while (tileRepresentationCache.canExpireCache()) {\n      const tileRepresentation = tileRepresentationCache.pop();\n      tileRepresentation.dispose();\n    }\n\n    // TODO: let the renderers manage their own cache instead of managing the source cache\n    /**\n     * Here we unconditionally expire the source cache since the renderer maintains\n     * its own cache.\n     * @param {import(\"../../Map.js\").default} map Map.\n     * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n     */\n    const postRenderFunction = function (map, frameState) {\n      tileSource.updateCacheSize(0.1, frameState.viewState.projection);\n      tileSource.expireCache(frameState.viewState.projection, empty);\n    };\n\n    frameState.postRenderFunctions.push(postRenderFunction);\n\n    this.postRender(gl, frameState);\n    return canvas;\n  }\n\n  /**\n   * Look for tiles covering the provided tile coordinate at an alternate\n   * zoom level.  Loaded tiles will be added to the provided tile representation lookup.\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid The tile grid.\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n   * @param {number} altZ The alternate zoom level.\n   * @param {TileRepresentationLookup} tileRepresentationLookup Lookup of\n   * tile representations by zoom level.\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n   * @private\n   */\n  findAltTiles_(tileGrid, tileCoord, altZ, tileRepresentationLookup) {\n    const tileRange = tileGrid.getTileRangeForTileCoordAndZ(\n      tileCoord,\n      altZ,\n      this.tempTileRange_,\n    );\n\n    if (!tileRange) {\n      return false;\n    }\n\n    let covered = true;\n    const tileRepresentationCache = this.tileRepresentationCache;\n    const source = this.getLayer().getRenderSource();\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        const cacheKey = getCacheKey(source, [altZ, x, y]);\n        let loaded = false;\n        if (tileRepresentationCache.containsKey(cacheKey)) {\n          const tileRepresentation = tileRepresentationCache.get(cacheKey);\n          if (\n            tileRepresentation.ready &&\n            !lookupHasTile(tileRepresentationLookup, tileRepresentation.tile)\n          ) {\n            addTileRepresentationToLookup(\n              tileRepresentationLookup,\n              tileRepresentation,\n              altZ,\n            );\n            loaded = true;\n          }\n        }\n        if (!loaded) {\n          covered = false;\n        }\n      }\n    }\n    return covered;\n  }\n\n  clearCache() {\n    const tileRepresentationCache = this.tileRepresentationCache;\n    tileRepresentationCache.forEach((tileRepresentation) =>\n      tileRepresentation.dispose(),\n    );\n    tileRepresentationCache.clear();\n  }\n\n  removeHelper() {\n    if (this.helper) {\n      this.clearCache();\n    }\n\n    super.removeHelper();\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    super.disposeInternal();\n    delete this.frameState;\n  }\n}\n\nexport default WebGLBaseTileLayerRenderer;\n","/**\n * @module ol/renderer/webgl/TileLayer\n */\nimport ReprojDataTile from '../../reproj/DataTile.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport TileState from '../../TileState.js';\nimport TileTexture from '../../webgl/TileTexture.js';\nimport WebGLArrayBuffer from '../../webgl/Buffer.js';\nimport WebGLBaseTileLayerRenderer, {\n  Uniforms as BaseUniforms,\n  getCacheKey,\n} from './TileLayerBase.js';\nimport {AttributeType} from '../../webgl/Helper.js';\nimport {ELEMENT_ARRAY_BUFFER, STATIC_DRAW} from '../../webgl.js';\nimport {apply as applyTransform} from '../../transform.js';\nimport {\n  boundingExtent,\n  containsCoordinate,\n  getIntersection,\n} from '../../extent.js';\nimport {fromUserExtent} from '../../proj.js';\nimport {fromTransform as mat4FromTransform} from '../../vec/mat4.js';\nimport {toSize} from '../../size.js';\n\nexport const Uniforms = {\n  ...BaseUniforms,\n  TILE_TEXTURE_ARRAY: 'u_tileTextures',\n  TEXTURE_PIXEL_WIDTH: 'u_texturePixelWidth',\n  TEXTURE_PIXEL_HEIGHT: 'u_texturePixelHeight',\n  TEXTURE_RESOLUTION: 'u_textureResolution', // map units per texture pixel\n  TEXTURE_ORIGIN_X: 'u_textureOriginX', // map x coordinate of left edge of texture\n  TEXTURE_ORIGIN_Y: 'u_textureOriginY', // map y coordinate of top edge of texture\n};\n\nexport const Attributes = {\n  TEXTURE_COORD: 'a_textureCoord',\n};\n\n/**\n * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n */\nconst attributeDescriptions = [\n  {\n    name: Attributes.TEXTURE_COORD,\n    size: 2,\n    type: AttributeType.FLOAT,\n  },\n];\n\n/**\n * @typedef {Object} Options\n * @property {string} vertexShader Vertex shader source.\n * @property {string} fragmentShader Fragment shader source.\n * @property {Object<string, import(\"../../webgl/Helper\").UniformValue>} [uniforms] Additional uniforms\n * made available to shaders.\n * @property {Array<import(\"../../webgl/PaletteTexture.js\").default>} [paletteTextures] Palette textures.\n * @property {number} [cacheSize=512] The texture cache size.\n */\n\n/**\n * @typedef {import(\"../../layer/WebGLTile.js\").default} LayerType\n */\n/**\n * @typedef {import(\"../../webgl/TileTexture.js\").TileType} TileTextureType\n */\n/**\n * @typedef {import(\"../../webgl/TileTexture.js\").default} TileTextureRepresentation\n */\n\n/**\n * @classdesc\n * WebGL renderer for tile layers.\n * @extends {WebGLBaseTileLayerRenderer<LayerType, TileTextureType, TileTextureRepresentation>}\n * @api\n */\nclass WebGLTileLayerRenderer extends WebGLBaseTileLayerRenderer {\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   * @param {Options} options Options.\n   */\n  constructor(tileLayer, options) {\n    super(tileLayer, options);\n\n    /**\n     * @type {WebGLProgram}\n     * @private\n     */\n    this.program_;\n\n    /**\n     * @private\n     */\n    this.vertexShader_ = options.vertexShader;\n\n    /**\n     * @private\n     */\n    this.fragmentShader_ = options.fragmentShader;\n\n    /**\n     * Tiles are rendered as a quad with the following structure:\n     *\n     *  [P3]---------[P2]\n     *   |`           |\n     *   |  `     B   |\n     *   |    `       |\n     *   |      `     |\n     *   |   A    `   |\n     *   |          ` |\n     *  [P0]---------[P1]\n     *\n     * Triangle A: P0, P1, P3\n     * Triangle B: P1, P2, P3\n     *\n     * @private\n     */\n    this.indices_ = new WebGLArrayBuffer(ELEMENT_ARRAY_BUFFER, STATIC_DRAW);\n    this.indices_.fromArray([0, 1, 3, 1, 2, 3]);\n\n    /**\n     * @type {Array<import(\"../../webgl/PaletteTexture.js\").default>}\n     * @private\n     */\n    this.paletteTextures_ = options.paletteTextures || [];\n  }\n\n  /**\n   * @param {Options} options Options.\n   */\n  reset(options) {\n    super.reset(options);\n    if (this.helper) {\n      const gl = this.helper.getGL();\n      for (const paletteTexture of this.paletteTextures_) {\n        paletteTexture.delete(gl);\n      }\n    }\n\n    this.vertexShader_ = options.vertexShader;\n    this.fragmentShader_ = options.fragmentShader;\n    this.paletteTextures_ = options.paletteTextures || [];\n\n    if (this.helper) {\n      this.program_ = this.helper.getProgram(\n        this.fragmentShader_,\n        this.vertexShader_,\n      );\n    }\n  }\n\n  afterHelperCreated() {\n    this.program_ = this.helper.getProgram(\n      this.fragmentShader_,\n      this.vertexShader_,\n    );\n    this.helper.flushBufferData(this.indices_);\n  }\n\n  removeHelper() {\n    if (this.helper) {\n      const gl = this.helper.getGL();\n      for (const paletteTexture of this.paletteTextures_) {\n        paletteTexture.delete(gl);\n      }\n    }\n\n    super.removeHelper();\n  }\n\n  createTileRepresentation(options) {\n    return new TileTexture(options);\n  }\n\n  beforeTilesRender(frameState, tilesWithAlpha) {\n    super.beforeTilesRender(frameState, tilesWithAlpha);\n    this.helper.useProgram(this.program_, frameState);\n  }\n\n  renderTile(\n    tileTexture,\n    tileTransform,\n    frameState,\n    renderExtent,\n    tileResolution,\n    tileSize,\n    tileOrigin,\n    tileExtent,\n    depth,\n    gutter,\n    alpha,\n  ) {\n    const gl = this.helper.getGL();\n    this.helper.bindBuffer(tileTexture.coords);\n    this.helper.bindBuffer(this.indices_);\n    this.helper.enableAttributes(attributeDescriptions);\n\n    let textureSlot = 0;\n    while (textureSlot < tileTexture.textures.length) {\n      const uniformName = `${Uniforms.TILE_TEXTURE_ARRAY}[${textureSlot}]`;\n      this.helper.bindTexture(\n        tileTexture.textures[textureSlot],\n        textureSlot,\n        uniformName,\n      );\n      ++textureSlot;\n    }\n\n    for (\n      let paletteIndex = 0;\n      paletteIndex < this.paletteTextures_.length;\n      ++paletteIndex\n    ) {\n      const paletteTexture = this.paletteTextures_[paletteIndex];\n      const texture = paletteTexture.getTexture(gl);\n      this.helper.bindTexture(texture, textureSlot, paletteTexture.name);\n      ++textureSlot;\n    }\n\n    const viewState = frameState.viewState;\n\n    const tileWidthWithGutter = tileSize[0] + 2 * gutter;\n    const tileHeightWithGutter = tileSize[1] + 2 * gutter;\n\n    const tile = tileTexture.tile;\n    const tileCoord = tile.tileCoord;\n\n    const tileCenterI = tileCoord[1];\n    const tileCenterJ = tileCoord[2];\n\n    this.helper.setUniformMatrixValue(\n      Uniforms.TILE_TRANSFORM,\n      mat4FromTransform(this.tempMat4, tileTransform),\n    );\n\n    this.helper.setUniformFloatValue(Uniforms.TRANSITION_ALPHA, alpha);\n    this.helper.setUniformFloatValue(Uniforms.DEPTH, depth);\n\n    let gutterExtent = renderExtent;\n    if (gutter > 0) {\n      gutterExtent = tileExtent;\n      getIntersection(gutterExtent, renderExtent, gutterExtent);\n    }\n    this.helper.setUniformFloatVec4(Uniforms.RENDER_EXTENT, gutterExtent);\n\n    this.helper.setUniformFloatValue(Uniforms.RESOLUTION, viewState.resolution);\n    this.helper.setUniformFloatValue(Uniforms.ZOOM, viewState.zoom);\n\n    this.helper.setUniformFloatValue(\n      Uniforms.TEXTURE_PIXEL_WIDTH,\n      tileWidthWithGutter,\n    );\n    this.helper.setUniformFloatValue(\n      Uniforms.TEXTURE_PIXEL_HEIGHT,\n      tileHeightWithGutter,\n    );\n    this.helper.setUniformFloatValue(\n      Uniforms.TEXTURE_RESOLUTION,\n      tileResolution,\n    );\n    this.helper.setUniformFloatValue(\n      Uniforms.TEXTURE_ORIGIN_X,\n      tileOrigin[0] +\n        tileCenterI * tileSize[0] * tileResolution -\n        gutter * tileResolution,\n    );\n    this.helper.setUniformFloatValue(\n      Uniforms.TEXTURE_ORIGIN_Y,\n      tileOrigin[1] -\n        tileCenterJ * tileSize[1] * tileResolution +\n        gutter * tileResolution,\n    );\n\n    this.helper.drawElements(0, this.indices_.getSize());\n  }\n\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView} Data at the pixel location.\n   */\n  getData(pixel) {\n    const gl = this.helper.getGL();\n    if (!gl) {\n      return null;\n    }\n\n    const frameState = this.frameState;\n    if (!frameState) {\n      return null;\n    }\n\n    const layer = this.getLayer();\n    const coordinate = applyTransform(\n      frameState.pixelToCoordinateTransform,\n      pixel.slice(),\n    );\n\n    const viewState = frameState.viewState;\n    const layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (\n        !containsCoordinate(\n          fromUserExtent(layerExtent, viewState.projection),\n          coordinate,\n        )\n      ) {\n        return null;\n      }\n    }\n\n    // determine last source suitable for rendering at coordinate\n    const sources = layer.getSources(\n      boundingExtent([coordinate]),\n      viewState.resolution,\n    );\n    let i, source, tileGrid;\n    for (i = sources.length - 1; i >= 0; --i) {\n      source = sources[i];\n      if (source.getState() === 'ready') {\n        tileGrid = source.getTileGridForProjection(viewState.projection);\n        if (source.getWrapX()) {\n          break;\n        }\n        const gridExtent = tileGrid.getExtent();\n        if (!gridExtent || containsCoordinate(gridExtent, coordinate)) {\n          break;\n        }\n      }\n    }\n    if (i < 0) {\n      return null;\n    }\n\n    const tileTextureCache = this.tileRepresentationCache;\n    for (\n      let z = tileGrid.getZForResolution(viewState.resolution);\n      z >= tileGrid.getMinZoom();\n      --z\n    ) {\n      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n      const cacheKey = getCacheKey(source, tileCoord);\n      if (!tileTextureCache.containsKey(cacheKey)) {\n        continue;\n      }\n      const tileTexture = tileTextureCache.get(cacheKey);\n      const tile = tileTexture.tile;\n      if (\n        (tile instanceof ReprojTile || tile instanceof ReprojDataTile) &&\n        tile.getState() === TileState.EMPTY\n      ) {\n        return null;\n      }\n      if (!tileTexture.loaded) {\n        continue;\n      }\n      const tileOrigin = tileGrid.getOrigin(z);\n      const tileSize = toSize(tileGrid.getTileSize(z));\n      const tileResolution = tileGrid.getResolution(z);\n\n      const col =\n        (coordinate[0] - tileOrigin[0]) / tileResolution -\n        tileCoord[1] * tileSize[0];\n\n      const row =\n        (tileOrigin[1] - coordinate[1]) / tileResolution -\n        tileCoord[2] * tileSize[1];\n\n      return tileTexture.getPixelData(col, row);\n    }\n    return null;\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    const helper = this.helper;\n    if (helper) {\n      const gl = helper.getGL();\n      for (const paletteTexture of this.paletteTextures_) {\n        paletteTexture.delete(gl);\n      }\n      this.paletteTextures_.length = 0;\n\n      gl.deleteProgram(this.program_);\n      delete this.program_;\n      helper.deleteBuffer(this.indices_);\n    }\n    super.disposeInternal();\n    delete this.indices_;\n  }\n}\n\nexport default WebGLTileLayerRenderer;\n"],"names":["CanvasImageLayerRenderer","constructor","imageLayer","super","this","image_","getImage","prepareFrame","frameState","layerState","layerStatesArray","layerIndex","pixelRatio","viewState","viewResolution","resolution","imageSource","getLayer","getSource","hints","viewHints","renderedExtent","extent","undefined","fromUserExtent","projection","ANIMATING","INTERACTING","image","loadImage","getState","EMPTY","getData","pixel","layer","coordinate","pixelToCoordinateTransform","slice","layerExtent","getExtent","imageExtent","img","imageMapWidth","col","Math","floor","width","imageMapHeight","row","height","getImageData","renderFrame","target","imageResolution","getResolution","imageResolutionX","imageResolutionY","Array","isArray","imagePixelRatio","getPixelRatio","viewCenter","center","scaleX","scaleY","prepareContainer","context","canvas","getRenderContext","clipped","render","clipUnrotated","transform","tempTransform","renderedResolution","dw","dh","getInterpolate","imageSmoothingEnabled","preRender","dx","dy","opacity","save","globalAlpha","drawImage","restore","postRender","container","canvasPool","pixelContext","createPixelContext","willReadFrequently","CanvasLayerRenderer","pixelTransform","inversePixelTransform","deferredContext_","containerReused","pixelContext_","data","clearRect","err","getBackground","background","useContainer","backgroundColor","layerClassName","getClassName","className","style","firstElementChild","HTMLCanvasElement","getContext","document","createElement","position","appendChild","left","transformOrigin","topLeft","topRight","bottomRight","bottomLeft","coordinateToPixelTransform","inverted","beginPath","moveTo","round","lineTo","clip","rotation","size","canvasTransform","dispatchRenderEvent_","type","hasListener","event","dispatchEvent","declutter","PRERENDER","POSTRENDER","renderDeferredInternal","renderDeferred","draw","clear","getRenderTransform","offsetX","dx1","dy1","sx","sy","dx2","dy2","disposeInternal","CanvasTileLayerRenderer","tileLayer","extentChanged","renderedExtent_","renderedPixelRatio","renderedProjection","renderedRevision","renderedTiles","newTiles_","tmpExtent","tmpTileRange_","isDrawableTile","tile","tileState","useInterimTilesOnError","getUseInterimTilesOnError","LOADED","ERROR","getTile","z","x","y","tileSource","getPreload","getInterimTile","source","getRenderSource","tileGrid","getTileGridForProjection","tilePixelRatio","getTilePixelRatio","getZForResolution","getMinZoom","tileCoord","getTileCoordForCoordAndZ","tileOrigin","getOrigin","tileSize","getTileSize","tileResolution","gutter","getGutterForProjection","loadedTileCallback","tiles","zoom","sourceRevision","getRevision","zDirection","canvasExtent","tileRange","getTileRangeForExtentAndZ","tilesToDrawByZ","findLoadedTiles","createLoadedTileFinder","tmpTileRange","viewport","minX","maxX","minY","maxY","tileCoordIntersectsViewport","uid","toString","inTransition","endTransition","includes","getAlpha","time","childTileRange","getTileCoordChildTileRange","covered","forEachTileCoordParentTileRange","canvasScale","length","clips","clipZs","currentClip","zs","Object","keys","map","Number","sort","getOpaque","reverse","i","currentZ","currentTilePixelSize","getTilePixelSize","currentResolution","currentScale","originTileCoord","originTileExtent","getTileCoordExtent","origin","tileGutter","tilesToDraw","tileCoordKey","xIndex","nextX","yIndex","nextY","w","h","transition","contextSaved","ii","push","drawTileImage","unshift","updateUsedTiles","usedTiles","manageTilePyramid","scheduleExpireCache","getTileImage","alpha","alphaChanged","animate","canExpireCache","postRenderFunction","tileSourceKey","expireCache","bind","postRenderFunctions","getKey","preload","tileCallback","wantedTiles","tileQueue","minZoom","tileCount","IDLE","isKeyQueued","enqueue","getTileCoordCenter","useTile","updateCacheSize","CanvasVectorLayerRenderer","vectorLayer","boundHandleStyleImageChange_","handleStyleImageChange_","animatingOrInteracting_","hitDetectionImageData_","clipped_","renderedFeatures_","renderedRevision_","renderedResolution_","NaN","wrappedRenderedExtent_","renderedRotation_","renderedCenter_","renderedProjection_","renderedPixelRatio_","renderedRenderOrder_","renderedFrameDeclutter_","replayGroup_","replayGroupChanged","clipping","targetContext_","opacity_","renderWorlds","executorGroup","declutterable","projectionExtent","vectorSource","getDeclutter","snapToPixel","multiWorld","getWrapX","canWrapX","worldWidth","endWorld","ceil","world","execute","setDrawContext_","resetDrawContext_","renderDeclutter","replayGroup","isEmpty","hasRenderListeners","getFeatures","Promise","resolve","transforms","startX","userProjection","getUserProjection","getStyleFunction","forEachFeatureAtCoordinate","hitTolerance","callback","matches","features","featureCallback","feature","geometry","distanceSq","key","match","splice","lastIndexOf","result","executorGroups","some","all","item","value","handleFontsChanged","getVisible","changed","renderIfReadyAndVisible","animating","interacting","updateWhileAnimating","getUpdateWhileAnimating","updateWhileInteracting","getUpdateWhileInteracting","ready","frameStateExtent","vectorLayerRevision","vectorLayerRenderBuffer","getRenderBuffer","vectorLayerRenderOrder","getRenderOrder","loadExtents","max","loadExtent","userTransform","userExtent","toUserExtent","loadFeatures","toUserResolution","getTransformFromProjections","squaredTolerance","index","styles","styleFunction","dirty","renderFeature","getFeaturesInExtent","replayGroupInstructions","finish","getOverlaps","builderGroup","loading","IMAGE_REPLAYS","VECTOR_REPLAYS","CanvasVectorTileLayerRenderer","renderedLayerRevision_","renderedPixelToCoordinateTransform_","renderedOpacity_","tmpTransform_","tileClipContexts_","prepareTile","state","updateExecutorGroup_","tileImageNeedsRender_","hifi","wantedResolution","Date","now","getRenderMode","renderTileImage_","hasContext","layerRevision","revision","renderOrder","builderState","getReplayState","renderedRenderOrder","sourceTileGrid","getTileGrid","tileExtent","wrappedTileCoord","sourceTiles","getSourceTiles","layerUid","hitDetectionImageData","t","tt","sourceTile","sourceTileCoord","sourceTileExtent","sharedExtent","builderExtent","bufferedExtent","getGeometry","call","executorGroupInstructions","replayExtent","renderingReplayGroup","hitExtent","getId","found","declutteredFeatures","reject","getTileCoordForCoordAndResolution","loadingSourceTiles","corner","tilePixel","reduce","accumulator","concat","j","getTileRenderTransform","acc","forEach","executorGroupZIndexContexts","getDeferredZIndexContexts","usedZIndices","executorGroupZindexContext","zIndexKeys","zIndex","zIndexContexts","zIndexContext","getRenderedContext","tileClipContext","worldOffset","renderMode","replayTypes","filter","tileClipContexts","group","hasExecutors","getClipCoords","clipContext","jj","replayState","renderedTileResolution","renderedTileRevision","renderPixelRatio","renderScale","setTransform","apply","pixelScale","SIMPLIFY_TOLERANCE","GEOMETRY_RENDERERS","renderPointGeometry","renderLineStringGeometry","renderPolygonGeometry","renderMultiPointGeometry","renderMultiLineStringGeometry","renderMultiPolygonGeometry","renderGeometryCollectionGeometry","renderCircleGeometry","defaultOrder","feature1","feature2","parseInt","getSquaredTolerance","tolerance","getTolerance","fillStyle","getFill","strokeStyle","getStroke","circleReplay","getBuilder","getZIndex","setFillStrokeStyle","drawCircle","textStyle","getText","textReplay","setTextStyle","drawText","listener","loadingPromises","imageStyle","imageState","getImageState","load","then","renderFeatureInternal","getGeometryFunction","simplifiedGeometry","simplifyTransformed","renderer","getRenderer","renderGeometry","geometryRenderer","getType","geometries","getGeometries","replay","drawCustom","getHitDetectionRenderer","declutterBuilderGroup","getGeometriesArray","lineStringReplay","drawLineString","drawMultiLineString","polygonReplay","drawMultiPolygon","hasText","declutterImageWithText","imageReplay","setImageStyle","drawPoint","hasImage","getOpacity","drawMultiPoint","drawPolygon","WebGLLayerRenderer","options","inversePixelTransform_","postProcesses_","postProcesses","uniforms_","uniforms","helper","addChangeListener","MAP","removeHelper","dispatchPreComposeEvent","dispatchPostComposeEvent","PRECOMPOSE","POSTCOMPOSE","reset","setUniforms","dispose","incrementGroup","groupNumber","canvasCacheKey","mapId","canvasCacheKeyMatches","needsToBeRecreated","getCanvas","afterHelperCreated","prepareFrameInternal","getWorldParameters","startWorld","WebGLPointsLayerRenderer","projectionMatrixTransform","PROJECTION_MATRIX","sourceRevision_","verticesBuffer_","indicesBuffer_","vertexShader_","vertexShader","fragmentShader_","fragmentShader","program_","hitDetectionEnabled_","hitDetectionEnabled","customAttributes","attributes","attribute","name","FLOAT","previousExtent_","currentTransform_","renderTransform_","invertRenderTransform_","renderInstructions_","Float32Array","hitRenderTarget_","lastSentId","worker_","addEventListener","received","GENERATE_POINT_BUFFERS","projectionTransform","fromArrayBuffer","vertexBuffer","flushBufferData","indexBuffer","renderInstructions","id","featureCache_","featureCount_","sourceListenKeys_","VectorEventType","ADDFEATURE","handleSourceFeatureAdded_","CHANGEFEATURE","handleSourceFeatureChanged_","REMOVEFEATURE","handleSourceFeatureDelete_","CLEAR","handleSourceFeatureClear_","forEachFeature","properties","getProperties","getProgram","gl","getGL","finalizeDraw","clearCachedData","viewNotMoving","ViewHint","sourceChanged","renderBuffer","BaseVector","rebuildBuffers_","useProgram","prepareDraw","bindBuffer","enableAttributes","makeProjectionTransform","baseInstructionLength","singleInstructionLength","totalSize","featureCache","tmpCoords","tmpColor","idx","featureUid","userCoords","fromUserCoordinate","getFlatCoordinates","hitColor","message","buffer","customAttributesSize","postMessage","readPixel","color","getFeatureByUid","forHitDetection","setSize","prepareDrawToRenderTarget","applyUniforms","applyHitDetectionUniform","renderCount","getSize","drawElements","terminate","layer_","Uniforms","TILE_TRANSFORM","TRANSITION_ALPHA","DEPTH","RENDER_EXTENT","PATTERN_ORIGIN","RESOLUTION","ZOOM","GLOBAL_ALPHA","SCREEN_TO_WORLD_MATRIX","empty","depthForZ","newTileRepresentationLookup","tileIds","Set","representationsByZ","lookupHasTile","tileRepresentationLookup","has","addTileRepresentationToLookup","tileRepresentation","add","getRenderExtent","gridExtent","getCacheKey","WebGLBaseTileLayerRenderer","renderComplete","tileTransform_","tempMat4","tempTileRange_","TileRange","tempTileCoord_","tempSize_","cacheSize","tileRepresentationCache","LRUCache","projection_","isDrawableTile_","TileState","clearCache","createTileRepresentation","enqueueTiles","initialZ","getMapInternal","minZ","min","getMaxResolution","getView","getResolutionForZoom","cacheKey","containsKey","get","setTile","interimTile","grid","set","tileQueueKey","beforeTilesRender","tilesWithAlpha","beforeTilesMaskRender","renderTile","tileTransform","renderExtent","depth","renderTileMask","tileZ","drawTile_","alphaLookup","centerX","centerY","tileWidthWithGutter","tileHeightWithGutter","aspectRatio","centerI","centerJ","tileScale","tileCenterI","tileCenterJ","nextExtent","targetZ","nextResolution","setTimeout","blend","coveredByChildren","findAltTiles_","parentZ","coveredByParent","pop","altZ","getTileRangeForTileCoordAndZ","loaded","TILE_TEXTURE_ARRAY","TEXTURE_PIXEL_WIDTH","TEXTURE_PIXEL_HEIGHT","TEXTURE_RESOLUTION","TEXTURE_ORIGIN_X","TEXTURE_ORIGIN_Y","Attributes","TEXTURE_COORD","attributeDescriptions","WebGLTileLayerRenderer","indices_","fromArray","paletteTextures_","paletteTextures","paletteTexture","delete","TileTexture","tileTexture","coords","textureSlot","textures","uniformName","bindTexture","paletteIndex","texture","getTexture","setUniformMatrixValue","mat4","setUniformFloatValue","gutterExtent","setUniformFloatVec4","sources","getSources","tileTextureCache","getPixelData","deleteProgram","deleteBuffer"],"sourceRoot":""}
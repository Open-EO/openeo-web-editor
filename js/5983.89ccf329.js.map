{"version":3,"file":"js/5983.89ccf329.js","mappings":"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","sources":["webpack://@openeo/web-editor/./node_modules/ol/ViewProperty.js","webpack://@openeo/web-editor/./node_modules/ol/View.js","webpack://@openeo/web-editor/./node_modules/ol/Tile.js","webpack://@openeo/web-editor/./node_modules/ol/TileState.js","webpack://@openeo/web-editor/./node_modules/ol/Observable.js","webpack://@openeo/web-editor/./node_modules/ol/ObjectEventType.js","webpack://@openeo/web-editor/./node_modules/ol/Object.js","webpack://@openeo/web-editor/./node_modules/ol/ViewHint.js","webpack://@openeo/web-editor/./node_modules/ol/TileQueue.js","webpack://@openeo/web-editor/./node_modules/ol/Map.js","webpack://@openeo/web-editor/./node_modules/ol/TileCache.js","webpack://@openeo/web-editor/./node_modules/ol/TileRange.js"],"sourcesContent":["/**\n * @module ol/ViewProperty\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  CENTER: 'center',\n  RESOLUTION: 'resolution',\n  ROTATION: 'rotation',\n};\n","/**\n * @module ol/View\n */\nimport BaseObject from './Object.js';\nimport ViewHint from './ViewHint.js';\nimport ViewProperty from './ViewProperty.js';\nimport {DEFAULT_TILE_SIZE} from './tilegrid/common.js';\nimport {\n  METERS_PER_UNIT,\n  createProjection,\n  disableCoordinateWarning,\n  fromUserCoordinate,\n  fromUserExtent,\n  getUserProjection,\n  toUserCoordinate,\n  toUserExtent,\n} from './proj.js';\nimport {VOID} from './functions.js';\nimport {\n  add as addCoordinate,\n  equals as coordinatesEqual,\n  equals,\n  rotate as rotateCoordinate,\n} from './coordinate.js';\nimport {assert} from './asserts.js';\nimport {none as centerNone, createExtent} from './centerconstraint.js';\nimport {clamp, modulo} from './math.js';\nimport {\n  createMinMaxResolution,\n  createSnapToPower,\n  createSnapToResolutions,\n} from './resolutionconstraint.js';\nimport {\n  createSnapToN,\n  createSnapToZero,\n  disable,\n  none as rotationNone,\n} from './rotationconstraint.js';\nimport {easeOut, inAndOut} from './easing.js';\nimport {\n  getCenter,\n  getForViewAndSize,\n  getHeight,\n  getWidth,\n  isEmpty,\n} from './extent.js';\nimport {linearFindNearest} from './array.js';\nimport {fromExtent as polygonFromExtent} from './geom/Polygon.js';\n\n/**\n * An animation configuration\n *\n * @typedef {Object} Animation\n * @property {import(\"./coordinate.js\").Coordinate} [sourceCenter] Source center.\n * @property {import(\"./coordinate.js\").Coordinate} [targetCenter] Target center.\n * @property {number} [sourceResolution] Source resolution.\n * @property {number} [targetResolution] Target resolution.\n * @property {number} [sourceRotation] Source rotation.\n * @property {number} [targetRotation] Target rotation.\n * @property {import(\"./coordinate.js\").Coordinate} [anchor] Anchor.\n * @property {number} start Start.\n * @property {number} duration Duration.\n * @property {boolean} complete Complete.\n * @property {function(number):number} easing Easing.\n * @property {function(boolean):void} callback Callback.\n */\n\n/**\n * @typedef {Object} Constraints\n * @property {import(\"./centerconstraint.js\").Type} center Center.\n * @property {import(\"./resolutionconstraint.js\").Type} resolution Resolution.\n * @property {import(\"./rotationconstraint.js\").Type} rotation Rotation.\n */\n\n/**\n * @typedef {Object} FitOptions\n * @property {import(\"./size.js\").Size} [size] The size in pixels of the box to\n * fit the extent into. Defaults to the size of the map the view is associated with.\n * If no map or multiple maps are connected to the view, provide the desired box size\n * (e.g. `map.getSize()`).\n * @property {!Array<number>} [padding=[0, 0, 0, 0]] Padding (in pixels) to be\n * cleared inside the view. Values in the array are top, right, bottom and left\n * padding.\n * @property {boolean} [nearest=false] If the view `constrainResolution` option is `true`,\n * get the nearest extent instead of the closest that actually fits the view.\n * @property {number} [minResolution=0] Minimum resolution that we zoom to.\n * @property {number} [maxZoom] Maximum zoom level that we zoom to. If\n * `minResolution` is given, this property is ignored.\n * @property {number} [duration] The duration of the animation in milliseconds.\n * By default, there is no animation to the target extent.\n * @property {function(number):number} [easing] The easing function used during\n * the animation (defaults to {@link module:ol/easing.inAndOut}).\n * The function will be called for each frame with a number representing a\n * fraction of the animation's duration.  The function should return a number\n * between 0 and 1 representing the progress toward the destination state.\n * @property {function(boolean):void} [callback] Function called when the view is in\n * its final position. The callback will be called with `true` if the animation\n * series completed on its own or `false` if it was cancelled.\n */\n\n/**\n * @typedef {Object} ViewOptions\n * @property {import(\"./coordinate.js\").Coordinate} [center] The initial center for\n * the view. If a user projection is not set, the coordinate system for the center is\n * specified with the `projection` option. Layer sources will not be fetched if this\n * is not set, but the center can be set later with {@link #setCenter}.\n * @property {boolean|number} [constrainRotation=true] Rotation constraint.\n * `false` means no constraint. `true` means no constraint, but snap to zero\n * near zero. A number constrains the rotation to that number of values. For\n * example, `4` will constrain the rotation to 0, 90, 180, and 270 degrees.\n * @property {boolean} [enableRotation=true] Enable rotation.\n * If `false`, a rotation constraint that always sets the rotation to zero is\n * used. The `constrainRotation` option has no effect if `enableRotation` is\n * `false`.\n * @property {import(\"./extent.js\").Extent} [extent] The extent that constrains the\n * view, in other words, nothing outside of this extent can be visible on the map.\n * @property {boolean} [constrainOnlyCenter=false] If true, the extent\n * constraint will only apply to the view center and not the whole extent.\n * @property {boolean} [smoothExtentConstraint=true] If true, the extent\n * constraint will be applied smoothly, i.e. allow the view to go slightly outside\n * of the given `extent`.\n * @property {number} [maxResolution] The maximum resolution used to determine\n * the resolution constraint. It is used together with `minResolution` (or\n * `maxZoom`) and `zoomFactor`. If unspecified it is calculated in such a way\n * that the projection's validity extent fits in a 256x256 px tile. If the\n * projection is Spherical Mercator (the default) then `maxResolution` defaults\n * to `40075016.68557849 / 256 = 156543.03392804097`.\n * @property {number} [minResolution] The minimum resolution used to determine\n * the resolution constraint.  It is used together with `maxResolution` (or\n * `minZoom`) and `zoomFactor`.  If unspecified it is calculated assuming 29\n * zoom levels (with a factor of 2). If the projection is Spherical Mercator\n * (the default) then `minResolution` defaults to\n * `40075016.68557849 / 256 / Math.pow(2, 28) = 0.0005831682455839253`.\n * @property {number} [maxZoom=28] The maximum zoom level used to determine the\n * resolution constraint. It is used together with `minZoom` (or\n * `maxResolution`) and `zoomFactor`.  Note that if `minResolution` is also\n * provided, it is given precedence over `maxZoom`.\n * @property {number} [minZoom=0] The minimum zoom level used to determine the\n * resolution constraint. It is used together with `maxZoom` (or\n * `minResolution`) and `zoomFactor`.  Note that if `maxResolution` is also\n * provided, it is given precedence over `minZoom`.\n * @property {boolean} [multiWorld=false] If `false` the view is constrained so\n * only one world is visible, and you cannot pan off the edge.  If `true` the map\n * may show multiple worlds at low zoom levels.  Only used if the `projection` is\n * global.  Note that if `extent` is also provided it is given precedence.\n * @property {boolean} [constrainResolution=false] If true, the view will always\n * animate to the closest zoom level after an interaction; false means\n * intermediary zoom levels are allowed.\n * @property {boolean} [smoothResolutionConstraint=true] If true, the resolution\n * min/max values will be applied smoothly, i. e. allow the view to exceed slightly\n * the given resolution or zoom bounds.\n * @property {boolean} [showFullExtent=false] Allow the view to be zoomed out to\n * show the full configured extent. By default, when a view is configured with an\n * extent, users will not be able to zoom out so the viewport exceeds the extent in\n * either dimension. This means the full extent may not be visible if the viewport\n * is taller or wider than the aspect ratio of the configured extent. If\n * showFullExtent is true, the user will be able to zoom out so that the viewport\n * exceeds the height or width of the configured extent, but not both, allowing the\n * full extent to be shown.\n * @property {import(\"./proj.js\").ProjectionLike} [projection='EPSG:3857'] The\n * projection. The default is Spherical Mercator.\n * @property {number} [resolution] The initial resolution for the view. The\n * units are `projection` units per pixel (e.g. meters per pixel). An\n * alternative to setting this is to set `zoom`. Layer sources will not be\n * fetched if neither this nor `zoom` are defined, but they can be set later\n * with {@link #setZoom} or {@link #setResolution}.\n * @property {Array<number>} [resolutions] Resolutions that determine the\n * zoom levels if specified. The index in the array corresponds to the zoom level,\n * therefore the resolution values have to be in descending order. It also constrains\n * the resolution by the minimum and maximum value. If set the `maxResolution`,\n * `minResolution`, `minZoom`, `maxZoom`, and `zoomFactor` options are ignored.\n * @property {number} [rotation=0] The initial rotation for the view in radians\n * (positive rotation clockwise, 0 means North).\n * @property {number} [zoom] Only used if `resolution` is not defined. Zoom\n * level used to calculate the initial resolution for the view.\n * @property {number} [zoomFactor=2] The zoom factor used to compute the\n * corresponding resolution.\n * @property {!Array<number>} [padding=[0, 0, 0, 0]] Padding (in css pixels).\n * If the map viewport is partially covered with other content (overlays) along\n * its edges, this setting allows to shift the center of the viewport away from\n * that content. The order of the values is top, right, bottom, left.\n */\n\n/**\n * @typedef {Object} AnimationOptions\n * @property {import(\"./coordinate.js\").Coordinate} [center] The center of the view at the end of\n * the animation.\n * @property {number} [zoom] The zoom level of the view at the end of the\n * animation. This takes precedence over `resolution`.\n * @property {number} [resolution] The resolution of the view at the end\n * of the animation.  If `zoom` is also provided, this option will be ignored.\n * @property {number} [rotation] The rotation of the view at the end of\n * the animation.\n * @property {import(\"./coordinate.js\").Coordinate} [anchor] Optional anchor to remain fixed\n * during a rotation or resolution animation.\n * @property {number} [duration=1000] The duration of the animation in milliseconds.\n * @property {function(number):number} [easing] The easing function used\n * during the animation (defaults to {@link module:ol/easing.inAndOut}).\n * The function will be called for each frame with a number representing a\n * fraction of the animation's duration.  The function should return a number\n * between 0 and 1 representing the progress toward the destination state.\n */\n\n/**\n * @typedef {Object} State\n * @property {import(\"./coordinate.js\").Coordinate} center Center (in view projection coordinates).\n * @property {import(\"./proj/Projection.js\").default} projection Projection.\n * @property {number} resolution Resolution.\n * @property {import(\"./coordinate.js\").Coordinate} [nextCenter] The next center during an animation series.\n * @property {number} [nextResolution] The next resolution during an animation series.\n * @property {number} [nextRotation] The next rotation during an animation series.\n * @property {number} rotation Rotation.\n * @property {number} zoom Zoom.\n */\n\n/**\n * Like {@link import(\"./Map.js\").FrameState}, but just `viewState` and `extent`.\n * @typedef {Object} ViewStateLayerStateExtent\n * @property {State} viewState View state.\n * @property {import(\"./extent.js\").Extent} extent Extent (in user projection coordinates).\n * @property {Array<import(\"./layer/Layer.js\").State>} [layerStatesArray] Layer states.\n */\n\n/**\n * Default min zoom level for the map view.\n * @type {number}\n */\nconst DEFAULT_MIN_ZOOM = 0;\n\n/**\n * @typedef {import(\"./ObjectEventType\").Types|'change:center'|'change:resolution'|'change:rotation'} ViewObjectEventTypes\n */\n\n/***\n * @template Return\n * @typedef {import(\"./Observable\").OnSignature<import(\"./Observable\").EventTypes, import(\"./events/Event.js\").default, Return> &\n *   import(\"./Observable\").OnSignature<ViewObjectEventTypes, import(\"./Object\").ObjectEvent, Return> &\n *   import(\"./Observable\").CombinedOnSignature<import(\"./Observable\").EventTypes|ViewObjectEventTypes, Return>} ViewOnSignature\n */\n\n/**\n * @classdesc\n * A View object represents a simple 2D view of the map.\n *\n * This is the object to act upon to change the center, resolution,\n * and rotation of the map.\n *\n * A View has a `projection`. The projection determines the\n * coordinate system of the center, and its units determine the units of the\n * resolution (projection units per pixel). The default projection is\n * Web Mercator (EPSG:3857).\n *\n * ### The view states\n *\n * A View is determined by three states: `center`, `resolution`,\n * and `rotation`. Each state has a corresponding getter and setter, e.g.\n * `getCenter` and `setCenter` for the `center` state.\n *\n * The `zoom` state is actually not saved on the view: all computations\n * internally use the `resolution` state. Still, the `setZoom` and `getZoom`\n * methods are available, as well as `getResolutionForZoom` and\n * `getZoomForResolution` to switch from one system to the other.\n *\n * ### The constraints\n *\n * `setCenter`, `setResolution` and `setRotation` can be used to change the\n * states of the view, but any constraint defined in the constructor will\n * be applied along the way.\n *\n * A View object can have a *resolution constraint*, a *rotation constraint*\n * and a *center constraint*.\n *\n * The *resolution constraint* typically restricts min/max values and\n * snaps to specific resolutions. It is determined by the following\n * options: `resolutions`, `maxResolution`, `maxZoom` and `zoomFactor`.\n * If `resolutions` is set, the other three options are ignored. See\n * documentation for each option for more information. By default, the view\n * only has a min/max restriction and allow intermediary zoom levels when\n * pinch-zooming for example.\n *\n * The *rotation constraint* snaps to specific angles. It is determined\n * by the following options: `enableRotation` and `constrainRotation`.\n * By default rotation is allowed and its value is snapped to zero when approaching the\n * horizontal.\n *\n * The *center constraint* is determined by the `extent` option. By\n * default the view center is not constrained at all.\n *\n * ### Changing the view state\n *\n * It is important to note that `setZoom`, `setResolution`, `setCenter` and\n * `setRotation` are subject to the above mentioned constraints. As such, it\n * may sometimes not be possible to know in advance the resulting state of the\n * View. For example, calling `setResolution(10)` does not guarantee that\n * `getResolution()` will return `10`.\n *\n * A consequence of this is that, when applying a delta on the view state, one\n * should use `adjustCenter`, `adjustRotation`, `adjustZoom` and `adjustResolution`\n * rather than the corresponding setters. This will let view do its internal\n * computations. Besides, the `adjust*` methods also take an `anchor`\n * argument which allows specifying an origin for the transformation.\n *\n * ### Interacting with the view\n *\n * View constraints are usually only applied when the view is *at rest*, meaning that\n * no interaction or animation is ongoing. As such, if the user puts the view in a\n * state that is not equivalent to a constrained one (e.g. rotating the view when\n * the snap angle is 0), an animation will be triggered at the interaction end to\n * put back the view to a stable state;\n *\n * @api\n */\nclass View extends BaseObject {\n  /**\n   * @param {ViewOptions} [options] View options.\n   */\n  constructor(options) {\n    super();\n\n    /***\n     * @type {ViewOnSignature<import(\"./events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {ViewOnSignature<import(\"./events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {ViewOnSignature<void>}\n     */\n    this.un;\n\n    options = Object.assign({}, options);\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.hints_ = [0, 0];\n\n    /**\n     * @private\n     * @type {Array<Array<Animation>>}\n     */\n    this.animations_ = [];\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.updateAnimationKey_;\n\n    /**\n     * @private\n     * @const\n     * @type {import(\"./proj/Projection.js\").default}\n     */\n    this.projection_ = createProjection(options.projection, 'EPSG:3857');\n\n    /**\n     * @private\n     * @type {import(\"./size.js\").Size}\n     */\n    this.viewportSize_ = [100, 100];\n\n    /**\n     * @private\n     * @type {import(\"./coordinate.js\").Coordinate|undefined}\n     */\n    this.targetCenter_ = null;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.targetResolution_;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.targetRotation_;\n\n    /**\n     * @private\n     * @type {import(\"./coordinate.js\").Coordinate}\n     */\n    this.nextCenter_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.nextResolution_;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.nextRotation_;\n\n    /**\n     * @private\n     * @type {import(\"./coordinate.js\").Coordinate|undefined}\n     */\n    this.cancelAnchor_ = undefined;\n\n    if (options.projection) {\n      disableCoordinateWarning();\n    }\n    if (options.center) {\n      options.center = fromUserCoordinate(options.center, this.projection_);\n    }\n    if (options.extent) {\n      options.extent = fromUserExtent(options.extent, this.projection_);\n    }\n\n    this.applyOptions_(options);\n  }\n\n  /**\n   * Set up the view with the given options.\n   * @param {ViewOptions} options View options.\n   */\n  applyOptions_(options) {\n    const properties = Object.assign({}, options);\n    for (const key in ViewProperty) {\n      delete properties[key];\n    }\n    this.setProperties(properties, true);\n\n    const resolutionConstraintInfo = createResolutionConstraint(options);\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxResolution_ = resolutionConstraintInfo.maxResolution;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.minResolution_ = resolutionConstraintInfo.minResolution;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;\n\n    /**\n     * @private\n     * @type {Array<number>|undefined}\n     */\n    this.resolutions_ = options.resolutions;\n\n    /**\n     * @type {Array<number>|undefined}\n     * @private\n     */\n    this.padding_ = options.padding;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.minZoom_ = resolutionConstraintInfo.minZoom;\n\n    const centerConstraint = createCenterConstraint(options);\n    const resolutionConstraint = resolutionConstraintInfo.constraint;\n    const rotationConstraint = createRotationConstraint(options);\n\n    /**\n     * @private\n     * @type {Constraints}\n     */\n    this.constraints_ = {\n      center: centerConstraint,\n      resolution: resolutionConstraint,\n      rotation: rotationConstraint,\n    };\n\n    this.setRotation(options.rotation !== undefined ? options.rotation : 0);\n    this.setCenterInternal(\n      options.center !== undefined ? options.center : null,\n    );\n    if (options.resolution !== undefined) {\n      this.setResolution(options.resolution);\n    } else if (options.zoom !== undefined) {\n      this.setZoom(options.zoom);\n    }\n  }\n\n  /**\n   * Padding (in css pixels).\n   * If the map viewport is partially covered with other content (overlays) along\n   * its edges, this setting allows to shift the center of the viewport away from that\n   * content. The order of the values in the array is top, right, bottom, left.\n   * The default is no padding, which is equivalent to `[0, 0, 0, 0]`.\n   * @type {Array<number>|undefined}\n   * @api\n   */\n  get padding() {\n    return this.padding_;\n  }\n  set padding(padding) {\n    let oldPadding = this.padding_;\n    this.padding_ = padding;\n    const center = this.getCenterInternal();\n    if (center) {\n      const newPadding = padding || [0, 0, 0, 0];\n      oldPadding = oldPadding || [0, 0, 0, 0];\n      const resolution = this.getResolution();\n      const offsetX =\n        (resolution / 2) *\n        (newPadding[3] - oldPadding[3] + oldPadding[1] - newPadding[1]);\n      const offsetY =\n        (resolution / 2) *\n        (newPadding[0] - oldPadding[0] + oldPadding[2] - newPadding[2]);\n      this.setCenterInternal([center[0] + offsetX, center[1] - offsetY]);\n    }\n  }\n\n  /**\n   * Get an updated version of the view options used to construct the view.  The\n   * current resolution (or zoom), center, and rotation are applied to any stored\n   * options.  The provided options can be used to apply new min/max zoom or\n   * resolution limits.\n   * @param {ViewOptions} newOptions New options to be applied.\n   * @return {ViewOptions} New options updated with the current view state.\n   */\n  getUpdatedOptions_(newOptions) {\n    const options = this.getProperties();\n\n    // preserve resolution (or zoom)\n    if (options.resolution !== undefined) {\n      options.resolution = this.getResolution();\n    } else {\n      options.zoom = this.getZoom();\n    }\n\n    // preserve center\n    options.center = this.getCenterInternal();\n\n    // preserve rotation\n    options.rotation = this.getRotation();\n\n    return Object.assign({}, options, newOptions);\n  }\n\n  /**\n   * Animate the view.  The view's center, zoom (or resolution), and rotation\n   * can be animated for smooth transitions between view states.  For example,\n   * to animate the view to a new zoom level:\n   *\n   *     view.animate({zoom: view.getZoom() + 1});\n   *\n   * By default, the animation lasts one second and uses in-and-out easing.  You\n   * can customize this behavior by including `duration` (in milliseconds) and\n   * `easing` options (see {@link module:ol/easing}).\n   *\n   * To chain together multiple animations, call the method with multiple\n   * animation objects.  For example, to first zoom and then pan:\n   *\n   *     view.animate({zoom: 10}, {center: [0, 0]});\n   *\n   * If you provide a function as the last argument to the animate method, it\n   * will get called at the end of an animation series.  The callback will be\n   * called with `true` if the animation series completed on its own or `false`\n   * if it was cancelled.\n   *\n   * Animations are cancelled by user interactions (e.g. dragging the map) or by\n   * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`\n   * (or another method that calls one of these).\n   *\n   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation\n   *     options.  Multiple animations can be run in series by passing multiple\n   *     options objects.  To run multiple animations in parallel, call the method\n   *     multiple times.  An optional callback can be provided as a final\n   *     argument.  The callback will be called with a boolean indicating whether\n   *     the animation completed without being cancelled.\n   * @api\n   */\n  animate(var_args) {\n    if (this.isDef() && !this.getAnimating()) {\n      this.resolveConstraints(0);\n    }\n    const args = new Array(arguments.length);\n    for (let i = 0; i < args.length; ++i) {\n      let options = arguments[i];\n      if (options.center) {\n        options = Object.assign({}, options);\n        options.center = fromUserCoordinate(\n          options.center,\n          this.getProjection(),\n        );\n      }\n      if (options.anchor) {\n        options = Object.assign({}, options);\n        options.anchor = fromUserCoordinate(\n          options.anchor,\n          this.getProjection(),\n        );\n      }\n      args[i] = options;\n    }\n    this.animateInternal.apply(this, args);\n  }\n\n  /**\n   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation options.\n   */\n  animateInternal(var_args) {\n    let animationCount = arguments.length;\n    let callback;\n    if (\n      animationCount > 1 &&\n      typeof arguments[animationCount - 1] === 'function'\n    ) {\n      callback = arguments[animationCount - 1];\n      --animationCount;\n    }\n\n    let i = 0;\n    for (; i < animationCount && !this.isDef(); ++i) {\n      // if view properties are not yet set, shortcut to the final state\n      const state = arguments[i];\n      if (state.center) {\n        this.setCenterInternal(state.center);\n      }\n      if (state.zoom !== undefined) {\n        this.setZoom(state.zoom);\n      } else if (state.resolution) {\n        this.setResolution(state.resolution);\n      }\n      if (state.rotation !== undefined) {\n        this.setRotation(state.rotation);\n      }\n    }\n    if (i === animationCount) {\n      if (callback) {\n        animationCallback(callback, true);\n      }\n      return;\n    }\n\n    let start = Date.now();\n    let center = this.targetCenter_.slice();\n    let resolution = this.targetResolution_;\n    let rotation = this.targetRotation_;\n    const series = [];\n    for (; i < animationCount; ++i) {\n      const options = /** @type {AnimationOptions} */ (arguments[i]);\n\n      const animation = {\n        start: start,\n        complete: false,\n        anchor: options.anchor,\n        duration: options.duration !== undefined ? options.duration : 1000,\n        easing: options.easing || inAndOut,\n        callback: callback,\n      };\n\n      if (options.center) {\n        animation.sourceCenter = center;\n        animation.targetCenter = options.center.slice();\n        center = animation.targetCenter;\n      }\n\n      if (options.zoom !== undefined) {\n        animation.sourceResolution = resolution;\n        animation.targetResolution = this.getResolutionForZoom(options.zoom);\n        resolution = animation.targetResolution;\n      } else if (options.resolution) {\n        animation.sourceResolution = resolution;\n        animation.targetResolution = options.resolution;\n        resolution = animation.targetResolution;\n      }\n\n      if (options.rotation !== undefined) {\n        animation.sourceRotation = rotation;\n        const delta =\n          modulo(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;\n        animation.targetRotation = rotation + delta;\n        rotation = animation.targetRotation;\n      }\n\n      // check if animation is a no-op\n      if (isNoopAnimation(animation)) {\n        animation.complete = true;\n        // we still push it onto the series for callback handling\n      } else {\n        start += animation.duration;\n      }\n      series.push(animation);\n    }\n    this.animations_.push(series);\n    this.setHint(ViewHint.ANIMATING, 1);\n    this.updateAnimations_();\n  }\n\n  /**\n   * Determine if the view is being animated.\n   * @return {boolean} The view is being animated.\n   * @api\n   */\n  getAnimating() {\n    return this.hints_[ViewHint.ANIMATING] > 0;\n  }\n\n  /**\n   * Determine if the user is interacting with the view, such as panning or zooming.\n   * @return {boolean} The view is being interacted with.\n   * @api\n   */\n  getInteracting() {\n    return this.hints_[ViewHint.INTERACTING] > 0;\n  }\n\n  /**\n   * Cancel any ongoing animations.\n   * @api\n   */\n  cancelAnimations() {\n    this.setHint(ViewHint.ANIMATING, -this.hints_[ViewHint.ANIMATING]);\n    let anchor;\n    for (let i = 0, ii = this.animations_.length; i < ii; ++i) {\n      const series = this.animations_[i];\n      if (series[0].callback) {\n        animationCallback(series[0].callback, false);\n      }\n      if (!anchor) {\n        for (let j = 0, jj = series.length; j < jj; ++j) {\n          const animation = series[j];\n          if (!animation.complete) {\n            anchor = animation.anchor;\n            break;\n          }\n        }\n      }\n    }\n    this.animations_.length = 0;\n    this.cancelAnchor_ = anchor;\n    this.nextCenter_ = null;\n    this.nextResolution_ = NaN;\n    this.nextRotation_ = NaN;\n  }\n\n  /**\n   * Update all animations.\n   */\n  updateAnimations_() {\n    if (this.updateAnimationKey_ !== undefined) {\n      cancelAnimationFrame(this.updateAnimationKey_);\n      this.updateAnimationKey_ = undefined;\n    }\n    if (!this.getAnimating()) {\n      return;\n    }\n    const now = Date.now();\n    let more = false;\n    for (let i = this.animations_.length - 1; i >= 0; --i) {\n      const series = this.animations_[i];\n      let seriesComplete = true;\n      for (let j = 0, jj = series.length; j < jj; ++j) {\n        const animation = series[j];\n        if (animation.complete) {\n          continue;\n        }\n        const elapsed = now - animation.start;\n        let fraction =\n          animation.duration > 0 ? elapsed / animation.duration : 1;\n        if (fraction >= 1) {\n          animation.complete = true;\n          fraction = 1;\n        } else {\n          seriesComplete = false;\n        }\n        const progress = animation.easing(fraction);\n        if (animation.sourceCenter) {\n          const x0 = animation.sourceCenter[0];\n          const y0 = animation.sourceCenter[1];\n          const x1 = animation.targetCenter[0];\n          const y1 = animation.targetCenter[1];\n          this.nextCenter_ = animation.targetCenter;\n          const x = x0 + progress * (x1 - x0);\n          const y = y0 + progress * (y1 - y0);\n          this.targetCenter_ = [x, y];\n        }\n        if (animation.sourceResolution && animation.targetResolution) {\n          const resolution =\n            progress === 1\n              ? animation.targetResolution\n              : animation.sourceResolution +\n                progress *\n                  (animation.targetResolution - animation.sourceResolution);\n          if (animation.anchor) {\n            const size = this.getViewportSize_(this.getRotation());\n            const constrainedResolution = this.constraints_.resolution(\n              resolution,\n              0,\n              size,\n              true,\n            );\n            this.targetCenter_ = this.calculateCenterZoom(\n              constrainedResolution,\n              animation.anchor,\n            );\n          }\n          this.nextResolution_ = animation.targetResolution;\n          this.targetResolution_ = resolution;\n          this.applyTargetState_(true);\n        }\n        if (\n          animation.sourceRotation !== undefined &&\n          animation.targetRotation !== undefined\n        ) {\n          const rotation =\n            progress === 1\n              ? modulo(animation.targetRotation + Math.PI, 2 * Math.PI) -\n                Math.PI\n              : animation.sourceRotation +\n                progress *\n                  (animation.targetRotation - animation.sourceRotation);\n          if (animation.anchor) {\n            const constrainedRotation = this.constraints_.rotation(\n              rotation,\n              true,\n            );\n            this.targetCenter_ = this.calculateCenterRotate(\n              constrainedRotation,\n              animation.anchor,\n            );\n          }\n          this.nextRotation_ = animation.targetRotation;\n          this.targetRotation_ = rotation;\n        }\n        this.applyTargetState_(true);\n        more = true;\n        if (!animation.complete) {\n          break;\n        }\n      }\n      if (seriesComplete) {\n        this.animations_[i] = null;\n        this.setHint(ViewHint.ANIMATING, -1);\n        this.nextCenter_ = null;\n        this.nextResolution_ = NaN;\n        this.nextRotation_ = NaN;\n        const callback = series[0].callback;\n        if (callback) {\n          animationCallback(callback, true);\n        }\n      }\n    }\n    // prune completed series\n    this.animations_ = this.animations_.filter(Boolean);\n    if (more && this.updateAnimationKey_ === undefined) {\n      this.updateAnimationKey_ = requestAnimationFrame(\n        this.updateAnimations_.bind(this),\n      );\n    }\n  }\n\n  /**\n   * @param {number} rotation Target rotation.\n   * @param {import(\"./coordinate.js\").Coordinate} anchor Rotation anchor.\n   * @return {import(\"./coordinate.js\").Coordinate|undefined} Center for rotation and anchor.\n   */\n  calculateCenterRotate(rotation, anchor) {\n    let center;\n    const currentCenter = this.getCenterInternal();\n    if (currentCenter !== undefined) {\n      center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];\n      rotateCoordinate(center, rotation - this.getRotation());\n      addCoordinate(center, anchor);\n    }\n    return center;\n  }\n\n  /**\n   * @param {number} resolution Target resolution.\n   * @param {import(\"./coordinate.js\").Coordinate} anchor Zoom anchor.\n   * @return {import(\"./coordinate.js\").Coordinate|undefined} Center for resolution and anchor.\n   */\n  calculateCenterZoom(resolution, anchor) {\n    let center;\n    const currentCenter = this.getCenterInternal();\n    const currentResolution = this.getResolution();\n    if (currentCenter !== undefined && currentResolution !== undefined) {\n      const x =\n        anchor[0] -\n        (resolution * (anchor[0] - currentCenter[0])) / currentResolution;\n      const y =\n        anchor[1] -\n        (resolution * (anchor[1] - currentCenter[1])) / currentResolution;\n      center = [x, y];\n    }\n    return center;\n  }\n\n  /**\n   * Returns the current viewport size.\n   * @private\n   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size\n   * @return {import(\"./size.js\").Size} Viewport size or `[100, 100]` when no viewport is found.\n   */\n  getViewportSize_(rotation) {\n    const size = this.viewportSize_;\n    if (rotation) {\n      const w = size[0];\n      const h = size[1];\n      return [\n        Math.abs(w * Math.cos(rotation)) + Math.abs(h * Math.sin(rotation)),\n        Math.abs(w * Math.sin(rotation)) + Math.abs(h * Math.cos(rotation)),\n      ];\n    }\n    return size;\n  }\n\n  /**\n   * Stores the viewport size on the view. The viewport size is not read every time from the DOM\n   * to avoid performance hit and layout reflow.\n   * This should be done on map size change.\n   * Note: the constraints are not resolved during an animation to avoid stopping it\n   * @param {import(\"./size.js\").Size} [size] Viewport size; if undefined, [100, 100] is assumed\n   */\n  setViewportSize(size) {\n    this.viewportSize_ = Array.isArray(size) ? size.slice() : [100, 100];\n    if (!this.getAnimating()) {\n      this.resolveConstraints(0);\n    }\n  }\n\n  /**\n   * Get the view center.\n   * @return {import(\"./coordinate.js\").Coordinate|undefined} The center of the view.\n   * @observable\n   * @api\n   */\n  getCenter() {\n    const center = this.getCenterInternal();\n    if (!center) {\n      return center;\n    }\n    return toUserCoordinate(center, this.getProjection());\n  }\n\n  /**\n   * Get the view center without transforming to user projection.\n   * @return {import(\"./coordinate.js\").Coordinate|undefined} The center of the view.\n   */\n  getCenterInternal() {\n    return /** @type {import(\"./coordinate.js\").Coordinate|undefined} */ (\n      this.get(ViewProperty.CENTER)\n    );\n  }\n\n  /**\n   * @return {Constraints} Constraints.\n   */\n  getConstraints() {\n    return this.constraints_;\n  }\n\n  /**\n   * @return {boolean} Resolution constraint is set\n   */\n  getConstrainResolution() {\n    return this.get('constrainResolution');\n  }\n\n  /**\n   * @param {Array<number>} [hints] Destination array.\n   * @return {Array<number>} Hint.\n   */\n  getHints(hints) {\n    if (hints !== undefined) {\n      hints[0] = this.hints_[0];\n      hints[1] = this.hints_[1];\n      return hints;\n    }\n    return this.hints_.slice();\n  }\n\n  /**\n   * Calculate the extent for the current view state and the passed box size.\n   * @param {import(\"./size.js\").Size} [size] The pixel dimensions of the box\n   * into which the calculated extent should fit. Defaults to the size of the\n   * map the view is associated with.\n   * If no map or multiple maps are connected to the view, provide the desired\n   * box size (e.g. `map.getSize()`).\n   * @return {import(\"./extent.js\").Extent} Extent.\n   * @api\n   */\n  calculateExtent(size) {\n    const extent = this.calculateExtentInternal(size);\n    return toUserExtent(extent, this.getProjection());\n  }\n\n  /**\n   * @param {import(\"./size.js\").Size} [size] Box pixel size. If not provided,\n   * the map's last known viewport size will be used.\n   * @return {import(\"./extent.js\").Extent} Extent.\n   */\n  calculateExtentInternal(size) {\n    size = size || this.getViewportSizeMinusPadding_();\n    const center = /** @type {!import(\"./coordinate.js\").Coordinate} */ (\n      this.getCenterInternal()\n    );\n    assert(center, 'The view center is not defined');\n    const resolution = /** @type {!number} */ (this.getResolution());\n    assert(resolution !== undefined, 'The view resolution is not defined');\n    const rotation = /** @type {!number} */ (this.getRotation());\n    assert(rotation !== undefined, 'The view rotation is not defined');\n\n    return getForViewAndSize(center, resolution, rotation, size);\n  }\n\n  /**\n   * Get the maximum resolution of the view.\n   * @return {number} The maximum resolution of the view.\n   * @api\n   */\n  getMaxResolution() {\n    return this.maxResolution_;\n  }\n\n  /**\n   * Get the minimum resolution of the view.\n   * @return {number} The minimum resolution of the view.\n   * @api\n   */\n  getMinResolution() {\n    return this.minResolution_;\n  }\n\n  /**\n   * Get the maximum zoom level for the view.\n   * @return {number} The maximum zoom level.\n   * @api\n   */\n  getMaxZoom() {\n    return /** @type {number} */ (\n      this.getZoomForResolution(this.minResolution_)\n    );\n  }\n\n  /**\n   * Set a new maximum zoom level for the view.\n   * @param {number} zoom The maximum zoom level.\n   * @api\n   */\n  setMaxZoom(zoom) {\n    this.applyOptions_(this.getUpdatedOptions_({maxZoom: zoom}));\n  }\n\n  /**\n   * Get the minimum zoom level for the view.\n   * @return {number} The minimum zoom level.\n   * @api\n   */\n  getMinZoom() {\n    return /** @type {number} */ (\n      this.getZoomForResolution(this.maxResolution_)\n    );\n  }\n\n  /**\n   * Set a new minimum zoom level for the view.\n   * @param {number} zoom The minimum zoom level.\n   * @api\n   */\n  setMinZoom(zoom) {\n    this.applyOptions_(this.getUpdatedOptions_({minZoom: zoom}));\n  }\n\n  /**\n   * Set whether the view should allow intermediary zoom levels.\n   * @param {boolean} enabled Whether the resolution is constrained.\n   * @api\n   */\n  setConstrainResolution(enabled) {\n    this.applyOptions_(this.getUpdatedOptions_({constrainResolution: enabled}));\n  }\n\n  /**\n   * Get the view projection.\n   * @return {import(\"./proj/Projection.js\").default} The projection of the view.\n   * @api\n   */\n  getProjection() {\n    return this.projection_;\n  }\n\n  /**\n   * Get the view resolution.\n   * @return {number|undefined} The resolution of the view.\n   * @observable\n   * @api\n   */\n  getResolution() {\n    return /** @type {number|undefined} */ (this.get(ViewProperty.RESOLUTION));\n  }\n\n  /**\n   * Get the resolutions for the view. This returns the array of resolutions\n   * passed to the constructor of the View, or undefined if none were given.\n   * @return {Array<number>|undefined} The resolutions of the view.\n   * @api\n   */\n  getResolutions() {\n    return this.resolutions_;\n  }\n\n  /**\n   * Get the resolution for a provided extent (in map units) and size (in pixels).\n   * @param {import(\"./extent.js\").Extent} extent Extent.\n   * @param {import(\"./size.js\").Size} [size] Box pixel size.\n   * @return {number} The resolution at which the provided extent will render at\n   *     the given size.\n   * @api\n   */\n  getResolutionForExtent(extent, size) {\n    return this.getResolutionForExtentInternal(\n      fromUserExtent(extent, this.getProjection()),\n      size,\n    );\n  }\n\n  /**\n   * Get the resolution for a provided extent (in map units) and size (in pixels).\n   * @param {import(\"./extent.js\").Extent} extent Extent.\n   * @param {import(\"./size.js\").Size} [size] Box pixel size.\n   * @return {number} The resolution at which the provided extent will render at\n   *     the given size.\n   */\n  getResolutionForExtentInternal(extent, size) {\n    size = size || this.getViewportSizeMinusPadding_();\n    const xResolution = getWidth(extent) / size[0];\n    const yResolution = getHeight(extent) / size[1];\n    return Math.max(xResolution, yResolution);\n  }\n\n  /**\n   * Return a function that returns a value between 0 and 1 for a\n   * resolution. Exponential scaling is assumed.\n   * @param {number} [power] Power.\n   * @return {function(number): number} Resolution for value function.\n   */\n  getResolutionForValueFunction(power) {\n    power = power || 2;\n    const maxResolution = this.getConstrainedResolution(this.maxResolution_);\n    const minResolution = this.minResolution_;\n    const max = Math.log(maxResolution / minResolution) / Math.log(power);\n    return (\n      /**\n       * @param {number} value Value.\n       * @return {number} Resolution.\n       */\n      function (value) {\n        const resolution = maxResolution / Math.pow(power, value * max);\n        return resolution;\n      }\n    );\n  }\n\n  /**\n   * Get the view rotation.\n   * @return {number} The rotation of the view in radians.\n   * @observable\n   * @api\n   */\n  getRotation() {\n    return /** @type {number} */ (this.get(ViewProperty.ROTATION));\n  }\n\n  /**\n   * Return a function that returns a resolution for a value between\n   * 0 and 1. Exponential scaling is assumed.\n   * @param {number} [power] Power.\n   * @return {function(number): number} Value for resolution function.\n   */\n  getValueForResolutionFunction(power) {\n    const logPower = Math.log(power || 2);\n    const maxResolution = this.getConstrainedResolution(this.maxResolution_);\n    const minResolution = this.minResolution_;\n    const max = Math.log(maxResolution / minResolution) / logPower;\n    return (\n      /**\n       * @param {number} resolution Resolution.\n       * @return {number} Value.\n       */\n      function (resolution) {\n        const value = Math.log(maxResolution / resolution) / logPower / max;\n        return value;\n      }\n    );\n  }\n\n  /**\n   * Returns the size of the viewport minus padding.\n   * @private\n   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size\n   * @return {import(\"./size.js\").Size} Viewport size reduced by the padding.\n   */\n  getViewportSizeMinusPadding_(rotation) {\n    let size = this.getViewportSize_(rotation);\n    const padding = this.padding_;\n    if (padding) {\n      size = [\n        size[0] - padding[1] - padding[3],\n        size[1] - padding[0] - padding[2],\n      ];\n    }\n    return size;\n  }\n\n  /**\n   * @return {State} View state.\n   */\n  getState() {\n    const projection = this.getProjection();\n    const resolution = this.getResolution();\n    const rotation = this.getRotation();\n    let center = /** @type {import(\"./coordinate.js\").Coordinate} */ (\n      this.getCenterInternal()\n    );\n    const padding = this.padding_;\n    if (padding) {\n      const reducedSize = this.getViewportSizeMinusPadding_();\n      center = calculateCenterOn(\n        center,\n        this.getViewportSize_(),\n        [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]],\n        resolution,\n        rotation,\n      );\n    }\n    return {\n      center: center.slice(0),\n      projection: projection !== undefined ? projection : null,\n      resolution: resolution,\n      nextCenter: this.nextCenter_,\n      nextResolution: this.nextResolution_,\n      nextRotation: this.nextRotation_,\n      rotation: rotation,\n      zoom: this.getZoom(),\n    };\n  }\n\n  /**\n   * @return {ViewStateLayerStateExtent} Like `FrameState`, but just `viewState` and `extent`.\n   */\n  getViewStateAndExtent() {\n    return {\n      viewState: this.getState(),\n      extent: this.calculateExtent(),\n    };\n  }\n\n  /**\n   * Get the current zoom level. This method may return non-integer zoom levels\n   * if the view does not constrain the resolution, or if an interaction or\n   * animation is underway.\n   * @return {number|undefined} Zoom.\n   * @api\n   */\n  getZoom() {\n    let zoom;\n    const resolution = this.getResolution();\n    if (resolution !== undefined) {\n      zoom = this.getZoomForResolution(resolution);\n    }\n    return zoom;\n  }\n\n  /**\n   * Get the zoom level for a resolution.\n   * @param {number} resolution The resolution.\n   * @return {number|undefined} The zoom level for the provided resolution.\n   * @api\n   */\n  getZoomForResolution(resolution) {\n    let offset = this.minZoom_ || 0;\n    let max, zoomFactor;\n    if (this.resolutions_) {\n      const nearest = linearFindNearest(this.resolutions_, resolution, 1);\n      offset = nearest;\n      max = this.resolutions_[nearest];\n      if (nearest == this.resolutions_.length - 1) {\n        zoomFactor = 2;\n      } else {\n        zoomFactor = max / this.resolutions_[nearest + 1];\n      }\n    } else {\n      max = this.maxResolution_;\n      zoomFactor = this.zoomFactor_;\n    }\n    return offset + Math.log(max / resolution) / Math.log(zoomFactor);\n  }\n\n  /**\n   * Get the resolution for a zoom level.\n   * @param {number} zoom Zoom level.\n   * @return {number} The view resolution for the provided zoom level.\n   * @api\n   */\n  getResolutionForZoom(zoom) {\n    if (this.resolutions_) {\n      if (this.resolutions_.length <= 1) {\n        return 0;\n      }\n      const baseLevel = clamp(\n        Math.floor(zoom),\n        0,\n        this.resolutions_.length - 2,\n      );\n      const zoomFactor =\n        this.resolutions_[baseLevel] / this.resolutions_[baseLevel + 1];\n      return (\n        this.resolutions_[baseLevel] /\n        Math.pow(zoomFactor, clamp(zoom - baseLevel, 0, 1))\n      );\n    }\n    return (\n      this.maxResolution_ / Math.pow(this.zoomFactor_, zoom - this.minZoom_)\n    );\n  }\n\n  /**\n   * Fit the given geometry or extent based on the given map size and border.\n   * The size is pixel dimensions of the box to fit the extent into.\n   * In most cases you will want to use the map size, that is `map.getSize()`.\n   * Takes care of the map angle.\n   * @param {import(\"./geom/SimpleGeometry.js\").default|import(\"./extent.js\").Extent} geometryOrExtent The geometry or\n   *     extent to fit the view to.\n   * @param {FitOptions} [options] Options.\n   * @api\n   */\n  fit(geometryOrExtent, options) {\n    /** @type {import(\"./geom/SimpleGeometry.js\").default} */\n    let geometry;\n    assert(\n      Array.isArray(geometryOrExtent) ||\n        typeof (/** @type {?} */ (geometryOrExtent).getSimplifiedGeometry) ===\n          'function',\n      'Invalid extent or geometry provided as `geometry`',\n    );\n    if (Array.isArray(geometryOrExtent)) {\n      assert(\n        !isEmpty(geometryOrExtent),\n        'Cannot fit empty extent provided as `geometry`',\n      );\n      const extent = fromUserExtent(geometryOrExtent, this.getProjection());\n      geometry = polygonFromExtent(extent);\n    } else if (geometryOrExtent.getType() === 'Circle') {\n      const extent = fromUserExtent(\n        geometryOrExtent.getExtent(),\n        this.getProjection(),\n      );\n      geometry = polygonFromExtent(extent);\n      geometry.rotate(this.getRotation(), getCenter(extent));\n    } else {\n      const userProjection = getUserProjection();\n      if (userProjection) {\n        geometry = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (\n          geometryOrExtent\n            .clone()\n            .transform(userProjection, this.getProjection())\n        );\n      } else {\n        geometry = geometryOrExtent;\n      }\n    }\n\n    this.fitInternal(geometry, options);\n  }\n\n  /**\n   * Calculate rotated extent\n   * @param {import(\"./geom/SimpleGeometry.js\").default} geometry The geometry.\n   * @return {import(\"./extent\").Extent} The rotated extent for the geometry.\n   */\n  rotatedExtentForGeometry(geometry) {\n    const rotation = this.getRotation();\n    const cosAngle = Math.cos(rotation);\n    const sinAngle = Math.sin(-rotation);\n    const coords = geometry.getFlatCoordinates();\n    const stride = geometry.getStride();\n    let minRotX = +Infinity;\n    let minRotY = +Infinity;\n    let maxRotX = -Infinity;\n    let maxRotY = -Infinity;\n    for (let i = 0, ii = coords.length; i < ii; i += stride) {\n      const rotX = coords[i] * cosAngle - coords[i + 1] * sinAngle;\n      const rotY = coords[i] * sinAngle + coords[i + 1] * cosAngle;\n      minRotX = Math.min(minRotX, rotX);\n      minRotY = Math.min(minRotY, rotY);\n      maxRotX = Math.max(maxRotX, rotX);\n      maxRotY = Math.max(maxRotY, rotY);\n    }\n    return [minRotX, minRotY, maxRotX, maxRotY];\n  }\n\n  /**\n   * @param {import(\"./geom/SimpleGeometry.js\").default} geometry The geometry.\n   * @param {FitOptions} [options] Options.\n   */\n  fitInternal(geometry, options) {\n    options = options || {};\n    let size = options.size;\n    if (!size) {\n      size = this.getViewportSizeMinusPadding_();\n    }\n    const padding =\n      options.padding !== undefined ? options.padding : [0, 0, 0, 0];\n    const nearest = options.nearest !== undefined ? options.nearest : false;\n    let minResolution;\n    if (options.minResolution !== undefined) {\n      minResolution = options.minResolution;\n    } else if (options.maxZoom !== undefined) {\n      minResolution = this.getResolutionForZoom(options.maxZoom);\n    } else {\n      minResolution = 0;\n    }\n\n    const rotatedExtent = this.rotatedExtentForGeometry(geometry);\n\n    // calculate resolution\n    let resolution = this.getResolutionForExtentInternal(rotatedExtent, [\n      size[0] - padding[1] - padding[3],\n      size[1] - padding[0] - padding[2],\n    ]);\n    resolution = isNaN(resolution)\n      ? minResolution\n      : Math.max(resolution, minResolution);\n    resolution = this.getConstrainedResolution(resolution, nearest ? 0 : 1);\n\n    // calculate center\n    const rotation = this.getRotation();\n    const sinAngle = Math.sin(rotation);\n    const cosAngle = Math.cos(rotation);\n    const centerRot = getCenter(rotatedExtent);\n    centerRot[0] += ((padding[1] - padding[3]) / 2) * resolution;\n    centerRot[1] += ((padding[0] - padding[2]) / 2) * resolution;\n    const centerX = centerRot[0] * cosAngle - centerRot[1] * sinAngle;\n    const centerY = centerRot[1] * cosAngle + centerRot[0] * sinAngle;\n    const center = this.getConstrainedCenter([centerX, centerY], resolution);\n    const callback = options.callback ? options.callback : VOID;\n\n    if (options.duration !== undefined) {\n      this.animateInternal(\n        {\n          resolution: resolution,\n          center: center,\n          duration: options.duration,\n          easing: options.easing,\n        },\n        callback,\n      );\n    } else {\n      this.targetResolution_ = resolution;\n      this.targetCenter_ = center;\n      this.applyTargetState_(false, true);\n      animationCallback(callback, true);\n    }\n  }\n\n  /**\n   * Center on coordinate and view position.\n   * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"./size.js\").Size} size Box pixel size.\n   * @param {import(\"./pixel.js\").Pixel} position Position on the view to center on.\n   * @api\n   */\n  centerOn(coordinate, size, position) {\n    this.centerOnInternal(\n      fromUserCoordinate(coordinate, this.getProjection()),\n      size,\n      position,\n    );\n  }\n\n  /**\n   * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"./size.js\").Size} size Box pixel size.\n   * @param {import(\"./pixel.js\").Pixel} position Position on the view to center on.\n   */\n  centerOnInternal(coordinate, size, position) {\n    this.setCenterInternal(\n      calculateCenterOn(\n        coordinate,\n        size,\n        position,\n        this.getResolution(),\n        this.getRotation(),\n      ),\n    );\n  }\n\n  /**\n   * Calculates the shift between map and viewport center.\n   * @param {import(\"./coordinate.js\").Coordinate} center Center.\n   * @param {number} resolution Resolution.\n   * @param {number} rotation Rotation.\n   * @param {import(\"./size.js\").Size} size Size.\n   * @return {Array<number>|undefined} Center shift.\n   */\n  calculateCenterShift(center, resolution, rotation, size) {\n    let centerShift;\n    const padding = this.padding_;\n    if (padding && center) {\n      const reducedSize = this.getViewportSizeMinusPadding_(-rotation);\n      const shiftedCenter = calculateCenterOn(\n        center,\n        size,\n        [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]],\n        resolution,\n        rotation,\n      );\n      centerShift = [\n        center[0] - shiftedCenter[0],\n        center[1] - shiftedCenter[1],\n      ];\n    }\n    return centerShift;\n  }\n\n  /**\n   * @return {boolean} Is defined.\n   */\n  isDef() {\n    return !!this.getCenterInternal() && this.getResolution() !== undefined;\n  }\n\n  /**\n   * Adds relative coordinates to the center of the view. Any extent constraint will apply.\n   * @param {import(\"./coordinate.js\").Coordinate} deltaCoordinates Relative value to add.\n   * @api\n   */\n  adjustCenter(deltaCoordinates) {\n    const center = toUserCoordinate(this.targetCenter_, this.getProjection());\n    this.setCenter([\n      center[0] + deltaCoordinates[0],\n      center[1] + deltaCoordinates[1],\n    ]);\n  }\n\n  /**\n   * Adds relative coordinates to the center of the view. Any extent constraint will apply.\n   * @param {import(\"./coordinate.js\").Coordinate} deltaCoordinates Relative value to add.\n   */\n  adjustCenterInternal(deltaCoordinates) {\n    const center = this.targetCenter_;\n    this.setCenterInternal([\n      center[0] + deltaCoordinates[0],\n      center[1] + deltaCoordinates[1],\n    ]);\n  }\n\n  /**\n   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution\n   * constraint will apply.\n   * @param {number} ratio The ratio to apply on the view resolution.\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The origin of the transformation.\n   * @api\n   */\n  adjustResolution(ratio, anchor) {\n    anchor = anchor && fromUserCoordinate(anchor, this.getProjection());\n    this.adjustResolutionInternal(ratio, anchor);\n  }\n\n  /**\n   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution\n   * constraint will apply.\n   * @param {number} ratio The ratio to apply on the view resolution.\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The origin of the transformation.\n   */\n  adjustResolutionInternal(ratio, anchor) {\n    const isMoving = this.getAnimating() || this.getInteracting();\n    const size = this.getViewportSize_(this.getRotation());\n    const newResolution = this.constraints_.resolution(\n      this.targetResolution_ * ratio,\n      0,\n      size,\n      isMoving,\n    );\n\n    if (anchor) {\n      this.targetCenter_ = this.calculateCenterZoom(newResolution, anchor);\n    }\n\n    this.targetResolution_ *= ratio;\n    this.applyTargetState_();\n  }\n\n  /**\n   * Adds a value to the view zoom level, optionally using an anchor. Any resolution\n   * constraint will apply.\n   * @param {number} delta Relative value to add to the zoom level.\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The origin of the transformation.\n   * @api\n   */\n  adjustZoom(delta, anchor) {\n    this.adjustResolution(Math.pow(this.zoomFactor_, -delta), anchor);\n  }\n\n  /**\n   * Adds a value to the view rotation, optionally using an anchor. Any rotation\n   * constraint will apply.\n   * @param {number} delta Relative value to add to the zoom rotation, in radians.\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The rotation center.\n   * @api\n   */\n  adjustRotation(delta, anchor) {\n    if (anchor) {\n      anchor = fromUserCoordinate(anchor, this.getProjection());\n    }\n    this.adjustRotationInternal(delta, anchor);\n  }\n\n  /**\n   * @param {number} delta Relative value to add to the zoom rotation, in radians.\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The rotation center.\n   */\n  adjustRotationInternal(delta, anchor) {\n    const isMoving = this.getAnimating() || this.getInteracting();\n    const newRotation = this.constraints_.rotation(\n      this.targetRotation_ + delta,\n      isMoving,\n    );\n    if (anchor) {\n      this.targetCenter_ = this.calculateCenterRotate(newRotation, anchor);\n    }\n    this.targetRotation_ += delta;\n    this.applyTargetState_();\n  }\n\n  /**\n   * Set the center of the current view. Any extent constraint will apply.\n   * @param {import(\"./coordinate.js\").Coordinate|undefined} center The center of the view.\n   * @observable\n   * @api\n   */\n  setCenter(center) {\n    this.setCenterInternal(\n      center ? fromUserCoordinate(center, this.getProjection()) : center,\n    );\n  }\n\n  /**\n   * Set the center using the view projection (not the user projection).\n   * @param {import(\"./coordinate.js\").Coordinate|undefined} center The center of the view.\n   */\n  setCenterInternal(center) {\n    this.targetCenter_ = center;\n    this.applyTargetState_();\n  }\n\n  /**\n   * @param {import(\"./ViewHint.js\").default} hint Hint.\n   * @param {number} delta Delta.\n   * @return {number} New value.\n   */\n  setHint(hint, delta) {\n    this.hints_[hint] += delta;\n    this.changed();\n    return this.hints_[hint];\n  }\n\n  /**\n   * Set the resolution for this view. Any resolution constraint will apply.\n   * @param {number|undefined} resolution The resolution of the view.\n   * @observable\n   * @api\n   */\n  setResolution(resolution) {\n    this.targetResolution_ = resolution;\n    this.applyTargetState_();\n  }\n\n  /**\n   * Set the rotation for this view. Any rotation constraint will apply.\n   * @param {number} rotation The rotation of the view in radians.\n   * @observable\n   * @api\n   */\n  setRotation(rotation) {\n    this.targetRotation_ = rotation;\n    this.applyTargetState_();\n  }\n\n  /**\n   * Zoom to a specific zoom level. Any resolution constrain will apply.\n   * @param {number} zoom Zoom level.\n   * @api\n   */\n  setZoom(zoom) {\n    this.setResolution(this.getResolutionForZoom(zoom));\n  }\n\n  /**\n   * Recompute rotation/resolution/center based on target values.\n   * Note: we have to compute rotation first, then resolution and center considering that\n   * parameters can influence one another in case a view extent constraint is present.\n   * @param {boolean} [doNotCancelAnims] Do not cancel animations.\n   * @param {boolean} [forceMoving] Apply constraints as if the view is moving.\n   * @private\n   */\n  applyTargetState_(doNotCancelAnims, forceMoving) {\n    const isMoving =\n      this.getAnimating() || this.getInteracting() || forceMoving;\n\n    // compute rotation\n    const newRotation = this.constraints_.rotation(\n      this.targetRotation_,\n      isMoving,\n    );\n    const size = this.getViewportSize_(newRotation);\n    const newResolution = this.constraints_.resolution(\n      this.targetResolution_,\n      0,\n      size,\n      isMoving,\n    );\n    const newCenter = this.constraints_.center(\n      this.targetCenter_,\n      newResolution,\n      size,\n      isMoving,\n      this.calculateCenterShift(\n        this.targetCenter_,\n        newResolution,\n        newRotation,\n        size,\n      ),\n    );\n\n    if (this.get(ViewProperty.ROTATION) !== newRotation) {\n      this.set(ViewProperty.ROTATION, newRotation);\n    }\n    if (this.get(ViewProperty.RESOLUTION) !== newResolution) {\n      this.set(ViewProperty.RESOLUTION, newResolution);\n      this.set('zoom', this.getZoom(), true);\n    }\n    if (\n      !newCenter ||\n      !this.get(ViewProperty.CENTER) ||\n      !equals(this.get(ViewProperty.CENTER), newCenter)\n    ) {\n      this.set(ViewProperty.CENTER, newCenter);\n    }\n\n    if (this.getAnimating() && !doNotCancelAnims) {\n      this.cancelAnimations();\n    }\n    this.cancelAnchor_ = undefined;\n  }\n\n  /**\n   * If any constraints need to be applied, an animation will be triggered.\n   * This is typically done on interaction end.\n   * Note: calling this with a duration of 0 will apply the constrained values straight away,\n   * without animation.\n   * @param {number} [duration] The animation duration in ms.\n   * @param {number} [resolutionDirection] Which direction to zoom.\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The origin of the transformation.\n   */\n  resolveConstraints(duration, resolutionDirection, anchor) {\n    duration = duration !== undefined ? duration : 200;\n    const direction = resolutionDirection || 0;\n\n    const newRotation = this.constraints_.rotation(this.targetRotation_);\n    const size = this.getViewportSize_(newRotation);\n    const newResolution = this.constraints_.resolution(\n      this.targetResolution_,\n      direction,\n      size,\n    );\n    const newCenter = this.constraints_.center(\n      this.targetCenter_,\n      newResolution,\n      size,\n      false,\n      this.calculateCenterShift(\n        this.targetCenter_,\n        newResolution,\n        newRotation,\n        size,\n      ),\n    );\n\n    if (duration === 0 && !this.cancelAnchor_) {\n      this.targetResolution_ = newResolution;\n      this.targetRotation_ = newRotation;\n      this.targetCenter_ = newCenter;\n      this.applyTargetState_();\n      return;\n    }\n\n    anchor = anchor || (duration === 0 ? this.cancelAnchor_ : undefined);\n    this.cancelAnchor_ = undefined;\n\n    if (\n      this.getResolution() !== newResolution ||\n      this.getRotation() !== newRotation ||\n      !this.getCenterInternal() ||\n      !equals(this.getCenterInternal(), newCenter)\n    ) {\n      if (this.getAnimating()) {\n        this.cancelAnimations();\n      }\n\n      this.animateInternal({\n        rotation: newRotation,\n        center: newCenter,\n        resolution: newResolution,\n        duration: duration,\n        easing: easeOut,\n        anchor: anchor,\n      });\n    }\n  }\n\n  /**\n   * Notify the View that an interaction has started.\n   * The view state will be resolved to a stable one if needed\n   * (depending on its constraints).\n   * @api\n   */\n  beginInteraction() {\n    this.resolveConstraints(0);\n\n    this.setHint(ViewHint.INTERACTING, 1);\n  }\n\n  /**\n   * Notify the View that an interaction has ended. The view state will be resolved\n   * to a stable one if needed (depending on its constraints).\n   * @param {number} [duration] Animation duration in ms.\n   * @param {number} [resolutionDirection] Which direction to zoom.\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The origin of the transformation.\n   * @api\n   */\n  endInteraction(duration, resolutionDirection, anchor) {\n    anchor = anchor && fromUserCoordinate(anchor, this.getProjection());\n    this.endInteractionInternal(duration, resolutionDirection, anchor);\n  }\n\n  /**\n   * Notify the View that an interaction has ended. The view state will be resolved\n   * to a stable one if needed (depending on its constraints).\n   * @param {number} [duration] Animation duration in ms.\n   * @param {number} [resolutionDirection] Which direction to zoom.\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The origin of the transformation.\n   */\n  endInteractionInternal(duration, resolutionDirection, anchor) {\n    if (!this.getInteracting()) {\n      return;\n    }\n    this.setHint(ViewHint.INTERACTING, -1);\n    this.resolveConstraints(duration, resolutionDirection, anchor);\n  }\n\n  /**\n   * Get a valid position for the view center according to the current constraints.\n   * @param {import(\"./coordinate.js\").Coordinate|undefined} targetCenter Target center position.\n   * @param {number} [targetResolution] Target resolution. If not supplied, the current one will be used.\n   * This is useful to guess a valid center position at a different zoom level.\n   * @return {import(\"./coordinate.js\").Coordinate|undefined} Valid center position.\n   */\n  getConstrainedCenter(targetCenter, targetResolution) {\n    const size = this.getViewportSize_(this.getRotation());\n    return this.constraints_.center(\n      targetCenter,\n      targetResolution || this.getResolution(),\n      size,\n    );\n  }\n\n  /**\n   * Get a valid zoom level according to the current view constraints.\n   * @param {number|undefined} targetZoom Target zoom.\n   * @param {number} [direction=0] Indicate which resolution should be used\n   * by a renderer if the view resolution does not match any resolution of the tile source.\n   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution\n   * will be used. If -1, the nearest higher resolution will be used.\n   * @return {number|undefined} Valid zoom level.\n   */\n  getConstrainedZoom(targetZoom, direction) {\n    const targetRes = this.getResolutionForZoom(targetZoom);\n    return this.getZoomForResolution(\n      this.getConstrainedResolution(targetRes, direction),\n    );\n  }\n\n  /**\n   * Get a valid resolution according to the current view constraints.\n   * @param {number|undefined} targetResolution Target resolution.\n   * @param {number} [direction=0] Indicate which resolution should be used\n   * by a renderer if the view resolution does not match any resolution of the tile source.\n   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution\n   * will be used. If -1, the nearest higher resolution will be used.\n   * @return {number|undefined} Valid resolution.\n   */\n  getConstrainedResolution(targetResolution, direction) {\n    direction = direction || 0;\n    const size = this.getViewportSize_(this.getRotation());\n\n    return this.constraints_.resolution(targetResolution, direction, size);\n  }\n}\n\n/**\n * @param {Function} callback Callback.\n * @param {*} returnValue Return value.\n */\nfunction animationCallback(callback, returnValue) {\n  setTimeout(function () {\n    callback(returnValue);\n  }, 0);\n}\n\n/**\n * @param {ViewOptions} options View options.\n * @return {import(\"./centerconstraint.js\").Type} The constraint.\n */\nexport function createCenterConstraint(options) {\n  if (options.extent !== undefined) {\n    const smooth =\n      options.smoothExtentConstraint !== undefined\n        ? options.smoothExtentConstraint\n        : true;\n    return createExtent(options.extent, options.constrainOnlyCenter, smooth);\n  }\n\n  const projection = createProjection(options.projection, 'EPSG:3857');\n  if (options.multiWorld !== true && projection.isGlobal()) {\n    const extent = projection.getExtent().slice();\n    extent[0] = -Infinity;\n    extent[2] = Infinity;\n    return createExtent(extent, false, false);\n  }\n\n  return centerNone;\n}\n\n/**\n * @param {ViewOptions} options View options.\n * @return {{constraint: import(\"./resolutionconstraint.js\").Type, maxResolution: number,\n *     minResolution: number, minZoom: number, zoomFactor: number}} The constraint.\n */\nexport function createResolutionConstraint(options) {\n  let resolutionConstraint;\n  let maxResolution;\n  let minResolution;\n\n  // TODO: move these to be ol constants\n  // see https://github.com/openlayers/openlayers/issues/2076\n  const defaultMaxZoom = 28;\n  const defaultZoomFactor = 2;\n\n  let minZoom =\n    options.minZoom !== undefined ? options.minZoom : DEFAULT_MIN_ZOOM;\n\n  let maxZoom =\n    options.maxZoom !== undefined ? options.maxZoom : defaultMaxZoom;\n\n  const zoomFactor =\n    options.zoomFactor !== undefined ? options.zoomFactor : defaultZoomFactor;\n\n  const multiWorld =\n    options.multiWorld !== undefined ? options.multiWorld : false;\n\n  const smooth =\n    options.smoothResolutionConstraint !== undefined\n      ? options.smoothResolutionConstraint\n      : true;\n\n  const showFullExtent =\n    options.showFullExtent !== undefined ? options.showFullExtent : false;\n\n  const projection = createProjection(options.projection, 'EPSG:3857');\n  const projExtent = projection.getExtent();\n  let constrainOnlyCenter = options.constrainOnlyCenter;\n  let extent = options.extent;\n  if (!multiWorld && !extent && projection.isGlobal()) {\n    constrainOnlyCenter = false;\n    extent = projExtent;\n  }\n\n  if (options.resolutions !== undefined) {\n    const resolutions = options.resolutions;\n    maxResolution = resolutions[minZoom];\n    minResolution =\n      resolutions[maxZoom] !== undefined\n        ? resolutions[maxZoom]\n        : resolutions[resolutions.length - 1];\n\n    if (options.constrainResolution) {\n      resolutionConstraint = createSnapToResolutions(\n        resolutions,\n        smooth,\n        !constrainOnlyCenter && extent,\n        showFullExtent,\n      );\n    } else {\n      resolutionConstraint = createMinMaxResolution(\n        maxResolution,\n        minResolution,\n        smooth,\n        !constrainOnlyCenter && extent,\n        showFullExtent,\n      );\n    }\n  } else {\n    // calculate the default min and max resolution\n    const size = !projExtent\n      ? // use an extent that can fit the whole world if need be\n        (360 * METERS_PER_UNIT.degrees) / projection.getMetersPerUnit()\n      : Math.max(getWidth(projExtent), getHeight(projExtent));\n\n    const defaultMaxResolution =\n      size / DEFAULT_TILE_SIZE / Math.pow(defaultZoomFactor, DEFAULT_MIN_ZOOM);\n\n    const defaultMinResolution =\n      defaultMaxResolution /\n      Math.pow(defaultZoomFactor, defaultMaxZoom - DEFAULT_MIN_ZOOM);\n\n    // user provided maxResolution takes precedence\n    maxResolution = options.maxResolution;\n    if (maxResolution !== undefined) {\n      minZoom = 0;\n    } else {\n      maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);\n    }\n\n    // user provided minResolution takes precedence\n    minResolution = options.minResolution;\n    if (minResolution === undefined) {\n      if (options.maxZoom !== undefined) {\n        if (options.maxResolution !== undefined) {\n          minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);\n        } else {\n          minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);\n        }\n      } else {\n        minResolution = defaultMinResolution;\n      }\n    }\n\n    // given discrete zoom levels, minResolution may be different than provided\n    maxZoom =\n      minZoom +\n      Math.floor(\n        Math.log(maxResolution / minResolution) / Math.log(zoomFactor),\n      );\n    minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);\n\n    if (options.constrainResolution) {\n      resolutionConstraint = createSnapToPower(\n        zoomFactor,\n        maxResolution,\n        minResolution,\n        smooth,\n        !constrainOnlyCenter && extent,\n        showFullExtent,\n      );\n    } else {\n      resolutionConstraint = createMinMaxResolution(\n        maxResolution,\n        minResolution,\n        smooth,\n        !constrainOnlyCenter && extent,\n        showFullExtent,\n      );\n    }\n  }\n  return {\n    constraint: resolutionConstraint,\n    maxResolution: maxResolution,\n    minResolution: minResolution,\n    minZoom: minZoom,\n    zoomFactor: zoomFactor,\n  };\n}\n\n/**\n * @param {ViewOptions} options View options.\n * @return {import(\"./rotationconstraint.js\").Type} Rotation constraint.\n */\nexport function createRotationConstraint(options) {\n  const enableRotation =\n    options.enableRotation !== undefined ? options.enableRotation : true;\n  if (enableRotation) {\n    const constrainRotation = options.constrainRotation;\n    if (constrainRotation === undefined || constrainRotation === true) {\n      return createSnapToZero();\n    }\n    if (constrainRotation === false) {\n      return rotationNone;\n    }\n    if (typeof constrainRotation === 'number') {\n      return createSnapToN(constrainRotation);\n    }\n    return rotationNone;\n  }\n  return disable;\n}\n\n/**\n * Determine if an animation involves no view change.\n * @param {Animation} animation The animation.\n * @return {boolean} The animation involves no view change.\n */\nexport function isNoopAnimation(animation) {\n  if (animation.sourceCenter && animation.targetCenter) {\n    if (!coordinatesEqual(animation.sourceCenter, animation.targetCenter)) {\n      return false;\n    }\n  }\n  if (animation.sourceResolution !== animation.targetResolution) {\n    return false;\n  }\n  if (animation.sourceRotation !== animation.targetRotation) {\n    return false;\n  }\n  return true;\n}\n\n/**\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n * @param {import(\"./size.js\").Size} size Box pixel size.\n * @param {import(\"./pixel.js\").Pixel} position Position on the view to center on.\n * @param {number} resolution Resolution.\n * @param {number} rotation Rotation.\n * @return {import(\"./coordinate.js\").Coordinate} Shifted center.\n */\nfunction calculateCenterOn(coordinate, size, position, resolution, rotation) {\n  // calculate rotated position\n  const cosAngle = Math.cos(-rotation);\n  let sinAngle = Math.sin(-rotation);\n  let rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;\n  let rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;\n  rotX += (size[0] / 2 - position[0]) * resolution;\n  rotY += (position[1] - size[1] / 2) * resolution;\n\n  // go back to original angle\n  sinAngle = -sinAngle; // go back to original rotation\n  const centerX = rotX * cosAngle - rotY * sinAngle;\n  const centerY = rotY * cosAngle + rotX * sinAngle;\n\n  return [centerX, centerY];\n}\n\nexport default View;\n","/**\n * @module ol/Tile\n */\nimport EventTarget from './events/Target.js';\nimport EventType from './events/EventType.js';\nimport TileState from './TileState.js';\nimport {abstract} from './util.js';\nimport {easeIn} from './easing.js';\n\n/**\n * A function that takes an {@link module:ol/Tile~Tile} for the tile and a\n * `{string}` for the url as arguments. The default is\n * ```js\n * source.setTileLoadFunction(function(tile, src) {\n *   tile.getImage().src = src;\n * });\n * ```\n * For more fine grained control, the load function can use fetch or XMLHttpRequest and involve\n * error handling:\n *\n * ```js\n * import TileState from 'ol/TileState.js';\n *\n * source.setTileLoadFunction(function(tile, src) {\n *   const xhr = new XMLHttpRequest();\n *   xhr.responseType = 'blob';\n *   xhr.addEventListener('loadend', function (evt) {\n *     const data = this.response;\n *     if (data !== undefined) {\n *       tile.getImage().src = URL.createObjectURL(data);\n *     } else {\n *       tile.setState(TileState.ERROR);\n *     }\n *   });\n *   xhr.addEventListener('error', function () {\n *     tile.setState(TileState.ERROR);\n *   });\n *   xhr.open('GET', src);\n *   xhr.send();\n * });\n * ```\n *\n * @typedef {function(Tile, string): void} LoadFunction\n * @api\n */\n\n/**\n * {@link module:ol/source/Tile~TileSource} sources use a function of this type to get\n * the url that provides a tile for a given tile coordinate.\n *\n * This function takes an {@link module:ol/tilecoord~TileCoord} for the tile\n * coordinate, a `{number}` representing the pixel ratio and a\n * {@link module:ol/proj/Projection~Projection} for the projection  as arguments\n * and returns a `{string}` representing the tile URL, or undefined if no tile\n * should be requested for the passed tile coordinate.\n *\n * @typedef {function(import(\"./tilecoord.js\").TileCoord, number,\n *           import(\"./proj/Projection.js\").default): (string|undefined)} UrlFunction\n * @api\n */\n\n/**\n * @typedef {Object} Options\n * @property {number} [transition=250] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n * @api\n */\n\n/**\n * @classdesc\n * Base class for tiles.\n *\n * @abstract\n */\nclass Tile extends EventTarget {\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @param {Options} [options] Tile options.\n   */\n  constructor(tileCoord, state, options) {\n    super();\n\n    options = options ? options : {};\n\n    /**\n     * @type {import(\"./tilecoord.js\").TileCoord}\n     */\n    this.tileCoord = tileCoord;\n\n    /**\n     * @protected\n     * @type {import(\"./TileState.js\").default}\n     */\n    this.state = state;\n\n    /**\n     * An \"interim\" tile for this tile. The interim tile may be used while this\n     * one is loading, for \"smooth\" transitions when changing params/dimensions\n     * on the source.\n     * @type {Tile|null}\n     */\n    this.interimTile = null;\n\n    /**\n     * A key assigned to the tile. This is used by the tile source to determine\n     * if this tile can effectively be used, or if a new tile should be created\n     * and this one be used as an interim tile for this new tile.\n     * @type {string}\n     */\n    this.key = '';\n\n    /**\n     * The duration for the opacity transition.\n     * @type {number}\n     */\n    this.transition_ =\n      options.transition === undefined ? 250 : options.transition;\n\n    /**\n     * Lookup of start times for rendering transitions.  If the start time is\n     * equal to -1, the transition is complete.\n     * @type {Object<string, number>}\n     */\n    this.transitionStarts_ = {};\n\n    /**\n     * @type {boolean}\n     */\n    this.interpolate = !!options.interpolate;\n  }\n\n  /**\n   * @protected\n   */\n  changed() {\n    this.dispatchEvent(EventType.CHANGE);\n  }\n\n  /**\n   * Called by the tile cache when the tile is removed from the cache due to expiry\n   */\n  release() {\n    if (this.state === TileState.ERROR) {\n      // to remove the `change` listener on this tile in `ol/TileQueue#handleTileChange`\n      this.setState(TileState.EMPTY);\n    }\n  }\n\n  /**\n   * @return {string} Key.\n   */\n  getKey() {\n    return this.key + '/' + this.tileCoord;\n  }\n\n  /**\n   * Get the interim tile most suitable for rendering using the chain of interim\n   * tiles. This corresponds to the  most recent tile that has been loaded, if no\n   * such tile exists, the original tile is returned.\n   * @return {!Tile} Best tile for rendering.\n   */\n  getInterimTile() {\n    let tile = this.interimTile;\n    if (!tile) {\n      //empty chain\n      return this;\n    }\n\n    // find the first loaded tile and return it. Since the chain is sorted in\n    // decreasing order of creation time, there is no need to search the remainder\n    // of the list (all those tiles correspond to older requests and will be\n    // cleaned up by refreshInterimChain)\n    do {\n      if (tile.getState() == TileState.LOADED) {\n        // Show tile immediately instead of fading it in after loading, because\n        // the interim tile is in place already\n        this.transition_ = 0;\n        return tile;\n      }\n      tile = tile.interimTile;\n    } while (tile);\n\n    // we can not find a better tile\n    return this;\n  }\n\n  /**\n   * Goes through the chain of interim tiles and discards sections of the chain\n   * that are no longer relevant.\n   */\n  refreshInterimChain() {\n    let tile = this.interimTile;\n    if (!tile) {\n      return;\n    }\n\n    /** @type {Tile} */\n    let prev = this;\n    do {\n      if (tile.getState() == TileState.LOADED) {\n        //we have a loaded tile, we can discard the rest of the list\n        //we would could abort any LOADING tile request\n        //older than this tile (i.e. any LOADING tile following this entry in the chain)\n        tile.interimTile = null;\n        break;\n      }\n      if (tile.getState() == TileState.LOADING) {\n        //keep this LOADING tile any loaded tiles later in the chain are\n        //older than this tile, so we're still interested in the request\n        prev = tile;\n      } else if (tile.getState() == TileState.IDLE) {\n        //the head of the list is the most current tile, we don't need\n        //to start any other requests for this chain\n        prev.interimTile = tile.interimTile;\n      } else {\n        prev = tile;\n      }\n      tile = prev.interimTile;\n    } while (tile);\n  }\n\n  /**\n   * Get the tile coordinate for this tile.\n   * @return {import(\"./tilecoord.js\").TileCoord} The tile coordinate.\n   * @api\n   */\n  getTileCoord() {\n    return this.tileCoord;\n  }\n\n  /**\n   * @return {import(\"./TileState.js\").default} State.\n   */\n  getState() {\n    return this.state;\n  }\n\n  /**\n   * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,\n   * it is important to set the state correctly to {@link module:ol/TileState~ERROR}\n   * when the tile cannot be loaded. Otherwise the tile cannot be removed from\n   * the tile queue and will block other requests.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @api\n   */\n  setState(state) {\n    if (this.state !== TileState.ERROR && this.state > state) {\n      throw new Error('Tile load sequence violation');\n    }\n    this.state = state;\n    this.changed();\n  }\n\n  /**\n   * Load the image or retry if loading previously failed.\n   * Loading is taken care of by the tile queue, and calling this method is\n   * only needed for preloading or for reloading in case of an error.\n   * @abstract\n   * @api\n   */\n  load() {\n    abstract();\n  }\n\n  /**\n   * Get the alpha value for rendering.\n   * @param {string} id An id for the renderer.\n   * @param {number} time The render frame time.\n   * @return {number} A number between 0 and 1.\n   */\n  getAlpha(id, time) {\n    if (!this.transition_) {\n      return 1;\n    }\n\n    let start = this.transitionStarts_[id];\n    if (!start) {\n      start = time;\n      this.transitionStarts_[id] = start;\n    } else if (start === -1) {\n      return 1;\n    }\n\n    const delta = time - start + 1000 / 60; // avoid rendering at 0\n    if (delta >= this.transition_) {\n      return 1;\n    }\n    return easeIn(delta / this.transition_);\n  }\n\n  /**\n   * Determine if a tile is in an alpha transition.  A tile is considered in\n   * transition if tile.getAlpha() has not yet been called or has been called\n   * and returned 1.\n   * @param {string} id An id for the renderer.\n   * @return {boolean} The tile is in transition.\n   */\n  inTransition(id) {\n    if (!this.transition_) {\n      return false;\n    }\n    return this.transitionStarts_[id] !== -1;\n  }\n\n  /**\n   * Mark a transition as complete.\n   * @param {string} id An id for the renderer.\n   */\n  endTransition(id) {\n    if (this.transition_) {\n      this.transitionStarts_[id] = -1;\n    }\n  }\n}\n\nexport default Tile;\n","/**\n * @module ol/TileState\n */\n\n/**\n * @enum {number}\n */\nexport default {\n  IDLE: 0,\n  LOADING: 1,\n  LOADED: 2,\n  /**\n   * Indicates that tile loading failed\n   * @type {number}\n   */\n  ERROR: 3,\n  EMPTY: 4,\n};\n","/**\n * @module ol/Observable\n */\nimport EventTarget from './events/Target.js';\nimport EventType from './events/EventType.js';\nimport {listen, listenOnce, unlistenByKey} from './events.js';\n\n/***\n * @template {string} Type\n * @template {Event|import(\"./events/Event.js\").default} EventClass\n * @template Return\n * @typedef {(type: Type, listener: (event: EventClass) => ?) => Return} OnSignature\n */\n\n/***\n * @template {string} Type\n * @template Return\n * @typedef {(type: Type[], listener: (event: Event|import(\"./events/Event\").default) => ?) => Return extends void ? void : Return[]} CombinedOnSignature\n */\n\n/**\n * @typedef {'change'|'error'} EventTypes\n */\n\n/***\n * @template Return\n * @typedef {OnSignature<EventTypes, import(\"./events/Event.js\").default, Return> & CombinedOnSignature<EventTypes, Return>} ObservableOnSignature\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * An event target providing convenient methods for listener registration\n * and unregistration. A generic `change` event is always available through\n * {@link module:ol/Observable~Observable#changed}.\n *\n * @fires import(\"./events/Event.js\").default\n * @api\n */\nclass Observable extends EventTarget {\n  constructor() {\n    super();\n\n    this.on =\n      /** @type {ObservableOnSignature<import(\"./events\").EventsKey>} */ (\n        this.onInternal\n      );\n\n    this.once =\n      /** @type {ObservableOnSignature<import(\"./events\").EventsKey>} */ (\n        this.onceInternal\n      );\n\n    this.un = /** @type {ObservableOnSignature<void>} */ (this.unInternal);\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.revision_ = 0;\n  }\n\n  /**\n   * Increases the revision counter and dispatches a 'change' event.\n   * @api\n   */\n  changed() {\n    ++this.revision_;\n    this.dispatchEvent(EventType.CHANGE);\n  }\n\n  /**\n   * Get the version number for this object.  Each time the object is modified,\n   * its version number will be incremented.\n   * @return {number} Revision.\n   * @api\n   */\n  getRevision() {\n    return this.revision_;\n  }\n\n  /**\n   * @param {string|Array<string>} type Type.\n   * @param {function((Event|import(\"./events/Event\").default)): ?} listener Listener.\n   * @return {import(\"./events.js\").EventsKey|Array<import(\"./events.js\").EventsKey>} Event key.\n   * @protected\n   */\n  onInternal(type, listener) {\n    if (Array.isArray(type)) {\n      const len = type.length;\n      const keys = new Array(len);\n      for (let i = 0; i < len; ++i) {\n        keys[i] = listen(this, type[i], listener);\n      }\n      return keys;\n    }\n    return listen(this, /** @type {string} */ (type), listener);\n  }\n\n  /**\n   * @param {string|Array<string>} type Type.\n   * @param {function((Event|import(\"./events/Event\").default)): ?} listener Listener.\n   * @return {import(\"./events.js\").EventsKey|Array<import(\"./events.js\").EventsKey>} Event key.\n   * @protected\n   */\n  onceInternal(type, listener) {\n    let key;\n    if (Array.isArray(type)) {\n      const len = type.length;\n      key = new Array(len);\n      for (let i = 0; i < len; ++i) {\n        key[i] = listenOnce(this, type[i], listener);\n      }\n    } else {\n      key = listenOnce(this, /** @type {string} */ (type), listener);\n    }\n    /** @type {Object} */ (listener).ol_key = key;\n    return key;\n  }\n\n  /**\n   * Unlisten for a certain type of event.\n   * @param {string|Array<string>} type Type.\n   * @param {function((Event|import(\"./events/Event\").default)): ?} listener Listener.\n   * @protected\n   */\n  unInternal(type, listener) {\n    const key = /** @type {Object} */ (listener).ol_key;\n    if (key) {\n      unByKey(key);\n    } else if (Array.isArray(type)) {\n      for (let i = 0, ii = type.length; i < ii; ++i) {\n        this.removeEventListener(type[i], listener);\n      }\n    } else {\n      this.removeEventListener(type, listener);\n    }\n  }\n}\n\n/**\n * Listen for a certain type of event.\n * @function\n * @param {string|Array<string>} type The event type or array of event types.\n * @param {function((Event|import(\"./events/Event\").default)): ?} listener The listener function.\n * @return {import(\"./events.js\").EventsKey|Array<import(\"./events.js\").EventsKey>} Unique key for the listener. If\n *     called with an array of event types as the first argument, the return\n *     will be an array of keys.\n * @api\n */\nObservable.prototype.on;\n\n/**\n * Listen once for a certain type of event.\n * @function\n * @param {string|Array<string>} type The event type or array of event types.\n * @param {function((Event|import(\"./events/Event\").default)): ?} listener The listener function.\n * @return {import(\"./events.js\").EventsKey|Array<import(\"./events.js\").EventsKey>} Unique key for the listener. If\n *     called with an array of event types as the first argument, the return\n *     will be an array of keys.\n * @api\n */\nObservable.prototype.once;\n\n/**\n * Unlisten for a certain type of event.\n * @function\n * @param {string|Array<string>} type The event type or array of event types.\n * @param {function((Event|import(\"./events/Event\").default)): ?} listener The listener function.\n * @api\n */\nObservable.prototype.un;\n\n/**\n * Removes an event listener using the key returned by `on()` or `once()`.\n * @param {import(\"./events.js\").EventsKey|Array<import(\"./events.js\").EventsKey>} key The key returned by `on()`\n *     or `once()` (or an array of keys).\n * @api\n */\nexport function unByKey(key) {\n  if (Array.isArray(key)) {\n    for (let i = 0, ii = key.length; i < ii; ++i) {\n      unlistenByKey(key[i]);\n    }\n  } else {\n    unlistenByKey(/** @type {import(\"./events.js\").EventsKey} */ (key));\n  }\n}\n\nexport default Observable;\n","/**\n * @module ol/ObjectEventType\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  /**\n   * Triggered when a property is changed.\n   * @event module:ol/Object.ObjectEvent#propertychange\n   * @api\n   */\n  PROPERTYCHANGE: 'propertychange',\n};\n\n/**\n * @typedef {'propertychange'} Types\n */\n","/**\n * @module ol/Object\n */\nimport Event from './events/Event.js';\nimport ObjectEventType from './ObjectEventType.js';\nimport Observable from './Observable.js';\nimport {getUid} from './util.js';\nimport {isEmpty} from './obj.js';\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/Object~BaseObject} instances are instances of this type.\n */\nexport class ObjectEvent extends Event {\n  /**\n   * @param {string} type The event type.\n   * @param {string} key The property name.\n   * @param {*} oldValue The old value for `key`.\n   */\n  constructor(type, key, oldValue) {\n    super(type);\n\n    /**\n     * The name of the property whose value is changing.\n     * @type {string}\n     * @api\n     */\n    this.key = key;\n\n    /**\n     * The old value. To get the new value use `e.target.get(e.key)` where\n     * `e` is the event object.\n     * @type {*}\n     * @api\n     */\n    this.oldValue = oldValue;\n  }\n}\n\n/***\n * @template Return\n * @typedef {import(\"./Observable\").OnSignature<import(\"./Observable\").EventTypes, import(\"./events/Event.js\").default, Return> &\n *    import(\"./Observable\").OnSignature<import(\"./ObjectEventType\").Types, ObjectEvent, Return> &\n *    import(\"./Observable\").CombinedOnSignature<import(\"./Observable\").EventTypes|import(\"./ObjectEventType\").Types, Return>} ObjectOnSignature\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Most non-trivial classes inherit from this.\n *\n * This extends {@link module:ol/Observable~Observable} with observable\n * properties, where each property is observable as well as the object as a\n * whole.\n *\n * Classes that inherit from this have pre-defined properties, to which you can\n * add your owns. The pre-defined properties are listed in this documentation as\n * 'Observable Properties', and have their own accessors; for example,\n * {@link module:ol/Map~Map} has a `target` property, accessed with\n * `getTarget()` and changed with `setTarget()`. Not all properties are however\n * settable. There are also general-purpose accessors `get()` and `set()`. For\n * example, `get('target')` is equivalent to `getTarget()`.\n *\n * The `set` accessors trigger a change event, and you can monitor this by\n * registering a listener. For example, {@link module:ol/View~View} has a\n * `center` property, so `view.on('change:center', function(evt) {...});` would\n * call the function whenever the value of the center property changes. Within\n * the function, `evt.target` would be the view, so `evt.target.getCenter()`\n * would return the new center.\n *\n * You can add your own observable properties with\n * `object.set('prop', 'value')`, and retrieve that with `object.get('prop')`.\n * You can listen for changes on that property value with\n * `object.on('change:prop', listener)`. You can get a list of all\n * properties with {@link module:ol/Object~BaseObject#getProperties}.\n *\n * Note that the observable properties are separate from standard JS properties.\n * You can, for example, give your map object a title with\n * `map.title='New title'` and with `map.set('title', 'Another title')`. The\n * first will be a `hasOwnProperty`; the second will appear in\n * `getProperties()`. Only the second is observable.\n *\n * Properties can be deleted by using the unset method. E.g.\n * object.unset('foo').\n *\n * @fires ObjectEvent\n * @api\n */\nclass BaseObject extends Observable {\n  /**\n   * @param {Object<string, *>} [values] An object with key-value pairs.\n   */\n  constructor(values) {\n    super();\n\n    /***\n     * @type {ObjectOnSignature<import(\"./events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {ObjectOnSignature<import(\"./events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {ObjectOnSignature<void>}\n     */\n    this.un;\n\n    // Call {@link module:ol/util.getUid} to ensure that the order of objects' ids is\n    // the same as the order in which they were created.  This also helps to\n    // ensure that object properties are always added in the same order, which\n    // helps many JavaScript engines generate faster code.\n    getUid(this);\n\n    /**\n     * @private\n     * @type {Object<string, *>|null}\n     */\n    this.values_ = null;\n\n    if (values !== undefined) {\n      this.setProperties(values);\n    }\n  }\n\n  /**\n   * Gets a value.\n   * @param {string} key Key name.\n   * @return {*} Value.\n   * @api\n   */\n  get(key) {\n    let value;\n    if (this.values_ && this.values_.hasOwnProperty(key)) {\n      value = this.values_[key];\n    }\n    return value;\n  }\n\n  /**\n   * Get a list of object property names.\n   * @return {Array<string>} List of property names.\n   * @api\n   */\n  getKeys() {\n    return (this.values_ && Object.keys(this.values_)) || [];\n  }\n\n  /**\n   * Get an object of all property names and values.\n   * @return {Object<string, *>} Object.\n   * @api\n   */\n  getProperties() {\n    return (this.values_ && Object.assign({}, this.values_)) || {};\n  }\n\n  /**\n   * Get an object of all property names and values.\n   * @return {Object<string, *>?} Object.\n   */\n  getPropertiesInternal() {\n    return this.values_;\n  }\n\n  /**\n   * @return {boolean} The object has properties.\n   */\n  hasProperties() {\n    return !!this.values_;\n  }\n\n  /**\n   * @param {string} key Key name.\n   * @param {*} oldValue Old value.\n   */\n  notify(key, oldValue) {\n    let eventType;\n    eventType = `change:${key}`;\n    if (this.hasListener(eventType)) {\n      this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));\n    }\n    eventType = ObjectEventType.PROPERTYCHANGE;\n    if (this.hasListener(eventType)) {\n      this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));\n    }\n  }\n\n  /**\n   * @param {string} key Key name.\n   * @param {import(\"./events.js\").Listener} listener Listener.\n   */\n  addChangeListener(key, listener) {\n    this.addEventListener(`change:${key}`, listener);\n  }\n\n  /**\n   * @param {string} key Key name.\n   * @param {import(\"./events.js\").Listener} listener Listener.\n   */\n  removeChangeListener(key, listener) {\n    this.removeEventListener(`change:${key}`, listener);\n  }\n\n  /**\n   * Sets a value.\n   * @param {string} key Key name.\n   * @param {*} value Value.\n   * @param {boolean} [silent] Update without triggering an event.\n   * @api\n   */\n  set(key, value, silent) {\n    const values = this.values_ || (this.values_ = {});\n    if (silent) {\n      values[key] = value;\n    } else {\n      const oldValue = values[key];\n      values[key] = value;\n      if (oldValue !== value) {\n        this.notify(key, oldValue);\n      }\n    }\n  }\n\n  /**\n   * Sets a collection of key-value pairs.  Note that this changes any existing\n   * properties and adds new ones (it does not remove any existing properties).\n   * @param {Object<string, *>} values Values.\n   * @param {boolean} [silent] Update without triggering an event.\n   * @api\n   */\n  setProperties(values, silent) {\n    for (const key in values) {\n      this.set(key, values[key], silent);\n    }\n  }\n\n  /**\n   * Apply any properties from another object without triggering events.\n   * @param {BaseObject} source The source object.\n   * @protected\n   */\n  applyProperties(source) {\n    if (!source.values_) {\n      return;\n    }\n    Object.assign(this.values_ || (this.values_ = {}), source.values_);\n  }\n\n  /**\n   * Unsets a property.\n   * @param {string} key Key name.\n   * @param {boolean} [silent] Unset without triggering an event.\n   * @api\n   */\n  unset(key, silent) {\n    if (this.values_ && key in this.values_) {\n      const oldValue = this.values_[key];\n      delete this.values_[key];\n      if (isEmpty(this.values_)) {\n        this.values_ = null;\n      }\n      if (!silent) {\n        this.notify(key, oldValue);\n      }\n    }\n  }\n}\n\nexport default BaseObject;\n","/**\n * @module ol/ViewHint\n */\n\n/**\n * @enum {number}\n */\nexport default {\n  ANIMATING: 0,\n  INTERACTING: 1,\n};\n","/**\n * @module ol/TileQueue\n */\nimport EventType from './events/EventType.js';\nimport PriorityQueue, {DROP} from './structs/PriorityQueue.js';\nimport TileState from './TileState.js';\n\n/**\n * @typedef {function(import(\"./Tile.js\").default, string, import(\"./coordinate.js\").Coordinate, number): number} PriorityFunction\n */\n\nclass TileQueue extends PriorityQueue {\n  /**\n   * @param {PriorityFunction} tilePriorityFunction Tile priority function.\n   * @param {function(): ?} tileChangeCallback Function called on each tile change event.\n   */\n  constructor(tilePriorityFunction, tileChangeCallback) {\n    super(\n      /**\n       * @param {Array} element Element.\n       * @return {number} Priority.\n       */\n      function (element) {\n        return tilePriorityFunction.apply(null, element);\n      },\n      /**\n       * @param {Array} element Element.\n       * @return {string} Key.\n       */\n      function (element) {\n        return /** @type {import(\"./Tile.js\").default} */ (element[0]).getKey();\n      },\n    );\n\n    /** @private */\n    this.boundHandleTileChange_ = this.handleTileChange.bind(this);\n\n    /**\n     * @private\n     * @type {function(): ?}\n     */\n    this.tileChangeCallback_ = tileChangeCallback;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.tilesLoading_ = 0;\n\n    /**\n     * @private\n     * @type {!Object<string,boolean>}\n     */\n    this.tilesLoadingKeys_ = {};\n  }\n\n  /**\n   * @param {Array} element Element.\n   * @return {boolean} The element was added to the queue.\n   */\n  enqueue(element) {\n    const added = super.enqueue(element);\n    if (added) {\n      const tile = element[0];\n      tile.addEventListener(EventType.CHANGE, this.boundHandleTileChange_);\n    }\n    return added;\n  }\n\n  /**\n   * @return {number} Number of tiles loading.\n   */\n  getTilesLoading() {\n    return this.tilesLoading_;\n  }\n\n  /**\n   * @param {import(\"./events/Event.js\").default} event Event.\n   * @protected\n   */\n  handleTileChange(event) {\n    const tile = /** @type {import(\"./Tile.js\").default} */ (event.target);\n    const state = tile.getState();\n    if (\n      state === TileState.LOADED ||\n      state === TileState.ERROR ||\n      state === TileState.EMPTY\n    ) {\n      if (state !== TileState.ERROR) {\n        tile.removeEventListener(EventType.CHANGE, this.boundHandleTileChange_);\n      }\n      const tileKey = tile.getKey();\n      if (tileKey in this.tilesLoadingKeys_) {\n        delete this.tilesLoadingKeys_[tileKey];\n        --this.tilesLoading_;\n      }\n      this.tileChangeCallback_();\n    }\n  }\n\n  /**\n   * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.\n   * @param {number} maxNewLoads Maximum number of new tiles to load.\n   */\n  loadMoreTiles(maxTotalLoading, maxNewLoads) {\n    let newLoads = 0;\n    let state, tile, tileKey;\n    while (\n      this.tilesLoading_ < maxTotalLoading &&\n      newLoads < maxNewLoads &&\n      this.getCount() > 0\n    ) {\n      tile = /** @type {import(\"./Tile.js\").default} */ (this.dequeue()[0]);\n      tileKey = tile.getKey();\n      state = tile.getState();\n      if (state === TileState.IDLE && !(tileKey in this.tilesLoadingKeys_)) {\n        this.tilesLoadingKeys_[tileKey] = true;\n        ++this.tilesLoading_;\n        ++newLoads;\n        tile.load();\n      }\n    }\n  }\n}\n\nexport default TileQueue;\n\n/**\n * @param {import('./Map.js').FrameState} frameState Frame state.\n * @param {import(\"./Tile.js\").default} tile Tile.\n * @param {string} tileSourceKey Tile source key.\n * @param {import(\"./coordinate.js\").Coordinate} tileCenter Tile center.\n * @param {number} tileResolution Tile resolution.\n * @return {number} Tile priority.\n */\nexport function getTilePriority(\n  frameState,\n  tile,\n  tileSourceKey,\n  tileCenter,\n  tileResolution,\n) {\n  // Filter out tiles at higher zoom levels than the current zoom level, or that\n  // are outside the visible extent.\n  if (!frameState || !(tileSourceKey in frameState.wantedTiles)) {\n    return DROP;\n  }\n  if (!frameState.wantedTiles[tileSourceKey][tile.getKey()]) {\n    return DROP;\n  }\n  // Prioritize the highest zoom level tiles closest to the focus.\n  // Tiles at higher zoom levels are prioritized using Math.log(tileResolution).\n  // Within a zoom level, tiles are prioritized by the distance in pixels between\n  // the center of the tile and the center of the viewport.  The factor of 65536\n  // means that the prioritization should behave as desired for tiles up to\n  // 65536 * Math.log(2) = 45426 pixels from the focus.\n  const center = frameState.viewState.center;\n  const deltaX = tileCenter[0] - center[0];\n  const deltaY = tileCenter[1] - center[1];\n  return (\n    65536 * Math.log(tileResolution) +\n    Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution\n  );\n}\n","/**\n * @module ol/Map\n */\nimport BaseObject from './Object.js';\nimport Collection from './Collection.js';\nimport CollectionEventType from './CollectionEventType.js';\nimport CompositeMapRenderer from './renderer/Composite.js';\nimport EventType from './events/EventType.js';\nimport Layer from './layer/Layer.js';\nimport LayerGroup, {GroupEvent} from './layer/Group.js';\nimport MapBrowserEvent from './MapBrowserEvent.js';\nimport MapBrowserEventHandler from './MapBrowserEventHandler.js';\nimport MapBrowserEventType from './MapBrowserEventType.js';\nimport MapEvent from './MapEvent.js';\nimport MapEventType from './MapEventType.js';\nimport MapProperty from './MapProperty.js';\nimport ObjectEventType from './ObjectEventType.js';\nimport PointerEventType from './pointer/EventType.js';\nimport RenderEventType from './render/EventType.js';\nimport TileQueue, {getTilePriority} from './TileQueue.js';\nimport View from './View.js';\nimport ViewHint from './ViewHint.js';\nimport {DEVICE_PIXEL_RATIO, PASSIVE_EVENT_LISTENERS} from './has.js';\nimport {TRUE} from './functions.js';\nimport {\n  apply as applyTransform,\n  create as createTransform,\n} from './transform.js';\nimport {assert} from './asserts.js';\nimport {\n  clone,\n  createOrUpdateEmpty,\n  equals as equalsExtent,\n  getForViewAndSize,\n  isEmpty,\n} from './extent.js';\nimport {defaults as defaultControls} from './control/defaults.js';\nimport {defaults as defaultInteractions} from './interaction/defaults.js';\nimport {equals} from './array.js';\nimport {fromUserCoordinate, toUserCoordinate} from './proj.js';\nimport {getUid} from './util.js';\nimport {hasArea} from './size.js';\nimport {listen, unlistenByKey} from './events.js';\nimport {removeNode} from './dom.js';\nimport {warn} from './console.js';\n\n/**\n * State of the current frame. Only `pixelRatio`, `time` and `viewState` should\n * be used in applications.\n * @typedef {Object} FrameState\n * @property {number} pixelRatio The pixel ratio of the frame.\n * @property {number} time The time when rendering of the frame was requested.\n * @property {import(\"./View.js\").State} viewState The state of the current view.\n * @property {boolean} animate Animate.\n * @property {import(\"./transform.js\").Transform} coordinateToPixelTransform CoordinateToPixelTransform.\n * @property {Object<string, import(\"rbush\").default>|null} declutter Declutter trees by declutter group.\n * When null, no decluttering is needed because no layers have decluttering enabled.\n * @property {null|import(\"./extent.js\").Extent} extent Extent (in view projection coordinates).\n * @property {import(\"./extent.js\").Extent} [nextExtent] Next extent during an animation series.\n * @property {number} index Index.\n * @property {Array<import(\"./layer/Layer.js\").State>} layerStatesArray LayerStatesArray.\n * @property {number} layerIndex LayerIndex.\n * @property {import(\"./transform.js\").Transform} pixelToCoordinateTransform PixelToCoordinateTransform.\n * @property {Array<PostRenderFunction>} postRenderFunctions PostRenderFunctions.\n * @property {import(\"./size.js\").Size} size Size.\n * @property {TileQueue} tileQueue TileQueue.\n * @property {!Object<string, Object<string, boolean>>} usedTiles UsedTiles.\n * @property {Array<number>} viewHints ViewHints.\n * @property {!Object<string, Object<string, boolean>>} wantedTiles WantedTiles.\n * @property {string} mapId The id of the map.\n * @property {Object<string, boolean>} renderTargets Identifiers of previously rendered elements.\n */\n\n/**\n * @typedef {function(Map, ?FrameState): any} PostRenderFunction\n */\n\n/**\n * @typedef {Object} AtPixelOptions\n * @property {undefined|function(import(\"./layer/Layer.js\").default<import(\"./source/Source\").default>): boolean} [layerFilter] Layer filter\n * function. The filter function will receive one argument, the\n * {@link module:ol/layer/Layer~Layer layer-candidate} and it should return a boolean value.\n * Only layers which are visible and for which this function returns `true`\n * will be tested for features. By default, all visible layers will be tested.\n * @property {number} [hitTolerance=0] Hit-detection tolerance in css pixels. Pixels\n * inside the radius around the given position will be checked for features.\n * @property {boolean} [checkWrapped=true] Check-Wrapped Will check for wrapped geometries inside the range of\n *   +/- 1 world width. Works only if a projection is used that can be wrapped.\n */\n\n/**\n * @typedef {Object} MapOptionsInternal\n * @property {Collection<import(\"./control/Control.js\").default>} [controls] Controls.\n * @property {Collection<import(\"./interaction/Interaction.js\").default>} [interactions] Interactions.\n * @property {HTMLElement|Document} keyboardEventTarget KeyboardEventTarget.\n * @property {Collection<import(\"./Overlay.js\").default>} overlays Overlays.\n * @property {Object<string, *>} values Values.\n */\n\n/**\n * @typedef {import(\"./ObjectEventType\").Types|'change:layergroup'|'change:size'|'change:target'|'change:view'} MapObjectEventTypes\n */\n\n/***\n * @template Return\n * @typedef {import(\"./Observable\").OnSignature<import(\"./Observable\").EventTypes, import(\"./events/Event.js\").default, Return> &\n *    import(\"./Observable\").OnSignature<MapObjectEventTypes, import(\"./Object\").ObjectEvent, Return> &\n *    import(\"./Observable\").OnSignature<import(\"./MapBrowserEventType\").Types, import(\"./MapBrowserEvent\").default, Return> &\n *    import(\"./Observable\").OnSignature<import(\"./MapEventType\").Types, import(\"./MapEvent\").default, Return> &\n *    import(\"./Observable\").OnSignature<import(\"./render/EventType\").MapRenderEventTypes, import(\"./render/Event\").default, Return> &\n *    import(\"./Observable\").CombinedOnSignature<import(\"./Observable\").EventTypes|MapObjectEventTypes|\n *      import(\"./MapBrowserEventType\").Types|import(\"./MapEventType\").Types|\n *      import(\"./render/EventType\").MapRenderEventTypes, Return>} MapEventHandler\n */\n\n/**\n * Object literal with config options for the map.\n * @typedef {Object} MapOptions\n * @property {Collection<import(\"./control/Control.js\").default>|Array<import(\"./control/Control.js\").default>} [controls]\n * Controls initially added to the map. If not specified,\n * {@link module:ol/control/defaults.defaults} is used.\n * @property {number} [pixelRatio=window.devicePixelRatio] The ratio between\n * physical pixels and device-independent pixels (dips) on the device.\n * @property {Collection<import(\"./interaction/Interaction.js\").default>|Array<import(\"./interaction/Interaction.js\").default>} [interactions]\n * Interactions that are initially added to the map. If not specified,\n * {@link module:ol/interaction/defaults.defaults} is used.\n * @property {HTMLElement|Document|string} [keyboardEventTarget] The element to\n * listen to keyboard events on. This determines when the `KeyboardPan` and\n * `KeyboardZoom` interactions trigger. For example, if this option is set to\n * `document` the keyboard interactions will always trigger. If this option is\n * not specified, the element the library listens to keyboard events on is the\n * map target (i.e. the user-provided div for the map). If this is not\n * `document`, the target element needs to be focused for key events to be\n * emitted, requiring that the target element has a `tabindex` attribute.\n * @property {Array<import(\"./layer/Base.js\").default>|Collection<import(\"./layer/Base.js\").default>|LayerGroup} [layers]\n * Layers. If this is not defined, a map with no layers will be rendered. Note\n * that layers are rendered in the order supplied, so if you want, for example,\n * a vector layer to appear on top of a tile layer, it must come after the tile\n * layer.\n * @property {number} [maxTilesLoading=16] Maximum number tiles to load\n * simultaneously.\n * @property {number} [moveTolerance=1] The minimum distance in pixels the\n * cursor must move to be detected as a map move event instead of a click.\n * Increasing this value can make it easier to click on the map.\n * @property {Collection<import(\"./Overlay.js\").default>|Array<import(\"./Overlay.js\").default>} [overlays]\n * Overlays initially added to the map. By default, no overlays are added.\n * @property {HTMLElement|string} [target] The container for the map, either the\n * element itself or the `id` of the element. If not specified at construction\n * time, {@link module:ol/Map~Map#setTarget} must be called for the map to be\n * rendered. If passed by element, the container can be in a secondary document.\n * **Note:** CSS `transform` support for the target element is limited to `scale`.\n * @property {View|Promise<import(\"./View.js\").ViewOptions>} [view] The map's view.  No layer sources will be\n * fetched unless this is specified at construction time or through\n * {@link module:ol/Map~Map#setView}.\n */\n\n/**\n * @param {import(\"./layer/Base.js\").default} layer Layer.\n */\nfunction removeLayerMapProperty(layer) {\n  if (layer instanceof Layer) {\n    layer.setMapInternal(null);\n    return;\n  }\n  if (layer instanceof LayerGroup) {\n    layer.getLayers().forEach(removeLayerMapProperty);\n  }\n}\n\n/**\n * @param {import(\"./layer/Base.js\").default} layer Layer.\n * @param {Map} map Map.\n */\nfunction setLayerMapProperty(layer, map) {\n  if (layer instanceof Layer) {\n    layer.setMapInternal(map);\n    return;\n  }\n  if (layer instanceof LayerGroup) {\n    const layers = layer.getLayers().getArray();\n    for (let i = 0, ii = layers.length; i < ii; ++i) {\n      setLayerMapProperty(layers[i], map);\n    }\n  }\n}\n\n/**\n * @classdesc\n * The map is the core component of OpenLayers. For a map to render, a view,\n * one or more layers, and a target container are needed:\n *\n *     import Map from 'ol/Map.js';\n *     import View from 'ol/View.js';\n *     import TileLayer from 'ol/layer/Tile.js';\n *     import OSM from 'ol/source/OSM.js';\n *\n *     const map = new Map({\n *       view: new View({\n *         center: [0, 0],\n *         zoom: 1,\n *       }),\n *       layers: [\n *         new TileLayer({\n *           source: new OSM(),\n *         }),\n *       ],\n *       target: 'map',\n *     });\n *\n * The above snippet creates a map using a {@link module:ol/layer/Tile~TileLayer} to\n * display {@link module:ol/source/OSM~OSM} OSM data and render it to a DOM\n * element with the id `map`.\n *\n * The constructor places a viewport container (with CSS class name\n * `ol-viewport`) in the target element (see `getViewport()`), and then two\n * further elements within the viewport: one with CSS class name\n * `ol-overlaycontainer-stopevent` for controls and some overlays, and one with\n * CSS class name `ol-overlaycontainer` for other overlays (see the `stopEvent`\n * option of {@link module:ol/Overlay~Overlay} for the difference). The map\n * itself is placed in a further element within the viewport.\n *\n * Layers are stored as a {@link module:ol/Collection~Collection} in\n * layerGroups. A top-level group is provided by the library. This is what is\n * accessed by `getLayerGroup` and `setLayerGroup`. Layers entered in the\n * options are added to this group, and `addLayer` and `removeLayer` change the\n * layer collection in the group. `getLayers` is a convenience function for\n * `getLayerGroup().getLayers()`. Note that {@link module:ol/layer/Group~LayerGroup}\n * is a subclass of {@link module:ol/layer/Base~BaseLayer}, so layers entered in the\n * options or added with `addLayer` can be groups, which can contain further\n * groups, and so on.\n *\n * @fires import(\"./MapBrowserEvent.js\").MapBrowserEvent\n * @fires import(\"./MapEvent.js\").MapEvent\n * @fires import(\"./render/Event.js\").default#precompose\n * @fires import(\"./render/Event.js\").default#postcompose\n * @fires import(\"./render/Event.js\").default#rendercomplete\n * @api\n */\nclass Map extends BaseObject {\n  /**\n   * @param {MapOptions} [options] Map options.\n   */\n  constructor(options) {\n    super();\n\n    options = options || {};\n\n    /***\n     * @type {MapEventHandler<import(\"./events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {MapEventHandler<import(\"./events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {MapEventHandler<void>}\n     */\n    this.un;\n\n    const optionsInternal = createOptionsInternal(options);\n\n    /**\n     * @private\n     * @type {boolean|undefined}\n     */\n    this.renderComplete_;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.loaded_ = true;\n\n    /** @private */\n    this.boundHandleBrowserEvent_ = this.handleBrowserEvent.bind(this);\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.maxTilesLoading_ =\n      options.maxTilesLoading !== undefined ? options.maxTilesLoading : 16;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ =\n      options.pixelRatio !== undefined\n        ? options.pixelRatio\n        : DEVICE_PIXEL_RATIO;\n\n    /**\n     * @private\n     * @type {ReturnType<typeof setTimeout>}\n     */\n    this.postRenderTimeoutHandle_;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.animationDelayKey_;\n\n    /**\n     * @private\n     */\n    this.animationDelay_ = this.animationDelay_.bind(this);\n\n    /**\n     * @private\n     * @type {import(\"./transform.js\").Transform}\n     */\n    this.coordinateToPixelTransform_ = createTransform();\n\n    /**\n     * @private\n     * @type {import(\"./transform.js\").Transform}\n     */\n    this.pixelToCoordinateTransform_ = createTransform();\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.frameIndex_ = 0;\n\n    /**\n     * @private\n     * @type {?FrameState}\n     */\n    this.frameState_ = null;\n\n    /**\n     * The extent at the previous 'moveend' event.\n     * @private\n     * @type {import(\"./extent.js\").Extent}\n     */\n    this.previousExtent_ = null;\n\n    /**\n     * @private\n     * @type {?import(\"./events.js\").EventsKey}\n     */\n    this.viewPropertyListenerKey_ = null;\n\n    /**\n     * @private\n     * @type {?import(\"./events.js\").EventsKey}\n     */\n    this.viewChangeListenerKey_ = null;\n\n    /**\n     * @private\n     * @type {?Array<import(\"./events.js\").EventsKey>}\n     */\n    this.layerGroupPropertyListenerKeys_ = null;\n\n    /**\n     * @private\n     * @type {!HTMLElement}\n     */\n    this.viewport_ = document.createElement('div');\n    this.viewport_.className =\n      'ol-viewport' + ('ontouchstart' in window ? ' ol-touch' : '');\n    this.viewport_.style.position = 'relative';\n    this.viewport_.style.overflow = 'hidden';\n    this.viewport_.style.width = '100%';\n    this.viewport_.style.height = '100%';\n\n    /**\n     * @private\n     * @type {!HTMLElement}\n     */\n    this.overlayContainer_ = document.createElement('div');\n    this.overlayContainer_.style.position = 'absolute';\n    this.overlayContainer_.style.zIndex = '0';\n    this.overlayContainer_.style.width = '100%';\n    this.overlayContainer_.style.height = '100%';\n    this.overlayContainer_.style.pointerEvents = 'none';\n    this.overlayContainer_.className = 'ol-overlaycontainer';\n    this.viewport_.appendChild(this.overlayContainer_);\n\n    /**\n     * @private\n     * @type {!HTMLElement}\n     */\n    this.overlayContainerStopEvent_ = document.createElement('div');\n    this.overlayContainerStopEvent_.style.position = 'absolute';\n    this.overlayContainerStopEvent_.style.zIndex = '0';\n    this.overlayContainerStopEvent_.style.width = '100%';\n    this.overlayContainerStopEvent_.style.height = '100%';\n    this.overlayContainerStopEvent_.style.pointerEvents = 'none';\n    this.overlayContainerStopEvent_.className = 'ol-overlaycontainer-stopevent';\n    this.viewport_.appendChild(this.overlayContainerStopEvent_);\n\n    /**\n     * @private\n     * @type {MapBrowserEventHandler}\n     */\n    this.mapBrowserEventHandler_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.moveTolerance_ = options.moveTolerance;\n\n    /**\n     * @private\n     * @type {HTMLElement|Document}\n     */\n    this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;\n\n    /**\n     * @private\n     * @type {?Array<import(\"./events.js\").EventsKey>}\n     */\n    this.targetChangeHandlerKeys_ = null;\n\n    /**\n     * @private\n     * @type {HTMLElement|null}\n     */\n    this.targetElement_ = null;\n\n    /**\n     * @type {ResizeObserver}\n     */\n    this.resizeObserver_ = new ResizeObserver(() => this.updateSize());\n\n    /**\n     * @type {Collection<import(\"./control/Control.js\").default>}\n     * @protected\n     */\n    this.controls = optionsInternal.controls || defaultControls();\n\n    /**\n     * @type {Collection<import(\"./interaction/Interaction.js\").default>}\n     * @protected\n     */\n    this.interactions =\n      optionsInternal.interactions ||\n      defaultInteractions({\n        onFocusOnly: true,\n      });\n\n    /**\n     * @type {Collection<import(\"./Overlay.js\").default>}\n     * @private\n     */\n    this.overlays_ = optionsInternal.overlays;\n\n    /**\n     * A lookup of overlays by id.\n     * @private\n     * @type {Object<string, import(\"./Overlay.js\").default>}\n     */\n    this.overlayIdIndex_ = {};\n\n    /**\n     * @type {import(\"./renderer/Map.js\").default|null}\n     * @private\n     */\n    this.renderer_ = null;\n\n    /**\n     * @private\n     * @type {!Array<PostRenderFunction>}\n     */\n    this.postRenderFunctions_ = [];\n\n    /**\n     * @private\n     * @type {TileQueue}\n     */\n    this.tileQueue_ = new TileQueue(\n      this.getTilePriority.bind(this),\n      this.handleTileChange_.bind(this),\n    );\n\n    this.addChangeListener(\n      MapProperty.LAYERGROUP,\n      this.handleLayerGroupChanged_,\n    );\n    this.addChangeListener(MapProperty.VIEW, this.handleViewChanged_);\n    this.addChangeListener(MapProperty.SIZE, this.handleSizeChanged_);\n    this.addChangeListener(MapProperty.TARGET, this.handleTargetChanged_);\n\n    // setProperties will trigger the rendering of the map if the map\n    // is \"defined\" already.\n    this.setProperties(optionsInternal.values);\n\n    const map = this;\n    if (options.view && !(options.view instanceof View)) {\n      options.view.then(function (viewOptions) {\n        map.setView(new View(viewOptions));\n      });\n    }\n\n    this.controls.addEventListener(\n      CollectionEventType.ADD,\n      /**\n       * @param {import(\"./Collection.js\").CollectionEvent<import(\"./control/Control.js\").default>} event CollectionEvent\n       */\n      (event) => {\n        event.element.setMap(this);\n      },\n    );\n\n    this.controls.addEventListener(\n      CollectionEventType.REMOVE,\n      /**\n       * @param {import(\"./Collection.js\").CollectionEvent<import(\"./control/Control.js\").default>} event CollectionEvent.\n       */\n      (event) => {\n        event.element.setMap(null);\n      },\n    );\n\n    this.interactions.addEventListener(\n      CollectionEventType.ADD,\n      /**\n       * @param {import(\"./Collection.js\").CollectionEvent<import(\"./interaction/Interaction.js\").default>} event CollectionEvent.\n       */\n      (event) => {\n        event.element.setMap(this);\n      },\n    );\n\n    this.interactions.addEventListener(\n      CollectionEventType.REMOVE,\n      /**\n       * @param {import(\"./Collection.js\").CollectionEvent<import(\"./interaction/Interaction.js\").default>} event CollectionEvent.\n       */\n      (event) => {\n        event.element.setMap(null);\n      },\n    );\n\n    this.overlays_.addEventListener(\n      CollectionEventType.ADD,\n      /**\n       * @param {import(\"./Collection.js\").CollectionEvent<import(\"./Overlay.js\").default>} event CollectionEvent.\n       */\n      (event) => {\n        this.addOverlayInternal_(event.element);\n      },\n    );\n\n    this.overlays_.addEventListener(\n      CollectionEventType.REMOVE,\n      /**\n       * @param {import(\"./Collection.js\").CollectionEvent<import(\"./Overlay.js\").default>} event CollectionEvent.\n       */\n      (event) => {\n        const id = event.element.getId();\n        if (id !== undefined) {\n          delete this.overlayIdIndex_[id.toString()];\n        }\n        event.element.setMap(null);\n      },\n    );\n\n    this.controls.forEach(\n      /**\n       * @param {import(\"./control/Control.js\").default} control Control.\n       */\n      (control) => {\n        control.setMap(this);\n      },\n    );\n\n    this.interactions.forEach(\n      /**\n       * @param {import(\"./interaction/Interaction.js\").default} interaction Interaction.\n       */\n      (interaction) => {\n        interaction.setMap(this);\n      },\n    );\n\n    this.overlays_.forEach(this.addOverlayInternal_.bind(this));\n  }\n\n  /**\n   * Add the given control to the map.\n   * @param {import(\"./control/Control.js\").default} control Control.\n   * @api\n   */\n  addControl(control) {\n    this.getControls().push(control);\n  }\n\n  /**\n   * Add the given interaction to the map. If you want to add an interaction\n   * at another point of the collection use `getInteractions()` and the methods\n   * available on {@link module:ol/Collection~Collection}. This can be used to\n   * stop the event propagation from the handleEvent function. The interactions\n   * get to handle the events in the reverse order of this collection.\n   * @param {import(\"./interaction/Interaction.js\").default} interaction Interaction to add.\n   * @api\n   */\n  addInteraction(interaction) {\n    this.getInteractions().push(interaction);\n  }\n\n  /**\n   * Adds the given layer to the top of this map. If you want to add a layer\n   * elsewhere in the stack, use `getLayers()` and the methods available on\n   * {@link module:ol/Collection~Collection}.\n   * @param {import(\"./layer/Base.js\").default} layer Layer.\n   * @api\n   */\n  addLayer(layer) {\n    const layers = this.getLayerGroup().getLayers();\n    layers.push(layer);\n  }\n\n  /**\n   * @param {import(\"./layer/Group.js\").GroupEvent} event The layer add event.\n   * @private\n   */\n  handleLayerAdd_(event) {\n    setLayerMapProperty(event.layer, this);\n  }\n\n  /**\n   * Add the given overlay to the map.\n   * @param {import(\"./Overlay.js\").default} overlay Overlay.\n   * @api\n   */\n  addOverlay(overlay) {\n    this.getOverlays().push(overlay);\n  }\n\n  /**\n   * This deals with map's overlay collection changes.\n   * @param {import(\"./Overlay.js\").default} overlay Overlay.\n   * @private\n   */\n  addOverlayInternal_(overlay) {\n    const id = overlay.getId();\n    if (id !== undefined) {\n      this.overlayIdIndex_[id.toString()] = overlay;\n    }\n    overlay.setMap(this);\n  }\n\n  /**\n   *\n   * Clean up.\n   */\n  disposeInternal() {\n    this.controls.clear();\n    this.interactions.clear();\n    this.overlays_.clear();\n    this.resizeObserver_.disconnect();\n    this.setTarget(null);\n    super.disposeInternal();\n  }\n\n  /**\n   * Detect features that intersect a pixel on the viewport, and execute a\n   * callback with each intersecting feature. Layers included in the detection can\n   * be configured through the `layerFilter` option in `options`.\n   * @param {import(\"./pixel.js\").Pixel} pixel Pixel.\n   * @param {function(import(\"./Feature.js\").FeatureLike, import(\"./layer/Layer.js\").default<import(\"./source/Source\").default>, import(\"./geom/SimpleGeometry.js\").default): T} callback Feature callback. The callback will be\n   *     called with two arguments. The first argument is one\n   *     {@link module:ol/Feature~Feature feature} or\n   *     {@link module:ol/render/Feature~RenderFeature render feature} at the pixel, the second is\n   *     the {@link module:ol/layer/Layer~Layer layer} of the feature and will be null for\n   *     unmanaged layers. To stop detection, callback functions can return a\n   *     truthy value.\n   * @param {AtPixelOptions} [options] Optional options.\n   * @return {T|undefined} Callback result, i.e. the return value of last\n   * callback execution, or the first truthy callback return value.\n   * @template T\n   * @api\n   */\n  forEachFeatureAtPixel(pixel, callback, options) {\n    if (!this.frameState_ || !this.renderer_) {\n      return;\n    }\n    const coordinate = this.getCoordinateFromPixelInternal(pixel);\n    options = options !== undefined ? options : {};\n    const hitTolerance =\n      options.hitTolerance !== undefined ? options.hitTolerance : 0;\n    const layerFilter =\n      options.layerFilter !== undefined ? options.layerFilter : TRUE;\n    const checkWrapped = options.checkWrapped !== false;\n    return this.renderer_.forEachFeatureAtCoordinate(\n      coordinate,\n      this.frameState_,\n      hitTolerance,\n      checkWrapped,\n      callback,\n      null,\n      layerFilter,\n      null,\n    );\n  }\n\n  /**\n   * Get all features that intersect a pixel on the viewport.\n   * @param {import(\"./pixel.js\").Pixel} pixel Pixel.\n   * @param {AtPixelOptions} [options] Optional options.\n   * @return {Array<import(\"./Feature.js\").FeatureLike>} The detected features or\n   * an empty array if none were found.\n   * @api\n   */\n  getFeaturesAtPixel(pixel, options) {\n    const features = [];\n    this.forEachFeatureAtPixel(\n      pixel,\n      function (feature) {\n        features.push(feature);\n      },\n      options,\n    );\n    return features;\n  }\n\n  /**\n   * Get all layers from all layer groups.\n   * @return {Array<import(\"./layer/Layer.js\").default>} Layers.\n   * @api\n   */\n  getAllLayers() {\n    const layers = [];\n    function addLayersFrom(layerGroup) {\n      layerGroup.forEach(function (layer) {\n        if (layer instanceof LayerGroup) {\n          addLayersFrom(layer.getLayers());\n        } else {\n          layers.push(layer);\n        }\n      });\n    }\n    addLayersFrom(this.getLayers());\n    return layers;\n  }\n\n  /**\n   * Detect if features intersect a pixel on the viewport. Layers included in the\n   * detection can be configured through the `layerFilter` option.\n   * @param {import(\"./pixel.js\").Pixel} pixel Pixel.\n   * @param {AtPixelOptions} [options] Optional options.\n   * @return {boolean} Is there a feature at the given pixel?\n   * @api\n   */\n  hasFeatureAtPixel(pixel, options) {\n    if (!this.frameState_ || !this.renderer_) {\n      return false;\n    }\n    const coordinate = this.getCoordinateFromPixelInternal(pixel);\n    options = options !== undefined ? options : {};\n    const layerFilter =\n      options.layerFilter !== undefined ? options.layerFilter : TRUE;\n    const hitTolerance =\n      options.hitTolerance !== undefined ? options.hitTolerance : 0;\n    const checkWrapped = options.checkWrapped !== false;\n    return this.renderer_.hasFeatureAtCoordinate(\n      coordinate,\n      this.frameState_,\n      hitTolerance,\n      checkWrapped,\n      layerFilter,\n      null,\n    );\n  }\n\n  /**\n   * Returns the coordinate in user projection for a browser event.\n   * @param {MouseEvent} event Event.\n   * @return {import(\"./coordinate.js\").Coordinate} Coordinate.\n   * @api\n   */\n  getEventCoordinate(event) {\n    return this.getCoordinateFromPixel(this.getEventPixel(event));\n  }\n\n  /**\n   * Returns the coordinate in view projection for a browser event.\n   * @param {MouseEvent} event Event.\n   * @return {import(\"./coordinate.js\").Coordinate} Coordinate.\n   */\n  getEventCoordinateInternal(event) {\n    return this.getCoordinateFromPixelInternal(this.getEventPixel(event));\n  }\n\n  /**\n   * Returns the map pixel position for a browser event relative to the viewport.\n   * @param {UIEvent|{clientX: number, clientY: number}} event Event.\n   * @return {import(\"./pixel.js\").Pixel} Pixel.\n   * @api\n   */\n  getEventPixel(event) {\n    const viewport = this.viewport_;\n    const viewportPosition = viewport.getBoundingClientRect();\n    const viewportSize = this.getSize();\n    const scaleX = viewportPosition.width / viewportSize[0];\n    const scaleY = viewportPosition.height / viewportSize[1];\n    const eventPosition =\n      //FIXME Are we really calling this with a TouchEvent anywhere?\n      'changedTouches' in event\n        ? /** @type {TouchEvent} */ (event).changedTouches[0]\n        : /** @type {MouseEvent} */ (event);\n\n    return [\n      (eventPosition.clientX - viewportPosition.left) / scaleX,\n      (eventPosition.clientY - viewportPosition.top) / scaleY,\n    ];\n  }\n\n  /**\n   * Get the target in which this map is rendered.\n   * Note that this returns what is entered as an option or in setTarget:\n   * if that was an element, it returns an element; if a string, it returns that.\n   * @return {HTMLElement|string|undefined} The Element or id of the Element that the\n   *     map is rendered in.\n   * @observable\n   * @api\n   */\n  getTarget() {\n    return /** @type {HTMLElement|string|undefined} */ (\n      this.get(MapProperty.TARGET)\n    );\n  }\n\n  /**\n   * Get the DOM element into which this map is rendered. In contrast to\n   * `getTarget` this method always return an `Element`, or `null` if the\n   * map has no target.\n   * @return {HTMLElement} The element that the map is rendered in.\n   * @api\n   */\n  getTargetElement() {\n    return this.targetElement_;\n  }\n\n  /**\n   * Get the coordinate for a given pixel.  This returns a coordinate in the\n   * user projection.\n   * @param {import(\"./pixel.js\").Pixel} pixel Pixel position in the map viewport.\n   * @return {import(\"./coordinate.js\").Coordinate} The coordinate for the pixel position.\n   * @api\n   */\n  getCoordinateFromPixel(pixel) {\n    return toUserCoordinate(\n      this.getCoordinateFromPixelInternal(pixel),\n      this.getView().getProjection(),\n    );\n  }\n\n  /**\n   * Get the coordinate for a given pixel.  This returns a coordinate in the\n   * map view projection.\n   * @param {import(\"./pixel.js\").Pixel} pixel Pixel position in the map viewport.\n   * @return {import(\"./coordinate.js\").Coordinate} The coordinate for the pixel position.\n   */\n  getCoordinateFromPixelInternal(pixel) {\n    const frameState = this.frameState_;\n    if (!frameState) {\n      return null;\n    }\n    return applyTransform(frameState.pixelToCoordinateTransform, pixel.slice());\n  }\n\n  /**\n   * Get the map controls. Modifying this collection changes the controls\n   * associated with the map.\n   * @return {Collection<import(\"./control/Control.js\").default>} Controls.\n   * @api\n   */\n  getControls() {\n    return this.controls;\n  }\n\n  /**\n   * Get the map overlays. Modifying this collection changes the overlays\n   * associated with the map.\n   * @return {Collection<import(\"./Overlay.js\").default>} Overlays.\n   * @api\n   */\n  getOverlays() {\n    return this.overlays_;\n  }\n\n  /**\n   * Get an overlay by its identifier (the value returned by overlay.getId()).\n   * Note that the index treats string and numeric identifiers as the same. So\n   * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.\n   * @param {string|number} id Overlay identifier.\n   * @return {import(\"./Overlay.js\").default|null} Overlay.\n   * @api\n   */\n  getOverlayById(id) {\n    const overlay = this.overlayIdIndex_[id.toString()];\n    return overlay !== undefined ? overlay : null;\n  }\n\n  /**\n   * Get the map interactions. Modifying this collection changes the interactions\n   * associated with the map.\n   *\n   * Interactions are used for e.g. pan, zoom and rotate.\n   * @return {Collection<import(\"./interaction/Interaction.js\").default>} Interactions.\n   * @api\n   */\n  getInteractions() {\n    return this.interactions;\n  }\n\n  /**\n   * Get the layergroup associated with this map.\n   * @return {LayerGroup} A layer group containing the layers in this map.\n   * @observable\n   * @api\n   */\n  getLayerGroup() {\n    return /** @type {LayerGroup} */ (this.get(MapProperty.LAYERGROUP));\n  }\n\n  /**\n   * Clear any existing layers and add layers to the map.\n   * @param {Array<import(\"./layer/Base.js\").default>|Collection<import(\"./layer/Base.js\").default>} layers The layers to be added to the map.\n   * @api\n   */\n  setLayers(layers) {\n    const group = this.getLayerGroup();\n    if (layers instanceof Collection) {\n      group.setLayers(layers);\n      return;\n    }\n\n    const collection = group.getLayers();\n    collection.clear();\n    collection.extend(layers);\n  }\n\n  /**\n   * Get the collection of layers associated with this map.\n   * @return {!Collection<import(\"./layer/Base.js\").default>} Layers.\n   * @api\n   */\n  getLayers() {\n    const layers = this.getLayerGroup().getLayers();\n    return layers;\n  }\n\n  /**\n   * @return {boolean} Layers have sources that are still loading.\n   */\n  getLoadingOrNotReady() {\n    const layerStatesArray = this.getLayerGroup().getLayerStatesArray();\n    for (let i = 0, ii = layerStatesArray.length; i < ii; ++i) {\n      const state = layerStatesArray[i];\n      if (!state.visible) {\n        continue;\n      }\n      const renderer = state.layer.getRenderer();\n      if (renderer && !renderer.ready) {\n        return true;\n      }\n      const source = state.layer.getSource();\n      if (source && source.loading) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Get the pixel for a coordinate.  This takes a coordinate in the user\n   * projection and returns the corresponding pixel.\n   * @param {import(\"./coordinate.js\").Coordinate} coordinate A map coordinate.\n   * @return {import(\"./pixel.js\").Pixel} A pixel position in the map viewport.\n   * @api\n   */\n  getPixelFromCoordinate(coordinate) {\n    const viewCoordinate = fromUserCoordinate(\n      coordinate,\n      this.getView().getProjection(),\n    );\n    return this.getPixelFromCoordinateInternal(viewCoordinate);\n  }\n\n  /**\n   * Get the pixel for a coordinate.  This takes a coordinate in the map view\n   * projection and returns the corresponding pixel.\n   * @param {import(\"./coordinate.js\").Coordinate} coordinate A map coordinate.\n   * @return {import(\"./pixel.js\").Pixel} A pixel position in the map viewport.\n   */\n  getPixelFromCoordinateInternal(coordinate) {\n    const frameState = this.frameState_;\n    if (!frameState) {\n      return null;\n    }\n    return applyTransform(\n      frameState.coordinateToPixelTransform,\n      coordinate.slice(0, 2),\n    );\n  }\n\n  /**\n   * Get the map renderer.\n   * @return {import(\"./renderer/Map.js\").default|null} Renderer\n   */\n  getRenderer() {\n    return this.renderer_;\n  }\n\n  /**\n   * Get the size of this map.\n   * @return {import(\"./size.js\").Size|undefined} The size in pixels of the map in the DOM.\n   * @observable\n   * @api\n   */\n  getSize() {\n    return /** @type {import(\"./size.js\").Size|undefined} */ (\n      this.get(MapProperty.SIZE)\n    );\n  }\n\n  /**\n   * Get the view associated with this map. A view manages properties such as\n   * center and resolution.\n   * @return {View} The view that controls this map.\n   * @observable\n   * @api\n   */\n  getView() {\n    return /** @type {View} */ (this.get(MapProperty.VIEW));\n  }\n\n  /**\n   * Get the element that serves as the map viewport.\n   * @return {HTMLElement} Viewport.\n   * @api\n   */\n  getViewport() {\n    return this.viewport_;\n  }\n\n  /**\n   * Get the element that serves as the container for overlays.  Elements added to\n   * this container will let mousedown and touchstart events through to the map,\n   * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}\n   * events.\n   * @return {!HTMLElement} The map's overlay container.\n   */\n  getOverlayContainer() {\n    return this.overlayContainer_;\n  }\n\n  /**\n   * Get the element that serves as a container for overlays that don't allow\n   * event propagation. Elements added to this container won't let mousedown and\n   * touchstart events through to the map, so clicks and gestures on an overlay\n   * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\n   * @return {!HTMLElement} The map's overlay container that stops events.\n   */\n  getOverlayContainerStopEvent() {\n    return this.overlayContainerStopEvent_;\n  }\n\n  /**\n   * @return {!Document} The document where the map is displayed.\n   */\n  getOwnerDocument() {\n    const targetElement = this.getTargetElement();\n    return targetElement ? targetElement.ownerDocument : document;\n  }\n\n  /**\n   * @param {import(\"./Tile.js\").default} tile Tile.\n   * @param {string} tileSourceKey Tile source key.\n   * @param {import(\"./coordinate.js\").Coordinate} tileCenter Tile center.\n   * @param {number} tileResolution Tile resolution.\n   * @return {number} Tile priority.\n   */\n  getTilePriority(tile, tileSourceKey, tileCenter, tileResolution) {\n    return getTilePriority(\n      this.frameState_,\n      tile,\n      tileSourceKey,\n      tileCenter,\n      tileResolution,\n    );\n  }\n\n  /**\n   * @param {UIEvent} browserEvent Browser event.\n   * @param {string} [type] Type.\n   */\n  handleBrowserEvent(browserEvent, type) {\n    type = type || browserEvent.type;\n    const mapBrowserEvent = new MapBrowserEvent(type, this, browserEvent);\n    this.handleMapBrowserEvent(mapBrowserEvent);\n  }\n\n  /**\n   * @param {MapBrowserEvent} mapBrowserEvent The event to handle.\n   */\n  handleMapBrowserEvent(mapBrowserEvent) {\n    if (!this.frameState_) {\n      // With no view defined, we cannot translate pixels into geographical\n      // coordinates so interactions cannot be used.\n      return;\n    }\n    const originalEvent = /** @type {PointerEvent} */ (\n      mapBrowserEvent.originalEvent\n    );\n    const eventType = originalEvent.type;\n    if (\n      eventType === PointerEventType.POINTERDOWN ||\n      eventType === EventType.WHEEL ||\n      eventType === EventType.KEYDOWN\n    ) {\n      const doc = this.getOwnerDocument();\n      const rootNode = this.viewport_.getRootNode\n        ? this.viewport_.getRootNode()\n        : doc;\n      const target = /** @type {Node} */ (originalEvent.target);\n      if (\n        // Abort if the target is a child of the container for elements whose events are not meant\n        // to be handled by map interactions.\n        this.overlayContainerStopEvent_.contains(target) ||\n        // Abort if the event target is a child of the container that is no longer in the page.\n        // It's possible for the target to no longer be in the page if it has been removed in an\n        // event listener, this might happen in a Control that recreates it's content based on\n        // user interaction either manually or via a render in something like https://reactjs.org/\n        !(rootNode === doc ? doc.documentElement : rootNode).contains(target)\n      ) {\n        return;\n      }\n    }\n    mapBrowserEvent.frameState = this.frameState_;\n    if (this.dispatchEvent(mapBrowserEvent) !== false) {\n      const interactionsArray = this.getInteractions().getArray().slice();\n      for (let i = interactionsArray.length - 1; i >= 0; i--) {\n        const interaction = interactionsArray[i];\n        if (\n          interaction.getMap() !== this ||\n          !interaction.getActive() ||\n          !this.getTargetElement()\n        ) {\n          continue;\n        }\n        const cont = interaction.handleEvent(mapBrowserEvent);\n        if (!cont || mapBrowserEvent.propagationStopped) {\n          break;\n        }\n      }\n    }\n  }\n\n  /**\n   * @protected\n   */\n  handlePostRender() {\n    const frameState = this.frameState_;\n\n    // Manage the tile queue\n    // Image loads are expensive and a limited resource, so try to use them\n    // efficiently:\n    // * When the view is static we allow a large number of parallel tile loads\n    //   to complete the frame as quickly as possible.\n    // * When animating or interacting, image loads can cause janks, so we reduce\n    //   the maximum number of loads per frame and limit the number of parallel\n    //   tile loads to remain reactive to view changes and to reduce the chance of\n    //   loading tiles that will quickly disappear from view.\n    const tileQueue = this.tileQueue_;\n    if (!tileQueue.isEmpty()) {\n      let maxTotalLoading = this.maxTilesLoading_;\n      let maxNewLoads = maxTotalLoading;\n      if (frameState) {\n        const hints = frameState.viewHints;\n        if (hints[ViewHint.ANIMATING] || hints[ViewHint.INTERACTING]) {\n          const lowOnFrameBudget = Date.now() - frameState.time > 8;\n          maxTotalLoading = lowOnFrameBudget ? 0 : 8;\n          maxNewLoads = lowOnFrameBudget ? 0 : 2;\n        }\n      }\n      if (tileQueue.getTilesLoading() < maxTotalLoading) {\n        tileQueue.reprioritize(); // FIXME only call if view has changed\n        tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);\n      }\n    }\n\n    if (frameState && this.renderer_ && !frameState.animate) {\n      if (this.renderComplete_ === true) {\n        if (this.hasListener(RenderEventType.RENDERCOMPLETE)) {\n          this.renderer_.dispatchRenderEvent(\n            RenderEventType.RENDERCOMPLETE,\n            frameState,\n          );\n        }\n        if (this.loaded_ === false) {\n          this.loaded_ = true;\n          this.dispatchEvent(\n            new MapEvent(MapEventType.LOADEND, this, frameState),\n          );\n        }\n      } else if (this.loaded_ === true) {\n        this.loaded_ = false;\n        this.dispatchEvent(\n          new MapEvent(MapEventType.LOADSTART, this, frameState),\n        );\n      }\n    }\n\n    const postRenderFunctions = this.postRenderFunctions_;\n    for (let i = 0, ii = postRenderFunctions.length; i < ii; ++i) {\n      postRenderFunctions[i](this, frameState);\n    }\n    postRenderFunctions.length = 0;\n  }\n\n  /**\n   * @private\n   */\n  handleSizeChanged_() {\n    if (this.getView() && !this.getView().getAnimating()) {\n      this.getView().resolveConstraints(0);\n    }\n\n    this.render();\n  }\n\n  /**\n   * @private\n   */\n  handleTargetChanged_() {\n    if (this.mapBrowserEventHandler_) {\n      for (let i = 0, ii = this.targetChangeHandlerKeys_.length; i < ii; ++i) {\n        unlistenByKey(this.targetChangeHandlerKeys_[i]);\n      }\n      this.targetChangeHandlerKeys_ = null;\n      this.viewport_.removeEventListener(\n        EventType.CONTEXTMENU,\n        this.boundHandleBrowserEvent_,\n      );\n      this.viewport_.removeEventListener(\n        EventType.WHEEL,\n        this.boundHandleBrowserEvent_,\n      );\n      this.mapBrowserEventHandler_.dispose();\n      this.mapBrowserEventHandler_ = null;\n      removeNode(this.viewport_);\n    }\n\n    if (this.targetElement_) {\n      this.resizeObserver_.unobserve(this.targetElement_);\n      const rootNode = this.targetElement_.getRootNode();\n      if (rootNode instanceof ShadowRoot) {\n        this.resizeObserver_.unobserve(rootNode.host);\n      }\n      this.setSize(undefined);\n    }\n\n    // target may be undefined, null, a string or an Element.\n    // If it's a string we convert it to an Element before proceeding.\n    // If it's not now an Element we remove the viewport from the DOM.\n    // If it's an Element we append the viewport element to it.\n\n    const target = this.getTarget();\n    const targetElement =\n      typeof target === 'string' ? document.getElementById(target) : target;\n    this.targetElement_ = targetElement;\n    if (!targetElement) {\n      if (this.renderer_) {\n        clearTimeout(this.postRenderTimeoutHandle_);\n        this.postRenderTimeoutHandle_ = undefined;\n        this.postRenderFunctions_.length = 0;\n        this.renderer_.dispose();\n        this.renderer_ = null;\n      }\n      if (this.animationDelayKey_) {\n        cancelAnimationFrame(this.animationDelayKey_);\n        this.animationDelayKey_ = undefined;\n      }\n    } else {\n      targetElement.appendChild(this.viewport_);\n      if (!this.renderer_) {\n        this.renderer_ = new CompositeMapRenderer(this);\n      }\n\n      this.mapBrowserEventHandler_ = new MapBrowserEventHandler(\n        this,\n        this.moveTolerance_,\n      );\n      for (const key in MapBrowserEventType) {\n        this.mapBrowserEventHandler_.addEventListener(\n          MapBrowserEventType[key],\n          this.handleMapBrowserEvent.bind(this),\n        );\n      }\n      this.viewport_.addEventListener(\n        EventType.CONTEXTMENU,\n        this.boundHandleBrowserEvent_,\n        false,\n      );\n      this.viewport_.addEventListener(\n        EventType.WHEEL,\n        this.boundHandleBrowserEvent_,\n        PASSIVE_EVENT_LISTENERS ? {passive: false} : false,\n      );\n\n      const keyboardEventTarget = !this.keyboardEventTarget_\n        ? targetElement\n        : this.keyboardEventTarget_;\n      this.targetChangeHandlerKeys_ = [\n        listen(\n          keyboardEventTarget,\n          EventType.KEYDOWN,\n          this.handleBrowserEvent,\n          this,\n        ),\n        listen(\n          keyboardEventTarget,\n          EventType.KEYPRESS,\n          this.handleBrowserEvent,\n          this,\n        ),\n      ];\n      const rootNode = targetElement.getRootNode();\n      if (rootNode instanceof ShadowRoot) {\n        this.resizeObserver_.observe(rootNode.host);\n      }\n      this.resizeObserver_.observe(targetElement);\n    }\n\n    this.updateSize();\n    // updateSize calls setSize, so no need to call this.render\n    // ourselves here.\n  }\n\n  /**\n   * @private\n   */\n  handleTileChange_() {\n    this.render();\n  }\n\n  /**\n   * @private\n   */\n  handleViewPropertyChanged_() {\n    this.render();\n  }\n\n  /**\n   * @private\n   */\n  handleViewChanged_() {\n    if (this.viewPropertyListenerKey_) {\n      unlistenByKey(this.viewPropertyListenerKey_);\n      this.viewPropertyListenerKey_ = null;\n    }\n    if (this.viewChangeListenerKey_) {\n      unlistenByKey(this.viewChangeListenerKey_);\n      this.viewChangeListenerKey_ = null;\n    }\n    const view = this.getView();\n    if (view) {\n      this.updateViewportSize_(this.getSize());\n\n      this.viewPropertyListenerKey_ = listen(\n        view,\n        ObjectEventType.PROPERTYCHANGE,\n        this.handleViewPropertyChanged_,\n        this,\n      );\n      this.viewChangeListenerKey_ = listen(\n        view,\n        EventType.CHANGE,\n        this.handleViewPropertyChanged_,\n        this,\n      );\n\n      view.resolveConstraints(0);\n    }\n    this.render();\n  }\n\n  /**\n   * @private\n   */\n  handleLayerGroupChanged_() {\n    if (this.layerGroupPropertyListenerKeys_) {\n      this.layerGroupPropertyListenerKeys_.forEach(unlistenByKey);\n      this.layerGroupPropertyListenerKeys_ = null;\n    }\n    const layerGroup = this.getLayerGroup();\n    if (layerGroup) {\n      this.handleLayerAdd_(new GroupEvent('addlayer', layerGroup));\n      this.layerGroupPropertyListenerKeys_ = [\n        listen(layerGroup, ObjectEventType.PROPERTYCHANGE, this.render, this),\n        listen(layerGroup, EventType.CHANGE, this.render, this),\n        listen(layerGroup, 'addlayer', this.handleLayerAdd_, this),\n        listen(layerGroup, 'removelayer', this.handleLayerRemove_, this),\n      ];\n    }\n    this.render();\n  }\n\n  /**\n   * @return {boolean} Is rendered.\n   */\n  isRendered() {\n    return !!this.frameState_;\n  }\n\n  /**\n   * @private\n   */\n  animationDelay_() {\n    this.animationDelayKey_ = undefined;\n    this.renderFrame_(Date.now());\n  }\n\n  /**\n   * Requests an immediate render in a synchronous manner.\n   * @api\n   */\n  renderSync() {\n    if (this.animationDelayKey_) {\n      cancelAnimationFrame(this.animationDelayKey_);\n    }\n    this.animationDelay_();\n  }\n\n  /**\n   * Redraws all text after new fonts have loaded\n   */\n  redrawText() {\n    const layerStates = this.getLayerGroup().getLayerStatesArray();\n    for (let i = 0, ii = layerStates.length; i < ii; ++i) {\n      const layer = layerStates[i].layer;\n      if (layer.hasRenderer()) {\n        layer.getRenderer().handleFontsChanged();\n      }\n    }\n  }\n\n  /**\n   * Request a map rendering (at the next animation frame).\n   * @api\n   */\n  render() {\n    if (this.renderer_ && this.animationDelayKey_ === undefined) {\n      this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);\n    }\n  }\n\n  /**\n   * Remove the given control from the map.\n   * @param {import(\"./control/Control.js\").default} control Control.\n   * @return {import(\"./control/Control.js\").default|undefined} The removed control (or undefined\n   *     if the control was not found).\n   * @api\n   */\n  removeControl(control) {\n    return this.getControls().remove(control);\n  }\n\n  /**\n   * Remove the given interaction from the map.\n   * @param {import(\"./interaction/Interaction.js\").default} interaction Interaction to remove.\n   * @return {import(\"./interaction/Interaction.js\").default|undefined} The removed interaction (or\n   *     undefined if the interaction was not found).\n   * @api\n   */\n  removeInteraction(interaction) {\n    return this.getInteractions().remove(interaction);\n  }\n\n  /**\n   * Removes the given layer from the map.\n   * @param {import(\"./layer/Base.js\").default} layer Layer.\n   * @return {import(\"./layer/Base.js\").default|undefined} The removed layer (or undefined if the\n   *     layer was not found).\n   * @api\n   */\n  removeLayer(layer) {\n    const layers = this.getLayerGroup().getLayers();\n    return layers.remove(layer);\n  }\n\n  /**\n   * @param {import(\"./layer/Group.js\").GroupEvent} event The layer remove event.\n   * @private\n   */\n  handleLayerRemove_(event) {\n    removeLayerMapProperty(event.layer);\n  }\n\n  /**\n   * Remove the given overlay from the map.\n   * @param {import(\"./Overlay.js\").default} overlay Overlay.\n   * @return {import(\"./Overlay.js\").default|undefined} The removed overlay (or undefined\n   *     if the overlay was not found).\n   * @api\n   */\n  removeOverlay(overlay) {\n    return this.getOverlays().remove(overlay);\n  }\n\n  /**\n   * @param {number} time Time.\n   * @private\n   */\n  renderFrame_(time) {\n    const size = this.getSize();\n    const view = this.getView();\n    const previousFrameState = this.frameState_;\n    /** @type {?FrameState} */\n    let frameState = null;\n    if (size !== undefined && hasArea(size) && view && view.isDef()) {\n      const viewHints = view.getHints(\n        this.frameState_ ? this.frameState_.viewHints : undefined,\n      );\n      const viewState = view.getState();\n      frameState = {\n        animate: false,\n        coordinateToPixelTransform: this.coordinateToPixelTransform_,\n        declutter: null,\n        extent: getForViewAndSize(\n          viewState.center,\n          viewState.resolution,\n          viewState.rotation,\n          size,\n        ),\n        index: this.frameIndex_++,\n        layerIndex: 0,\n        layerStatesArray: this.getLayerGroup().getLayerStatesArray(),\n        pixelRatio: this.pixelRatio_,\n        pixelToCoordinateTransform: this.pixelToCoordinateTransform_,\n        postRenderFunctions: [],\n        size: size,\n        tileQueue: this.tileQueue_,\n        time: time,\n        usedTiles: {},\n        viewState: viewState,\n        viewHints: viewHints,\n        wantedTiles: {},\n        mapId: getUid(this),\n        renderTargets: {},\n      };\n      if (viewState.nextCenter && viewState.nextResolution) {\n        const rotation = isNaN(viewState.nextRotation)\n          ? viewState.rotation\n          : viewState.nextRotation;\n\n        frameState.nextExtent = getForViewAndSize(\n          viewState.nextCenter,\n          viewState.nextResolution,\n          rotation,\n          size,\n        );\n      }\n    }\n\n    this.frameState_ = frameState;\n    this.renderer_.renderFrame(frameState);\n\n    if (frameState) {\n      if (frameState.animate) {\n        this.render();\n      }\n      Array.prototype.push.apply(\n        this.postRenderFunctions_,\n        frameState.postRenderFunctions,\n      );\n\n      if (previousFrameState) {\n        const moveStart =\n          !this.previousExtent_ ||\n          (!isEmpty(this.previousExtent_) &&\n            !equalsExtent(frameState.extent, this.previousExtent_));\n        if (moveStart) {\n          this.dispatchEvent(\n            new MapEvent(MapEventType.MOVESTART, this, previousFrameState),\n          );\n          this.previousExtent_ = createOrUpdateEmpty(this.previousExtent_);\n        }\n      }\n\n      const idle =\n        this.previousExtent_ &&\n        !frameState.viewHints[ViewHint.ANIMATING] &&\n        !frameState.viewHints[ViewHint.INTERACTING] &&\n        !equalsExtent(frameState.extent, this.previousExtent_);\n\n      if (idle) {\n        this.dispatchEvent(\n          new MapEvent(MapEventType.MOVEEND, this, frameState),\n        );\n        clone(frameState.extent, this.previousExtent_);\n      }\n    }\n\n    this.dispatchEvent(new MapEvent(MapEventType.POSTRENDER, this, frameState));\n\n    this.renderComplete_ =\n      this.hasListener(MapEventType.LOADSTART) ||\n      this.hasListener(MapEventType.LOADEND) ||\n      this.hasListener(RenderEventType.RENDERCOMPLETE)\n        ? !this.tileQueue_.getTilesLoading() &&\n          !this.tileQueue_.getCount() &&\n          !this.getLoadingOrNotReady()\n        : undefined;\n\n    if (!this.postRenderTimeoutHandle_) {\n      this.postRenderTimeoutHandle_ = setTimeout(() => {\n        this.postRenderTimeoutHandle_ = undefined;\n        this.handlePostRender();\n      }, 0);\n    }\n  }\n\n  /**\n   * Sets the layergroup of this map.\n   * @param {LayerGroup} layerGroup A layer group containing the layers in this map.\n   * @observable\n   * @api\n   */\n  setLayerGroup(layerGroup) {\n    const oldLayerGroup = this.getLayerGroup();\n    if (oldLayerGroup) {\n      this.handleLayerRemove_(new GroupEvent('removelayer', oldLayerGroup));\n    }\n    this.set(MapProperty.LAYERGROUP, layerGroup);\n  }\n\n  /**\n   * Set the size of this map.\n   * @param {import(\"./size.js\").Size|undefined} size The size in pixels of the map in the DOM.\n   * @observable\n   * @api\n   */\n  setSize(size) {\n    this.set(MapProperty.SIZE, size);\n  }\n\n  /**\n   * Set the target element to render this map into.\n   * @param {HTMLElement|string} [target] The Element or id of the Element\n   *     that the map is rendered in.\n   * @observable\n   * @api\n   */\n  setTarget(target) {\n    this.set(MapProperty.TARGET, target);\n  }\n\n  /**\n   * Set the view for this map.\n   * @param {View|Promise<import(\"./View.js\").ViewOptions>} view The view that controls this map.\n   * It is also possible to pass a promise that resolves to options for constructing a view.  This\n   * alternative allows view properties to be resolved by sources or other components that load\n   * view-related metadata.\n   * @observable\n   * @api\n   */\n  setView(view) {\n    if (!view || view instanceof View) {\n      this.set(MapProperty.VIEW, view);\n      return;\n    }\n    this.set(MapProperty.VIEW, new View());\n\n    const map = this;\n    view.then(function (viewOptions) {\n      map.setView(new View(viewOptions));\n    });\n  }\n\n  /**\n   * Force a recalculation of the map viewport size.  This should be called when\n   * third-party code changes the size of the map viewport.\n   * @api\n   */\n  updateSize() {\n    const targetElement = this.getTargetElement();\n\n    let size = undefined;\n    if (targetElement) {\n      const computedStyle = getComputedStyle(targetElement);\n      const width =\n        targetElement.offsetWidth -\n        parseFloat(computedStyle['borderLeftWidth']) -\n        parseFloat(computedStyle['paddingLeft']) -\n        parseFloat(computedStyle['paddingRight']) -\n        parseFloat(computedStyle['borderRightWidth']);\n      const height =\n        targetElement.offsetHeight -\n        parseFloat(computedStyle['borderTopWidth']) -\n        parseFloat(computedStyle['paddingTop']) -\n        parseFloat(computedStyle['paddingBottom']) -\n        parseFloat(computedStyle['borderBottomWidth']);\n      if (!isNaN(width) && !isNaN(height)) {\n        size = [width, height];\n        if (\n          !hasArea(size) &&\n          !!(\n            targetElement.offsetWidth ||\n            targetElement.offsetHeight ||\n            targetElement.getClientRects().length\n          )\n        ) {\n          warn(\n            \"No map visible because the map container's width or height are 0.\",\n          );\n        }\n      }\n    }\n\n    const oldSize = this.getSize();\n    if (size && (!oldSize || !equals(size, oldSize))) {\n      this.setSize(size);\n      this.updateViewportSize_(size);\n    }\n  }\n\n  /**\n   * Recomputes the viewport size and save it on the view object (if any)\n   * @param {import(\"./size.js\").Size|undefined} size The size.\n   * @private\n   */\n  updateViewportSize_(size) {\n    const view = this.getView();\n    if (view) {\n      view.setViewportSize(size);\n    }\n  }\n}\n\n/**\n * @param {MapOptions} options Map options.\n * @return {MapOptionsInternal} Internal map options.\n */\nfunction createOptionsInternal(options) {\n  /**\n   * @type {HTMLElement|Document}\n   */\n  let keyboardEventTarget = null;\n  if (options.keyboardEventTarget !== undefined) {\n    keyboardEventTarget =\n      typeof options.keyboardEventTarget === 'string'\n        ? document.getElementById(options.keyboardEventTarget)\n        : options.keyboardEventTarget;\n  }\n\n  /**\n   * @type {Object<string, *>}\n   */\n  const values = {};\n\n  const layerGroup =\n    options.layers &&\n    typeof (/** @type {?} */ (options.layers).getLayers) === 'function'\n      ? /** @type {LayerGroup} */ (options.layers)\n      : new LayerGroup({\n          layers:\n            /** @type {Collection<import(\"./layer/Base.js\").default>|Array<import(\"./layer/Base.js\").default>} */ (\n              options.layers\n            ),\n        });\n  values[MapProperty.LAYERGROUP] = layerGroup;\n\n  values[MapProperty.TARGET] = options.target;\n\n  values[MapProperty.VIEW] =\n    options.view instanceof View ? options.view : new View();\n\n  /** @type {Collection<import(\"./control/Control.js\").default>} */\n  let controls;\n  if (options.controls !== undefined) {\n    if (Array.isArray(options.controls)) {\n      controls = new Collection(options.controls.slice());\n    } else {\n      assert(\n        typeof (/** @type {?} */ (options.controls).getArray) === 'function',\n        'Expected `controls` to be an array or an `ol/Collection.js`',\n      );\n      controls = options.controls;\n    }\n  }\n\n  /** @type {Collection<import(\"./interaction/Interaction\").default>} */\n  let interactions;\n  if (options.interactions !== undefined) {\n    if (Array.isArray(options.interactions)) {\n      interactions = new Collection(options.interactions.slice());\n    } else {\n      assert(\n        typeof (/** @type {?} */ (options.interactions).getArray) ===\n          'function',\n        'Expected `interactions` to be an array or an `ol/Collection.js`',\n      );\n      interactions = options.interactions;\n    }\n  }\n\n  /** @type {Collection<import(\"./Overlay.js\").default>} */\n  let overlays;\n  if (options.overlays !== undefined) {\n    if (Array.isArray(options.overlays)) {\n      overlays = new Collection(options.overlays.slice());\n    } else {\n      assert(\n        typeof (/** @type {?} */ (options.overlays).getArray) === 'function',\n        'Expected `overlays` to be an array or an `ol/Collection.js`',\n      );\n      overlays = options.overlays;\n    }\n  } else {\n    overlays = new Collection();\n  }\n\n  return {\n    controls: controls,\n    interactions: interactions,\n    keyboardEventTarget: keyboardEventTarget,\n    overlays: overlays,\n    values: values,\n  };\n}\nexport default Map;\n","/**\n * @module ol/TileCache\n */\nimport LRUCache from './structs/LRUCache.js';\nimport {fromKey, getKey} from './tilecoord.js';\n\nclass TileCache extends LRUCache {\n  clear() {\n    while (this.getCount() > 0) {\n      this.pop().release();\n    }\n    super.clear();\n  }\n\n  /**\n   * @param {!Object<string, boolean>} usedTiles Used tiles.\n   */\n  expireCache(usedTiles) {\n    while (this.canExpireCache()) {\n      const tile = this.peekLast();\n      if (tile.getKey() in usedTiles) {\n        break;\n      } else {\n        this.pop().release();\n      }\n    }\n  }\n\n  /**\n   * Prune all tiles from the cache that don't have the same z as the newest tile.\n   */\n  pruneExceptNewestZ() {\n    if (this.getCount() === 0) {\n      return;\n    }\n    const key = this.peekFirstKey();\n    const tileCoord = fromKey(key);\n    const z = tileCoord[0];\n    this.forEach((tile) => {\n      if (tile.tileCoord[0] !== z) {\n        this.remove(getKey(tile.tileCoord));\n        tile.release();\n      }\n    });\n  }\n}\n\nexport default TileCache;\n","/**\n * @module ol/TileRange\n */\n\n/**\n * A representation of a contiguous block of tiles.  A tile range is specified\n * by its min/max tile coordinates and is inclusive of coordinates.\n */\nclass TileRange {\n  /**\n   * @param {number} minX Minimum X.\n   * @param {number} maxX Maximum X.\n   * @param {number} minY Minimum Y.\n   * @param {number} maxY Maximum Y.\n   */\n  constructor(minX, maxX, minY, maxY) {\n    /**\n     * @type {number}\n     */\n    this.minX = minX;\n\n    /**\n     * @type {number}\n     */\n    this.maxX = maxX;\n\n    /**\n     * @type {number}\n     */\n    this.minY = minY;\n\n    /**\n     * @type {number}\n     */\n    this.maxY = maxY;\n  }\n\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @return {boolean} Contains tile coordinate.\n   */\n  contains(tileCoord) {\n    return this.containsXY(tileCoord[1], tileCoord[2]);\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   * @return {boolean} Contains.\n   */\n  containsTileRange(tileRange) {\n    return (\n      this.minX <= tileRange.minX &&\n      tileRange.maxX <= this.maxX &&\n      this.minY <= tileRange.minY &&\n      tileRange.maxY <= this.maxY\n    );\n  }\n\n  /**\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @return {boolean} Contains coordinate.\n   */\n  containsXY(x, y) {\n    return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   * @return {boolean} Equals.\n   */\n  equals(tileRange) {\n    return (\n      this.minX == tileRange.minX &&\n      this.minY == tileRange.minY &&\n      this.maxX == tileRange.maxX &&\n      this.maxY == tileRange.maxY\n    );\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   */\n  extend(tileRange) {\n    if (tileRange.minX < this.minX) {\n      this.minX = tileRange.minX;\n    }\n    if (tileRange.maxX > this.maxX) {\n      this.maxX = tileRange.maxX;\n    }\n    if (tileRange.minY < this.minY) {\n      this.minY = tileRange.minY;\n    }\n    if (tileRange.maxY > this.maxY) {\n      this.maxY = tileRange.maxY;\n    }\n  }\n\n  /**\n   * @return {number} Height.\n   */\n  getHeight() {\n    return this.maxY - this.minY + 1;\n  }\n\n  /**\n   * @return {import(\"./size.js\").Size} Size.\n   */\n  getSize() {\n    return [this.getWidth(), this.getHeight()];\n  }\n\n  /**\n   * @return {number} Width.\n   */\n  getWidth() {\n    return this.maxX - this.minX + 1;\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   * @return {boolean} Intersects.\n   */\n  intersects(tileRange) {\n    return (\n      this.minX <= tileRange.maxX &&\n      this.maxX >= tileRange.minX &&\n      this.minY <= tileRange.maxY &&\n      this.maxY >= tileRange.minY\n    );\n  }\n}\n\n/**\n * @param {number} minX Minimum X.\n * @param {number} maxX Maximum X.\n * @param {number} minY Minimum Y.\n * @param {number} maxY Maximum Y.\n * @param {TileRange} [tileRange] TileRange.\n * @return {TileRange} Tile range.\n */\nexport function createOrUpdate(minX, maxX, minY, maxY, tileRange) {\n  if (tileRange !== undefined) {\n    tileRange.minX = minX;\n    tileRange.maxX = maxX;\n    tileRange.minY = minY;\n    tileRange.maxY = maxY;\n    return tileRange;\n  }\n  return new TileRange(minX, maxX, minY, maxY);\n}\n\nexport default TileRange;\n"],"names":["CENTER","RESOLUTION","ROTATION","DEFAULT_MIN_ZOOM","View","constructor","options","super","this","on","once","un","Object","assign","hints_","animations_","updateAnimationKey_","projection_","createProjection","projection","viewportSize_","targetCenter_","targetResolution_","targetRotation_","nextCenter_","nextResolution_","nextRotation_","cancelAnchor_","undefined","disableCoordinateWarning","center","fromUserCoordinate","extent","fromUserExtent","applyOptions_","properties","key","ViewProperty","setProperties","resolutionConstraintInfo","createResolutionConstraint","maxResolution_","maxResolution","minResolution_","minResolution","zoomFactor_","zoomFactor","resolutions_","resolutions","padding_","padding","minZoom_","minZoom","centerConstraint","createCenterConstraint","resolutionConstraint","constraint","rotationConstraint","createRotationConstraint","constraints_","resolution","rotation","setRotation","setCenterInternal","setResolution","zoom","setZoom","oldPadding","getCenterInternal","newPadding","getResolution","offsetX","offsetY","getUpdatedOptions_","newOptions","getProperties","getZoom","getRotation","animate","var_args","isDef","getAnimating","resolveConstraints","args","Array","arguments","length","i","getProjection","anchor","animateInternal","apply","callback","animationCount","state","animationCallback","start","Date","now","slice","series","animation","complete","duration","easing","sourceCenter","targetCenter","sourceResolution","targetResolution","getResolutionForZoom","sourceRotation","delta","Math","PI","targetRotation","isNoopAnimation","push","setHint","ViewHint","ANIMATING","updateAnimations_","getInteracting","INTERACTING","cancelAnimations","ii","j","jj","NaN","cancelAnimationFrame","more","seriesComplete","elapsed","fraction","progress","x0","y0","x1","y1","x","y","size","getViewportSize_","constrainedResolution","calculateCenterZoom","applyTargetState_","constrainedRotation","calculateCenterRotate","filter","Boolean","requestAnimationFrame","bind","currentCenter","currentResolution","w","h","abs","cos","sin","setViewportSize","isArray","getCenter","toUserCoordinate","get","getConstraints","getConstrainResolution","getHints","hints","calculateExtent","calculateExtentInternal","toUserExtent","getViewportSizeMinusPadding_","getMaxResolution","getMinResolution","getMaxZoom","getZoomForResolution","setMaxZoom","maxZoom","getMinZoom","setMinZoom","setConstrainResolution","enabled","constrainResolution","getResolutions","getResolutionForExtent","getResolutionForExtentInternal","xResolution","yResolution","max","getResolutionForValueFunction","power","getConstrainedResolution","log","value","pow","getValueForResolutionFunction","logPower","getState","reducedSize","calculateCenterOn","nextCenter","nextResolution","nextRotation","getViewStateAndExtent","viewState","offset","nearest","baseLevel","floor","fit","geometryOrExtent","geometry","getType","getExtent","rotate","userProjection","getUserProjection","clone","transform","fitInternal","rotatedExtentForGeometry","cosAngle","sinAngle","coords","getFlatCoordinates","stride","getStride","minRotX","Infinity","minRotY","maxRotX","maxRotY","rotX","rotY","min","rotatedExtent","isNaN","centerRot","centerX","centerY","getConstrainedCenter","centerOn","coordinate","position","centerOnInternal","calculateCenterShift","centerShift","shiftedCenter","adjustCenter","deltaCoordinates","setCenter","adjustCenterInternal","adjustResolution","ratio","adjustResolutionInternal","isMoving","newResolution","adjustZoom","adjustRotation","adjustRotationInternal","newRotation","hint","changed","doNotCancelAnims","forceMoving","newCenter","set","resolutionDirection","direction","beginInteraction","endInteraction","endInteractionInternal","getConstrainedZoom","targetZoom","targetRes","returnValue","setTimeout","smooth","smoothExtentConstraint","constrainOnlyCenter","multiWorld","isGlobal","defaultMaxZoom","defaultZoomFactor","smoothResolutionConstraint","showFullExtent","projExtent","METERS_PER_UNIT","degrees","getMetersPerUnit","defaultMaxResolution","defaultMinResolution","enableRotation","constrainRotation","Tile","tileCoord","interimTile","transition_","transition","transitionStarts_","interpolate","dispatchEvent","CHANGE","release","ERROR","setState","EMPTY","getKey","getInterimTile","tile","LOADED","refreshInterimChain","prev","LOADING","IDLE","getTileCoord","Error","load","getAlpha","id","time","inTransition","endTransition","Observable","revision_","getRevision","onInternal","type","listener","len","keys","onceInternal","ol_key","unInternal","unByKey","removeEventListener","prototype","PROPERTYCHANGE","ObjectEvent","oldValue","BaseObject","values","values_","hasOwnProperty","getKeys","getPropertiesInternal","hasProperties","notify","eventType","hasListener","addChangeListener","addEventListener","removeChangeListener","silent","applyProperties","source","unset","TileQueue","PriorityQueue","tilePriorityFunction","tileChangeCallback","element","boundHandleTileChange_","handleTileChange","tileChangeCallback_","tilesLoading_","tilesLoadingKeys_","enqueue","added","EventType","getTilesLoading","event","TileState","tileKey","loadMoreTiles","maxTotalLoading","maxNewLoads","newLoads","getCount","dequeue","getTilePriority","frameState","tileSourceKey","tileCenter","tileResolution","wantedTiles","deltaX","deltaY","sqrt","removeLayerMapProperty","layer","Layer","setMapInternal","getLayers","forEach","setLayerMapProperty","map","layers","getArray","Map","optionsInternal","createOptionsInternal","renderComplete_","loaded_","boundHandleBrowserEvent_","handleBrowserEvent","maxTilesLoading_","maxTilesLoading","pixelRatio_","pixelRatio","postRenderTimeoutHandle_","animationDelayKey_","animationDelay_","coordinateToPixelTransform_","pixelToCoordinateTransform_","frameIndex_","frameState_","previousExtent_","viewPropertyListenerKey_","viewChangeListenerKey_","layerGroupPropertyListenerKeys_","viewport_","document","createElement","className","window","style","overflow","width","height","overlayContainer_","zIndex","pointerEvents","appendChild","overlayContainerStopEvent_","mapBrowserEventHandler_","moveTolerance_","moveTolerance","keyboardEventTarget_","keyboardEventTarget","targetChangeHandlerKeys_","targetElement_","resizeObserver_","ResizeObserver","updateSize","controls","interactions","onFocusOnly","overlays_","overlays","overlayIdIndex_","renderer_","postRenderFunctions_","tileQueue_","handleTileChange_","MapProperty","LAYERGROUP","handleLayerGroupChanged_","VIEW","handleViewChanged_","SIZE","handleSizeChanged_","TARGET","handleTargetChanged_","view","then","viewOptions","setView","CollectionEventType","ADD","setMap","REMOVE","addOverlayInternal_","getId","toString","control","interaction","addControl","getControls","addInteraction","getInteractions","addLayer","getLayerGroup","handleLayerAdd_","addOverlay","overlay","getOverlays","disposeInternal","clear","disconnect","setTarget","forEachFeatureAtPixel","pixel","getCoordinateFromPixelInternal","hitTolerance","layerFilter","checkWrapped","forEachFeatureAtCoordinate","getFeaturesAtPixel","features","feature","getAllLayers","addLayersFrom","layerGroup","hasFeatureAtPixel","hasFeatureAtCoordinate","getEventCoordinate","getCoordinateFromPixel","getEventPixel","getEventCoordinateInternal","viewport","viewportPosition","getBoundingClientRect","viewportSize","getSize","scaleX","scaleY","eventPosition","changedTouches","clientX","left","clientY","top","getTarget","getTargetElement","getView","pixelToCoordinateTransform","getOverlayById","setLayers","group","Collection","collection","extend","getLoadingOrNotReady","layerStatesArray","getLayerStatesArray","visible","renderer","getRenderer","ready","getSource","loading","getPixelFromCoordinate","viewCoordinate","getPixelFromCoordinateInternal","coordinateToPixelTransform","getViewport","getOverlayContainer","getOverlayContainerStopEvent","getOwnerDocument","targetElement","ownerDocument","browserEvent","mapBrowserEvent","MapBrowserEvent","handleMapBrowserEvent","originalEvent","POINTERDOWN","WHEEL","KEYDOWN","doc","rootNode","getRootNode","target","contains","documentElement","interactionsArray","getMap","getActive","cont","handleEvent","propagationStopped","handlePostRender","tileQueue","isEmpty","viewHints","lowOnFrameBudget","reprioritize","RENDERCOMPLETE","dispatchRenderEvent","MapEvent","MapEventType","LOADEND","LOADSTART","postRenderFunctions","render","CONTEXTMENU","dispose","unobserve","ShadowRoot","host","setSize","getElementById","Composite","MapBrowserEventHandler","MapBrowserEventType","passive","KEYPRESS","observe","clearTimeout","handleViewPropertyChanged_","updateViewportSize_","ObjectEventType","Group","handleLayerRemove_","isRendered","renderFrame_","renderSync","redrawText","layerStates","hasRenderer","handleFontsChanged","removeControl","remove","removeInteraction","removeLayer","removeOverlay","previousFrameState","declutter","index","layerIndex","usedTiles","mapId","renderTargets","nextExtent","renderFrame","moveStart","MOVESTART","idle","MOVEEND","POSTRENDER","setLayerGroup","oldLayerGroup","computedStyle","getComputedStyle","offsetWidth","parseFloat","offsetHeight","getClientRects","oldSize","TileCache","pop","expireCache","canExpireCache","peekLast","pruneExceptNewestZ","peekFirstKey","z","TileRange","minX","maxX","minY","maxY","containsXY","containsTileRange","tileRange","equals","getHeight","getWidth","intersects","createOrUpdate"],"sourceRoot":""}
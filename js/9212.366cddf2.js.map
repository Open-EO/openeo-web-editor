{"version":3,"file":"js/9212.366cddf2.js","mappings":"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","sources":["webpack://@openeo/web-editor/./node_modules/ol-ext/control/TextButton.js","webpack://@openeo/web-editor/./node_modules/ol-ext/control/Toggle.js","webpack://@openeo/web-editor/./node_modules/ol-ext/geom/GeomUtils.js","webpack://@openeo/web-editor/./node_modules/ol-ext/geom/LineStringSplitAt.js","webpack://@openeo/web-editor/./node_modules/ol-ext/interaction/Delete.js","webpack://@openeo/web-editor/./node_modules/ol-ext/interaction/DrawHole.js","webpack://@openeo/web-editor/./node_modules/ol-ext/interaction/DrawRegular.js","webpack://@openeo/web-editor/./node_modules/ol-ext/interaction/ModifyFeature.js","webpack://@openeo/web-editor/./node_modules/ol-ext/interaction/Offset.js","webpack://@openeo/web-editor/./node_modules/ol-ext/interaction/Split.js","webpack://@openeo/web-editor/./node_modules/ol-ext/interaction/Transform.js","webpack://@openeo/web-editor/./node_modules/ol-ext/source/Vector.js","webpack://@openeo/web-editor/./node_modules/ol-ext/interaction/UndoRedo.js","webpack://@openeo/web-editor/./node_modules/ol-ext/style/defaultStyle.js","webpack://@openeo/web-editor/./node_modules/ol/geom/Circle.js","webpack://@openeo/web-editor/./node_modules/ol/interaction/Draw.js","webpack://@openeo/web-editor/./node_modules/ol/interaction/Extent.js","webpack://@openeo/web-editor/./node_modules/ol/interaction/Snap.js"],"sourcesContent":["/*\tCopyright (c) 2016 Jean-Marc VIGLINO,\r\nreleased under the CeCILL-B license (French BSD license)\r\n(http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).\r\n*/\r\n\r\nimport ol_control_Button from \"./Button.js\";\r\n\r\n/** A simple push button control drawn as text\r\n * @constructor\r\n * @extends {ol_control_Button}\r\n * @param {Object=} options Control options.\r\n *\t@param {String} options.className class of the control\r\n*\t@param {String} options.title title of the control\r\n*\t@param {String} options.html html to insert in the control\r\n*\t@param {function} options.handleClick callback when control is clicked (or use change:active event)\r\n*/\r\nvar ol_control_TextButton = class olcontrolTextButton extends ol_control_Button {\r\n  constructor(options) {\r\n    options = options || {};\r\n    options.className = (options.className || '') + ' ol-text-button';\r\n    super(options);\r\n  }\r\n}\r\n\r\nexport default ol_control_TextButton\r\n","/*\tCopyright (c) 2016 Jean-Marc VIGLINO,\r\n  released under the CeCILL-B license (French BSD license)\r\n  (http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).\r\n*/\r\n\r\nimport ol_control_Button from './Button.js'\r\n\r\n/** A simple toggle control\r\n * The control can be created with an interaction to control its activation.\r\n *\r\n * @constructor\r\n * @extends {ol_control_Button}\r\n * @fires change:active, change:disable\r\n * @param {Object=} options Control options.\r\n *  @param {String} options.className class of the control\r\n *  @param {String} options.title title of the control\r\n *  @param {String} options.html html to insert in the control\r\n *  @param {ol.interaction} options.interaction interaction associated with the control\r\n *  @param {bool} options.active the control is created active, default false\r\n *  @param {bool} options.disable the control is created disabled, default false\r\n *  @param {ol.control.Bar} options.bar a subbar associated with the control (drawn when active if control is nested in a ol.control.Bar)\r\n *  @param {bool} options.autoActive the control will activate when shown in an ol.control.Bar, default false\r\n *  @param {function} options.onToggle callback when control is clicked (or use change:active event)\r\n */\r\nvar ol_control_Toggle = class olcontrolToggle extends ol_control_Button {\r\n  constructor(options) {\r\n    options = options || {};\r\n\r\n    if (options.toggleFn) {\r\n      options.onToggle = options.toggleFn; // compat old version\r\n    }\r\n    options.handleClick = function () {\r\n      self.toggle();\r\n      if (options.onToggle) {\r\n        options.onToggle.call(self, self.getActive());\r\n      }\r\n    };\r\n    options.className = (options.className || '') + ' ol-toggle';\r\n    super(options);\r\n\r\n    var self = this;\r\n\r\n    this.interaction_ = options.interaction;\r\n    if (this.interaction_) {\r\n      this.interaction_.setActive(options.active);\r\n      this.interaction_.on(\"change:active\", function () {\r\n        self.setActive(self.interaction_.getActive());\r\n      });\r\n    }\r\n\r\n    this.set(\"title\", options.title);\r\n\r\n    this.set(\"autoActivate\", options.autoActivate);\r\n    if (options.bar)\r\n      this.setSubBar(options.bar);\r\n\r\n    this.setActive(options.active);\r\n    this.setDisable(options.disable);\r\n  }\r\n  /**\r\n   * Set the map instance the control is associated with\r\n   * and add interaction attached to it to this map.\r\n   * @param {_ol_Map_} map The map instance.\r\n   */\r\n  setMap(map) {\r\n    if (!map && this.getMap()) {\r\n      if (this.interaction_) {\r\n        this.getMap().removeInteraction(this.interaction_);\r\n      }\r\n      if (this.subbar_)\r\n        this.getMap().removeControl(this.subbar_);\r\n    }\r\n\r\n    super.setMap(map);\r\n\r\n    if (map) {\r\n      if (this.interaction_)\r\n        map.addInteraction(this.interaction_);\r\n      if (this.subbar_)\r\n        map.addControl(this.subbar_);\r\n    }\r\n  }\r\n  /** Get the subbar associated with a control\r\n   * @return {ol_control_Bar}\r\n   */\r\n  getSubBar() {\r\n    return this.subbar_;\r\n  }\r\n  /** Set the subbar associated with a control\r\n   * @param {ol_control_Bar} [bar] a subbar if none remove the current subbar\r\n   */\r\n  setSubBar(bar) {\r\n    var map = this.getMap();\r\n    if (map && this.subbar_)\r\n      map.removeControl(this.subbar_);\r\n    this.subbar_ = bar;\r\n    if (bar) {\r\n      this.subbar_.setTarget(this.element);\r\n      this.subbar_.element.classList.add(\"ol-option-bar\");\r\n      if (map)\r\n        map.addControl(this.subbar_);\r\n    }\r\n  }\r\n  /**\r\n   * Test if the control is disabled.\r\n   * @return {bool}.\r\n   * @api stable\r\n   */\r\n  getDisable() {\r\n    var button = this.element.querySelector(\"button\");\r\n    return button && button.disabled;\r\n  }\r\n  /** Disable the control. If disable, the control will be deactivated too.\r\n  * @param {bool} b disable (or enable) the control, default false (enable)\r\n  */\r\n  setDisable(b) {\r\n    if (this.getDisable() == b)\r\n      return;\r\n    this.element.querySelector(\"button\").disabled = b;\r\n    if (b && this.getActive())\r\n      this.setActive(false);\r\n\r\n    this.dispatchEvent({ type: 'change:disable', key: 'disable', oldValue: !b, disable: b });\r\n  }\r\n  /**\r\n   * Test if the control is active.\r\n   * @return {bool}.\r\n   * @api stable\r\n   */\r\n  getActive() {\r\n    return this.element.classList.contains(\"ol-active\");\r\n  }\r\n  /** Toggle control state active/deactive\r\n   */\r\n  toggle() {\r\n    if (this.getActive())\r\n      this.setActive(false);\r\n    else\r\n      this.setActive(true);\r\n  }\r\n  /** Change control state\r\n   * @param {bool} b activate or deactivate the control, default false\r\n   */\r\n  setActive(b) {\r\n    if (this.interaction_)\r\n      this.interaction_.setActive(b);\r\n    if (this.subbar_)\r\n      this.subbar_.setActive(b);\r\n    if (this.getActive() === b)\r\n      return;\r\n    if (b)\r\n      this.element.classList.add(\"ol-active\");\r\n    else\r\n      this.element.classList.remove(\"ol-active\");\r\n\r\n    this.dispatchEvent({ type: 'change:active', key: 'active', oldValue: !b, active: b });\r\n  }\r\n  /** Set the control interaction\r\n  * @param {_ol_interaction_} i interaction to associate with the control\r\n  */\r\n  setInteraction(i) {\r\n    this.interaction_ = i;\r\n  }\r\n  /** Get the control interaction\r\n  * @return {_ol_interaction_} interaction associated with the control\r\n  */\r\n  getInteraction() {\r\n    return this.interaction_;\r\n  }\r\n}\r\n\r\nexport default ol_control_Toggle\r\n","/*\tCopyright (c) 2016 Jean-Marc VIGLINO, \r\n  released under the CeCILL-B license (French BSD license)\r\n  (http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).\r\n\r\n  Usefull function to handle geometric operations\r\n*/\r\n\r\nimport ol_geom_LineString from 'ol/geom/LineString.js'\r\nimport ol_geom_LinearRing from 'ol/geom/LinearRing.js'\r\nimport ol_geom_MultiLineString from 'ol/geom/MultiLineString.js'\r\nimport ol_geom_MultiPoint from 'ol/geom/MultiPoint.js'\r\nimport ol_geom_MultiPolygon from 'ol/geom/MultiPolygon.js'\r\nimport ol_geom_Point from 'ol/geom/Point.js'\r\nimport ol_geom_Polygon from 'ol/geom/Polygon.js'\r\nimport ol_geom_Circle from 'ol/geom/Circle.js'\r\nimport {getCenter as ol_extent_getCenter} from 'ol/extent.js'\r\nimport {buffer as ol_extent_buffer} from 'ol/extent.js'\r\n\r\n/** Distance beetween 2 points\r\n *\tUsefull geometric functions\r\n * @param {ol.Coordinate} p1 first point\r\n * @param {ol.Coordinate} p2 second point\r\n * @return {number} distance\r\n */\r\nvar ol_coordinate_dist2d = function(p1, p2) {\r\n  var dx = p1[0]-p2[0];\r\n  var dy = p1[1]-p2[1];\r\n  return Math.sqrt(dx*dx+dy*dy);\r\n}\r\n\r\n/** 2 points are equal\r\n *\tUsefull geometric functions\r\n * @param {ol.Coordinate} p1 first point\r\n * @param {ol.Coordinate} p2 second point\r\n * @return {boolean}\r\n */\r\nvar ol_coordinate_equal = function(p1, p2) {\r\n  return (p1[0]==p2[0] && p1[1]==p2[1]);\r\n}\r\n\r\n/** Get center coordinate of a feature\r\n * @param {ol.Feature} f\r\n * @return {ol.coordinate} the center\r\n */\r\nvar ol_coordinate_getFeatureCenter = function(f) {\r\n  return ol_coordinate_getGeomCenter (f.getGeometry());\r\n};\r\n\r\n/** Get center coordinate of a geometry\r\n* @param {ol.geom.Geometry} geom\r\n* @return {ol.Coordinate} the center\r\n*/\r\nvar ol_coordinate_getGeomCenter = function(geom) {\r\n  switch (geom.getType()) {\r\n    case 'Point': \r\n      return geom.getCoordinates();\r\n    case \"MultiPolygon\":\r\n      geom = geom.getPolygon(0);\r\n      // fallthrough\r\n    case \"Polygon\":\r\n      return geom.getInteriorPoint().getCoordinates();\r\n    default:\r\n      return geom.getClosestPoint(ol_extent_getCenter(geom.getExtent()));\r\n  }\r\n};\r\n\r\n/** Offset a polyline\r\n * @param {Array<ol.Coordinate>} coords\r\n * @param {number} offset\r\n * @return {Array<ol.Coordinate>} resulting coord\r\n * @see http://stackoverflow.com/a/11970006/796832\r\n * @see https://drive.google.com/viewerng/viewer?a=v&pid=sites&srcid=ZGVmYXVsdGRvbWFpbnxqa2dhZGdldHN0b3JlfGd4OjQ4MzI5M2Y0MjNmNzI2MjY\r\n */\r\nvar ol_coordinate_offsetCoords = function (coords, offset) {\r\n  var path = [];\r\n  var N = coords.length-1;\r\n  var max = N;\r\n  var mi, mi1, li, li1, ri, ri1, si, si1, Xi1, Yi1;\r\n  var p0, p1, p2;\r\n  var isClosed = ol_coordinate_equal(coords[0],coords[N]);\r\n  if (!isClosed) {\r\n    p0 = coords[0];\r\n    p1 = coords[1];\r\n    p2 = [\r\n      p0[0] + (p1[1] - p0[1]) / ol_coordinate_dist2d(p0,p1) *offset,\r\n      p0[1] - (p1[0] - p0[0]) / ol_coordinate_dist2d(p0,p1) *offset\r\n    ];\r\n    path.push(p2);\r\n    coords.push(coords[N])\r\n    N++;\r\n    max--;\r\n  }\r\n  for (var i = 0; i < max; i++) {\r\n    p0 = coords[i];\r\n    p1 = coords[(i+1) % N];\r\n    p2 = coords[(i+2) % N];\r\n\r\n    mi = (p1[1] - p0[1])/(p1[0] - p0[0]);\r\n    mi1 = (p2[1] - p1[1])/(p2[0] - p1[0]);\r\n    // Prevent alignements\r\n    if (Math.abs(mi-mi1) > 1e-10) {\r\n      li = Math.sqrt((p1[0] - p0[0])*(p1[0] - p0[0])+(p1[1] - p0[1])*(p1[1] - p0[1]));\r\n      li1 = Math.sqrt((p2[0] - p1[0])*(p2[0] - p1[0])+(p2[1] - p1[1])*(p2[1] - p1[1]));\r\n      ri = p0[0] + offset*(p1[1] - p0[1])/li;\r\n      ri1 = p1[0] + offset*(p2[1] - p1[1])/li1;\r\n      si = p0[1] - offset*(p1[0] - p0[0])/li;\r\n      si1 = p1[1] - offset*(p2[0] - p1[0])/li1;\r\n      Xi1 = (mi1*ri1-mi*ri+si-si1) / (mi1-mi);\r\n      Yi1 = (mi*mi1*(ri1-ri)+mi1*si-mi*si1) / (mi1-mi);\r\n\r\n      // Correction for vertical lines\r\n      if(p1[0] - p0[0] == 0) {\r\n        Xi1 = p1[0] + offset*(p1[1] - p0[1])/Math.abs(p1[1] - p0[1]);\r\n        Yi1 = mi1*Xi1 - mi1*ri1 + si1;\r\n      }\r\n      if (p2[0] - p1[0] == 0 ) {\r\n        Xi1 = p2[0] + offset*(p2[1] - p1[1])/Math.abs(p2[1] - p1[1]);\r\n        Yi1 = mi*Xi1 - mi*ri + si;\r\n      }\r\n\r\n      path.push([Xi1, Yi1]);\r\n    }\r\n  }\r\n  if (isClosed) {\r\n    path.push(path[0]);\r\n  } else {\r\n    coords.pop();\r\n    p0 = coords[coords.length-1];\r\n    p1 = coords[coords.length-2];\r\n    p2 = [\r\n      p0[0] - (p1[1] - p0[1]) / ol_coordinate_dist2d(p0,p1) *offset,\r\n      p0[1] + (p1[0] - p0[0]) / ol_coordinate_dist2d(p0,p1) *offset\r\n    ];\r\n    path.push(p2);\r\n  }\r\n  return path;\r\n}\r\n\r\n/** Find the segment a point belongs to\r\n * @param {ol.Coordinate} pt\r\n * @param {Array<ol.Coordinate>} coords\r\n * @return {} the index (-1 if not found) and the segment\r\n */\r\nvar ol_coordinate_findSegment = function (pt, coords) {\r\n  for (var i=0; i<coords.length-1; i++) {\r\n    var p0 = coords[i];\r\n    var p1 = coords[i+1];\r\n    if (ol_coordinate_equal(pt, p0) || ol_coordinate_equal(pt, p1)) {\r\n      return { index:1, segment: [p0,p1] };\r\n    } else {\r\n      var d0 = ol_coordinate_dist2d(p0,p1);\r\n      var v0 = [ (p1[0] - p0[0]) / d0, (p1[1] - p0[1]) / d0 ];\r\n      var d1 = ol_coordinate_dist2d(p0,pt);\r\n      var v1 = [ (pt[0] - p0[0]) / d1, (pt[1] - p0[1]) / d1 ];\r\n      if (Math.abs(v0[0]*v1[1] - v0[1]*v1[0]) < 1e-10) {\r\n        return { index:1, segment: [p0,p1] };\r\n      }\r\n    }\r\n  }\r\n  return { index: -1 };\r\n};\r\n\r\n/**\r\n * Split a Polygon geom with horizontal lines\r\n * @param {Array<ol.Coordinate>} geom\r\n * @param {number} y the y to split\r\n * @param {number} n contour index\r\n * @return {Array<Array<ol.Coordinate>>}\r\n */\r\nvar ol_coordinate_splitH = function (geom, y, n) {\r\n  var x, abs;\r\n  var list = [];\r\n  for (var i=0; i<geom.length-1; i++) {\r\n    // Hole separator?\r\n    if (!geom[i].length || !geom[i+1].length) continue;\r\n    // Intersect\r\n    if (geom[i][1]<=y && geom[i+1][1]>y || geom[i][1]>=y && geom[i+1][1]<y) {\r\n      abs = (y-geom[i][1]) / (geom[i+1][1]-geom[i][1]);\r\n      x = abs * (geom[i+1][0]-geom[i][0]) + geom[i][0];\r\n      list.push ({ contour: n, index: i, pt: [x,y], abs: abs });\r\n    }\r\n  }\r\n  // Sort x\r\n  list.sort(function(a,b) { return a.pt[0] - b.pt[0] });\r\n  // Horizontal segment\r\n  var result = [];\r\n  for (var j=0; j<list.length-1; j += 2) {\r\n    result.push([list[j], list[j+1]])\r\n  }\r\n  return result;\r\n};\r\n\r\n/** Create a geometry given a type and coordinates */\r\nvar ol_geom_createFromType = function (type, coordinates) {\r\n  switch (type) {\r\n    case 'LineString': return new ol_geom_LineString(coordinates);\r\n    case 'LinearRing': return new ol_geom_LinearRing(coordinates);\r\n    case 'MultiLineString': return new ol_geom_MultiLineString(coordinates);\r\n    case 'MultiPoint': return new ol_geom_MultiPoint(coordinates);\r\n    case 'MultiPolygon': return new ol_geom_MultiPolygon(coordinates);\r\n    case 'Point': return new ol_geom_Point(coordinates);\r\n    case 'Polygon': return new ol_geom_Polygon(coordinates);\r\n    default:\r\n      console.error('[createFromType] Unsupported type: '+type);\r\n      return null;\r\n  }\r\n};\r\n\r\nexport {ol_geom_createFromType}\r\nexport {ol_coordinate_dist2d, ol_coordinate_equal, ol_coordinate_findSegment, ol_coordinate_getFeatureCenter, ol_coordinate_getGeomCenter, ol_coordinate_offsetCoords, ol_coordinate_splitH}\r\n\r\n/** Intersect 2 lines\r\n * @param {Arrar<ol.coordinate>} d1\r\n * @param {Arrar<ol.coordinate>} d2\r\n */\r\nvar ol_coordinate_getIntersectionPoint = function (d1, d2) {\r\n  var d1x = d1[1][0] - d1[0][0];\r\n  var d1y = d1[1][1] - d1[0][1];\r\n  var d2x = d2[1][0] - d2[0][0];\r\n  var d2y = d2[1][1] - d2[0][1];\r\n  var det = d1x * d2y - d1y * d2x;\r\n  if (det != 0) {\r\n    var k = (d1x * d1[0][1] - d1x * d2[0][1] - d1y * d1[0][0] + d1y * d2[0][0]) / det;\r\n    return [d2[0][0] + k*d2x, d2[0][1] + k*d2y];\r\n  } else {\r\n    return false;\r\n  }\r\n};\r\n\r\nexport { ol_coordinate_getIntersectionPoint }\r\n\r\nvar ol_extent_intersection;\r\n\r\n(function() {\r\n// Split at x\r\nfunction splitX(pts, x) {\r\n  var pt;\r\n  for (let i=pts.length-1; i>0; i--) {\r\n    if ((pts[i][0]>x && pts[i-1][0]<x) || (pts[i][0]<x && pts[i-1][0]>x)) {\r\n      pt = [ x, (x - pts[i][0]) / (pts[i-1][0]-pts[i][0]) * (pts[i-1][1]-pts[i][1]) + pts[i][1]];\r\n      pts.splice(i, 0, pt);\r\n    }\r\n  }\r\n}\r\n// Split at y\r\nfunction splitY(pts, y) {\r\n  var pt;\r\n  for (let i=pts.length-1; i>0; i--) {\r\n    if ((pts[i][1]>y && pts[i-1][1]<y) || (pts[i][1]<y && pts[i-1][1]>y)) {\r\n      pt = [ (y - pts[i][1]) / (pts[i-1][1]-pts[i][1]) * (pts[i-1][0]-pts[i][0]) + pts[i][0], y];\r\n      pts.splice(i, 0, pt);\r\n    }\r\n  }\r\n}\r\n\r\n/** Fast polygon intersection with an extent (used for area calculation)\r\n * @param {ol_extent_Extent} extent\r\n * @param {ol_geom_Polygon|ol_geom_MultiPolygon} polygon\r\n * @returns {ol_geom_Polygon|ol_geom_MultiPolygon|null} return null if not a polygon geometry\r\n */\r\nol_extent_intersection = function(extent, polygon) {\r\n  var poly = (polygon.getType() === 'Polygon');\r\n  if (!poly && polygon.getType() !== 'MultiPolygon') return null;\r\n  var geom = polygon.getCoordinates();\r\n  if (poly) geom = [geom];\r\n  geom.forEach(function(g) {\r\n    g.forEach(function(c) {\r\n      splitX(c, extent[0]);\r\n      splitX(c, extent[2]);\r\n      splitY(c, extent[1]);\r\n      splitY(c, extent[3]);\r\n    });\r\n  })\r\n  // Snap geom to the extent \r\n  geom.forEach(function(g) {\r\n    g.forEach(function(c) {\r\n      c.forEach(function(p) {\r\n        if (p[0]<extent[0]) p[0] = extent[0];\r\n        else if (p[0]>extent[2]) p[0] = extent[2];\r\n        if (p[1]<extent[1]) p[1] = extent[1];\r\n        else if (p[1]>extent[3]) p[1] = extent[3];\r\n      })\r\n    })\r\n  })\r\n  if (poly) {\r\n    return new ol_geom_Polygon(geom[0]);\r\n  } else {\r\n    return new ol_geom_MultiPolygon(geom);\r\n  }\r\n};\r\n})();\r\n\r\nexport { ol_extent_intersection }\r\nexport { ol_extent_intersection as extentIntersection }\r\n\r\n/** Add points along a segment\r\n * @param {ol_Coordinate} p1 \r\n * @param {ol_Coordinate} p2 \r\n * @param {number} d \r\n * @param {boolean} start include starting point, default true\r\n * @returns {Array<ol_Coordinate>}\r\n */\r\nvar ol_coordinate_sampleAt = function(p1, p2, d, start) {\r\n  var pts = [];\r\n  if (start!==false) pts.push(p1);\r\n  var dl = ol_coordinate_dist2d(p1,p2);\r\n  if (dl) {\r\n    var nb = Math.round(dl/d);\r\n    if (nb>1) {\r\n      var dx = (p2[0]-p1[0]) / nb;\r\n      var dy = (p2[1]-p1[1]) / nb;\r\n      for (var i=1; i<nb; i++) {\r\n        pts.push([p1[0] + dx*i, p1[1] + dy*i])\r\n      }\r\n    }\r\n  }\r\n  pts.push(p2);\r\n  return pts;\r\n};\r\nexport { ol_coordinate_sampleAt }\r\n\r\n/** Sample a LineString at a distance\r\n * @param {number} d\r\n * @returns {ol_geom_LineString}\r\n */\r\nol_geom_LineString.prototype.sampleAt = function(d) {\r\n  var line = this.getCoordinates();\r\n  var result = [];\r\n  for (var i=1; i<line.length; i++) {\r\n    result = result.concat(ol_coordinate_sampleAt(line[i-1], line[i], d, i===1));\r\n  }\r\n  return new ol_geom_LineString(result);\r\n};\r\n\r\n/** Sample a MultiLineString at a distance\r\n * @param {number} d\r\n * @returns {ol_geom_MultiLineString}\r\n */\r\nol_geom_MultiLineString.prototype.sampleAt = function(d) {\r\n  var lines = this.getCoordinates();\r\n  var result = [];\r\n  lines.forEach(function(p) {\r\n    var l = [];\r\n    for (var i=1; i<p.length; i++) {\r\n      l = l.concat(ol_coordinate_sampleAt(p[i-1], p[i], d, i===1));\r\n    }\r\n    result.push(l);\r\n  })\r\n  return new ol_geom_MultiLineString(result);\r\n};\r\n\r\n/** Sample a Polygon at a distance\r\n * @param {number} d\r\n * @returns {ol_geom_Polygon}\r\n */\r\nol_geom_Polygon.prototype.sampleAt = function(res) {\r\n  var poly = this.getCoordinates();\r\n  var result = [];\r\n  poly.forEach(function(p) {\r\n    var l = [];\r\n    for (var i=1; i<p.length; i++) {\r\n      l = l.concat(ol_coordinate_sampleAt(p[i-1], p[i], res, i===1));\r\n    }\r\n    result.push(l);\r\n  })\r\n  return new ol_geom_Polygon(result);\r\n};\r\n\r\n/** Sample a MultiPolygon at a distance\r\n * @param {number} res\r\n * @returns {ol_geom_MultiPolygon}\r\n */\r\nol_geom_MultiPolygon.prototype.sampleAt = function(res) {\r\n  var mpoly = this.getCoordinates();\r\n  var result = [];\r\n  mpoly.forEach(function(poly) {\r\n    var a = [];\r\n    result.push(a);\r\n    poly.forEach(function(p) {\r\n      var l = [];\r\n      for (var i=1; i<p.length; i++) {\r\n        l = l.concat(ol_coordinate_sampleAt(p[i-1], p[i], res, i===1));\r\n      }\r\n      a.push(l);\r\n    })\r\n  });\r\n  return new ol_geom_MultiPolygon(result);\r\n};\r\n\r\n/** Intersect a geometry using a circle\r\n * @param {ol_geom_Geometry} geom\r\n * @param {number} resolution circle resolution to sample the polygon on the circle, default 1\r\n * @returns {ol_geom_Geometry}\r\n */\r\nol_geom_Circle.prototype.intersection = function(geom, resolution) {\r\n  if (geom.sampleAt) {\r\n    var ext = ol_extent_buffer(this.getCenter().concat(this.getCenter()), this.getRadius());\r\n    geom = ol_extent_intersection(ext, geom);\r\n    geom = geom.simplify(resolution);\r\n    var c = this.getCenter();\r\n    var r = this.getRadius();\r\n    //var res = (resolution||1) * r / 100;\r\n    var g = geom.sampleAt(resolution).getCoordinates();\r\n    switch (geom.getType()) {\r\n      case 'Polygon': g = [g];\r\n        // fallthrough\r\n      case 'MultiPolygon': {\r\n        var hasout = false;\r\n        // var hasin = false;\r\n        var result = [];\r\n        g.forEach(function(poly) {\r\n          var a = [];\r\n          result.push(a);\r\n          poly.forEach(function(ring) {\r\n            var l = [];\r\n            a.push(l);\r\n            ring.forEach(function(p) {\r\n              var d = ol_coordinate_dist2d(c, p);\r\n              if (d > r) {\r\n                hasout = true;\r\n                l.push([\r\n                  c[0] + r / d * (p[0]-c[0]),\r\n                  c[1] + r / d * (p[1]-c[1])\r\n                ]);\r\n              } else {\r\n                // hasin = true;\r\n                l.push(p);\r\n              }\r\n            });\r\n          })\r\n        });\r\n        if (!hasout) return geom;\r\n        if (geom.getType() === 'Polygon') {\r\n          return new ol_geom_Polygon(result[0]);\r\n        } else {\r\n          return new ol_geom_MultiPolygon(result);\r\n        }\r\n      }\r\n    }\r\n  } else {\r\n    console.warn('[ol/geom/Circle~intersection] Unsupported geometry type: '+geom.getType());\r\n  }\r\n  return geom;\r\n};\r\n","import {ol_coordinate_equal} from \"./GeomUtils.js\";\r\nimport ol_geom_LineString from \"ol/geom/LineString.js\";\r\n\r\n/** Split a lineString by a point or a list of points\r\n *\tNB: points must be on the line, use getClosestPoint() to get one\r\n * @param {ol.Coordinate | Array<ol.Coordinate>} pt points to split the line\r\n * @param {Number} tol distance tolerance for 2 points to be equal\r\n */\r\nol_geom_LineString.prototype.splitAt = function(pt, tol) {\r\n  var i;\r\n  if (!pt) return [this];\r\n    if (!tol) tol = 1e-10;\r\n    // Test if list of points\r\n    if (pt.length && pt[0].length) {\r\n      var result = [this];\r\n      for (i=0; i<pt.length; i++) {\r\n        var r = [];\r\n        for (var k=0; k<result.length; k++) {\r\n          var ri = result[k].splitAt(pt[i], tol);\r\n          r = r.concat(ri);\r\n        }\r\n        result = r;\r\n      }\r\n      return result;\r\n    }\r\n    // Nothing to do\r\n    if (ol_coordinate_equal(pt,this.getFirstCoordinate())\r\n    || ol_coordinate_equal(pt,this.getLastCoordinate())) {\r\n      return [this];\r\n    }\r\n    // Get\r\n    var c0 = this.getCoordinates();\r\n    var ci=[c0[0]];\r\n    var c = [];\r\n    for (i=0; i<c0.length-1; i++) {\r\n      // Filter equal points\r\n      if (ol_coordinate_equal(c0[i],c0[i+1])) continue;\r\n      // Extremity found\r\n      if (ol_coordinate_equal(pt,c0[i+1])) {\r\n        ci.push(c0[i+1]);\r\n        c.push(new ol_geom_LineString(ci));\r\n        ci = [];\r\n      }\r\n      // Test alignement\r\n      else if (!ol_coordinate_equal(pt,c0[i])) {\r\n        var d1, d2, split=false;\r\n        if (c0[i][0] == c0[i+1][0]) {\r\n          d1 = (c0[i][1]-pt[1]) / (c0[i][1]-c0[i+1][1]);\r\n          split = (c0[i][0] == pt[0]) && (0 < d1 && d1 <= 1)\r\n        } else if (c0[i][1] == c0[i+1][1]) {\r\n          d1 = (c0[i][0]-pt[0]) / (c0[i][0]-c0[i+1][0]);\r\n          split = (c0[i][1] == pt[1]) && (0 < d1 && d1 <= 1)\r\n        } else {\r\n          d1 = (c0[i][0]-pt[0]) / (c0[i][0]-c0[i+1][0]);\r\n          d2 = (c0[i][1]-pt[1]) / (c0[i][1]-c0[i+1][1]);\r\n          split = (Math.abs(d1-d2) <= tol && 0 < d1 && d1 <= 1)\r\n        }\r\n        // pt is inside the segment > split\r\n        if (split) {\r\n          ci.push(pt);\r\n          c.push (new ol_geom_LineString(ci));\r\n          ci = [pt];\r\n        }\r\n      }\r\n      ci.push(c0[i+1]);\r\n    }\r\n    if (ci.length>1) c.push (new ol_geom_LineString(ci));\r\n    if (c.length) return c;\r\n    else return [this];\r\n}\r\n\r\n// import('ol-ext/geom/LineStringSplitAt')","/*\tCopyright (c) 2018 Jean-Marc VIGLINO, \r\n\treleased under the CeCILL-B license (French BSD license)\r\n\t(http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).\r\n*/\r\n\r\nimport ol_interaction_Select from 'ol/interaction/Select.js'\r\nimport ol_source_Vector from 'ol/source/Vector.js'\r\n\r\n/** A Select interaction to delete features on click.\r\n * @constructor\r\n * @extends {ol_interaction_Interaction}\r\n * @fires deletestart\r\n * @fires deleteend\r\n * @param {Object} options ol.interaction.Select options\r\n */\r\nvar ol_interaction_Delete = class olinteractionDelete extends ol_interaction_Select {\r\n  constructor(options) {\r\n    super(options);\r\n    this.on('select', function (e) {\r\n      this.getFeatures().clear();\r\n      this.delete(e.selected);\r\n    }.bind(this));\r\n  }\r\n  /** Get vector source of the map\r\n   * @return {Array<ol.source.Vector>}\r\n   */\r\n  _getSources(layers) {\r\n    if (!this.getMap())\r\n      return [];\r\n    if (!layers)\r\n      layers = this.getMap().getLayers();\r\n    var sources = [];\r\n    layers.forEach(function (l) {\r\n      // LayerGroup\r\n      if (l.getLayers) {\r\n        sources = sources.concat(this._getSources(l.getLayers()));\r\n      } else {\r\n        if (l.getSource && l.getSource() instanceof ol_source_Vector) {\r\n          sources.push(l.getSource());\r\n        }\r\n      }\r\n    }.bind(this));\r\n    return sources;\r\n  }\r\n  /** Delete features: remove the features from the map (from all layers in the map)\r\n   * @param {ol.Collection<ol.Feature>|Array<ol.Feature>} features The features to delete\r\n   * @api\r\n   */\r\n  delete(features) {\r\n    if (features && (features.length || features.getLength())) {\r\n      this.dispatchEvent({ type: 'deletestart', features: features });\r\n      var delFeatures = [];\r\n      // Get the sources concerned\r\n      this._getSources().forEach(function (source) {\r\n        try {\r\n          // Try to delete features in the source\r\n          features.forEach(function (f) {\r\n            source.removeFeature(f);\r\n            delFeatures.push(f);\r\n          });\r\n        } catch (e) { /* ok */ }\r\n      });\r\n      this.dispatchEvent({ type: 'deleteend', features: delFeatures });\r\n    }\r\n  }\r\n}\r\n\r\nexport default ol_interaction_Delete","/*\tCopyright (c) 2017 Jean-Marc VIGLINO, \r\n  released under the CeCILL-B license (French BSD license)\r\n  (http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).\r\n*/\r\n\r\nimport ol_geom_Polygon from 'ol/geom/Polygon.js'\r\nimport ol_geom_MultiPolygon from 'ol/geom/MultiPolygon.js'\r\nimport ol_geom_LinearRing from 'ol/geom/LinearRing.js'\r\nimport ol_interaction_Draw from 'ol/interaction/Draw.js'\r\nimport ol_interaction_Select from 'ol/interaction/Select.js'\r\n\r\n/** Interaction to draw holes in a polygon.\r\n * It fires a drawstart, drawend event when drawing the hole\r\n * and a modifystart, modifyend event before and after inserting the hole in the feature geometry.\r\n * @constructor\r\n * @extends {ol_interaction_Interaction}\r\n * @fires drawstart\r\n * @fires drawend\r\n * @fires modifystart\r\n * @fires modifyend\r\n * @param {olx.interaction.DrawHoleOptions} options extend olx.interaction.DrawOptions\r\n * \t@param {Array<ol.layer.Vector> | function | undefined} options.layers A list of layers from which polygons should be selected. Alternatively, a filter function can be provided. default: all visible layers\r\n * \t@param {Array<ol.Feature> | ol.Collection<ol.Feature> | function | undefined} options.featureFilter An array or a collection of features the interaction applies on or a function that takes a feature and a layer and returns true if the feature is a candidate\r\n * \t@param { ol.style.Style | Array<ol.style.Style> | StyleFunction | undefined }\tStyle for the selected features, default: default edit style\r\n */\r\nvar ol_interaction_DrawHole = class olinteractionDrawHole extends ol_interaction_Draw {\r\n  constructor(options) {\r\n    options = options || {}\r\n    // Geometry function that test points inside the current selection\r\n    var _geometryFn = function(coordinates, geometry) {\r\n      var coord = coordinates[0].pop()\r\n      if (!this.getPolygon() || this.getPolygon().intersectsCoordinate(coord)) {\r\n        this.lastOKCoord = [coord[0], coord[1]]\r\n      }\r\n      coordinates[0].push([this.lastOKCoord[0], this.lastOKCoord[1]])\r\n  \r\n      if (geometry) {\r\n        geometry.setCoordinates([coordinates[0].concat([coordinates[0][0]])])\r\n      } else {\r\n        geometry = new ol_geom_Polygon(coordinates)\r\n      }\r\n      return geometry\r\n    }\r\n    var geomFn = options.geometryFunction\r\n    if (geomFn) {\r\n      options.geometryFunction = function (c, g) {\r\n        g = _geometryFn(c, g)\r\n        return geomFn(c, g)\r\n      }\r\n    } else {\r\n      options.geometryFunction = _geometryFn\r\n    }\r\n\r\n    // Create draw interaction\r\n    options.type = 'Polygon';\r\n    super(options)\r\n    \r\n    // Select interaction for the current feature\r\n    this._select = new ol_interaction_Select({ style: options.style })\r\n    this._select.setActive(false)\r\n\r\n    // Layer filter function\r\n    if (options.layers) {\r\n      if (typeof (options.layers) === 'function') {\r\n        this.layers_ = options.layers\r\n      } else if (options.layers.indexOf) {\r\n        this.layers_ = function (l) {\r\n          return (options.layers.indexOf(l) >= 0)\r\n        }\r\n      }\r\n    }\r\n\r\n    // Features to apply on \r\n    if (typeof (options.featureFilter) === 'function') {\r\n      this._features = options.featureFilter\r\n    } else if (options.featureFilter) {\r\n      var features = options.featureFilter\r\n      this._features = function (f) {\r\n        if (features.indexOf) {\r\n          return !!features[features.indexOf(f)]\r\n        } else {\r\n          return !!features.item(features.getArray().indexOf(f))\r\n        }\r\n      }\r\n    } else {\r\n      this._features = function () { return true }\r\n    }\r\n\r\n    // Start drawing if inside a feature\r\n    this.on('drawstart', this._startDrawing.bind(this))\r\n    // End drawing add the hole to the current Polygon\r\n    this.on('drawend', this._finishDrawing.bind(this))\r\n  }\r\n\r\n  /**\r\n   * Remove the interaction from its current map, if any,  and attach it to a new\r\n   * map, if any. Pass `null` to just remove the interaction from the current map.\r\n   * @param {ol.Map} map Map.\r\n   * @api stable\r\n   */\r\n  setMap(map) {\r\n    // Remove previous selection\r\n    if (this.getMap()) this.getMap().removeInteraction(this._select)\r\n    // Add new one\r\n    if (map) map.addInteraction(this._select)\r\n    super.setMap.call(this, map)\r\n  }\r\n  /**\r\n   * Activate/deactivate the interaction\r\n   * @param {boolean}\r\n   * @api stable\r\n   */\r\n  setActive(b) {\r\n    if (this._select) this._select.getFeatures().clear()\r\n    super.setActive.call(this, b)\r\n  }\r\n  /**\r\n   * Remove last point of the feature currently being drawn\r\n   * (test if points to remove before).\r\n   */\r\n  removeLastPoint() {\r\n    if (this._feature && this._feature.getGeometry().getCoordinates()[0].length > 2) {\r\n      super.removeLastPoint.call(this)\r\n    }\r\n  }\r\n  /**\r\n   * Get the current polygon to hole\r\n   * @return {ol.Feature}\r\n   */\r\n  getPolygon() {\r\n    return this._polygon\r\n    // return this._select.getFeatures().item(0).getGeometry();\r\n  }\r\n  /**\r\n   * Get current feature to add a hole and start drawing\r\n   * @param {ol_interaction_Draw.Event} e\r\n   * @private\r\n   */\r\n  _startDrawing(e) {\r\n    var map = this.getMap()\r\n    this._feature = e.feature\r\n    var coord = e.feature.getGeometry().getCoordinates()[0][0]\r\n    this._current = null\r\n    // Check object under the pointer\r\n    map.forEachFeatureAtPixel(\r\n      map.getPixelFromCoordinate(coord),\r\n      function (feature, layer) {\r\n        // Not yet found?\r\n        if (!this._current && this._features(feature, layer)) {\r\n          var poly = feature.getGeometry()\r\n          if (poly.getType() === \"Polygon\"\r\n            && poly.intersectsCoordinate(coord)) {\r\n            this._polygonIndex = false\r\n            this._polygon = poly\r\n            this._current = feature\r\n          } else if (poly.getType() === \"MultiPolygon\"\r\n            && poly.intersectsCoordinate(coord)) {\r\n            for (var i = 0, p; p = poly.getPolygon(i); i++) {\r\n              if (p.intersectsCoordinate(coord)) {\r\n                this._polygonIndex = i\r\n                this._polygon = p\r\n                this._current = feature\r\n                break\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }.bind(this), {\r\n      layerFilter: this.layers_\r\n    }\r\n    )\r\n    this._select.getFeatures().clear()\r\n    if (!this._current) {\r\n      this.setActive(false)\r\n      this.setActive(true)\r\n    } else {\r\n      this._select.getFeatures().push(this._current)\r\n    }\r\n  }\r\n  /**\r\n   * Stop drawing and add the sketch feature to the target feature.\r\n   * @param {ol_interaction_Draw.Event} e\r\n   * @private\r\n   */\r\n  _finishDrawing(e) {\r\n    // The feature is the hole\r\n    e.hole = e.feature\r\n    // Get the current feature\r\n    e.feature = this._select.getFeatures().item(0)\r\n    this.dispatchEvent({ type: 'modifystart', features: [this._current] })\r\n    // Create the hole\r\n    var c = e.hole.getGeometry().getCoordinates()[0]\r\n    if (c.length > 3) {\r\n      if (this._polygonIndex !== false) {\r\n        var geom = e.feature.getGeometry()\r\n        var newGeom = new ol_geom_MultiPolygon([])\r\n        for (var i = 0, pi; pi = geom.getPolygon(i); i++) {\r\n          if (i === this._polygonIndex) {\r\n            pi.appendLinearRing(new ol_geom_LinearRing(c))\r\n            newGeom.appendPolygon(pi)\r\n          } else {\r\n            newGeom.appendPolygon(pi)\r\n          }\r\n        }\r\n        e.feature.setGeometry(newGeom)\r\n      } else {\r\n        this.getPolygon().appendLinearRing(new ol_geom_LinearRing(c))\r\n      }\r\n    }\r\n    this.dispatchEvent({ type: 'modifyend', features: [this._current] })\r\n    // reset\r\n    this._feature = null\r\n    this._select.getFeatures().clear()\r\n  }\r\n  /**\r\n   * Function that is called when a geometry's coordinates are updated.\r\n   * @param {Array<ol.coordinate>} coordinates\r\n   * @param {ol_geom_Polygon} geometry\r\n   * @return {ol_geom_Polygon}\r\n   * @private\r\n   */\r\n  _geometryFn(coordinates, geometry) {\r\n    var coord = coordinates[0].pop()\r\n    if (!this.getPolygon() || this.getPolygon().intersectsCoordinate(coord)) {\r\n      this.lastOKCoord = [coord[0], coord[1]]\r\n    }\r\n    coordinates[0].push([this.lastOKCoord[0], this.lastOKCoord[1]])\r\n\r\n    if (geometry) {\r\n      geometry.setCoordinates([coordinates[0].concat([coordinates[0][0]])])\r\n    } else {\r\n      geometry = new ol_geom_Polygon(coordinates)\r\n    }\r\n    return geometry\r\n  }\r\n}\r\n\r\nexport default ol_interaction_DrawHole\r\n","/*\tCopyright (c) 2016 Jean-Marc VIGLINO, \r\n  released under the CeCILL-B license (French BSD license)\r\n  (http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).\r\n*/\r\n\r\nimport ol_interaction_Interaction from 'ol/interaction/Interaction.js'\r\nimport ol_style_Style_defaultStyle from '../style/defaultStyle.js'\r\nimport ol_Collection from 'ol/Collection.js'\r\nimport ol_layer_Vector from 'ol/layer/Vector.js'\r\nimport ol_source_Vector from 'ol/source/Vector.js'\r\nimport ol_geom_Circle from 'ol/geom/Circle.js'\r\nimport {fromCircle as ol_geom_Polygon_fromCircle} from 'ol/geom/Polygon.js'\r\nimport ol_geom_Point from 'ol/geom/Point.js'\r\nimport ol_geom_LineString from 'ol/geom/LineString.js'\r\nimport ol_geom_Polygon from 'ol/geom/Polygon.js'\r\nimport ol_Feature from 'ol/Feature.js'\r\n\r\n/** Interaction rotate\r\n * @constructor\r\n * @extends {ol_interaction_Interaction}\r\n * @fires drawstart, drawing, drawend, drawcancel\r\n * @param {olx.interaction.TransformOptions} options\r\n *  @param {Array<ol.Layer>} options.source Destination source for the drawn features\r\n *  @param {ol.Collection<ol.Feature>} options.features Destination collection for the drawn features \r\n *  @param {ol.style.Style | Array.<ol.style.Style> | ol.style.StyleFunction | undefined} options.style style for the sketch\r\n *  @param {integer} options.sides number of sides, default 0 = circle\r\n *  @param { ol.events.ConditionType | undefined } options.condition A function that takes an ol.MapBrowserEvent and returns a boolean that event should be handled. By default module:ol/events/condition.always.\r\n *  @param { ol.events.ConditionType | undefined } options.squareCondition A function that takes an ol.MapBrowserEvent and returns a boolean to draw square features. Default test shift key\r\n *  @param { ol.events.ConditionType | undefined } options.centerCondition A function that takes an ol.MapBrowserEvent and returns a boolean to draw centered features. Default check Ctrl key\r\n *  @param { bool } options.canRotate Allow rotation when centered + square, default: true\r\n *  @param { string } [options.geometryName=geometry] \r\n *  @param { number } options.clickTolerance click tolerance on touch devices, default: 6\r\n *  @param { number } options.maxCircleCoordinates Maximum number of point on a circle, default: 100\r\n */\r\nvar ol_interaction_DrawRegular = class olinteractionDrawRegular extends ol_interaction_Interaction {\r\n  constructor(options) {\r\n    options = options || {}\r\n    \r\n    super({\r\n      handleEvent: function(e) { return self.handleEvent_(e) }\r\n    })\r\n\r\n    var self = this;\r\n\r\n    this.squaredClickTolerance_ = options.clickTolerance ? options.clickTolerance * options.clickTolerance : 36\r\n    this.maxCircleCoordinates_ = options.maxCircleCoordinates || 100\r\n\r\n    // Collection of feature to transform \r\n    this.features_ = options.features\r\n    // List of layers to transform \r\n    this.source_ = options.source\r\n    // Square condition\r\n    this.conditionFn_ = options.condition\r\n    // Square condition\r\n    this.squareFn_ = options.squareCondition\r\n    // Centered condition\r\n    this.centeredFn_ = options.centerCondition\r\n    // Allow rotation when centered + square\r\n    this.canRotate_ = (options.canRotate !== false)\r\n    // Specify custom geometry name\r\n    this.geometryName_ = options.geometryName || 'geometry'\r\n\r\n    // Number of sides (default=0: circle)\r\n    this.setSides(options.sides)\r\n\r\n    // Style\r\n    var defaultStyle = ol_style_Style_defaultStyle(true)\r\n\r\n    // Create a new overlay layer for the sketch\r\n    this.sketch_ = new ol_Collection()\r\n    this.overlayLayer_ = new ol_layer_Vector({\r\n      source: new ol_source_Vector({\r\n        features: this.sketch_,\r\n        useSpatialIndex: false\r\n      }),\r\n      name: 'DrawRegular overlay',\r\n      displayInLayerSwitcher: false,\r\n      style: options.style || defaultStyle\r\n    })\r\n  }\r\n  /**\r\n   * Remove the interaction from its current map, if any,  and attach it to a new\r\n   * map, if any. Pass `null` to just remove the interaction from the current map.\r\n   * @param {ol.Map} map Map.\r\n   * @api stable\r\n   */\r\n  setMap(map) {\r\n    if (this.getMap()) this.getMap().removeLayer(this.overlayLayer_)\r\n    super.setMap(map)\r\n    this.overlayLayer_.setMap(map)\r\n  }\r\n  /**\r\n   * Activate/deactivate the interaction\r\n   * @param {boolean}\r\n   * @api stable\r\n   */\r\n  setActive(b) {\r\n    this.reset()\r\n    super.setActive(b)\r\n  }\r\n  /**\r\n   * Reset the interaction\r\n   * @api stable\r\n   */\r\n  reset() {\r\n    if (this.overlayLayer_) this.overlayLayer_.getSource().clear()\r\n    this.started_ = false\r\n  }\r\n  /**\r\n   * Set the number of sides.\r\n   * @param {int} number of sides.\r\n   * @api stable\r\n   */\r\n  setSides(nb) {\r\n    nb = parseInt(nb)\r\n    this.sides_ = nb > 2 ? nb : 0\r\n  }\r\n  /**\r\n   * Allow rotation when centered + square\r\n   * @param {bool}\r\n   * @api stable\r\n   */\r\n  canRotate(b) {\r\n    if (b === true || b === false)\r\n      this.canRotate_ = b\r\n    return this.canRotate_\r\n  }\r\n  /**\r\n   * Get the number of sides.\r\n   * @return {int} number of sides.\r\n   * @api stable\r\n   */\r\n  getSides() {\r\n    return this.sides_\r\n  }\r\n  /** Get geom of the current drawing\r\n  * @return {ol.geom.Polygon | ol.geom.Point}\r\n  */\r\n  getGeom_() {\r\n    this.overlayLayer_.getSource().clear()\r\n    if (!this.center_)\r\n      return false\r\n\r\n    var g\r\n    if (this.coord_) {\r\n      var center = this.center_\r\n      var coord = this.coord_\r\n\r\n      // Specific case: circle\r\n      var d, dmax, r, circle, centerPx\r\n      if (!this.sides_ && this.square_ && !this.centered_) {\r\n        center = [(coord[0] + center[0]) / 2, (coord[1] + center[1]) / 2]\r\n        d = [coord[0] - center[0], coord[1] - center[1]]\r\n        r = Math.sqrt(d[0] * d[0] + d[1] * d[1])\r\n        circle = new ol_geom_Circle(center, r, 'XY')\r\n        // Optimize points on the circle\r\n        centerPx = this.getMap().getPixelFromCoordinate(center)\r\n        dmax = Math.max(100, Math.abs(centerPx[0] - this.coordPx_[0]), Math.abs(centerPx[1] - this.coordPx_[1]))\r\n        dmax = Math.min(this.maxCircleCoordinates_, Math.round(dmax / 3))\r\n        return ol_geom_Polygon_fromCircle(circle, dmax, 0)\r\n      } else {\r\n        var hasrotation = this.canRotate_ && this.centered_ && this.square_\r\n        d = [coord[0] - center[0], coord[1] - center[1]]\r\n        if (this.square_ && !hasrotation) {\r\n          //var d = [coord[0] - center[0], coord[1] - center[1]];\r\n          var dm = Math.max(Math.abs(d[0]), Math.abs(d[1]))\r\n          coord = [\r\n            center[0] + (d[0] > 0 ? dm : -dm),\r\n            center[1] + (d[1] > 0 ? dm : -dm)\r\n          ]\r\n        }\r\n        r = Math.sqrt(d[0] * d[0] + d[1] * d[1])\r\n        if (r > 0) {\r\n          circle = new ol_geom_Circle(center, r, 'XY')\r\n          var a\r\n          if (hasrotation)\r\n            a = Math.atan2(d[1], d[0])\r\n          else\r\n            a = this.startAngle[this.sides_] || this.startAngle['default']\r\n\r\n          if (this.sides_) {\r\n            g = ol_geom_Polygon_fromCircle(circle, this.sides_, a)\r\n          } else {\r\n            // Optimize points on the circle\r\n            centerPx = this.getMap().getPixelFromCoordinate(this.center_)\r\n            dmax = Math.max(100, Math.abs(centerPx[0] - this.coordPx_[0]), Math.abs(centerPx[1] - this.coordPx_[1]))\r\n            dmax = Math.min(this.maxCircleCoordinates_, Math.round(dmax / (this.centered_ ? 3 : 5)))\r\n            g = ol_geom_Polygon_fromCircle(circle, dmax, 0)\r\n          }\r\n\r\n          if (hasrotation)\r\n            return g\r\n\r\n          // Scale polygon to fit extent\r\n          var ext = g.getExtent()\r\n          if (!this.centered_)\r\n            center = this.center_\r\n          else\r\n            center = [2 * this.center_[0] - this.coord_[0], 2 * this.center_[1] - this.coord_[1]]\r\n          var scx = (center[0] - coord[0]) / (ext[0] - ext[2])\r\n          var scy = (center[1] - coord[1]) / (ext[1] - ext[3])\r\n          if (this.square_) {\r\n            var sc = Math.min(Math.abs(scx), Math.abs(scy))\r\n            scx = Math.sign(scx) * sc\r\n            scy = Math.sign(scy) * sc\r\n          }\r\n          var t = [center[0] - ext[0] * scx, center[1] - ext[1] * scy]\r\n\r\n          g.applyTransform(function (g1, g2, dim) {\r\n            for (var i = 0; i < g1.length; i += dim) {\r\n              g2[i] = g1[i] * scx + t[0]\r\n              g2[i + 1] = g1[i + 1] * scy + t[1]\r\n            }\r\n            return g2\r\n          })\r\n          return g\r\n        }\r\n      }\r\n    }\r\n\r\n    // No geom => return a point\r\n    return new ol_geom_Point(this.center_)\r\n  }\r\n  /** Draw sketch\r\n  * @return {ol.Feature} The feature being drawn.\r\n  */\r\n  drawSketch_(evt) {\r\n    this.overlayLayer_.getSource().clear()\r\n    if (evt) {\r\n      this.square_ = this.squareFn_ ? this.squareFn_(evt) : evt.originalEvent.shiftKey\r\n      this.centered_ = this.centeredFn_ ? this.centeredFn_(evt) : evt.originalEvent.metaKey || evt.originalEvent.ctrlKey\r\n      var g = this.getGeom_()\r\n      if (g) {\r\n        var f = this.feature_\r\n\r\n        //f.setGeometry (g);\r\n        if (g.getType() === 'Polygon')\r\n          f.getGeometry().setCoordinates(g.getCoordinates())\r\n        this.overlayLayer_.getSource().addFeature(f)\r\n        if (this.coord_\r\n          && this.square_\r\n          && ((this.canRotate_ && this.centered_ && this.coord_) || (!this.sides_ && !this.centered_))) {\r\n          this.overlayLayer_.getSource().addFeature(new ol_Feature(new ol_geom_LineString([this.center_, this.coord_])))\r\n        }\r\n        return f\r\n      }\r\n    }\r\n  }\r\n  /** Draw sketch (Point)\r\n  */\r\n  drawPoint_(pt, noclear) {\r\n    if (!noclear)\r\n      this.overlayLayer_.getSource().clear()\r\n    this.overlayLayer_.getSource().addFeature(new ol_Feature(new ol_geom_Point(pt)))\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} evt Map browser event.\r\n   */\r\n  handleEvent_(evt) {\r\n    var dx, dy\r\n    // Event date time\r\n    this._eventTime = new Date()\r\n    switch (evt.type) {\r\n      case \"pointerdown\": {\r\n        if (this.conditionFn_ && !this.conditionFn_(evt))\r\n          break\r\n        this.downPx_ = evt.pixel\r\n        this.start_(evt)\r\n        // Test long touch\r\n        var dt = 500\r\n        this._longTouch = false\r\n        setTimeout(function () {\r\n          this._longTouch = (new Date() - this._eventTime > .9 * dt)\r\n          if (this._longTouch)\r\n            this.handleMoveEvent_(evt)\r\n        }.bind(this), dt)\r\n        break\r\n      }\r\n      case \"pointerup\": {\r\n        // Started and fisrt move\r\n        if (this.started_ && this.coord_) {\r\n          dx = this.downPx_[0] - evt.pixel[0]\r\n          dy = this.downPx_[1] - evt.pixel[1]\r\n          if (dx * dx + dy * dy <= this.squaredClickTolerance_) {\r\n            // The pointer has moved\r\n            if (this.lastEvent == \"pointermove\" || this.lastEvent == \"keydown\") {\r\n              this.end_(evt)\r\n            }\r\n\r\n            // On touch device there is no move event : terminate = click on the same point\r\n            else {\r\n              dx = this.upPx_[0] - evt.pixel[0]\r\n              dy = this.upPx_[1] - evt.pixel[1]\r\n              if (dx * dx + dy * dy <= this.squaredClickTolerance_) {\r\n                this.end_(evt)\r\n              } else {\r\n                this.handleMoveEvent_(evt)\r\n                this.drawPoint_(evt.coordinate, true)\r\n              }\r\n            }\r\n          }\r\n        }\r\n        this.upPx_ = evt.pixel\r\n        break\r\n      }\r\n      case \"pointerdrag\": {\r\n        if (this.started_) {\r\n          var centerPx = this.getMap().getPixelFromCoordinate(this.center_)\r\n          dx = centerPx[0] - evt.pixel[0]\r\n          dy = centerPx[1] - evt.pixel[1]\r\n          if (dx * dx + dy * dy <= this.squaredClickTolerance_) {\r\n            this.reset()\r\n          }\r\n        }\r\n        return !this._longTouch\r\n        // break;\r\n      }\r\n      case \"pointermove\": {\r\n        if (this.started_) {\r\n          dx = this.downPx_[0] - evt.pixel[0]\r\n          dy = this.downPx_[1] - evt.pixel[1]\r\n          if (dx * dx + dy * dy > this.squaredClickTolerance_) {\r\n            this.handleMoveEvent_(evt)\r\n            this.lastEvent = evt.type\r\n          }\r\n        }\r\n        break\r\n      }\r\n      default: {\r\n        this.lastEvent = evt.type\r\n        // Prevent zoom in on dblclick\r\n        if (this.started_ && evt.type === 'dblclick') {\r\n          //evt.stopPropagation();\r\n          return false\r\n        }\r\n        break\r\n      }\r\n    }\r\n    return true\r\n  }\r\n  /** Stop drawing.\r\n   */\r\n  finishDrawing() {\r\n    if (this.started_ && this.coord_) {\r\n      this.end_({ pixel: this.upPx_, coordinate: this.coord_ })\r\n    }\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} evt Event.\r\n   */\r\n  handleMoveEvent_(evt) {\r\n    if (this.started_) {\r\n      this.coord_ = evt.coordinate\r\n      this.coordPx_ = evt.pixel\r\n      var f = this.drawSketch_(evt)\r\n      this.dispatchEvent({\r\n        type: 'drawing',\r\n        feature: f,\r\n        pixel: evt.pixel,\r\n        startCoordinate: this.center_,\r\n        coordinate: evt.coordinate,\r\n        square: this.square_,\r\n        centered: this.centered_\r\n      })\r\n    } else {\r\n      this.drawPoint_(evt.coordinate)\r\n    }\r\n  }\r\n  /** Start an new draw\r\n   * @param {ol.MapBrowserEvent} evt Map browser event.\r\n   * @return {boolean} `false` to stop the drag sequence.\r\n   */\r\n  start_(evt) {\r\n    if (!this.started_) {\r\n      this.started_ = true\r\n      this.center_ = evt.coordinate\r\n      this.coord_ = null\r\n      var f = this.feature_ = new ol_Feature({})\r\n      f.setGeometryName(this.geometryName_ || 'geometry')\r\n      f.setGeometry(new ol_geom_Polygon([[evt.coordinate, evt.coordinate, evt.coordinate]]))\r\n      this.drawSketch_(evt)\r\n      this.dispatchEvent({ type: 'drawstart', feature: f, pixel: evt.pixel, coordinate: evt.coordinate })\r\n    } else {\r\n      this.coord_ = evt.coordinate\r\n    }\r\n  }\r\n  /** End drawing\r\n   * @param {ol.MapBrowserEvent} evt Map browser event.\r\n   * @return {boolean} `false` to stop the drag sequence.\r\n   */\r\n  end_(evt) {\r\n    this.coord_ = evt.coordinate\r\n    this.started_ = false\r\n    if (this.coord_ && (this.center_[0] !== this.coord_[0] || this.center_[1] !== this.coord_[1])) {\r\n      var f = this.feature_\r\n\r\n      f.setGeometry(this.getGeom_())\r\n      if (this.source_)\r\n        this.source_.addFeature(f)\r\n      else if (this.features_)\r\n        this.features_.push(f)\r\n      this.dispatchEvent({ type: 'drawend', feature: f, pixel: evt.pixel, coordinate: evt.coordinate, square: this.square_, centered: this.centered_ })\r\n    } else {\r\n      this.dispatchEvent({ type: 'drawcancel', feature: null, pixel: evt.pixel, coordinate: evt.coordinate, square: this.square_, centered: this.centered_ })\r\n    }\r\n\r\n    this.center_ = this.coord_ = null\r\n    this.drawSketch_()\r\n  }\r\n}\r\n\r\n/** Default start angle array for each sides\r\n*/\r\nol_interaction_DrawRegular.prototype.startAngle = {\r\n  'default':Math.PI/2,\r\n  3: -Math.PI/2,\r\n  4: Math.PI/4\r\n};\r\n\r\nexport default ol_interaction_DrawRegular\r\n","/*\tCopyright (c) 2016 Jean-Marc VIGLINO, \r\n  released under the CeCILL-B license (French BSD license)\r\n  (http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).\r\n*/\r\n\r\nimport ol_style_Style from 'ol/style/Style.js'\r\nimport ol_style_Stroke from 'ol/style/Stroke.js'\r\nimport ol_source_Vector from 'ol/source/Vector.js'\r\nimport ol_style_Fill from 'ol/style/Fill.js'\r\nimport ol_style_Circle from 'ol/style/Circle.js'\r\nimport ol_layer_Vector from 'ol/layer/Vector.js'\r\nimport ol_geom_Point from 'ol/geom/Point.js'\r\nimport ol_Feature from 'ol/Feature.js'\r\nimport ol_geom_LineString from 'ol/geom/LineString.js'\r\nimport ol_interaction_Interaction from 'ol/interaction/Interaction.js'\r\nimport {ol_coordinate_dist2d, ol_coordinate_equal} from \"../geom/GeomUtils.js\";\r\nimport {boundingExtent as ol_extent_boundingExtent} from 'ol/extent.js'\r\nimport {buffer as ol_extent_buffer} from 'ol/extent.js'\r\nimport {altKeyOnly as ol_events_condition_altKeyOnly} from 'ol/events/condition.js'\r\nimport {primaryAction as ol_events_condition_primaryAction} from 'ol/events/condition.js'\r\nimport {always as ol_events_condition_always} from 'ol/events/condition.js'\r\n\r\nimport '../geom/LineStringSplitAt.js'\r\n\r\n/** Interaction for modifying feature geometries. Similar to the core ol/interaction/Modify.\r\n * The interaction is more suitable to use to handle feature modification: only features concerned \r\n * by the modification are passed to the events (instead of all feature with ol/interaction/Modify)\r\n * - the modifystart event is fired before the feature is modified (no points still inserted)\r\n * - the modifyend event is fired after the modification\r\n * - it fires a modifying event\r\n * @constructor\r\n * @extends {ol_interaction_Interaction}\r\n * @fires modifystart\r\n * @fires modifying\r\n * @fires modifyend\r\n * @fires select\r\n * @param {*} options\r\n *\t@param {ol.source.Vector} options.source a source to modify (configured with useSpatialIndex set to true)\r\n *\t@param {ol.source.Vector|Array<ol.source.Vector>} options.sources a list of source to modify (configured with useSpatialIndex set to true)\r\n *  @param {ol.Collection.<ol.Feature>} options.features collection of feature to modify\r\n *  @param {integer} options.pixelTolerance Pixel tolerance for considering the pointer close enough to a segment or vertex for editing. Default is 10.\r\n *  @param {function|undefined} options.filter a filter that takes a feature and return true if it can be modified, default always true.\r\n *  @param {ol.style.Style | Array<ol.style.Style> | undefined} options.style Style for the sketch features.\r\n *  @param {ol.EventsConditionType | undefined} options.condition A function that takes an ol.MapBrowserEvent and returns a boolean to indicate whether that event will be considered to add or move a vertex to the sketch. Default is ol.events.condition.primaryAction.\r\n *  @param {ol.EventsConditionType | undefined} options.deleteCondition A function that takes an ol.MapBrowserEvent and returns a boolean to indicate whether that event should be handled. By default, ol.events.condition.singleClick with ol.events.condition.altKeyOnly results in a vertex deletion.\r\n *  @param {ol.EventsConditionType | undefined} options.insertVertexCondition A function that takes an ol.MapBrowserEvent and returns a boolean to indicate whether a new vertex can be added to the sketch features. Default is ol.events.condition.always\r\n *  @param {boolean} options.wrapX Wrap the world horizontally on the sketch overlay, default false\r\n */\r\nvar ol_interaction_ModifyFeature = class olinteractionModifyFeature extends ol_interaction_Interaction {\r\n  constructor(options) {\r\n    options = options || {}\r\n\r\n    var dragging, modifying\r\n    super({\r\n      handleEvent: function (e) {\r\n        switch (e.type) {\r\n          case 'pointerdown': {\r\n            dragging = this.handleDownEvent(e)\r\n            modifying = dragging || this._deleteCondition(e)\r\n            return !dragging\r\n          }\r\n          case 'pointerup': {\r\n            dragging = false\r\n            return this.handleUpEvent(e)\r\n          }\r\n          case 'pointerdrag': {\r\n            if (dragging)\r\n              return this.handleDragEvent(e)\r\n            else\r\n              return true\r\n          }\r\n          case 'pointermove': {\r\n            if (!dragging){\r\n              return this.handleMoveEvent(e)\r\n            } else {\r\n              return false\r\n            }\r\n          }\r\n          case 'singleclick':\r\n          case 'click': {\r\n            // Prevent click when modifying\r\n            return !modifying\r\n          }\r\n          default: return true\r\n        }\r\n      }\r\n    })\r\n\r\n    // Snap distance (in px)\r\n    this.snapDistance_ = options.pixelTolerance || 10\r\n    // Split tolerance between the calculated intersection and the geometry\r\n    this.tolerance_ = 1e-10\r\n    // Cursor\r\n    this.cursor_ = options.cursor\r\n\r\n    // List of source to split\r\n    this.sources_ = options.sources ? (options.sources instanceof Array) ? options.sources : [options.sources] : []\r\n    if (options.source) {\r\n      this.sources_.push(options.source)\r\n    }\r\n    if (options.features) {\r\n      this.sources_.push(new ol_source_Vector({ features: options.features }))\r\n    }\r\n    // Get all features candidate\r\n    this.filterSplit_ = options.filter || function () { return true }\r\n\r\n    this._condition = options.condition || ol_events_condition_primaryAction\r\n    this._deleteCondition = options.deleteCondition || ol_events_condition_altKeyOnly\r\n    this._insertVertexCondition = options.insertVertexCondition || ol_events_condition_always\r\n\r\n    // Default style\r\n    var sketchStyle = function () {\r\n      return [new ol_style_Style({\r\n        image: new ol_style_Circle({\r\n          radius: 6,\r\n          fill: new ol_style_Fill({ color: [0, 153, 255, 1] }),\r\n          stroke: new ol_style_Stroke({ color: '#FFF', width: 1.25 })\r\n        })\r\n      })\r\n      ]\r\n    }\r\n\r\n    // Custom style\r\n    if (options.style) {\r\n      if (typeof (options.style) === 'function') {\r\n        sketchStyle = options.style\r\n      } else {\r\n        sketchStyle = function () { return options.style }\r\n      }\r\n    }\r\n\r\n    // Create a new overlay for the sketch\r\n    this.overlayLayer_ = new ol_layer_Vector({\r\n      source: new ol_source_Vector({\r\n        useSpatialIndex: false\r\n      }),\r\n      name: 'Modify overlay',\r\n      displayInLayerSwitcher: false,\r\n      style: sketchStyle,\r\n      wrapX: options.wrapX\r\n    })\r\n\r\n  }\r\n  /**\r\n   * Remove the interaction from its current map, if any,  and attach it to a new\r\n   * map, if any. Pass `null` to just remove the interaction from the current map.\r\n   * @param {ol.Map} map Map.\r\n   * @api stable\r\n   */\r\n  setMap(map) {\r\n    if (this.getMap()) this.getMap().removeLayer(this.overlayLayer_)\r\n    super.setMap(map)\r\n    this.overlayLayer_.setMap(map)\r\n  }\r\n  /**\r\n   * Activate or deactivate the interaction + remove the sketch.\r\n   * @param {boolean} active.\r\n   * @api stable\r\n   */\r\n  setActive(active) {\r\n    super.setActive(active)\r\n    if (this.overlayLayer_) this.overlayLayer_.getSource().clear()\r\n  }\r\n  /** Change the filter function\r\n   * @param {function|undefined} options.filter a filter that takes a feature and return true if it can be modified, default always true.\r\n   */\r\n  setFilter(filter) {\r\n    if (typeof (filter) === 'function')\r\n      this.filterSplit_ = filter\r\n    else if (filter === undefined)\r\n      this.filterSplit_ = function () { return true }\r\n  }\r\n  /** Get closest feature at pixel\r\n   * @param {ol.Pixel}\r\n   * @return {*}\r\n   * @private\r\n   */\r\n  getClosestFeature(e) {\r\n    var f, c, d = this.snapDistance_ + 1\r\n    for (var i = 0; i < this.sources_.length; i++) {\r\n      var source = this.sources_[i]\r\n      f = source.getClosestFeatureToCoordinate(e.coordinate)\r\n      if (f && this.filterSplit_(f)) {\r\n        var ci = f.getGeometry().getClosestPoint(e.coordinate)\r\n        var di = ol_coordinate_dist2d(e.coordinate, ci) / e.frameState.viewState.resolution\r\n        if (di < d) {\r\n          d = di\r\n          c = ci\r\n        }\r\n        break\r\n      }\r\n    }\r\n    if (d > this.snapDistance_) {\r\n      if (this.currentFeature)\r\n        this.dispatchEvent({ type: 'select', selected: [], deselected: [this.currentFeature] })\r\n      this.currentFeature = null\r\n      return false\r\n    } else {\r\n      // Snap to node\r\n      var coord = this.getNearestCoord(c, f.getGeometry())\r\n      if (coord) {\r\n        coord = coord.coord\r\n        var p = this.getMap().getPixelFromCoordinate(coord)\r\n        if (ol_coordinate_dist2d(e.pixel, p) < this.snapDistance_) {\r\n          c = coord\r\n        }\r\n        //\r\n        if (this.currentFeature !== f)\r\n          this.dispatchEvent({ type: 'select', selected: [f], deselected: [this.currentFeature] })\r\n        this.currentFeature = f\r\n        return { source: source, feature: f, coord: c }\r\n      }\r\n    }\r\n  }\r\n  /** Get nearest coordinate in a list\r\n  * @param {ol.coordinate} pt the point to find nearest\r\n  * @param {ol.geom} coords list of coordinates\r\n  * @return {*} the nearest point with a coord (projected point), dist (distance to the geom), ring (if Polygon)\r\n  */\r\n  getNearestCoord(pt, geom) {\r\n    var i, l, p, p0, dm\r\n    switch (geom.getType()) {\r\n      case 'Point': {\r\n        return { coord: geom.getCoordinates(), dist: ol_coordinate_dist2d(geom.getCoordinates(), pt) }\r\n      }\r\n      case 'MultiPoint': {\r\n        return this.getNearestCoord(pt, new ol_geom_LineString(geom.getCoordinates()))\r\n      }\r\n      case 'LineString':\r\n      case 'LinearRing': {\r\n        var d\r\n        dm = Number.MAX_VALUE\r\n        var coords = geom.getCoordinates()\r\n        for (i = 0; i < coords.length; i++) {\r\n          d = ol_coordinate_dist2d(pt, coords[i])\r\n          if (d < dm) {\r\n            dm = d\r\n            p0 = coords[i]\r\n          }\r\n        }\r\n        return { coord: p0, dist: dm }\r\n      }\r\n      case 'MultiLineString': {\r\n        var lstring = geom.getLineStrings()\r\n        p0 = false, dm = Number.MAX_VALUE\r\n        for (i = 0; l = lstring[i]; i++) {\r\n          p = this.getNearestCoord(pt, l)\r\n          if (p && p.dist < dm) {\r\n            p0 = p\r\n            dm = p.dist\r\n            p0.ring = i\r\n          }\r\n        }\r\n        return p0\r\n      }\r\n      case 'Polygon': {\r\n        var lring = geom.getLinearRings()\r\n        p0 = false\r\n        dm = Number.MAX_VALUE\r\n        for (i = 0; l = lring[i]; i++) {\r\n          p = this.getNearestCoord(pt, l)\r\n          if (p && p.dist < dm) {\r\n            p0 = p\r\n            dm = p.dist\r\n            p0.ring = i\r\n          }\r\n        }\r\n        return p0\r\n      }\r\n      case 'MultiPolygon': {\r\n        var poly = geom.getPolygons()\r\n        p0 = false\r\n        dm = Number.MAX_VALUE\r\n        for (i = 0; l = poly[i]; i++) {\r\n          p = this.getNearestCoord(pt, l)\r\n          if (p && p.dist < dm) {\r\n            p0 = p\r\n            dm = p.dist\r\n            p0.poly = i\r\n          }\r\n        }\r\n        return p0\r\n      }\r\n      case 'GeometryCollection': {\r\n        var g = geom.getGeometries()\r\n        p0 = false\r\n        dm = Number.MAX_VALUE\r\n        for (i = 0; l = g[i]; i++) {\r\n          p = this.getNearestCoord(pt, l)\r\n          if (p && p.dist < dm) {\r\n            p0 = p\r\n            dm = p.dist\r\n            p0.geom = i\r\n          }\r\n        }\r\n        return p0\r\n      }\r\n      default: return false\r\n    }\r\n  }\r\n  /** Get arcs concerned by a modification\r\n   * @param {ol.geom} geom the geometry concerned\r\n   * @param {ol.coordinate} coord pointed coordinates\r\n   */\r\n  getArcs(geom, coord) {\r\n    var arcs = false\r\n    var coords, i, s, l, g\r\n    switch (geom.getType()) {\r\n      case 'Point': {\r\n        if (ol_coordinate_equal(coord, geom.getCoordinates())) {\r\n          arcs = {\r\n            geom: geom,\r\n            type: geom.getType(),\r\n            coord1: [],\r\n            coord2: [],\r\n            node: true\r\n          }\r\n        }\r\n        break\r\n      }\r\n      case 'MultiPoint': {\r\n        coords = geom.getCoordinates()\r\n        for (i = 0; i < coords.length; i++) {\r\n          if (ol_coordinate_equal(coord, coords[i])) {\r\n            arcs = {\r\n              geom: geom,\r\n              type: geom.getType(),\r\n              index: i,\r\n              coord1: [],\r\n              coord2: [],\r\n              node: true\r\n            }\r\n            break\r\n          }\r\n        }\r\n        break\r\n      }\r\n      case 'LinearRing':\r\n      case 'LineString': {\r\n        var p = geom.getClosestPoint(coord)\r\n        if (ol_coordinate_dist2d(p, coord) < 1.5 * this.tolerance_) {\r\n          var split\r\n          // Split the line in two\r\n          if (geom.getType() === 'LinearRing') {\r\n            g = new ol_geom_LineString(geom.getCoordinates())\r\n            split = g.splitAt(coord, this.tolerance_)\r\n          } else {\r\n            split = geom.splitAt(coord, this.tolerance_)\r\n          }\r\n          // If more than 2\r\n          if (split.length > 2) {\r\n            coords = split[1].getCoordinates()\r\n            for (i = 2; s = split[i]; i++) {\r\n              var c = s.getCoordinates()\r\n              c.shift()\r\n              coords = coords.concat(c)\r\n            }\r\n            split = [split[0], new ol_geom_LineString(coords)]\r\n          }\r\n          // Split in two\r\n          if (split.length === 2) {\r\n            var c0 = split[0].getCoordinates()\r\n            var c1 = split[1].getCoordinates()\r\n            var nbpt = c0.length + c1.length - 1\r\n            c0.pop()\r\n            c1.shift()\r\n            arcs = {\r\n              geom: geom,\r\n              type: geom.getType(),\r\n              coord1: c0,\r\n              coord2: c1,\r\n              node: (geom.getCoordinates().length === nbpt),\r\n              closed: false\r\n            }\r\n          } else if (split.length === 1) {\r\n            s = split[0].getCoordinates()\r\n            var start = ol_coordinate_equal(s[0], coord)\r\n            var end = ol_coordinate_equal(s[s.length - 1], coord)\r\n            // Move first point\r\n            if (start) {\r\n              s.shift()\r\n              if (end)\r\n                s.pop()\r\n              arcs = {\r\n                geom: geom,\r\n                type: geom.getType(),\r\n                coord1: [],\r\n                coord2: s,\r\n                node: true,\r\n                closed: end\r\n              }\r\n            } else if (end) {\r\n              // Move last point\r\n              s.pop()\r\n              arcs = {\r\n                geom: geom,\r\n                type: geom.getType(),\r\n                coord1: s,\r\n                coord2: [],\r\n                node: true,\r\n                closed: false\r\n              }\r\n            }\r\n          }\r\n        }\r\n        break\r\n      }\r\n      case 'MultiLineString': {\r\n        var lstring = geom.getLineStrings()\r\n        for (i = 0; l = lstring[i]; i++) {\r\n          arcs = this.getArcs(l, coord)\r\n          if (arcs) {\r\n            arcs.geom = geom\r\n            arcs.type = geom.getType()\r\n            arcs.lstring = i\r\n            break\r\n          }\r\n        }\r\n        break\r\n      }\r\n      case 'Polygon': {\r\n        var lring = geom.getLinearRings()\r\n        for (i = 0; l = lring[i]; i++) {\r\n          arcs = this.getArcs(l, coord)\r\n          if (arcs) {\r\n            arcs.geom = geom\r\n            arcs.type = geom.getType()\r\n            arcs.index = i\r\n            break\r\n          }\r\n        }\r\n        break\r\n      }\r\n      case 'MultiPolygon': {\r\n        var poly = geom.getPolygons()\r\n        for (i = 0; l = poly[i]; i++) {\r\n          arcs = this.getArcs(l, coord)\r\n          if (arcs) {\r\n            arcs.geom = geom\r\n            arcs.type = geom.getType()\r\n            arcs.poly = i\r\n            break\r\n          }\r\n        }\r\n        break\r\n      }\r\n      case 'GeometryCollection': {\r\n        g = geom.getGeometries()\r\n        for (i = 0; l = g[i]; i++) {\r\n          arcs = this.getArcs(l, coord)\r\n          if (arcs) {\r\n            arcs.geom = geom\r\n            arcs.g = i\r\n            arcs.typeg = arcs.type\r\n            arcs.type = geom.getType()\r\n            break\r\n          }\r\n        }\r\n        break\r\n      }\r\n      default: {\r\n        console.error('ol/interaction/ModifyFeature ' + geom.getType() + ' not supported!')\r\n        break\r\n      }\r\n    }\r\n    return arcs\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} evt Map browser event.\r\n   * @return {boolean} `true` to start the drag sequence.\r\n   */\r\n  handleDownEvent(evt) {\r\n    if (!this.getActive())\r\n      return false\r\n\r\n    // Something to move ?\r\n    var current = this.getClosestFeature(evt)\r\n\r\n    if (current && (this._condition(evt) || this._deleteCondition(evt))) {\r\n      var features = []\r\n      this.arcs = []\r\n\r\n      // Get features concerned\r\n      this.sources_.forEach(function (s) {\r\n        var extent = ol_extent_buffer(ol_extent_boundingExtent([current.coord]), this.tolerance_)\r\n        features = features.concat(features, s.getFeaturesInExtent(extent))\r\n      }.bind(this))\r\n\r\n      // Get arcs concerned\r\n      this._modifiedFeatures = []\r\n      features.forEach(function (f) {\r\n        var a = this.getArcs(f.getGeometry(), current.coord)\r\n        if (a) {\r\n          if (this._insertVertexCondition(evt) || a.node) {\r\n            a.feature = f\r\n            this._modifiedFeatures.push(f)\r\n            this.arcs.push(a)\r\n          }\r\n        }\r\n      }.bind(this))\r\n\r\n      if (this._modifiedFeatures.length) {\r\n        if (this._deleteCondition(evt)) {\r\n          return !this._removePoint(current, evt)\r\n        } else {\r\n          this.dispatchEvent({\r\n            type: 'modifystart',\r\n            coordinate: current.coord,\r\n            originalEvent: evt.originalEvent,\r\n            features: this._modifiedFeatures\r\n          })\r\n          this.handleDragEvent({\r\n            coordinate: current.coord,\r\n            originalEvent: evt.originalEvent\r\n          })\r\n          return true\r\n        }\r\n      } else {\r\n        return true\r\n      }\r\n    } else {\r\n      return false\r\n    }\r\n  }\r\n  /** Get modified features\r\n   * @return {Array<ol.Feature>} list of modified features\r\n   */\r\n  getModifiedFeatures() {\r\n    return this._modifiedFeatures || []\r\n  }\r\n  /** Removes the vertex currently being pointed.\r\n   */\r\n  removePoint() {\r\n    this._removePoint({}, {})\r\n  }\r\n  /**\r\n   * @private\r\n   */\r\n  _getModification(a) {\r\n    var coords = a.coord1.concat(a.coord2)\r\n    switch (a.type) {\r\n      case 'LineString': {\r\n        if (a.closed)\r\n          coords.push(coords[0])\r\n        if (coords.length > 1) {\r\n          if (a.geom.getCoordinates().length != coords.length) {\r\n            a.coords = coords\r\n            return true\r\n          }\r\n        }\r\n        break\r\n      }\r\n      case 'MultiLineString': {\r\n        if (a.closed)\r\n          coords.push(coords[0])\r\n        if (coords.length > 1) {\r\n          var c = a.geom.getCoordinates()\r\n          if (c[a.lstring].length != coords.length) {\r\n            c[a.lstring] = coords\r\n            a.coords = c\r\n            return true\r\n          }\r\n        }\r\n        break\r\n      }\r\n      case 'Polygon': {\r\n        if (a.closed)\r\n          coords.push(coords[0])\r\n        if (coords.length > 3) {\r\n          c = a.geom.getCoordinates()\r\n          if (c[a.index].length != coords.length) {\r\n            c[a.index] = coords\r\n            a.coords = c\r\n            return true\r\n          }\r\n        }\r\n        break\r\n      }\r\n      case 'MultiPolygon': {\r\n        if (a.closed)\r\n          coords.push(coords[0])\r\n        if (coords.length > 3) {\r\n          c = a.geom.getCoordinates()\r\n          if (c[a.poly][a.index].length != coords.length) {\r\n            c[a.poly][a.index] = coords\r\n            a.coords = c\r\n            return true\r\n          }\r\n        }\r\n        break\r\n      }\r\n      case 'GeometryCollection': {\r\n        a.type = a.typeg\r\n        var geom = a.geom\r\n        var geoms = geom.getGeometries()\r\n        a.geom = geoms[a.g]\r\n        var found = this._getModification(a)\r\n        // Restore current arc\r\n        geom.setGeometries(geoms)\r\n        a.geom = geom\r\n        a.type = 'GeometryCollection'\r\n        return found\r\n      }\r\n      default: {\r\n        //console.error('ol/interaction/ModifyFeature '+a.type+' not supported!');\r\n        break\r\n      }\r\n    }\r\n    return false\r\n  }\r\n  /** Removes the vertex currently being pointed.\r\n   * @private\r\n   */\r\n  _removePoint(current, evt) {\r\n    if (!this.arcs)\r\n      return false\r\n\r\n    this.overlayLayer_.getSource().clear()\r\n\r\n    var found = false\r\n    // Get all modifications\r\n    this.arcs.forEach(function (a) {\r\n      found = found || this._getModification(a)\r\n    }.bind(this))\r\n\r\n    // Almost one point is removed\r\n    if (found) {\r\n      this.dispatchEvent({\r\n        type: 'modifystart',\r\n        coordinate: current.coord,\r\n        originalEvent: evt.originalEvent,\r\n        features: this._modifiedFeatures\r\n      })\r\n      this.arcs.forEach(function (a) {\r\n        if (a.geom.getType() === 'GeometryCollection') {\r\n          if (a.coords) {\r\n            var geoms = a.geom.getGeometries()\r\n            geoms[a.g].setCoordinates(a.coords)\r\n            a.geom.setGeometries(geoms)\r\n          }\r\n        } else {\r\n          if (a.coords)\r\n            a.geom.setCoordinates(a.coords)\r\n        }\r\n      }.bind(this))\r\n      this.dispatchEvent({\r\n        type: 'modifyend',\r\n        coordinate: current.coord,\r\n        originalEvent: evt.originalEvent,\r\n        features: this._modifiedFeatures\r\n      })\r\n    }\r\n\r\n    this.arcs = []\r\n    return found\r\n  }\r\n  /**\r\n   * @private\r\n   */\r\n  handleUpEvent(e) {\r\n    if (!this.getActive())\r\n      return false\r\n    if (!this.arcs || !this.arcs.length)\r\n      return true\r\n\r\n    this.overlayLayer_.getSource().clear()\r\n    this.dispatchEvent({\r\n      type: 'modifyend',\r\n      coordinate: e.coordinate,\r\n      originalEvent: e.originalEvent,\r\n      features: this._modifiedFeatures\r\n    })\r\n\r\n    this.arcs = []\r\n    return true\r\n  }\r\n  /**\r\n   * @private\r\n   */\r\n  setArcCoordinates(a, coords) {\r\n    var c\r\n    switch (a.type) {\r\n      case 'Point': {\r\n        a.geom.setCoordinates(coords[0])\r\n        break\r\n      }\r\n      case 'MultiPoint': {\r\n        c = a.geom.getCoordinates()\r\n        c[a.index] = coords[0]\r\n        a.geom.setCoordinates(c)\r\n        break\r\n      }\r\n      case 'LineString': {\r\n        a.geom.setCoordinates(coords)\r\n        break\r\n      }\r\n      case 'MultiLineString': {\r\n        c = a.geom.getCoordinates()\r\n        c[a.lstring] = coords\r\n        a.geom.setCoordinates(c)\r\n        break\r\n      }\r\n      case 'Polygon': {\r\n        c = a.geom.getCoordinates()\r\n        c[a.index] = coords\r\n        a.geom.setCoordinates(c)\r\n        break\r\n      }\r\n      case 'MultiPolygon': {\r\n        c = a.geom.getCoordinates()\r\n        c[a.poly][a.index] = coords\r\n        a.geom.setCoordinates(c)\r\n        break\r\n      }\r\n      case 'GeometryCollection': {\r\n        a.type = a.typeg\r\n        var geom = a.geom\r\n        var geoms = geom.getGeometries()\r\n        a.geom = geoms[a.g]\r\n        this.setArcCoordinates(a, coords)\r\n        geom.setGeometries(geoms)\r\n        a.geom = geom\r\n        a.type = 'GeometryCollection'\r\n        break\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * @private\r\n   */\r\n  handleDragEvent(e) {\r\n    if (!this.getActive()) return false\r\n    if (!this.arcs) return true\r\n\r\n    // Show sketch\r\n    this.overlayLayer_.getSource().clear()\r\n    var p = new ol_Feature(new ol_geom_Point(e.coordinate))\r\n    this.overlayLayer_.getSource().addFeature(p)\r\n\r\n    // Nothing to do\r\n    if (!this.arcs.length) return true\r\n\r\n    // Move arcs\r\n    this.arcs.forEach(function (a) {\r\n      var coords = a.coord1.concat([e.coordinate], a.coord2)\r\n      if (a.closed) coords.push(e.coordinate)\r\n      this.setArcCoordinates(a, coords)\r\n    }.bind(this))\r\n\r\n    this.dispatchEvent({\r\n      type: 'modifying',\r\n      coordinate: e.coordinate,\r\n      originalEvent: e.originalEvent,\r\n      features: this._modifiedFeatures\r\n    })\r\n\r\n    return true\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} evt Event.\r\n   * @private\r\n   */\r\n  handleMoveEvent(e) {\r\n    if (!this.getActive()) return true\r\n\r\n    this.overlayLayer_.getSource().clear()\r\n    var current = this.getClosestFeature(e)\r\n\r\n    // Draw sketch\r\n    if (current) {\r\n      var p = new ol_Feature(new ol_geom_Point(current.coord))\r\n      this.overlayLayer_.getSource().addFeature(p)\r\n    }\r\n\r\n    // Show cursor\r\n    var element = e.map.getTargetElement()\r\n    if (this.cursor_) {\r\n      if (current) {\r\n        if (element.style.cursor != this.cursor_) {\r\n          this.previousCursor_ = element.style.cursor\r\n          element.style.cursor = this.cursor_\r\n        }\r\n      } else if (this.previousCursor_ !== undefined) {\r\n        element.style.cursor = this.previousCursor_\r\n        this.previousCursor_ = undefined\r\n      }\r\n    }\r\n    return true\r\n  }\r\n  /** Get the current feature to modify\r\n   * @return {ol.Feature}\r\n   */\r\n  getCurrentFeature() {\r\n    return this.currentFeature\r\n  }\r\n}\r\n\r\nexport default ol_interaction_ModifyFeature","/*\tCopyright (c) 2016 Jean-Marc VIGLINO, \r\n\treleased under the CeCILL-B license (French BSD license)\r\n\t(http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).\r\n*/\r\nimport ol_interaction_Pointer from 'ol/interaction/Pointer.js'\r\nimport ol_geom_LineString from 'ol/geom/LineString.js'\r\nimport ol_geom_Polygon from 'ol/geom/Polygon.js'\r\nimport {ol_coordinate_dist2d, ol_coordinate_findSegment, ol_coordinate_offsetCoords} from \"../geom/GeomUtils.js\";\r\n\r\nimport ol_style_Style_defaultStyle from '../style/defaultStyle.js'\r\n\r\n/** Offset interaction for offseting feature geometry\r\n * @constructor\r\n * @extends {ol_interaction_Pointer}\r\n * @fires offsetstart\r\n * @fires offsetting\r\n * @fires offsetend\r\n * @param {any} options\r\n *\t@param {function} [options.filter] a function that takes a feature and a layer and return true if the feature can be modified\r\n *\t@param {ol.layer.Vector | Array<ol.layer.Vector>} options.layers list of feature to transform \r\n *\t@param {ol.Collection.<ol.Feature>} options.features collection of feature to transform\r\n *\t@param {ol.source.Vector | undefined} options.source source to duplicate feature when ctrl key is down\r\n *\t@param {boolean} options.duplicate force feature to duplicate (source must be set)\r\n *  @param {ol.style.Style | Array.<ol.style.Style> | ol.style.StyleFunction | undefined} style style for the sketch\r\n */\r\nvar ol_interaction_Offset = class olinteractionOffset extends ol_interaction_Pointer {\r\n  constructor(options) {\r\n    options = options || {};\r\n\r\n    // Extend pointer\r\n    super({\r\n      handleDownEvent: function(e) { return self.handleDownEvent_(e) },\r\n      handleDragEvent: function(e) { return self.handleDragEvent_(e) },\r\n      handleMoveEvent: function(e) { return self.handleMoveEvent_(e) },\r\n      handleUpEvent: function(e) { return self.handleUpEvent_(e) },\r\n    });\r\n    var self = this;\r\n\r\n    this._filter = options.filter;\r\n    // Collection of feature to transform\r\n    this.features_ = options.features;\r\n    // List of layers to transform\r\n    this.layers_ = options.layers ? (options.layers instanceof Array) ? options.layers : [options.layers] : null;\r\n    // duplicate\r\n    this.set('duplicate', options.duplicate);\r\n    this.source_ = options.source;\r\n    // Style\r\n    this._style = (typeof (options.style) === 'function') ? options.style : function () {\r\n      if (options.style)\r\n        return options.style;\r\n      else\r\n        return ol_style_Style_defaultStyle(true);\r\n    };\r\n\r\n    // init\r\n    this.previousCursor_ = false;\r\n  }\r\n  /** Get Feature at pixel\r\n   * @param {ol.MapBrowserEvent} evt Map browser event.\r\n   * @return {any} a feature and the hit point\r\n   * @private\r\n   */\r\n  getFeatureAtPixel_(e) {\r\n    var self = this;\r\n    return this.getMap().forEachFeatureAtPixel(e.pixel,\r\n      function (feature, layer) {\r\n        var current;\r\n        if (self._filter && !self._filter(feature, layer))\r\n          return false;\r\n        // feature belong to a layer\r\n        if (self.layers_) {\r\n          for (var i = 0; i < self.layers_.length; i++) {\r\n            if (self.layers_[i] === layer) {\r\n              current = feature;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n\r\n        // feature in the collection\r\n        else if (self.features_) {\r\n          self.features_.forEach(function (f) {\r\n            if (f === feature) {\r\n              current = feature;\r\n            }\r\n          });\r\n        }\r\n\r\n        // Others\r\n        else {\r\n          current = feature;\r\n        }\r\n\r\n        // Only poygon or linestring\r\n        var typeGeom = current.getGeometry().getType();\r\n        if (current && /Polygon|LineString/.test(typeGeom)) {\r\n          if (typeGeom === 'Polygon' && current.getGeometry().getCoordinates().length > 1)\r\n            return false;\r\n          // test distance\r\n          var p = current.getGeometry().getClosestPoint(e.coordinate);\r\n          var dx = p[0] - e.coordinate[0];\r\n          var dy = p[1] - e.coordinate[1];\r\n          var d = Math.sqrt(dx * dx + dy * dy) / e.frameState.viewState.resolution;\r\n\r\n          if (d < 5) {\r\n            return {\r\n              feature: current,\r\n              hit: p,\r\n              coordinates: current.getGeometry().getCoordinates(),\r\n              geom: current.getGeometry().clone(),\r\n              geomType: typeGeom\r\n            };\r\n          } else {\r\n            return false;\r\n          }\r\n        } else {\r\n          return false;\r\n        }\r\n      }, { hitTolerance: 5 });\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} e Map browser event.\r\n   * @return {boolean} `true` to start the drag sequence.\r\n   * @private\r\n   */\r\n  handleDownEvent_(e) {\r\n    this.current_ = this.getFeatureAtPixel_(e);\r\n    if (this.current_) {\r\n      this.currentStyle_ = this.current_.feature.getStyle();\r\n      if (this.source_ && (this.get('duplicate') || e.originalEvent.ctrlKey)) {\r\n        this.current_.feature = this.current_.feature.clone();\r\n        this.current_.feature.setStyle(this._style(this.current_.feature));\r\n        this.source_.addFeature(this.current_.feature);\r\n      } else {\r\n        // Modify the current feature\r\n        this.current_.feature.setStyle(this._style(this.current_.feature));\r\n        this._modifystart = true;\r\n      }\r\n      this.dispatchEvent({ type: 'offsetstart', feature: this.current_.feature, offset: 0 });\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} e Map browser event.\r\n   * @private\r\n   */\r\n  handleDragEvent_(e) {\r\n    if (this._modifystart) {\r\n      this.dispatchEvent({ type: 'modifystart', features: [this.current_.feature] });\r\n      this._modifystart = false;\r\n    }\r\n    var p = this.current_.geom.getClosestPoint(e.coordinate);\r\n    var d = ol_coordinate_dist2d(p, e.coordinate);\r\n    var seg, v1, v2, offset;\r\n    switch (this.current_.geomType) {\r\n      case 'Polygon': {\r\n        seg = ol_coordinate_findSegment(p, this.current_.coordinates[0]).segment;\r\n        if (seg) {\r\n          v1 = [seg[1][0] - seg[0][0], seg[1][1] - seg[0][1]];\r\n          v2 = [e.coordinate[0] - p[0], e.coordinate[1] - p[1]];\r\n          if (v1[0] * v2[1] - v1[1] * v2[0] > 0) {\r\n            d = -d;\r\n          }\r\n\r\n          offset = [];\r\n          for (var i = 0; i < this.current_.coordinates.length; i++) {\r\n            offset.push(ol_coordinate_offsetCoords(this.current_.coordinates[i], i == 0 ? d : -d));\r\n          }\r\n          this.current_.feature.setGeometry(new ol_geom_Polygon(offset));\r\n        }\r\n        break;\r\n      }\r\n      case 'LineString': {\r\n        seg = ol_coordinate_findSegment(p, this.current_.coordinates).segment;\r\n        if (seg) {\r\n          v1 = [seg[1][0] - seg[0][0], seg[1][1] - seg[0][1]];\r\n          v2 = [e.coordinate[0] - p[0], e.coordinate[1] - p[1]];\r\n          if (v1[0] * v2[1] - v1[1] * v2[0] > 0) {\r\n            d = -d;\r\n          }\r\n          offset = ol_coordinate_offsetCoords(this.current_.coordinates, d);\r\n          this.current_.feature.setGeometry(new ol_geom_LineString(offset));\r\n        }\r\n        break;\r\n      }\r\n      default: {\r\n        break;\r\n      }\r\n    }\r\n    this.dispatchEvent({ type: 'offsetting', feature: this.current_.feature, offset: d, segment: [p, e.coordinate], coordinate: e.coordinate });\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} e Map browser event.\r\n   * @private\r\n   */\r\n  handleUpEvent_(e) {\r\n    if (!this._modifystart) {\r\n      this.dispatchEvent({ type: 'offsetend', feature: this.current_.feature, coordinate: e.coordinate });\r\n    }\r\n    this.current_.feature.setStyle(this.currentStyle_);\r\n    this.current_ = false;\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} e Event.\r\n   * @private\r\n   */\r\n  handleMoveEvent_(e) {\r\n    var f = this.getFeatureAtPixel_(e);\r\n    if (f) {\r\n      if (this.previousCursor_ === false) {\r\n        this.previousCursor_ = e.map.getTargetElement().style.cursor;\r\n      }\r\n      e.map.getTargetElement().style.cursor = 'pointer';\r\n    } else {\r\n      e.map.getTargetElement().style.cursor = this.previousCursor_;\r\n      this.previousCursor_ = false;\r\n    }\r\n  }\r\n}\r\n\r\nexport default ol_interaction_Offset\r\n","/*\tCopyright (c) 2016 Jean-Marc VIGLINO, \r\n  released under the CeCILL-B license (French BSD license)\r\n  (http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).\r\n*/\r\n\r\nimport ol_interaction_Interaction from 'ol/interaction/Interaction.js'\r\nimport ol_style_Style from 'ol/style/Style.js'\r\nimport ol_style_Stroke from 'ol/style/Stroke.js'\r\nimport ol_source_Vector from 'ol/source/Vector.js'\r\nimport ol_style_Fill from 'ol/style/Fill.js'\r\nimport ol_style_Circle from 'ol/style/Circle.js'\r\nimport ol_layer_Vector from 'ol/layer/Vector.js'\r\nimport ol_geom_Point from 'ol/geom/Point.js'\r\nimport ol_Feature from 'ol/Feature.js'\r\nimport ol_geom_LineString from 'ol/geom/LineString.js'\r\nimport {ol_coordinate_dist2d} from \"../geom/GeomUtils.js\";\r\nimport '../geom/LineStringSplitAt.js'\r\n\r\n/** Interaction split interaction for splitting feature geometry\r\n * @constructor\r\n * @extends {ol_interaction_Interaction}\r\n * @fires  beforesplit, aftersplit, pointermove\r\n * @param {*} \r\n *  @param {ol.source.Vector|Array<ol.source.Vector>} [options.sources] a list of source to split (configured with useSpatialIndex set to true), if none use map visible layers.\r\n *  @param {ol.Collection.<ol.Feature>} options.features collection of feature to split (instead of a list of sources)\r\n *  @param {integer} options.snapDistance distance (in px) to snap to an object, default 25px\r\n *\t@param {string|undefined} options.cursor cursor name to display when hovering an objet\r\n *  @param {function|undefined} options.filter a filter that takes a feature and return true if it can be clipped, default always split.\r\n *  @param ol_style_Style | Array<ol_style_Style> | false | undefined} options.featureStyle Style for the selected features, choose false if you don't want feature selection. By default the default edit style is used.\r\n *  @param {ol_style_Style | Array<ol_style_Style> | undefined} options.sketchStyle Style for the sektch features. \r\n *  @param {function|undefined} options.tolerance Distance between the calculated intersection and a vertex on the source geometry below which the existing vertex will be used for the split.  Default is 1e-10.\r\n */\r\nvar ol_interaction_Split = class olinteractionSplit extends ol_interaction_Interaction {\r\n  constructor(options) {\r\n    if (!options)\r\n      options = {}\r\n\r\n    super({\r\n      handleEvent: function (e) {\r\n        switch (e.type) {\r\n          case \"singleclick\":\r\n            return this.handleDownEvent(e)\r\n          case \"pointermove\":\r\n            return this.handleMoveEvent(e)\r\n          default:\r\n            return true\r\n        }\r\n        //return true;\r\n      }\r\n    })\r\n\r\n    // Snap distance (in px)\r\n    this.snapDistance_ = options.snapDistance || 25\r\n    // Split tolerance between the calculated intersection and the geometry\r\n    this.tolerance_ = options.tolerance || 1e-10\r\n    // Cursor\r\n    this.cursor_ = options.cursor\r\n\r\n    // List of source to split\r\n    this.setSources(options.sources)\r\n\r\n    if (options.features) {\r\n      this.sources_.push(new ol_source_Vector({ features: options.features }))\r\n    }\r\n\r\n    // Get all features candidate\r\n    this.filterSplit_ = options.filter || function () { return true }\r\n\r\n    // Default style\r\n    var white = [255, 255, 255, 1]\r\n    var blue = [0, 153, 255, 1]\r\n    var width = 3\r\n    var fill = new ol_style_Fill({ color: 'rgba(255,255,255,0.4)' })\r\n    var stroke = new ol_style_Stroke({\r\n      color: '#3399CC',\r\n      width: 1.25\r\n    })\r\n    var sketchStyle = [\r\n      new ol_style_Style({\r\n        image: new ol_style_Circle({\r\n          fill: fill,\r\n          stroke: stroke,\r\n          radius: 5\r\n        }),\r\n        fill: fill,\r\n        stroke: stroke\r\n      })\r\n    ]\r\n    var featureStyle = [\r\n      new ol_style_Style({\r\n        stroke: new ol_style_Stroke({\r\n          color: white,\r\n          width: width + 2\r\n        })\r\n      }),\r\n      new ol_style_Style({\r\n        image: new ol_style_Circle({\r\n          radius: 2 * width,\r\n          fill: new ol_style_Fill({\r\n            color: blue\r\n          }),\r\n          stroke: new ol_style_Stroke({\r\n            color: white,\r\n            width: width / 2\r\n          })\r\n        }),\r\n        stroke: new ol_style_Stroke({\r\n          color: blue,\r\n          width: width\r\n        })\r\n      }),\r\n    ]\r\n\r\n    // Custom style\r\n    if (options.sketchStyle)\r\n      sketchStyle = options.sketchStyle instanceof Array ? options.sketchStyle : [options.sketchStyle]\r\n    if (options.featureStyle)\r\n      featureStyle = options.featureStyle instanceof Array ? options.featureStyle : [options.featureStyle]\r\n\r\n    // Create a new overlay for the sketch\r\n    this.overlayLayer_ = new ol_layer_Vector({\r\n      source: new ol_source_Vector({\r\n        useSpatialIndex: false\r\n      }),\r\n      name: 'Split overlay',\r\n      displayInLayerSwitcher: false,\r\n      style: function (f) {\r\n        if (f._sketch_)\r\n          return sketchStyle\r\n        else\r\n          return featureStyle\r\n      }\r\n    })\r\n\r\n  }\r\n  /**\r\n   * Remove the interaction from its current map, if any,  and attach it to a new\r\n   * map, if any. Pass `null` to just remove the interaction from the current map.\r\n   * @param {ol.Map} map Map.\r\n   * @api stable\r\n   */\r\n  setMap(map) {\r\n    if (this.getMap()) {\r\n      this.getMap().removeLayer(this.overlayLayer_)\r\n    }\r\n    super.setMap(map)\r\n    this.overlayLayer_.setMap(map)\r\n  }\r\n  /** Get sources to split features in\r\n   * @return {Array<ol.source.Vector>}\r\n   */\r\n  getSources() {\r\n    if (!this.sources_ && this.getMap()) {\r\n      var sources = []\r\n      var getSources = function (layers) {\r\n        layers.forEach(function (layer) {\r\n          if (layer.getVisible()) {\r\n            if (layer.getSource && layer.getSource() instanceof ol_source_Vector) {\r\n              sources.unshift(layer.getSource())\r\n            } else if (layer.getLayers) {\r\n              getSources(layer.getLayers())\r\n            }\r\n          }\r\n        })\r\n      }\r\n      getSources(this.getMap().getLayers())\r\n      return sources\r\n    }\r\n    return this.sources_ || []\r\n  }\r\n  /** Set sources to split features in\r\n   * @param {ol.source.Vector|Array<ol.source.Vector>} [sources]\r\n   */\r\n  setSources(sources) {\r\n    this.sources_ = sources ? (sources instanceof Array ? sources || false : [sources]) : false\r\n  }\r\n  /** Get closest feature at pixel\r\n   * @param {ol.Pixel}\r\n   * @return {ol.feature}\r\n   * @private\r\n   */\r\n  getClosestFeature(e) {\r\n    var source, f, c, g, d = this.snapDistance_ + 1\r\n    // Look for closest point in the sources\r\n    this.getSources().forEach(function (si) {\r\n      var fi = si.getClosestFeatureToCoordinate(e.coordinate)\r\n      if (fi && fi.getGeometry().splitAt) {\r\n        var ci = fi.getGeometry().getClosestPoint(e.coordinate)\r\n        var gi = new ol_geom_LineString([e.coordinate, ci])\r\n        var di = gi.getLength() / e.frameState.viewState.resolution\r\n        if (di < d) {\r\n          source = si\r\n          d = di\r\n          f = fi\r\n          g = gi\r\n          c = ci\r\n        }\r\n      }\r\n    })\r\n    // Snap ?\r\n    if (d > this.snapDistance_) {\r\n      return false\r\n    } else {\r\n      // Snap to node\r\n      var coord = this.getNearestCoord(c, f.getGeometry().getCoordinates())\r\n      var p = this.getMap().getPixelFromCoordinate(coord)\r\n      if (ol_coordinate_dist2d(e.pixel, p) < this.snapDistance_) {\r\n        c = coord\r\n      }\r\n      //\r\n      return { source: source, feature: f, coord: c, link: g }\r\n    }\r\n  }\r\n  /** Get nearest coordinate in a list\r\n  * @param {ol.coordinate} pt the point to find nearest\r\n  * @param {Array<ol.coordinate>} coords list of coordinates\r\n  * @return {ol.coordinate} the nearest coordinate in the list\r\n  */\r\n  getNearestCoord(pt, coords) {\r\n    var d, dm = Number.MAX_VALUE, p0\r\n    for (var i = 0; i < coords.length; i++) {\r\n      d = ol_coordinate_dist2d(pt, coords[i])\r\n      if (d < dm) {\r\n        dm = d\r\n        p0 = coords[i]\r\n      }\r\n    }\r\n    return p0\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} evt Map browser event.\r\n   * @return {boolean} `true` to start the drag sequence.\r\n   */\r\n  handleDownEvent(evt) {\r\n    // Something to split ?\r\n    var current = this.getClosestFeature(evt)\r\n\r\n    if (current) {\r\n      var self = this\r\n      self.overlayLayer_.getSource().clear()\r\n      var split = current.feature.getGeometry().splitAt(current.coord, this.tolerance_)\r\n      var i\r\n      if (split.length > 1) {\r\n        var tosplit = []\r\n        for (i = 0; i < split.length; i++) {\r\n          var f = current.feature.clone()\r\n          f.setGeometry(split[i])\r\n          tosplit.push(f)\r\n        }\r\n        self.dispatchEvent({ type: 'beforesplit', original: current.feature, features: tosplit })\r\n        current.source.dispatchEvent({ type: 'beforesplit', original: current.feature, features: tosplit })\r\n        current.source.removeFeature(current.feature)\r\n        for (i = 0; i < tosplit.length; i++) {\r\n          current.source.addFeature(tosplit[i])\r\n        }\r\n        self.dispatchEvent({ type: 'aftersplit', original: current.feature, features: tosplit })\r\n        current.source.dispatchEvent({ type: 'aftersplit', original: current.feature, features: tosplit })\r\n      }\r\n    }\r\n    return false\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} evt Event.\r\n   */\r\n  handleMoveEvent(e) {\r\n    var map = e.map\r\n    this.overlayLayer_.getSource().clear()\r\n    var current = this.getClosestFeature(e)\r\n\r\n    if (current && this.filterSplit_(current.feature)) {\r\n      var p, l\r\n      // Draw sketch\r\n      this.overlayLayer_.getSource().addFeature(current.feature)\r\n      p = new ol_Feature(new ol_geom_Point(current.coord))\r\n      p._sketch_ = true\r\n      this.overlayLayer_.getSource().addFeature(p)\r\n      //\r\n      l = new ol_Feature(current.link)\r\n      l._sketch_ = true\r\n      this.overlayLayer_.getSource().addFeature(l)\r\n      // move event\r\n      this.dispatchEvent({\r\n        type: 'pointermove',\r\n        coordinate: e.coordinate,\r\n        frameState: e.frameState,\r\n        originalEvent: e.originalEvent,\r\n        map: e.map,\r\n        pixel: e.pixel,\r\n        feature: current.feature,\r\n        linkGeometry: current.link\r\n      })\r\n    } else {\r\n      this.dispatchEvent(e)\r\n    }\r\n\r\n    var element = map.getTargetElement()\r\n    if (this.cursor_) {\r\n      if (current) {\r\n        if (element.style.cursor != this.cursor_) {\r\n          this.previousCursor_ = element.style.cursor\r\n          element.style.cursor = this.cursor_\r\n        }\r\n      } else if (this.previousCursor_ !== undefined) {\r\n        element.style.cursor = this.previousCursor_\r\n        this.previousCursor_ = undefined\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport default ol_interaction_Split\r\n","import ol_style_Style from 'ol/style/Style.js'\r\nimport ol_style_Stroke from 'ol/style/Stroke.js'\r\nimport ol_source_Vector from 'ol/source/Vector.js'\r\nimport ol_style_Fill from 'ol/style/Fill.js'\r\nimport ol_layer_Vector from 'ol/layer/Vector.js'\r\nimport ol_geom_Point from 'ol/geom/Point.js'\r\nimport ol_Feature from 'ol/Feature.js'\r\nimport ol_Collection from 'ol/Collection.js'\r\nimport ol_interaction_Pointer from 'ol/interaction/Pointer.js'\r\nimport ol_style_RegularShape from 'ol/style/RegularShape.js'\r\nimport {fromExtent as ol_geom_Polygon_fromExtent} from 'ol/geom/Polygon.js'\r\nimport {boundingExtent as ol_extent_boundingExtent, buffer as ol_extent_buffer, createEmpty as ol_extent_createEmpty, extend as ol_extent_extend, getCenter as ol_extent_getCenter} from 'ol/extent.js'\r\nimport {unByKey as ol_Observable_unByKey} from 'ol/Observable.js'\r\nimport ol_geom_Polygon from 'ol/geom/Polygon.js'\r\n\r\n/** Interaction rotate\r\n * @constructor\r\n * @extends {ol_interaction_Pointer}\r\n * @fires select | rotatestart | rotating | rotateend | translatestart | translating | translateend | scalestart | scaling | scaleend\r\n * @param {any} options\r\n *  @param {function} options.filter A function that takes a Feature and a Layer and returns true if the feature may be transformed or false otherwise.\r\n *  @param {Array<ol.Layer>} options.layers array of layers to transform,\r\n *  @param {ol.Collection<ol.Feature>} options.features collection of feature to transform,\r\n *\t@param {ol.EventsConditionType|undefined} options.condition A function that takes an ol.MapBrowserEvent and a feature collection and returns a boolean to indicate whether that event should be handled. default: ol.events.condition.always.\r\n *\t@param {ol.EventsConditionType|undefined} options.addCondition A function that takes an ol.MapBrowserEvent and returns a boolean to indicate whether that event should be handled ie. the feature will be added to the transforms features. default: ol.events.condition.never.\r\n *\t@param {number | undefined} options.hitTolerance Tolerance to select feature in pixel, default 0\r\n *\t@param {bool} options.translateFeature Translate when click on feature\r\n *\t@param {bool} options.translate Can translate the feature\r\n *  @param {bool} options.translateBBox Enable translate when the user drags inside the bounding box\r\n *\t@param {bool} options.stretch can stretch the feature\r\n *\t@param {bool} options.scale can scale the feature\r\n *\t@param {bool} options.rotate can rotate the feature\r\n *\t@param {bool} options.noFlip prevent the feature geometry to flip, default false\r\n *\t@param {bool} options.selection the intraction handle selection/deselection, if not use the select prototype to add features to transform, default true\r\n *\t@param {ol.events.ConditionType | undefined} options.keepAspectRatio A function that takes an ol.MapBrowserEvent and returns a boolean to keep aspect ratio, default ol.events.condition.shiftKeyOnly.\r\n *\t@param {ol.events.ConditionType | undefined} options.modifyCenter A function that takes an ol.MapBrowserEvent and returns a boolean to apply scale & strech from the center, default ol.events.condition.metaKey or ol.events.condition.ctrlKey.\r\n *\t@param {boolean} options.enableRotatedTransform Enable transform when map is rotated\r\n *\t@param {boolean} [options.keepRectangle=false] keep rectangle when possible\r\n *\t@param {*} options.style list of ol.style for handles\r\n *  @param {number|Array<number>|function} [options.pointRadius=0] radius for points or a function that takes a feature and returns the radius (or [radiusX, radiusY]). If not null show handles to transform the points\r\n */\r\nvar ol_interaction_Transform = class olinteractionTransform extends ol_interaction_Pointer {\r\n  constructor(options) {\r\n    options = options || {}\r\n    // Extend pointer\r\n    super({\r\n      handleDownEvent: function(e) { return self.handleDownEvent_(e) },\r\n      handleDragEvent: function(e) { return this.handleDragEvent_(e) },\r\n      handleMoveEvent: function(e) { return this.handleMoveEvent_(e) },\r\n      handleUpEvent: function(e) { return this.handleUpEvent_(e) },\r\n    })\r\n    \r\n    var self = this\r\n    this.selection_ = new ol_Collection()\r\n\r\n    // Create a new overlay layer for the sketch\r\n    this.handles_ = new ol_Collection()\r\n    this.overlayLayer_ = new ol_layer_Vector({\r\n      source: new ol_source_Vector({\r\n        features: this.handles_,\r\n        useSpatialIndex: false,\r\n        wrapX: false // For vector editing across the -180° and 180° meridians to work properly, this should be set to false\r\n      }),\r\n      name: 'Transform overlay',\r\n      displayInLayerSwitcher: false,\r\n      // Return the style according to the handle type\r\n      style: function (feature) {\r\n        return (self.style[(feature.get('handle') || 'default') + (feature.get('constraint') || '') + (feature.get('option') || '')])\r\n      },\r\n    })\r\n\r\n    // Collection of feature to transform\r\n    this.features_ = options.features\r\n    // Filter or list of layers to transform\r\n    if (typeof (options.filter) === 'function')\r\n      this._filter = options.filter\r\n    this.layers_ = options.layers ? (options.layers instanceof Array) ? options.layers : [options.layers] : null\r\n\r\n    this._handleEvent = options.condition || function () { return true }\r\n    this.addFn_ = options.addCondition || function () { return false }\r\n    this.setPointRadius(options.pointRadius)\r\n    /* Translate when click on feature */\r\n    this.set('translateFeature', (options.translateFeature !== false))\r\n    /* Can translate the feature */\r\n    this.set('translate', (options.translate !== false))\r\n    /* Translate when click on the bounding box */\r\n    this.set('translateBBox', (options.translateBBox === true))\r\n    /* Can stretch the feature */\r\n    this.set('stretch', (options.stretch !== false))\r\n    /* Can scale the feature */\r\n    this.set('scale', (options.scale !== false))\r\n    /* Can rotate the feature */\r\n    this.set('rotate', (options.rotate !== false))\r\n    /* Keep aspect ratio */\r\n    this.set('keepAspectRatio', (options.keepAspectRatio || function (e) { return e.originalEvent.shiftKey }))\r\n    /* Modify center */\r\n    this.set('modifyCenter', (options.modifyCenter || function (e) { return e.originalEvent.metaKey || e.originalEvent.ctrlKey }))\r\n    /* Prevent flip */\r\n    this.set('noFlip', (options.noFlip || false))\r\n    /* Handle selection */\r\n    this.set('selection', (options.selection !== false))\r\n    /*  */\r\n    this.set('hitTolerance', (options.hitTolerance || 0))\r\n    /* Enable view rotated transforms */\r\n    this.set('enableRotatedTransform', (options.enableRotatedTransform || false))\r\n    /* Keep rectangle angles 90 degrees */\r\n    this.set('keepRectangle', (options.keepRectangle || false))\r\n\r\n\r\n    // Force redraw when changed\r\n    this.on('propertychange', function () {\r\n      this.drawSketch_()\r\n    })\r\n\r\n    // setstyle\r\n    this.setDefaultStyle()\r\n  }\r\n  /**\r\n   * Remove the interaction from its current map, if any,  and attach it to a new\r\n   * map, if any. Pass `null` to just remove the interaction from the current map.\r\n   * @param {ol.Map} map Map.\r\n   * @api stable\r\n   */\r\n  setMap(map) {\r\n    var oldMap = this.getMap()\r\n    if (oldMap) {\r\n      var targetElement = oldMap.getTargetElement()\r\n      oldMap.removeLayer(this.overlayLayer_)\r\n      if (this.previousCursor_ && targetElement) {\r\n        targetElement.style.cursor = this.previousCursor_\r\n      }\r\n      this.previousCursor_ = undefined\r\n    }\r\n    super.setMap(map)\r\n    this.overlayLayer_.setMap(map)\r\n    if (map === null) {\r\n      this.select(null)\r\n    }\r\n    if (map !== null) {\r\n      this.isTouch = /touch/.test(map.getViewport().className)\r\n      this.setDefaultStyle()\r\n    }\r\n  }\r\n  /**\r\n   * Activate/deactivate interaction\r\n   * @param {bool}\r\n   * @api stable\r\n   */\r\n  setActive(b) {\r\n    this.select(null)\r\n    if (this.overlayLayer_) this.overlayLayer_.setVisible(b)\r\n    super.setActive(b)\r\n  }\r\n  /** Set default sketch style\r\n   * @param {Object|undefined} options\r\n   *  @param {ol_style_Stroke} stroke stroke style for selection rectangle\r\n   *  @param {ol_style_Fill} fill fill style for selection rectangle\r\n   *  @param {ol_style_Stroke} pointStroke stroke style for handles\r\n   *  @param {ol_style_Fill} pointFill fill style for handles\r\n   */\r\n  setDefaultStyle(options) {\r\n    options = options || {}\r\n    // Style\r\n    var stroke = options.pointStroke || new ol_style_Stroke({ color: [255, 0, 0, 1], width: 1 })\r\n    var strokedash = options.stroke || new ol_style_Stroke({ color: [255, 0, 0, 1], width: 1, lineDash: [4, 4] })\r\n    var fill0 = options.fill || new ol_style_Fill({ color: [255, 0, 0, 0.01] })\r\n    var fill = options.pointFill || new ol_style_Fill({ color: [255, 255, 255, 0.8] })\r\n    var circle = new ol_style_RegularShape({\r\n      fill: fill,\r\n      stroke: stroke,\r\n      radius: this.isTouch ? 12 : 6,\r\n      displacement: this.isTouch ? [24, -24] : [12, -12],\r\n      points: 15\r\n    })\r\n    // Old version with no displacement\r\n    if (!circle.setDisplacement)\r\n      circle.getAnchor()[0] = this.isTouch ? -10 : -5\r\n    var bigpt = new ol_style_RegularShape({\r\n      fill: fill,\r\n      stroke: stroke,\r\n      radius: this.isTouch ? 16 : 8,\r\n      points: 4,\r\n      angle: Math.PI / 4\r\n    })\r\n    var smallpt = new ol_style_RegularShape({\r\n      fill: fill,\r\n      stroke: stroke,\r\n      radius: this.isTouch ? 12 : 6,\r\n      points: 4,\r\n      angle: Math.PI / 4\r\n    })\r\n    function createStyle(img, stroke, fill) {\r\n      return [new ol_style_Style({ image: img, stroke: stroke, fill: fill })]\r\n    }\r\n    /** Style for handles */\r\n    this.style = {\r\n      'default': createStyle(bigpt, strokedash, fill0),\r\n      'translate': createStyle(bigpt, stroke, fill),\r\n      'rotate': createStyle(circle, stroke, fill),\r\n      'rotate0': createStyle(bigpt, stroke, fill),\r\n      'scale': createStyle(bigpt, stroke, fill),\r\n      'scale1': createStyle(bigpt, stroke, fill),\r\n      'scale2': createStyle(bigpt, stroke, fill),\r\n      'scale3': createStyle(bigpt, stroke, fill),\r\n      'scalev': createStyle(smallpt, stroke, fill),\r\n      'scaleh1': createStyle(smallpt, stroke, fill),\r\n      'scalev2': createStyle(smallpt, stroke, fill),\r\n      'scaleh3': createStyle(smallpt, stroke, fill),\r\n    }\r\n    this.drawSketch_()\r\n  }\r\n  /**\r\n   * Set sketch style.\r\n   * @param {style} style Style name: 'default','translate','rotate','rotate0','scale','scale1','scale2','scale3','scalev','scaleh1','scalev2','scaleh3'\r\n   * @param {ol.style.Style|Array<ol.style.Style>} olstyle\r\n   * @api stable\r\n   */\r\n  setStyle(style, olstyle) {\r\n    if (!olstyle)\r\n      return\r\n    if (olstyle instanceof Array)\r\n      this.style[style] = olstyle\r\n    else\r\n      this.style[style] = [olstyle]\r\n    for (var i = 0; i < this.style[style].length; i++) {\r\n      var im = this.style[style][i].getImage()\r\n      if (im) {\r\n        if (style == 'rotate') {\r\n          im.getAnchor()[0] = -5\r\n        }\r\n        if (this.isTouch)\r\n          im.setScale(1.8)\r\n      }\r\n      var tx = this.style[style][i].getText()\r\n      if (tx) {\r\n        if (style == 'rotate')\r\n          tx.setOffsetX(this.isTouch ? 14 : 7)\r\n        if (this.isTouch)\r\n          tx.setScale(1.8)\r\n      }\r\n    }\r\n    this.drawSketch_()\r\n  }\r\n  /** Get Feature at pixel\r\n   * @param {ol.Pixel}\r\n   * @return {ol.feature}\r\n   * @private\r\n   */\r\n  getFeatureAtPixel_(pixel) {\r\n    var self = this\r\n    return this.getMap().forEachFeatureAtPixel(pixel,\r\n      function (feature, layer) {\r\n        var found = false\r\n        // Overlay ?\r\n        if (!layer) {\r\n          if (feature === self.bbox_) {\r\n            if (self.get('translateBBox')) {\r\n              return { feature: feature, handle: 'translate', constraint: '', option: '' }\r\n            } else {\r\n              return false\r\n            }\r\n          }\r\n          self.handles_.forEach(function (f) {\r\n            if (f === feature)\r\n              found = true\r\n          })\r\n          if (found)\r\n            return { feature: feature, handle: feature.get('handle'), constraint: feature.get('constraint'), option: feature.get('option') }\r\n        }\r\n        // No seletion\r\n        if (!self.get('selection')) {\r\n          // Return the currently selected feature the user is interacting with.\r\n          if (self.selection_.getArray().some(function (f) { return feature === f })) {\r\n            return { feature: feature }\r\n          }\r\n          return null\r\n        }\r\n        // filter condition\r\n        if (self._filter) {\r\n          if (self._filter(feature, layer))\r\n            return { feature: feature }\r\n          else\r\n            return null\r\n        }\r\n\r\n        // feature belong to a layer\r\n        else if (self.layers_) {\r\n          for (var i = 0; i < self.layers_.length; i++) {\r\n            if (self.layers_[i] === layer)\r\n              return { feature: feature }\r\n          }\r\n          return null\r\n        }\r\n\r\n        // feature in the collection\r\n        else if (self.features_) {\r\n          self.features_.forEach(function (f) {\r\n            if (f === feature)\r\n              found = true\r\n          })\r\n          if (found)\r\n            return { feature: feature }\r\n          else\r\n            return null\r\n        }\r\n\r\n        // Others\r\n        else\r\n          return { feature: feature }\r\n      },\r\n      { hitTolerance: this.get('hitTolerance') }\r\n    ) || {}\r\n  }\r\n  /** Rotate feature from map view rotation\r\n   * @param {ol.Feature} f the feature\r\n   * @param {boolean} clone clone resulting geom\r\n   * @param {ol.geom.Geometry} rotated geometry\r\n   */\r\n  getGeometryRotateToZero_(f, clone) {\r\n    var origGeom = f.getGeometry()\r\n    var viewRotation = this.getMap().getView().getRotation()\r\n    if (viewRotation === 0 || !this.get('enableRotatedTransform')) {\r\n      return (clone) ? origGeom.clone() : origGeom\r\n    }\r\n    var rotGeom = origGeom.clone()\r\n    rotGeom.rotate(viewRotation * -1, this.getMap().getView().getCenter())\r\n    return rotGeom\r\n  }\r\n  /** Test if rectangle\r\n   * @param {ol.Geometry} geom\r\n   * @returns {boolean}\r\n   * @private\r\n   */\r\n  _isRectangle(geom) {\r\n    if (this.get('keepRectangle') && geom.getType() === 'Polygon') {\r\n      var coords = geom.getCoordinates()[0]\r\n      return coords.length === 5\r\n    }\r\n    return false\r\n  }\r\n  /** Draw transform sketch\r\n  * @param {boolean} draw only the center\r\n  */\r\n  drawSketch_(center) {\r\n    var i, f, geom\r\n    var keepRectangle = this.selection_.item(0) && this._isRectangle(this.selection_.item(0).getGeometry())\r\n    this.overlayLayer_.getSource().clear()\r\n    if (!this.selection_.getLength())\r\n      return\r\n    var viewRotation = this.getMap().getView().getRotation()\r\n    var ext = this.getGeometryRotateToZero_(this.selection_.item(0)).getExtent()\r\n    var coords\r\n    if (keepRectangle) {\r\n      coords = this.getGeometryRotateToZero_(this.selection_.item(0)).getCoordinates()[0].slice(0, 4)\r\n      coords.unshift(coords[3])\r\n    }\r\n    // Clone and extend\r\n    ext = ol_extent_buffer(ext, 0)\r\n    this.selection_.forEach(function (f) {\r\n      var extendExt = this.getGeometryRotateToZero_(f).getExtent()\r\n      ol_extent_extend(ext, extendExt)\r\n    }.bind(this))\r\n\r\n    var ptRadius = (this.selection_.getLength() === 1 ? this._pointRadius(this.selection_.item(0)) : 0)\r\n    if (ptRadius && !(ptRadius instanceof Array))\r\n      ptRadius = [ptRadius, ptRadius]\r\n\r\n    if (center === true) {\r\n      if (!this.ispt_) {\r\n        this.overlayLayer_.getSource().addFeature(new ol_Feature({ geometry: new ol_geom_Point(this.center_), handle: 'rotate0' }))\r\n        geom = ol_geom_Polygon_fromExtent(ext)\r\n        if (this.get('enableRotatedTransform') && viewRotation !== 0) {\r\n          geom.rotate(viewRotation, this.getMap().getView().getCenter())\r\n        }\r\n        f = this.bbox_ = new ol_Feature(geom)\r\n        this.overlayLayer_.getSource().addFeature(f)\r\n      }\r\n    } else {\r\n      if (this.ispt_) {\r\n        // Calculate extent arround the point\r\n        var p = this.getMap().getPixelFromCoordinate([ext[0], ext[1]])\r\n        if (p) {\r\n          var dx = ptRadius ? ptRadius[0] || 10 : 10\r\n          var dy = ptRadius ? ptRadius[1] || 10 : 10\r\n          ext = ol_extent_boundingExtent([\r\n            this.getMap().getCoordinateFromPixel([p[0] - dx, p[1] - dy]),\r\n            this.getMap().getCoordinateFromPixel([p[0] + dx, p[1] + dy])\r\n          ])\r\n        }\r\n      }\r\n      geom = keepRectangle ? new ol_geom_Polygon([coords]) : ol_geom_Polygon_fromExtent(ext)\r\n      if (this.get('enableRotatedTransform') && viewRotation !== 0) {\r\n        geom.rotate(viewRotation, this.getMap().getView().getCenter())\r\n      }\r\n      f = this.bbox_ = new ol_Feature(geom)\r\n      var features = []\r\n      var g = geom.getCoordinates()[0]\r\n      if (!this.ispt_ || ptRadius) {\r\n        features.push(f)\r\n        // Middle\r\n        if (!this.iscircle_ && !this.ispt_ && this.get('stretch') && this.get('scale'))\r\n          for (i = 0; i < g.length - 1; i++) {\r\n            f = new ol_Feature({ geometry: new ol_geom_Point([(g[i][0] + g[i + 1][0]) / 2, (g[i][1] + g[i + 1][1]) / 2]), handle: 'scale', constraint: i % 2 ? \"h\" : \"v\", option: i })\r\n            features.push(f)\r\n          }\r\n        // Handles\r\n        if (this.get('scale'))\r\n          for (i = 0; i < g.length - 1; i++) {\r\n            f = new ol_Feature({ geometry: new ol_geom_Point(g[i]), handle: 'scale', option: i })\r\n            features.push(f)\r\n          }\r\n        // Center\r\n        if (this.get('translate') && !this.get('translateFeature')) {\r\n          f = new ol_Feature({ geometry: new ol_geom_Point([(g[0][0] + g[2][0]) / 2, (g[0][1] + g[2][1]) / 2]), handle: 'translate' })\r\n          features.push(f)\r\n        }\r\n      }\r\n      // Rotate\r\n      if (!this.iscircle_ && this.get('rotate')) {\r\n        f = new ol_Feature({ geometry: new ol_geom_Point(g[3]), handle: 'rotate' })\r\n        features.push(f)\r\n      }\r\n      // Add sketch\r\n      this.overlayLayer_.getSource().addFeatures(features)\r\n    }\r\n\r\n  }\r\n  /** Select a feature to transform\r\n  * @param {ol.Feature} feature the feature to transform\r\n  * @param {boolean} add true to add the feature to the selection, default false\r\n  */\r\n  select(feature, add) {\r\n    if (!feature) {\r\n      if (this.selection_) {\r\n        this.selection_.clear()\r\n        this.drawSketch_()\r\n      }\r\n      return\r\n    }\r\n    if (!feature.getGeometry || !feature.getGeometry()) return\r\n    // Add to selection\r\n    if (add) {\r\n      this.selection_.push(feature)\r\n    } else {\r\n      var index = this.selection_.getArray().indexOf(feature)\r\n      this.selection_.removeAt(index)\r\n    }\r\n    this.ispt_ = (this.selection_.getLength() === 1 ? (this.selection_.item(0).getGeometry().getType() == \"Point\") : false)\r\n    this.iscircle_ = (this.selection_.getLength() === 1 ? (this.selection_.item(0).getGeometry().getType() == \"Circle\") : false)\r\n    this.drawSketch_()\r\n    this.watchFeatures_()\r\n    // select event\r\n    this.dispatchEvent({ type: 'select', feature: feature, features: this.selection_ })\r\n  }\r\n  /** Update the selection collection.\r\n  * @param {ol.Collection<ol.Feature>} features the features to transform\r\n  */\r\n  setSelection(features) {\r\n    this.selection_.clear()\r\n    features.forEach(function (feature) {\r\n      this.selection_.push(feature)\r\n    }.bind(this))\r\n\r\n    this.ispt_ = (this.selection_.getLength() === 1 ? (this.selection_.item(0).getGeometry().getType() == \"Point\") : false)\r\n    this.iscircle_ = (this.selection_.getLength() === 1 ? (this.selection_.item(0).getGeometry().getType() == \"Circle\") : false)\r\n    this.drawSketch_()\r\n    this.watchFeatures_()\r\n    // select event\r\n    this.dispatchEvent({ type: 'select', features: this.selection_ })\r\n  }\r\n  /** Watch selected features\r\n   * @private\r\n   */\r\n  watchFeatures_() {\r\n    // Listen to feature modification\r\n    if (this._featureListeners) {\r\n      this._featureListeners.forEach(function (l) {\r\n        ol_Observable_unByKey(l)\r\n      })\r\n    }\r\n    this._featureListeners = []\r\n    this.selection_.forEach(function (f) {\r\n      this._featureListeners.push(\r\n        f.on('change', function () {\r\n          if (!this.isUpdating_) {\r\n            this.drawSketch_()\r\n          }\r\n        }.bind(this))\r\n      )\r\n    }.bind(this))\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} evt Map browser event.\r\n   * @return {boolean} `true` to start the drag sequence.\r\n   * @private\r\n   */\r\n  handleDownEvent_(evt) {\r\n    if (!this._handleEvent(evt, this.selection_))\r\n      return\r\n    var sel = this.getFeatureAtPixel_(evt.pixel)\r\n    var feature = sel.feature\r\n    if (this.selection_.getLength()\r\n      && this.selection_.getArray().indexOf(feature) >= 0\r\n      && ((this.ispt_ && this.get('translate')) || this.get('translateFeature'))) {\r\n      sel.handle = 'translate'\r\n    }\r\n    if (sel.handle) {\r\n      this.mode_ = sel.handle\r\n      this.opt_ = sel.option\r\n      this.constraint_ = sel.constraint\r\n      // Save info\r\n      var viewRotation = this.getMap().getView().getRotation()\r\n      this.coordinate_ = evt.coordinate\r\n      this.pixel_ = evt.pixel\r\n      this.geoms_ = []\r\n      this.rotatedGeoms_ = []\r\n      var extent = ol_extent_createEmpty()\r\n      var rotExtent = ol_extent_createEmpty()\r\n      for (var i = 0, f; f = this.selection_.item(i); i++) {\r\n        this.geoms_.push(f.getGeometry().clone())\r\n        extent = ol_extent_extend(extent, f.getGeometry().getExtent())\r\n        if (this.get('enableRotatedTransform') && viewRotation !== 0) {\r\n          var rotGeom = this.getGeometryRotateToZero_(f, true)\r\n          this.rotatedGeoms_.push(rotGeom)\r\n          rotExtent = ol_extent_extend(rotExtent, rotGeom.getExtent())\r\n        }\r\n      }\r\n      this.extent_ = (ol_geom_Polygon_fromExtent(extent)).getCoordinates()[0]\r\n      if (this.get('enableRotatedTransform') && viewRotation !== 0) {\r\n        this.rotatedExtent_ = (ol_geom_Polygon_fromExtent(rotExtent)).getCoordinates()[0]\r\n      }\r\n      if (this.mode_ === 'rotate') {\r\n        this.center_ = this.getCenter() || ol_extent_getCenter(extent)\r\n        // we are now rotating (cursor down on rotate mode), so apply the grabbing cursor\r\n        var element = evt.map.getTargetElement()\r\n        element.style.cursor = this.Cursors.rotate0\r\n        this.previousCursor_ = element.style.cursor\r\n      } else {\r\n        this.center_ = ol_extent_getCenter(extent)\r\n      }\r\n      this.angle_ = Math.atan2(this.center_[1] - evt.coordinate[1], this.center_[0] - evt.coordinate[0])\r\n\r\n      this.dispatchEvent({\r\n        type: this.mode_ + 'start',\r\n        feature: this.selection_.item(0),\r\n        features: this.selection_,\r\n        pixel: evt.pixel,\r\n        coordinate: evt.coordinate\r\n      })\r\n      return true\r\n    }\r\n    else if (this.get('selection')) {\r\n      if (feature) {\r\n        if (!this.addFn_(evt))\r\n          this.selection_.clear()\r\n        var index = this.selection_.getArray().indexOf(feature)\r\n        if (index < 0)\r\n          this.selection_.push(feature)\r\n        else\r\n          this.selection_.removeAt(index)\r\n      } else {\r\n        this.selection_.clear()\r\n      }\r\n      this.ispt_ = this.selection_.getLength() === 1 ? (this.selection_.item(0).getGeometry().getType() == \"Point\") : false\r\n      this.iscircle_ = (this.selection_.getLength() === 1 ? (this.selection_.item(0).getGeometry().getType() == \"Circle\") : false)\r\n      this.drawSketch_()\r\n      this.watchFeatures_()\r\n      this.dispatchEvent({ type: 'select', feature: feature, features: this.selection_, pixel: evt.pixel, coordinate: evt.coordinate })\r\n      return false\r\n    }\r\n  }\r\n  /**\r\n   * Get the rotation center\r\n   * @return {ol.coordinate|undefined}\r\n   */\r\n  getCenter() {\r\n    return this.get('center')\r\n  }\r\n  /**\r\n   * Set the rotation center\r\n   * @param {ol.coordinate|undefined} c the center point, default center on the objet\r\n   */\r\n  setCenter(c) {\r\n    return this.set('center', c)\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} evt Map browser event.\r\n   * @private\r\n   */\r\n  handleDragEvent_(evt) {\r\n    if (!this._handleEvent(evt, this.features_))\r\n      return\r\n    var viewRotation = this.getMap().getView().getRotation()\r\n    var i, j, f, geometry\r\n    var pt0 = [this.coordinate_[0], this.coordinate_[1]]\r\n    var pt = [evt.coordinate[0], evt.coordinate[1]]\r\n    this.isUpdating_ = true\r\n    switch (this.mode_) {\r\n      case 'rotate': {\r\n        var a = Math.atan2(this.center_[1] - pt[1], this.center_[0] - pt[0])\r\n        if (!this.ispt) {\r\n          // var geometry = this.geom_.clone();\r\n          // geometry.rotate(a-this.angle_, this.center_);\r\n          // this.feature_.setGeometry(geometry);\r\n          for (i = 0, f; f = this.selection_.item(i); i++) {\r\n            geometry = this.geoms_[i].clone()\r\n            geometry.rotate(a - this.angle_, this.center_)\r\n            // bug: ol, bad calculation circle geom extent\r\n            if (geometry.getType() == 'Circle')\r\n              geometry.setCenterAndRadius(geometry.getCenter(), geometry.getRadius())\r\n            f.setGeometry(geometry)\r\n          }\r\n        }\r\n        this.drawSketch_(true)\r\n        this.dispatchEvent({\r\n          type: 'rotating',\r\n          feature: this.selection_.item(0),\r\n          features: this.selection_,\r\n          angle: a - this.angle_,\r\n          pixel: evt.pixel,\r\n          coordinate: evt.coordinate\r\n        })\r\n        break\r\n      }\r\n      case 'translate': {\r\n        var deltaX = pt[0] - pt0[0]\r\n        var deltaY = pt[1] - pt0[1]\r\n\r\n        //this.feature_.getGeometry().translate(deltaX, deltaY);\r\n        for (i = 0, f; f = this.selection_.item(i); i++) {\r\n          f.getGeometry().translate(deltaX, deltaY)\r\n        }\r\n        this.handles_.forEach(function (f) {\r\n          f.getGeometry().translate(deltaX, deltaY)\r\n        })\r\n\r\n        this.coordinate_ = evt.coordinate\r\n        this.dispatchEvent({\r\n          type: 'translating',\r\n          feature: this.selection_.item(0),\r\n          features: this.selection_,\r\n          delta: [deltaX, deltaY],\r\n          pixel: evt.pixel,\r\n          coordinate: evt.coordinate\r\n        })\r\n        break\r\n      }\r\n      case 'scale': {\r\n        var center = this.center_\r\n        if (this.get('modifyCenter')(evt)) {\r\n          var extentCoordinates = this.extent_\r\n          if (this.get('enableRotatedTransform') && viewRotation !== 0) {\r\n            extentCoordinates = this.rotatedExtent_\r\n          }\r\n          center = extentCoordinates[(Number(this.opt_) + 2) % 4]\r\n        }\r\n        var keepRectangle = (this.geoms_.length == 1 && this._isRectangle(this.geoms_[0]))\r\n        var stretch = this.constraint_\r\n        var opt = this.opt_\r\n\r\n        var downCoordinate = this.coordinate_\r\n        var dragCoordinate = evt.coordinate\r\n        if (this.get('enableRotatedTransform') && viewRotation !== 0) {\r\n          var downPoint = new ol_geom_Point(this.coordinate_)\r\n          downPoint.rotate(viewRotation * -1, center)\r\n          downCoordinate = downPoint.getCoordinates()\r\n\r\n          var dragPoint = new ol_geom_Point(evt.coordinate)\r\n          dragPoint.rotate(viewRotation * -1, center)\r\n          dragCoordinate = dragPoint.getCoordinates()\r\n        }\r\n\r\n        var scx = ((dragCoordinate)[0] - (center)[0]) / (downCoordinate[0] - (center)[0])\r\n        var scy = ((dragCoordinate)[1] - (center)[1]) / (downCoordinate[1] - (center)[1])\r\n        var displacementVector = [dragCoordinate[0] - downCoordinate[0], (dragCoordinate)[1] - downCoordinate[1]]\r\n\r\n        if (this.get('enableRotatedTransform') && viewRotation !== 0) {\r\n          var centerPoint = new ol_geom_Point(center)\r\n          centerPoint.rotate(viewRotation * -1, this.getMap().getView().getCenter())\r\n          center = centerPoint.getCoordinates()\r\n        }\r\n\r\n        if (this.get('noFlip')) {\r\n          if (scx < 0)\r\n            scx = -scx\r\n          if (scy < 0)\r\n            scy = -scy\r\n        }\r\n\r\n        if (this.constraint_) {\r\n          if (this.constraint_ == \"h\")\r\n            scx = 1\r\n          else\r\n            scy = 1\r\n        } else {\r\n          if (this.get('keepAspectRatio')(evt)) {\r\n            scx = scy = Math.min(scx, scy)\r\n          }\r\n        }\r\n\r\n        for (i = 0, f; f = this.selection_.item(i); i++) {\r\n          geometry = (viewRotation === 0 || !this.get('enableRotatedTransform')) ? this.geoms_[i].clone() : this.rotatedGeoms_[i].clone()\r\n          geometry.applyTransform(function (g1, g2, dim) {\r\n            if (dim < 2) return g2\r\n\r\n            if (!keepRectangle) {\r\n              for (j = 0; j < g1.length; j += dim) {\r\n                if (scx != 1)\r\n                  g2[j] = center[0] + (g1[j] - center[0]) * scx\r\n                if (scy != 1)\r\n                  g2[j + 1] = center[1] + (g1[j + 1] - center[1]) * scy\r\n              }\r\n            } else {\r\n              var pointArray = [[6], [0, 8], [2], [4]]\r\n              var pointA = [g1[0], g1[1]]\r\n              var pointB = [g1[2], g1[3]]\r\n              var pointC = [g1[4], g1[5]]\r\n              var pointD = [g1[6], g1[7]]\r\n              var pointA1 = [g1[8], g1[9]]\r\n\r\n              if (stretch) {\r\n                var base = (opt % 2 === 0) ? this._countVector(pointA, pointB) : this._countVector(pointD, pointA)\r\n                var projectedVector = this._projectVectorOnVector(displacementVector, base)\r\n                var nextIndex = opt + 1 < pointArray.length ? opt + 1 : 0\r\n                var coordsToChange = [...pointArray[opt], ...pointArray[nextIndex]]\r\n\r\n                for (j = 0; j < g1.length; j += dim) {\r\n                  g2[j] = coordsToChange.includes(j) ? g1[j] + projectedVector[0] : g1[j]\r\n                  g2[j + 1] = coordsToChange.includes(j) ? g1[j + 1] + projectedVector[1] : g1[j + 1]\r\n                }\r\n              } else {\r\n                var projectedLeft, projectedRight\r\n                switch (opt) {\r\n                  case 0:\r\n                    displacementVector = this._countVector(pointD, dragCoordinate)\r\n                    projectedLeft = this._projectVectorOnVector(displacementVector, this._countVector(pointC, pointD))\r\n                    projectedRight = this._projectVectorOnVector(displacementVector, this._countVector(pointA, pointD));\r\n                    [g2[0], g2[1]] = this._movePoint(pointA, projectedLeft);\r\n                    [g2[4], g2[5]] = this._movePoint(pointC, projectedRight);\r\n                    [g2[6], g2[7]] = this._movePoint(pointD, displacementVector);\r\n                    [g2[8], g2[9]] = this._movePoint(pointA1, projectedLeft)\r\n                    break\r\n                  case 1:\r\n                    displacementVector = this._countVector(pointA, dragCoordinate)\r\n                    projectedLeft = this._projectVectorOnVector(displacementVector, this._countVector(pointD, pointA))\r\n                    projectedRight = this._projectVectorOnVector(displacementVector, this._countVector(pointB, pointA));\r\n                    [g2[0], g2[1]] = this._movePoint(pointA, displacementVector);\r\n                    [g2[2], g2[3]] = this._movePoint(pointB, projectedLeft);\r\n                    [g2[6], g2[7]] = this._movePoint(pointD, projectedRight);\r\n                    [g2[8], g2[9]] = this._movePoint(pointA1, displacementVector)\r\n                    break\r\n                  case 2:\r\n                    displacementVector = this._countVector(pointB, dragCoordinate)\r\n                    projectedLeft = this._projectVectorOnVector(displacementVector, this._countVector(pointA, pointB))\r\n                    projectedRight = this._projectVectorOnVector(displacementVector, this._countVector(pointC, pointB));\r\n                    [g2[0], g2[1]] = this._movePoint(pointA, projectedRight);\r\n                    [g2[2], g2[3]] = this._movePoint(pointB, displacementVector);\r\n                    [g2[4], g2[5]] = this._movePoint(pointC, projectedLeft);\r\n                    [g2[8], g2[9]] = this._movePoint(pointA1, projectedRight)\r\n                    break\r\n                  case 3:\r\n                    displacementVector = this._countVector(pointC, dragCoordinate)\r\n                    projectedLeft = this._projectVectorOnVector(displacementVector, this._countVector(pointB, pointC))\r\n                    projectedRight = this._projectVectorOnVector(displacementVector, this._countVector(pointD, pointC));\r\n                    [g2[2], g2[3]] = this._movePoint(pointB, projectedRight);\r\n                    [g2[4], g2[5]] = this._movePoint(pointC, displacementVector);\r\n                    [g2[6], g2[7]] = this._movePoint(pointD, projectedLeft)\r\n                    break\r\n                }\r\n              }\r\n            }\r\n\r\n            // bug: ol, bad calculation circle geom extent\r\n            if (geometry.getType() == 'Circle') geometry.setCenterAndRadius(geometry.getCenter(), geometry.getRadius())\r\n            return g2\r\n          }.bind(this))\r\n          if (this.get('enableRotatedTransform') && viewRotation !== 0) {\r\n            //geometry.rotate(viewRotation, rotationCenter);\r\n            geometry.rotate(viewRotation, this.getMap().getView().getCenter())\r\n          }\r\n          f.setGeometry(geometry)\r\n        }\r\n        this.drawSketch_()\r\n        this.dispatchEvent({\r\n          type: 'scaling',\r\n          feature: this.selection_.item(0),\r\n          features: this.selection_,\r\n          scale: [scx, scy],\r\n          pixel: evt.pixel,\r\n          coordinate: evt.coordinate\r\n        })\r\n        break\r\n      }\r\n      default: break\r\n    }\r\n    this.isUpdating_ = false\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} evt Event.\r\n   * @private\r\n   */\r\n  handleMoveEvent_(evt) {\r\n    if (!this._handleEvent(evt, this.features_))\r\n      return\r\n    // console.log(\"handleMoveEvent\");\r\n    if (!this.mode_) {\r\n      var sel = this.getFeatureAtPixel_(evt.pixel)\r\n      var element = evt.map.getTargetElement()\r\n      if (sel.feature) {\r\n        var c = sel.handle ? this.Cursors[(sel.handle || 'default') + (sel.constraint || '') + (sel.option || '')] : this.Cursors.select\r\n\r\n        if (this.previousCursor_ === undefined) {\r\n          this.previousCursor_ = element.style.cursor\r\n        }\r\n        element.style.cursor = c\r\n      } else {\r\n        if (this.previousCursor_ !== undefined)\r\n          element.style.cursor = this.previousCursor_\r\n        this.previousCursor_ = undefined\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} evt Map browser event.\r\n   * @return {boolean} `false` to stop the drag sequence.\r\n   */\r\n  handleUpEvent_(evt) {\r\n    // remove rotate0 cursor on Up event, otherwise it's stuck on grab/grabbing\r\n    if (this.mode_ === 'rotate') {\r\n      var element = evt.map.getTargetElement()\r\n      element.style.cursor = this.Cursors.default\r\n      this.previousCursor_ = undefined\r\n    }\r\n\r\n    //dispatchEvent\r\n    this.dispatchEvent({\r\n      type: this.mode_ + 'end',\r\n      feature: this.selection_.item(0),\r\n      features: this.selection_,\r\n      oldgeom: this.geoms_[0],\r\n      oldgeoms: this.geoms_\r\n    })\r\n\r\n    this.drawSketch_()\r\n    this.mode_ = null\r\n    return false\r\n  }\r\n  /** Set the point radius to calculate handles on points\r\n   *  @param {number|Array<number>|function} [pointRadius=0] radius for points or a function that takes a feature and returns the radius (or [radiusX, radiusY]). If not null show handles to transform the points\r\n   */\r\n  setPointRadius(pointRadius) {\r\n    if (typeof (pointRadius) === 'function') {\r\n      this._pointRadius = pointRadius\r\n    } else {\r\n      this._pointRadius = function () { return pointRadius }\r\n    }\r\n  }\r\n  /** Get the features that are selected for transform\r\n   * @return ol.Collection\r\n   */\r\n  getFeatures() {\r\n    return this.selection_;\r\n  }\r\n  /**\r\n   * @private\r\n   */\r\n  _projectVectorOnVector(displacement_vector, base) {\r\n    var k = (displacement_vector[0] * base[0] + displacement_vector[1] * base[1]) / (base[0] * base[0] + base[1] * base[1]);\r\n    return [base[0] * k, base[1] * k];\r\n  }\r\n  /**\r\n   * @private\r\n   */\r\n  _countVector(start, end) {\r\n    return [end[0] - start[0], end[1] - start[1]];\r\n  }\r\n  /**\r\n   * @private\r\n   */\r\n  _movePoint(point, displacementVector) {\r\n    return [point[0]+displacementVector[0], point[1]+displacementVector[1]];\r\n  }\r\n  \r\n  \r\n}\r\n\r\n/** Cursors for transform\r\n*/\r\nol_interaction_Transform.prototype.Cursors = {\r\n  'default': 'auto',\r\n  'select': 'pointer',\r\n  'translate': 'move',\r\n  'rotate': 'move',\r\n  'rotate0': 'move',\r\n  'scale': 'nesw-resize',\r\n  'scale1': 'nwse-resize',\r\n  'scale2': 'nesw-resize',\r\n  'scale3': 'nwse-resize',\r\n  'scalev': 'ew-resize',\r\n  'scaleh1': 'ns-resize',\r\n  'scalev2': 'ew-resize',\r\n  'scaleh3': 'ns-resize'\r\n};\r\n\r\nexport default ol_interaction_Transform\r\n","import ol_source_Vector from 'ol/source/Vector.js'\r\n\r\n;(function () {\r\n  var clear = ol_source_Vector.prototype.clear;\r\n\r\n  /** Overwrite ol/source/Vector clear to fire clearstart / clearend event\r\n   */\r\n  ol_source_Vector.prototype.clear = function(opt_fast) {\r\n    this.dispatchEvent({ type: 'clearstart' });\r\n    clear.call(this, opt_fast)\r\n    this.dispatchEvent({ type: 'clearend' });\r\n  };\r\n})();\r\n","import ol_Collection from 'ol/Collection.js'\r\nimport ol_interaction_Interaction from 'ol/interaction/Interaction.js'\r\nimport ol_layer_Vector from 'ol/layer/Vector.js'\r\nimport {unByKey as ol_Observable_unByKey} from 'ol/Observable.js'\r\nimport '../source/Vector.js'\r\n\r\n/** Undo/redo interaction\r\n * @constructor\r\n * @extends {ol_interaction_Interaction}\r\n * @fires undo\r\n * @fires redo\r\n * @fires change:add\r\n * @fires change:remove\r\n * @fires change:clear\r\n * @param {Object} options\r\n *  @param {number=} options.maxLength max undo stack length (0=Infinity), default Infinity\r\n *  @param {Array<ol.Layer>} options.layers array of layers to undo/redo\r\n */\r\nvar ol_interaction_UndoRedo = class olinteractionUndoRedo extends ol_interaction_Interaction {\r\n  constructor(options) {\r\n    options = options || {}\r\n\r\n    super({\r\n      handleEvent: function () {\r\n        return true\r\n      }\r\n    })\r\n\r\n    //array of layers to undo/redo\r\n    this._layers = options.layers\r\n\r\n    this._undoStack = new ol_Collection()\r\n    this._redoStack = new ol_Collection()\r\n    // Zero level stack\r\n    this._undo = []\r\n    this._redo = []\r\n    this._undoStack.on('add', function (e) {\r\n      if (e.element.level === undefined) {\r\n        e.element.level = this._level\r\n        if (!e.element.level) {\r\n          e.element.view = {\r\n            center: this.getMap().getView().getCenter(),\r\n            zoom: this.getMap().getView().getZoom()\r\n          }\r\n          this._undo.push(e.element)\r\n        }\r\n      } else {\r\n        if (!e.element.level)\r\n          this._undo.push(this._redo.shift())\r\n      }\r\n      if (!e.element.level) {\r\n        this.dispatchEvent({\r\n          type: 'stack:add',\r\n          action: e.element\r\n        })\r\n      }\r\n      this._reduce()\r\n    }.bind(this))\r\n    this._undoStack.on('remove', function (e) {\r\n      if (!e.element.level) {\r\n        if (this._doShift) {\r\n          this._undo.shift()\r\n        } else {\r\n          if (this._undo.length)\r\n            this._redo.push(this._undo.pop())\r\n        }\r\n        if (!this._doClear) {\r\n          this.dispatchEvent({\r\n            type: 'stack:remove',\r\n            action: e.element,\r\n            shift: this._doShift\r\n          })\r\n        }\r\n      }\r\n    }.bind(this))\r\n    // Block counter\r\n    this._block = 0\r\n    this._level = 0\r\n    // Shift an undo action ?\r\n    this._doShift = false\r\n    // Start recording\r\n    this._record = true\r\n    // Custom definitions\r\n    this._defs = {}\r\n  }\r\n  /** Add a custom undo/redo\r\n   * @param {string} action the action key name\r\n   * @param {function} undoFn function called when undoing\r\n   * @param {function} redoFn function called when redoing\r\n   * @api\r\n   */\r\n  define(action, undoFn, redoFn) {\r\n    this._defs[action] = { undo: undoFn, redo: redoFn }\r\n  }\r\n  /** Get first level undo / redo length\r\n   * @param {string} [type] get redo stack length, default get undo\r\n   * @return {number}\r\n   */\r\n  length(type) {\r\n    return (type === 'redo') ? this._redo.length : this._undo.length\r\n  }\r\n  /** Set undo stack max length\r\n   * @param {number} length\r\n   */\r\n  setMaxLength(length) {\r\n    length = parseInt(length)\r\n    if (length && length < 0)\r\n      length = 0\r\n    this.set('maxLength', length)\r\n    this._reduce()\r\n  }\r\n  /** Get undo / redo size (includes all block levels)\r\n   * @param {string} [type] get redo stack length, default get undo\r\n   * @return {number}\r\n   */\r\n  size(type) {\r\n    return (type === 'redo') ? this._redoStack.getLength() : this._undoStack.getLength()\r\n  }\r\n  /** Set undo stack max size\r\n   * @param {number} size\r\n   */\r\n  setMaxSize(size) {\r\n    size = parseInt(size)\r\n    if (size && size < 0)\r\n      size = 0\r\n    this.set('maxSize', size)\r\n    this._reduce()\r\n  }\r\n  /** Reduce stack: shift undo to set size\r\n   * @private\r\n   */\r\n  _reduce() {\r\n    if (this.get('maxLength')) {\r\n      while (this.length() > this.get('maxLength')) {\r\n        this.shift()\r\n      }\r\n    }\r\n    if (this.get('maxSize')) {\r\n      while (this.length() > 1 && this.size() > this.get('maxSize')) {\r\n        this.shift()\r\n      }\r\n    }\r\n  }\r\n  /** Get first level undo / redo first level stack\r\n   * @param {string} [type] get redo stack, default get undo\r\n   * @return {Array<*>}\r\n   */\r\n  getStack(type) {\r\n    return (type === 'redo') ? this._redo : this._undo\r\n  }\r\n  /** Add a new custom undo/redo\r\n   * @param {string} action the action key name\r\n   * @param {any} prop an object that will be passed in the undo/redo functions of the action\r\n   * @param {string} name action name\r\n   * @return {boolean} true if the action is defined\r\n   */\r\n  push(action, prop, name) {\r\n    if (this._defs[action]) {\r\n      this._undoStack.push({\r\n        type: action,\r\n        name: name,\r\n        custom: true,\r\n        prop: prop\r\n      })\r\n      return true\r\n    } else {\r\n      console.warn('[UndoRedoInteraction]: \"' + action + '\" is not defined.')\r\n      return false\r\n    }\r\n  }\r\n  /** Remove undo action from the beginning of the stack.\r\n   * The action is not returned.\r\n   */\r\n  shift() {\r\n    this._doShift = true\r\n    var a = this._undoStack.removeAt(0)\r\n    this._doShift = false\r\n    // Remove all block\r\n    if (a.type === 'blockstart') {\r\n      a = this._undoStack.item(0)\r\n      while (this._undoStack.getLength() && a.level > 0) {\r\n        this._undoStack.removeAt(0)\r\n        a = this._undoStack.item(0)\r\n      }\r\n    }\r\n  }\r\n  /** Activate or deactivate the interaction, ie. records or not events on the map.\r\n   * @param {boolean} active\r\n   * @api stable\r\n   */\r\n  setActive(active) {\r\n    super.setActive(active)\r\n    this._record = active\r\n  }\r\n  /**\r\n   * Remove the interaction from its current map, if any, and attach it to a new\r\n   * map, if any. Pass `null` to just remove the interaction from the current map.\r\n   * @param {ol.Map} map Map.\r\n   * @api stable\r\n   */\r\n  setMap(map) {\r\n    if (this._mapListener) {\r\n      this._mapListener.forEach(function (l) { ol_Observable_unByKey(l) })\r\n    }\r\n    this._mapListener = []\r\n    super.setMap(map)\r\n    // Watch blocks\r\n    if (map) {\r\n      this._mapListener.push(map.on('undoblockstart', this.blockStart.bind(this)))\r\n      this._mapListener.push(map.on('undoblockend', this.blockEnd.bind(this)))\r\n    }\r\n    // Watch sources\r\n    this._watchSources()\r\n    this._watchInteractions()\r\n  }\r\n  /** Watch for changes in the map sources\r\n   * @private\r\n   */\r\n  _watchSources() {\r\n    var map = this.getMap()\r\n    // Clear listeners\r\n    if (this._sourceListener) {\r\n      this._sourceListener.forEach(function (l) { ol_Observable_unByKey(l) })\r\n    }\r\n    this._sourceListener = []\r\n\r\n    var self = this\r\n\r\n    // Ges vector layers \r\n    function getVectorLayers(layers, init) {\r\n      if (!init)\r\n        init = []\r\n      layers.forEach(function (l) {\r\n        if (l instanceof ol_layer_Vector) {\r\n          if (!self._layers || self._layers.indexOf(l) >= 0) {\r\n            init.push(l)\r\n          }\r\n        } else if (l.getLayers) {\r\n          getVectorLayers(l.getLayers(), init)\r\n        }\r\n      })\r\n      return init\r\n    }\r\n\r\n    if (map) {\r\n      // Watch the vector sources in the map \r\n      var vectors = getVectorLayers(map.getLayers())\r\n      vectors.forEach((function (l) {\r\n        var s = l.getSource()\r\n        this._sourceListener.push(s.on(['addfeature', 'removefeature'], this._onAddRemove.bind(this)))\r\n        this._sourceListener.push(s.on('clearstart', function () {\r\n          this.blockStart('clear')\r\n        }.bind(this)))\r\n        this._sourceListener.push(s.on('clearend', this.blockEnd.bind(this)))\r\n      }).bind(this))\r\n\r\n      // Watch new inserted/removed\r\n      this._sourceListener.push(map.getLayers().on(['add', 'remove'], this._watchSources.bind(this)))\r\n    }\r\n  }\r\n  /** Watch for interactions\r\n   * @private\r\n   */\r\n  _watchInteractions() {\r\n    var map = this.getMap()\r\n    // Clear listeners\r\n    if (this._interactionListener) {\r\n      this._interactionListener.forEach(function (l) { ol_Observable_unByKey(l) })\r\n    }\r\n    this._interactionListener = []\r\n\r\n    if (map) {\r\n      // Watch the interactions in the map \r\n      map.getInteractions().forEach((function (i) {\r\n        this._interactionListener.push(i.on(\r\n          ['setattributestart', 'modifystart', 'rotatestart', 'translatestart', 'scalestart', 'deletestart', 'deleteend', 'beforesplit', 'aftersplit'],\r\n          this._onInteraction.bind(this)\r\n        ))\r\n      }).bind(this))\r\n\r\n      // Watch new inserted / unwatch removed\r\n      this._interactionListener.push(map.getInteractions().on(\r\n        ['add', 'remove'],\r\n        this._watchInteractions.bind(this)\r\n      ))\r\n    }\r\n  }\r\n  /** A feature is added / removed\r\n   */\r\n  _onAddRemove(e) {\r\n    if (this._record) {\r\n      this._redoStack.clear()\r\n      this._redo.length = 0\r\n      this._undoStack.push({\r\n        type: e.type,\r\n        source: e.target,\r\n        feature: e.feature\r\n      })\r\n    }\r\n  }\r\n  /** Perform an interaction\r\n   * @private\r\n   */\r\n  _onInteraction(e) {\r\n    var fn = this._onInteraction[e.type]\r\n    if (fn)\r\n      fn.call(this, e)\r\n  }\r\n  /** Start an undo block\r\n   * @param {string} [name] name f the action\r\n   * @api\r\n   */\r\n  blockStart(name) {\r\n    this._redoStack.clear()\r\n    this._redo.length = 0\r\n    this._undoStack.push({\r\n      type: 'blockstart',\r\n      name: name\r\n    })\r\n    this._level++\r\n  }\r\n  /** End an undo block\r\n   * @api\r\n   */\r\n  blockEnd() {\r\n    this._undoStack.push({ type: 'blockend' })\r\n    this._level--\r\n  }\r\n  /** handle undo/redo\r\n   * @private\r\n   */\r\n  _handleDo(e, undo) {\r\n    // Not active\r\n    if (!this.getActive())\r\n      return\r\n\r\n    // Stop recording while undoing\r\n    this._record = false\r\n    if (e.custom) {\r\n      if (this._defs[e.type]) {\r\n        if (undo)\r\n          this._defs[e.type].undo(e.prop)\r\n        else\r\n          this._defs[e.type].redo(e.prop)\r\n      } else {\r\n        console.warn('[UndoRedoInteraction]: \"' + e.type + '\" is not defined.')\r\n      }\r\n    } else {\r\n      switch (e.type) {\r\n        case 'addfeature': {\r\n          if (undo)\r\n            e.source.removeFeature(e.feature)\r\n          else\r\n            e.source.addFeature(e.feature)\r\n          break\r\n        }\r\n        case 'removefeature': {\r\n          if (undo)\r\n            e.source.addFeature(e.feature)\r\n          else\r\n            e.source.removeFeature(e.feature)\r\n          break\r\n        }\r\n        case 'changegeometry': {\r\n          var geom = e.feature.getGeometry()\r\n          e.feature.setGeometry(e.oldGeom)\r\n          e.oldGeom = geom\r\n          break\r\n        }\r\n        case 'changeattribute': {\r\n          var newp = e.newProperties\r\n          var oldp = e.oldProperties\r\n          for (var p in oldp) {\r\n            if (oldp === undefined)\r\n              e.feature.unset(p)\r\n            else\r\n              e.feature.set(p, oldp[p])\r\n          }\r\n          e.oldProperties = newp\r\n          e.newProperties = oldp\r\n          break\r\n        }\r\n        case 'blockstart': {\r\n          this._block += undo ? -1 : 1\r\n          break\r\n        }\r\n        case 'blockend': {\r\n          this._block += undo ? 1 : -1\r\n          break\r\n        }\r\n        default: {\r\n          console.warn('[UndoRedoInteraction]: \"' + e.type + '\" is not defined.')\r\n        }\r\n      }\r\n    }\r\n\r\n    // Handle block\r\n    if (this._block < 0)\r\n      this._block = 0\r\n    if (this._block) {\r\n      if (undo)\r\n        this.undo()\r\n      else\r\n        this.redo()\r\n    }\r\n    this._record = true\r\n\r\n    // Dispatch event\r\n    this.dispatchEvent({\r\n      type: undo ? 'undo' : 'redo',\r\n      action: e\r\n    })\r\n  }\r\n  /** Undo last operation\r\n   * @api\r\n   */\r\n  undo() {\r\n    var e = this._undoStack.item(this._undoStack.getLength() - 1)\r\n    if (!e)\r\n      return\r\n    this._redoStack.push(e)\r\n    this._undoStack.pop()\r\n    this._handleDo(e, true)\r\n  }\r\n  /** Redo last operation\r\n   * @api\r\n   */\r\n  redo() {\r\n    var e = this._redoStack.item(this._redoStack.getLength() - 1)\r\n    if (!e)\r\n      return\r\n    this._undoStack.push(e)\r\n    this._redoStack.pop()\r\n    this._handleDo(e, false)\r\n  }\r\n  /** Clear undo stack\r\n   * @api\r\n   */\r\n  clear() {\r\n    this._doClear = true\r\n    this._undo.length = this._redo.length = 0\r\n    this._undoStack.clear()\r\n    this._redoStack.clear()\r\n    this._doClear = false\r\n    this.dispatchEvent({ type: 'stack:clear' })\r\n  }\r\n  /** Check if undo is avaliable\r\n   * @return {number} the number of undo\r\n   * @api\r\n   */\r\n  hasUndo() {\r\n    return this._undoStack.getLength()\r\n  }\r\n  /** Check if redo is avaliable\r\n   * @return {number} the number of redo\r\n   * @api\r\n   */\r\n  hasRedo() {\r\n    return this._redoStack.getLength()\r\n  }\r\n}\r\n\r\n/** Set attribute\r\n * @private\r\n */\r\nol_interaction_UndoRedo.prototype._onInteraction.setattributestart = function(e) {\r\n  this.blockStart(e.target.get('name') || 'setattribute');\r\n  var newp = Object.assign({}, e.properties);\r\n  e.features.forEach(function(f) {\r\n    var oldp = {};\r\n    for (var p in newp) {\r\n      oldp[p] = f.get(p);\r\n    }\r\n    this._undoStack.push({\r\n      type: 'changeattribute', \r\n      feature: f,\r\n      newProperties: newp,\r\n      oldProperties: oldp\r\n    });\r\n  }.bind(this));\r\n  this.blockEnd();\r\n};\r\n\r\nol_interaction_UndoRedo.prototype._onInteraction.rotatestart = \r\nol_interaction_UndoRedo.prototype._onInteraction.translatestart = \r\nol_interaction_UndoRedo.prototype._onInteraction.scalestart = \r\nol_interaction_UndoRedo.prototype._onInteraction.modifystart = function (e) {\r\n  this.blockStart(e.type.replace(/start$/,''));\r\n  e.features.forEach(function(m) {\r\n    this._undoStack.push({ \r\n      type: 'changegeometry', \r\n      feature: m, \r\n      oldGeom: m.getGeometry().clone() \r\n    });\r\n  }.bind(this));\r\n  this.blockEnd();\r\n};\r\n\r\n\r\n/** @private\r\n */\r\nol_interaction_UndoRedo.prototype._onInteraction.beforesplit = function() {\r\n  // Check modify before split\r\n  var l = this._undoStack.getLength();\r\n  if (l>2 \r\n    && this._undoStack.item(l-1).type === 'blockend'\r\n    && this._undoStack.item(l-2).type === 'changegeometry') {\r\n    this._undoStack.pop();\r\n  } else {\r\n    this.blockStart('split');\r\n  }\r\n};\r\nol_interaction_UndoRedo.prototype._onInteraction.deletestart = function() {\r\n  this.blockStart('delete');\r\n}\r\n\r\n\r\n/** @private\r\n */\r\nol_interaction_UndoRedo.prototype._onInteraction.aftersplit =\r\nol_interaction_UndoRedo.prototype._onInteraction.deleteend =\r\nol_interaction_UndoRedo.prototype.blockEnd;\r\n\r\nexport default ol_interaction_UndoRedo\r\n","import ol_style_Style from 'ol/style/Style.js'\r\nimport ol_style_Circle from 'ol/style/Circle.js'\r\nimport ol_style_Stroke from 'ol/style/Stroke.js'\r\nimport ol_style_Fill from 'ol/style/Fill.js'\r\n\r\nvar ol_style_Style_defaultStyle;\r\n\r\n(function() {\r\n\r\n// Style\r\nvar white = [255, 255, 255, 1];\r\nvar blue = [0, 153, 255, 1];\r\nvar width = 3;\r\n\r\nvar defaultEditStyle = [\r\n  new ol_style_Style({\r\n    stroke: new ol_style_Stroke({ color: white, width: width + 2 })\r\n  }),\r\n  new ol_style_Style({\r\n    image: new ol_style_Circle({\r\n      radius: width * 2,\r\n      fill: new ol_style_Fill({ color: blue }),\r\n      stroke: new ol_style_Stroke({ color: white, width: width / 2 })\r\n    }),\r\n    stroke: new ol_style_Stroke({ color: blue, width: width }),\r\n    fill: new ol_style_Fill({\r\n      color: [255, 255, 255, 0.5]\r\n    })\r\n  })\r\n];\r\n\r\n/**\r\n * Get the default style\r\n * @param {boolean|*} [edit] true to get editing style or a { color, fillColor } object, default get default blue style\r\n * @return {Array<ol.style.Style>}\r\n */\r\nol_style_Style_defaultStyle = function(edit) {\r\n  if (edit===true) {\r\n    return defaultEditStyle;\r\n  } else {\r\n    edit = edit || {};\r\n    var fill = new ol_style_Fill({\r\n      color: edit.fillColor || 'rgba(255,255,255,0.4)'\r\n    });\r\n    var stroke = new ol_style_Stroke({\r\n      color: edit.color || '#3399CC',\r\n      width: 1.25\r\n    });\r\n    var style = new ol_style_Style({\r\n      image: new ol_style_Circle({\r\n        fill: fill,\r\n        stroke: stroke,\r\n        radius: 5\r\n      }),\r\n      fill: fill,\r\n      stroke: stroke\r\n    });\r\n    return [ style ];\r\n  }\r\n};\r\n\r\n})();\r\n\r\nexport default ol_style_Style_defaultStyle\r\n","/**\n * @module ol/geom/Circle\n */\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {createOrUpdate, forEachCorner, intersects} from '../extent.js';\nimport {deflateCoordinate} from './flat/deflate.js';\nimport {rotate, translate} from './flat/transform.js';\n\n/**\n * @classdesc\n * Circle geometry.\n *\n * @api\n */\nclass Circle extends SimpleGeometry {\n  /**\n   * @param {!import(\"../coordinate.js\").Coordinate} center Center.\n   *     For internal use, flat coordinates in combination with `layout` and no\n   *     `radius` are also accepted.\n   * @param {number} [radius] Radius.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   */\n  constructor(center, radius, layout) {\n    super();\n    if (layout !== undefined && radius === undefined) {\n      this.setFlatCoordinates(layout, center);\n    } else {\n      radius = radius ? radius : 0;\n      this.setCenterAndRadius(center, radius, layout);\n    }\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!Circle} Clone.\n   * @api\n   */\n  clone() {\n    const circle = new Circle(\n      this.flatCoordinates.slice(),\n      undefined,\n      this.layout\n    );\n    circle.applyProperties(this);\n    return circle;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    const flatCoordinates = this.flatCoordinates;\n    const dx = x - flatCoordinates[0];\n    const dy = y - flatCoordinates[1];\n    const squaredDistance = dx * dx + dy * dy;\n    if (squaredDistance < minSquaredDistance) {\n      if (squaredDistance === 0) {\n        for (let i = 0; i < this.stride; ++i) {\n          closestPoint[i] = flatCoordinates[i];\n        }\n      } else {\n        const delta = this.getRadius() / Math.sqrt(squaredDistance);\n        closestPoint[0] = flatCoordinates[0] + delta * dx;\n        closestPoint[1] = flatCoordinates[1] + delta * dy;\n        for (let i = 2; i < this.stride; ++i) {\n          closestPoint[i] = flatCoordinates[i];\n        }\n      }\n      closestPoint.length = this.stride;\n      return squaredDistance;\n    }\n    return minSquaredDistance;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @return {boolean} Contains (x, y).\n   */\n  containsXY(x, y) {\n    const flatCoordinates = this.flatCoordinates;\n    const dx = x - flatCoordinates[0];\n    const dy = y - flatCoordinates[1];\n    return dx * dx + dy * dy <= this.getRadiusSquared_();\n  }\n\n  /**\n   * Return the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.\n   * @return {import(\"../coordinate.js\").Coordinate} Center.\n   * @api\n   */\n  getCenter() {\n    return this.flatCoordinates.slice(0, this.stride);\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @protected\n   * @return {import(\"../extent.js\").Extent} extent Extent.\n   */\n  computeExtent(extent) {\n    const flatCoordinates = this.flatCoordinates;\n    const radius = flatCoordinates[this.stride] - flatCoordinates[0];\n    return createOrUpdate(\n      flatCoordinates[0] - radius,\n      flatCoordinates[1] - radius,\n      flatCoordinates[0] + radius,\n      flatCoordinates[1] + radius,\n      extent\n    );\n  }\n\n  /**\n   * Return the radius of the circle.\n   * @return {number} Radius.\n   * @api\n   */\n  getRadius() {\n    return Math.sqrt(this.getRadiusSquared_());\n  }\n\n  /**\n   * @private\n   * @return {number} Radius squared.\n   */\n  getRadiusSquared_() {\n    const dx = this.flatCoordinates[this.stride] - this.flatCoordinates[0];\n    const dy = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];\n    return dx * dx + dy * dy;\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   */\n  getType() {\n    return 'Circle';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   */\n  intersectsExtent(extent) {\n    const circleExtent = this.getExtent();\n    if (intersects(extent, circleExtent)) {\n      const center = this.getCenter();\n\n      if (extent[0] <= center[0] && extent[2] >= center[0]) {\n        return true;\n      }\n      if (extent[1] <= center[1] && extent[3] >= center[1]) {\n        return true;\n      }\n\n      return forEachCorner(extent, this.intersectsCoordinate.bind(this));\n    }\n    return false;\n  }\n\n  /**\n   * Set the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.\n   * @param {import(\"../coordinate.js\").Coordinate} center Center.\n   * @api\n   */\n  setCenter(center) {\n    const stride = this.stride;\n    const radius = this.flatCoordinates[stride] - this.flatCoordinates[0];\n    const flatCoordinates = center.slice();\n    flatCoordinates[stride] = flatCoordinates[0] + radius;\n    for (let i = 1; i < stride; ++i) {\n      flatCoordinates[stride + i] = center[i];\n    }\n    this.setFlatCoordinates(this.layout, flatCoordinates);\n    this.changed();\n  }\n\n  /**\n   * Set the center (as {@link module:ol/coordinate~Coordinate coordinate}) and the radius (as\n   * number) of the circle.\n   * @param {!import(\"../coordinate.js\").Coordinate} center Center.\n   * @param {number} radius Radius.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @api\n   */\n  setCenterAndRadius(center, radius, layout) {\n    this.setLayout(layout, center, 0);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    /** @type {Array<number>} */\n    const flatCoordinates = this.flatCoordinates;\n    let offset = deflateCoordinate(flatCoordinates, 0, center, this.stride);\n    flatCoordinates[offset++] = flatCoordinates[0] + radius;\n    for (let i = 1, ii = this.stride; i < ii; ++i) {\n      flatCoordinates[offset++] = flatCoordinates[i];\n    }\n    flatCoordinates.length = offset;\n    this.changed();\n  }\n\n  getCoordinates() {\n    return null;\n  }\n\n  setCoordinates(coordinates, layout) {}\n\n  /**\n   * Set the radius of the circle. The radius is in the units of the projection.\n   * @param {number} radius Radius.\n   * @api\n   */\n  setRadius(radius) {\n    this.flatCoordinates[this.stride] = this.flatCoordinates[0] + radius;\n    this.changed();\n  }\n\n  /**\n   * Rotate the geometry around a given coordinate. This modifies the geometry\n   * coordinates in place.\n   * @param {number} angle Rotation angle in counter-clockwise radians.\n   * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\n   * @api\n   */\n  rotate(angle, anchor) {\n    const center = this.getCenter();\n    const stride = this.getStride();\n    this.setCenter(\n      rotate(center, 0, center.length, stride, angle, anchor, center)\n    );\n    this.changed();\n  }\n\n  /**\n   * Translate the geometry.  This modifies the geometry coordinates in place.  If\n   * instead you want a new geometry, first `clone()` this geometry.\n   * @param {number} deltaX Delta X.\n   * @param {number} deltaY Delta Y.\n   * @api\n   */\n  translate(deltaX, deltaY) {\n    const center = this.getCenter();\n    const stride = this.getStride();\n    this.setCenter(\n      translate(center, 0, center.length, stride, deltaX, deltaY, center)\n    );\n    this.changed();\n  }\n}\n\n/**\n * Transform each coordinate of the circle from one coordinate reference system\n * to another. The geometry is modified in place.\n * If you do not want the geometry modified in place, first clone() it and\n * then use this function on the clone.\n *\n * Internally a circle is currently represented by two points: the center of\n * the circle `[cx, cy]`, and the point to the right of the circle\n * `[cx + r, cy]`. This `transform` function just transforms these two points.\n * So the resulting geometry is also a circle, and that circle does not\n * correspond to the shape that would be obtained by transforming every point\n * of the original circle.\n *\n * @param {import(\"../proj.js\").ProjectionLike} source The current projection.  Can be a\n *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n * @param {import(\"../proj.js\").ProjectionLike} destination The desired projection.  Can be a\n *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n * @return {Circle} This geometry.  Note that original geometry is\n *     modified in place.\n * @function\n * @api\n */\nCircle.prototype.transform;\nexport default Circle;\n","/**\n * @module ol/interaction/Draw\n */\nimport Circle from '../geom/Circle.js';\nimport Event from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport Feature from '../Feature.js';\nimport GeometryCollection from '../geom/GeometryCollection.js';\nimport InteractionProperty from './Property.js';\nimport LineString from '../geom/LineString.js';\nimport MapBrowserEvent from '../MapBrowserEvent.js';\nimport MapBrowserEventType from '../MapBrowserEventType.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport PointerInteraction from './Pointer.js';\nimport Polygon, {fromCircle, makeRegular} from '../geom/Polygon.js';\nimport VectorLayer from '../layer/Vector.js';\nimport VectorSource from '../source/Vector.js';\nimport {FALSE, TRUE} from '../functions.js';\nimport {\n  always,\n  never,\n  noModifierKeys,\n  shiftKeyOnly,\n} from '../events/condition.js';\nimport {\n  boundingExtent,\n  getBottomLeft,\n  getBottomRight,\n  getTopLeft,\n  getTopRight,\n} from '../extent.js';\nimport {clamp, squaredDistance, toFixed} from '../math.js';\nimport {createEditingStyle} from '../style/Style.js';\nimport {\n  distance,\n  squaredDistance as squaredCoordinateDistance,\n} from '../coordinate.js';\nimport {fromUserCoordinate, getUserProjection} from '../proj.js';\nimport {getStrideForLayout} from '../geom/SimpleGeometry.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../geom/Geometry.js\").Type} type Geometry type of\n * the geometries being drawn with this instance.\n * @property {number} [clickTolerance=6] The maximum distance in pixels between\n * \"down\" and \"up\" for a \"up\" event to be considered a \"click\" event and\n * actually add a point/vertex to the geometry being drawn.  The default of `6`\n * was chosen for the draw interaction to behave correctly on mouse as well as\n * on touch devices.\n * @property {import(\"../Collection.js\").default<Feature>} [features]\n * Destination collection for the drawn features.\n * @property {VectorSource} [source] Destination source for\n * the drawn features.\n * @property {number} [dragVertexDelay=500] Delay in milliseconds after pointerdown\n * before the current vertex can be dragged to its exact position.\n * @property {number} [snapTolerance=12] Pixel distance for snapping to the\n * drawing finish. Must be greater than `0`.\n * @property {boolean} [stopClick=false] Stop click, singleclick, and\n * doubleclick events from firing during drawing.\n * @property {number} [maxPoints] The number of points that can be drawn before\n * a polygon ring or line string is finished. By default there is no\n * restriction.\n * @property {number} [minPoints] The number of points that must be drawn\n * before a polygon ring or line string can be finished. Default is `3` for\n * polygon rings and `2` for line strings.\n * @property {import(\"../events/condition.js\").Condition} [finishCondition] A function\n * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether the drawing can be finished. Not used when drawing\n * POINT or MULTI_POINT geometries.\n * @property {import(\"../style/Style.js\").StyleLike|import(\"../style/flat.js\").FlatStyleLike} [style]\n * Style for sketch features.\n * @property {GeometryFunction} [geometryFunction]\n * Function that is called when a geometry's coordinates are updated.\n * @property {string} [geometryName] Geometry name to use for features created\n * by the draw interaction.\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * By default {@link module:ol/events/condition.noModifierKeys}, i.e. a click,\n * adds a vertex or deactivates freehand drawing.\n * @property {boolean} [freehand=false] Operate in freehand mode for lines,\n * polygons, and circles.  This makes the interaction always operate in freehand\n * mode and takes precedence over any `freehandCondition` option.\n * @property {import(\"../events/condition.js\").Condition} [freehandCondition]\n * Condition that activates freehand drawing for lines and polygons. This\n * function takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and\n * returns a boolean to indicate whether that event should be handled. The\n * default is {@link module:ol/events/condition.shiftKeyOnly}, meaning that the\n * Shift key activates freehand drawing.\n * @property {boolean|import(\"../events/condition.js\").Condition} [trace=false] Trace a portion of another geometry.\n * Ignored when in freehand mode.\n * @property {VectorSource} [traceSource] Source for features to trace.  If tracing is active and a `traceSource` is\n * not provided, the interaction's `source` will be used.  Tracing requires that the interaction is configured with\n * either a `traceSource` or a `source`.\n * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch\n * overlay.\n * @property {import(\"../geom/Geometry.js\").GeometryLayout} [geometryLayout='XY'] Layout of the\n * feature geometries created by the draw interaction.\n */\n\n/**\n * Coordinate type when drawing points.\n * @typedef {import(\"../coordinate.js\").Coordinate} PointCoordType\n */\n\n/**\n * Coordinate type when drawing lines.\n * @typedef {Array<import(\"../coordinate.js\").Coordinate>} LineCoordType\n */\n\n/**\n * Coordinate type when drawing polygons.\n * @typedef {Array<Array<import(\"../coordinate.js\").Coordinate>>} PolyCoordType\n */\n\n/**\n * Types used for drawing coordinates.\n * @typedef {PointCoordType|LineCoordType|PolyCoordType} SketchCoordType\n */\n\n/**\n * @typedef {Object} TraceState\n * @property {boolean} active Tracing active.\n * @property {import(\"../pixel.js\").Pixel} [startPx] The initially clicked pixel location.\n * @property {Array<TraceTarget>} [targets] Targets available for tracing.\n * @property {number} [targetIndex] The index of the currently traced target.  A value of -1 indicates\n * that no trace target is active.\n */\n\n/**\n * @typedef {Object} TraceTarget\n * @property {Array<import(\"../coordinate.js\").Coordinate>} coordinates Target coordinates.\n * @property {boolean} ring The target coordinates are a linear ring.\n * @property {number} startIndex The index of first traced coordinate.  A fractional index represents an\n * edge intersection.  Index values for rings will wrap (may be negative or larger than coordinates length).\n * @property {number} endIndex The index of last traced coordinate.  Details from startIndex also apply here.\n */\n\n/**\n * Function that takes an array of coordinates and an optional existing geometry\n * and a projection as arguments, and returns a geometry. The optional existing\n * geometry is the geometry that is returned when the function is called without\n * a second argument.\n * @typedef {function(!SketchCoordType, import(\"../geom/SimpleGeometry.js\").default,\n *     import(\"../proj/Projection.js\").default):\n *     import(\"../geom/SimpleGeometry.js\").default} GeometryFunction\n */\n\n/**\n * @typedef {'Point' | 'LineString' | 'Polygon' | 'Circle'} Mode\n * Draw mode.  This collapses multi-part geometry types with their single-part\n * cousins.\n */\n\n/**\n * @enum {string}\n */\nconst DrawEventType = {\n  /**\n   * Triggered upon feature draw start\n   * @event DrawEvent#drawstart\n   * @api\n   */\n  DRAWSTART: 'drawstart',\n  /**\n   * Triggered upon feature draw end\n   * @event DrawEvent#drawend\n   * @api\n   */\n  DRAWEND: 'drawend',\n  /**\n   * Triggered upon feature draw abortion\n   * @event DrawEvent#drawabort\n   * @api\n   */\n  DRAWABORT: 'drawabort',\n};\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/Draw~Draw} instances are\n * instances of this type.\n */\nexport class DrawEvent extends Event {\n  /**\n   * @param {DrawEventType} type Type.\n   * @param {Feature} feature The feature drawn.\n   */\n  constructor(type, feature) {\n    super(type);\n\n    /**\n     * The feature being drawn.\n     * @type {Feature}\n     * @api\n     */\n    this.feature = feature;\n  }\n}\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} coordinate The coordinate.\n * @param {Array<Feature>} features The candidate features.\n * @return {Array<TraceTarget>} The trace targets.\n */\nfunction getTraceTargets(coordinate, features) {\n  /**\n   * @type {Array<TraceTarget>}\n   */\n  const targets = [];\n\n  for (let i = 0; i < features.length; ++i) {\n    const feature = features[i];\n    const geometry = feature.getGeometry();\n    appendGeometryTraceTargets(coordinate, geometry, targets);\n  }\n\n  return targets;\n}\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} a One coordinate.\n * @param {import(\"../coordinate.js\").Coordinate} b Another coordinate.\n * @return {number} The squared distance between the two coordinates.\n */\nfunction getSquaredDistance(a, b) {\n  return squaredDistance(a[0], a[1], b[0], b[1]);\n}\n\n/**\n * @param {LineCoordType} coordinates The ring coordinates.\n * @param {number} index The index.  May be wrapped.\n * @return {import(\"../coordinate.js\").Coordinate} The coordinate.\n */\nfunction getCoordinate(coordinates, index) {\n  const count = coordinates.length;\n  if (index < 0) {\n    return coordinates[index + count];\n  }\n  if (index >= count) {\n    return coordinates[index - count];\n  }\n  return coordinates[index];\n}\n\n/**\n * Get the cumulative squared distance along a ring path.  The end index index may be \"wrapped\" and it may\n * be less than the start index to indicate the direction of travel.  The start and end index may have\n * a fractional part to indicate a point between two coordinates.\n * @param {LineCoordType} coordinates Ring coordinates.\n * @param {number} startIndex The start index.\n * @param {number} endIndex The end index.\n * @return {number} The cumulative squared distance along the ring path.\n */\nfunction getCumulativeSquaredDistance(coordinates, startIndex, endIndex) {\n  let lowIndex, highIndex;\n  if (startIndex < endIndex) {\n    lowIndex = startIndex;\n    highIndex = endIndex;\n  } else {\n    lowIndex = endIndex;\n    highIndex = startIndex;\n  }\n  const lowWholeIndex = Math.ceil(lowIndex);\n  const highWholeIndex = Math.floor(highIndex);\n\n  if (lowWholeIndex > highWholeIndex) {\n    // both start and end are on the same segment\n    const start = interpolateCoordinate(coordinates, lowIndex);\n    const end = interpolateCoordinate(coordinates, highIndex);\n    return getSquaredDistance(start, end);\n  }\n\n  let sd = 0;\n\n  if (lowIndex < lowWholeIndex) {\n    const start = interpolateCoordinate(coordinates, lowIndex);\n    const end = getCoordinate(coordinates, lowWholeIndex);\n    sd += getSquaredDistance(start, end);\n  }\n\n  if (highWholeIndex < highIndex) {\n    const start = getCoordinate(coordinates, highWholeIndex);\n    const end = interpolateCoordinate(coordinates, highIndex);\n    sd += getSquaredDistance(start, end);\n  }\n\n  for (let i = lowWholeIndex; i < highWholeIndex - 1; ++i) {\n    const start = getCoordinate(coordinates, i);\n    const end = getCoordinate(coordinates, i + 1);\n    sd += getSquaredDistance(start, end);\n  }\n\n  return sd;\n}\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} coordinate The coordinate.\n * @param {import(\"../geom/Geometry.js\").default} geometry The candidate geometry.\n * @param {Array<TraceTarget>} targets The trace targets.\n */\nfunction appendGeometryTraceTargets(coordinate, geometry, targets) {\n  if (geometry instanceof LineString) {\n    appendTraceTarget(coordinate, geometry.getCoordinates(), false, targets);\n    return;\n  }\n  if (geometry instanceof MultiLineString) {\n    const coordinates = geometry.getCoordinates();\n    for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n      appendTraceTarget(coordinate, coordinates[i], false, targets);\n    }\n    return;\n  }\n  if (geometry instanceof Polygon) {\n    const coordinates = geometry.getCoordinates();\n    for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n      appendTraceTarget(coordinate, coordinates[i], true, targets);\n    }\n    return;\n  }\n  if (geometry instanceof MultiPolygon) {\n    const polys = geometry.getCoordinates();\n    for (let i = 0, ii = polys.length; i < ii; ++i) {\n      const coordinates = polys[i];\n      for (let j = 0, jj = coordinates.length; j < jj; ++j) {\n        appendTraceTarget(coordinate, coordinates[j], true, targets);\n      }\n    }\n    return;\n  }\n  if (geometry instanceof GeometryCollection) {\n    const geometries = geometry.getGeometries();\n    for (let i = 0; i < geometries.length; ++i) {\n      appendGeometryTraceTargets(coordinate, geometries[i], targets);\n    }\n    return;\n  }\n  // other types cannot be traced\n}\n\n/**\n * @typedef {Object} TraceTargetUpdateInfo\n * @property {number} index The new target index.\n * @property {number} endIndex The new segment end index.\n */\n\n/**\n * @type {TraceTargetUpdateInfo}\n */\nconst sharedUpdateInfo = {index: -1, endIndex: NaN};\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} coordinate The coordinate.\n * @param {TraceState} traceState The trace state.\n * @param {import(\"../Map.js\").default} map The map.\n * @param {number} snapTolerance The snap tolerance.\n * @return {TraceTargetUpdateInfo} Information about the new trace target.  The returned\n * object is reused between calls and must not be modified by the caller.\n */\nfunction getTraceTargetUpdate(coordinate, traceState, map, snapTolerance) {\n  const x = coordinate[0];\n  const y = coordinate[1];\n\n  let closestTargetDistance = Infinity;\n\n  let newTargetIndex = -1;\n  let newEndIndex = NaN;\n\n  for (\n    let targetIndex = 0;\n    targetIndex < traceState.targets.length;\n    ++targetIndex\n  ) {\n    const target = traceState.targets[targetIndex];\n    const coordinates = target.coordinates;\n\n    let minSegmentDistance = Infinity;\n    let endIndex;\n    for (\n      let coordinateIndex = 0;\n      coordinateIndex < coordinates.length - 1;\n      ++coordinateIndex\n    ) {\n      const start = coordinates[coordinateIndex];\n      const end = coordinates[coordinateIndex + 1];\n      const rel = getPointSegmentRelationship(x, y, start, end);\n      if (rel.squaredDistance < minSegmentDistance) {\n        minSegmentDistance = rel.squaredDistance;\n        endIndex = coordinateIndex + rel.along;\n      }\n    }\n\n    if (minSegmentDistance < closestTargetDistance) {\n      closestTargetDistance = minSegmentDistance;\n      if (target.ring && traceState.targetIndex === targetIndex) {\n        // same target, maintain the same trace direction\n        if (target.endIndex > target.startIndex) {\n          // forward trace\n          if (endIndex < target.startIndex) {\n            endIndex += coordinates.length;\n          }\n        } else if (target.endIndex < target.startIndex) {\n          // reverse trace\n          if (endIndex > target.startIndex) {\n            endIndex -= coordinates.length;\n          }\n        }\n      }\n      newEndIndex = endIndex;\n      newTargetIndex = targetIndex;\n    }\n  }\n\n  const newTarget = traceState.targets[newTargetIndex];\n  let considerBothDirections = newTarget.ring;\n  if (traceState.targetIndex === newTargetIndex && considerBothDirections) {\n    // only consider switching trace direction if close to the start\n    const newCoordinate = interpolateCoordinate(\n      newTarget.coordinates,\n      newEndIndex\n    );\n    const pixel = map.getPixelFromCoordinate(newCoordinate);\n    if (distance(pixel, traceState.startPx) > snapTolerance) {\n      considerBothDirections = false;\n    }\n  }\n\n  if (considerBothDirections) {\n    const coordinates = newTarget.coordinates;\n    const count = coordinates.length;\n    const startIndex = newTarget.startIndex;\n    const endIndex = newEndIndex;\n    if (startIndex < endIndex) {\n      const forwardDistance = getCumulativeSquaredDistance(\n        coordinates,\n        startIndex,\n        endIndex\n      );\n      const reverseDistance = getCumulativeSquaredDistance(\n        coordinates,\n        startIndex,\n        endIndex - count\n      );\n      if (reverseDistance < forwardDistance) {\n        newEndIndex -= count;\n      }\n    } else {\n      const reverseDistance = getCumulativeSquaredDistance(\n        coordinates,\n        startIndex,\n        endIndex\n      );\n      const forwardDistance = getCumulativeSquaredDistance(\n        coordinates,\n        startIndex,\n        endIndex + count\n      );\n      if (forwardDistance < reverseDistance) {\n        newEndIndex += count;\n      }\n    }\n  }\n\n  sharedUpdateInfo.index = newTargetIndex;\n  sharedUpdateInfo.endIndex = newEndIndex;\n  return sharedUpdateInfo;\n}\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} coordinate The clicked coordinate.\n * @param {Array<import(\"../coordinate.js\").Coordinate>} coordinates The geometry component coordinates.\n * @param {boolean} ring The coordinates represent a linear ring.\n * @param {Array<TraceTarget>} targets The trace targets.\n */\nfunction appendTraceTarget(coordinate, coordinates, ring, targets) {\n  const x = coordinate[0];\n  const y = coordinate[1];\n  for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n    const start = coordinates[i];\n    const end = coordinates[i + 1];\n    const rel = getPointSegmentRelationship(x, y, start, end);\n    if (rel.squaredDistance === 0) {\n      const index = i + rel.along;\n      targets.push({\n        coordinates: coordinates,\n        ring: ring,\n        startIndex: index,\n        endIndex: index,\n      });\n      return;\n    }\n  }\n}\n\n/**\n * @typedef {Object} PointSegmentRelationship\n * @property {number} along The closest point expressed as a fraction along the segment length.\n * @property {number} squaredDistance The squared distance of the point to the segment.\n */\n\n/**\n * @type {PointSegmentRelationship}\n */\nconst sharedRel = {along: 0, squaredDistance: 0};\n\n/**\n * @param {number} x The point x.\n * @param {number} y The point y.\n * @param {import(\"../coordinate.js\").Coordinate} start The segment start.\n * @param {import(\"../coordinate.js\").Coordinate} end The segment end.\n * @return {PointSegmentRelationship} The point segment relationship.  The returned object is\n * shared between calls and must not be modified by the caller.\n */\nfunction getPointSegmentRelationship(x, y, start, end) {\n  const x1 = start[0];\n  const y1 = start[1];\n  const x2 = end[0];\n  const y2 = end[1];\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  let along = 0;\n  let px = x1;\n  let py = y1;\n  if (dx !== 0 || dy !== 0) {\n    along = clamp(((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy), 0, 1);\n    px += dx * along;\n    py += dy * along;\n  }\n\n  sharedRel.along = along;\n  sharedRel.squaredDistance = toFixed(squaredDistance(x, y, px, py), 10);\n  return sharedRel;\n}\n\n/**\n * @param {LineCoordType} coordinates The coordinates.\n * @param {number} index The index.  May be fractional and may wrap.\n * @return {import(\"../coordinate.js\").Coordinate} The interpolated coordinate.\n */\nfunction interpolateCoordinate(coordinates, index) {\n  const count = coordinates.length;\n\n  let startIndex = Math.floor(index);\n  const along = index - startIndex;\n  if (startIndex >= count) {\n    startIndex -= count;\n  } else if (startIndex < 0) {\n    startIndex += count;\n  }\n\n  let endIndex = startIndex + 1;\n  if (endIndex >= count) {\n    endIndex -= count;\n  }\n\n  const start = coordinates[startIndex];\n  const x0 = start[0];\n  const y0 = start[1];\n  const end = coordinates[endIndex];\n  const dx = end[0] - x0;\n  const dy = end[1] - y0;\n\n  return [x0 + dx * along, y0 + dy * along];\n}\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'drawabort'|'drawend'|'drawstart', DrawEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'drawabort'|'drawend'|'drawstart', Return>} DrawOnSignature\n */\n\n/**\n * @classdesc\n * Interaction for drawing feature geometries.\n *\n * @fires DrawEvent\n * @api\n */\nclass Draw extends PointerInteraction {\n  /**\n   * @param {Options} options Options.\n   */\n  constructor(options) {\n    const pointerOptions = /** @type {import(\"./Pointer.js\").Options} */ (\n      options\n    );\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n\n    super(pointerOptions);\n\n    /***\n     * @type {DrawOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {DrawOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {DrawOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.shouldHandle_ = false;\n\n    /**\n     * @type {import(\"../pixel.js\").Pixel}\n     * @private\n     */\n    this.downPx_ = null;\n\n    /**\n     * @type {?}\n     * @private\n     */\n    this.downTimeout_;\n\n    /**\n     * @type {number|undefined}\n     * @private\n     */\n    this.lastDragTime_;\n\n    /**\n     * Pointer type of the last pointermove event\n     * @type {string}\n     * @private\n     */\n    this.pointerType_;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.freehand_ = false;\n\n    /**\n     * Target source for drawn features.\n     * @type {VectorSource|null}\n     * @private\n     */\n    this.source_ = options.source ? options.source : null;\n\n    /**\n     * Target collection for drawn features.\n     * @type {import(\"../Collection.js\").default<Feature>|null}\n     * @private\n     */\n    this.features_ = options.features ? options.features : null;\n\n    /**\n     * Pixel distance for snapping.\n     * @type {number}\n     * @private\n     */\n    this.snapTolerance_ = options.snapTolerance ? options.snapTolerance : 12;\n\n    /**\n     * Geometry type.\n     * @type {import(\"../geom/Geometry.js\").Type}\n     * @private\n     */\n    this.type_ = /** @type {import(\"../geom/Geometry.js\").Type} */ (\n      options.type\n    );\n\n    /**\n     * Drawing mode (derived from geometry type.\n     * @type {Mode}\n     * @private\n     */\n    this.mode_ = getMode(this.type_);\n\n    /**\n     * Stop click, singleclick, and doubleclick events from firing during drawing.\n     * Default is `false`.\n     * @type {boolean}\n     * @private\n     */\n    this.stopClick_ = !!options.stopClick;\n\n    /**\n     * The number of points that must be drawn before a polygon ring or line\n     * string can be finished.  The default is 3 for polygon rings and 2 for\n     * line strings.\n     * @type {number}\n     * @private\n     */\n    this.minPoints_ = options.minPoints\n      ? options.minPoints\n      : this.mode_ === 'Polygon'\n      ? 3\n      : 2;\n\n    /**\n     * The number of points that can be drawn before a polygon ring or line string\n     * is finished. The default is no restriction.\n     * @type {number}\n     * @private\n     */\n    this.maxPoints_ =\n      this.mode_ === 'Circle'\n        ? 2\n        : options.maxPoints\n        ? options.maxPoints\n        : Infinity;\n\n    /**\n     * A function to decide if a potential finish coordinate is permissible\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.finishCondition_ = options.finishCondition\n      ? options.finishCondition\n      : TRUE;\n\n    /**\n     * @private\n     * @type {import(\"../geom/Geometry.js\").GeometryLayout}\n     */\n    this.geometryLayout_ = options.geometryLayout\n      ? options.geometryLayout\n      : 'XY';\n\n    let geometryFunction = options.geometryFunction;\n    if (!geometryFunction) {\n      const mode = this.mode_;\n      if (mode === 'Circle') {\n        /**\n         * @param {!LineCoordType} coordinates The coordinates.\n         * @param {import(\"../geom/SimpleGeometry.js\").default|undefined} geometry Optional geometry.\n         * @param {import(\"../proj/Projection.js\").default} projection The view projection.\n         * @return {import(\"../geom/SimpleGeometry.js\").default} A geometry.\n         */\n        geometryFunction = function (coordinates, geometry, projection) {\n          const circle = geometry\n            ? /** @type {Circle} */ (geometry)\n            : new Circle([NaN, NaN]);\n          const center = fromUserCoordinate(coordinates[0], projection);\n          const squaredLength = squaredCoordinateDistance(\n            center,\n            fromUserCoordinate(coordinates[coordinates.length - 1], projection)\n          );\n          circle.setCenterAndRadius(\n            center,\n            Math.sqrt(squaredLength),\n            this.geometryLayout_\n          );\n          const userProjection = getUserProjection();\n          if (userProjection) {\n            circle.transform(projection, userProjection);\n          }\n          return circle;\n        };\n      } else {\n        let Constructor;\n        if (mode === 'Point') {\n          Constructor = Point;\n        } else if (mode === 'LineString') {\n          Constructor = LineString;\n        } else if (mode === 'Polygon') {\n          Constructor = Polygon;\n        }\n        /**\n         * @param {!LineCoordType} coordinates The coordinates.\n         * @param {import(\"../geom/SimpleGeometry.js\").default|undefined} geometry Optional geometry.\n         * @param {import(\"../proj/Projection.js\").default} projection The view projection.\n         * @return {import(\"../geom/SimpleGeometry.js\").default} A geometry.\n         */\n        geometryFunction = function (coordinates, geometry, projection) {\n          if (geometry) {\n            if (mode === 'Polygon') {\n              if (coordinates[0].length) {\n                // Add a closing coordinate to match the first\n                geometry.setCoordinates(\n                  [coordinates[0].concat([coordinates[0][0]])],\n                  this.geometryLayout_\n                );\n              } else {\n                geometry.setCoordinates([], this.geometryLayout_);\n              }\n            } else {\n              geometry.setCoordinates(coordinates, this.geometryLayout_);\n            }\n          } else {\n            geometry = new Constructor(coordinates, this.geometryLayout_);\n          }\n          return geometry;\n        };\n      }\n    }\n\n    /**\n     * @type {GeometryFunction}\n     * @private\n     */\n    this.geometryFunction_ = geometryFunction;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.dragVertexDelay_ =\n      options.dragVertexDelay !== undefined ? options.dragVertexDelay : 500;\n\n    /**\n     * Finish coordinate for the feature (first point for polygons, last point for\n     * linestrings).\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    this.finishCoordinate_ = null;\n\n    /**\n     * Sketch feature.\n     * @type {Feature<import('../geom/SimpleGeometry.js').default>}\n     * @private\n     */\n    this.sketchFeature_ = null;\n\n    /**\n     * Sketch point.\n     * @type {Feature<Point>}\n     * @private\n     */\n    this.sketchPoint_ = null;\n\n    /**\n     * Sketch coordinates. Used when drawing a line or polygon.\n     * @type {SketchCoordType}\n     * @private\n     */\n    this.sketchCoords_ = null;\n\n    /**\n     * Sketch line. Used when drawing polygon.\n     * @type {Feature<LineString>}\n     * @private\n     */\n    this.sketchLine_ = null;\n\n    /**\n     * Sketch line coordinates. Used when drawing a polygon or circle.\n     * @type {LineCoordType}\n     * @private\n     */\n    this.sketchLineCoords_ = null;\n\n    /**\n     * Squared tolerance for handling up events.  If the squared distance\n     * between a down and up event is greater than this tolerance, up events\n     * will not be handled.\n     * @type {number}\n     * @private\n     */\n    this.squaredClickTolerance_ = options.clickTolerance\n      ? options.clickTolerance * options.clickTolerance\n      : 36;\n\n    /**\n     * Draw overlay where our sketch features are drawn.\n     * @type {VectorLayer}\n     * @private\n     */\n    this.overlay_ = new VectorLayer({\n      source: new VectorSource({\n        useSpatialIndex: false,\n        wrapX: options.wrapX ? options.wrapX : false,\n      }),\n      style: options.style ? options.style : getDefaultStyleFunction(),\n      updateWhileInteracting: true,\n    });\n\n    /**\n     * Name of the geometry attribute for newly created features.\n     * @type {string|undefined}\n     * @private\n     */\n    this.geometryName_ = options.geometryName;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.condition_ = options.condition ? options.condition : noModifierKeys;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.freehandCondition_;\n    if (options.freehand) {\n      this.freehandCondition_ = always;\n    } else {\n      this.freehandCondition_ = options.freehandCondition\n        ? options.freehandCondition\n        : shiftKeyOnly;\n    }\n\n    /**\n     * @type {import(\"../events/condition.js\").Condition}\n     * @private\n     */\n    this.traceCondition_;\n    this.setTrace(options.trace || false);\n\n    /**\n     * @type {TraceState}\n     * @private\n     */\n    this.traceState_ = {active: false};\n\n    /**\n     * @type {VectorSource|null}\n     * @private\n     */\n    this.traceSource_ = options.traceSource || options.source || null;\n\n    this.addChangeListener(InteractionProperty.ACTIVE, this.updateState_);\n  }\n\n  /**\n   * Toggle tracing mode or set a tracing condition.\n   *\n   * @param {boolean|import(\"../events/condition.js\").Condition} trace A boolean to toggle tracing mode or an event\n   *     condition that will be checked when a feature is clicked to determine if tracing should be active.\n   */\n  setTrace(trace) {\n    let condition;\n    if (!trace) {\n      condition = never;\n    } else if (trace === true) {\n      condition = always;\n    } else {\n      condition = trace;\n    }\n    this.traceCondition_ = condition;\n  }\n\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../Map.js\").default} map Map.\n   */\n  setMap(map) {\n    super.setMap(map);\n    this.updateState_();\n  }\n\n  /**\n   * Get the overlay layer that this interaction renders sketch features to.\n   * @return {VectorLayer} Overlay layer.\n   * @api\n   */\n  getOverlay() {\n    return this.overlay_;\n  }\n\n  /**\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may actually draw or finish the drawing.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   * @api\n   */\n  handleEvent(event) {\n    if (event.originalEvent.type === EventType.CONTEXTMENU) {\n      // Avoid context menu for long taps when drawing on mobile\n      event.originalEvent.preventDefault();\n    }\n    this.freehand_ = this.mode_ !== 'Point' && this.freehandCondition_(event);\n    let move = event.type === MapBrowserEventType.POINTERMOVE;\n    let pass = true;\n    if (\n      !this.freehand_ &&\n      this.lastDragTime_ &&\n      event.type === MapBrowserEventType.POINTERDRAG\n    ) {\n      const now = Date.now();\n      if (now - this.lastDragTime_ >= this.dragVertexDelay_) {\n        this.downPx_ = event.pixel;\n        this.shouldHandle_ = !this.freehand_;\n        move = true;\n      } else {\n        this.lastDragTime_ = undefined;\n      }\n      if (this.shouldHandle_ && this.downTimeout_ !== undefined) {\n        clearTimeout(this.downTimeout_);\n        this.downTimeout_ = undefined;\n      }\n    }\n    if (\n      this.freehand_ &&\n      event.type === MapBrowserEventType.POINTERDRAG &&\n      this.sketchFeature_ !== null\n    ) {\n      this.addToDrawing_(event.coordinate);\n      pass = false;\n    } else if (\n      this.freehand_ &&\n      event.type === MapBrowserEventType.POINTERDOWN\n    ) {\n      pass = false;\n    } else if (move && this.getPointerCount() < 2) {\n      pass = event.type === MapBrowserEventType.POINTERMOVE;\n      if (pass && this.freehand_) {\n        this.handlePointerMove_(event);\n        if (this.shouldHandle_) {\n          // Avoid page scrolling when freehand drawing on mobile\n          event.originalEvent.preventDefault();\n        }\n      } else if (\n        event.originalEvent.pointerType === 'mouse' ||\n        (event.type === MapBrowserEventType.POINTERDRAG &&\n          this.downTimeout_ === undefined)\n      ) {\n        this.handlePointerMove_(event);\n      }\n    } else if (event.type === MapBrowserEventType.DBLCLICK) {\n      pass = false;\n    }\n\n    return super.handleEvent(event) && pass;\n  }\n\n  /**\n   * Handle pointer down events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleDownEvent(event) {\n    this.shouldHandle_ = !this.freehand_;\n\n    if (this.freehand_) {\n      this.downPx_ = event.pixel;\n      if (!this.finishCoordinate_) {\n        this.startDrawing_(event.coordinate);\n      }\n      return true;\n    }\n\n    if (!this.condition_(event)) {\n      this.lastDragTime_ = undefined;\n      return false;\n    }\n\n    this.lastDragTime_ = Date.now();\n    this.downTimeout_ = setTimeout(() => {\n      this.handlePointerMove_(\n        new MapBrowserEvent(\n          MapBrowserEventType.POINTERMOVE,\n          event.map,\n          event.originalEvent,\n          false,\n          event.frameState\n        )\n      );\n    }, this.dragVertexDelay_);\n    this.downPx_ = event.pixel;\n    return true;\n  }\n\n  /**\n   * @private\n   */\n  deactivateTrace_() {\n    this.traceState_ = {active: false};\n  }\n\n  /**\n   * Activate or deactivate trace state based on a browser event.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @private\n   */\n  toggleTraceState_(event) {\n    if (!this.traceSource_ || !this.traceCondition_(event)) {\n      return;\n    }\n\n    if (this.traceState_.active) {\n      this.deactivateTrace_();\n      return;\n    }\n\n    const map = this.getMap();\n    const lowerLeft = map.getCoordinateFromPixel([\n      event.pixel[0] - this.snapTolerance_,\n      event.pixel[1] + this.snapTolerance_,\n    ]);\n    const upperRight = map.getCoordinateFromPixel([\n      event.pixel[0] + this.snapTolerance_,\n      event.pixel[1] - this.snapTolerance_,\n    ]);\n    const extent = boundingExtent([lowerLeft, upperRight]);\n    const features = this.traceSource_.getFeaturesInExtent(extent);\n    if (features.length === 0) {\n      return;\n    }\n\n    const targets = getTraceTargets(event.coordinate, features);\n    if (targets.length) {\n      this.traceState_ = {\n        active: true,\n        startPx: event.pixel.slice(),\n        targets: targets,\n        targetIndex: -1,\n      };\n    }\n  }\n\n  /**\n   * @param {TraceTarget} target The trace target.\n   * @param {number} endIndex The new end index of the trace.\n   * @private\n   */\n  addOrRemoveTracedCoordinates_(target, endIndex) {\n    // three cases to handle:\n    //  1. traced in the same direction and points need adding\n    //  2. traced in the same direction and points need removing\n    //  3. traced in a new direction\n    const previouslyForward = target.startIndex <= target.endIndex;\n    const currentlyForward = target.startIndex <= endIndex;\n    if (previouslyForward === currentlyForward) {\n      // same direction\n      if (\n        (previouslyForward && endIndex > target.endIndex) ||\n        (!previouslyForward && endIndex < target.endIndex)\n      ) {\n        // case 1 - add new points\n        this.addTracedCoordinates_(target, target.endIndex, endIndex);\n      } else if (\n        (previouslyForward && endIndex < target.endIndex) ||\n        (!previouslyForward && endIndex > target.endIndex)\n      ) {\n        // case 2 - remove old points\n        this.removeTracedCoordinates_(endIndex, target.endIndex);\n      }\n    } else {\n      // case 3 - remove old points, add new points\n      this.removeTracedCoordinates_(target.startIndex, target.endIndex);\n      this.addTracedCoordinates_(target, target.startIndex, endIndex);\n    }\n  }\n\n  /**\n   * @param {number} fromIndex The start index.\n   * @param {number} toIndex The end index.\n   * @private\n   */\n  removeTracedCoordinates_(fromIndex, toIndex) {\n    if (fromIndex === toIndex) {\n      return;\n    }\n\n    let remove = 0;\n    if (fromIndex < toIndex) {\n      const start = Math.ceil(fromIndex);\n      let end = Math.floor(toIndex);\n      if (end === toIndex) {\n        end -= 1;\n      }\n      remove = end - start + 1;\n    } else {\n      const start = Math.floor(fromIndex);\n      let end = Math.ceil(toIndex);\n      if (end === toIndex) {\n        end += 1;\n      }\n      remove = start - end + 1;\n    }\n\n    if (remove > 0) {\n      this.removeLastPoints_(remove);\n    }\n  }\n\n  /**\n   * @param {TraceTarget} target The trace target.\n   * @param {number} fromIndex The start index.\n   * @param {number} toIndex The end index.\n   * @private\n   */\n  addTracedCoordinates_(target, fromIndex, toIndex) {\n    if (fromIndex === toIndex) {\n      return;\n    }\n\n    const coordinates = [];\n    if (fromIndex < toIndex) {\n      // forward trace\n      const start = Math.ceil(fromIndex);\n      let end = Math.floor(toIndex);\n      if (end === toIndex) {\n        // if end is snapped to a vertex, it will be added later\n        end -= 1;\n      }\n      for (let i = start; i <= end; ++i) {\n        coordinates.push(getCoordinate(target.coordinates, i));\n      }\n    } else {\n      // reverse trace\n      const start = Math.floor(fromIndex);\n      let end = Math.ceil(toIndex);\n      if (end === toIndex) {\n        end += 1;\n      }\n      for (let i = start; i >= end; --i) {\n        coordinates.push(getCoordinate(target.coordinates, i));\n      }\n    }\n    if (coordinates.length) {\n      this.appendCoordinates(coordinates);\n    }\n  }\n\n  /**\n   * Update the trace.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @private\n   */\n  updateTrace_(event) {\n    const traceState = this.traceState_;\n    if (!traceState.active) {\n      return;\n    }\n\n    if (traceState.targetIndex === -1) {\n      // check if we are ready to pick a target\n      if (distance(traceState.startPx, event.pixel) < this.snapTolerance_) {\n        return;\n      }\n    }\n\n    const updatedTraceTarget = getTraceTargetUpdate(\n      event.coordinate,\n      traceState,\n      this.getMap(),\n      this.snapTolerance_\n    );\n\n    if (traceState.targetIndex !== updatedTraceTarget.index) {\n      // target changed\n      if (traceState.targetIndex !== -1) {\n        // remove points added during previous trace\n        const oldTarget = traceState.targets[traceState.targetIndex];\n        this.removeTracedCoordinates_(oldTarget.startIndex, oldTarget.endIndex);\n      }\n      // add points for the new target\n      const newTarget = traceState.targets[updatedTraceTarget.index];\n      this.addTracedCoordinates_(\n        newTarget,\n        newTarget.startIndex,\n        updatedTraceTarget.endIndex\n      );\n    } else {\n      // target stayed the same\n      const target = traceState.targets[traceState.targetIndex];\n      this.addOrRemoveTracedCoordinates_(target, updatedTraceTarget.endIndex);\n    }\n\n    // modify the state with updated info\n    traceState.targetIndex = updatedTraceTarget.index;\n    const target = traceState.targets[traceState.targetIndex];\n    target.endIndex = updatedTraceTarget.endIndex;\n\n    // update event coordinate and pixel to match end point of final segment\n    const coordinate = interpolateCoordinate(\n      target.coordinates,\n      target.endIndex\n    );\n    const pixel = this.getMap().getPixelFromCoordinate(coordinate);\n    event.coordinate = coordinate;\n    event.pixel = [Math.round(pixel[0]), Math.round(pixel[1])];\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleUpEvent(event) {\n    let pass = true;\n\n    if (this.getPointerCount() === 0) {\n      if (this.downTimeout_) {\n        clearTimeout(this.downTimeout_);\n        this.downTimeout_ = undefined;\n      }\n\n      this.handlePointerMove_(event);\n      const tracing = this.traceState_.active;\n      this.toggleTraceState_(event);\n\n      if (this.shouldHandle_) {\n        const startingToDraw = !this.finishCoordinate_;\n        if (startingToDraw) {\n          this.startDrawing_(event.coordinate);\n        }\n        if (!startingToDraw && this.freehand_) {\n          this.finishDrawing();\n        } else if (\n          !this.freehand_ &&\n          (!startingToDraw || this.mode_ === 'Point')\n        ) {\n          if (this.atFinish_(event.pixel, tracing)) {\n            if (this.finishCondition_(event)) {\n              this.finishDrawing();\n            }\n          } else {\n            this.addToDrawing_(event.coordinate);\n          }\n        }\n        pass = false;\n      } else if (this.freehand_) {\n        this.abortDrawing();\n      }\n    }\n\n    if (!pass && this.stopClick_) {\n      event.preventDefault();\n    }\n    return pass;\n  }\n\n  /**\n   * Handle move events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event A move event.\n   * @private\n   */\n  handlePointerMove_(event) {\n    this.pointerType_ = event.originalEvent.pointerType;\n    if (\n      this.downPx_ &&\n      ((!this.freehand_ && this.shouldHandle_) ||\n        (this.freehand_ && !this.shouldHandle_))\n    ) {\n      const downPx = this.downPx_;\n      const clickPx = event.pixel;\n      const dx = downPx[0] - clickPx[0];\n      const dy = downPx[1] - clickPx[1];\n      const squaredDistance = dx * dx + dy * dy;\n      this.shouldHandle_ = this.freehand_\n        ? squaredDistance > this.squaredClickTolerance_\n        : squaredDistance <= this.squaredClickTolerance_;\n      if (!this.shouldHandle_) {\n        return;\n      }\n    }\n\n    if (!this.finishCoordinate_) {\n      this.createOrUpdateSketchPoint_(event.coordinate.slice());\n      return;\n    }\n\n    this.updateTrace_(event);\n    this.modifyDrawing_(event.coordinate);\n  }\n\n  /**\n   * Determine if an event is within the snapping tolerance of the start coord.\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @param {boolean} [tracing] Drawing in trace mode (only stop if at the starting point).\n   * @return {boolean} The event is within the snapping tolerance of the start.\n   * @private\n   */\n  atFinish_(pixel, tracing) {\n    let at = false;\n    if (this.sketchFeature_) {\n      let potentiallyDone = false;\n      let potentiallyFinishCoordinates = [this.finishCoordinate_];\n      const mode = this.mode_;\n      if (mode === 'Point') {\n        at = true;\n      } else if (mode === 'Circle') {\n        at = this.sketchCoords_.length === 2;\n      } else if (mode === 'LineString') {\n        potentiallyDone =\n          !tracing && this.sketchCoords_.length > this.minPoints_;\n      } else if (mode === 'Polygon') {\n        const sketchCoords = /** @type {PolyCoordType} */ (this.sketchCoords_);\n        potentiallyDone = sketchCoords[0].length > this.minPoints_;\n        potentiallyFinishCoordinates = [\n          sketchCoords[0][0],\n          sketchCoords[0][sketchCoords[0].length - 2],\n        ];\n        if (tracing) {\n          potentiallyFinishCoordinates = [sketchCoords[0][0]];\n        } else {\n          potentiallyFinishCoordinates = [\n            sketchCoords[0][0],\n            sketchCoords[0][sketchCoords[0].length - 2],\n          ];\n        }\n      }\n      if (potentiallyDone) {\n        const map = this.getMap();\n        for (let i = 0, ii = potentiallyFinishCoordinates.length; i < ii; i++) {\n          const finishCoordinate = potentiallyFinishCoordinates[i];\n          const finishPixel = map.getPixelFromCoordinate(finishCoordinate);\n          const dx = pixel[0] - finishPixel[0];\n          const dy = pixel[1] - finishPixel[1];\n          const snapTolerance = this.freehand_ ? 1 : this.snapTolerance_;\n          at = Math.sqrt(dx * dx + dy * dy) <= snapTolerance;\n          if (at) {\n            this.finishCoordinate_ = finishCoordinate;\n            break;\n          }\n        }\n      }\n    }\n    return at;\n  }\n\n  /**\n   * @param {import(\"../coordinate\").Coordinate} coordinates Coordinate.\n   * @private\n   */\n  createOrUpdateSketchPoint_(coordinates) {\n    if (!this.sketchPoint_) {\n      this.sketchPoint_ = new Feature(new Point(coordinates));\n      this.updateSketchFeatures_();\n    } else {\n      const sketchPointGeom = this.sketchPoint_.getGeometry();\n      sketchPointGeom.setCoordinates(coordinates);\n    }\n  }\n\n  /**\n   * @param {import(\"../geom/Polygon.js\").default} geometry Polygon geometry.\n   * @private\n   */\n  createOrUpdateCustomSketchLine_(geometry) {\n    if (!this.sketchLine_) {\n      this.sketchLine_ = new Feature();\n    }\n    const ring = geometry.getLinearRing(0);\n    let sketchLineGeom = this.sketchLine_.getGeometry();\n    if (!sketchLineGeom) {\n      sketchLineGeom = new LineString(\n        ring.getFlatCoordinates(),\n        ring.getLayout()\n      );\n      this.sketchLine_.setGeometry(sketchLineGeom);\n    } else {\n      sketchLineGeom.setFlatCoordinates(\n        ring.getLayout(),\n        ring.getFlatCoordinates()\n      );\n      sketchLineGeom.changed();\n    }\n  }\n\n  /**\n   * Start the drawing.\n   * @param {import(\"../coordinate.js\").Coordinate} start Start coordinate.\n   * @private\n   */\n  startDrawing_(start) {\n    const projection = this.getMap().getView().getProjection();\n    const stride = getStrideForLayout(this.geometryLayout_);\n    while (start.length < stride) {\n      start.push(0);\n    }\n    this.finishCoordinate_ = start;\n    if (this.mode_ === 'Point') {\n      this.sketchCoords_ = start.slice();\n    } else if (this.mode_ === 'Polygon') {\n      this.sketchCoords_ = [[start.slice(), start.slice()]];\n      this.sketchLineCoords_ = this.sketchCoords_[0];\n    } else {\n      this.sketchCoords_ = [start.slice(), start.slice()];\n    }\n    if (this.sketchLineCoords_) {\n      this.sketchLine_ = new Feature(new LineString(this.sketchLineCoords_));\n    }\n    const geometry = this.geometryFunction_(\n      this.sketchCoords_,\n      undefined,\n      projection\n    );\n    this.sketchFeature_ = new Feature();\n    if (this.geometryName_) {\n      this.sketchFeature_.setGeometryName(this.geometryName_);\n    }\n    this.sketchFeature_.setGeometry(geometry);\n    this.updateSketchFeatures_();\n    this.dispatchEvent(\n      new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_)\n    );\n  }\n\n  /**\n   * Modify the drawing.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @private\n   */\n  modifyDrawing_(coordinate) {\n    const map = this.getMap();\n    const geometry = this.sketchFeature_.getGeometry();\n    const projection = map.getView().getProjection();\n    const stride = getStrideForLayout(this.geometryLayout_);\n    let coordinates, last;\n    while (coordinate.length < stride) {\n      coordinate.push(0);\n    }\n    if (this.mode_ === 'Point') {\n      last = this.sketchCoords_;\n    } else if (this.mode_ === 'Polygon') {\n      coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];\n      last = coordinates[coordinates.length - 1];\n      if (this.atFinish_(map.getPixelFromCoordinate(coordinate))) {\n        // snap to finish\n        coordinate = this.finishCoordinate_.slice();\n      }\n    } else {\n      coordinates = this.sketchCoords_;\n      last = coordinates[coordinates.length - 1];\n    }\n    last[0] = coordinate[0];\n    last[1] = coordinate[1];\n    this.geometryFunction_(\n      /** @type {!LineCoordType} */ (this.sketchCoords_),\n      geometry,\n      projection\n    );\n    if (this.sketchPoint_) {\n      const sketchPointGeom = this.sketchPoint_.getGeometry();\n      sketchPointGeom.setCoordinates(coordinate);\n    }\n    if (geometry.getType() === 'Polygon' && this.mode_ !== 'Polygon') {\n      this.createOrUpdateCustomSketchLine_(/** @type {Polygon} */ (geometry));\n    } else if (this.sketchLineCoords_) {\n      const sketchLineGeom = this.sketchLine_.getGeometry();\n      sketchLineGeom.setCoordinates(this.sketchLineCoords_);\n    }\n    this.updateSketchFeatures_();\n  }\n\n  /**\n   * Add a new coordinate to the drawing.\n   * @param {!PointCoordType} coordinate Coordinate\n   * @private\n   */\n  addToDrawing_(coordinate) {\n    const geometry = this.sketchFeature_.getGeometry();\n    const projection = this.getMap().getView().getProjection();\n    let done;\n    let coordinates;\n    const mode = this.mode_;\n    if (mode === 'LineString' || mode === 'Circle') {\n      this.finishCoordinate_ = coordinate.slice();\n      coordinates = /** @type {LineCoordType} */ (this.sketchCoords_);\n      if (coordinates.length >= this.maxPoints_) {\n        if (this.freehand_) {\n          coordinates.pop();\n        } else {\n          done = true;\n        }\n      }\n      coordinates.push(coordinate.slice());\n      this.geometryFunction_(coordinates, geometry, projection);\n    } else if (mode === 'Polygon') {\n      coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];\n      if (coordinates.length >= this.maxPoints_) {\n        if (this.freehand_) {\n          coordinates.pop();\n        } else {\n          done = true;\n        }\n      }\n      coordinates.push(coordinate.slice());\n      if (done) {\n        this.finishCoordinate_ = coordinates[0];\n      }\n      this.geometryFunction_(this.sketchCoords_, geometry, projection);\n    }\n    this.createOrUpdateSketchPoint_(coordinate.slice());\n    this.updateSketchFeatures_();\n    if (done) {\n      this.finishDrawing();\n    }\n  }\n\n  /**\n   * @param {number} n The number of points to remove.\n   */\n  removeLastPoints_(n) {\n    if (!this.sketchFeature_) {\n      return;\n    }\n    const geometry = this.sketchFeature_.getGeometry();\n    const projection = this.getMap().getView().getProjection();\n    const mode = this.mode_;\n    for (let i = 0; i < n; ++i) {\n      let coordinates;\n      if (mode === 'LineString' || mode === 'Circle') {\n        coordinates = /** @type {LineCoordType} */ (this.sketchCoords_);\n        coordinates.splice(-2, 1);\n        if (coordinates.length >= 2) {\n          this.finishCoordinate_ = coordinates[coordinates.length - 2].slice();\n          const finishCoordinate = this.finishCoordinate_.slice();\n          coordinates[coordinates.length - 1] = finishCoordinate;\n          this.createOrUpdateSketchPoint_(finishCoordinate);\n        }\n        this.geometryFunction_(coordinates, geometry, projection);\n        if (geometry.getType() === 'Polygon' && this.sketchLine_) {\n          this.createOrUpdateCustomSketchLine_(\n            /** @type {Polygon} */ (geometry)\n          );\n        }\n      } else if (mode === 'Polygon') {\n        coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];\n        coordinates.splice(-2, 1);\n        const sketchLineGeom = this.sketchLine_.getGeometry();\n        if (coordinates.length >= 2) {\n          const finishCoordinate = coordinates[coordinates.length - 2].slice();\n          coordinates[coordinates.length - 1] = finishCoordinate;\n          this.createOrUpdateSketchPoint_(finishCoordinate);\n        }\n        sketchLineGeom.setCoordinates(coordinates);\n        this.geometryFunction_(this.sketchCoords_, geometry, projection);\n      }\n\n      if (coordinates.length === 1) {\n        this.abortDrawing();\n        break;\n      }\n    }\n\n    this.updateSketchFeatures_();\n  }\n\n  /**\n   * Remove last point of the feature currently being drawn. Does not do anything when\n   * drawing POINT or MULTI_POINT geometries.\n   * @api\n   */\n  removeLastPoint() {\n    this.removeLastPoints_(1);\n  }\n\n  /**\n   * Stop drawing and add the sketch feature to the target layer.\n   * The {@link module:ol/interaction/Draw~DrawEventType.DRAWEND} event is\n   * dispatched before inserting the feature.\n   * @api\n   */\n  finishDrawing() {\n    const sketchFeature = this.abortDrawing_();\n    if (!sketchFeature) {\n      return;\n    }\n    let coordinates = this.sketchCoords_;\n    const geometry = sketchFeature.getGeometry();\n    const projection = this.getMap().getView().getProjection();\n    if (this.mode_ === 'LineString') {\n      // remove the redundant last point\n      coordinates.pop();\n      this.geometryFunction_(coordinates, geometry, projection);\n    } else if (this.mode_ === 'Polygon') {\n      // remove the redundant last point in ring\n      /** @type {PolyCoordType} */ (coordinates)[0].pop();\n      this.geometryFunction_(coordinates, geometry, projection);\n      coordinates = geometry.getCoordinates();\n    }\n\n    // cast multi-part geometries\n    if (this.type_ === 'MultiPoint') {\n      sketchFeature.setGeometry(\n        new MultiPoint([/** @type {PointCoordType} */ (coordinates)])\n      );\n    } else if (this.type_ === 'MultiLineString') {\n      sketchFeature.setGeometry(\n        new MultiLineString([/** @type {LineCoordType} */ (coordinates)])\n      );\n    } else if (this.type_ === 'MultiPolygon') {\n      sketchFeature.setGeometry(\n        new MultiPolygon([/** @type {PolyCoordType} */ (coordinates)])\n      );\n    }\n\n    // First dispatch event to allow full set up of feature\n    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWEND, sketchFeature));\n\n    // Then insert feature\n    if (this.features_) {\n      this.features_.push(sketchFeature);\n    }\n    if (this.source_) {\n      this.source_.addFeature(sketchFeature);\n    }\n  }\n\n  /**\n   * Stop drawing without adding the sketch feature to the target layer.\n   * @return {Feature<import(\"../geom/SimpleGeometry.js\").default>|null} The sketch feature (or null if none).\n   * @private\n   */\n  abortDrawing_() {\n    this.finishCoordinate_ = null;\n    const sketchFeature = this.sketchFeature_;\n    this.sketchFeature_ = null;\n    this.sketchPoint_ = null;\n    this.sketchLine_ = null;\n    this.overlay_.getSource().clear(true);\n    this.deactivateTrace_();\n    return sketchFeature;\n  }\n\n  /**\n   * Stop drawing without adding the sketch feature to the target layer.\n   * @api\n   */\n  abortDrawing() {\n    const sketchFeature = this.abortDrawing_();\n    if (sketchFeature) {\n      this.dispatchEvent(new DrawEvent(DrawEventType.DRAWABORT, sketchFeature));\n    }\n  }\n\n  /**\n   * Append coordinates to the end of the geometry that is currently being drawn.\n   * This can be used when drawing LineStrings or Polygons. Coordinates will\n   * either be appended to the current LineString or the outer ring of the current\n   * Polygon. If no geometry is being drawn, a new one will be created.\n   * @param {!LineCoordType} coordinates Linear coordinates to be appended to\n   * the coordinate array.\n   * @api\n   */\n  appendCoordinates(coordinates) {\n    const mode = this.mode_;\n    const newDrawing = !this.sketchFeature_;\n    if (newDrawing) {\n      this.startDrawing_(coordinates[0]);\n    }\n    /** @type {LineCoordType} */\n    let sketchCoords;\n    if (mode === 'LineString' || mode === 'Circle') {\n      sketchCoords = /** @type {LineCoordType} */ (this.sketchCoords_);\n    } else if (mode === 'Polygon') {\n      sketchCoords =\n        this.sketchCoords_ && this.sketchCoords_.length\n          ? /** @type {PolyCoordType} */ (this.sketchCoords_)[0]\n          : [];\n    } else {\n      return;\n    }\n\n    if (newDrawing) {\n      sketchCoords.shift();\n    }\n\n    // Remove last coordinate from sketch drawing (this coordinate follows cursor position)\n    sketchCoords.pop();\n\n    // Append coordinate list\n    for (let i = 0; i < coordinates.length; i++) {\n      this.addToDrawing_(coordinates[i]);\n    }\n\n    const ending = coordinates[coordinates.length - 1];\n    // Duplicate last coordinate for sketch drawing (cursor position)\n    this.addToDrawing_(ending);\n    this.modifyDrawing_(ending);\n  }\n\n  /**\n   * Initiate draw mode by starting from an existing geometry which will\n   * receive new additional points. This only works on features with\n   * `LineString` geometries, where the interaction will extend lines by adding\n   * points to the end of the coordinates array.\n   * This will change the original feature, instead of drawing a copy.\n   *\n   * The function will dispatch a `drawstart` event.\n   *\n   * @param {!Feature<LineString>} feature Feature to be extended.\n   * @api\n   */\n  extend(feature) {\n    const geometry = feature.getGeometry();\n    const lineString = geometry;\n    this.sketchFeature_ = feature;\n    this.sketchCoords_ = lineString.getCoordinates();\n    const last = this.sketchCoords_[this.sketchCoords_.length - 1];\n    this.finishCoordinate_ = last.slice();\n    this.sketchCoords_.push(last.slice());\n    this.sketchPoint_ = new Feature(new Point(last));\n    this.updateSketchFeatures_();\n    this.dispatchEvent(\n      new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_)\n    );\n  }\n\n  /**\n   * Redraw the sketch features.\n   * @private\n   */\n  updateSketchFeatures_() {\n    const sketchFeatures = [];\n    if (this.sketchFeature_) {\n      sketchFeatures.push(this.sketchFeature_);\n    }\n    if (this.sketchLine_) {\n      sketchFeatures.push(this.sketchLine_);\n    }\n    if (this.sketchPoint_) {\n      sketchFeatures.push(this.sketchPoint_);\n    }\n    const overlaySource = this.overlay_.getSource();\n    overlaySource.clear(true);\n    overlaySource.addFeatures(sketchFeatures);\n  }\n\n  /**\n   * @private\n   */\n  updateState_() {\n    const map = this.getMap();\n    const active = this.getActive();\n    if (!map || !active) {\n      this.abortDrawing();\n    }\n    this.overlay_.setMap(active ? map : null);\n  }\n}\n\n/**\n * @return {import(\"../style/Style.js\").StyleFunction} Styles.\n */\nfunction getDefaultStyleFunction() {\n  const styles = createEditingStyle();\n  return function (feature, resolution) {\n    return styles[feature.getGeometry().getType()];\n  };\n}\n\n/**\n * Create a `geometryFunction` for `type: 'Circle'` that will create a regular\n * polygon with a user specified number of sides and start angle instead of a\n * {@link import(\"../geom/Circle.js\").Circle} geometry.\n * @param {number} [sides] Number of sides of the regular polygon.\n *     Default is 32.\n * @param {number} [angle] Angle of the first point in counter-clockwise\n *     radians. 0 means East.\n *     Default is the angle defined by the heading from the center of the\n *     regular polygon to the current pointer position.\n * @return {GeometryFunction} Function that draws a polygon.\n * @api\n */\nexport function createRegularPolygon(sides, angle) {\n  return function (coordinates, geometry, projection) {\n    const center = fromUserCoordinate(\n      /** @type {LineCoordType} */ (coordinates)[0],\n      projection\n    );\n    const end = fromUserCoordinate(\n      /** @type {LineCoordType} */ (coordinates)[coordinates.length - 1],\n      projection\n    );\n    const radius = Math.sqrt(squaredCoordinateDistance(center, end));\n    geometry = geometry || fromCircle(new Circle(center), sides);\n\n    let internalAngle = angle;\n    if (!angle && angle !== 0) {\n      const x = end[0] - center[0];\n      const y = end[1] - center[1];\n      internalAngle = Math.atan2(y, x);\n    }\n    makeRegular(\n      /** @type {Polygon} */ (geometry),\n      center,\n      radius,\n      internalAngle\n    );\n\n    const userProjection = getUserProjection();\n    if (userProjection) {\n      geometry.transform(projection, userProjection);\n    }\n    return geometry;\n  };\n}\n\n/**\n * Create a `geometryFunction` that will create a box-shaped polygon (aligned\n * with the coordinate system axes).  Use this with the draw interaction and\n * `type: 'Circle'` to return a box instead of a circle geometry.\n * @return {GeometryFunction} Function that draws a box-shaped polygon.\n * @api\n */\nexport function createBox() {\n  return function (coordinates, geometry, projection) {\n    const extent = boundingExtent(\n      /** @type {LineCoordType} */ ([\n        coordinates[0],\n        coordinates[coordinates.length - 1],\n      ]).map(function (coordinate) {\n        return fromUserCoordinate(coordinate, projection);\n      })\n    );\n    const boxCoordinates = [\n      [\n        getBottomLeft(extent),\n        getBottomRight(extent),\n        getTopRight(extent),\n        getTopLeft(extent),\n        getBottomLeft(extent),\n      ],\n    ];\n    if (geometry) {\n      geometry.setCoordinates(boxCoordinates);\n    } else {\n      geometry = new Polygon(boxCoordinates);\n    }\n    const userProjection = getUserProjection();\n    if (userProjection) {\n      geometry.transform(projection, userProjection);\n    }\n    return geometry;\n  };\n}\n\n/**\n * Get the drawing mode.  The mode for multi-part geometries is the same as for\n * their single-part cousins.\n * @param {import(\"../geom/Geometry.js\").Type} type Geometry type.\n * @return {Mode} Drawing mode.\n */\nfunction getMode(type) {\n  switch (type) {\n    case 'Point':\n    case 'MultiPoint':\n      return 'Point';\n    case 'LineString':\n    case 'MultiLineString':\n      return 'LineString';\n    case 'Polygon':\n    case 'MultiPolygon':\n      return 'Polygon';\n    case 'Circle':\n      return 'Circle';\n    default:\n      throw new Error('Invalid type: ' + type);\n  }\n}\n\nexport default Draw;\n","/**\n * @module ol/interaction/Extent\n */\nimport Event from '../events/Event.js';\nimport Feature from '../Feature.js';\nimport MapBrowserEventType from '../MapBrowserEventType.js';\nimport Point from '../geom/Point.js';\nimport PointerInteraction from './Pointer.js';\nimport VectorLayer from '../layer/Vector.js';\nimport VectorSource from '../source/Vector.js';\nimport {always} from '../events/condition.js';\nimport {boundingExtent, getArea} from '../extent.js';\nimport {\n  closestOnSegment,\n  distance as coordinateDistance,\n  squaredDistance as squaredCoordinateDistance,\n  squaredDistanceToSegment,\n} from '../coordinate.js';\nimport {createEditingStyle} from '../style/Style.js';\nimport {fromExtent as polygonFromExtent} from '../geom/Polygon.js';\nimport {toUserExtent} from '../proj.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * Default is {@link module:ol/events/condition.always}.\n * @property {import(\"../extent.js\").Extent} [extent] Initial extent. Defaults to no\n * initial extent.\n * @property {import(\"../style/Style.js\").StyleLike} [boxStyle]\n * Style for the drawn extent box. Defaults to the `Polygon` editing style\n * documented in {@link module:ol/style/Style~Style}\n * @property {number} [pixelTolerance=10] Pixel tolerance for considering the\n * pointer close enough to a segment or vertex for editing.\n * @property {import(\"../style/Style.js\").StyleLike} [pointerStyle]\n * Style for the cursor used to draw the extent. Defaults to the `Point` editing style\n * documented in {@link module:ol/style/Style~Style}\n * @property {boolean} [wrapX=false] Wrap the drawn extent across multiple maps\n * in the X direction? Only affects visuals, not functionality.\n */\n\n/**\n * @enum {string}\n */\nconst ExtentEventType = {\n  /**\n   * Triggered after the extent is changed\n   * @event ExtentEvent#extentchanged\n   * @api\n   */\n  EXTENTCHANGED: 'extentchanged',\n};\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/Extent~Extent} instances are\n * instances of this type.\n */\nexport class ExtentEvent extends Event {\n  /**\n   * @param {import(\"../extent.js\").Extent} extent the new extent\n   */\n  constructor(extent) {\n    super(ExtentEventType.EXTENTCHANGED);\n\n    /**\n     * The current extent.\n     * @type {import(\"../extent.js\").Extent}\n     * @api\n     */\n    this.extent = extent;\n  }\n}\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'extentchanged', ExtentEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'extentchanged', Return>} ExtentOnSignature\n */\n\n/**\n * @classdesc\n * Allows the user to draw a vector box by clicking and dragging on the map.\n * Once drawn, the vector box can be modified by dragging its vertices or edges.\n * This interaction is only supported for mouse devices.\n *\n * @fires ExtentEvent\n * @api\n */\nclass Extent extends PointerInteraction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options || {};\n\n    super(/** @type {import(\"./Pointer.js\").Options} */ (options));\n\n    /***\n     * @type {ExtentOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {ExtentOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {ExtentOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * Condition\n     * @type {import(\"../events/condition.js\").Condition}\n     * @private\n     */\n    this.condition_ = options.condition ? options.condition : always;\n\n    /**\n     * Extent of the drawn box\n     * @type {import(\"../extent.js\").Extent}\n     * @private\n     */\n    this.extent_ = null;\n\n    /**\n     * Handler for pointer move events\n     * @type {function (import(\"../coordinate.js\").Coordinate): import(\"../extent.js\").Extent|null}\n     * @private\n     */\n    this.pointerHandler_ = null;\n\n    /**\n     * Pixel threshold to snap to extent\n     * @type {number}\n     * @private\n     */\n    this.pixelTolerance_ =\n      options.pixelTolerance !== undefined ? options.pixelTolerance : 10;\n\n    /**\n     * Is the pointer snapped to an extent vertex\n     * @type {boolean}\n     * @private\n     */\n    this.snappedToVertex_ = false;\n\n    /**\n     * Feature for displaying the visible extent\n     * @type {Feature}\n     * @private\n     */\n    this.extentFeature_ = null;\n\n    /**\n     * Feature for displaying the visible pointer\n     * @type {Feature<Point>}\n     * @private\n     */\n    this.vertexFeature_ = null;\n\n    if (!options) {\n      options = {};\n    }\n\n    /**\n     * Layer for the extentFeature\n     * @type {VectorLayer}\n     * @private\n     */\n    this.extentOverlay_ = new VectorLayer({\n      source: new VectorSource({\n        useSpatialIndex: false,\n        wrapX: !!options.wrapX,\n      }),\n      style: options.boxStyle\n        ? options.boxStyle\n        : getDefaultExtentStyleFunction(),\n      updateWhileAnimating: true,\n      updateWhileInteracting: true,\n    });\n\n    /**\n     * Layer for the vertexFeature\n     * @type {VectorLayer}\n     * @private\n     */\n    this.vertexOverlay_ = new VectorLayer({\n      source: new VectorSource({\n        useSpatialIndex: false,\n        wrapX: !!options.wrapX,\n      }),\n      style: options.pointerStyle\n        ? options.pointerStyle\n        : getDefaultPointerStyleFunction(),\n      updateWhileAnimating: true,\n      updateWhileInteracting: true,\n    });\n\n    if (options.extent) {\n      this.setExtent(options.extent);\n    }\n  }\n\n  /**\n   * @param {import(\"../pixel.js\").Pixel} pixel cursor location\n   * @param {import(\"../Map.js\").default} map map\n   * @return {import(\"../coordinate.js\").Coordinate|null} snapped vertex on extent\n   * @private\n   */\n  snapToVertex_(pixel, map) {\n    const pixelCoordinate = map.getCoordinateFromPixelInternal(pixel);\n    const sortByDistance = function (a, b) {\n      return (\n        squaredDistanceToSegment(pixelCoordinate, a) -\n        squaredDistanceToSegment(pixelCoordinate, b)\n      );\n    };\n    const extent = this.getExtentInternal();\n    if (extent) {\n      //convert extents to line segments and find the segment closest to pixelCoordinate\n      const segments = getSegments(extent);\n      segments.sort(sortByDistance);\n      const closestSegment = segments[0];\n\n      let vertex = closestOnSegment(pixelCoordinate, closestSegment);\n      const vertexPixel = map.getPixelFromCoordinateInternal(vertex);\n\n      //if the distance is within tolerance, snap to the segment\n      if (coordinateDistance(pixel, vertexPixel) <= this.pixelTolerance_) {\n        //test if we should further snap to a vertex\n        const pixel1 = map.getPixelFromCoordinateInternal(closestSegment[0]);\n        const pixel2 = map.getPixelFromCoordinateInternal(closestSegment[1]);\n        const squaredDist1 = squaredCoordinateDistance(vertexPixel, pixel1);\n        const squaredDist2 = squaredCoordinateDistance(vertexPixel, pixel2);\n        const dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));\n        this.snappedToVertex_ = dist <= this.pixelTolerance_;\n        if (this.snappedToVertex_) {\n          vertex =\n            squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];\n        }\n        return vertex;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent pointer move event\n   * @private\n   */\n  handlePointerMove_(mapBrowserEvent) {\n    const pixel = mapBrowserEvent.pixel;\n    const map = mapBrowserEvent.map;\n\n    let vertex = this.snapToVertex_(pixel, map);\n    if (!vertex) {\n      vertex = map.getCoordinateFromPixelInternal(pixel);\n    }\n    this.createOrUpdatePointerFeature_(vertex);\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent extent\n   * @return {Feature} extent as featrue\n   * @private\n   */\n  createOrUpdateExtentFeature_(extent) {\n    let extentFeature = this.extentFeature_;\n\n    if (!extentFeature) {\n      if (!extent) {\n        extentFeature = new Feature({});\n      } else {\n        extentFeature = new Feature(polygonFromExtent(extent));\n      }\n      this.extentFeature_ = extentFeature;\n      this.extentOverlay_.getSource().addFeature(extentFeature);\n    } else {\n      if (!extent) {\n        extentFeature.setGeometry(undefined);\n      } else {\n        extentFeature.setGeometry(polygonFromExtent(extent));\n      }\n    }\n    return extentFeature;\n  }\n\n  /**\n   * @param {import(\"../coordinate.js\").Coordinate} vertex location of feature\n   * @return {Feature} vertex as feature\n   * @private\n   */\n  createOrUpdatePointerFeature_(vertex) {\n    let vertexFeature = this.vertexFeature_;\n    if (!vertexFeature) {\n      vertexFeature = new Feature(new Point(vertex));\n      this.vertexFeature_ = vertexFeature;\n      this.vertexOverlay_.getSource().addFeature(vertexFeature);\n    } else {\n      const geometry = vertexFeature.getGeometry();\n      geometry.setCoordinates(vertex);\n    }\n    return vertexFeature;\n  }\n\n  /**\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   */\n  handleEvent(mapBrowserEvent) {\n    if (!mapBrowserEvent.originalEvent || !this.condition_(mapBrowserEvent)) {\n      return true;\n    }\n    //display pointer (if not dragging)\n    if (\n      mapBrowserEvent.type == MapBrowserEventType.POINTERMOVE &&\n      !this.handlingDownUpSequence\n    ) {\n      this.handlePointerMove_(mapBrowserEvent);\n    }\n    //call pointer to determine up/down/drag\n    super.handleEvent(mapBrowserEvent);\n    //return false to stop propagation\n    return false;\n  }\n\n  /**\n   * Handle pointer down events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleDownEvent(mapBrowserEvent) {\n    const pixel = mapBrowserEvent.pixel;\n    const map = mapBrowserEvent.map;\n\n    const extent = this.getExtentInternal();\n    let vertex = this.snapToVertex_(pixel, map);\n\n    //find the extent corner opposite the passed corner\n    const getOpposingPoint = function (point) {\n      let x_ = null;\n      let y_ = null;\n      if (point[0] == extent[0]) {\n        x_ = extent[2];\n      } else if (point[0] == extent[2]) {\n        x_ = extent[0];\n      }\n      if (point[1] == extent[1]) {\n        y_ = extent[3];\n      } else if (point[1] == extent[3]) {\n        y_ = extent[1];\n      }\n      if (x_ !== null && y_ !== null) {\n        return [x_, y_];\n      }\n      return null;\n    };\n    if (vertex && extent) {\n      const x =\n        vertex[0] == extent[0] || vertex[0] == extent[2] ? vertex[0] : null;\n      const y =\n        vertex[1] == extent[1] || vertex[1] == extent[3] ? vertex[1] : null;\n\n      //snap to point\n      if (x !== null && y !== null) {\n        this.pointerHandler_ = getPointHandler(getOpposingPoint(vertex));\n        //snap to edge\n      } else if (x !== null) {\n        this.pointerHandler_ = getEdgeHandler(\n          getOpposingPoint([x, extent[1]]),\n          getOpposingPoint([x, extent[3]])\n        );\n      } else if (y !== null) {\n        this.pointerHandler_ = getEdgeHandler(\n          getOpposingPoint([extent[0], y]),\n          getOpposingPoint([extent[2], y])\n        );\n      }\n      //no snap - new bbox\n    } else {\n      vertex = map.getCoordinateFromPixelInternal(pixel);\n      this.setExtent([vertex[0], vertex[1], vertex[0], vertex[1]]);\n      this.pointerHandler_ = getPointHandler(vertex);\n    }\n    return true; //event handled; start downup sequence\n  }\n\n  /**\n   * Handle pointer drag events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   */\n  handleDragEvent(mapBrowserEvent) {\n    if (this.pointerHandler_) {\n      const pixelCoordinate = mapBrowserEvent.coordinate;\n      this.setExtent(this.pointerHandler_(pixelCoordinate));\n      this.createOrUpdatePointerFeature_(pixelCoordinate);\n    }\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleUpEvent(mapBrowserEvent) {\n    this.pointerHandler_ = null;\n    //If bbox is zero area, set to null;\n    const extent = this.getExtentInternal();\n    if (!extent || getArea(extent) === 0) {\n      this.setExtent(null);\n    }\n    return false; //Stop handling downup sequence\n  }\n\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../Map.js\").default} map Map.\n   */\n  setMap(map) {\n    this.extentOverlay_.setMap(map);\n    this.vertexOverlay_.setMap(map);\n    super.setMap(map);\n  }\n\n  /**\n   * Returns the current drawn extent in the view projection (or user projection if set)\n   *\n   * @return {import(\"../extent.js\").Extent} Drawn extent in the view projection.\n   * @api\n   */\n  getExtent() {\n    return toUserExtent(\n      this.getExtentInternal(),\n      this.getMap().getView().getProjection()\n    );\n  }\n\n  /**\n   * Returns the current drawn extent in the view projection\n   *\n   * @return {import(\"../extent.js\").Extent} Drawn extent in the view projection.\n   * @api\n   */\n  getExtentInternal() {\n    return this.extent_;\n  }\n\n  /**\n   * Manually sets the drawn extent, using the view projection.\n   *\n   * @param {import(\"../extent.js\").Extent} extent Extent\n   * @api\n   */\n  setExtent(extent) {\n    //Null extent means no bbox\n    this.extent_ = extent ? extent : null;\n    this.createOrUpdateExtentFeature_(extent);\n    this.dispatchEvent(new ExtentEvent(this.extent_));\n  }\n}\n\n/**\n * Returns the default style for the drawn bbox\n *\n * @return {import(\"../style/Style.js\").StyleFunction} Default Extent style\n */\nfunction getDefaultExtentStyleFunction() {\n  const style = createEditingStyle();\n  return function (feature, resolution) {\n    return style['Polygon'];\n  };\n}\n\n/**\n * Returns the default style for the pointer\n *\n * @return {import(\"../style/Style.js\").StyleFunction} Default pointer style\n */\nfunction getDefaultPointerStyleFunction() {\n  const style = createEditingStyle();\n  return function (feature, resolution) {\n    return style['Point'];\n  };\n}\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} fixedPoint corner that will be unchanged in the new extent\n * @return {function (import(\"../coordinate.js\").Coordinate): import(\"../extent.js\").Extent} event handler\n */\nfunction getPointHandler(fixedPoint) {\n  return function (point) {\n    return boundingExtent([fixedPoint, point]);\n  };\n}\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} fixedP1 first corner that will be unchanged in the new extent\n * @param {import(\"../coordinate.js\").Coordinate} fixedP2 second corner that will be unchanged in the new extent\n * @return {function (import(\"../coordinate.js\").Coordinate): import(\"../extent.js\").Extent|null} event handler\n */\nfunction getEdgeHandler(fixedP1, fixedP2) {\n  if (fixedP1[0] == fixedP2[0]) {\n    return function (point) {\n      return boundingExtent([fixedP1, [point[0], fixedP2[1]]]);\n    };\n  } else if (fixedP1[1] == fixedP2[1]) {\n    return function (point) {\n      return boundingExtent([fixedP1, [fixedP2[0], point[1]]]);\n    };\n  }\n  return null;\n}\n\n/**\n * @param {import(\"../extent.js\").Extent} extent extent\n * @return {Array<Array<import(\"../coordinate.js\").Coordinate>>} extent line segments\n */\nfunction getSegments(extent) {\n  return [\n    [\n      [extent[0], extent[1]],\n      [extent[0], extent[3]],\n    ],\n    [\n      [extent[0], extent[3]],\n      [extent[2], extent[3]],\n    ],\n    [\n      [extent[2], extent[3]],\n      [extent[2], extent[1]],\n    ],\n    [\n      [extent[2], extent[1]],\n      [extent[0], extent[1]],\n    ],\n  ];\n}\n\nexport default Extent;\n","/**\n * @module ol/interaction/Snap\n */\nimport CollectionEventType from '../CollectionEventType.js';\nimport EventType from '../events/EventType.js';\nimport PointerInteraction from './Pointer.js';\nimport RBush from '../structs/RBush.js';\nimport VectorEventType from '../source/VectorEventType.js';\nimport {FALSE, TRUE} from '../functions.js';\nimport {boundingExtent, buffer, createEmpty} from '../extent.js';\nimport {\n  closestOnCircle,\n  closestOnSegment,\n  squaredDistance,\n} from '../coordinate.js';\nimport {fromCircle} from '../geom/Polygon.js';\nimport {\n  fromUserCoordinate,\n  getUserProjection,\n  toUserCoordinate,\n  toUserExtent,\n} from '../proj.js';\nimport {getUid} from '../util.js';\nimport {listen, unlistenByKey} from '../events.js';\n\n/**\n * @typedef {Object} Result\n * @property {import(\"../coordinate.js\").Coordinate|null} vertex Vertex.\n * @property {import(\"../pixel.js\").Pixel|null} vertexPixel VertexPixel.\n */\n\n/**\n * @typedef {Object} SegmentData\n * @property {import(\"../Feature.js\").default} feature Feature.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} segment Segment.\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../Collection.js\").default<import(\"../Feature.js\").default>} [features] Snap to these features. Either this option or source should be provided.\n * @property {boolean} [edge=true] Snap to edges.\n * @property {boolean} [vertex=true] Snap to vertices.\n * @property {number} [pixelTolerance=10] Pixel tolerance for considering the pointer close enough to a segment or\n * vertex for snapping.\n * @property {import(\"../source/Vector.js\").default} [source] Snap to features from this source. Either this option or features should be provided\n */\n\n/**\n * @param  {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} evt Event.\n * @return {import(\"../Feature.js\").default} Feature.\n */\nfunction getFeatureFromEvent(evt) {\n  if (\n    /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */ (evt).feature\n  ) {\n    return /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */ (evt)\n      .feature;\n  } else if (\n    /** @type {import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} */ (\n      evt\n    ).element\n  ) {\n    return /** @type {import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} */ (\n      evt\n    ).element;\n  }\n}\n\nconst tempSegment = [];\n\n/**\n * @classdesc\n * Handles snapping of vector features while modifying or drawing them.  The\n * features can come from a {@link module:ol/source/Vector~VectorSource} or {@link module:ol/Collection~Collection}\n * Any interaction object that allows the user to interact\n * with the features using the mouse can benefit from the snapping, as long\n * as it is added before.\n *\n * The snap interaction modifies map browser event `coordinate` and `pixel`\n * properties to force the snap to occur to any interaction that them.\n *\n * Example:\n *\n *     import Snap from 'ol/interaction/Snap.js';\n *\n *     const snap = new Snap({\n *       source: source\n *     });\n *\n *     map.addInteraction(snap);\n *\n * @api\n */\nclass Snap extends PointerInteraction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const pointerOptions = /** @type {import(\"./Pointer.js\").Options} */ (\n      options\n    );\n\n    if (!pointerOptions.handleDownEvent) {\n      pointerOptions.handleDownEvent = TRUE;\n    }\n\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n\n    super(pointerOptions);\n\n    /**\n     * @type {import(\"../source/Vector.js\").default|null}\n     * @private\n     */\n    this.source_ = options.source ? options.source : null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.vertex_ = options.vertex !== undefined ? options.vertex : true;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.edge_ = options.edge !== undefined ? options.edge : true;\n\n    /**\n     * @type {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|null}\n     * @private\n     */\n    this.features_ = options.features ? options.features : null;\n\n    /**\n     * @type {Array<import(\"../events.js\").EventsKey>}\n     * @private\n     */\n    this.featuresListenerKeys_ = [];\n\n    /**\n     * @type {Object<string, import(\"../events.js\").EventsKey>}\n     * @private\n     */\n    this.featureChangeListenerKeys_ = {};\n\n    /**\n     * Extents are preserved so indexed segment can be quickly removed\n     * when its feature geometry changes\n     * @type {Object<string, import(\"../extent.js\").Extent>}\n     * @private\n     */\n    this.indexedFeaturesExtents_ = {};\n\n    /**\n     * If a feature geometry changes while a pointer drag|move event occurs, the\n     * feature doesn't get updated right away.  It will be at the next 'pointerup'\n     * event fired.\n     * @type {!Object<string, import(\"../Feature.js\").default>}\n     * @private\n     */\n    this.pendingFeatures_ = {};\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.pixelTolerance_ =\n      options.pixelTolerance !== undefined ? options.pixelTolerance : 10;\n\n    /**\n     * Segment RTree for each layer\n     * @type {import(\"../structs/RBush.js\").default<SegmentData>}\n     * @private\n     */\n    this.rBush_ = new RBush();\n\n    /**\n     * @const\n     * @private\n     * @type {Object<string, function(Array<Array<import('../coordinate.js').Coordinate>>, import(\"../geom/Geometry.js\").default): void>}\n     */\n    this.GEOMETRY_SEGMENTERS_ = {\n      'Point': this.segmentPointGeometry_.bind(this),\n      'LineString': this.segmentLineStringGeometry_.bind(this),\n      'LinearRing': this.segmentLineStringGeometry_.bind(this),\n      'Polygon': this.segmentPolygonGeometry_.bind(this),\n      'MultiPoint': this.segmentMultiPointGeometry_.bind(this),\n      'MultiLineString': this.segmentMultiLineStringGeometry_.bind(this),\n      'MultiPolygon': this.segmentMultiPolygonGeometry_.bind(this),\n      'GeometryCollection': this.segmentGeometryCollectionGeometry_.bind(this),\n      'Circle': this.segmentCircleGeometry_.bind(this),\n    };\n  }\n\n  /**\n   * Add a feature to the collection of features that we may snap to.\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {boolean} [register] Whether to listen to the feature change or not\n   *     Defaults to `true`.\n   * @api\n   */\n  addFeature(feature, register) {\n    register = register !== undefined ? register : true;\n    const feature_uid = getUid(feature);\n    const geometry = feature.getGeometry();\n    if (geometry) {\n      const segmenter = this.GEOMETRY_SEGMENTERS_[geometry.getType()];\n      if (segmenter) {\n        this.indexedFeaturesExtents_[feature_uid] = geometry.getExtent(\n          createEmpty()\n        );\n        const segments =\n          /** @type {Array<Array<import('../coordinate.js').Coordinate>>} */ ([]);\n        segmenter(segments, geometry);\n        if (segments.length === 1) {\n          this.rBush_.insert(boundingExtent(segments[0]), {\n            feature: feature,\n            segment: segments[0],\n          });\n        } else if (segments.length > 1) {\n          const extents = segments.map((s) => boundingExtent(s));\n          const segmentsData = segments.map((segment) => ({\n            feature: feature,\n            segment: segment,\n          }));\n          this.rBush_.load(extents, segmentsData);\n        }\n      }\n    }\n\n    if (register) {\n      this.featureChangeListenerKeys_[feature_uid] = listen(\n        feature,\n        EventType.CHANGE,\n        this.handleFeatureChange_,\n        this\n      );\n    }\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @private\n   */\n  forEachFeatureAdd_(feature) {\n    this.addFeature(feature);\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @private\n   */\n  forEachFeatureRemove_(feature) {\n    this.removeFeature(feature);\n  }\n\n  /**\n   * @return {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|Array<import(\"../Feature.js\").default>} Features.\n   * @private\n   */\n  getFeatures_() {\n    /** @type {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|Array<import(\"../Feature.js\").default>} */\n    let features;\n    if (this.features_) {\n      features = this.features_;\n    } else if (this.source_) {\n      features = this.source_.getFeatures();\n    }\n    return features;\n  }\n\n  /**\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   */\n  handleEvent(evt) {\n    const result = this.snapTo(evt.pixel, evt.coordinate, evt.map);\n    if (result) {\n      evt.coordinate = result.vertex.slice(0, 2);\n      evt.pixel = result.vertexPixel;\n    }\n    return super.handleEvent(evt);\n  }\n\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} evt Event.\n   * @private\n   */\n  handleFeatureAdd_(evt) {\n    const feature = getFeatureFromEvent(evt);\n    this.addFeature(feature);\n  }\n\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} evt Event.\n   * @private\n   */\n  handleFeatureRemove_(evt) {\n    const feature = getFeatureFromEvent(evt);\n    this.removeFeature(feature);\n  }\n\n  /**\n   * @param {import(\"../events/Event.js\").default} evt Event.\n   * @private\n   */\n  handleFeatureChange_(evt) {\n    const feature = /** @type {import(\"../Feature.js\").default} */ (evt.target);\n    if (this.handlingDownUpSequence) {\n      const uid = getUid(feature);\n      if (!(uid in this.pendingFeatures_)) {\n        this.pendingFeatures_[uid] = feature;\n      }\n    } else {\n      this.updateFeature_(feature);\n    }\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleUpEvent(evt) {\n    const featuresToUpdate = Object.values(this.pendingFeatures_);\n    if (featuresToUpdate.length) {\n      featuresToUpdate.forEach(this.updateFeature_.bind(this));\n      this.pendingFeatures_ = {};\n    }\n    return false;\n  }\n\n  /**\n   * Remove a feature from the collection of features that we may snap to.\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {boolean} [unlisten] Whether to unlisten to the feature change\n   *     or not. Defaults to `true`.\n   * @api\n   */\n  removeFeature(feature, unlisten) {\n    const unregister = unlisten !== undefined ? unlisten : true;\n    const feature_uid = getUid(feature);\n    const extent = this.indexedFeaturesExtents_[feature_uid];\n    if (extent) {\n      const rBush = this.rBush_;\n      const nodesToRemove = [];\n      rBush.forEachInExtent(extent, function (node) {\n        if (feature === node.feature) {\n          nodesToRemove.push(node);\n        }\n      });\n      for (let i = nodesToRemove.length - 1; i >= 0; --i) {\n        rBush.remove(nodesToRemove[i]);\n      }\n    }\n\n    if (unregister) {\n      unlistenByKey(this.featureChangeListenerKeys_[feature_uid]);\n      delete this.featureChangeListenerKeys_[feature_uid];\n    }\n  }\n\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../Map.js\").default} map Map.\n   */\n  setMap(map) {\n    const currentMap = this.getMap();\n    const keys = this.featuresListenerKeys_;\n    const features = /** @type {Array<import(\"../Feature.js\").default>} */ (\n      this.getFeatures_()\n    );\n\n    if (currentMap) {\n      keys.forEach(unlistenByKey);\n      keys.length = 0;\n      features.forEach(this.forEachFeatureRemove_.bind(this));\n    }\n    super.setMap(map);\n\n    if (map) {\n      if (this.features_) {\n        keys.push(\n          listen(\n            this.features_,\n            CollectionEventType.ADD,\n            this.handleFeatureAdd_,\n            this\n          ),\n          listen(\n            this.features_,\n            CollectionEventType.REMOVE,\n            this.handleFeatureRemove_,\n            this\n          )\n        );\n      } else if (this.source_) {\n        keys.push(\n          listen(\n            this.source_,\n            VectorEventType.ADDFEATURE,\n            this.handleFeatureAdd_,\n            this\n          ),\n          listen(\n            this.source_,\n            VectorEventType.REMOVEFEATURE,\n            this.handleFeatureRemove_,\n            this\n          )\n        );\n      }\n      features.forEach(this.forEachFeatureAdd_.bind(this));\n    }\n  }\n\n  /**\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel\n   * @param {import(\"../coordinate.js\").Coordinate} pixelCoordinate Coordinate\n   * @param {import(\"../Map.js\").default} map Map.\n   * @return {Result|null} Snap result\n   */\n  snapTo(pixel, pixelCoordinate, map) {\n    const projection = map.getView().getProjection();\n    const projectedCoordinate = fromUserCoordinate(pixelCoordinate, projection);\n\n    const box = toUserExtent(\n      buffer(\n        boundingExtent([projectedCoordinate]),\n        map.getView().getResolution() * this.pixelTolerance_\n      ),\n      projection\n    );\n\n    const segments = this.rBush_.getInExtent(box);\n\n    const segmentsLength = segments.length;\n    if (segmentsLength === 0) {\n      return null;\n    }\n\n    let closestVertex;\n    let minSquaredDistance = Infinity;\n\n    const squaredPixelTolerance = this.pixelTolerance_ * this.pixelTolerance_;\n    const getResult = () => {\n      if (closestVertex) {\n        const vertexPixel = map.getPixelFromCoordinate(closestVertex);\n        const squaredPixelDistance = squaredDistance(pixel, vertexPixel);\n        if (squaredPixelDistance <= squaredPixelTolerance) {\n          return {\n            vertex: closestVertex,\n            vertexPixel: [\n              Math.round(vertexPixel[0]),\n              Math.round(vertexPixel[1]),\n            ],\n          };\n        }\n      }\n      return null;\n    };\n\n    if (this.vertex_) {\n      for (let i = 0; i < segmentsLength; ++i) {\n        const segmentData = segments[i];\n        if (segmentData.feature.getGeometry().getType() !== 'Circle') {\n          segmentData.segment.forEach((vertex) => {\n            const tempVertexCoord = fromUserCoordinate(vertex, projection);\n            const delta = squaredDistance(projectedCoordinate, tempVertexCoord);\n            if (delta < minSquaredDistance) {\n              closestVertex = vertex;\n              minSquaredDistance = delta;\n            }\n          });\n        }\n      }\n      const result = getResult();\n      if (result) {\n        return result;\n      }\n    }\n\n    if (this.edge_) {\n      for (let i = 0; i < segmentsLength; ++i) {\n        let vertex = null;\n        const segmentData = segments[i];\n        if (segmentData.feature.getGeometry().getType() === 'Circle') {\n          let circleGeometry = segmentData.feature.getGeometry();\n          const userProjection = getUserProjection();\n          if (userProjection) {\n            circleGeometry = circleGeometry\n              .clone()\n              .transform(userProjection, projection);\n          }\n          vertex = closestOnCircle(\n            projectedCoordinate,\n            /** @type {import(\"../geom/Circle.js\").default} */ (circleGeometry)\n          );\n        } else {\n          const [segmentStart, segmentEnd] = segmentData.segment;\n          // points have only one coordinate\n          if (segmentEnd) {\n            tempSegment[0] = fromUserCoordinate(segmentStart, projection);\n            tempSegment[1] = fromUserCoordinate(segmentEnd, projection);\n            vertex = closestOnSegment(projectedCoordinate, tempSegment);\n          }\n        }\n        if (vertex) {\n          const delta = squaredDistance(projectedCoordinate, vertex);\n          if (delta < minSquaredDistance) {\n            closestVertex = toUserCoordinate(vertex, projection);\n            minSquaredDistance = delta;\n          }\n        }\n      }\n\n      const result = getResult();\n      if (result) {\n        return result;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @private\n   */\n  updateFeature_(feature) {\n    this.removeFeature(feature, false);\n    this.addFeature(feature, false);\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/Circle.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentCircleGeometry_(segments, geometry) {\n    const projection = this.getMap().getView().getProjection();\n    let circleGeometry = geometry;\n    const userProjection = getUserProjection();\n    if (userProjection) {\n      circleGeometry = /** @type {import(\"../geom/Circle.js\").default} */ (\n        circleGeometry.clone().transform(userProjection, projection)\n      );\n    }\n    const polygon = fromCircle(circleGeometry);\n    if (userProjection) {\n      polygon.transform(projection, userProjection);\n    }\n    const coordinates = polygon.getCoordinates()[0];\n    for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      segments.push(coordinates.slice(i, i + 2));\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentGeometryCollectionGeometry_(segments, geometry) {\n    const geometries = geometry.getGeometriesArray();\n    for (let i = 0; i < geometries.length; ++i) {\n      const segmenter = this.GEOMETRY_SEGMENTERS_[geometries[i].getType()];\n      if (segmenter) {\n        segmenter(segments, geometries[i]);\n      }\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/LineString.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentLineStringGeometry_(segments, geometry) {\n    const coordinates = geometry.getCoordinates();\n    for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      segments.push(coordinates.slice(i, i + 2));\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/MultiLineString.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentMultiLineStringGeometry_(segments, geometry) {\n    const lines = geometry.getCoordinates();\n    for (let j = 0, jj = lines.length; j < jj; ++j) {\n      const coordinates = lines[j];\n      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        segments.push(coordinates.slice(i, i + 2));\n      }\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/MultiPoint.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentMultiPointGeometry_(segments, geometry) {\n    geometry.getCoordinates().forEach((point) => {\n      segments.push([point]);\n    });\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentMultiPolygonGeometry_(segments, geometry) {\n    const polygons = geometry.getCoordinates();\n    for (let k = 0, kk = polygons.length; k < kk; ++k) {\n      const rings = polygons[k];\n      for (let j = 0, jj = rings.length; j < jj; ++j) {\n        const coordinates = rings[j];\n        for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n          segments.push(coordinates.slice(i, i + 2));\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/Point.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentPointGeometry_(segments, geometry) {\n    segments.push([geometry.getCoordinates()]);\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/Polygon.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentPolygonGeometry_(segments, geometry) {\n    const rings = geometry.getCoordinates();\n    for (let j = 0, jj = rings.length; j < jj; ++j) {\n      const coordinates = rings[j];\n      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        segments.push(coordinates.slice(i, i + 2));\n      }\n    }\n  }\n}\n\nexport default Snap;\n"],"names":["ol_control_TextButton","constructor","options","className","super","ol_control_Toggle","toggleFn","onToggle","handleClick","self","toggle","call","getActive","this","interaction_","interaction","setActive","active","on","set","title","autoActivate","bar","setSubBar","setDisable","disable","setMap","map","getMap","removeInteraction","subbar_","removeControl","addInteraction","addControl","getSubBar","setTarget","element","classList","add","getDisable","button","querySelector","disabled","b","dispatchEvent","type","key","oldValue","contains","remove","setInteraction","i","getInteraction","ol_extent_intersection","ol_coordinate_dist2d","p1","p2","dx","dy","Math","sqrt","ol_coordinate_equal","ol_coordinate_offsetCoords","coords","offset","mi","mi1","li","li1","ri","ri1","si","si1","Xi1","Yi1","p0","path","N","length","max","isClosed","push","abs","pop","ol_coordinate_findSegment","pt","index","segment","d0","v0","d1","v1","splitX","pts","x","splice","splitY","y","extent","polygon","poly","getType","geom","getCoordinates","forEach","g","c","p","ol_coordinate_sampleAt","d","start","dl","nb","round","line","result","concat","lines","l","res","mpoly","a","resolution","sampleAt","ext","getCenter","getRadius","simplify","r","hasout","ring","console","warn","tol","k","splitAt","getFirstCoordinate","getLastCoordinate","c0","ci","d2","split","ol_interaction_Delete","e","getFeatures","clear","delete","selected","bind","_getSources","layers","getLayers","sources","getSource","features","getLength","delFeatures","source","f","removeFeature","ol_interaction_DrawHole","_geometryFn","coordinates","geometry","coord","getPolygon","intersectsCoordinate","lastOKCoord","setCoordinates","geomFn","geometryFunction","_select","style","layers_","indexOf","_features","featureFilter","item","getArray","_startDrawing","_finishDrawing","removeLastPoint","_feature","getGeometry","_polygon","feature","_current","forEachFeatureAtPixel","getPixelFromCoordinate","layer","_polygonIndex","layerFilter","hole","pi","newGeom","appendLinearRing","appendPolygon","setGeometry","ol_interaction_DrawRegular","handleEvent","handleEvent_","squaredClickTolerance_","clickTolerance","maxCircleCoordinates_","maxCircleCoordinates","features_","source_","conditionFn_","condition","squareFn_","squareCondition","centeredFn_","centerCondition","canRotate_","canRotate","geometryName_","geometryName","setSides","sides","defaultStyle","sketch_","overlayLayer_","useSpatialIndex","name","displayInLayerSwitcher","removeLayer","reset","started_","parseInt","sides_","getSides","getGeom_","center_","coord_","dmax","circle","centerPx","center","square_","centered_","coordPx_","min","hasrotation","dm","atan2","startAngle","getExtent","scx","scy","sc","sign","t","applyTransform","g1","g2","dim","drawSketch_","evt","originalEvent","shiftKey","metaKey","ctrlKey","feature_","addFeature","drawPoint_","noclear","_eventTime","Date","downPx_","pixel","start_","dt","_longTouch","setTimeout","handleMoveEvent_","lastEvent","end_","upPx_","coordinate","finishDrawing","startCoordinate","square","centered","setGeometryName","prototype","PI","ol_interaction_ModifyFeature","dragging","modifying","handleDownEvent","_deleteCondition","handleUpEvent","handleDragEvent","handleMoveEvent","snapDistance_","pixelTolerance","tolerance_","cursor_","cursor","sources_","Array","filterSplit_","filter","_condition","deleteCondition","_insertVertexCondition","insertVertexCondition","sketchStyle","image","radius","fill","color","stroke","width","wrapX","setFilter","undefined","getClosestFeature","getClosestFeatureToCoordinate","getClosestPoint","di","frameState","viewState","currentFeature","deselected","getNearestCoord","dist","Number","MAX_VALUE","lstring","getLineStrings","lring","getLinearRings","getPolygons","getGeometries","getArcs","s","arcs","coord1","coord2","node","shift","c1","nbpt","closed","end","typeg","error","current","getFeaturesInExtent","_modifiedFeatures","_removePoint","getModifiedFeatures","removePoint","_getModification","geoms","found","setGeometries","setArcCoordinates","getTargetElement","previousCursor_","getCurrentFeature","ol_interaction_Offset","handleDownEvent_","handleDragEvent_","handleUpEvent_","_filter","duplicate","_style","getFeatureAtPixel_","typeGeom","test","hit","clone","geomType","hitTolerance","current_","currentStyle_","getStyle","get","setStyle","_modifystart","seg","v2","ol_interaction_Split","snapDistance","tolerance","setSources","white","blue","featureStyle","_sketch_","getSources","getVisible","unshift","fi","gi","link","tosplit","original","linkGeometry","ol_interaction_Transform","selection_","handles_","_handleEvent","addFn_","addCondition","setPointRadius","pointRadius","translateFeature","translate","translateBBox","stretch","scale","rotate","keepAspectRatio","modifyCenter","noFlip","selection","enableRotatedTransform","keepRectangle","setDefaultStyle","oldMap","targetElement","select","isTouch","getViewport","setVisible","pointStroke","strokedash","lineDash","fill0","pointFill","displacement","points","setDisplacement","getAnchor","bigpt","angle","smallpt","createStyle","img","olstyle","im","getImage","setScale","tx","getText","setOffsetX","bbox_","handle","constraint","option","some","getGeometryRotateToZero_","origGeom","viewRotation","getView","getRotation","rotGeom","_isRectangle","slice","extendExt","ptRadius","_pointRadius","ispt_","getCoordinateFromPixel","iscircle_","addFeatures","removeAt","watchFeatures_","setSelection","_featureListeners","isUpdating_","sel","mode_","opt_","constraint_","coordinate_","pixel_","geoms_","rotatedGeoms_","rotExtent","extent_","rotatedExtent_","Cursors","rotate0","angle_","setCenter","j","pt0","ispt","setCenterAndRadius","deltaX","deltaY","delta","extentCoordinates","opt","downCoordinate","dragCoordinate","downPoint","dragPoint","displacementVector","centerPoint","pointArray","pointA","pointB","pointC","pointD","pointA1","base","_countVector","projectedVector","_projectVectorOnVector","nextIndex","coordsToChange","includes","projectedLeft","projectedRight","_movePoint","default","oldgeom","oldgeoms","displacement_vector","point","opt_fast","ol_interaction_UndoRedo","_layers","_undoStack","_redoStack","_undo","_redo","level","_level","view","zoom","getZoom","action","_reduce","_doShift","_doClear","_block","_record","_defs","define","undoFn","redoFn","undo","redo","setMaxLength","size","setMaxSize","getStack","prop","custom","_mapListener","blockStart","blockEnd","_watchSources","_watchInteractions","_sourceListener","getVectorLayers","init","vectors","_onAddRemove","_interactionListener","getInteractions","_onInteraction","target","fn","_handleDo","oldGeom","newp","newProperties","oldp","oldProperties","unset","hasUndo","hasRedo","setattributestart","Object","assign","properties","rotatestart","translatestart","scalestart","modifystart","replace","m","beforesplit","deletestart","aftersplit","deleteend","ol_style_Style_defaultStyle","defaultEditStyle","edit","fillColor","Circle","layout","setFlatCoordinates","flatCoordinates","applyProperties","closestPointXY","closestPoint","minSquaredDistance","squaredDistance","stride","containsXY","getRadiusSquared_","computeExtent","intersectsExtent","circleExtent","changed","setLayout","ii","setRadius","anchor","getStride","transform","DrawEventType","DRAWSTART","DRAWEND","DRAWABORT","DrawEvent","getTraceTargets","targets","appendGeometryTraceTargets","getSquaredDistance","getCoordinate","count","getCumulativeSquaredDistance","startIndex","endIndex","lowIndex","highIndex","lowWholeIndex","ceil","highWholeIndex","floor","interpolateCoordinate","sd","appendTraceTarget","polys","jj","geometries","sharedUpdateInfo","NaN","getTraceTargetUpdate","traceState","snapTolerance","closestTargetDistance","Infinity","newTargetIndex","newEndIndex","targetIndex","minSegmentDistance","coordinateIndex","rel","getPointSegmentRelationship","along","newTarget","considerBothDirections","newCoordinate","startPx","forwardDistance","reverseDistance","sharedRel","x1","y1","x2","y2","px","py","x0","y0","Draw","pointerOptions","stopDown","once","un","shouldHandle_","downTimeout_","lastDragTime_","pointerType_","freehand_","snapTolerance_","type_","getMode","stopClick_","stopClick","minPoints_","minPoints","maxPoints_","maxPoints","finishCondition_","finishCondition","geometryLayout_","geometryLayout","mode","projection","fromUserCoordinate","squaredLength","userProjection","getUserProjection","Constructor","geometryFunction_","dragVertexDelay_","dragVertexDelay","finishCoordinate_","sketchFeature_","sketchPoint_","sketchCoords_","sketchLine_","sketchLineCoords_","overlay_","getDefaultStyleFunction","updateWhileInteracting","condition_","freehandCondition_","freehand","freehandCondition","traceCondition_","setTrace","trace","traceState_","traceSource_","traceSource","addChangeListener","updateState_","getOverlay","event","preventDefault","move","pass","now","clearTimeout","addToDrawing_","getPointerCount","handlePointerMove_","pointerType","startDrawing_","deactivateTrace_","toggleTraceState_","lowerLeft","upperRight","addOrRemoveTracedCoordinates_","previouslyForward","currentlyForward","addTracedCoordinates_","removeTracedCoordinates_","fromIndex","toIndex","removeLastPoints_","appendCoordinates","updateTrace_","updatedTraceTarget","oldTarget","tracing","startingToDraw","atFinish_","abortDrawing","downPx","clickPx","modifyDrawing_","createOrUpdateSketchPoint_","at","potentiallyDone","potentiallyFinishCoordinates","sketchCoords","finishCoordinate","finishPixel","sketchPointGeom","updateSketchFeatures_","createOrUpdateCustomSketchLine_","getLinearRing","sketchLineGeom","getLayout","getFlatCoordinates","getProjection","last","done","n","sketchFeature","abortDrawing_","newDrawing","ending","extend","lineString","sketchFeatures","overlaySource","styles","createEditingStyle","Error","ExtentEventType","EXTENTCHANGED","ExtentEvent","Extent","pointerHandler_","pixelTolerance_","snappedToVertex_","extentFeature_","vertexFeature_","extentOverlay_","boxStyle","getDefaultExtentStyleFunction","updateWhileAnimating","vertexOverlay_","pointerStyle","getDefaultPointerStyleFunction","setExtent","snapToVertex_","pixelCoordinate","getCoordinateFromPixelInternal","sortByDistance","getExtentInternal","segments","getSegments","sort","closestSegment","vertex","vertexPixel","getPixelFromCoordinateInternal","pixel1","pixel2","squaredDist1","squaredDist2","mapBrowserEvent","createOrUpdatePointerFeature_","createOrUpdateExtentFeature_","extentFeature","vertexFeature","handlingDownUpSequence","getOpposingPoint","x_","y_","getPointHandler","getEdgeHandler","toUserExtent","fixedPoint","fixedP1","fixedP2","getFeatureFromEvent","tempSegment","Snap","vertex_","edge_","edge","featuresListenerKeys_","featureChangeListenerKeys_","indexedFeaturesExtents_","pendingFeatures_","rBush_","GEOMETRY_SEGMENTERS_","segmentPointGeometry_","segmentLineStringGeometry_","segmentPolygonGeometry_","segmentMultiPointGeometry_","segmentMultiLineStringGeometry_","segmentMultiPolygonGeometry_","segmentGeometryCollectionGeometry_","segmentCircleGeometry_","register","feature_uid","segmenter","insert","extents","segmentsData","load","handleFeatureChange_","forEachFeatureAdd_","forEachFeatureRemove_","getFeatures_","snapTo","handleFeatureAdd_","handleFeatureRemove_","uid","updateFeature_","featuresToUpdate","values","unlisten","unregister","rBush","nodesToRemove","forEachInExtent","currentMap","keys","projectedCoordinate","box","getResolution","getInExtent","segmentsLength","closestVertex","squaredPixelTolerance","getResult","squaredPixelDistance","segmentData","tempVertexCoord","circleGeometry","segmentStart","segmentEnd","toUserCoordinate","getGeometriesArray","polygons","kk","rings"],"sourceRoot":""}
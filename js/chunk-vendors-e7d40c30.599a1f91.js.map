{"version":3,"file":"js/chunk-vendors-e7d40c30.599a1f91.js","mappings":"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","sources":["webpack://@openeo/web-editor/./node_modules/@openeo/js-commons/src/main.js","webpack://@openeo/web-editor/./node_modules/@openeo/js-commons/src/migrate/capabilities.js","webpack://@openeo/web-editor/./node_modules/@openeo/js-commons/src/migrate/collections.js","webpack://@openeo/web-editor/./node_modules/@openeo/js-commons/src/migrate/commons.js","webpack://@openeo/web-editor/./node_modules/@openeo/js-commons/src/migrate/processes.js","webpack://@openeo/web-editor/./node_modules/@openeo/js-commons/src/processDataType.js","webpack://@openeo/web-editor/./node_modules/@openeo/js-commons/src/processParameter.js","webpack://@openeo/web-editor/./node_modules/@openeo/js-commons/src/processRegistry.js","webpack://@openeo/web-editor/./node_modules/@openeo/js-commons/src/processSchema.js","webpack://@openeo/web-editor/./node_modules/@openeo/js-commons/src/processUtils.js","webpack://@openeo/web-editor/./node_modules/@openeo/js-commons/src/utils.js","webpack://@openeo/web-editor/./node_modules/@openeo/js-commons/src/versions.js"],"sourcesContent":["// Migrations\r\nconst MigrateCapabilities = require('./migrate/capabilities');\r\nconst MigrateCollections = require('./migrate/collections');\r\nconst MigrateProcesses = require('./migrate/processes');\r\n// Processes\r\nconst ProcessDataType = require('./processDataType');\r\nconst ProcessParameter = require('./processParameter');\r\nconst ProcessSchema = require('./processSchema');\r\nconst ProcessUtils = require('./processUtils');\r\nconst ProcessRegistry = require('./processRegistry');\r\n// Others\r\nconst Versions = require('./versions');\r\nconst Utils = require('./utils');\r\n\r\nmodule.exports = {\r\n\tMigrateCapabilities,\r\n\tMigrateCollections,\r\n\tMigrateProcesses,\r\n\tProcessDataType,\r\n\tProcessParameter,\r\n\tProcessSchema,\r\n\tProcessUtils,\r\n\tProcessRegistry,\r\n\tVersions,\r\n\tUtils,\r\n};","const Utils = require('../utils.js');\r\nconst Versions = require('../versions.js');\r\nconst MigrateCommons = require('./commons.js');\r\n\r\nconst NO_VERSION = \"0.0.0\";\r\n\r\n/** Migrate capabilities related responses to the latest version. */\r\nclass MigrateCapabilities {\r\n\r\n    /**\r\n     * Tries to determine the API version from the capabilities object.\r\n     * \r\n     * Returns the version number, e.g. \"0.4.2\", \"1.0.0\" or \"0.0.0\" (if unknown).\r\n     * \r\n     * @param {object} capabilities \r\n     * @returns {string}\r\n     */\r\n    static guessApiVersion(capabilities) {\r\n        // No object passed\r\n        if (!Utils.isObject(capabilities)) {\r\n            return NO_VERSION;\r\n        }\r\n\r\n        // Get exact info from version fields\r\n        if (Versions.validate(capabilities.api_version)) {\r\n            return capabilities.api_version;\r\n        }\r\n        else if (Versions.validate(capabilities.version)) {\r\n            return capabilities.version;\r\n        }\r\n        // Now we are really guessing\r\n        else if (Array.isArray(capabilities.endpoints)) {\r\n            if (capabilities.endpoints.find(e => e.path === '/file_formats' || e.path === '/conformance' || e.path === '/files')) {\r\n                return \"1.0.0\";\r\n            }\r\n            else if (capabilities.endpoints.find(e => e.path === '/output_formats' || e.path === '/files/{user_id}')) {\r\n                return \"0.4.2\";\r\n            }\r\n            else if (!capabilities.backend_version && !capabilities.title && !capabilities.description && !capabilities.links) {\r\n                return \"0.3.1\";\r\n            }\r\n        }\r\n\r\n        // Can't determine version\r\n        return NO_VERSION;\r\n    }\r\n\r\n    /**\r\n     * Converts a `GET /` response to the latest version.\r\n     * \r\n     * Always returns a deep copy of the input object.\r\n     * \r\n     * @param {object} response - The response to convert\r\n     * @param {string|null} version - Version number of the API, which the response conforms to. If `null`, tries to guess the version with `guessApiVersion()`.\r\n     * @param {boolean} updateVersionNumbers - Should version numbers in the response be updated?\r\n     * @param {boolean} updateEndpointPaths - Should the endpoint paths be updated to their recent equivalents?\r\n     * @param {string} id - If no id is set in the response, sets it to the value specified here. Defaults to `unknown`.\r\n     * @param {string} title - If no title is set in the response, sets it to the value specified here. Defaults to `Unknown`.\r\n     * @param {string} title - If no backend_version is set in the response, sets it to the value specified here. Defaults to `0.0.0`.\r\n     * @returns {object}\r\n     */\r\n    static convertCapabilitiesToLatestSpec(originalCapabilities, version = null, updateVersionNumbers = true, updateEndpointPaths = true, id = \"unknown\", title = \"Unknown\", backend_version = \"0.0.0\") {\r\n        if (version === null) {\r\n            version = this.guessApiVersion(originalCapabilities);\r\n        }\r\n        // Return empty if version number is not available\r\n        if (version === NO_VERSION) {\r\n            return {};\r\n        }\r\n\r\n        if (Versions.compare(version, \"0.3.x\", \"<=\")) {\r\n            throw \"Migrating from API version 0.3.0 and older is not supported.\";\r\n        }\r\n\r\n        let capabilities = Utils.deepClone(originalCapabilities);\r\n        // Fill & Update version number\r\n        if (!updateVersionNumbers) {\r\n            capabilities.api_version = version;\r\n        }\r\n        else {\r\n            capabilities.api_version = \"1.0.0\";\r\n        }\r\n\r\n        // Convert billing plans\r\n        if (Utils.isObject(capabilities.billing)) {\r\n            capabilities.billing = this.convertBillingToLatestSpec(capabilities.billing, version);\r\n        }\r\n        else {\r\n            delete capabilities.billing;\r\n        }\r\n\r\n        // Convert endpoints\r\n        capabilities.endpoints = this.convertEndpointsToLatestSpec(capabilities.endpoints, version, updateEndpointPaths);\r\n\r\n        // Fill STAC Version field\r\n        if (!updateVersionNumbers && Versions.compare(version, \"0.4.x\", \"=\")) {\r\n            capabilities.stac_version = \"0.6.2\";\r\n        }\r\n        else if (updateVersionNumbers || typeof capabilities.stac_version !== 'string') {\r\n            capabilities.stac_version = \"0.9.0\";\r\n        }\r\n\r\n        // Add missing fields with somewhat useful data\r\n        if (typeof capabilities.production !== 'boolean') {\r\n            capabilities.production = Versions.compare(version, \"1.0.0-rc.1\", \"=\") || Versions.compare(version, \"1.0.0-rc.2\", \"=\") ? true : false;\r\n        }\r\n        if (typeof capabilities.backend_version !== 'string') {\r\n            capabilities.backend_version = backend_version;\r\n        }\r\n        if (typeof capabilities.id !== 'string') {\r\n            capabilities.id = id;\r\n        }\r\n        if (typeof capabilities.title !== 'string') {\r\n            capabilities.title = title;\r\n        }\r\n        if (typeof capabilities.description !== 'string') {\r\n            capabilities.description = \"\";\r\n        }\r\n        capabilities.links = MigrateCommons.migrateLinks(capabilities.links, version);\r\n\r\n        return capabilities;\r\n    }\r\n\r\n    /**\r\n     * Converts the billing part of the `GET /` response to the latest version.\r\n     * \r\n     * Always returns a deep copy of the input object.\r\n     * \r\n     * @param {object} billing - The response to convert\r\n     * @param {string} version - Version number of the API, which the response conforms to\r\n     * @returns {object}\r\n     */\r\n    static convertBillingToLatestSpec(billing, version) {\r\n        if (Versions.compare(version, \"0.3.x\", \"<=\")) {\r\n            throw \"Migrating from API version 0.3.0 and older is not supported.\";\r\n        }\r\n        if (Utils.isObject(billing)) {\r\n            billing = Utils.deepClone(billing);\r\n        }\r\n        else {\r\n            billing = {};\r\n        }\r\n\r\n        if (typeof billing.currency !== 'string') {\r\n            billing.currency = null;\r\n        }\r\n\r\n        return billing;\r\n    }\r\n\r\n    /**\r\n     * Converts the endpoints part of the `GET /` response to the latest version.\r\n     * \r\n     * Always returns a deep copy of the input object.\r\n     * \r\n     * @param {array} endpoints - The response to convert\r\n     * @param {string} version - Version number of the API, which the response conforms to\r\n     * @param {boolean} updatePaths - Should the endpoint paths be updated to their recent equivalents?\r\n     * @returns {array}\r\n     */\r\n    static convertEndpointsToLatestSpec(endpoints, version, updatePaths = false) {\r\n        if (Versions.compare(version, \"0.3.x\", \"<=\")) {\r\n            throw \"Migrating from API version 0.3.0 and older is not supported.\";\r\n        }\r\n        if (!Array.isArray(endpoints)) {\r\n            return [];\r\n        }\r\n        endpoints = Utils.deepClone(endpoints);\r\n        // convert v0.4 endpoints to v1.0\r\n        if (updatePaths) {\r\n            let isV04 = Versions.compare(version, \"0.4.x\", \"=\");\r\n            let isLtV100RC2 = Versions.compare(version, \"1.0.0-rc.2\", \"<\");\r\n\r\n            let addPutToPg = function(endpoints) {\r\n                let newPgPath = '/process_graphs/{process_graph_id}';\r\n                let i = endpoints.findIndex(e => e.path === newPgPath);\r\n                if (i >= 0) {\r\n                    if (endpoints[i].methods.indexOf('PUT') === -1) {\r\n                        endpoints[i].methods.push('PUT');\r\n                    }\r\n                }\r\n                else {\r\n                    endpoints.push({\r\n                        path: newPgPath,\r\n                        methods: ['PUT']\r\n                    });\r\n                }\r\n                return endpoints;\r\n            };\r\n\r\n            for(var i in endpoints) {\r\n                let e = endpoints[i];\r\n                if (isV04) {\r\n                    switch (e.path) {\r\n                        case '/output_formats':\r\n                            e.path = '/file_formats';\r\n                            break;\r\n                        case '/files/{user_id}':\r\n                            e.path = '/files';\r\n                            break;\r\n                        case '/files/{user_id}/{path}':\r\n                            e.path = '/files/{path}';\r\n                            break;\r\n                    }\r\n                }\r\n                if (isLtV100RC2) {\r\n                    switch (e.path) {\r\n                        case '/process_graphs':\r\n                            let post = e.methods.indexOf('POST');\r\n                            if (post >= 0) {\r\n                                e.methods.splice(post, 1);\r\n                                addPutToPg(endpoints);\r\n                            }\r\n                            break;\r\n                        case '/process_graphs/{process_graph_id}':\r\n                            let patch = e.methods.indexOf('PATCH');\r\n                            if (patch >= 0) {\r\n                                e.methods.splice(patch, 1);\r\n                                addPutToPg(endpoints);\r\n                            }\r\n                            break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return endpoints;\r\n    }\r\n\r\n    /**\r\n     * Alias for `convertFileFormatsToLatestSpec()`.\r\n     * \r\n     * @alias MigrateCapabilities.convertFileFormatsToLatestSpec\r\n     * @deprecated\r\n     * @param {object} formats - The response to convert\r\n     * @param {string} version - Version number of the API, which the response conforms to\r\n     * @returns {object}\r\n     */\r\n    static convertOutputFormatsToLatestSpec(formats, version) {\r\n        return this.convertFileFormatsToLatestSpec(formats, version);\r\n    }\r\n\r\n    /**\r\n     * Converts a `GET /file_formats` response to the latest version.\r\n     * \r\n     * Always returns a deep copy of the input object.\r\n     * \r\n     * @param {object} formats - The response to convert\r\n     * @param {string} version - Version number of the API, which the response conforms to\r\n     * @returns {object}\r\n     */\r\n    static convertFileFormatsToLatestSpec(formats, version) {\r\n        if (Versions.compare(version, \"0.3.x\", \"<=\")) {\r\n            throw \"Migrating from API version 0.3.0 and older is not supported.\";\r\n        }\r\n        if (Utils.isObject(formats)) {\r\n            formats = Utils.deepClone(formats);\r\n        }\r\n        else {\r\n            formats = {};\r\n        }\r\n\r\n        if (Versions.compare(version, \"0.4.x\", \"=\") && Utils.isObject(formats)) {\r\n            formats = {\r\n                output: formats\r\n            };\r\n        }\r\n\r\n        formats.input = upgradeFileFormats(formats.input, version);\r\n        formats.output = upgradeFileFormats(formats.output, version);\r\n\r\n        return formats;\r\n    }\r\n\r\n    /**\r\n     * Converts a `GET /service_types` response to the latest version.\r\n     * \r\n     * Always returns a deep copy of the input object.\r\n     * \r\n     * @param {object} types - The response to convert\r\n     * @param {string} version - Version number of the API, which the response conforms to\r\n     * @returns {object}\r\n     */\r\n    static convertServiceTypesToLatestSpec(types, version) {\r\n        if (Versions.compare(version, \"0.3.x\", \"<=\")) {\r\n            throw \"Migrating from API version 0.3.0 and older is not supported.\";\r\n        }\r\n        if (!Utils.isObject(types)) {\r\n            return {};\r\n        }\r\n\r\n        types = Utils.deepClone(types);\r\n        for(let t in types) {\r\n            if (!Utils.isObject(types[t])) {\r\n                types[t] = {};\r\n            }\r\n            if (Versions.compare(version, \"0.4.x\", \"=\")) {\r\n                // Remove attributes\r\n                delete types[t].attributes;\r\n\r\n                // Rename parameters to configuration\r\n                if (Utils.isObject(types[t].parameters)) {\r\n                    types[t].configuration = types[t].parameters;\r\n                }\r\n                delete types[t].parameters;\r\n\r\n                // Rename variables to process_parameters\r\n                if (Array.isArray(types[t].variables)) {\r\n                    types[t].process_parameters = types[t].variables.map(v => {\r\n                        let param = {\r\n                            name: v.variable_id,\r\n                            description: typeof v.description === 'string' ? v.description : \"\",\r\n                            schema: {\r\n                                type: [\r\n                                    typeof v.type === 'string' ? v.type : \"string\",\r\n                                    \"null\"\r\n                                ]\r\n                            }\r\n                        };\r\n                        if (typeof v.default !== 'undefined') {\r\n                            param.default = v.default;\r\n                        }\r\n                        return param;\r\n                    });\r\n                }\r\n                delete types[t].variables;\r\n            }\r\n\r\n            if (!Utils.isObject(types[t].configuration)) {\r\n                types[t].configuration = {};\r\n            }\r\n            else {\r\n                types[t].configuration = MigrateCommons.migrateDiscoveryParameters(types[t].configuration, version);\r\n            }\r\n\r\n            if (!Array.isArray(types[t].process_parameters)) {\r\n                types[t].process_parameters = [];\r\n            }\r\n\r\n            if (typeof types[t].links !== 'undefined') { // links not required, so only apply if defined anyway\r\n                types[t].links = MigrateCommons.migrateLinks(types[t].links, version);\r\n            }\r\n        }\r\n        return types;\r\n    }\r\n\r\n    /**\r\n     * Converts a `GET /udf_runtimes` response to the latest version.\r\n     * \r\n     * Always returns a deep copy of the input object.\r\n     * \r\n     * @param {object} runtimes - The response to convert\r\n     * @param {string} version - Version number of the API, which the response conforms to\r\n     * @returns {object}\r\n     */\r\n    static convertUdfRuntimesToLatestSpec(runtimes, version) {\r\n        if (Versions.compare(version, \"0.3.x\", \"<=\")) {\r\n            throw \"Migrating from API version 0.3.0 and older is not supported.\";\r\n        }\r\n        if (!Utils.isObject(runtimes)) {\r\n            return {};\r\n        }\r\n\r\n        runtimes = Utils.deepClone(runtimes);\r\n        for(let r in runtimes) {\r\n        // Nothing to do, was not supported in 0.3 and nothing changed in 0.4.\r\n            if (Versions.compare(version, \"0.4.x\", \"=\")) {\r\n                if (!Utils.isObject(runtimes[r])) {\r\n                    delete runtimes[r];\r\n                    continue;\r\n                }\r\n\r\n                // null is not allowed any longer, replace with empty string\r\n                if (runtimes[r].description === null) {\r\n                    runtimes[r].description = \"\";\r\n                }\r\n            }\r\n\r\n            if (typeof runtimes[r].type !== 'string') {\r\n                if (typeof runtimes[r].docker === 'string') {\r\n                    runtimes[r].type = 'docker';\r\n                }\r\n                else {\r\n                    runtimes[r].type = 'language';\r\n                }\r\n            }\r\n\r\n            if (typeof runtimes[r].links !== 'undefined') { // links not required, so only apply if defined anyway\r\n                runtimes[r].links = MigrateCommons.migrateLinks(runtimes[r].links, version);\r\n            }\r\n        }\r\n\r\n        return runtimes;\r\n    }\r\n\r\n}\r\n\r\nconst GIS_DATA_TYPES = ['raster', 'vector', 'table', 'other'];\r\n\r\nfunction upgradeFileFormats(formats, version) {\r\n    if (!Utils.isObject(formats)) {\r\n        formats = {};\r\n    }\r\n    for(let id in formats) {\r\n        if (!Utils.isObject(formats[id].parameters)) {\r\n            formats[id].parameters = {};\r\n        }\r\n        else {\r\n            formats[id].parameters = MigrateCommons.migrateDiscoveryParameters(formats[id].parameters, version);\r\n        }\r\n\r\n        // Can be empty: https://github.com/Open-EO/openeo-api/issues/325\r\n        if (!Array.isArray(formats[id].gis_data_types)) {\r\n            formats[id].gis_data_types = [];\r\n        }\r\n        else {\r\n            formats[id].gis_data_types = formats[id].gis_data_types.filter(t => GIS_DATA_TYPES.includes(t));\r\n        }\r\n\r\n        if (typeof formats[id].links !== 'undefined') { // links not required, so only apply if defined anyway\r\n            formats[id].links = MigrateCommons.migrateLinks(formats[id].links, version);\r\n        }\r\n    }\r\n    return formats;\r\n}\r\n\r\nmodule.exports = MigrateCapabilities;","const Utils = require('../utils.js');\r\nconst Versions = require('../versions.js');\r\nconst MigrateCommons = require('./commons.js');\r\n\r\nconst extMap = {\r\n    \"cube\": \"datacube\",\r\n    \"eo\": \"eo\",\r\n    \"label\": \"label\",\r\n    \"pc\": \"pointcloud\",\r\n    \"proj\": \"projection\",\r\n    \"sar\": \"sar\",\r\n    \"sat\": \"sat\",\r\n    \"sci\": \"scientific\",\r\n    \"view\": \"view\"\r\n};\r\n\r\nconst fieldMap = {\r\n    // Item to core\r\n    'item:license': 'license',\r\n    'item:providers': 'providers',\r\n    // EO to core\r\n    'eo:instrument': 'instruments',\r\n    'eo:platform': 'platform',\r\n    'eo:constellation': 'constellation',\r\n    // EO to proj\r\n    'eo:epsg': 'proj:epsg',\r\n    // EO to view\r\n    'eo:off_nadir': 'view:off_nadir',\r\n    'eo:azimuth': 'view:azimuth',\r\n    'eo:sun_azimuth': 'view:sun_azimuth',\r\n    'eo:sun_elevation': 'view:sun_elevation',\r\n    // Datetime Range to core\r\n    'dtr:start_datetime': 'start_datetime',\r\n    'dtr:end_datetime': 'end_datetime',\r\n    // Point Cloud\r\n    'pc:schema': 'pc:schemas',\r\n    // SAR rename\r\n    'sar:type': 'sar:product_type',\r\n    'sar:polarization': 'sar:polarizations',\r\n    // SAR to core\r\n    'sar:instrument': 'instruments',\r\n    'sar:platform': 'platform',\r\n    'sar:constellation': 'constellation',\r\n    // SAR to sat\r\n    'sar:off_nadir': 'sat:off_nadir_angle',\r\n    'sar:relative_orbit': 'sat:relative_orbit',\r\n// The following four fields don't translate directly, see code below\r\n    'sar:pass_direction': 'sat:orbit_state',\r\n//   sar:resolution => sar:resolution_range, sar:resolution_azimuth\r\n//   sar:pixel_spacing => sar:pixel_spacing_range, sar:pixel_spacing_azimuth\r\n//   sar:looks => sar:looks_range, sar:looks_azimuth, sar:looks_equivalent_number (opt)\r\n};\r\n\r\nconst moveToRoot = [\r\n    'cube:dimensions',\r\n    'sci:publications',\r\n    'sci:doi',\r\n    'sci:citation'\r\n];\r\n\r\nconst DIMENSION_TYPES = [\r\n    'spatial',\r\n    'temporal',\r\n    'bands',\r\n    'other'\r\n];\r\n\r\n\r\n/** Migrate Collections related responses to the latest version. */\r\nclass MigrateCollections {\r\n\r\n    /**\r\n     * Converts a `GET /collections` response to the latest version.\r\n     * \r\n     * Always returns a deep copy of the input object.\r\n     * \r\n     * @param {object} response - The response to convert\r\n     * @param {string} version - Version number of the API, which the response conforms to\r\n     * @returns {object}\r\n     */\r\n    static convertCollectionsToLatestSpec(response, version) {\r\n        if (Versions.compare(version, \"0.3.x\", \"<=\")) {\r\n            throw \"Migrating from API version 0.3.0 and older is not supported.\";\r\n        }\r\n\r\n        // Make sure we don't alter the original object\r\n        response = Utils.deepClone(response);\r\n\r\n        if (Array.isArray(response.collections)) {\r\n            response.collections = response.collections\r\n                .map(c => MigrateCollections.convertCollectionToLatestSpec(c, version))\r\n                .filter(c => typeof c.id === 'string');\r\n        }\r\n        else {\r\n            response.collections = [];\r\n        }\r\n\r\n        response.links = MigrateCommons.migrateLinks(response.links, version);\r\n\r\n        return response;\r\n    }\r\n\r\n    /**\r\n     * Converts a single collection to the latest version.\r\n     * \r\n     * Always returns a deep copy of the input object.\r\n     * \r\n     * @param {object} process - The collection to convert\r\n     * @param {string} version - Version number of the API, which the collection conforms to\r\n     * @returns {object}\r\n     */\r\n    static convertCollectionToLatestSpec(originalCollection, version) {\r\n        if (Versions.compare(version, \"0.3.x\", \"<=\")) {\r\n            throw \"Migrating from API version 0.3.0 and older is not supported.\";\r\n        }\r\n\r\n        // Make sure we don't alter the original object\r\n        let collection = Utils.deepClone(originalCollection);\r\n\r\n        // If collection has no id => seems to be an invalid collection => abort\r\n        if (typeof collection.id !== 'string' || collection.id.length === 0) {\r\n            return {};\r\n        }\r\n\r\n        // Update stac_version\r\n        if (!Versions.validate(collection.stac_version) || Versions.compare(collection.stac_version, \"0.9.0\", \"<\")) {\r\n            collection.stac_version = \"0.9.0\";\r\n        }\r\n\r\n        // Add missing extent upfront. Makes the following code simpler as it works on the object.\r\n        if (!Utils.isObject(collection.extent)) {\r\n            collection.extent = {};\r\n        }\r\n\r\n        // convert v0.4 collections to latest version\r\n        if (Versions.compare(version, \"0.4.x\", \"=\")) {\r\n            // Restructure spatial extent\r\n            if (Array.isArray(collection.extent.spatial)) {\r\n                collection.extent.spatial = {\r\n                    bbox: [\r\n                        collection.extent.spatial\r\n                    ]\r\n                };\r\n            }\r\n            // Restructure temporal extent\r\n            if (Array.isArray(collection.extent.temporal)) {\r\n                collection.extent.temporal = {\r\n                    interval: [\r\n                        collection.extent.temporal\r\n                    ]\r\n                };\r\n            }\r\n\r\n            // move properties to other_properties\r\n            if (Utils.isObject(collection.properties)) {\r\n                if (!Utils.isObject(collection.other_properties)) {\r\n                    collection.other_properties = {};\r\n                }\r\n                for(let key in collection.properties) {\r\n                    collection.other_properties[key] = {\r\n                        values: [\r\n                            collection.properties[key]\r\n                        ]\r\n                    };\r\n                }\r\n            }\r\n            delete collection.properties;\r\n\r\n            // now we can work on all properties and migrate to summaries\r\n            let props = Utils.isObject(collection.other_properties) ? collection.other_properties : {};\r\n            for(let key in props) {\r\n                let val = props[key];\r\n                if (Utils.isObject(val) && (Array.isArray(val.extent) || Array.isArray(val.values))) {\r\n                    if (Array.isArray(val.extent)) {\r\n                        props[key] = {\r\n                            min: val.extent[0],\r\n                            max: val.extent[1]\r\n                        };\r\n                    }\r\n                    else { // val.values is an array\r\n                        if (val.values.findIndex(v => !Array.isArray(v)) === -1) {\r\n                            if (val.values.length <= 1) {\r\n                                props[key] = val.values[0];\r\n                            }\r\n                            else {\r\n                                props[key] = val.values.reduce((a, b) => a.concat(b));\r\n                            }\r\n                        }\r\n                        else {\r\n                            props[key] = val.values;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    // If not valid, move to top-level\r\n                    if (typeof collection[key] === 'undefined') {\r\n                        collection[key] = val;\r\n                    }\r\n                    delete props[key];\r\n                }\r\n            }\r\n            delete collection.other_properties;\r\n\r\n            if (!Utils.isObject(collection.summaries)) {\r\n                collection.summaries = {};\r\n            }\r\n            for(let key in props) {\r\n                let val = props[key];\r\n\r\n                if (key === 'sar:pass_direction') {\r\n                    // Convert null to geostationary\r\n                    val = val.map(v => v === null ? 'geostationary' : v);\r\n                }\r\n\r\n                // Convert arrays into separate fields as needed for some SAR fields\r\n                if ((key === 'sar:resolution' || key === 'sar:pixel_spacing' || key === 'sar:looks') && Array.isArray(val) && val.length >= 2) {\r\n                    collection.summaries[key + '_range'] = val.slice(0,1);\r\n                    collection.summaries[key + '_azimuth'] = val.slice(1,2);\r\n                    if (val.length > 2) {\r\n                        collection.summaries[key + '_equivalent_number'] = val.slice(2,3);\r\n                    }\r\n                }\r\n                // Do the renaming of fields\r\n                else if (typeof fieldMap[key] === 'string') {\r\n                    collection.summaries[fieldMap[key]] = val;\r\n                }\r\n                // Move invalid summaries to the top level\r\n                else if (moveToRoot.includes(key) && Array.isArray(val) && val.length === 1) {\r\n                    collection[key] = val[0];\r\n                }\r\n                // Do the general conversion\r\n                else {\r\n                    collection.summaries[key] = val;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Add missing required fields\r\n        if (typeof collection.description !== 'string') {\r\n            collection.description = \"\";\r\n        }\r\n        if (!Utils.isObject(collection.extent.spatial)) {\r\n            collection.extent.spatial = {};\r\n        }\r\n        if (!Utils.isObject(collection.extent.temporal)) {\r\n            collection.extent.temporal = {};\r\n        }\r\n        if (typeof collection.license !== 'string') {\r\n            collection.license = \"proprietary\";\r\n        }\r\n        if (!Utils.isObject(collection.summaries)) {\r\n            collection.summaries = {};\r\n        }\r\n        if (!Utils.isObject(collection['cube:dimensions'])) {\r\n            collection['cube:dimensions'] = {};\r\n        }\r\n        else {\r\n            for(var name in collection['cube:dimensions']) {\r\n                if (Utils.isObject(collection['cube:dimensions'][name]) && !DIMENSION_TYPES.includes(collection['cube:dimensions'][name].type)) {\r\n                    collection['cube:dimensions'][name].type = 'other';\r\n                }\r\n            }\r\n        }\r\n\r\n        // Fix links\r\n        collection.links = MigrateCommons.migrateLinks(collection.links);\r\n\r\n        // Fix stac_extensions\r\n        var extensions = Array.isArray(collection.stac_extensions) ? collection.stac_extensions : [];\r\n        for(var key in collection) {\r\n            let ext = null;\r\n            let prefix = key.split(':', 1);\r\n            if (key === 'deprecated' || key === 'version') {\r\n                ext = 'version';\r\n            }\r\n            else if (typeof extMap[prefix] === 'string') {\r\n                ext = extMap[prefix];\r\n            }\r\n\r\n            if (ext !== null && !extensions.includes(ext)) {\r\n                extensions.push(ext);\r\n            }\r\n        }\r\n        extensions.sort();\r\n        collection.stac_extensions = extensions;\r\n\r\n        return collection;\r\n    }\r\n\r\n}\r\n\r\nmodule.exports = MigrateCollections;","const Utils = require('../utils.js');\r\nconst Versions = require('../versions.js');\r\n\r\nclass MigrateCommons {\r\n\r\n\tstatic migrateLinks(links, version, fallbackRel = 'related') {\r\n\t\tif (!Array.isArray(links)) {\r\n\t\t\treturn [];\r\n\t\t}\r\n\r\n\t\treturn links\r\n\t\t\t.filter(link => Utils.isObject(link) && typeof link.href === 'string')\r\n\t\t\t.map(link => {\r\n\t\t\t\tif (typeof link.rel !== 'string') {\r\n\t\t\t\t\tlink.rel = fallbackRel;\r\n\t\t\t\t}\r\n\t\t\t\treturn link;\r\n\t\t\t});\r\n\t}\r\n\r\n\tstatic migrateDiscoveryParameters(parameters, version) {\r\n\t\tif (Versions.compare(version, \"1.0.0-rc.2\", \"<=\")) {\r\n\t\t\tfor(var name in parameters) {\r\n\t\t\t\tif (!Utils.isObject(parameters[name])) {\r\n\t\t\t\t\tdelete parameters[name];\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet type = parameters[name].type;\r\n\t\t\t\tif (typeof type === 'string') {\r\n\t\t\t\t\tparameters[name].type = [type, \"null\"];\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet example = parameters[name].example;\r\n\t\t\t\tif (typeof example !== 'undefined') {\r\n\t\t\t\t\tparameters[name].examples = [example];\r\n\t\t\t\t\tdelete parameters[name].example;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn parameters;\r\n\t}\r\n\r\n}\r\n\r\nmodule.exports = MigrateCommons;","const Utils = require('../utils.js');\r\nconst Versions = require('../versions.js');\r\nconst MigrateCommons = require('./commons.js');\r\n\r\n/** Migrate processes related responses to the latest version. */\r\nclass MigrateProcesses {\r\n\r\n    /**\r\n     * Converts a `GET /process` response to the latest version.\r\n     * \r\n     * Always returns a deep copy of the input object.\r\n     * \r\n     * @param {object} response - The response to convert\r\n     * @param {string} version - Version number of the API, which the response conforms to\r\n     * @returns {object}\r\n     */\r\n    static convertProcessesToLatestSpec(response, version) {\r\n        if (Versions.compare(version, \"0.3.x\", \"<=\")) {\r\n            throw \"Migrating from API version 0.3.0 and older is not supported.\";\r\n        }\r\n\r\n        // Make sure we don't alter the original object\r\n        response = Utils.deepClone(response);\r\n\r\n        if (Array.isArray(response.processes)) {\r\n            response.processes = response.processes\r\n                .map(p => MigrateProcesses.convertProcessToLatestSpec(p, version))\r\n                .filter(p => typeof p.id === 'string');\r\n        }\r\n        else {\r\n            response.processes = [];\r\n        }\r\n\r\n        response.links = MigrateCommons.migrateLinks(response.links, version);\r\n\r\n        return response;\r\n    }\r\n\r\n    /**\r\n     * Converts a single process to the latest version.\r\n     * \r\n     * Always returns a deep copy of the input object.\r\n     * \r\n     * @param {object} process - The process to convert\r\n     * @param {string} version - Version number of the API, which the process conforms to\r\n     * @returns {object}\r\n     */\r\n    static convertProcessToLatestSpec(process, version) {\r\n        if (Versions.compare(version, \"0.3.x\", \"<=\")) {\r\n            throw \"Migrating from API version 0.3.0 and older is not supported.\";\r\n        }\r\n\r\n        // Make sure we don't alter the original object\r\n        process = Utils.deepClone(process);\r\n\r\n        // If process has no id => seems to be an invalid process => abort\r\n        if (typeof process.id !== 'string' || process.id.length === 0) {\r\n            return {};\r\n        }\r\n\r\n        // Convert the parameters from object to array\r\n        if (Versions.compare(version, \"0.4.x\", \"=\")) {\r\n            // Determine the parameter order\r\n            if (!Array.isArray(process.parameter_order) || process.parameter_order.length === 0) {\r\n                process.parameter_order = [];\r\n                for(let param in process.parameters) {\r\n                    process.parameter_order.push(param);\r\n                }\r\n            }\r\n    \r\n            // Upgrade parameters and convert from array to object\r\n            let params = [];\r\n            for(let name of process.parameter_order) {\r\n                // Add name \r\n                let obj = {name: name};\r\n                if (Utils.isObject(process.parameters[name])) {\r\n                    Object.assign(obj, process.parameters[name]);\r\n                }\r\n\r\n                // Migrate from required to optional\r\n                if (!obj.required) {\r\n                    obj.optional = true;\r\n                }\r\n                delete obj.required;\r\n\r\n                // Add to list of ordered params\r\n                params.push(obj);\r\n            }\r\n            delete process.parameter_order;\r\n            process.parameters = params;\r\n        }\r\n\r\n        // Set required field description if not a string\r\n        if (typeof process.description !== 'string') {\r\n            process.description = \"\";\r\n        }\r\n\r\n        // Update parameters\r\n        if (Array.isArray(process.parameters)) {\r\n            for (var i = process.parameters.length-1; i >= 0; i--) {\r\n                let param = process.parameters[i];\r\n                if (!Utils.isObject(param)) {\r\n                    process.parameters.splice(i, 1);\r\n                    continue;\r\n                }\r\n\r\n                // Set required field description if not a string\r\n                if (typeof param.description !== 'string') {\r\n                    param.description = \"\";\r\n                }\r\n\r\n                // Upgrade parameter schema\r\n                process.parameters[i] = upgradeSchema(param, version);\r\n            }\r\n        }\r\n        else {\r\n            process.parameters = [];\r\n        }\r\n\r\n        // Update return value\r\n        if (!Utils.isObject(process.returns)) {\r\n            process.returns = {};\r\n        }\r\n        process.returns = upgradeSchema(process.returns, version, false);\r\n\r\n        // Remove process graphs from examples (and ensure there are arguments given)\r\n        if (Array.isArray(process.examples)) {\r\n            process.examples = process.examples.filter(example => Utils.isObject(example) && Utils.isObject(example.arguments));\r\n        }\r\n\r\n        if (typeof process.links !== 'undefined') { // links not required, so only apply if defined anyway\r\n            process.links = MigrateCommons.migrateLinks(process.links, version);\r\n        }\r\n\r\n        // Update process graph -> nothing to do yet\r\n\r\n        return process;\r\n    }\r\n\r\n}\r\n    \r\nfunction upgradeSchema(obj, version, isParam = true) {\r\n    var schema = {};\r\n    if (obj.schema && typeof obj.schema === 'object') { // array or object?\r\n        schema = obj.schema;\r\n    }\r\n\r\n    if (Versions.compare(version, \"0.4.x\", \"=\")) {\r\n        // Remove anyOf/oneOf wrapper\r\n        for(let type of ['anyOf', 'oneOf']) {\r\n            if (Array.isArray(schema[type])) {\r\n                // Parameters only: Move default value to parameter-level\r\n                if (isParam && typeof schema.default !== 'undefined') {\r\n                    obj.default = schema.default;\r\n                }\r\n                // Move array one level up, removing anyOf and oneOf\r\n                schema = schema[type];\r\n                break;\r\n            }\r\n        }\r\n\r\n        let moveMediaType = (Versions.compare(version, \"0.4.x\") <= 0 && typeof obj.media_type !== 'undefined');\r\n        let schemas = Array.isArray(schema) ? schema : [schema];\r\n        for(let subSchema of schemas) {\r\n            // Rename format to subtype recursively\r\n            subSchema = renameFormat(subSchema);\r\n\r\n            // Parameters only: Move default value to parameter-level\r\n            if (isParam && typeof subSchema.default !== 'undefined') {\r\n                obj.default = subSchema.default;\r\n                delete subSchema.default;\r\n            }\r\n\r\n            // Replace media_type field with contentMediaType from JSON Schemas\r\n            if (moveMediaType) {\r\n                subSchema.contentMediaType = obj.media_type;\r\n            }\r\n        }\r\n\r\n        // Remove the media type\r\n        if (moveMediaType) {\r\n            delete obj.media_type;\r\n        }\r\n    }\r\n\r\n    // Clients SHOULD automatically set `optional` to `true`, if a default value is specified.\r\n    if (Versions.compare(version, \"0.4.x\", \">\")) {\r\n        if (typeof obj.default !== 'undefined') {\r\n            obj.optional = true;\r\n        }\r\n    }\r\n\r\n    obj.schema = schema;\r\n    return obj;\r\n}\r\n\r\nfunction renameFormat(schema) {\r\n    if (Utils.isObject(schema) && typeof schema.type !== 'undefined' && typeof schema.format === 'string') {\r\n        switch(schema.format) {\r\n            case 'url':\r\n                schema.format = 'uri';\r\n                break;\r\n            case 'proj-definition':\r\n                schema.deprecated = true;\r\n                break;\r\n            case 'callback':\r\n                schema.format = 'process-graph';\r\n                if (Utils.isObject(schema.parameters)) {\r\n                    let params = [];\r\n                    for(let name in schema.parameters) {\r\n                        let paramSchema = schema.parameters[name];\r\n                        let param = {\r\n                            name: name,\r\n                            description: typeof paramSchema.description === 'string' ? paramSchema.description : \"\",\r\n                            schema: paramSchema\r\n                        };\r\n                        params.push(param);\r\n                    }\r\n                    schema.parameters = params;\r\n                }\r\n                break;\r\n        }\r\n\r\n        schema.subtype = schema.format;\r\n        // Leave format for \"well-known\" formats defined in JSON Schema\r\n        if (!['date-time', 'time', 'date', 'uri'].includes(schema.format)) {\r\n            delete schema.format;\r\n        }\r\n    }\r\n    for(let i in schema) {\r\n        if (schema[i] && typeof schema[i] === 'object') {\r\n            schema[i] = renameFormat(schema[i]);\r\n        }\r\n    }\r\n    return schema;\r\n}\r\n\r\nmodule.exports = MigrateProcesses;","const Utils = require('./utils');\r\n\r\n/**\r\n * Wrapper class for a single data type definition in a schema (e.g. process parameter schema, return value schema).\r\n * \r\n * @class\r\n */\r\nclass ProcessDataType {\r\n\t\r\n\t/**\r\n\t * Constructs a new process data type based on JSON Schema.\r\n\t * \r\n\t * @param {object} schema\r\n\t * @param {?ProcessSchema} [parent=null]\r\n\t * @param {*} [defaultValue=undefined]\r\n\t */\r\n\tconstructor(schema, parent = null, defaultValue = undefined) {\r\n\t\tthis.schema = schema;\r\n\t\tif (typeof this.schema.default === 'undefined') {\r\n\t\t\tthis.schema.default = defaultValue;\r\n\t\t}\r\n\t\tthis.parent = parent;\r\n\t}\r\n\r\n\t/**\r\n\t * Converts the schema to a JSON-serializable representation.\r\n\t * \r\n\t * @returns {object}\r\n\t */\r\n\ttoJSON() {\r\n\t\treturn Object.assign({}, this.schema, {default: this.default()});\r\n\t}\r\n\r\n\t/**\r\n\t * Checks whether the data type is only `null`.\r\n\t * \r\n\t * @returns {boolean}\r\n\t */\r\n\tisAny() {\r\n\t\treturn this.dataType() === 'any';\r\n\t}\r\n\r\n\t/**\r\n\t * Checks whether the data type is only `null`.\r\n\t * \r\n\t * @returns {boolean}\r\n\t */\r\n\tisNull() {\r\n\t\treturn this.schema.type === 'null';\r\n\t}\r\n\r\n\t/**\r\n\t * Checks whether the data type allows `null`.\r\n\t * \r\n\t * @returns {boolean}\r\n\t */\r\n\tnullable() {\r\n\t\treturn this.isNull() || this.isAny();\r\n\t}\r\n\r\n\t/**\r\n\t * Returns whether the data type is editable.\r\n\t * \r\n\t * This means it returns `true`, unless certain data types are detected that\r\n\t * can't be transmitted via JSON in the openEO API (e.g. data cubes or labeled arrays).\r\n\t * \r\n\t * @returns {boolean}\r\n\t */\r\n\tisEditable() {\r\n\t\treturn !ProcessDataType.NON_EDITABLE.includes(this.dataType());\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the data type.\r\n\t * \r\n\t * The priority is as such:\r\n\t * - subtype\r\n\t * - native data type\r\n\t * - \"any\"\r\n\t * \r\n\t * @param {boolean} [native=false] - Set to true to only return the native data type.\r\n\t * @returns {string}\r\n\t */\r\n\tdataType(native = false) {\r\n\t\tlet nativeType = this.schema.type || \"any\";\r\n\t\treturn native ? nativeType : (this.schema.subtype || nativeType);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the native data type of the schema.\r\n\t * \r\n\t * One of: array, object, null, string, boolean, number or any\r\n\t * \r\n\t * @returns {string}\r\n\t */\r\n\tnativeDataType() {\r\n\t\treturn this.dataType(true);\r\n\t}\r\n\r\n\t/**\r\n\t * Checks whether the data type contains an enumeration of values.\r\n\t * \r\n\t * @returns {boolean}\r\n\t * @see ProcessDataType#getEnumChoices\r\n\t */\r\n\tisEnum() {\r\n\t\treturn Array.isArray(this.schema.enum) && this.schema.enum.length > 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the allowed enumeration of values.\r\n\t * \r\n\t * @returns {array}\r\n\t * @see ProcessDataType#isEnum\r\n\t */\r\n\tgetEnumChoices() {\r\n\t\treturn this.isEnum() ? this.schema.enum : [];\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the parameters for a \"child process\" that is defined for the data type.\r\n\t * \r\n\t * @returns {array<object>}\r\n\t */\r\n\tgetCallbackParameters() {\r\n\t\tif (Array.isArray(this.schema.parameters)) { // For \"normal\" callbacks\r\n\t\t\treturn this.schema.parameters;\r\n\t\t}\r\n\t\telse if (Utils.isObject(this.schema.additionalProperties) && Array.isArray(this.schema.additionalProperties.parameters)) {\r\n\t\t\treturn this.schema.additionalProperties.parameters; // Used for metadata-filter\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn [];\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the group of the data type.\r\n\t * \r\n\t * Group is a \"extension\" of JSON Schema, which allows to group schemas by certain criteria.\r\n\t * \r\n\t * @returns {string}\r\n\t */\r\n\tgroup() {\r\n\t\treturn Utils.hasText(this.schema.group) ? this.schema.group : ProcessDataType.DEFAULT_GROUP;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the title of the data type.\r\n\t * \r\n\t * If no title is present, returns a \"prettified\" version of the data type\r\n\t * (e.g. \"Temporal Interval\" for the data type \"temporal-interval\").\r\n\t * \r\n\t * @returns {string}\r\n\t */\r\n\ttitle() {\r\n\t\tif (Utils.hasText(this.schema.title)) {\r\n\t\t\treturn this.schema.title;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn Utils.prettifyString(this.dataType());\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the description of the data type.\r\n\t * \r\n\t * @returns {string}\r\n\t */\r\n\tdescription() {\r\n\t\treturn Utils.hasText(this.schema.description) ? this.schema.description : \"\";\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the default value of the data type.\r\n\t * \r\n\t * This may return `undefined`.\r\n\t * \r\n\t * @returns {*}\r\n\t */\r\n\tdefault() {\r\n\t\tif (typeof this.schema.default === 'function') {\r\n\t\t\treturn this.schema.default();\r\n\t\t}\r\n\t\treturn this.schema.default;\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * The name of the default group for schemas.\r\n * \r\n * Defaults to `Other`.\r\n * \r\n * @type {string}\r\n */\r\nProcessDataType.DEFAULT_GROUP = 'Other';\r\n/**\r\n * A list of data types that can't be edited.\r\n * \r\n * Non-editable data types can't be transmitted via JSON through the openEO API\r\n * (e.g. data cubes or labeled arrays).\r\n * \r\n * @type {array<string>}\r\n */\r\nProcessDataType.NON_EDITABLE = [\r\n\t'raster-cube',\r\n\t'vector-cube',\r\n\t'labeled-array'\r\n];\r\n\r\nmodule.exports = ProcessDataType;","const ProcessSchema = require('./processSchema');\r\n\r\n/**\r\n * Wrapper class for a process parameter.\r\n * \r\n * @class\r\n */\r\nclass ProcessParameter extends ProcessSchema {\r\n\r\n\t/**\r\n\t * Constructs a new process parameter based on the openEO API representation.\r\n\t * \r\n\t * @param {object} parameter \r\n\t */\r\n\tconstructor(parameter) {\r\n\t\tsuper(parameter.schema, parameter.default);\r\n\r\n\t\tObject.assign(this, parameter);\r\n\t}\r\n\r\n}\r\n\r\nmodule.exports = ProcessParameter;","const Utils = require('./utils');\r\n\r\n/**\r\n * Central registry for processes.\r\n * \r\n * @class\r\n */\r\nclass ProcessRegistry {\r\n\r\n\t/**\r\n\t * Creates a new registry of all processes.\r\n\t * \r\n\t * @param {Array.<object>|ProcessRegistry} [processes=[]] - Optionally, a list of predefined processes.\r\n\t * @param {boolean} [addNamespace=false] - Add a namespace property to processes if set to `true`.\r\n\t */\r\n\tconstructor(processes = [], addNamespace = false) {\r\n\t\t/**\r\n\t\t * List of listeners for change events.\r\n\t\t * @public\r\n\t\t */\r\n\t\tthis.listeners = [];\r\n\t\t/**\r\n\t\t * Object of namespaces and processes.\r\n\t\t * @protected\r\n\t\t * @type {object.<string,object.<string,object>>}\r\n\t\t */\r\n\t\tthis.processes = {};\r\n\t\t/**\r\n\t\t * Add a namespace property to processes if set to `true`.\r\n\t\t * @protected\r\n\t\t * @type {boolean}\r\n\t\t */\r\n\t\tthis.addNamespace = addNamespace;\r\n\r\n\t\t// Fill process list\r\n\t\tif (processes instanceof ProcessRegistry) {\r\n\t\t\tfor(let namespace in processes.processes) {\r\n\t\t\t\tthis.addAll(processes.processes[namespace]);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.addAll(processes);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Event that is fired on changes, notifies listeners.\r\n\t * \r\n\t * @param {string} event - One of 'add', 'addAll' or 'remove'.\r\n\t * @param {*} data \r\n\t * @param {string} namespace \r\n\t */\r\n\tonChange(event, data, namespace) {\r\n\t\tfor(let listener of this.listeners) {\r\n\t\t\tlistener(event, data, namespace);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Adds a list of processes for a given namespace.\r\n\t * \r\n\t * Replaces an existing process in the given namespace if it exists.\r\n\t * \r\n\t * Fires 'addAll' event.\r\n\t * \r\n\t * @param {Array.<object>} processes Optionally, a list of processes\r\n\t * @param {string} [namespace=\"backend\"] The namespace for the processes (defaults to 'backend', i.e. pre-defined processes)\r\n\t */\r\n\taddAll(processes, namespace = 'backend') {\r\n\t\tfor(var i in processes) {\r\n\t\t\tthis.add(processes[i], namespace, false);\r\n\t\t}\r\n\t\tthis.onChange('addAll', processes, namespace);\r\n\t}\r\n\r\n\t/**\r\n\t * Adds a single process to a given namespace.\r\n\t * \r\n\t * Replaces an existing process in the given namespace if it exists.\r\n\t * \r\n\t * Fires 'add' event.\r\n\t * \r\n\t * @param {object} processes A process definition\r\n\t * @param {string} [namespace=\"backend\"] The namespace for the process (defaults to 'backend', i.e. pre-defined processes)\r\n\t */\r\n\tadd(process, namespace = 'backend', fireEvent = true) {\r\n\t\tif (!Utils.isObject(process)) {\r\n\t\t\tthrow new Error(\"Invalid process; not an object.\");\r\n\t\t}\r\n\t\tif (typeof process.id !== 'string') {\r\n\t\t\tthrow new Error(\"Invalid process; no id specified.\");\r\n\t\t}\r\n\t\tif (typeof namespace !== 'string') {\r\n\t\t\tthrow new Error(\"Invalid namespace; not a string.\");\r\n\t\t}\r\n\r\n\t\tif (!this.processes[namespace]) {\r\n\t\t\tthis.processes[namespace] = {};\r\n\t\t}\r\n\t\tprocess = Object.assign(this.addNamespace ? {namespace} : {}, process);\r\n\t\tthis.processes[namespace][process.id] = process;\r\n\t\tif (fireEvent) {\r\n\t\t\tthis.onChange('add', process, namespace);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the count of all processes independant of the namespaces.\r\n\t * \r\n\t * @returns {number} \r\n\t */\r\n\tcount() {\r\n\t\treturn Utils.size(this.all());\r\n\t}\r\n\r\n\t/**\r\n\t * Returns all processes as a list, independant of the namespaces.\r\n\t * \r\n\t * @returns {Array.<object>} \r\n\t */\r\n\tall() {\r\n\t\tlet processes = [];\r\n\t\tfor(let ns in this.processes) {\r\n\t\t\tprocesses = processes.concat(Object.values(this.processes[ns]));\r\n\t\t}\r\n\t\treturn processes;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks whether a namespace exists (i.e. at least one process for the namespace exists)\r\n\t * \r\n\t * @param {string} namespace The namespace\r\n\t * @returns {boolean}\r\n\t */\r\n\thasNamespace(namespace) {\r\n\t\tif(typeof namespace !== 'string') {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\treturn Boolean(this.processes[namespace]);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a (sorted) list of all available namespaces.\r\n\t * \r\n\t * @returns {Array.<string>} \r\n\t */\r\n\tnamespaces() {\r\n\t\treturn Object.keys(this.processes).sort();\r\n\t}\r\n\r\n\t/**\r\n\t * Returns all processes from a specific namespace.\r\n\t * \r\n\t * Returns an empty list if the namespace is not defined.\r\n\t * \r\n\t * @param {string} namespace The namespace of the processes to return (e.g. 'backend' for pre-defined processes)\r\n\t * @returns {Array.<object>} \r\n\t */\r\n\tnamespace(namespace) {\r\n\t\tif(typeof namespace !== 'string') {\r\n\t\t\treturn [];\r\n\t\t}\r\n\t\tlet processes = this.processes[namespace];\r\n\t\treturn processes ? Object.values(processes) : [];\r\n\t}\r\n\r\n\t/**\r\n\t * Checks whether a process with the given ID exists in the given namespace.\r\n\t * \r\n\t * If the namespace is set to `null` (default) then it checks both user processes and backend processes.\r\n\t * The default namespace for pre-defined processes is `backend`.\r\n\t * \r\n\t * @param {string} id The process identifier\r\n\t * @param {?string} [namespace=null] The namespace of the process\r\n\t * @returns {boolean} \r\n\t */\r\n\thas(id, namespace = null) {\r\n\t\treturn Boolean(this.get(id, namespace));\r\n\t}\r\n\t\r\n\t/**\r\n\t * Retrieve the process with the given ID fron the given namespace.\r\n\t * \r\n\t * If the namespace is set to `null` (default) then it retrieces from both (1) `user` processes and (2) `backend` processes\r\n\t * with preference to user processes on conflict. The default namespace for pre-defined processes is `backend`.\r\n\t * \r\n\t * @param {string} id The process identifier\r\n\t * @param {?string} [namespace=null] The namespace of the process\r\n\t * @returns {object} \r\n\t */\r\n\tget(id, namespace = null) {\r\n\t\tif (typeof id !== 'string') {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t// If no namespace is set, prefer the user namespace over backend namespace\r\n\t\tif (namespace === null) {\r\n\t\t\treturn this.get(id, 'user') || this.get(id, 'backend');\r\n\t\t}\r\n\r\n\t\tif (this.processes[namespace]) {\r\n\t\t\treturn this.processes[namespace][id] || null;\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\t/**\r\n\t * Removes a single process or a complete namespace from the registry.\r\n\t * \r\n\t * If nothing is given, removes the namespace 'user'.\r\n\t * If only a namespace is given, removes the whole namespace.\r\n\t * If only a process is given, removes a process from the namespace `user`.\r\n\t * If both parameters are given, removes a process from the given namespace.\r\n\t * \r\n\t * Returns `true` on succes, `false` on failure.\r\n\t * \r\n\t * Fires 'remove' event.\r\n\t * \r\n\t * @param {?string} [id=null] The process identifier\r\n\t * @param {?string} [namespace=\"user\"] The namespace, defaults to `user`\r\n\t * @returns {boolean}\r\n\t */\r\n\tremove(id = null, namespace = 'user') {\r\n\t\tif (typeof namespace !== 'string') {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tif (this.processes[namespace]) {\r\n\t\t\tif (typeof id === 'string') {\r\n\t\t\t\tif (this.processes[namespace][id]) {\r\n\t\t\t\t\tlet process = this.processes[namespace][id];\r\n\t\t\t\t\tdelete this.processes[namespace][id];\r\n\t\t\t\t\tif (Utils.size(this.processes[namespace]) === 0) {\r\n\t\t\t\t\t\tdelete this.processes[namespace];\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.onChange('remove', process, namespace);\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tdelete this.processes[namespace];\r\n\t\t\t\tthis.onChange('remove', null, namespace);\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n}\r\n\r\nmodule.exports = ProcessRegistry;","const ProcessUtils = require('./processUtils');\r\nconst ProcessDataType = require('./processDataType');\r\nconst Utils = require('./utils');\r\n\r\n/**\r\n * Wrapper class for the process schemas (i.e. from parameters or return value).\r\n * \r\n * @class\r\n */\r\nclass ProcessSchema {\r\n\t\r\n\t/**\r\n\t * Constructs a new process schema based on the openEO API representation.\r\n\t * \r\n\t * Can be array or JSON Schema object. The array consists of multiple JSON Schemas then.\r\n\t * \r\n\t * @param {?object|array} [schema=null]\r\n\t * @param {*} [defaultValue=undefined]\r\n\t */\r\n\tconstructor(schema = null, defaultValue = undefined) {\r\n\t\tif (!Utils.isObject(schema) && !Array.isArray(schema)) {\r\n\t\t\tthis.unspecified = true;\r\n\t\t\tthis.schemas = [];\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.unspecified = false;\r\n\t\t\tthis.schemas = ProcessUtils.normalizeJsonSchema(schema, true).map(s => new ProcessDataType(s, this, defaultValue));\r\n\r\n\t\t\t// Find and assign the default value from sub-schemas if no defaultValue was given\r\n\t\t\tif (typeof defaultValue === 'undefined') {\r\n\t\t\t\tlet defaults = this.schemas\r\n\t\t\t\t\t.map(s => s.default())\r\n\t\t\t\t\t.filter(d => typeof d !== 'undefined');\r\n\t\t\t\tthis.default = defaults[0];\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis.default = defaultValue;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.refs = [];\r\n\t}\r\n\r\n\t/**\r\n\t * Converts the schemas to a JSON-serializable representation.\r\n\t * \r\n\t * @returns {object}\r\n\t */\r\n\ttoJSON() {\r\n\t\treturn this.schemas.map(s => s.toJSON());\r\n\t}\r\n\r\n\t/**\r\n\t * Returns whether the schema is editable.\r\n\t * \r\n\t * This means it returns `true`, unless certain data types are detected that\r\n\t * can't be transmitted via JSON in the openEO API (e.g. data cubes or labeled arrays).\r\n\t * \r\n\t * @returns {boolean}\r\n\t */\r\n\tisEditable() {\r\n\t\treturn (this.unspecified || this.schemas.filter(s => s.isEditable() && !s.isNull()).length > 0);\r\n\t}\r\n\r\n\t/**\r\n\t * Checks whether the schema is exactly and only of the given data type.\r\n\t * \r\n\t * Can be a native type or a openEO \"subtype\".\r\n\t * \r\n\t * @param {string} type \r\n\t * @returns {boolean}\r\n\t */\r\n\tis(type) {\r\n\t\tvar types = this.dataTypes();\r\n\t\treturn (types.length === 1 && types[0] === type);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the native data type of the schema.\r\n\t * \r\n\t * One of: array, object, null, string, boolean, number\r\n\t * \r\n\t * @returns {string}\r\n\t */\r\n\tnativeDataType() {\r\n\t\treturn this.dataType(true);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the data type of the associated schemas.\r\n\t * \r\n\t * Setting `native` to `true` will only consider native JSON data types and \"any\".\r\n\t * Otherwise, subtypes will also be considered.\r\n\t * \r\n\t * If the schema has a two data types and one of them is `null`, \r\n\t * `null` is ignored and just the other data type is returned.\r\n\t * \r\n\t * `nullable()` can be used to check whether a schema allows `null`.\r\n\t * \r\n\t * Returns `mixed` if multiple data types are allowed.\r\n\t * \r\n\t * @param {boolean} [native=false]\r\n\t * @returns {string}\r\n\t * @see ProcessSchema#nullable\r\n\t */\r\n\tdataType(native = false) {\r\n\t\tvar types = this.dataTypes(true, native);\r\n\t\tvar nullIndex = types.indexOf('null');\r\n\t\tif (types.length === 1) {\r\n\t\t\treturn types[0];\r\n\t\t}\r\n\t\telse if (types.length === 2 && nullIndex !== -1) {\r\n\t\t\treturn types[nullIndex === 0 ? 1 : 0];\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn 'mixed';\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a set of all supported distinct data types (or 'any').\r\n\t * \r\n\t * By default, `null` is not included in the list of data types.\r\n\t * Setting `includeNull` to `true` to include `null` in the list.\r\n\t * \r\n\t * Setting `native` to `true` will only consider native JSON data types and \"any\".\r\n\t * Otherwise, subtypes will also be considered.\r\n\t * \r\n\t * @param {boolean} [includeNull=false]\r\n\t * @param {boolean} [native=false]\r\n\t * @returns {array<string>}\r\n\t */\r\n\tdataTypes(includeNull = false, native = false) {\r\n\t\tvar types = this.schemas\r\n\t\t\t.map(s => s.dataType(native))\r\n\t\t\t.filter((v, i, a) => a.indexOf(v) === i); // Return each type only once\r\n\t\tif (types.length === 0 || types.includes('any')) {\r\n\t\t\treturn ['any'];\r\n\t\t}\r\n\t\treturn includeNull ? types : types.filter(s => s !== 'null');\r\n\t}\r\n\r\n\t/**\r\n\t * Checks whether one of the schemas allows the value to be `null`.\r\n\t * \r\n\t * @returns {boolean}\r\n\t */\r\n\tnullable() {\r\n\t\treturn (this.unspecified || this.schemas.filter(s => s.nullable()).length > 0);\r\n\t}\r\n\r\n}\r\n\r\nmodule.exports = ProcessSchema;","const Utils = require('./utils');\r\n\r\n/**\r\n * Utilities to parse process specs and JSON schemas.\r\n * \r\n * @class\r\n */\r\nclass ProcessUtils {\r\n\r\n\t/**\r\n\t * From a \"complex\" JSON Schema with allOf/anyOf/oneOf, make separate schemas.\r\n\t * \r\n\t * So afterwards each schema has it's own array entry.\r\n\t * It merges allOf, resolves anyOf/oneOf into separate schemas.\r\n\t * May also split the JSON Schema type arrays into separate entries by setting `splitTypes` to `true`.\r\n\t * \r\n\t * @param {object|array} schemas - The JSON Schema(s) to convert\r\n\t * @returns {array}\r\n\t */\r\n\tstatic normalizeJsonSchema(schemas, splitTypes = false) {\r\n\t\t// Make schemas always an array\r\n\t\tif (Utils.isObject(schemas)) {\r\n\t\t\tschemas = [schemas];\r\n\t\t}\r\n\t\telse if (Array.isArray(schemas)) {\r\n\t\t\tschemas = schemas;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tschemas = [];\r\n\t\t}\r\n\r\n\t\t// Merge allOf, resolve anyOf/oneOf into separate schemas\r\n\t\tlet normalized = [];\r\n\t\tfor(let schema of schemas) {\r\n\t\t\tif (Array.isArray(schema.allOf)) {\r\n\t\t\t\tnormalized.push(Object.assign({}, ...schema.allOf));\r\n\t\t\t}\r\n\t\t\telse if (Array.isArray(schema.oneOf) || Array.isArray(schema.anyOf)) {\r\n\t\t\t\tlet copy = Utils.omitFromObject(schema, ['oneOf', 'anyOf']);\r\n\t\t\t\tlet subSchemas = schema.oneOf || schema.anyOf;\r\n\t\t\t\tfor(let subSchema of subSchemas) {\r\n\t\t\t\t\tnormalized.push(Object.assign({}, copy, subSchema));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tnormalized.push(schema);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!splitTypes) {\r\n\t\t\treturn normalized;\r\n\t\t}\r\n\r\n\t\t// Split type field into separate schemas\r\n\t\tschemas = [];\r\n\t\tfor(let schema of normalized) {\r\n\t\t\tif (Array.isArray(schema.type)) {\r\n\t\t\t\t/* jshint ignore:start */\r\n\t\t\t\tschemas = schemas.concat(schema.type.map(type => Object.assign({}, schema, {type: type})));\r\n\t\t\t\t/* jshint ignore:end */\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tschemas.push(schema);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn schemas;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the callback parameters for a given process parameter.\r\n\t * \r\n\t * @param {object} processParameter - The process parameter spec to parse.\r\n\t * @returns {array}\r\n\t * @throws {Error}\r\n\t */\r\n\tstatic getCallbackParameters(processParameter, keyPath = []) {\r\n\t\tif (!Utils.isObject(processParameter) || !processParameter.schema) {\r\n\t\t\treturn [];\r\n\t\t}\r\n\r\n\t\tlet schemas = ProcessUtils.normalizeJsonSchema(processParameter.schema);\r\n\t\tlet key;\r\n\t\twhile(key = keyPath.shift()) { // jshint ignore:line\r\n\t\t\tschemas = schemas.map(schema => ProcessUtils.normalizeJsonSchema(ProcessUtils.getElementJsonSchema(schema, key))); // jshint ignore:line\r\n\t\t\tschemas = schemas.concat(...schemas);\r\n\t\t}\r\n\r\n\r\n\t\tlet cbParams = [];\r\n\t\tfor(let schema of schemas) {\r\n\t\t\tlet params = null;\r\n\t\t\tif (Array.isArray(schema.parameters)) { // For \"normal\" callbacks\r\n\t\t\t\tparams = schema.parameters;\r\n\t\t\t}\r\n\t\t\telse if (Utils.isObject(schema.additionalProperties) && Array.isArray(schema.additionalProperties.parameters)) {\r\n\t\t\t\tparams = schema.additionalProperties.parameters; // Used for metadata-filter\r\n\t\t\t}\r\n\t\t\tif (Array.isArray(params)) {\r\n\t\t\t\tif (cbParams.length > 0 && !Utils.equals(cbParams, params)) {\r\n\t\t\t\t\tthrow new Error(\"Multiple schemas with different callback parameters found.\");\r\n\t\t\t\t}\r\n\t\t\t\tcbParams = params;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn cbParams;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the callback parameters for a given process parameter from a full process spec.\r\n\t * \r\n\t * @param {object} process - The process to parse.\r\n\t * @param {string} parameterName - The name of the parameter to get the callback parameters for.\r\n\t * @returns {array}\r\n\t * @throws {Error}\r\n\t */\r\n\tstatic getCallbackParametersForProcess(process, parameterName, path = []) {\r\n\t\tif (!Utils.isObject(process) || !Array.isArray(process.parameters)) {\r\n\t\t\treturn [];\r\n\t\t}\r\n\r\n\t\tlet param = process.parameters.find(p => p.name === parameterName);\r\n\t\treturn ProcessUtils.getCallbackParameters(param, path);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns *all* the native JSON data types allowed for the schema.\r\n\t * \r\n\t * @param {object} schema \r\n\t * @param {boolean} anyIsEmpty\r\n\t * @returns {array}\r\n\t */\r\n\tstatic getNativeTypesForJsonSchema(schema, anyIsEmpty = false) {\r\n\t\tif (Utils.isObject(schema) && Array.isArray(schema.type)) {\r\n\t\t\t// Remove duplicate and invalid types\r\n\t\t\tlet validTypes = Utils.unique(schema.type).filter(type => ProcessUtils.JSON_SCHEMA_TYPES.includes(type));\r\n\t\t\tif (validTypes.length > 0 && validTypes.length < ProcessUtils.JSON_SCHEMA_TYPES.length) {\r\n\t\t\t\treturn validTypes;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\treturn anyIsEmpty ? [] : ProcessUtils.JSON_SCHEMA_TYPES;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (Utils.isObject(schema) && typeof schema.type === 'string' && ProcessUtils.JSON_SCHEMA_TYPES.includes(schema.type)) {\r\n\t\t\treturn [schema.type];\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn anyIsEmpty ? [] : ProcessUtils.JSON_SCHEMA_TYPES;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the schema for a property of an object or an element of an array.\r\n\t * \r\n\t * If you want to retrieve the schema for a specific key, use the parameter `key`.\r\n\t * \r\n\t * @param {object} schema - The JSON schema to parse.\r\n\t * @param {string|integer|null} key - If you want to retrieve the schema for a specific key, otherwise null.\r\n\t * @returns {object} - JSON Schema\r\n\t */\r\n\tstatic getElementJsonSchema(schema, key = null) {\r\n\t\tlet types = ProcessUtils.getNativeTypesForJsonSchema(schema);\r\n\t\tif (Utils.isObject(schema) && types.includes('array') && typeof key !== 'string') {\r\n\t\t\tif (Utils.isObject(schema.items)) {\r\n\t\t\t\t// Array with one schema for all items: https://json-schema.org/understanding-json-schema/reference/array.html#id5\r\n\t\t\t\treturn schema.items;\r\n\t\t\t}\r\n\t\t\telse if (Array.isArray(schema.items)) {\r\n\t\t\t\t// Tuple validation: https://json-schema.org/understanding-json-schema/reference/array.html#id6\r\n\t\t\t\tif (key !== null && Utils.isObject(schema.items[key])) {\r\n\t\t\t\t\treturn schema.items[key];\r\n\t\t\t\t}\r\n\t\t\t\telse if (Utils.isObject(schema.additionalItems)) {\r\n\t\t\t\t\treturn schema.additionalItems;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (Utils.isObject(schema) && types.includes('object')) {\r\n\t\t\tif (key !== null && Utils.isObject(schema.properties) && Utils.isObject(schema.properties[key])) {\r\n\t\t\t\treturn schema.properties[key];\r\n\t\t\t}\r\n\t\t\telse if (Utils.isObject(schema.additionalProperties)) {\r\n\t\t\t\treturn schema.additionalProperties;\r\n\t\t\t}\r\n\t\t\t// ToDo: No support for patternProperties yet\r\n\t\t}\r\n\r\n\t\treturn {};\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * A list of all allowed JSON Schema type values.\r\n * \r\n * @type {array}\r\n */\r\nProcessUtils.JSON_SCHEMA_TYPES = ['string', 'number', 'integer', 'boolean', 'array', 'object', 'null'];\r\n\r\nmodule.exports = ProcessUtils;","var equal = require('fast-deep-equal/es6');\r\n\r\n/**\r\n * General utilities\r\n * \r\n * @class\r\n */\r\nclass Utils {\r\n\r\n\t/**\r\n\t * Checks whether a variable is a real object or not.\r\n\t * \r\n\t * This is a more strict version of `typeof x === 'object'` as this example would also succeeds for arrays and `null`.\r\n\t * This function only returns `true` for real objects and not for arrays, `null` or any other data types.\r\n\t * \r\n\t * @param {*} obj - A variable to check.\r\n\t * @returns {boolean} - `true` is the given variable is an object, `false` otherwise.\r\n\t */\r\n\tstatic isObject(obj) {\r\n\t\treturn (typeof obj === 'object' && obj === Object(obj) && !Array.isArray(obj));\r\n\t}\r\n\r\n\t/**\r\n\t * Checks whether a variable is a string and contains at least one character.\r\n\t * \r\n\t * @param {*} string - A variable to check.\r\n\t * @returns {boolean} - `true` is the given variable is an string with length > 0, `false` otherwise.\r\n\t */\r\n\tstatic hasText(string) {\r\n\t\treturn (typeof string === 'string' && string.length > 0);\r\n\t}\r\n\r\n\t/**\r\n\t * Performs a deep comparison between two values to determine if they are equivalent.\r\n\t * \r\n\t * @param {*} x - The value to compare.\r\n\t * @param {*} y - The other value to compare.\r\n\t * @returns {boolean} - Returns true if the values are equivalent, else false.\r\n\t */\r\n\tstatic equals(x, y) {\r\n\t\treturn equal(x, y);\r\n\t}\r\n\r\n\t/**\r\n\t * Creates an object composed of the picked object properties.\r\n\t * \r\n\t * Returns a shallow copy!\r\n\t * \r\n\t * @param {object} obj - The source object.\r\n\t * @param {string|array} toPick - The properties to pick.\r\n\t * @returns {object}\r\n\t */\r\n\tstatic pickFromObject(obj, toPick) {\r\n\t\tobj = Object(obj);\r\n\t\tif (typeof toPick === 'string') {\r\n\t\t\ttoPick = [toPick];\r\n\t\t}\r\n\t\tconst copy = {};\r\n\t\ttoPick.forEach(key => copy[key] = obj[key]);\r\n\t\treturn copy;\r\n\t}\r\n\r\n\t/**\r\n\t * This method creates an object composed of the own and inherited enumerable property paths of object that are not omitted.\r\n\t * \r\n\t * Returns a shallow copy!\r\n\t * \r\n\t * @param {object} obj - The source object.\r\n\t * @param {string|array} toOmit - The properties to omit.\r\n\t * @returns {object}\r\n\t */\r\n\tstatic omitFromObject(obj, toOmit) {\r\n\t\tobj = Object(obj);\r\n\t\tif (typeof toOmit === 'string') {\r\n\t\t\ttoOmit = [toOmit];\r\n\t\t}\r\n\t\tvar copy = Object.assign({}, obj);\r\n\t\tfor(let key of toOmit) {\r\n\t\t\tdelete copy[key];\r\n\t\t}\r\n\t\treturn copy;\r\n\t}\r\n\r\n\t/**\r\n\t *  Creates an array of values by running each property of `object` thru function.\r\n\t * \r\n\t * The function is invoked with three arguments: (value, key, object).\r\n\t * \r\n\t * @param {object} obj \r\n\t * @param {function} func \r\n\t * @returns {object}\r\n\t */\r\n\tstatic mapObject(obj, func) {\r\n\t\t// Taken from lodash, see https://github.com/lodash/lodash/blob/master/mapObject.js\r\n\t\tconst props = Object.keys(obj);\r\n\t\tconst result = new Array(props.length);\r\n\t\tprops.forEach((key, index) => {\r\n\t\t\tresult[index] = func(obj[key], key, obj);\r\n\t\t});\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/**\r\n\t * Creates an object with the same keys as object and values generated by running each own enumerable string keyed property of object thru the function.\r\n\t * \r\n\t * The function is invoked with three arguments: (value, key, object).\r\n\t * \r\n\t * @param {object} obj \r\n\t * @param {function} func \r\n\t * @returns {object}\r\n\t */\r\n\tstatic mapObjectValues(obj, func) {\r\n\t\t// Taken from lodash, see https://github.com/lodash/lodash/blob/master/mapValue.js\r\n\t\tobj = Object(obj);\r\n\t\tconst result = {};\r\n\t\tObject.keys(obj).forEach((key) => {\r\n\t\t\tresult[key] = func(obj[key], key, obj);\r\n\t\t});\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a duplicate-free version of an array.\r\n\t * \r\n\t * If useEquals is set to true, uses the `Utils.equals` function for comparison instead of \r\n\t * the JS === operator. Thus, if the array contains objects, you likely want to set \r\n\t * `useEquals` to `true`.\r\n\t * \r\n\t * @param {array} array\r\n\t * @param {boolean} useEquals\r\n\t * @returns {array}\r\n\t */\r\n\tstatic unique(array, useEquals = false) {\r\n\t\tif (useEquals) {\r\n\t\t\treturn array.filter((s1, pos, arr) => arr.findIndex(s2 => Utils.equals(s1, s2)) === pos);\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn [...new Set(array)];\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * Computes the size of an array (number of array elements) or object (number of key-value-pairs).\r\n\t * \r\n\t * Returns 0 for all other data types.\r\n\t * \r\n\t * @param {*} obj \r\n\t * @returns {integer}\r\n\t */\r\n\tstatic size(obj) {\r\n\t\tif (typeof obj === 'object' && obj !== null) {\r\n\t\t\tif (Array.isArray(obj)) {\r\n\t\t\t\treturn obj.length;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\treturn Object.keys(obj).length;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks whether a variable is numeric.\r\n\t * \r\n\t * Numeric is every string with numeric data or a number, excluding NaN and finite numbers.\r\n\t * \r\n\t * @param {*} n - A variable to check.\r\n\t * @returns {boolean} - `true` is the given variable is numeric, `false` otherwise.\r\n\t */\r\n\tstatic isNumeric(n) {\r\n\t\treturn !isNaN(parseFloat(n)) && isFinite(n);\r\n    }\r\n    \r\n    /**\r\n     * Deep clone for JSON-compatible data.\r\n     * \r\n     * @param {*} x - The data to clone.\r\n     * @returns {*} - The cloned data.\r\n     */\r\n    static deepClone(x) {\r\n\t\treturn JSON.parse(JSON.stringify(x));\r\n    }\r\n\r\n\t/**\r\n\t * Normalize a URL (mostly handling leading and trailing slashes).\r\n\t * \r\n\t * @static\r\n\t * @param {string} baseUrl - The URL to normalize\r\n\t * @param {string} path - An optional path to add to the URL\r\n\t * @returns {string} Normalized URL.\r\n\t */\r\n\tstatic normalizeUrl(baseUrl, path = null) {\r\n\t\tlet url = baseUrl.replace(/\\/$/, \"\"); // Remove trailing slash from base URL\r\n\t\tif (typeof path === 'string') {\r\n\t\t\tif (path.substr(0, 1) !== '/') {\r\n\t\t\t\tpath = '/' + path; // Add leading slash to path\r\n\t\t\t}\r\n\t\t\turl = url + path.replace(/\\/$/, \"\"); // Remove trailing slash from path\r\n\t\t}\r\n\t\treturn url;\r\n\t}\r\n\r\n\t/**\r\n\t * Replaces placeholders in this format: `{var}`.\r\n\t * \r\n\t * This can be used for the placeholders/variables in the openEO API's errors.json file.\r\n\t * \r\n\t * @param {string} message - The string to replace the placeholders in.\r\n\t * @param {object} variables - A map with the placeholder names as keys and the replacement value as value.\r\n\t */\r\n\tstatic replacePlaceholders(message, variables = {}) {\r\n\t\tif (typeof message === 'string' && Utils.isObject(variables)) {\r\n\t\t\tfor(var placeholder in variables) {\r\n\t\t\t\tlet vars = variables[placeholder];\r\n\t\t\t\tmessage = message.replace('{' + placeholder + '}', Array.isArray(vars) ? vars.join(\"; \") : vars);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn message;\r\n\t}\r\n\r\n\t/**\r\n\t * Compares two strings case-insensitive, including natural ordering for numbers.\r\n\t * \r\n\t * @param {string} a \r\n\t * @param {string} b \r\n\t * @returns {integer} Numeric value compatible with the [Array.sort(fn) interface](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Parameters).\r\n\t */\r\n    static compareStringCaseInsensitive(a, b) {\r\n        if (typeof a !== 'string') {\r\n            a = String(a);\r\n        }\r\n        if (typeof b !== 'string') {\r\n            b = String(b);\r\n        }\r\n        return a.localeCompare(b, undefined, {numeric: true, sensitivity: 'base'});\r\n    }\r\n\r\n\t/**\r\n\t * Tries to make a string more readable by capitalizing it.\r\n\t * Only applies to words with more than two characters.\r\n\t * \r\n\t * Supports converting from:\r\n\t * - Snake Case (abc_def => Abc Def)\r\n\t * - Kebab Case (abc-def => Abc Def)\r\n\t * - Camel Case (abcDef => Abc Def)\r\n\t * \r\n\t * Doesn't capitalize if the words are not in any of the casing formats above.\r\n\t * \r\n\t * @param {*} strings - String(s) to make readable\r\n\t * @param {string} arraySep - String to separate array elements with\r\n\t * @returns {string}\r\n\t */\r\n    static prettifyString(strings, arraySep = '; ') {\r\n\t\tif (!Array.isArray(strings)) {\r\n\t\t\tstrings = [String(strings)];\r\n\t\t}\r\n\t\tstrings = strings.map(str => {\r\n\t\t\tif (str.length >= 3) {\r\n\t\t\t\tconst replacer = (_,a,b) => a + ' ' + b.toUpperCase();\r\n\t\t\t\tif (str.includes('_')) {\r\n\t\t\t\t\t// Snake case converter\r\n\t\t\t\t\tstr = str.replace(/([a-zA-Z\\d])_([a-zA-Z\\d])/g, replacer);\r\n\t\t\t\t}\r\n\t\t\t\telse if (str.includes('-')) {\r\n\t\t\t\t\t// Kebab case converter\r\n\t\t\t\t\tstr = str.replace(/([a-zA-Z\\d])-([a-zA-Z\\d])/g, replacer);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t// Camelcase converter\r\n\t\t\t\t\tstr = str.replace(/([a-z])([A-Z])/g, replacer);\r\n\t\t\t\t}\r\n\t\t\t\t// Uppercase the first letter in the first word, too.\r\n\t\t\t\treturn str.charAt(0).toUpperCase() + str.substr(1);\r\n\t\t\t}\r\n\t\t\treturn str;\r\n\t\t});\r\n\t\treturn strings.join(arraySep);\t\r\n    }\r\n\r\n\t/**\r\n\t * Makes link lists from the openEO API more user-friendly.\r\n\t * \r\n\t * Supports:\r\n\t * - Set a reasonable title, if not available. Make title more readable.\r\n\t * - Sorting by title (see `sort` parameter)\r\n\t * - Removing given relation types (`rel` property, see `ignoreRel` parameter)\r\n\t * \r\n\t * @param {array} linkList - List of links\r\n\t * @param {boolean} sort - Enable/Disable sorting by title. Enabled (true) by default.\r\n\t * @param {array} ignoreRel - A list of rel types to remove. By default, removes the self links (rel type = `self`).\r\n\t * @returns {array}\r\n\t */\r\n    static friendlyLinks(linkList, sort = true, ignoreRel = ['self']) {\r\n        let links = [];\r\n        if (!Array.isArray(linkList)) {\r\n            return links;\r\n        }\r\n\r\n        for(let link of linkList) {\r\n            link = Object.assign({}, link); // Make sure to work on a copy\r\n            if (typeof link.rel === 'string' && ignoreRel.includes(link.rel.toLowerCase())) {\r\n                continue;\r\n            }\r\n            if (typeof link.title !== 'string' || link.title.length === 0) {\r\n                if (typeof link.rel === 'string' && link.rel.length > 1) {\r\n                    link.title = Utils.prettifyString(link.rel);\r\n                }\r\n                else {\r\n                    link.title = link.href.replace(/^https?:\\/\\/(www.)?/i, '').replace(/\\/$/i, '');\r\n                }\r\n            }\r\n            links.push(link);\r\n        }\r\n        if (sort) {\r\n            links.sort((a, b) => Utils.compareStringCaseInsensitive(a.title, b.title));\r\n        }\r\n        return links;\r\n    }\r\n\r\n}\r\n\r\nmodule.exports = Utils;","const VersionCompare = require('compare-versions');\r\n\r\n/** Version Number related methods */\r\nclass Versions {\r\n\r\n  /**\r\n   * Compare [semver](https://semver.org/) version strings.\r\n   * \r\n   * @param {string} firstVersion First version to compare\r\n   * @param {string} secondVersion Second version to compare\r\n   * @param {string|null} operator Optional; Arithmetic operator to use (>, >=, =, <=, <, !=). Defaults to `null`.\r\n   * @returns {boolean|integer} If operator is not `null`: true` if the comparison between the firstVersion and the secondVersion satisfies the operator, `false` otherwise. If operator is `null`: Numeric value compatible with the [Array.sort(fn) interface](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Parameters).\r\n   * ```\r\n   */\r\n    static compare(v1, v2, operator = null) {\r\n\t\tif (operator !== null) {\r\n\t\t\treturn VersionCompare.compare(v1, v2, operator);\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn VersionCompare(v1, v2);\r\n\t\t}\r\n\t}\r\n\r\n  /**\r\n   * Validate [semver](https://semver.org/) version strings.\r\n   * \r\n   * @param {*} version - Version number to validate\r\n   * @returns - `true` if the version number is a valid semver version number, `false` otherwise.\r\n   */\r\n\tstatic validate(version) {\r\n\t\treturn VersionCompare.validate(version);\r\n\t}\r\n\r\n\t/**\r\n\t * Tries to determine the most suitable version from a well-known discovery document that software is compatible to.\r\n\t * \r\n\t * @static\r\n\t * @param {array} wkVersions - A well-known discovery document compliant to the API specification.\r\n\t * @param {boolean} preferProduction - Set to `false` to make no difference between production and non-production versions.\r\n\t * @param {string|null} minVersion - The minimum version that should be returned.\r\n\t * @param {string|null} maxVersion - The maximum version that should be returned.\r\n\t * @returns {object[]} - Gives a list that lists all compatible versions (as still API compliant objects) ordered from the most suitable to the least suitable.\r\n\t */\r\n\tstatic findCompatible(wkVersions, preferProduction = true, minVersion = null, maxVersion = null) {\r\n\t\tif (!Array.isArray(wkVersions) || wkVersions.length === 0) {\r\n\t\t\treturn [];\r\n\t\t}\r\n\r\n\t\tlet compatible = wkVersions.filter(c => {\r\n\t\t\tif (typeof c.url === 'string' && Versions.validate(c.api_version)) {\r\n\t\t\t\tlet hasMinVer = Versions.validate(minVersion);\r\n\t\t\t\tlet hasMaxVer = Versions.validate(maxVersion);\r\n\t\t\t\tif (hasMinVer && hasMaxVer) {\r\n\t\t\t\t\treturn Versions.compare(c.api_version, minVersion, \">=\") && Versions.compare(c.api_version, maxVersion, \"<=\");\r\n\t\t\t\t}\r\n\t\t\t\telse if (hasMinVer) {\r\n\t\t\t\t\treturn Versions.compare(c.api_version, minVersion, \">=\");\r\n\t\t\t\t}\r\n\t\t\t\telse if (hasMaxVer) {\r\n\t\t\t\t\treturn Versions.compare(c.api_version, maxVersion, \"<=\");\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t });\r\n\t\tif (compatible.length === 0) {\r\n\t\t\treturn [];\r\n\t\t}\r\n\r\n\t\treturn compatible.sort((c1, c2) => {\r\n\t\t\tlet p1 = c1.production === true;\r\n\t\t\tlet p2 = c2.production === true;\r\n\t\t\tif (!preferProduction || p1 === p2) {\r\n\t\t\t\treturn Versions.compare(c1.api_version, c2.api_version) * -1; // `* -1` to sort in descending order.\r\n\t\t\t}\r\n\t\t\telse if (p1) {\r\n\t\t\t\treturn -1;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\treturn 1;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Find the latest version from well-known discovery that applies to the specified rules.\r\n\t * \r\n\t * This is basically the same as calling `findCompatible` and using the first element from the result.\r\n\t * \r\n\t * @param {array} wkVersions - A well-known discovery document compliant to the API specification.\r\n\t * @param {boolean} preferProduction - Set to `false` to make no difference between production and non-production versions.\r\n\t * @param {string|null} minVersion - The minimum version that should be returned.\r\n\t * @param {string|null} maxVersion - The maximum version that should be returned.\r\n\t * @returns {object|null}\r\n\t */\r\n\tstatic findLatest(wkVersions, preferProduction = true, minVersion = null, maxVersion = null) {\r\n\t\tlet versions = Versions.findCompatible(wkVersions, preferProduction, minVersion, maxVersion);\r\n\t\tif (versions.length > 0) {\r\n\t\t\treturn versions[0];\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t}\r\n\t\r\n}\r\n\r\nmodule.exports = Versions;"],"names":["MigrateCapabilities","MigrateCollections","MigrateProcesses","ProcessDataType","ProcessParameter","ProcessSchema","ProcessUtils","ProcessRegistry","Versions","Utils","module","exports","MigrateCommons","NO_VERSION","guessApiVersion","capabilities","isObject","validate","api_version","version","Array","isArray","endpoints","find","e","path","backend_version","title","description","links","convertCapabilitiesToLatestSpec","originalCapabilities","updateVersionNumbers","updateEndpointPaths","id","this","compare","deepClone","billing","convertBillingToLatestSpec","convertEndpointsToLatestSpec","stac_version","production","migrateLinks","currency","updatePaths","isV04","isLtV100RC2","addPutToPg","newPgPath","i","findIndex","methods","indexOf","push","post","splice","patch","convertOutputFormatsToLatestSpec","formats","convertFileFormatsToLatestSpec","output","input","upgradeFileFormats","convertServiceTypesToLatestSpec","types","t","attributes","parameters","configuration","variables","process_parameters","map","v","param","name","variable_id","schema","type","default","migrateDiscoveryParameters","convertUdfRuntimesToLatestSpec","runtimes","r","docker","GIS_DATA_TYPES","gis_data_types","filter","includes","extMap","fieldMap","moveToRoot","DIMENSION_TYPES","convertCollectionsToLatestSpec","response","collections","c","convertCollectionToLatestSpec","originalCollection","collection","length","extent","spatial","bbox","temporal","interval","properties","other_properties","key","values","props","val","min","max","reduce","a","b","concat","summaries","slice","license","extensions","stac_extensions","ext","prefix","split","sort","fallbackRel","link","href","rel","example","examples","convertProcessesToLatestSpec","processes","p","convertProcessToLatestSpec","process","parameter_order","params","obj","Object","assign","required","optional","upgradeSchema","returns","arguments","isParam","moveMediaType","media_type","schemas","subSchema","renameFormat","contentMediaType","format","deprecated","paramSchema","subtype","constructor","parent","defaultValue","undefined","toJSON","isAny","dataType","isNull","nullable","isEditable","NON_EDITABLE","native","nativeType","nativeDataType","isEnum","enum","getEnumChoices","getCallbackParameters","additionalProperties","group","hasText","DEFAULT_GROUP","prettifyString","parameter","super","addNamespace","listeners","namespace","addAll","onChange","event","data","listener","add","fireEvent","Error","count","size","all","ns","hasNamespace","Boolean","namespaces","keys","has","get","remove","unspecified","normalizeJsonSchema","s","defaults","d","refs","is","dataTypes","nullIndex","includeNull","splitTypes","normalized","allOf","oneOf","anyOf","copy","omitFromObject","subSchemas","processParameter","keyPath","shift","getElementJsonSchema","cbParams","equals","getCallbackParametersForProcess","parameterName","getNativeTypesForJsonSchema","anyIsEmpty","validTypes","unique","JSON_SCHEMA_TYPES","items","additionalItems","equal","string","x","y","pickFromObject","toPick","forEach","toOmit","mapObject","func","result","index","mapObjectValues","array","useEquals","s1","pos","arr","s2","Set","isNumeric","n","isNaN","parseFloat","isFinite","JSON","parse","stringify","normalizeUrl","baseUrl","url","replace","substr","replacePlaceholders","message","placeholder","vars","join","compareStringCaseInsensitive","String","localeCompare","numeric","sensitivity","strings","arraySep","str","replacer","_","toUpperCase","charAt","friendlyLinks","linkList","ignoreRel","toLowerCase","VersionCompare","v1","v2","operator","findCompatible","wkVersions","preferProduction","minVersion","maxVersion","compatible","hasMinVer","hasMaxVer","c1","c2","p1","p2","findLatest","versions"],"sourceRoot":""}
{"version":3,"sources":["webpack:///./node_modules/ol/tilegrid/common.js","webpack:///./node_modules/ol/tilegrid.js","webpack:///./node_modules/ol/util.js","webpack:///./node_modules/ol/tilecoord.js","webpack:///./node_modules/ol/size.js","webpack:///./node_modules/ol/structs/LRUCache.js","webpack:///./node_modules/ol/source/State.js","webpack:///./node_modules/ol/tilegrid/TileGrid.js","webpack:///./node_modules/ol/sphere.js","webpack:///./node_modules/ol/string.js","webpack:///./node_modules/ol/source/Tile.js","webpack:///./node_modules/ol/source/GeoTIFF.js","webpack:///./node_modules/ol/source/DataTile.js","webpack:///./node_modules/ol/source/TileEventType.js","webpack:///./node_modules/ol/source/Source.js"],"names":["DEFAULT_MAX_ZOOM","DEFAULT_TILE_SIZE","getForProjection","projection","tileGrid","getDefaultTileGrid","createForProjection","setDefaultTileGrid","wrapX","tileCoord","z","center","getTileCoordCenter","projectionExtent","extentFromProjection","worldWidth","worldsAway","Math","ceil","getTileCoordForCoordAndZ","createForExtent","extent","opt_maxZoom","opt_tileSize","opt_corner","corner","undefined","TOP_LEFT","resolutions","resolutionsFromExtent","origin","tileSize","createXYZ","opt_options","xyzOptions","getExtent","gridOptions","minZoom","maxZoom","maxResolution","opt_maxResolution","height","width","max","length","Array","pow","half","DEGREES","getMetersPerUnit","abstract","Error","uidCounter_","getUid","obj","ol_uid","String","VERSION","createOrUpdate","x","y","opt_tileCoord","getKeyZXY","getKey","fromKey","key","split","map","Number","hash","withinExtentAndZ","getMinZoom","getMaxZoom","tileRange","getFullTileRange","containsXY","hasArea","size","scale","ratio","opt_size","toSize","isArray","LRUCache","opt_highWaterMark","this","highWaterMark","count_","entries_","oldest_","newest_","prototype","canExpireCache","getCount","expireCache","keep","pop","clear","containsKey","hasOwnProperty","forEach","f","entry","value_","key_","newer","get","older","remove","getKeys","keys","i","getValues","values","peekLast","peekLastKey","peekFirstKey","replace","value","set","setSize","UNDEFINED","LOADING","READY","ERROR","tmpTileCoord","DECIMALS","TileGrid","options","zoomFactor","resolutions_","a","b","origins","ii","zoomFactor_","origin_","origins_","tileSizes_","tileSizes","tileSize_","extent_","fullTileRanges_","tmpSize_","tmpExtent_","sizes","min","restrictedTileRange","getTileRangeForExtentAndZ","minX","maxX","minY","maxY","calculateTileRanges_","forEachTileCoord","zoom","callback","j","jj","forEachTileCoordParentTileRange","opt_tileRange","opt_extent","tileCoordExtent","getTileCoordExtent","floor","getOrigin","getResolution","getResolutions","getTileCoordChildTileRange","getTileRangeForTileCoordAndZ","tileCoordZ","tileCoordX","tileCoordY","factor","getTileRangeExtent","resolution","getTileSize","getTileCoordForXYAndZ_","getTileCoordForCoordAndResolution","coordinate","getTileCoordForXYAndResolution_","reverseIntersectionPolicy","getZForResolution","getTileCoordResolution","opt_direction","fullTileRanges","DEFAULT_RADIUS","getDistance","c1","c2","opt_radius","radius","lat1","lat2","deltaLatBy2","deltaLonBy2","sin","cos","atan2","sqrt","offset","distance","bearing","lon1","dByR","lat","asin","lon","padNumber","number","opt_precision","numberString","toFixed","decimal","indexOf","join","__extends","extendStatics","d","Object","setPrototypeOf","__proto__","p","call","TypeError","__","constructor","create","TileSource","_super","_this","attributions","attributionsCollapsible","state","interpolate","on","once","un","opaque_","opaque","tilePixelRatio_","tilePixelRatio","tileCache","cacheSize","tmpSize","tileOptions","transition","zDirection","usedTiles","getTileCacheForProjection","forEachLoadedTile","tile","tileCoordKey","loaded","covered","getState","LOADED","getGutterForProjection","setKey","changed","getOpaque","getTile","pixelRatio","getTileGrid","getTileGridForProjection","getProjection","getTilePixelRatio","getTilePixelSize","getTileCoordForTileUrlFunction","opt_projection","getWrapX","isGlobal","refresh","updateCacheSize","tileCount","useTile","TileSourceEvent","type","workerPool","DataTileSource","tileLoadingKeys_","loader_","loader","handleTileChange_","bind","bandCount","setLoader","sourceLoader","DataTile","addEventListener","EventType","CHANGE","event","uid","tileState","TileState","TileEventType","TILELOADSTART","TILELOADERROR","TILELOADEND","dispatchEvent","Tile","STATISTICS_MAXIMUM","STATISTICS_MINIMUM","getWorkerPool","getBoundingBox","image","_","fileDirectory","ImageWidth","ImageLength","slice","referenceImage","geoKeys","ProjectedCSTypeGeoKey","code","units","ProjLinearUnitsGeoKey","GeographicTypeGeoKey","GeogAngularUnitsGeoKey","getImagesForTIFF","tiff","getImageCount","then","count","requests","getImage","Promise","all","getImagesForSource","source","request","overviews","url","assertEqual","expected","got","tolerance","message","rejector","length_1","error","abs","getMinForDataType","array","Int8Array","Int16Array","Int32Array","Float32Array","getMaxForDataType","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","GeoTIFFSource","State","sourceInfo_","sources","numSources","sourceOptions_","sourceOptions","sourceImagery_","resolutionFactors_","samplesPerPixel_","nodataValues_","metadata_","normalize_","normalize","addAlpha_","error_","readMethod_","convertToRGB","self","configure_","catch","console","setState","getError","samplesPerPixel","nodataValues","metadata","sourceCount","_loop_1","sourceIndex","images","imageCount","sourceExtent","sourceOrigin","sourceTileSizes","sourceResolutions","imageIndex","nodataValue","getGDALNoData","getGDALMetadata","NaN","wantedSamples","this_1","bands","getSamplesPerPixel","level","getTileWidth","getTileHeight","concat","viewRejector","resolutionFactor_1","scaledSourceResolutions","reverse","sourceImagery","unshift","firstSource","outer","nodata","isNaN","additionalBands","reduce","accumulator","loadTile_","viewResolver","addAlpha","sourceInfo","_loop_2","resolutionFactor","this_2","pixelBounds","round","samples","bandNumber","fillValue","sampleIndex","window","pool","interleave","pixelCount","dataLength","sourceSamples","data","dataIndex","pixelIndex","transparent","gain","bias","stats","parseFloat","sourceValue","bandIndex","getView","Source","attributions_","adaptAttributions","attributionsCollapsible_","loading","state_","wrapX_","interpolate_","viewPromise_","resolve","reject","getAttributions","getAttributionsCollapsible","getInterpolate","setAttributions","attributionLike","frameState"],"mappings":"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","file":"js/chunk-190b0674.1468702d.js","sourcesContent":["/**\n * @module ol/tilegrid/common\n */\n/**\n * Default maximum zoom for default tile grids.\n * @type {number}\n */\nexport var DEFAULT_MAX_ZOOM = 42;\n/**\n * Default tile size.\n * @type {number}\n */\nexport var DEFAULT_TILE_SIZE = 256;\n//# sourceMappingURL=common.js.map","/**\n * @module ol/tilegrid\n */\nimport Corner from './extent/Corner.js';\nimport TileGrid from './tilegrid/TileGrid.js';\nimport Units from './proj/Units.js';\nimport { DEFAULT_MAX_ZOOM, DEFAULT_TILE_SIZE } from './tilegrid/common.js';\nimport { METERS_PER_UNIT, get as getProjection } from './proj.js';\nimport { containsCoordinate, createOrUpdate, getCorner, getHeight, getWidth, } from './extent.js';\nimport { toSize } from './size.js';\n/**\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {!TileGrid} Default tile grid for the\n * passed projection.\n */\nexport function getForProjection(projection) {\n    var tileGrid = projection.getDefaultTileGrid();\n    if (!tileGrid) {\n        tileGrid = createForProjection(projection);\n        projection.setDefaultTileGrid(tileGrid);\n    }\n    return tileGrid;\n}\n/**\n * @param {TileGrid} tileGrid Tile grid.\n * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {import(\"./tilecoord.js\").TileCoord} Tile coordinate.\n */\nexport function wrapX(tileGrid, tileCoord, projection) {\n    var z = tileCoord[0];\n    var center = tileGrid.getTileCoordCenter(tileCoord);\n    var projectionExtent = extentFromProjection(projection);\n    if (!containsCoordinate(projectionExtent, center)) {\n        var worldWidth = getWidth(projectionExtent);\n        var worldsAway = Math.ceil((projectionExtent[0] - center[0]) / worldWidth);\n        center[0] += worldWidth * worldsAway;\n        return tileGrid.getTileCoordForCoordAndZ(center, z);\n    }\n    else {\n        return tileCoord;\n    }\n}\n/**\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number} [opt_maxZoom] Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size} [opt_tileSize] Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {import(\"./extent/Corner.js\").default} [opt_corner] Extent corner (default is `'top-left'`).\n * @return {!TileGrid} TileGrid instance.\n */\nexport function createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner) {\n    var corner = opt_corner !== undefined ? opt_corner : Corner.TOP_LEFT;\n    var resolutions = resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize);\n    return new TileGrid({\n        extent: extent,\n        origin: getCorner(extent, corner),\n        resolutions: resolutions,\n        tileSize: opt_tileSize,\n    });\n}\n/**\n * @typedef {Object} XYZOptions\n * @property {import(\"./extent.js\").Extent} [extent] Extent for the tile grid. The origin for an XYZ tile grid is the\n * top-left corner of the extent. If `maxResolution` is not provided the zero level of the grid is defined by the resolution\n * at which one tile fits in the provided extent. If not provided, the extent of the EPSG:3857 projection is used.\n * @property {number} [maxResolution] Resolution at level zero.\n * @property {number} [maxZoom] Maximum zoom. The default is `42`. This determines the number of levels\n * in the grid set. For example, a `maxZoom` of 21 means there are 22 levels in the grid set.\n * @property {number} [minZoom=0] Minimum zoom.\n * @property {number|import(\"./size.js\").Size} [tileSize=[256, 256]] Tile size in pixels.\n */\n/**\n * Creates a tile grid with a standard XYZ tiling scheme.\n * @param {XYZOptions} [opt_options] Tile grid options.\n * @return {!TileGrid} Tile grid instance.\n * @api\n */\nexport function createXYZ(opt_options) {\n    var xyzOptions = opt_options || {};\n    var extent = xyzOptions.extent || getProjection('EPSG:3857').getExtent();\n    var gridOptions = {\n        extent: extent,\n        minZoom: xyzOptions.minZoom,\n        tileSize: xyzOptions.tileSize,\n        resolutions: resolutionsFromExtent(extent, xyzOptions.maxZoom, xyzOptions.tileSize, xyzOptions.maxResolution),\n    };\n    return new TileGrid(gridOptions);\n}\n/**\n * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number} [opt_maxZoom] Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size} [opt_tileSize] Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {number} [opt_maxResolution] Resolution at level zero.\n * @return {!Array<number>} Resolutions array.\n */\nfunction resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize, opt_maxResolution) {\n    var maxZoom = opt_maxZoom !== undefined ? opt_maxZoom : DEFAULT_MAX_ZOOM;\n    var height = getHeight(extent);\n    var width = getWidth(extent);\n    var tileSize = toSize(opt_tileSize !== undefined ? opt_tileSize : DEFAULT_TILE_SIZE);\n    var maxResolution = opt_maxResolution > 0\n        ? opt_maxResolution\n        : Math.max(width / tileSize[0], height / tileSize[1]);\n    var length = maxZoom + 1;\n    var resolutions = new Array(length);\n    for (var z = 0; z < length; ++z) {\n        resolutions[z] = maxResolution / Math.pow(2, z);\n    }\n    return resolutions;\n}\n/**\n * @param {import(\"./proj.js\").ProjectionLike} projection Projection.\n * @param {number} [opt_maxZoom] Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size} [opt_tileSize] Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {import(\"./extent/Corner.js\").default} [opt_corner] Extent corner (default is `'top-left'`).\n * @return {!TileGrid} TileGrid instance.\n */\nexport function createForProjection(projection, opt_maxZoom, opt_tileSize, opt_corner) {\n    var extent = extentFromProjection(projection);\n    return createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner);\n}\n/**\n * Generate a tile grid extent from a projection.  If the projection has an\n * extent, it is used.  If not, a global extent is assumed.\n * @param {import(\"./proj.js\").ProjectionLike} projection Projection.\n * @return {import(\"./extent.js\").Extent} Extent.\n */\nexport function extentFromProjection(projection) {\n    projection = getProjection(projection);\n    var extent = projection.getExtent();\n    if (!extent) {\n        var half = (180 * METERS_PER_UNIT[Units.DEGREES]) / projection.getMetersPerUnit();\n        extent = createOrUpdate(-half, -half, half, half);\n    }\n    return extent;\n}\n//# sourceMappingURL=tilegrid.js.map","/**\n * @module ol/util\n */\n/**\n * @return {?} Any return.\n */\nexport function abstract() {\n    return /** @type {?} */ ((function () {\n        throw new Error('Unimplemented abstract method.');\n    })());\n}\n/**\n * Counter for getUid.\n * @type {number}\n * @private\n */\nvar uidCounter_ = 0;\n/**\n * Gets a unique ID for an object. This mutates the object so that further calls\n * with the same object as a parameter returns the same value. Unique IDs are generated\n * as a strictly increasing sequence. Adapted from goog.getUid.\n *\n * @param {Object} obj The object to get the unique ID for.\n * @return {string} The unique ID for the object.\n * @api\n */\nexport function getUid(obj) {\n    return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));\n}\n/**\n * OpenLayers version.\n * @type {string}\n */\nexport var VERSION = '6.14.1';\n//# sourceMappingURL=util.js.map","/**\n * @module ol/tilecoord\n */\n/**\n * An array of three numbers representing the location of a tile in a tile\n * grid. The order is `z` (zoom level), `x` (column), and `y` (row).\n * @typedef {Array<number>} TileCoord\n * @api\n */\n/**\n * @param {number} z Z.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {TileCoord} [opt_tileCoord] Tile coordinate.\n * @return {TileCoord} Tile coordinate.\n */\nexport function createOrUpdate(z, x, y, opt_tileCoord) {\n    if (opt_tileCoord !== undefined) {\n        opt_tileCoord[0] = z;\n        opt_tileCoord[1] = x;\n        opt_tileCoord[2] = y;\n        return opt_tileCoord;\n    }\n    else {\n        return [z, x, y];\n    }\n}\n/**\n * @param {number} z Z.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {string} Key.\n */\nexport function getKeyZXY(z, x, y) {\n    return z + '/' + x + '/' + y;\n}\n/**\n * Get the key for a tile coord.\n * @param {TileCoord} tileCoord The tile coord.\n * @return {string} Key.\n */\nexport function getKey(tileCoord) {\n    return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);\n}\n/**\n * Get the tile cache key for a tile key obtained through `tile.getKey()`.\n * @param {string} tileKey The tile key.\n * @return {string} The cache key.\n */\nexport function getCacheKeyForTileKey(tileKey) {\n    var _a = tileKey\n        .substring(tileKey.lastIndexOf('/') + 1, tileKey.length)\n        .split(',')\n        .map(Number), z = _a[0], x = _a[1], y = _a[2];\n    return getKeyZXY(z, x, y);\n}\n/**\n * Get a tile coord given a key.\n * @param {string} key The tile coord key.\n * @return {TileCoord} The tile coord.\n */\nexport function fromKey(key) {\n    return key.split('/').map(Number);\n}\n/**\n * @param {TileCoord} tileCoord Tile coord.\n * @return {number} Hash.\n */\nexport function hash(tileCoord) {\n    return (tileCoord[1] << tileCoord[0]) + tileCoord[2];\n}\n/**\n * @param {TileCoord} tileCoord Tile coordinate.\n * @param {!import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {boolean} Tile coordinate is within extent and zoom level range.\n */\nexport function withinExtentAndZ(tileCoord, tileGrid) {\n    var z = tileCoord[0];\n    var x = tileCoord[1];\n    var y = tileCoord[2];\n    if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {\n        return false;\n    }\n    var tileRange = tileGrid.getFullTileRange(z);\n    if (!tileRange) {\n        return true;\n    }\n    else {\n        return tileRange.containsXY(x, y);\n    }\n}\n//# sourceMappingURL=tilecoord.js.map","/**\n * @module ol/size\n */\n/**\n * An array of numbers representing a size: `[width, height]`.\n * @typedef {Array<number>} Size\n * @api\n */\n/**\n * Returns a buffered size.\n * @param {Size} size Size.\n * @param {number} num The amount by which to buffer.\n * @param {Size} [opt_size] Optional reusable size array.\n * @return {Size} The buffered size.\n */\nexport function buffer(size, num, opt_size) {\n    if (opt_size === undefined) {\n        opt_size = [0, 0];\n    }\n    opt_size[0] = size[0] + 2 * num;\n    opt_size[1] = size[1] + 2 * num;\n    return opt_size;\n}\n/**\n * Determines if a size has a positive area.\n * @param {Size} size The size to test.\n * @return {boolean} The size has a positive area.\n */\nexport function hasArea(size) {\n    return size[0] > 0 && size[1] > 0;\n}\n/**\n * Returns a size scaled by a ratio. The result will be an array of integers.\n * @param {Size} size Size.\n * @param {number} ratio Ratio.\n * @param {Size} [opt_size] Optional reusable size array.\n * @return {Size} The scaled size.\n */\nexport function scale(size, ratio, opt_size) {\n    if (opt_size === undefined) {\n        opt_size = [0, 0];\n    }\n    opt_size[0] = (size[0] * ratio + 0.5) | 0;\n    opt_size[1] = (size[1] * ratio + 0.5) | 0;\n    return opt_size;\n}\n/**\n * Returns an `Size` array for the passed in number (meaning: square) or\n * `Size` array.\n * (meaning: non-square),\n * @param {number|Size} size Width and height.\n * @param {Size} [opt_size] Optional reusable size array.\n * @return {Size} Size.\n * @api\n */\nexport function toSize(size, opt_size) {\n    if (Array.isArray(size)) {\n        return size;\n    }\n    else {\n        if (opt_size === undefined) {\n            opt_size = [size, size];\n        }\n        else {\n            opt_size[0] = size;\n            opt_size[1] = size;\n        }\n        return opt_size;\n    }\n}\n//# sourceMappingURL=size.js.map","/**\n * @module ol/structs/LRUCache\n */\nimport { assert } from '../asserts.js';\n/**\n * @typedef {Object} Entry\n * @property {string} key_ Key.\n * @property {Object} newer Newer.\n * @property {Object} older Older.\n * @property {*} value_ Value.\n */\n/**\n * @classdesc\n * Implements a Least-Recently-Used cache where the keys do not conflict with\n * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring\n * items from the cache is the responsibility of the user.\n *\n * @fires import(\"../events/Event.js\").default\n * @template T\n */\nvar LRUCache = /** @class */ (function () {\n    /**\n     * @param {number} [opt_highWaterMark] High water mark.\n     */\n    function LRUCache(opt_highWaterMark) {\n        /**\n         * Desired max cache size after expireCache(). If set to 0, no cache entries\n         * will be pruned at all.\n         * @type {number}\n         */\n        this.highWaterMark =\n            opt_highWaterMark !== undefined ? opt_highWaterMark : 2048;\n        /**\n         * @private\n         * @type {number}\n         */\n        this.count_ = 0;\n        /**\n         * @private\n         * @type {!Object<string, Entry>}\n         */\n        this.entries_ = {};\n        /**\n         * @private\n         * @type {?Entry}\n         */\n        this.oldest_ = null;\n        /**\n         * @private\n         * @type {?Entry}\n         */\n        this.newest_ = null;\n    }\n    /**\n     * @return {boolean} Can expire cache.\n     */\n    LRUCache.prototype.canExpireCache = function () {\n        return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;\n    };\n    /**\n     * Expire the cache.\n     * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.\n     */\n    LRUCache.prototype.expireCache = function (keep) {\n        while (this.canExpireCache()) {\n            this.pop();\n        }\n    };\n    /**\n     * FIXME empty description for jsdoc\n     */\n    LRUCache.prototype.clear = function () {\n        this.count_ = 0;\n        this.entries_ = {};\n        this.oldest_ = null;\n        this.newest_ = null;\n    };\n    /**\n     * @param {string} key Key.\n     * @return {boolean} Contains key.\n     */\n    LRUCache.prototype.containsKey = function (key) {\n        return this.entries_.hasOwnProperty(key);\n    };\n    /**\n     * @param {function(T, string, LRUCache<T>): ?} f The function\n     *     to call for every entry from the oldest to the newer. This function takes\n     *     3 arguments (the entry value, the entry key and the LRUCache object).\n     *     The return value is ignored.\n     */\n    LRUCache.prototype.forEach = function (f) {\n        var entry = this.oldest_;\n        while (entry) {\n            f(entry.value_, entry.key_, this);\n            entry = entry.newer;\n        }\n    };\n    /**\n     * @param {string} key Key.\n     * @param {*} [opt_options] Options (reserved for subclasses).\n     * @return {T} Value.\n     */\n    LRUCache.prototype.get = function (key, opt_options) {\n        var entry = this.entries_[key];\n        assert(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache\n        if (entry === this.newest_) {\n            return entry.value_;\n        }\n        else if (entry === this.oldest_) {\n            this.oldest_ = /** @type {Entry} */ (this.oldest_.newer);\n            this.oldest_.older = null;\n        }\n        else {\n            entry.newer.older = entry.older;\n            entry.older.newer = entry.newer;\n        }\n        entry.newer = null;\n        entry.older = this.newest_;\n        this.newest_.newer = entry;\n        this.newest_ = entry;\n        return entry.value_;\n    };\n    /**\n     * Remove an entry from the cache.\n     * @param {string} key The entry key.\n     * @return {T} The removed entry.\n     */\n    LRUCache.prototype.remove = function (key) {\n        var entry = this.entries_[key];\n        assert(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache\n        if (entry === this.newest_) {\n            this.newest_ = /** @type {Entry} */ (entry.older);\n            if (this.newest_) {\n                this.newest_.newer = null;\n            }\n        }\n        else if (entry === this.oldest_) {\n            this.oldest_ = /** @type {Entry} */ (entry.newer);\n            if (this.oldest_) {\n                this.oldest_.older = null;\n            }\n        }\n        else {\n            entry.newer.older = entry.older;\n            entry.older.newer = entry.newer;\n        }\n        delete this.entries_[key];\n        --this.count_;\n        return entry.value_;\n    };\n    /**\n     * @return {number} Count.\n     */\n    LRUCache.prototype.getCount = function () {\n        return this.count_;\n    };\n    /**\n     * @return {Array<string>} Keys.\n     */\n    LRUCache.prototype.getKeys = function () {\n        var keys = new Array(this.count_);\n        var i = 0;\n        var entry;\n        for (entry = this.newest_; entry; entry = entry.older) {\n            keys[i++] = entry.key_;\n        }\n        return keys;\n    };\n    /**\n     * @return {Array<T>} Values.\n     */\n    LRUCache.prototype.getValues = function () {\n        var values = new Array(this.count_);\n        var i = 0;\n        var entry;\n        for (entry = this.newest_; entry; entry = entry.older) {\n            values[i++] = entry.value_;\n        }\n        return values;\n    };\n    /**\n     * @return {T} Last value.\n     */\n    LRUCache.prototype.peekLast = function () {\n        return this.oldest_.value_;\n    };\n    /**\n     * @return {string} Last key.\n     */\n    LRUCache.prototype.peekLastKey = function () {\n        return this.oldest_.key_;\n    };\n    /**\n     * Get the key of the newest item in the cache.  Throws if the cache is empty.\n     * @return {string} The newest key.\n     */\n    LRUCache.prototype.peekFirstKey = function () {\n        return this.newest_.key_;\n    };\n    /**\n     * @return {T} value Value.\n     */\n    LRUCache.prototype.pop = function () {\n        var entry = this.oldest_;\n        delete this.entries_[entry.key_];\n        if (entry.newer) {\n            entry.newer.older = null;\n        }\n        this.oldest_ = /** @type {Entry} */ (entry.newer);\n        if (!this.oldest_) {\n            this.newest_ = null;\n        }\n        --this.count_;\n        return entry.value_;\n    };\n    /**\n     * @param {string} key Key.\n     * @param {T} value Value.\n     */\n    LRUCache.prototype.replace = function (key, value) {\n        this.get(key); // update `newest_`\n        this.entries_[key].value_ = value;\n    };\n    /**\n     * @param {string} key Key.\n     * @param {T} value Value.\n     */\n    LRUCache.prototype.set = function (key, value) {\n        assert(!(key in this.entries_), 16); // Tried to set a value for a key that is used already\n        var entry = {\n            key_: key,\n            newer: null,\n            older: this.newest_,\n            value_: value,\n        };\n        if (!this.newest_) {\n            this.oldest_ = entry;\n        }\n        else {\n            this.newest_.newer = entry;\n        }\n        this.newest_ = entry;\n        this.entries_[key] = entry;\n        ++this.count_;\n    };\n    /**\n     * Set a maximum number of entries for the cache.\n     * @param {number} size Cache size.\n     * @api\n     */\n    LRUCache.prototype.setSize = function (size) {\n        this.highWaterMark = size;\n    };\n    return LRUCache;\n}());\nexport default LRUCache;\n//# sourceMappingURL=LRUCache.js.map","/**\n * @module ol/source/State\n */\n/**\n * @enum {string}\n * State of the source, one of 'undefined', 'loading', 'ready' or 'error'.\n */\nexport default {\n    UNDEFINED: 'undefined',\n    LOADING: 'loading',\n    READY: 'ready',\n    ERROR: 'error',\n};\n//# sourceMappingURL=State.js.map","/**\n * @module ol/tilegrid/TileGrid\n */\nimport TileRange, { createOrUpdate as createOrUpdateTileRange, } from '../TileRange.js';\nimport { DEFAULT_TILE_SIZE } from './common.js';\nimport { assert } from '../asserts.js';\nimport { ceil, clamp, floor } from '../math.js';\nimport { createOrUpdate, getTopLeft } from '../extent.js';\nimport { createOrUpdate as createOrUpdateTileCoord } from '../tilecoord.js';\nimport { isSorted, linearFindNearest } from '../array.js';\nimport { toSize } from '../size.js';\n/**\n * @private\n * @type {import(\"../tilecoord.js\").TileCoord}\n */\nvar tmpTileCoord = [0, 0, 0];\n/**\n * Number of decimal digits to consider in integer values when rounding.\n * @type {number}\n */\nvar DECIMALS = 5;\n/**\n * @typedef {Object} Options\n * @property {import(\"../extent.js\").Extent} [extent] Extent for the tile grid. No tiles outside this\n * extent will be requested by {@link module:ol/source/Tile~TileSource} sources. When no `origin` or\n * `origins` are configured, the `origin` will be set to the top-left corner of the extent.\n * @property {number} [minZoom=0] Minimum zoom.\n * @property {import(\"../coordinate.js\").Coordinate} [origin] The tile grid origin, i.e. where the `x`\n * and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left to right and downwards. If not\n * specified, `extent` or `origins` must be provided.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} [origins] Tile grid origins, i.e. where\n * the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If given, the array length\n * should match the length of the `resolutions` array, i.e. each resolution can have a different\n * origin. Tile coordinates increase left to right and downwards. If not specified, `extent` or\n * `origin` must be provided.\n * @property {!Array<number>} resolutions Resolutions. The array index of each resolution needs\n * to match the zoom level. This means that even if a `minZoom` is configured, the resolutions\n * array will have a length of `maxZoom + 1`.\n * @property {Array<import(\"../size.js\").Size>} [sizes] Number of tile rows and columns\n * of the grid for each zoom level. If specified the values\n * define each zoom level's extent together with the `origin` or `origins`.\n * A grid `extent` can be configured in addition, and will further limit the extent\n * for which tile requests are made by sources. If the bottom-left corner of\n * an extent is used as `origin` or `origins`, then the `y` value must be\n * negative because OpenLayers tile coordinates use the top left as the origin.\n * @property {number|import(\"../size.js\").Size} [tileSize] Tile size.\n * Default is `[256, 256]`.\n * @property {Array<import(\"../size.js\").Size>} [tileSizes] Tile sizes. If given, the array length\n * should match the length of the `resolutions` array, i.e. each resolution can have a different\n * tile size.\n */\n/**\n * @classdesc\n * Base class for setting the grid pattern for sources accessing tiled-image\n * servers.\n * @api\n */\nvar TileGrid = /** @class */ (function () {\n    /**\n     * @param {Options} options Tile grid options.\n     */\n    function TileGrid(options) {\n        /**\n         * @protected\n         * @type {number}\n         */\n        this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;\n        /**\n         * @private\n         * @type {!Array<number>}\n         */\n        this.resolutions_ = options.resolutions;\n        assert(isSorted(this.resolutions_, function (a, b) {\n            return b - a;\n        }, true), 17); // `resolutions` must be sorted in descending order\n        // check if we've got a consistent zoom factor and origin\n        var zoomFactor;\n        if (!options.origins) {\n            for (var i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {\n                if (!zoomFactor) {\n                    zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];\n                }\n                else {\n                    if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {\n                        zoomFactor = undefined;\n                        break;\n                    }\n                }\n            }\n        }\n        /**\n         * @private\n         * @type {number|undefined}\n         */\n        this.zoomFactor_ = zoomFactor;\n        /**\n         * @protected\n         * @type {number}\n         */\n        this.maxZoom = this.resolutions_.length - 1;\n        /**\n         * @private\n         * @type {import(\"../coordinate.js\").Coordinate|null}\n         */\n        this.origin_ = options.origin !== undefined ? options.origin : null;\n        /**\n         * @private\n         * @type {Array<import(\"../coordinate.js\").Coordinate>}\n         */\n        this.origins_ = null;\n        if (options.origins !== undefined) {\n            this.origins_ = options.origins;\n            assert(this.origins_.length == this.resolutions_.length, 20); // Number of `origins` and `resolutions` must be equal\n        }\n        var extent = options.extent;\n        if (extent !== undefined && !this.origin_ && !this.origins_) {\n            this.origin_ = getTopLeft(extent);\n        }\n        assert((!this.origin_ && this.origins_) || (this.origin_ && !this.origins_), 18); // Either `origin` or `origins` must be configured, never both\n        /**\n         * @private\n         * @type {Array<number|import(\"../size.js\").Size>}\n         */\n        this.tileSizes_ = null;\n        if (options.tileSizes !== undefined) {\n            this.tileSizes_ = options.tileSizes;\n            assert(this.tileSizes_.length == this.resolutions_.length, 19); // Number of `tileSizes` and `resolutions` must be equal\n        }\n        /**\n         * @private\n         * @type {number|import(\"../size.js\").Size}\n         */\n        this.tileSize_ =\n            options.tileSize !== undefined\n                ? options.tileSize\n                : !this.tileSizes_\n                    ? DEFAULT_TILE_SIZE\n                    : null;\n        assert((!this.tileSize_ && this.tileSizes_) ||\n            (this.tileSize_ && !this.tileSizes_), 22); // Either `tileSize` or `tileSizes` must be configured, never both\n        /**\n         * @private\n         * @type {import(\"../extent.js\").Extent}\n         */\n        this.extent_ = extent !== undefined ? extent : null;\n        /**\n         * @private\n         * @type {Array<import(\"../TileRange.js\").default>}\n         */\n        this.fullTileRanges_ = null;\n        /**\n         * @private\n         * @type {import(\"../size.js\").Size}\n         */\n        this.tmpSize_ = [0, 0];\n        /**\n         * @private\n         * @type {import(\"../extent.js\").Extent}\n         */\n        this.tmpExtent_ = [0, 0, 0, 0];\n        if (options.sizes !== undefined) {\n            this.fullTileRanges_ = options.sizes.map(function (size, z) {\n                var tileRange = new TileRange(Math.min(0, size[0]), Math.max(size[0] - 1, -1), Math.min(0, size[1]), Math.max(size[1] - 1, -1));\n                if (extent) {\n                    var restrictedTileRange = this.getTileRangeForExtentAndZ(extent, z);\n                    tileRange.minX = Math.max(restrictedTileRange.minX, tileRange.minX);\n                    tileRange.maxX = Math.min(restrictedTileRange.maxX, tileRange.maxX);\n                    tileRange.minY = Math.max(restrictedTileRange.minY, tileRange.minY);\n                    tileRange.maxY = Math.min(restrictedTileRange.maxY, tileRange.maxY);\n                }\n                return tileRange;\n            }, this);\n        }\n        else if (extent) {\n            this.calculateTileRanges_(extent);\n        }\n    }\n    /**\n     * Call a function with each tile coordinate for a given extent and zoom level.\n     *\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @param {number} zoom Integer zoom level.\n     * @param {function(import(\"../tilecoord.js\").TileCoord): void} callback Function called with each tile coordinate.\n     * @api\n     */\n    TileGrid.prototype.forEachTileCoord = function (extent, zoom, callback) {\n        var tileRange = this.getTileRangeForExtentAndZ(extent, zoom);\n        for (var i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {\n            for (var j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {\n                callback([zoom, i, j]);\n            }\n        }\n    };\n    /**\n     * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n     * @param {function(number, import(\"../TileRange.js\").default): boolean} callback Callback.\n     * @param {import(\"../TileRange.js\").default} [opt_tileRange] Temporary import(\"../TileRange.js\").default object.\n     * @param {import(\"../extent.js\").Extent} [opt_extent] Temporary import(\"../extent.js\").Extent object.\n     * @return {boolean} Callback succeeded.\n     */\n    TileGrid.prototype.forEachTileCoordParentTileRange = function (tileCoord, callback, opt_tileRange, opt_extent) {\n        var tileRange, x, y;\n        var tileCoordExtent = null;\n        var z = tileCoord[0] - 1;\n        if (this.zoomFactor_ === 2) {\n            x = tileCoord[1];\n            y = tileCoord[2];\n        }\n        else {\n            tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);\n        }\n        while (z >= this.minZoom) {\n            if (this.zoomFactor_ === 2) {\n                x = Math.floor(x / 2);\n                y = Math.floor(y / 2);\n                tileRange = createOrUpdateTileRange(x, x, y, y, opt_tileRange);\n            }\n            else {\n                tileRange = this.getTileRangeForExtentAndZ(tileCoordExtent, z, opt_tileRange);\n            }\n            if (callback(z, tileRange)) {\n                return true;\n            }\n            --z;\n        }\n        return false;\n    };\n    /**\n     * Get the extent for this tile grid, if it was configured.\n     * @return {import(\"../extent.js\").Extent} Extent.\n     * @api\n     */\n    TileGrid.prototype.getExtent = function () {\n        return this.extent_;\n    };\n    /**\n     * Get the maximum zoom level for the grid.\n     * @return {number} Max zoom.\n     * @api\n     */\n    TileGrid.prototype.getMaxZoom = function () {\n        return this.maxZoom;\n    };\n    /**\n     * Get the minimum zoom level for the grid.\n     * @return {number} Min zoom.\n     * @api\n     */\n    TileGrid.prototype.getMinZoom = function () {\n        return this.minZoom;\n    };\n    /**\n     * Get the origin for the grid at the given zoom level.\n     * @param {number} z Integer zoom level.\n     * @return {import(\"../coordinate.js\").Coordinate} Origin.\n     * @api\n     */\n    TileGrid.prototype.getOrigin = function (z) {\n        if (this.origin_) {\n            return this.origin_;\n        }\n        else {\n            return this.origins_[z];\n        }\n    };\n    /**\n     * Get the resolution for the given zoom level.\n     * @param {number} z Integer zoom level.\n     * @return {number} Resolution.\n     * @api\n     */\n    TileGrid.prototype.getResolution = function (z) {\n        return this.resolutions_[z];\n    };\n    /**\n     * Get the list of resolutions for the tile grid.\n     * @return {Array<number>} Resolutions.\n     * @api\n     */\n    TileGrid.prototype.getResolutions = function () {\n        return this.resolutions_;\n    };\n    /**\n     * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n     * @param {import(\"../TileRange.js\").default} [opt_tileRange] Temporary import(\"../TileRange.js\").default object.\n     * @param {import(\"../extent.js\").Extent} [opt_extent] Temporary import(\"../extent.js\").Extent object.\n     * @return {import(\"../TileRange.js\").default} Tile range.\n     */\n    TileGrid.prototype.getTileCoordChildTileRange = function (tileCoord, opt_tileRange, opt_extent) {\n        if (tileCoord[0] < this.maxZoom) {\n            if (this.zoomFactor_ === 2) {\n                var minX = tileCoord[1] * 2;\n                var minY = tileCoord[2] * 2;\n                return createOrUpdateTileRange(minX, minX + 1, minY, minY + 1, opt_tileRange);\n            }\n            var tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent || this.tmpExtent_);\n            return this.getTileRangeForExtentAndZ(tileCoordExtent, tileCoord[0] + 1, opt_tileRange);\n        }\n        return null;\n    };\n    /**\n     * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n     * @param {number} z Integer zoom level.\n     * @param {import(\"../TileRange.js\").default} [opt_tileRange] Temporary import(\"../TileRange.js\").default object.\n     * @return {import(\"../TileRange.js\").default} Tile range.\n     */\n    TileGrid.prototype.getTileRangeForTileCoordAndZ = function (tileCoord, z, opt_tileRange) {\n        if (z > this.maxZoom || z < this.minZoom) {\n            return null;\n        }\n        var tileCoordZ = tileCoord[0];\n        var tileCoordX = tileCoord[1];\n        var tileCoordY = tileCoord[2];\n        if (z === tileCoordZ) {\n            return createOrUpdateTileRange(tileCoordX, tileCoordY, tileCoordX, tileCoordY, opt_tileRange);\n        }\n        if (this.zoomFactor_) {\n            var factor = Math.pow(this.zoomFactor_, z - tileCoordZ);\n            var minX = Math.floor(tileCoordX * factor);\n            var minY = Math.floor(tileCoordY * factor);\n            if (z < tileCoordZ) {\n                return createOrUpdateTileRange(minX, minX, minY, minY, opt_tileRange);\n            }\n            var maxX = Math.floor(factor * (tileCoordX + 1)) - 1;\n            var maxY = Math.floor(factor * (tileCoordY + 1)) - 1;\n            return createOrUpdateTileRange(minX, maxX, minY, maxY, opt_tileRange);\n        }\n        var tileCoordExtent = this.getTileCoordExtent(tileCoord, this.tmpExtent_);\n        return this.getTileRangeForExtentAndZ(tileCoordExtent, z, opt_tileRange);\n    };\n    /**\n     * Get the extent for a tile range.\n     * @param {number} z Integer zoom level.\n     * @param {import(\"../TileRange.js\").default} tileRange Tile range.\n     * @param {import(\"../extent.js\").Extent} [opt_extent] Temporary import(\"../extent.js\").Extent object.\n     * @return {import(\"../extent.js\").Extent} Extent.\n     */\n    TileGrid.prototype.getTileRangeExtent = function (z, tileRange, opt_extent) {\n        var origin = this.getOrigin(z);\n        var resolution = this.getResolution(z);\n        var tileSize = toSize(this.getTileSize(z), this.tmpSize_);\n        var minX = origin[0] + tileRange.minX * tileSize[0] * resolution;\n        var maxX = origin[0] + (tileRange.maxX + 1) * tileSize[0] * resolution;\n        var minY = origin[1] + tileRange.minY * tileSize[1] * resolution;\n        var maxY = origin[1] + (tileRange.maxY + 1) * tileSize[1] * resolution;\n        return createOrUpdate(minX, minY, maxX, maxY, opt_extent);\n    };\n    /**\n     * Get a tile range for the given extent and integer zoom level.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @param {number} z Integer zoom level.\n     * @param {import(\"../TileRange.js\").default} [opt_tileRange] Temporary tile range object.\n     * @return {import(\"../TileRange.js\").default} Tile range.\n     */\n    TileGrid.prototype.getTileRangeForExtentAndZ = function (extent, z, opt_tileRange) {\n        var tileCoord = tmpTileCoord;\n        this.getTileCoordForXYAndZ_(extent[0], extent[3], z, false, tileCoord);\n        var minX = tileCoord[1];\n        var minY = tileCoord[2];\n        this.getTileCoordForXYAndZ_(extent[2], extent[1], z, true, tileCoord);\n        return createOrUpdateTileRange(minX, tileCoord[1], minY, tileCoord[2], opt_tileRange);\n    };\n    /**\n     * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n     * @return {import(\"../coordinate.js\").Coordinate} Tile center.\n     */\n    TileGrid.prototype.getTileCoordCenter = function (tileCoord) {\n        var origin = this.getOrigin(tileCoord[0]);\n        var resolution = this.getResolution(tileCoord[0]);\n        var tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\n        return [\n            origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution,\n            origin[1] - (tileCoord[2] + 0.5) * tileSize[1] * resolution,\n        ];\n    };\n    /**\n     * Get the extent of a tile coordinate.\n     *\n     * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n     * @param {import(\"../extent.js\").Extent} [opt_extent] Temporary extent object.\n     * @return {import(\"../extent.js\").Extent} Extent.\n     * @api\n     */\n    TileGrid.prototype.getTileCoordExtent = function (tileCoord, opt_extent) {\n        var origin = this.getOrigin(tileCoord[0]);\n        var resolution = this.getResolution(tileCoord[0]);\n        var tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\n        var minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;\n        var minY = origin[1] - (tileCoord[2] + 1) * tileSize[1] * resolution;\n        var maxX = minX + tileSize[0] * resolution;\n        var maxY = minY + tileSize[1] * resolution;\n        return createOrUpdate(minX, minY, maxX, maxY, opt_extent);\n    };\n    /**\n     * Get the tile coordinate for the given map coordinate and resolution.  This\n     * method considers that coordinates that intersect tile boundaries should be\n     * assigned the higher tile coordinate.\n     *\n     * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @param {number} resolution Resolution.\n     * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Destination import(\"../tilecoord.js\").TileCoord object.\n     * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n     * @api\n     */\n    TileGrid.prototype.getTileCoordForCoordAndResolution = function (coordinate, resolution, opt_tileCoord) {\n        return this.getTileCoordForXYAndResolution_(coordinate[0], coordinate[1], resolution, false, opt_tileCoord);\n    };\n    /**\n     * Note that this method should not be called for resolutions that correspond\n     * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {number} resolution Resolution (for a non-integer zoom level).\n     * @param {boolean} reverseIntersectionPolicy Instead of letting edge\n     *     intersections go to the higher tile coordinate, let edge intersections\n     *     go to the lower tile coordinate.\n     * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Temporary import(\"../tilecoord.js\").TileCoord object.\n     * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n     * @private\n     */\n    TileGrid.prototype.getTileCoordForXYAndResolution_ = function (x, y, resolution, reverseIntersectionPolicy, opt_tileCoord) {\n        var z = this.getZForResolution(resolution);\n        var scale = resolution / this.getResolution(z);\n        var origin = this.getOrigin(z);\n        var tileSize = toSize(this.getTileSize(z), this.tmpSize_);\n        var tileCoordX = (scale * (x - origin[0])) / resolution / tileSize[0];\n        var tileCoordY = (scale * (origin[1] - y)) / resolution / tileSize[1];\n        if (reverseIntersectionPolicy) {\n            tileCoordX = ceil(tileCoordX, DECIMALS) - 1;\n            tileCoordY = ceil(tileCoordY, DECIMALS) - 1;\n        }\n        else {\n            tileCoordX = floor(tileCoordX, DECIMALS);\n            tileCoordY = floor(tileCoordY, DECIMALS);\n        }\n        return createOrUpdateTileCoord(z, tileCoordX, tileCoordY, opt_tileCoord);\n    };\n    /**\n     * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,\n     * they should have separate implementations.  This method is for integer zoom\n     * levels.  The other method should only be called for resolutions corresponding\n     * to non-integer zoom levels.\n     * @param {number} x Map x coordinate.\n     * @param {number} y Map y coordinate.\n     * @param {number} z Integer zoom level.\n     * @param {boolean} reverseIntersectionPolicy Instead of letting edge\n     *     intersections go to the higher tile coordinate, let edge intersections\n     *     go to the lower tile coordinate.\n     * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Temporary import(\"../tilecoord.js\").TileCoord object.\n     * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n     * @private\n     */\n    TileGrid.prototype.getTileCoordForXYAndZ_ = function (x, y, z, reverseIntersectionPolicy, opt_tileCoord) {\n        var origin = this.getOrigin(z);\n        var resolution = this.getResolution(z);\n        var tileSize = toSize(this.getTileSize(z), this.tmpSize_);\n        var tileCoordX = (x - origin[0]) / resolution / tileSize[0];\n        var tileCoordY = (origin[1] - y) / resolution / tileSize[1];\n        if (reverseIntersectionPolicy) {\n            tileCoordX = ceil(tileCoordX, DECIMALS) - 1;\n            tileCoordY = ceil(tileCoordY, DECIMALS) - 1;\n        }\n        else {\n            tileCoordX = floor(tileCoordX, DECIMALS);\n            tileCoordY = floor(tileCoordY, DECIMALS);\n        }\n        return createOrUpdateTileCoord(z, tileCoordX, tileCoordY, opt_tileCoord);\n    };\n    /**\n     * Get a tile coordinate given a map coordinate and zoom level.\n     * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @param {number} z Zoom level.\n     * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Destination import(\"../tilecoord.js\").TileCoord object.\n     * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n     * @api\n     */\n    TileGrid.prototype.getTileCoordForCoordAndZ = function (coordinate, z, opt_tileCoord) {\n        return this.getTileCoordForXYAndZ_(coordinate[0], coordinate[1], z, false, opt_tileCoord);\n    };\n    /**\n     * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n     * @return {number} Tile resolution.\n     */\n    TileGrid.prototype.getTileCoordResolution = function (tileCoord) {\n        return this.resolutions_[tileCoord[0]];\n    };\n    /**\n     * Get the tile size for a zoom level. The type of the return value matches the\n     * `tileSize` or `tileSizes` that the tile grid was configured with. To always\n     * get an {@link import(\"../size.js\").Size}, run the result through {@link module:ol/size.toSize}.\n     * @param {number} z Z.\n     * @return {number|import(\"../size.js\").Size} Tile size.\n     * @api\n     */\n    TileGrid.prototype.getTileSize = function (z) {\n        if (this.tileSize_) {\n            return this.tileSize_;\n        }\n        else {\n            return this.tileSizes_[z];\n        }\n    };\n    /**\n     * @param {number} z Zoom level.\n     * @return {import(\"../TileRange.js\").default} Extent tile range for the specified zoom level.\n     */\n    TileGrid.prototype.getFullTileRange = function (z) {\n        if (!this.fullTileRanges_) {\n            return this.extent_\n                ? this.getTileRangeForExtentAndZ(this.extent_, z)\n                : null;\n        }\n        else {\n            return this.fullTileRanges_[z];\n        }\n    };\n    /**\n     * @param {number} resolution Resolution.\n     * @param {number|import(\"../array.js\").NearestDirectionFunction} [opt_direction]\n     *     If 0, the nearest resolution will be used.\n     *     If 1, the nearest higher resolution (lower Z) will be used. If -1, the\n     *     nearest lower resolution (higher Z) will be used. Default is 0.\n     *     Use a {@link module:ol/array~NearestDirectionFunction} for more precise control.\n     *\n     * For example to change tile Z at the midpoint of zoom levels\n     * ```js\n     * function(value, high, low) {\n     *   return value - low * Math.sqrt(high / low);\n     * }\n     * ```\n     * @return {number} Z.\n     * @api\n     */\n    TileGrid.prototype.getZForResolution = function (resolution, opt_direction) {\n        var z = linearFindNearest(this.resolutions_, resolution, opt_direction || 0);\n        return clamp(z, this.minZoom, this.maxZoom);\n    };\n    /**\n     * @param {!import(\"../extent.js\").Extent} extent Extent for this tile grid.\n     * @private\n     */\n    TileGrid.prototype.calculateTileRanges_ = function (extent) {\n        var length = this.resolutions_.length;\n        var fullTileRanges = new Array(length);\n        for (var z = this.minZoom; z < length; ++z) {\n            fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);\n        }\n        this.fullTileRanges_ = fullTileRanges;\n    };\n    return TileGrid;\n}());\nexport default TileGrid;\n//# sourceMappingURL=TileGrid.js.map","/**\n * @module ol/sphere\n */\nimport GeometryType from './geom/GeometryType.js';\nimport { toDegrees, toRadians } from './math.js';\n/**\n * Object literal with options for the {@link getLength} or {@link getArea}\n * functions.\n * @typedef {Object} SphereMetricOptions\n * @property {import(\"./proj.js\").ProjectionLike} [projection='EPSG:3857']\n * Projection of the  geometry.  By default, the geometry is assumed to be in\n * Web Mercator.\n * @property {number} [radius=6371008.8] Sphere radius.  By default, the\n * [mean Earth radius](https://en.wikipedia.org/wiki/Earth_radius#Mean_radius)\n * for the WGS84 ellipsoid is used.\n */\n/**\n * The mean Earth radius (1/3 * (2a + b)) for the WGS84 ellipsoid.\n * https://en.wikipedia.org/wiki/Earth_radius#Mean_radius\n * @type {number}\n */\nexport var DEFAULT_RADIUS = 6371008.8;\n/**\n * Get the great circle distance (in meters) between two geographic coordinates.\n * @param {Array} c1 Starting coordinate.\n * @param {Array} c2 Ending coordinate.\n * @param {number} [opt_radius] The sphere radius to use.  Defaults to the Earth's\n *     mean radius using the WGS84 ellipsoid.\n * @return {number} The great circle distance between the points (in meters).\n * @api\n */\nexport function getDistance(c1, c2, opt_radius) {\n    var radius = opt_radius || DEFAULT_RADIUS;\n    var lat1 = toRadians(c1[1]);\n    var lat2 = toRadians(c2[1]);\n    var deltaLatBy2 = (lat2 - lat1) / 2;\n    var deltaLonBy2 = toRadians(c2[0] - c1[0]) / 2;\n    var a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) +\n        Math.sin(deltaLonBy2) *\n            Math.sin(deltaLonBy2) *\n            Math.cos(lat1) *\n            Math.cos(lat2);\n    return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n}\n/**\n * Get the cumulative great circle length of linestring coordinates (geographic).\n * @param {Array} coordinates Linestring coordinates.\n * @param {number} radius The sphere radius to use.\n * @return {number} The length (in meters).\n */\nfunction getLengthInternal(coordinates, radius) {\n    var length = 0;\n    for (var i = 0, ii = coordinates.length; i < ii - 1; ++i) {\n        length += getDistance(coordinates[i], coordinates[i + 1], radius);\n    }\n    return length;\n}\n/**\n * Get the spherical length of a geometry.  This length is the sum of the\n * great circle distances between coordinates.  For polygons, the length is\n * the sum of all rings.  For points, the length is zero.  For multi-part\n * geometries, the length is the sum of the length of each part.\n * @param {import(\"./geom/Geometry.js\").default} geometry A geometry.\n * @param {SphereMetricOptions} [opt_options] Options for the\n * length calculation.  By default, geometries are assumed to be in 'EPSG:3857'.\n * You can change this by providing a `projection` option.\n * @return {number} The spherical length (in meters).\n * @api\n */\nexport function getLength(geometry, opt_options) {\n    var options = opt_options || {};\n    var radius = options.radius || DEFAULT_RADIUS;\n    var projection = options.projection || 'EPSG:3857';\n    var type = geometry.getType();\n    if (type !== GeometryType.GEOMETRY_COLLECTION) {\n        geometry = geometry.clone().transform(projection, 'EPSG:4326');\n    }\n    var length = 0;\n    var coordinates, coords, i, ii, j, jj;\n    switch (type) {\n        case GeometryType.POINT:\n        case GeometryType.MULTI_POINT: {\n            break;\n        }\n        case GeometryType.LINE_STRING:\n        case GeometryType.LINEAR_RING: {\n            coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (geometry).getCoordinates();\n            length = getLengthInternal(coordinates, radius);\n            break;\n        }\n        case GeometryType.MULTI_LINE_STRING:\n        case GeometryType.POLYGON: {\n            coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (geometry).getCoordinates();\n            for (i = 0, ii = coordinates.length; i < ii; ++i) {\n                length += getLengthInternal(coordinates[i], radius);\n            }\n            break;\n        }\n        case GeometryType.MULTI_POLYGON: {\n            coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (geometry).getCoordinates();\n            for (i = 0, ii = coordinates.length; i < ii; ++i) {\n                coords = coordinates[i];\n                for (j = 0, jj = coords.length; j < jj; ++j) {\n                    length += getLengthInternal(coords[j], radius);\n                }\n            }\n            break;\n        }\n        case GeometryType.GEOMETRY_COLLECTION: {\n            var geometries = \n            /** @type {import(\"./geom/GeometryCollection.js\").default} */ (geometry).getGeometries();\n            for (i = 0, ii = geometries.length; i < ii; ++i) {\n                length += getLength(geometries[i], opt_options);\n            }\n            break;\n        }\n        default: {\n            throw new Error('Unsupported geometry type: ' + type);\n        }\n    }\n    return length;\n}\n/**\n * Returns the spherical area for a list of coordinates.\n *\n * [Reference](https://trs.jpl.nasa.gov/handle/2014/40409)\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for\n * Polygons on a Sphere\", JPL Publication 07-03, Jet Propulsion\n * Laboratory, Pasadena, CA, June 2007\n *\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates List of coordinates of a linear\n * ring. If the ring is oriented clockwise, the area will be positive,\n * otherwise it will be negative.\n * @param {number} radius The sphere radius.\n * @return {number} Area (in square meters).\n */\nfunction getAreaInternal(coordinates, radius) {\n    var area = 0;\n    var len = coordinates.length;\n    var x1 = coordinates[len - 1][0];\n    var y1 = coordinates[len - 1][1];\n    for (var i = 0; i < len; i++) {\n        var x2 = coordinates[i][0];\n        var y2 = coordinates[i][1];\n        area +=\n            toRadians(x2 - x1) *\n                (2 + Math.sin(toRadians(y1)) + Math.sin(toRadians(y2)));\n        x1 = x2;\n        y1 = y2;\n    }\n    return (area * radius * radius) / 2.0;\n}\n/**\n * Get the spherical area of a geometry.  This is the area (in meters) assuming\n * that polygon edges are segments of great circles on a sphere.\n * @param {import(\"./geom/Geometry.js\").default} geometry A geometry.\n * @param {SphereMetricOptions} [opt_options] Options for the area\n *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.\n *     You can change this by providing a `projection` option.\n * @return {number} The spherical area (in square meters).\n * @api\n */\nexport function getArea(geometry, opt_options) {\n    var options = opt_options || {};\n    var radius = options.radius || DEFAULT_RADIUS;\n    var projection = options.projection || 'EPSG:3857';\n    var type = geometry.getType();\n    if (type !== GeometryType.GEOMETRY_COLLECTION) {\n        geometry = geometry.clone().transform(projection, 'EPSG:4326');\n    }\n    var area = 0;\n    var coordinates, coords, i, ii, j, jj;\n    switch (type) {\n        case GeometryType.POINT:\n        case GeometryType.MULTI_POINT:\n        case GeometryType.LINE_STRING:\n        case GeometryType.MULTI_LINE_STRING:\n        case GeometryType.LINEAR_RING: {\n            break;\n        }\n        case GeometryType.POLYGON: {\n            coordinates = /** @type {import(\"./geom/Polygon.js\").default} */ (geometry).getCoordinates();\n            area = Math.abs(getAreaInternal(coordinates[0], radius));\n            for (i = 1, ii = coordinates.length; i < ii; ++i) {\n                area -= Math.abs(getAreaInternal(coordinates[i], radius));\n            }\n            break;\n        }\n        case GeometryType.MULTI_POLYGON: {\n            coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (geometry).getCoordinates();\n            for (i = 0, ii = coordinates.length; i < ii; ++i) {\n                coords = coordinates[i];\n                area += Math.abs(getAreaInternal(coords[0], radius));\n                for (j = 1, jj = coords.length; j < jj; ++j) {\n                    area -= Math.abs(getAreaInternal(coords[j], radius));\n                }\n            }\n            break;\n        }\n        case GeometryType.GEOMETRY_COLLECTION: {\n            var geometries = \n            /** @type {import(\"./geom/GeometryCollection.js\").default} */ (geometry).getGeometries();\n            for (i = 0, ii = geometries.length; i < ii; ++i) {\n                area += getArea(geometries[i], opt_options);\n            }\n            break;\n        }\n        default: {\n            throw new Error('Unsupported geometry type: ' + type);\n        }\n    }\n    return area;\n}\n/**\n * Returns the coordinate at the given distance and bearing from `c1`.\n *\n * @param {import(\"./coordinate.js\").Coordinate} c1 The origin point (`[lon, lat]` in degrees).\n * @param {number} distance The great-circle distance between the origin\n *     point and the target point.\n * @param {number} bearing The bearing (in radians).\n * @param {number} [opt_radius] The sphere radius to use.  Defaults to the Earth's\n *     mean radius using the WGS84 ellipsoid.\n * @return {import(\"./coordinate.js\").Coordinate} The target point.\n */\nexport function offset(c1, distance, bearing, opt_radius) {\n    var radius = opt_radius || DEFAULT_RADIUS;\n    var lat1 = toRadians(c1[1]);\n    var lon1 = toRadians(c1[0]);\n    var dByR = distance / radius;\n    var lat = Math.asin(Math.sin(lat1) * Math.cos(dByR) +\n        Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing));\n    var lon = lon1 +\n        Math.atan2(Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1), Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat));\n    return [toDegrees(lon), toDegrees(lat)];\n}\n//# sourceMappingURL=sphere.js.map","/**\n * @module ol/string\n */\n/**\n * @param {number} number Number to be formatted\n * @param {number} width The desired width\n * @param {number} [opt_precision] Precision of the output string (i.e. number of decimal places)\n * @return {string} Formatted string\n */\nexport function padNumber(number, width, opt_precision) {\n    var numberString = opt_precision !== undefined ? number.toFixed(opt_precision) : '' + number;\n    var decimal = numberString.indexOf('.');\n    decimal = decimal === -1 ? numberString.length : decimal;\n    return decimal > width\n        ? numberString\n        : new Array(1 + width - decimal).join('0') + numberString;\n}\n/**\n * Adapted from https://github.com/omichelsen/compare-versions/blob/master/index.js\n * @param {string|number} v1 First version\n * @param {string|number} v2 Second version\n * @return {number} Value\n */\nexport function compareVersions(v1, v2) {\n    var s1 = ('' + v1).split('.');\n    var s2 = ('' + v2).split('.');\n    for (var i = 0; i < Math.max(s1.length, s2.length); i++) {\n        var n1 = parseInt(s1[i] || '0', 10);\n        var n2 = parseInt(s2[i] || '0', 10);\n        if (n1 > n2) {\n            return 1;\n        }\n        if (n2 > n1) {\n            return -1;\n        }\n    }\n    return 0;\n}\n//# sourceMappingURL=string.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/source/Tile\n */\nimport Event from '../events/Event.js';\nimport Source from './Source.js';\nimport TileCache from '../TileCache.js';\nimport TileState from '../TileState.js';\nimport { abstract } from '../util.js';\nimport { assert } from '../asserts.js';\nimport { equivalent } from '../proj.js';\nimport { getKeyZXY, withinExtentAndZ } from '../tilecoord.js';\nimport { getForProjection as getTileGridForProjection, wrapX, } from '../tilegrid.js';\nimport { scale as scaleSize, toSize } from '../size.js';\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types, import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./TileEventType\").TileSourceEventTypes, TileSourceEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     import(\"./TileEventType\").TileSourceEventTypes, Return>} TileSourceOnSignature\n */\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] CacheSize.\n * @property {boolean} [opaque=false] Whether the layer is opaque.\n * @property {number} [tilePixelRatio] TilePixelRatio.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection.\n * @property {import(\"./State.js\").default} [state] State.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] TileGrid.\n * @property {boolean} [wrapX=false] WrapX.\n * @property {number} [transition] Transition.\n * @property {string} [key] Key.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0] ZDirection.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n */\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for sources providing images divided into a tile grid.\n * @abstract\n * @api\n */\nvar TileSource = /** @class */ (function (_super) {\n    __extends(TileSource, _super);\n    /**\n     * @param {Options} options SourceTile source options.\n     */\n    function TileSource(options) {\n        var _this = _super.call(this, {\n            attributions: options.attributions,\n            attributionsCollapsible: options.attributionsCollapsible,\n            projection: options.projection,\n            state: options.state,\n            wrapX: options.wrapX,\n            interpolate: options.interpolate,\n        }) || this;\n        /***\n         * @type {TileSourceOnSignature<import(\"../events\").EventsKey>}\n         */\n        _this.on;\n        /***\n         * @type {TileSourceOnSignature<import(\"../events\").EventsKey>}\n         */\n        _this.once;\n        /***\n         * @type {TileSourceOnSignature<void>}\n         */\n        _this.un;\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _this.opaque_ = options.opaque !== undefined ? options.opaque : false;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.tilePixelRatio_ =\n            options.tilePixelRatio !== undefined ? options.tilePixelRatio : 1;\n        /**\n         * @type {import(\"../tilegrid/TileGrid.js\").default|null}\n         */\n        _this.tileGrid = options.tileGrid !== undefined ? options.tileGrid : null;\n        var tileSize = [256, 256];\n        if (_this.tileGrid) {\n            toSize(_this.tileGrid.getTileSize(_this.tileGrid.getMinZoom()), tileSize);\n        }\n        /**\n         * @protected\n         * @type {import(\"../TileCache.js\").default}\n         */\n        _this.tileCache = new TileCache(options.cacheSize || 0);\n        /**\n         * @protected\n         * @type {import(\"../size.js\").Size}\n         */\n        _this.tmpSize = [0, 0];\n        /**\n         * @private\n         * @type {string}\n         */\n        _this.key_ = options.key || '';\n        /**\n         * @protected\n         * @type {import(\"../Tile.js\").Options}\n         */\n        _this.tileOptions = {\n            transition: options.transition,\n            interpolate: options.interpolate,\n        };\n        /**\n         * zDirection hint, read by the renderer. Indicates which resolution should be used\n         * by a renderer if the views resolution does not match any resolution of the tile source.\n         * If 0, the nearest resolution will be used. If 1, the nearest lower resolution\n         * will be used. If -1, the nearest higher resolution will be used.\n         * @type {number|import(\"../array.js\").NearestDirectionFunction}\n         */\n        _this.zDirection = options.zDirection ? options.zDirection : 0;\n        return _this;\n    }\n    /**\n     * @return {boolean} Can expire cache.\n     */\n    TileSource.prototype.canExpireCache = function () {\n        return this.tileCache.canExpireCache();\n    };\n    /**\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @param {!Object<string, boolean>} usedTiles Used tiles.\n     */\n    TileSource.prototype.expireCache = function (projection, usedTiles) {\n        var tileCache = this.getTileCacheForProjection(projection);\n        if (tileCache) {\n            tileCache.expireCache(usedTiles);\n        }\n    };\n    /**\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @param {number} z Zoom level.\n     * @param {import(\"../TileRange.js\").default} tileRange Tile range.\n     * @param {function(import(\"../Tile.js\").default):(boolean|void)} callback Called with each\n     *     loaded tile.  If the callback returns `false`, the tile will not be\n     *     considered loaded.\n     * @return {boolean} The tile range is fully covered with loaded tiles.\n     */\n    TileSource.prototype.forEachLoadedTile = function (projection, z, tileRange, callback) {\n        var tileCache = this.getTileCacheForProjection(projection);\n        if (!tileCache) {\n            return false;\n        }\n        var covered = true;\n        var tile, tileCoordKey, loaded;\n        for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {\n            for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {\n                tileCoordKey = getKeyZXY(z, x, y);\n                loaded = false;\n                if (tileCache.containsKey(tileCoordKey)) {\n                    tile = /** @type {!import(\"../Tile.js\").default} */ (tileCache.get(tileCoordKey));\n                    loaded = tile.getState() === TileState.LOADED;\n                    if (loaded) {\n                        loaded = callback(tile) !== false;\n                    }\n                }\n                if (!loaded) {\n                    covered = false;\n                }\n            }\n        }\n        return covered;\n    };\n    /**\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @return {number} Gutter.\n     */\n    TileSource.prototype.getGutterForProjection = function (projection) {\n        return 0;\n    };\n    /**\n     * Return the key to be used for all tiles in the source.\n     * @return {string} The key for all tiles.\n     */\n    TileSource.prototype.getKey = function () {\n        return this.key_;\n    };\n    /**\n     * Set the value to be used as the key for all tiles in the source.\n     * @param {string} key The key for tiles.\n     * @protected\n     */\n    TileSource.prototype.setKey = function (key) {\n        if (this.key_ !== key) {\n            this.key_ = key;\n            this.changed();\n        }\n    };\n    /**\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @return {boolean} Opaque.\n     */\n    TileSource.prototype.getOpaque = function (projection) {\n        return this.opaque_;\n    };\n    /**\n     * @return {Array<number>|null} Resolutions.\n     */\n    TileSource.prototype.getResolutions = function () {\n        if (!this.tileGrid) {\n            return null;\n        }\n        return this.tileGrid.getResolutions();\n    };\n    /**\n     * @abstract\n     * @param {number} z Tile coordinate z.\n     * @param {number} x Tile coordinate x.\n     * @param {number} y Tile coordinate y.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @return {!import(\"../Tile.js\").default} Tile.\n     */\n    TileSource.prototype.getTile = function (z, x, y, pixelRatio, projection) {\n        return abstract();\n    };\n    /**\n     * Return the tile grid of the tile source.\n     * @return {import(\"../tilegrid/TileGrid.js\").default|null} Tile grid.\n     * @api\n     */\n    TileSource.prototype.getTileGrid = function () {\n        return this.tileGrid;\n    };\n    /**\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n     */\n    TileSource.prototype.getTileGridForProjection = function (projection) {\n        if (!this.tileGrid) {\n            return getTileGridForProjection(projection);\n        }\n        else {\n            return this.tileGrid;\n        }\n    };\n    /**\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @return {import(\"../TileCache.js\").default} Tile cache.\n     * @protected\n     */\n    TileSource.prototype.getTileCacheForProjection = function (projection) {\n        assert(equivalent(this.getProjection(), projection), 68 // A VectorTile source can only be rendered if it has a projection compatible with the view projection.\n        );\n        return this.tileCache;\n    };\n    /**\n     * Get the tile pixel ratio for this source. Subclasses may override this\n     * method, which is meant to return a supported pixel ratio that matches the\n     * provided `pixelRatio` as close as possible.\n     * @param {number} pixelRatio Pixel ratio.\n     * @return {number} Tile pixel ratio.\n     */\n    TileSource.prototype.getTilePixelRatio = function (pixelRatio) {\n        return this.tilePixelRatio_;\n    };\n    /**\n     * @param {number} z Z.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @return {import(\"../size.js\").Size} Tile size.\n     */\n    TileSource.prototype.getTilePixelSize = function (z, pixelRatio, projection) {\n        var tileGrid = this.getTileGridForProjection(projection);\n        var tilePixelRatio = this.getTilePixelRatio(pixelRatio);\n        var tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);\n        if (tilePixelRatio == 1) {\n            return tileSize;\n        }\n        else {\n            return scaleSize(tileSize, tilePixelRatio, this.tmpSize);\n        }\n    };\n    /**\n     * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate\n     * is outside the resolution and extent range of the tile grid, `null` will be\n     * returned.\n     * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n     * @param {import(\"../proj/Projection.js\").default} [opt_projection] Projection.\n     * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate to be passed to the tileUrlFunction or\n     *     null if no tile URL should be created for the passed `tileCoord`.\n     */\n    TileSource.prototype.getTileCoordForTileUrlFunction = function (tileCoord, opt_projection) {\n        var projection = opt_projection !== undefined ? opt_projection : this.getProjection();\n        var tileGrid = this.getTileGridForProjection(projection);\n        if (this.getWrapX() && projection.isGlobal()) {\n            tileCoord = wrapX(tileGrid, tileCoord, projection);\n        }\n        return withinExtentAndZ(tileCoord, tileGrid) ? tileCoord : null;\n    };\n    /**\n     * Remove all cached tiles from the source. The next render cycle will fetch new tiles.\n     * @api\n     */\n    TileSource.prototype.clear = function () {\n        this.tileCache.clear();\n    };\n    TileSource.prototype.refresh = function () {\n        this.clear();\n        _super.prototype.refresh.call(this);\n    };\n    /**\n     * Increases the cache size if needed\n     * @param {number} tileCount Minimum number of tiles needed.\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     */\n    TileSource.prototype.updateCacheSize = function (tileCount, projection) {\n        var tileCache = this.getTileCacheForProjection(projection);\n        if (tileCount > tileCache.highWaterMark) {\n            tileCache.highWaterMark = tileCount;\n        }\n    };\n    /**\n     * Marks a tile coord as being used, without triggering a load.\n     * @abstract\n     * @param {number} z Tile coordinate z.\n     * @param {number} x Tile coordinate x.\n     * @param {number} y Tile coordinate y.\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     */\n    TileSource.prototype.useTile = function (z, x, y, projection) { };\n    return TileSource;\n}(Source));\n/**\n * @classdesc\n * Events emitted by {@link module:ol/source/Tile~TileSource} instances are instances of this\n * type.\n */\nvar TileSourceEvent = /** @class */ (function (_super) {\n    __extends(TileSourceEvent, _super);\n    /**\n     * @param {string} type Type.\n     * @param {import(\"../Tile.js\").default} tile The tile.\n     */\n    function TileSourceEvent(type, tile) {\n        var _this = _super.call(this, type) || this;\n        /**\n         * The tile related to the event.\n         * @type {import(\"../Tile.js\").default}\n         * @api\n         */\n        _this.tile = tile;\n        return _this;\n    }\n    return TileSourceEvent;\n}(Event));\nexport { TileSourceEvent };\nexport default TileSource;\n//# sourceMappingURL=Tile.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/source/GeoTIFF\n */\nimport DataTile from './DataTile.js';\nimport State from './State.js';\nimport TileGrid from '../tilegrid/TileGrid.js';\nimport { Pool, fromUrl as tiffFromUrl, fromUrls as tiffFromUrls } from 'geotiff';\nimport { Projection, get as getCachedProjection, toUserCoordinate, toUserExtent, } from '../proj.js';\nimport { clamp } from '../math.js';\nimport { getCenter, getIntersection } from '../extent.js';\nimport { toSize } from '../size.js';\nimport { fromCode as unitsFromCode } from '../proj/Units.js';\n/**\n * @typedef {Object} SourceInfo\n * @property {string} url URL for the source GeoTIFF.\n * @property {Array<string>} [overviews] List of any overview URLs.\n * @property {number} [min=0] The minimum source data value.  Rendered values are scaled from 0 to 1 based on\n * the configured min and max.  If not provided and raster statistics are available, those will be used instead.\n * If neither are available, the minimum for the data type will be used.  To disable this behavior, set\n * the `normalize` option to `false` in the constructor.\n * @property {number} [max] The maximum source data value.  Rendered values are scaled from 0 to 1 based on\n * the configured min and max.  If not provided and raster statistics are available, those will be used instead.\n * If neither are available, the maximum for the data type will be used.  To disable this behavior, set\n * the `normalize` option to `false` in the constructor.\n * @property {number} [nodata] Values to discard (overriding any nodata values in the metadata).\n * When provided, an additional alpha band will be added to the data.  Often the GeoTIFF metadata\n * will include information about nodata values, so you should only need to set this property if\n * you find that it is not already extracted from the metadata.\n * @property {Array<number>} [bands] Band numbers to be read from (where the first band is `1`). If not provided, all bands will\n * be read. For example, if a GeoTIFF has blue (1), green (2), red (3), and near-infrared (4) bands, and you only need the\n * near-infrared band, configure `bands: [4]`.\n */\n/**\n * @typedef {Object} GeoKeys\n * @property {number} GTModelTypeGeoKey Model type.\n * @property {number} GTRasterTypeGeoKey Raster type.\n * @property {number} GeogAngularUnitsGeoKey Angular units.\n * @property {number} GeogInvFlatteningGeoKey Inverse flattening.\n * @property {number} GeogSemiMajorAxisGeoKey Semi-major axis.\n * @property {number} GeographicTypeGeoKey Geographic coordinate system code.\n * @property {number} ProjLinearUnitsGeoKey Projected linear unit code.\n * @property {number} ProjectedCSTypeGeoKey Projected coordinate system code.\n */\n/**\n * @typedef {import(\"geotiff\").GeoTIFF} GeoTIFF\n */\n/**\n * @typedef {import(\"geotiff\").MultiGeoTIFF} MultiGeoTIFF\n */\n/**\n * @typedef {Object} GDALMetadata\n * @property {string} STATISTICS_MINIMUM The minimum value (as a string).\n * @property {string} STATISTICS_MAXIMUM The maximum value (as a string).\n */\nvar STATISTICS_MAXIMUM = 'STATISTICS_MAXIMUM';\nvar STATISTICS_MINIMUM = 'STATISTICS_MINIMUM';\n/**\n * @typedef {import(\"geotiff\").GeoTIFFImage} GeoTIFFImage\n */\nvar workerPool;\nfunction getWorkerPool() {\n    if (!workerPool) {\n        workerPool = new Pool();\n    }\n    return workerPool;\n}\n/**\n * Get the bounding box of an image.  If the image does not have an affine transform,\n * the pixel bounds are returned.\n * @param {GeoTIFFImage} image The image.\n * @return {Array<number>} The image bounding box.\n */\nfunction getBoundingBox(image) {\n    try {\n        return image.getBoundingBox();\n    }\n    catch (_) {\n        var fileDirectory = image.fileDirectory;\n        return [0, 0, fileDirectory.ImageWidth, fileDirectory.ImageLength];\n    }\n}\n/**\n * Get the origin of an image.  If the image does not have an affine transform,\n * the top-left corner of the pixel bounds is returned.\n * @param {GeoTIFFImage} image The image.\n * @return {Array<number>} The image origin.\n */\nfunction getOrigin(image) {\n    try {\n        return image.getOrigin().slice(0, 2);\n    }\n    catch (_) {\n        return [0, image.fileDirectory.ImageLength];\n    }\n}\n/**\n * Get the resolution of an image.  If the image does not have an affine transform,\n * the width of the image is compared with the reference image.\n * @param {GeoTIFFImage} image The image.\n * @param {GeoTIFFImage} referenceImage The reference image.\n * @return {number} The image resolution.\n */\nfunction getResolution(image, referenceImage) {\n    try {\n        return image.getResolution(referenceImage)[0];\n    }\n    catch (_) {\n        return (referenceImage.fileDirectory.ImageWidth / image.fileDirectory.ImageWidth);\n    }\n}\n/**\n * @param {GeoTIFFImage} image A GeoTIFF.\n * @return {import(\"../proj/Projection.js\").default} The image projection.\n */\nfunction getProjection(image) {\n    var geoKeys = image.geoKeys;\n    if (!geoKeys) {\n        return null;\n    }\n    if (geoKeys.ProjectedCSTypeGeoKey) {\n        var code = 'EPSG:' + geoKeys.ProjectedCSTypeGeoKey;\n        var projection = getCachedProjection(code);\n        if (!projection) {\n            var units = unitsFromCode(geoKeys.ProjLinearUnitsGeoKey);\n            if (units) {\n                projection = new Projection({\n                    code: code,\n                    units: units,\n                });\n            }\n        }\n        return projection;\n    }\n    if (geoKeys.GeographicTypeGeoKey) {\n        var code = 'EPSG:' + geoKeys.GeographicTypeGeoKey;\n        var projection = getCachedProjection(code);\n        if (!projection) {\n            var units = unitsFromCode(geoKeys.GeogAngularUnitsGeoKey);\n            if (units) {\n                projection = new Projection({\n                    code: code,\n                    units: units,\n                });\n            }\n        }\n        return projection;\n    }\n    return null;\n}\n/**\n * @param {GeoTIFF|MultiGeoTIFF} tiff A GeoTIFF.\n * @return {Promise<Array<GeoTIFFImage>>} Resolves to a list of images.\n */\nfunction getImagesForTIFF(tiff) {\n    return tiff.getImageCount().then(function (count) {\n        var requests = new Array(count);\n        for (var i = 0; i < count; ++i) {\n            requests[i] = tiff.getImage(i);\n        }\n        return Promise.all(requests);\n    });\n}\n/**\n * @param {SourceInfo} source The GeoTIFF source.\n * @param {object} options Options for the GeoTIFF source.\n * @return {Promise<Array<GeoTIFFImage>>} Resolves to a list of images.\n */\nfunction getImagesForSource(source, options) {\n    var request;\n    if (source.overviews) {\n        request = tiffFromUrls(source.url, source.overviews, options);\n    }\n    else {\n        request = tiffFromUrl(source.url, options);\n    }\n    return request.then(getImagesForTIFF);\n}\n/**\n * @param {number|Array<number>|Array<Array<number>>} expected Expected value.\n * @param {number|Array<number>|Array<Array<number>>} got Actual value.\n * @param {number} tolerance Accepted tolerance in fraction of expected between expected and got.\n * @param {string} message The error message.\n * @param {function(Error):void} rejector A function to be called with any error.\n */\nfunction assertEqual(expected, got, tolerance, message, rejector) {\n    if (Array.isArray(expected)) {\n        var length_1 = expected.length;\n        if (!Array.isArray(got) || length_1 != got.length) {\n            var error = new Error(message);\n            rejector(error);\n            throw error;\n        }\n        for (var i = 0; i < length_1; ++i) {\n            assertEqual(expected[i], got[i], tolerance, message, rejector);\n        }\n        return;\n    }\n    got = /** @type {number} */ (got);\n    if (Math.abs(expected - got) > tolerance * expected) {\n        throw new Error(message);\n    }\n}\n/**\n * @param {Array} array The data array.\n * @return {number} The minimum value.\n */\nfunction getMinForDataType(array) {\n    if (array instanceof Int8Array) {\n        return -128;\n    }\n    if (array instanceof Int16Array) {\n        return -32768;\n    }\n    if (array instanceof Int32Array) {\n        return -2147483648;\n    }\n    if (array instanceof Float32Array) {\n        return 1.2e-38;\n    }\n    return 0;\n}\n/**\n * @param {Array} array The data array.\n * @return {number} The maximum value.\n */\nfunction getMaxForDataType(array) {\n    if (array instanceof Int8Array) {\n        return 127;\n    }\n    if (array instanceof Uint8Array) {\n        return 255;\n    }\n    if (array instanceof Uint8ClampedArray) {\n        return 255;\n    }\n    if (array instanceof Int16Array) {\n        return 32767;\n    }\n    if (array instanceof Uint16Array) {\n        return 65535;\n    }\n    if (array instanceof Int32Array) {\n        return 2147483647;\n    }\n    if (array instanceof Uint32Array) {\n        return 4294967295;\n    }\n    if (array instanceof Float32Array) {\n        return 3.4e38;\n    }\n    return 255;\n}\n/**\n * @typedef {Object} GeoTIFFSourceOptions\n * @property {boolean} [forceXHR=false] Whether to force the usage of the browsers XMLHttpRequest API.\n * @property {Object<string, string>} [headers] additional key-value pairs of headers to be passed with each request. Key is the header name, value the header value.\n * @property {string} [credentials] How credentials shall be handled. See\n * https://developer.mozilla.org/en-US/docs/Web/API/fetch for reference and possible values\n * @property {number} [maxRanges] The maximum amount of ranges to request in a single multi-range request.\n * By default only a single range is used.\n * @property {boolean} [allowFullFile=false] Whether or not a full file is accepted when only a portion is\n * requested. Only use this when you know the source image to be small enough to fit in memory.\n * @property {number} [blockSize=65536] The block size to use.\n * @property {number} [cacheSize=100] The number of blocks that shall be held in a LRU cache.\n */\n/**\n * @typedef {Object} Options\n * @property {Array<SourceInfo>} sources List of information about GeoTIFF sources.\n * Multiple sources can be combined when their resolution sets are equal after applying a scale.\n * The list of sources defines a mapping between input bands as they are read from each GeoTIFF and\n * the output bands that are provided by data tiles. To control which bands to read from each GeoTIFF,\n * use the {@link import(\"./GeoTIFF.js\").SourceInfo bands} property. If, for example, you specify two\n * sources, one with 3 bands and {@link import(\"./GeoTIFF.js\").SourceInfo nodata} configured, and\n * another with 1 band, the resulting data tiles will have 5 bands: 3 from the first source, 1 alpha\n * band from the first source, and 1 band from the second source.\n * @property {GeoTIFFSourceOptions} [sourceOptions] Additional options to be passed to [geotiff.js](https://geotiffjs.github.io/geotiff.js/module-geotiff.html)'s `fromUrl` or `fromUrls` methods.\n * @property {boolean} [convertToRGB = false] By default, bands from the sources are read as-is. When\n * reading GeoTIFFs with the purpose of displaying them as RGB images, setting this to `true` will\n * convert other color spaces (YCbCr, CMYK) to RGB.\n * @property {boolean} [normalize=true] By default, the source data is normalized to values between\n * 0 and 1 with scaling factors based on the raster statistics or `min` and `max` properties of each source.\n * If instead you want to work with the raw values in a style expression, set this to `false`.  Setting this option\n * to `false` will make it so any `min` and `max` properties on sources are ignored.\n * @property {boolean} [opaque=false] Whether the layer is opaque.\n * @property {number} [transition=250] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {boolean} [wrapX=false] Render tiles beyond the tile grid extent.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * the linear interpolation is used to resample the data.  If false, nearest neighbor is used.\n */\n/**\n * @classdesc\n * A source for working with GeoTIFF data.\n * @api\n */\nvar GeoTIFFSource = /** @class */ (function (_super) {\n    __extends(GeoTIFFSource, _super);\n    /**\n     * @param {Options} options Data tile options.\n     */\n    function GeoTIFFSource(options) {\n        var _this = _super.call(this, {\n            state: State.LOADING,\n            tileGrid: null,\n            projection: null,\n            opaque: options.opaque,\n            transition: options.transition,\n            interpolate: options.interpolate !== false,\n            wrapX: options.wrapX,\n        }) || this;\n        /**\n         * @type {Array<SourceInfo>}\n         * @private\n         */\n        _this.sourceInfo_ = options.sources;\n        var numSources = _this.sourceInfo_.length;\n        /**\n         * @type {object}\n         * @private\n         */\n        _this.sourceOptions_ = options.sourceOptions;\n        /**\n         * @type {Array<Array<GeoTIFFImage>>}\n         * @private\n         */\n        _this.sourceImagery_ = new Array(numSources);\n        /**\n         * @type {Array<number>}\n         * @private\n         */\n        _this.resolutionFactors_ = new Array(numSources);\n        /**\n         * @type {Array<number>}\n         * @private\n         */\n        _this.samplesPerPixel_;\n        /**\n         * @type {Array<Array<number>>}\n         * @private\n         */\n        _this.nodataValues_;\n        /**\n         * @type {Array<Array<GDALMetadata>>}\n         * @private\n         */\n        _this.metadata_;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        _this.normalize_ = options.normalize !== false;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        _this.addAlpha_ = false;\n        /**\n         * @type {Error}\n         * @private\n         */\n        _this.error_ = null;\n        /**\n         * @type {'readRasters' | 'readRGB'}\n         */\n        _this.readMethod_ = options.convertToRGB ? 'readRGB' : 'readRasters';\n        _this.setKey(_this.sourceInfo_.map(function (source) { return source.url; }).join(','));\n        var self = _this;\n        var requests = new Array(numSources);\n        for (var i = 0; i < numSources; ++i) {\n            requests[i] = getImagesForSource(_this.sourceInfo_[i], _this.sourceOptions_);\n        }\n        Promise.all(requests)\n            .then(function (sources) {\n            self.configure_(sources);\n        })\n            .catch(function (error) {\n            console.error(error); // eslint-disable-line no-console\n            self.error_ = error;\n            self.setState(State.ERROR);\n        });\n        return _this;\n    }\n    /**\n     * @return {Error} A source loading error. When the source state is `error`, use this function\n     * to get more information about the error. To debug a faulty configuration, you may want to use\n     * a listener like\n     * ```js\n     * geotiffSource.on('change', () => {\n     *   if (geotiffSource.getState() === 'error') {\n     *     console.error(geotiffSource.getError());\n     *   }\n     * });\n     * ```\n     */\n    GeoTIFFSource.prototype.getError = function () {\n        return this.error_;\n    };\n    /**\n     * Configure the tile grid based on images within the source GeoTIFFs.  Each GeoTIFF\n     * must have the same internal tiled structure.\n     * @param {Array<Array<GeoTIFFImage>>} sources Each source is a list of images\n     * from a single GeoTIFF.\n     * @private\n     */\n    GeoTIFFSource.prototype.configure_ = function (sources) {\n        var extent;\n        var origin;\n        var tileSizes;\n        var resolutions;\n        var samplesPerPixel = new Array(sources.length);\n        var nodataValues = new Array(sources.length);\n        var metadata = new Array(sources.length);\n        var minZoom = 0;\n        var sourceCount = sources.length;\n        var _loop_1 = function (sourceIndex) {\n            var images = sources[sourceIndex];\n            var imageCount = images.length;\n            var sourceExtent = void 0;\n            var sourceOrigin = void 0;\n            var sourceTileSizes = new Array(imageCount);\n            var sourceResolutions = new Array(imageCount);\n            nodataValues[sourceIndex] = new Array(imageCount);\n            metadata[sourceIndex] = new Array(imageCount);\n            for (var imageIndex = 0; imageIndex < imageCount; ++imageIndex) {\n                var image = images[imageIndex];\n                var nodataValue = image.getGDALNoData();\n                metadata[sourceIndex][imageIndex] = image.getGDALMetadata(0);\n                nodataValues[sourceIndex][imageIndex] =\n                    nodataValue === null ? NaN : nodataValue;\n                var wantedSamples = this_1.sourceInfo_[sourceIndex].bands;\n                samplesPerPixel[sourceIndex] = wantedSamples\n                    ? wantedSamples.length\n                    : image.getSamplesPerPixel();\n                var level = imageCount - (imageIndex + 1);\n                if (!sourceExtent) {\n                    sourceExtent = getBoundingBox(image);\n                }\n                if (!sourceOrigin) {\n                    sourceOrigin = getOrigin(image);\n                }\n                sourceResolutions[level] = getResolution(image, images[0]);\n                sourceTileSizes[level] = [image.getTileWidth(), image.getTileHeight()];\n            }\n            if (!extent) {\n                extent = sourceExtent;\n            }\n            else {\n                getIntersection(extent, sourceExtent, extent);\n            }\n            if (!origin) {\n                origin = sourceOrigin;\n            }\n            else {\n                var message = \"Origin mismatch for source \".concat(sourceIndex, \", got [\").concat(sourceOrigin, \"] but expected [\").concat(origin, \"]\");\n                assertEqual(origin, sourceOrigin, 0, message, this_1.viewRejector);\n            }\n            if (!resolutions) {\n                resolutions = sourceResolutions;\n                this_1.resolutionFactors_[sourceIndex] = 1;\n            }\n            else {\n                if (resolutions.length - minZoom > sourceResolutions.length) {\n                    minZoom = resolutions.length - sourceResolutions.length;\n                }\n                var resolutionFactor_1 = resolutions[resolutions.length - 1] /\n                    sourceResolutions[sourceResolutions.length - 1];\n                this_1.resolutionFactors_[sourceIndex] = resolutionFactor_1;\n                var scaledSourceResolutions = sourceResolutions.map(function (resolution) { return (resolution *= resolutionFactor_1); });\n                var message = \"Resolution mismatch for source \".concat(sourceIndex, \", got [\").concat(scaledSourceResolutions, \"] but expected [\").concat(resolutions, \"]\");\n                assertEqual(resolutions.slice(minZoom, resolutions.length), scaledSourceResolutions, 0.02, message, this_1.viewRejector);\n            }\n            if (!tileSizes) {\n                tileSizes = sourceTileSizes;\n            }\n            else {\n                assertEqual(tileSizes.slice(minZoom, tileSizes.length), sourceTileSizes, 0, \"Tile size mismatch for source \".concat(sourceIndex), this_1.viewRejector);\n            }\n            this_1.sourceImagery_[sourceIndex] = images.reverse();\n        };\n        var this_1 = this;\n        for (var sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n            _loop_1(sourceIndex);\n        }\n        for (var i = 0, ii = this.sourceImagery_.length; i < ii; ++i) {\n            var sourceImagery = this.sourceImagery_[i];\n            while (sourceImagery.length < resolutions.length) {\n                sourceImagery.unshift(undefined);\n            }\n        }\n        if (!this.getProjection()) {\n            var firstSource = sources[0];\n            for (var i = firstSource.length - 1; i >= 0; --i) {\n                var image = firstSource[i];\n                var projection = getProjection(image);\n                if (projection) {\n                    this.projection = projection;\n                    break;\n                }\n            }\n        }\n        this.samplesPerPixel_ = samplesPerPixel;\n        this.nodataValues_ = nodataValues;\n        this.metadata_ = metadata;\n        // decide if we need to add an alpha band to handle nodata\n        outer: for (var sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n            // option 1: source is configured with a nodata value\n            if (this.sourceInfo_[sourceIndex].nodata !== undefined) {\n                this.addAlpha_ = true;\n                break;\n            }\n            var values = nodataValues[sourceIndex];\n            // option 2: check image metadata for limited bands\n            var bands = this.sourceInfo_[sourceIndex].bands;\n            if (bands) {\n                for (var i = 0; i < bands.length; ++i) {\n                    if (!isNaN(values[bands[i] - 1])) {\n                        this.addAlpha_ = true;\n                        break outer;\n                    }\n                }\n                continue;\n            }\n            // option 3: check image metadata for all bands\n            for (var imageIndex = 0; imageIndex < values.length; ++imageIndex) {\n                if (!isNaN(values[imageIndex])) {\n                    this.addAlpha_ = true;\n                    break outer;\n                }\n            }\n        }\n        var additionalBands = this.addAlpha_ ? 1 : 0;\n        this.bandCount =\n            samplesPerPixel.reduce(function (accumulator, value) {\n                accumulator += value;\n                return accumulator;\n            }, 0) + additionalBands;\n        var tileGrid = new TileGrid({\n            extent: extent,\n            minZoom: minZoom,\n            origin: origin,\n            resolutions: resolutions,\n            tileSizes: tileSizes,\n        });\n        this.tileGrid = tileGrid;\n        this.setLoader(this.loadTile_.bind(this));\n        this.setState(State.READY);\n        this.viewResolver({\n            projection: this.projection,\n            resolutions: resolutions,\n            center: toUserCoordinate(getCenter(extent), this.projection),\n            extent: toUserExtent(extent, this.projection),\n            zoom: 0,\n        });\n    };\n    GeoTIFFSource.prototype.loadTile_ = function (z, x, y) {\n        var size = toSize(this.tileGrid.getTileSize(z));\n        var sourceCount = this.sourceImagery_.length;\n        var requests = new Array(sourceCount);\n        var addAlpha = this.addAlpha_;\n        var bandCount = this.bandCount;\n        var samplesPerPixel = this.samplesPerPixel_;\n        var nodataValues = this.nodataValues_;\n        var sourceInfo = this.sourceInfo_;\n        var _loop_2 = function (sourceIndex) {\n            var source = sourceInfo[sourceIndex];\n            var resolutionFactor = this_2.resolutionFactors_[sourceIndex];\n            var pixelBounds = [\n                Math.round(x * (size[0] * resolutionFactor)),\n                Math.round(y * (size[1] * resolutionFactor)),\n                Math.round((x + 1) * (size[0] * resolutionFactor)),\n                Math.round((y + 1) * (size[1] * resolutionFactor)),\n            ];\n            var image = this_2.sourceImagery_[sourceIndex][z];\n            var samples = void 0;\n            if (source.bands) {\n                samples = source.bands.map(function (bandNumber) {\n                    return bandNumber - 1;\n                });\n            }\n            /** @type {number|Array<number>} */\n            var fillValue = void 0;\n            if (!isNaN(source.nodata)) {\n                fillValue = source.nodata;\n            }\n            else {\n                if (!samples) {\n                    fillValue = nodataValues[sourceIndex];\n                }\n                else {\n                    fillValue = samples.map(function (sampleIndex) {\n                        return nodataValues[sourceIndex][sampleIndex];\n                    });\n                }\n            }\n            requests[sourceIndex] = image[this_2.readMethod_]({\n                window: pixelBounds,\n                width: size[0],\n                height: size[1],\n                samples: samples,\n                fillValue: fillValue,\n                pool: getWorkerPool(),\n                interleave: false,\n            });\n        };\n        var this_2 = this;\n        for (var sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n            _loop_2(sourceIndex);\n        }\n        var pixelCount = size[0] * size[1];\n        var dataLength = pixelCount * bandCount;\n        var normalize = this.normalize_;\n        var metadata = this.metadata_;\n        return Promise.all(requests).then(function (sourceSamples) {\n            /** @type {Uint8Array|Float32Array} */\n            var data;\n            if (normalize) {\n                data = new Uint8Array(dataLength);\n            }\n            else {\n                data = new Float32Array(dataLength);\n            }\n            var dataIndex = 0;\n            for (var pixelIndex = 0; pixelIndex < pixelCount; ++pixelIndex) {\n                var transparent = addAlpha;\n                for (var sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n                    var source = sourceInfo[sourceIndex];\n                    var min = source.min;\n                    var max = source.max;\n                    var gain = void 0, bias = void 0;\n                    if (normalize) {\n                        var stats = metadata[sourceIndex][0];\n                        if (min === undefined) {\n                            if (stats && STATISTICS_MINIMUM in stats) {\n                                min = parseFloat(stats[STATISTICS_MINIMUM]);\n                            }\n                            else {\n                                min = getMinForDataType(sourceSamples[sourceIndex][0]);\n                            }\n                        }\n                        if (max === undefined) {\n                            if (stats && STATISTICS_MAXIMUM in stats) {\n                                max = parseFloat(stats[STATISTICS_MAXIMUM]);\n                            }\n                            else {\n                                max = getMaxForDataType(sourceSamples[sourceIndex][0]);\n                            }\n                        }\n                        gain = 255 / (max - min);\n                        bias = -min * gain;\n                    }\n                    for (var sampleIndex = 0; sampleIndex < samplesPerPixel[sourceIndex]; ++sampleIndex) {\n                        var sourceValue = sourceSamples[sourceIndex][sampleIndex][pixelIndex];\n                        var value = void 0;\n                        if (normalize) {\n                            value = clamp(gain * sourceValue + bias, 0, 255);\n                        }\n                        else {\n                            value = sourceValue;\n                        }\n                        if (!addAlpha) {\n                            data[dataIndex] = value;\n                        }\n                        else {\n                            var nodata = source.nodata;\n                            if (nodata === undefined) {\n                                var bandIndex = void 0;\n                                if (source.bands) {\n                                    bandIndex = source.bands[sampleIndex] - 1;\n                                }\n                                else {\n                                    bandIndex = sampleIndex;\n                                }\n                                nodata = nodataValues[sourceIndex][bandIndex];\n                            }\n                            if (sourceValue !== nodata) {\n                                transparent = false;\n                                data[dataIndex] = value;\n                            }\n                        }\n                        dataIndex++;\n                    }\n                }\n                if (addAlpha) {\n                    if (!transparent) {\n                        data[dataIndex] = 255;\n                    }\n                    dataIndex++;\n                }\n            }\n            return data;\n        });\n    };\n    return GeoTIFFSource;\n}(DataTile));\n/**\n * Get a promise for view properties based on the source.  Use the result of this function\n * as the `view` option in a map constructor.\n *\n *     const source = new GeoTIFF(options);\n *\n *     const map = new Map({\n *       target: 'map',\n *       layers: [\n *         new TileLayer({\n *           source: source,\n *         }),\n *       ],\n *       view: source.getView(),\n *     });\n *\n * @function\n * @return {Promise<import(\"../View.js\").ViewOptions>} A promise for view-related properties.\n * @api\n *\n */\nGeoTIFFSource.prototype.getView;\nexport default GeoTIFFSource;\n//# sourceMappingURL=GeoTIFF.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/source/DataTile\n */\nimport DataTile from '../DataTile.js';\nimport EventType from '../events/EventType.js';\nimport TileEventType from './TileEventType.js';\nimport TileSource, { TileSourceEvent } from './Tile.js';\nimport TileState from '../TileState.js';\nimport { assign } from '../obj.js';\nimport { createXYZ, extentFromProjection } from '../tilegrid.js';\nimport { getKeyZXY } from '../tilecoord.js';\nimport { getUid } from '../util.js';\nimport { toPromise } from '../functions.js';\n/**\n * Data tile loading function.  The function is called with z, x, and y tile coordinates and\n * returns {@link import(\"../DataTile.js\").Data data} for a tile or a promise for the same.\n * @typedef {function(number, number, number) : (import(\"../DataTile.js\").Data|Promise<import(\"../DataTile.js\").Data>)} Loader\n */\n/**\n * @typedef {Object} Options\n * @property {Loader} [loader] Data loader.  Called with z, x, and y tile coordinates.\n * Returns {@link import(\"../DataTile.js\").Data data} for a tile or a promise for the same.\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [maxZoom=42] Optional max zoom level. Not used if `tileGrid` is provided.\n * @property {number} [minZoom=0] Optional min zoom level. Not used if `tileGrid` is provided.\n * @property {number|import(\"../size.js\").Size} [tileSize=[256, 256]] The pixel width and height of the tiles.\n * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.\n * @property {import(\"../proj.js\").ProjectionLike} [projection='EPSG:3857'] Tile projection.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {boolean} [opaque=false] Whether the layer is opaque.\n * @property {import(\"./State.js\").default} [state] The source state.\n * @property {number} [tilePixelRatio] Tile pixel ratio.\n * @property {boolean} [wrapX=false] Render tiles beyond the antimeridian.\n * @property {number} [transition] Transition time when fading in new tiles (in miliseconds).\n * @property {number} [bandCount=4] Number of bands represented in the data.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n */\n/**\n * @classdesc\n * A source for typed array data tiles.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n * @api\n */\nvar DataTileSource = /** @class */ (function (_super) {\n    __extends(DataTileSource, _super);\n    /**\n     * @param {Options} options Image tile options.\n     */\n    function DataTileSource(options) {\n        var _this = this;\n        var projection = options.projection === undefined ? 'EPSG:3857' : options.projection;\n        var tileGrid = options.tileGrid;\n        if (tileGrid === undefined && projection) {\n            tileGrid = createXYZ({\n                extent: extentFromProjection(projection),\n                maxResolution: options.maxResolution,\n                maxZoom: options.maxZoom,\n                minZoom: options.minZoom,\n                tileSize: options.tileSize,\n            });\n        }\n        _this = _super.call(this, {\n            cacheSize: 0.1,\n            attributions: options.attributions,\n            attributionsCollapsible: options.attributionsCollapsible,\n            projection: projection,\n            tileGrid: tileGrid,\n            opaque: options.opaque,\n            state: options.state,\n            tilePixelRatio: options.tilePixelRatio,\n            wrapX: options.wrapX,\n            transition: options.transition,\n            interpolate: options.interpolate,\n        }) || this;\n        /**\n         * @private\n         * @type {!Object<string, boolean>}\n         */\n        _this.tileLoadingKeys_ = {};\n        /**\n         * @private\n         */\n        _this.loader_ = options.loader;\n        _this.handleTileChange_ = _this.handleTileChange_.bind(_this);\n        /**\n         * @type {number}\n         */\n        _this.bandCount = options.bandCount === undefined ? 4 : options.bandCount; // assume RGBA if undefined\n        return _this;\n    }\n    /**\n     * @param {Loader} loader The data loader.\n     * @protected\n     */\n    DataTileSource.prototype.setLoader = function (loader) {\n        this.loader_ = loader;\n    };\n    /**\n     * @param {number} z Tile coordinate z.\n     * @param {number} x Tile coordinate x.\n     * @param {number} y Tile coordinate y.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @return {!DataTile} Tile.\n     */\n    DataTileSource.prototype.getTile = function (z, x, y, pixelRatio, projection) {\n        var tileCoordKey = getKeyZXY(z, x, y);\n        if (this.tileCache.containsKey(tileCoordKey)) {\n            return this.tileCache.get(tileCoordKey);\n        }\n        var sourceLoader = this.loader_;\n        function loader() {\n            return toPromise(function () {\n                return sourceLoader(z, x, y);\n            });\n        }\n        var tile = new DataTile(assign({ tileCoord: [z, x, y], loader: loader }, this.tileOptions));\n        tile.key = this.getKey();\n        tile.addEventListener(EventType.CHANGE, this.handleTileChange_);\n        this.tileCache.set(tileCoordKey, tile);\n        return tile;\n    };\n    /**\n     * Handle tile change events.\n     * @param {import(\"../events/Event.js\").default} event Event.\n     */\n    DataTileSource.prototype.handleTileChange_ = function (event) {\n        var tile = /** @type {import(\"../Tile.js\").default} */ (event.target);\n        var uid = getUid(tile);\n        var tileState = tile.getState();\n        var type;\n        if (tileState == TileState.LOADING) {\n            this.tileLoadingKeys_[uid] = true;\n            type = TileEventType.TILELOADSTART;\n        }\n        else if (uid in this.tileLoadingKeys_) {\n            delete this.tileLoadingKeys_[uid];\n            type =\n                tileState == TileState.ERROR\n                    ? TileEventType.TILELOADERROR\n                    : tileState == TileState.LOADED\n                        ? TileEventType.TILELOADEND\n                        : undefined;\n        }\n        if (type) {\n            this.dispatchEvent(new TileSourceEvent(type, tile));\n        }\n    };\n    return DataTileSource;\n}(TileSource));\nexport default DataTileSource;\n//# sourceMappingURL=DataTile.js.map","/**\n * @module ol/source/TileEventType\n */\n/**\n * @enum {string}\n */\nexport default {\n    /**\n     * Triggered when a tile starts loading.\n     * @event module:ol/source/Tile.TileSourceEvent#tileloadstart\n     * @api\n     */\n    TILELOADSTART: 'tileloadstart',\n    /**\n     * Triggered when a tile finishes loading, either when its data is loaded,\n     * or when loading was aborted because the tile is no longer needed.\n     * @event module:ol/source/Tile.TileSourceEvent#tileloadend\n     * @api\n     */\n    TILELOADEND: 'tileloadend',\n    /**\n     * Triggered if tile loading results in an error.\n     * @event module:ol/source/Tile.TileSourceEvent#tileloaderror\n     * @api\n     */\n    TILELOADERROR: 'tileloaderror',\n};\n/**\n * @typedef {'tileloadstart'|'tileloadend'|'tileloaderror'} TileSourceEventTypes\n */\n//# sourceMappingURL=TileEventType.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/source/Source\n */\nimport BaseObject from '../Object.js';\nimport SourceState from './State.js';\nimport { abstract } from '../util.js';\nimport { get as getProjection } from '../proj.js';\n/**\n * A function that takes a {@link module:ol/PluggableMap~FrameState} and returns a string or\n * an array of strings representing source attributions.\n *\n * @typedef {function(import(\"../PluggableMap.js\").FrameState): (string|Array<string>)} Attribution\n */\n/**\n * A type that can be used to provide attribution information for data sources.\n *\n * It represents either\n * * a simple string (e.g. `' Acme Inc.'`)\n * * an array of simple strings (e.g. `[' Acme Inc.', ' Bacme Inc.']`)\n * * a function that returns a string or array of strings ({@link module:ol/source/Source~Attribution})\n *\n * @typedef {string|Array<string>|Attribution} AttributionLike\n */\n/**\n * @typedef {Object} Options\n * @property {AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection. Default is the view projection.\n * @property {import(\"./State.js\").default} [state='ready'] State.\n * @property {boolean} [wrapX=false] WrapX.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n */\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for {@link module:ol/layer/Layer~Layer} sources.\n *\n * A generic `change` event is triggered when the state of the source changes.\n * @abstract\n * @api\n */\nvar Source = /** @class */ (function (_super) {\n    __extends(Source, _super);\n    /**\n     * @param {Options} options Source options.\n     */\n    function Source(options) {\n        var _this = _super.call(this) || this;\n        /**\n         * @protected\n         * @type {import(\"../proj/Projection.js\").default}\n         */\n        _this.projection = getProjection(options.projection);\n        /**\n         * @private\n         * @type {?Attribution}\n         */\n        _this.attributions_ = adaptAttributions(options.attributions);\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _this.attributionsCollapsible_ =\n            options.attributionsCollapsible !== undefined\n                ? options.attributionsCollapsible\n                : true;\n        /**\n         * This source is currently loading data. Sources that defer loading to the\n         * map's tile queue never set this to `true`.\n         * @type {boolean}\n         */\n        _this.loading = false;\n        /**\n         * @private\n         * @type {import(\"./State.js\").default}\n         */\n        _this.state_ =\n            options.state !== undefined ? options.state : SourceState.READY;\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _this.wrapX_ = options.wrapX !== undefined ? options.wrapX : false;\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _this.interpolate_ = !!options.interpolate;\n        /**\n         * @protected\n         * @type {function(import(\"../View.js\").ViewOptions):void}\n         */\n        _this.viewResolver = null;\n        /**\n         * @protected\n         * @type {function(Error):void}\n         */\n        _this.viewRejector = null;\n        var self = _this;\n        /**\n         * @private\n         * @type {Promise<import(\"../View.js\").ViewOptions>}\n         */\n        _this.viewPromise_ = new Promise(function (resolve, reject) {\n            self.viewResolver = resolve;\n            self.viewRejector = reject;\n        });\n        return _this;\n    }\n    /**\n     * Get the attribution function for the source.\n     * @return {?Attribution} Attribution function.\n     * @api\n     */\n    Source.prototype.getAttributions = function () {\n        return this.attributions_;\n    };\n    /**\n     * @return {boolean} Attributions are collapsible.\n     * @api\n     */\n    Source.prototype.getAttributionsCollapsible = function () {\n        return this.attributionsCollapsible_;\n    };\n    /**\n     * Get the projection of the source.\n     * @return {import(\"../proj/Projection.js\").default} Projection.\n     * @api\n     */\n    Source.prototype.getProjection = function () {\n        return this.projection;\n    };\n    /**\n     * @abstract\n     * @return {Array<number>|null} Resolutions.\n     */\n    Source.prototype.getResolutions = function () {\n        return abstract();\n    };\n    /**\n     * @return {Promise<import(\"../View.js\").ViewOptions>} A promise for view-related properties.\n     */\n    Source.prototype.getView = function () {\n        return this.viewPromise_;\n    };\n    /**\n     * Get the state of the source, see {@link module:ol/source/State~State} for possible states.\n     * @return {import(\"./State.js\").default} State.\n     * @api\n     */\n    Source.prototype.getState = function () {\n        return this.state_;\n    };\n    /**\n     * @return {boolean|undefined} Wrap X.\n     */\n    Source.prototype.getWrapX = function () {\n        return this.wrapX_;\n    };\n    /**\n     * @return {boolean} Use linear interpolation when resampling.\n     */\n    Source.prototype.getInterpolate = function () {\n        return this.interpolate_;\n    };\n    /**\n     * Refreshes the source. The source will be cleared, and data from the server will be reloaded.\n     * @api\n     */\n    Source.prototype.refresh = function () {\n        this.changed();\n    };\n    /**\n     * Set the attributions of the source.\n     * @param {AttributionLike|undefined} attributions Attributions.\n     *     Can be passed as `string`, `Array<string>`, {@link module:ol/source/Source~Attribution},\n     *     or `undefined`.\n     * @api\n     */\n    Source.prototype.setAttributions = function (attributions) {\n        this.attributions_ = adaptAttributions(attributions);\n        this.changed();\n    };\n    /**\n     * Set the state of the source.\n     * @param {import(\"./State.js\").default} state State.\n     */\n    Source.prototype.setState = function (state) {\n        this.state_ = state;\n        this.changed();\n    };\n    return Source;\n}(BaseObject));\n/**\n * Turns the attributions option into an attributions function.\n * @param {AttributionLike|undefined} attributionLike The attribution option.\n * @return {Attribution|null} An attribution function (or null).\n */\nfunction adaptAttributions(attributionLike) {\n    if (!attributionLike) {\n        return null;\n    }\n    if (Array.isArray(attributionLike)) {\n        return function (frameState) {\n            return attributionLike;\n        };\n    }\n    if (typeof attributionLike === 'function') {\n        return attributionLike;\n    }\n    return function (frameState) {\n        return [attributionLike];\n    };\n}\nexport default Source;\n//# sourceMappingURL=Source.js.map"],"sourceRoot":""}
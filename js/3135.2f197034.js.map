{"version":3,"file":"js/3135.2f197034.js","mappings":"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","sources":["webpack://@openeo/web-editor/./node_modules/ol/has.js","webpack://@openeo/web-editor/./node_modules/ol/interaction/Interaction.js","webpack://@openeo/web-editor/./node_modules/ol/interaction/Pointer.js","webpack://@openeo/web-editor/./node_modules/ol/interaction/Property.js","webpack://@openeo/web-editor/./node_modules/ol/interaction/Select.js","webpack://@openeo/web-editor/./node_modules/ol/interaction/DoubleClickZoom.js","webpack://@openeo/web-editor/./node_modules/ol/interaction/DragPan.js","webpack://@openeo/web-editor/./node_modules/ol/interaction/DragRotate.js","webpack://@openeo/web-editor/./node_modules/ol/interaction/DragBox.js","webpack://@openeo/web-editor/./node_modules/ol/interaction/DragZoom.js","webpack://@openeo/web-editor/./node_modules/ol/interaction/KeyboardPan.js","webpack://@openeo/web-editor/./node_modules/ol/interaction/KeyboardZoom.js","webpack://@openeo/web-editor/./node_modules/ol/interaction/MouseWheelZoom.js","webpack://@openeo/web-editor/./node_modules/ol/interaction/PinchRotate.js","webpack://@openeo/web-editor/./node_modules/ol/interaction/PinchZoom.js","webpack://@openeo/web-editor/./node_modules/ol/interaction/defaults.js","webpack://@openeo/web-editor/./node_modules/ol/layer/Base.js","webpack://@openeo/web-editor/./node_modules/ol/layer/BaseTile.js","webpack://@openeo/web-editor/./node_modules/ol/layer/BaseVector.js","webpack://@openeo/web-editor/./node_modules/ol/layer/Group.js","webpack://@openeo/web-editor/./node_modules/ol/layer/Heatmap.js","webpack://@openeo/web-editor/./node_modules/ol/layer/BaseImage.js","webpack://@openeo/web-editor/./node_modules/ol/layer/Image.js","webpack://@openeo/web-editor/./node_modules/ol/layer/Layer.js","webpack://@openeo/web-editor/./node_modules/ol/layer/Property.js","webpack://@openeo/web-editor/./node_modules/ol/layer/Tile.js","webpack://@openeo/web-editor/./node_modules/ol/layer/TileProperty.js","webpack://@openeo/web-editor/./node_modules/ol/layer/Vector.js","webpack://@openeo/web-editor/./node_modules/ol/layer/VectorTile.js","webpack://@openeo/web-editor/./node_modules/ol/loadingstrategy.js","webpack://@openeo/web-editor/./node_modules/ol/obj.js"],"sourcesContent":["/**\n * @module ol/has\n */\n\nconst ua =\n  typeof navigator !== 'undefined' && typeof navigator.userAgent !== 'undefined'\n    ? navigator.userAgent.toLowerCase()\n    : '';\n\n/**\n * User agent string says we are dealing with Firefox as browser.\n * @type {boolean}\n */\nexport const FIREFOX = ua.includes('firefox');\n\n/**\n * User agent string says we are dealing with Safari as browser.\n * @type {boolean}\n */\nexport const SAFARI = ua.includes('safari') && !ua.includes('chrom');\n\n/**\n * https://bugs.webkit.org/show_bug.cgi?id=237906\n * @type {boolean}\n */\nexport const SAFARI_BUG_237906 =\n  SAFARI &&\n  (ua.includes('version/15.4') ||\n    /cpu (os|iphone os) 15_4 like mac os x/.test(ua));\n\n/**\n * User agent string says we are dealing with a WebKit engine.\n * @type {boolean}\n */\nexport const WEBKIT = ua.includes('webkit') && !ua.includes('edge');\n\n/**\n * User agent string says we are dealing with a Mac as platform.\n * @type {boolean}\n */\nexport const MAC = ua.includes('macintosh');\n\n/**\n * The ratio between physical pixels and device-independent pixels\n * (dips) on the device (`window.devicePixelRatio`).\n * @const\n * @type {number}\n * @api\n */\nexport const DEVICE_PIXEL_RATIO =\n  typeof devicePixelRatio !== 'undefined' ? devicePixelRatio : 1;\n\n/**\n * The execution context is a worker with OffscreenCanvas available.\n * @const\n * @type {boolean}\n */\nexport const WORKER_OFFSCREEN_CANVAS =\n  typeof WorkerGlobalScope !== 'undefined' &&\n  typeof OffscreenCanvas !== 'undefined' &&\n  self instanceof WorkerGlobalScope; //eslint-disable-line\n\n/**\n * Image.prototype.decode() is supported.\n * @type {boolean}\n */\nexport const IMAGE_DECODE =\n  typeof Image !== 'undefined' && Image.prototype.decode;\n\n/**\n * @type {boolean}\n */\nexport const PASSIVE_EVENT_LISTENERS = (function () {\n  let passive = false;\n  try {\n    const options = Object.defineProperty({}, 'passive', {\n      get: function () {\n        passive = true;\n      },\n    });\n\n    window.addEventListener('_', null, options);\n    window.removeEventListener('_', null, options);\n  } catch (error) {\n    // passive not supported\n  }\n  return passive;\n})();\n","/**\n * @module ol/interaction/Interaction\n */\nimport BaseObject from '../Object.js';\nimport InteractionProperty from './Property.js';\nimport {easeOut, linear} from '../easing.js';\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active', Return>} InteractionOnSignature\n */\n\n/**\n * Object literal with config options for interactions.\n * @typedef {Object} InteractionOptions\n * @property {function(import(\"../MapBrowserEvent.js\").default):boolean} handleEvent\n * Method called by the map to notify the interaction that a browser event was\n * dispatched to the map. If the function returns a falsy value, propagation of\n * the event to other interactions in the map's interactions chain will be\n * prevented (this includes functions with no explicit return). The interactions\n * are traversed in reverse order of the interactions collection of the map.\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * User actions that change the state of the map. Some are similar to controls,\n * but are not associated with a DOM element.\n * For example, {@link module:ol/interaction/KeyboardZoom~KeyboardZoom} is\n * functionally the same as {@link module:ol/control/Zoom~Zoom}, but triggered\n * by a keyboard event not a button element event.\n * Although interactions do not have a DOM element, some of them do render\n * vectors and so are visible on the screen.\n * @api\n */\nclass Interaction extends BaseObject {\n  /**\n   * @param {InteractionOptions} [options] Options.\n   */\n  constructor(options) {\n    super();\n\n    /***\n     * @type {InteractionOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {InteractionOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {InteractionOnSignature<void>}\n     */\n    this.un;\n\n    if (options && options.handleEvent) {\n      this.handleEvent = options.handleEvent;\n    }\n\n    /**\n     * @private\n     * @type {import(\"../Map.js\").default|null}\n     */\n    this.map_ = null;\n\n    this.setActive(true);\n  }\n\n  /**\n   * Return whether the interaction is currently active.\n   * @return {boolean} `true` if the interaction is active, `false` otherwise.\n   * @observable\n   * @api\n   */\n  getActive() {\n    return /** @type {boolean} */ (this.get(InteractionProperty.ACTIVE));\n  }\n\n  /**\n   * Get the map associated with this interaction.\n   * @return {import(\"../Map.js\").default|null} Map.\n   * @api\n   */\n  getMap() {\n    return this.map_;\n  }\n\n  /**\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event}.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   * @api\n   */\n  handleEvent(mapBrowserEvent) {\n    return true;\n  }\n\n  /**\n   * Activate or deactivate the interaction.\n   * @param {boolean} active Active.\n   * @observable\n   * @api\n   */\n  setActive(active) {\n    this.set(InteractionProperty.ACTIVE, active);\n  }\n\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../Map.js\").default|null} map Map.\n   */\n  setMap(map) {\n    this.map_ = map;\n  }\n}\n\n/**\n * @param {import(\"../View.js\").default} view View.\n * @param {import(\"../coordinate.js\").Coordinate} delta Delta.\n * @param {number} [duration] Duration.\n */\nexport function pan(view, delta, duration) {\n  const currentCenter = view.getCenterInternal();\n  if (currentCenter) {\n    const center = [currentCenter[0] + delta[0], currentCenter[1] + delta[1]];\n    view.animateInternal({\n      duration: duration !== undefined ? duration : 250,\n      easing: linear,\n      center: view.getConstrainedCenter(center),\n    });\n  }\n}\n\n/**\n * @param {import(\"../View.js\").default} view View.\n * @param {number} delta Delta from previous zoom level.\n * @param {import(\"../coordinate.js\").Coordinate} [anchor] Anchor coordinate in the user projection.\n * @param {number} [duration] Duration.\n */\nexport function zoomByDelta(view, delta, anchor, duration) {\n  const currentZoom = view.getZoom();\n\n  if (currentZoom === undefined) {\n    return;\n  }\n\n  const newZoom = view.getConstrainedZoom(currentZoom + delta);\n  const newResolution = view.getResolutionForZoom(newZoom);\n\n  if (view.getAnimating()) {\n    view.cancelAnimations();\n  }\n  view.animate({\n    resolution: newResolution,\n    anchor: anchor,\n    duration: duration !== undefined ? duration : 250,\n    easing: easeOut,\n  });\n}\n\nexport default Interaction;\n","/**\n * @module ol/interaction/Pointer\n */\nimport Interaction from './Interaction.js';\nimport MapBrowserEventType from '../MapBrowserEventType.js';\n\n/**\n * @typedef {Object} Options\n * @property {function(import(\"../MapBrowserEvent.js\").default):boolean} [handleDownEvent]\n * Function handling \"down\" events. If the function returns `true` then a drag\n * sequence is started.\n * @property {function(import(\"../MapBrowserEvent.js\").default):void} [handleDragEvent]\n * Function handling \"drag\" events. This function is called on \"move\" events\n * during a drag sequence.\n * @property {function(import(\"../MapBrowserEvent.js\").default):boolean} [handleEvent]\n * Method called by the map to notify the interaction that a browser event was\n * dispatched to the map. The function may return `false` to prevent the\n * propagation of the event to other interactions in the map's interactions\n * chain.\n * @property {function(import(\"../MapBrowserEvent.js\").default):void} [handleMoveEvent]\n * Function handling \"move\" events. This function is called on \"move\" events.\n * This functions is also called during a drag sequence, so during a drag\n * sequence both the `handleDragEvent` function and this function are called.\n * If `handleDownEvent` is defined and it returns true this function will not\n * be called during a drag sequence.\n * @property {function(import(\"../MapBrowserEvent.js\").default):boolean} [handleUpEvent]\n *  Function handling \"up\" events. If the function returns `false` then the\n * current drag sequence is stopped.\n * @property {function(boolean):boolean} [stopDown]\n * Should the down event be propagated to other interactions, or should be\n * stopped?\n */\n\n/**\n * @classdesc\n * Base class that calls user-defined functions on `down`, `move` and `up`\n * events. This class also manages \"drag sequences\".\n *\n * When the `handleDownEvent` user function returns `true` a drag sequence is\n * started. During a drag sequence the `handleDragEvent` user function is\n * called on `move` events. The drag sequence ends when the `handleUpEvent`\n * user function is called and returns `false`.\n * @api\n */\nclass PointerInteraction extends Interaction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    super(\n      /** @type {import(\"./Interaction.js\").InteractionOptions} */ (options)\n    );\n\n    if (options.handleDownEvent) {\n      this.handleDownEvent = options.handleDownEvent;\n    }\n\n    if (options.handleDragEvent) {\n      this.handleDragEvent = options.handleDragEvent;\n    }\n\n    if (options.handleMoveEvent) {\n      this.handleMoveEvent = options.handleMoveEvent;\n    }\n\n    if (options.handleUpEvent) {\n      this.handleUpEvent = options.handleUpEvent;\n    }\n\n    if (options.stopDown) {\n      this.stopDown = options.stopDown;\n    }\n\n    /**\n     * @type {boolean}\n     * @protected\n     */\n    this.handlingDownUpSequence = false;\n\n    /**\n     * @type {Array<PointerEvent>}\n     * @protected\n     */\n    this.targetPointers = [];\n  }\n\n  /**\n   * Returns the current number of pointers involved in the interaction,\n   * e.g. `2` when two fingers are used.\n   * @return {number} The number of pointers.\n   * @api\n   */\n  getPointerCount() {\n    return this.targetPointers.length;\n  }\n\n  /**\n   * Handle pointer down events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   * @protected\n   */\n  handleDownEvent(mapBrowserEvent) {\n    return false;\n  }\n\n  /**\n   * Handle pointer drag events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @protected\n   */\n  handleDragEvent(mapBrowserEvent) {}\n\n  /**\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may call into\n   * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are\n   * detected.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   * @api\n   */\n  handleEvent(mapBrowserEvent) {\n    if (!mapBrowserEvent.originalEvent) {\n      return true;\n    }\n\n    let stopEvent = false;\n    this.updateTrackedPointers_(mapBrowserEvent);\n    if (this.handlingDownUpSequence) {\n      if (mapBrowserEvent.type == MapBrowserEventType.POINTERDRAG) {\n        this.handleDragEvent(mapBrowserEvent);\n        // prevent page scrolling during dragging\n        mapBrowserEvent.originalEvent.preventDefault();\n      } else if (mapBrowserEvent.type == MapBrowserEventType.POINTERUP) {\n        const handledUp = this.handleUpEvent(mapBrowserEvent);\n        this.handlingDownUpSequence =\n          handledUp && this.targetPointers.length > 0;\n      }\n    } else {\n      if (mapBrowserEvent.type == MapBrowserEventType.POINTERDOWN) {\n        const handled = this.handleDownEvent(mapBrowserEvent);\n        this.handlingDownUpSequence = handled;\n        stopEvent = this.stopDown(handled);\n      } else if (mapBrowserEvent.type == MapBrowserEventType.POINTERMOVE) {\n        this.handleMoveEvent(mapBrowserEvent);\n      }\n    }\n    return !stopEvent;\n  }\n\n  /**\n   * Handle pointer move events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @protected\n   */\n  handleMoveEvent(mapBrowserEvent) {}\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   * @protected\n   */\n  handleUpEvent(mapBrowserEvent) {\n    return false;\n  }\n\n  /**\n   * This function is used to determine if \"down\" events should be propagated\n   * to other interactions or should be stopped.\n   * @param {boolean} handled Was the event handled by the interaction?\n   * @return {boolean} Should the `down` event be stopped?\n   */\n  stopDown(handled) {\n    return handled;\n  }\n\n  /**\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @private\n   */\n  updateTrackedPointers_(mapBrowserEvent) {\n    if (mapBrowserEvent.activePointers) {\n      this.targetPointers = mapBrowserEvent.activePointers;\n    }\n  }\n}\n\n/**\n * @param {Array<PointerEvent>} pointerEvents List of events.\n * @return {{clientX: number, clientY: number}} Centroid pixel.\n */\nexport function centroid(pointerEvents) {\n  const length = pointerEvents.length;\n  let clientX = 0;\n  let clientY = 0;\n  for (let i = 0; i < length; i++) {\n    clientX += pointerEvents[i].clientX;\n    clientY += pointerEvents[i].clientY;\n  }\n  return {clientX: clientX / length, clientY: clientY / length};\n}\n\nexport default PointerInteraction;\n","/**\n * @module ol/interaction/Property\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  ACTIVE: 'active',\n};\n","/**\n * @module ol/interaction/Select\n */\nimport Collection from '../Collection.js';\nimport CollectionEventType from '../CollectionEventType.js';\nimport Event from '../events/Event.js';\nimport Feature from '../Feature.js';\nimport Interaction from './Interaction.js';\nimport VectorLayer from '../layer/Vector.js';\nimport {TRUE} from '../functions.js';\nimport {clear} from '../obj.js';\nimport {createEditingStyle} from '../style/Style.js';\nimport {extend} from '../array.js';\nimport {getUid} from '../util.js';\nimport {never, shiftKeyOnly, singleClick} from '../events/condition.js';\n\n/**\n * @enum {string}\n */\nconst SelectEventType = {\n  /**\n   * Triggered when feature(s) has been (de)selected.\n   * @event SelectEvent#select\n   * @api\n   */\n  SELECT: 'select',\n};\n\n/**\n * A function that takes an {@link module:ol/Feature~Feature} and returns `true` if the feature may be\n * selected or `false` otherwise.\n * @typedef {function(import(\"../Feature.js\").default, import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>):boolean} FilterFunction\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../events/condition.js\").Condition} [addCondition] A function\n * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * By default, this is {@link module:ol/events/condition.never}. Use this if you\n * want to use different events for add and remove instead of `toggle`.\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled. This is the event\n * for the selected features as a whole. By default, this is\n * {@link module:ol/events/condition.singleClick}. Clicking on a feature selects that\n * feature and removes any that were in the selection. Clicking outside any\n * feature removes all from the selection.\n * See `toggle`, `add`, `remove` options for adding/removing extra features to/\n * from the selection.\n * @property {Array<import(\"../layer/Layer.js\").default>|function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean} [layers]\n * A list of layers from which features should be selected. Alternatively, a\n * filter function can be provided. The function will be called for each layer\n * in the map and should return `true` for layers that you want to be\n * selectable. If the option is absent, all visible layers will be considered\n * selectable.\n * @property {import(\"../style/Style.js\").StyleLike|null} [style]\n * Style for the selected features. By default the default edit style is used\n * (see {@link module:ol/style/Style~Style}). Set to `null` if this interaction should not apply\n * any style changes for selected features.\n * If set to a falsey value, the selected feature's style will not change.\n * @property {import(\"../events/condition.js\").Condition} [removeCondition] A function\n * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * By default, this is {@link module:ol/events/condition.never}. Use this if you\n * want to use different events for add and remove instead of `toggle`.\n * @property {import(\"../events/condition.js\").Condition} [toggleCondition] A function\n * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled. This is in addition\n * to the `condition` event. By default,\n * {@link module:ol/events/condition.shiftKeyOnly}, i.e. pressing `shift` as\n * well as the `condition` event, adds that feature to the current selection if\n * it is not currently selected, and removes it if it is. See `add` and `remove`\n * if you want to use different events instead of a toggle.\n * @property {boolean} [multi=false] A boolean that determines if the default\n * behaviour should select only single features or all (overlapping) features at\n * the clicked map position. The default of `false` means single select.\n * @property {Collection<Feature>} [features]\n * Collection where the interaction will place selected features. Optional. If\n * not set the interaction will create a collection. In any case the collection\n * used by the interaction is returned by\n * {@link module:ol/interaction/Select~Select#getFeatures}.\n * @property {FilterFunction} [filter] A function\n * that takes an {@link module:ol/Feature~Feature} and an\n * {@link module:ol/layer/Layer~Layer} and returns `true` if the feature may be\n * selected or `false` otherwise.\n * @property {number} [hitTolerance=0] Hit-detection tolerance. Pixels inside\n * the radius around the given position will be checked for features.\n */\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/Select~Select} instances are instances of\n * this type.\n */\nexport class SelectEvent extends Event {\n  /**\n   * @param {SelectEventType} type The event type.\n   * @param {Array<import(\"../Feature.js\").default>} selected Selected features.\n   * @param {Array<import(\"../Feature.js\").default>} deselected Deselected features.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Associated\n   *     {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\n   */\n  constructor(type, selected, deselected, mapBrowserEvent) {\n    super(type);\n\n    /**\n     * Selected features array.\n     * @type {Array<import(\"../Feature.js\").default>}\n     * @api\n     */\n    this.selected = selected;\n\n    /**\n     * Deselected features array.\n     * @type {Array<import(\"../Feature.js\").default>}\n     * @api\n     */\n    this.deselected = deselected;\n\n    /**\n     * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\n     * @type {import(\"../MapBrowserEvent.js\").default}\n     * @api\n     */\n    this.mapBrowserEvent = mapBrowserEvent;\n  }\n}\n\n/**\n * Original feature styles to reset to when features are no longer selected.\n * @type {Object<number, import(\"../style/Style.js\").default|Array<import(\"../style/Style.js\").default>|import(\"../style/Style.js\").StyleFunction>}\n */\nconst originalFeatureStyles = {};\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'select', SelectEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'select', Return>} SelectOnSignature\n */\n\n/**\n * @classdesc\n * Interaction for selecting vector features. By default, selected features are\n * styled differently, so this interaction can be used for visual highlighting,\n * as well as selecting features for other actions, such as modification or\n * output. There are three ways of controlling which features are selected:\n * using the browser event as defined by the `condition` and optionally the\n * `toggle`, `add`/`remove`, and `multi` options; a `layers` filter; and a\n * further feature filter using the `filter` option.\n *\n * @fires SelectEvent\n * @api\n */\nclass Select extends Interaction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n\n    /***\n     * @type {SelectOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {SelectOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {SelectOnSignature<void>}\n     */\n    this.un;\n\n    options = options ? options : {};\n\n    /**\n     * @private\n     */\n    this.boundAddFeature_ = this.addFeature_.bind(this);\n\n    /**\n     * @private\n     */\n    this.boundRemoveFeature_ = this.removeFeature_.bind(this);\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.condition_ = options.condition ? options.condition : singleClick;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.addCondition_ = options.addCondition ? options.addCondition : never;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.removeCondition_ = options.removeCondition\n      ? options.removeCondition\n      : never;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.toggleCondition_ = options.toggleCondition\n      ? options.toggleCondition\n      : shiftKeyOnly;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.multi_ = options.multi ? options.multi : false;\n\n    /**\n     * @private\n     * @type {FilterFunction}\n     */\n    this.filter_ = options.filter ? options.filter : TRUE;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;\n\n    /**\n     * @private\n     * @type {import(\"../style/Style.js\").default|Array<import(\"../style/Style.js\").default>|import(\"../style/Style.js\").StyleFunction|null}\n     */\n    this.style_ =\n      options.style !== undefined ? options.style : getDefaultStyleFunction();\n\n    /**\n     * @private\n     * @type {Collection<Feature>}\n     */\n    this.features_ = options.features || new Collection();\n\n    /** @type {function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean} */\n    let layerFilter;\n    if (options.layers) {\n      if (typeof options.layers === 'function') {\n        layerFilter = options.layers;\n      } else {\n        const layers = options.layers;\n        layerFilter = function (layer) {\n          return layers.includes(layer);\n        };\n      }\n    } else {\n      layerFilter = TRUE;\n    }\n\n    /**\n     * @private\n     * @type {function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean}\n     */\n    this.layerFilter_ = layerFilter;\n\n    /**\n     * An association between selected feature (key)\n     * and layer (value)\n     * @private\n     * @type {Object<string, import(\"../layer/Layer.js\").default>}\n     */\n    this.featureLayerAssociation_ = {};\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"../layer/Layer.js\").default} layer Layer.\n   * @private\n   */\n  addFeatureLayerAssociation_(feature, layer) {\n    this.featureLayerAssociation_[getUid(feature)] = layer;\n  }\n\n  /**\n   * Get the selected features.\n   * @return {Collection<Feature>} Features collection.\n   * @api\n   */\n  getFeatures() {\n    return this.features_;\n  }\n\n  /**\n   * Returns the Hit-detection tolerance.\n   * @return {number} Hit tolerance in pixels.\n   * @api\n   */\n  getHitTolerance() {\n    return this.hitTolerance_;\n  }\n\n  /**\n   * Returns the associated {@link module:ol/layer/Vector~VectorLayer vector layer} of\n   * a selected feature.\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @return {import('../layer/Vector.js').default} Layer.\n   * @api\n   */\n  getLayer(feature) {\n    return /** @type {import('../layer/Vector.js').default} */ (\n      this.featureLayerAssociation_[getUid(feature)]\n    );\n  }\n\n  /**\n   * Hit-detection tolerance. Pixels inside the radius around the given position\n   * will be checked for features.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @api\n   */\n  setHitTolerance(hitTolerance) {\n    this.hitTolerance_ = hitTolerance;\n  }\n\n  /**\n   * Remove the interaction from its current map, if any,  and attach it to a new\n   * map, if any. Pass `null` to just remove the interaction from the current map.\n   * @param {import(\"../Map.js\").default|null} map Map.\n   * @api\n   */\n  setMap(map) {\n    const currentMap = this.getMap();\n    if (currentMap && this.style_) {\n      this.features_.forEach(this.restorePreviousStyle_.bind(this));\n    }\n    super.setMap(map);\n    if (map) {\n      this.features_.addEventListener(\n        CollectionEventType.ADD,\n        this.boundAddFeature_\n      );\n      this.features_.addEventListener(\n        CollectionEventType.REMOVE,\n        this.boundRemoveFeature_\n      );\n\n      if (this.style_) {\n        this.features_.forEach(this.applySelectedStyle_.bind(this));\n      }\n    } else {\n      this.features_.removeEventListener(\n        CollectionEventType.ADD,\n        this.boundAddFeature_\n      );\n      this.features_.removeEventListener(\n        CollectionEventType.REMOVE,\n        this.boundRemoveFeature_\n      );\n    }\n  }\n\n  /**\n   * @param {import(\"../Collection.js\").CollectionEvent<Feature>} evt Event.\n   * @private\n   */\n  addFeature_(evt) {\n    const feature = evt.element;\n    if (this.style_) {\n      this.applySelectedStyle_(feature);\n    }\n    if (!this.getLayer(feature)) {\n      const layer = /** @type {VectorLayer} */ (\n        this.getMap()\n          .getAllLayers()\n          .find(function (layer) {\n            if (\n              layer instanceof VectorLayer &&\n              layer.getSource() &&\n              layer.getSource().hasFeature(feature)\n            ) {\n              return layer;\n            }\n          })\n      );\n      if (layer) {\n        this.addFeatureLayerAssociation_(feature, layer);\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../Collection.js\").CollectionEvent<Feature>} evt Event.\n   * @private\n   */\n  removeFeature_(evt) {\n    if (this.style_) {\n      this.restorePreviousStyle_(evt.element);\n    }\n  }\n\n  /**\n   * @return {import(\"../style/Style.js\").StyleLike|null} Select style.\n   */\n  getStyle() {\n    return this.style_;\n  }\n\n  /**\n   * @param {Feature} feature Feature\n   * @private\n   */\n  applySelectedStyle_(feature) {\n    const key = getUid(feature);\n    if (!(key in originalFeatureStyles)) {\n      originalFeatureStyles[key] = feature.getStyle();\n    }\n    feature.setStyle(this.style_);\n  }\n\n  /**\n   * @param {Feature} feature Feature\n   * @private\n   */\n  restorePreviousStyle_(feature) {\n    const interactions = this.getMap().getInteractions().getArray();\n    for (let i = interactions.length - 1; i >= 0; --i) {\n      const interaction = interactions[i];\n      if (\n        interaction !== this &&\n        interaction instanceof Select &&\n        interaction.getStyle() &&\n        interaction.getFeatures().getArray().lastIndexOf(feature) !== -1\n      ) {\n        feature.setStyle(interaction.getStyle());\n        return;\n      }\n    }\n\n    const key = getUid(feature);\n    feature.setStyle(originalFeatureStyles[key]);\n    delete originalFeatureStyles[key];\n  }\n\n  /**\n   * @param {Feature} feature Feature.\n   * @private\n   */\n  removeFeatureLayerAssociation_(feature) {\n    delete this.featureLayerAssociation_[getUid(feature)];\n  }\n\n  /**\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may change the\n   * selected state of features.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   */\n  handleEvent(mapBrowserEvent) {\n    if (!this.condition_(mapBrowserEvent)) {\n      return true;\n    }\n    const add = this.addCondition_(mapBrowserEvent);\n    const remove = this.removeCondition_(mapBrowserEvent);\n    const toggle = this.toggleCondition_(mapBrowserEvent);\n    const set = !add && !remove && !toggle;\n    const map = mapBrowserEvent.map;\n    const features = this.getFeatures();\n\n    /**\n     * @type {Array<Feature>}\n     */\n    const deselected = [];\n\n    /**\n     * @type {Array<Feature>}\n     */\n    const selected = [];\n\n    if (set) {\n      // Replace the currently selected feature(s) with the feature(s) at the\n      // pixel, or clear the selected feature(s) if there is no feature at\n      // the pixel.\n      clear(this.featureLayerAssociation_);\n      map.forEachFeatureAtPixel(\n        mapBrowserEvent.pixel,\n        /**\n         * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n         * @param {import(\"../layer/Layer.js\").default} layer Layer.\n         * @return {boolean|undefined} Continue to iterate over the features.\n         */\n        (feature, layer) => {\n          if (!(feature instanceof Feature) || !this.filter_(feature, layer)) {\n            return;\n          }\n          this.addFeatureLayerAssociation_(feature, layer);\n          selected.push(feature);\n          return !this.multi_;\n        },\n        {\n          layerFilter: this.layerFilter_,\n          hitTolerance: this.hitTolerance_,\n        }\n      );\n      for (let i = features.getLength() - 1; i >= 0; --i) {\n        const feature = features.item(i);\n        const index = selected.indexOf(feature);\n        if (index > -1) {\n          // feature is already selected\n          selected.splice(index, 1);\n        } else {\n          features.remove(feature);\n          deselected.push(feature);\n        }\n      }\n      if (selected.length !== 0) {\n        features.extend(selected);\n      }\n    } else {\n      // Modify the currently selected feature(s).\n      map.forEachFeatureAtPixel(\n        mapBrowserEvent.pixel,\n        /**\n         * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n         * @param {import(\"../layer/Layer.js\").default} layer Layer.\n         * @return {boolean|undefined} Continue to iterate over the features.\n         */\n        (feature, layer) => {\n          if (!(feature instanceof Feature) || !this.filter_(feature, layer)) {\n            return;\n          }\n          if ((add || toggle) && !features.getArray().includes(feature)) {\n            this.addFeatureLayerAssociation_(feature, layer);\n            selected.push(feature);\n          } else if (\n            (remove || toggle) &&\n            features.getArray().includes(feature)\n          ) {\n            deselected.push(feature);\n            this.removeFeatureLayerAssociation_(feature);\n          }\n          return !this.multi_;\n        },\n        {\n          layerFilter: this.layerFilter_,\n          hitTolerance: this.hitTolerance_,\n        }\n      );\n      for (let j = deselected.length - 1; j >= 0; --j) {\n        features.remove(deselected[j]);\n      }\n      features.extend(selected);\n    }\n    if (selected.length > 0 || deselected.length > 0) {\n      this.dispatchEvent(\n        new SelectEvent(\n          SelectEventType.SELECT,\n          selected,\n          deselected,\n          mapBrowserEvent\n        )\n      );\n    }\n    return true;\n  }\n}\n\n/**\n * @return {import(\"../style/Style.js\").StyleFunction} Styles.\n */\nfunction getDefaultStyleFunction() {\n  const styles = createEditingStyle();\n  extend(styles['Polygon'], styles['LineString']);\n  extend(styles['GeometryCollection'], styles['LineString']);\n\n  return function (feature) {\n    if (!feature.getGeometry()) {\n      return null;\n    }\n    return styles[feature.getGeometry().getType()];\n  };\n}\n\nexport default Select;\n","/**\n * @module ol/interaction/DoubleClickZoom\n */\nimport Interaction, {zoomByDelta} from './Interaction.js';\nimport MapBrowserEventType from '../MapBrowserEventType.js';\n\n/**\n * @typedef {Object} Options\n * @property {number} [duration=250] Animation duration in milliseconds.\n * @property {number} [delta=1] The zoom delta applied on each double click.\n */\n\n/**\n * @classdesc\n * Allows the user to zoom by double-clicking on the map.\n * @api\n */\nclass DoubleClickZoom extends Interaction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n\n    options = options ? options : {};\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.delta_ = options.delta ? options.delta : 1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 250;\n  }\n\n  /**\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a\n   * doubleclick) and eventually zooms the map.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   */\n  handleEvent(mapBrowserEvent) {\n    let stopEvent = false;\n    if (mapBrowserEvent.type == MapBrowserEventType.DBLCLICK) {\n      const browserEvent = /** @type {MouseEvent} */ (\n        mapBrowserEvent.originalEvent\n      );\n      const map = mapBrowserEvent.map;\n      const anchor = mapBrowserEvent.coordinate;\n      const delta = browserEvent.shiftKey ? -this.delta_ : this.delta_;\n      const view = map.getView();\n      zoomByDelta(view, delta, anchor, this.duration_);\n      browserEvent.preventDefault();\n      stopEvent = true;\n    }\n    return !stopEvent;\n  }\n}\n\nexport default DoubleClickZoom;\n","/**\n * @module ol/interaction/DragPan\n */\nimport PointerInteraction, {\n  centroid as centroidFromPointers,\n} from './Pointer.js';\nimport {FALSE} from '../functions.js';\nimport {\n  all,\n  focusWithTabindex,\n  noModifierKeys,\n  primaryAction,\n} from '../events/condition.js';\nimport {easeOut} from '../easing.js';\nimport {\n  rotate as rotateCoordinate,\n  scale as scaleCoordinate,\n} from '../coordinate.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean\n * to indicate whether that event should be handled.\n * Default is {@link module:ol/events/condition.noModifierKeys} and {@link module:ol/events/condition.primaryAction}.\n * @property {boolean} [onFocusOnly=false] When the map's target has a `tabindex` attribute set,\n * the interaction will only handle events when the map has the focus.\n * @property {import(\"../Kinetic.js\").default} [kinetic] Kinetic inertia to apply to the pan.\n */\n\n/**\n * @classdesc\n * Allows the user to pan the map by dragging the map.\n * @api\n */\nclass DragPan extends PointerInteraction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super({\n      stopDown: FALSE,\n    });\n\n    options = options ? options : {};\n\n    /**\n     * @private\n     * @type {import(\"../Kinetic.js\").default|undefined}\n     */\n    this.kinetic_ = options.kinetic;\n\n    /**\n     * @type {import(\"../pixel.js\").Pixel}\n     */\n    this.lastCentroid = null;\n\n    /**\n     * @type {number}\n     */\n    this.lastPointersCount_;\n\n    /**\n     * @type {boolean}\n     */\n    this.panning_ = false;\n\n    const condition = options.condition\n      ? options.condition\n      : all(noModifierKeys, primaryAction);\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.condition_ = options.onFocusOnly\n      ? all(focusWithTabindex, condition)\n      : condition;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.noKinetic_ = false;\n  }\n\n  /**\n   * Handle pointer drag events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   */\n  handleDragEvent(mapBrowserEvent) {\n    const map = mapBrowserEvent.map;\n    if (!this.panning_) {\n      this.panning_ = true;\n      map.getView().beginInteraction();\n    }\n    const targetPointers = this.targetPointers;\n    const centroid = map.getEventPixel(centroidFromPointers(targetPointers));\n    if (targetPointers.length == this.lastPointersCount_) {\n      if (this.kinetic_) {\n        this.kinetic_.update(centroid[0], centroid[1]);\n      }\n      if (this.lastCentroid) {\n        const delta = [\n          this.lastCentroid[0] - centroid[0],\n          centroid[1] - this.lastCentroid[1],\n        ];\n        const map = mapBrowserEvent.map;\n        const view = map.getView();\n        scaleCoordinate(delta, view.getResolution());\n        rotateCoordinate(delta, view.getRotation());\n        view.adjustCenterInternal(delta);\n      }\n    } else if (this.kinetic_) {\n      // reset so we don't overestimate the kinetic energy after\n      // after one finger down, tiny drag, second finger down\n      this.kinetic_.begin();\n    }\n    this.lastCentroid = centroid;\n    this.lastPointersCount_ = targetPointers.length;\n    mapBrowserEvent.originalEvent.preventDefault();\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleUpEvent(mapBrowserEvent) {\n    const map = mapBrowserEvent.map;\n    const view = map.getView();\n    if (this.targetPointers.length === 0) {\n      if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {\n        const distance = this.kinetic_.getDistance();\n        const angle = this.kinetic_.getAngle();\n        const center = view.getCenterInternal();\n        const centerpx = map.getPixelFromCoordinateInternal(center);\n        const dest = map.getCoordinateFromPixelInternal([\n          centerpx[0] - distance * Math.cos(angle),\n          centerpx[1] - distance * Math.sin(angle),\n        ]);\n        view.animateInternal({\n          center: view.getConstrainedCenter(dest),\n          duration: 500,\n          easing: easeOut,\n        });\n      }\n      if (this.panning_) {\n        this.panning_ = false;\n        view.endInteraction();\n      }\n      return false;\n    }\n    if (this.kinetic_) {\n      // reset so we don't overestimate the kinetic energy after\n      // after one finger up, tiny drag, second finger up\n      this.kinetic_.begin();\n    }\n    this.lastCentroid = null;\n    return true;\n  }\n\n  /**\n   * Handle pointer down events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleDownEvent(mapBrowserEvent) {\n    if (this.targetPointers.length > 0 && this.condition_(mapBrowserEvent)) {\n      const map = mapBrowserEvent.map;\n      const view = map.getView();\n      this.lastCentroid = null;\n      // stop any current animation\n      if (view.getAnimating()) {\n        view.cancelAnimations();\n      }\n      if (this.kinetic_) {\n        this.kinetic_.begin();\n      }\n      // No kinetic as soon as more than one pointer on the screen is\n      // detected. This is to prevent nasty pans after pinch.\n      this.noKinetic_ = this.targetPointers.length > 1;\n      return true;\n    }\n    return false;\n  }\n}\n\nexport default DragPan;\n","/**\n * @module ol/interaction/DragRotate\n */\nimport PointerInteraction from './Pointer.js';\nimport {FALSE} from '../functions.js';\nimport {\n  altShiftKeysOnly,\n  mouseActionButton,\n  mouseOnly,\n} from '../events/condition.js';\nimport {disable} from '../rotationconstraint.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that takes an\n * {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean\n * to indicate whether that event should be handled.\n * Default is {@link module:ol/events/condition.altShiftKeysOnly}.\n * @property {number} [duration=250] Animation duration in milliseconds.\n */\n\n/**\n * @classdesc\n * Allows the user to rotate the map by clicking and dragging on the map,\n * normally combined with an {@link module:ol/events/condition} that limits\n * it to when the alt and shift keys are held down.\n *\n * This interaction is only supported for mouse devices.\n * @api\n */\nclass DragRotate extends PointerInteraction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    super({\n      stopDown: FALSE,\n    });\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.condition_ = options.condition ? options.condition : altShiftKeysOnly;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.lastAngle_ = undefined;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 250;\n  }\n\n  /**\n   * Handle pointer drag events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   */\n  handleDragEvent(mapBrowserEvent) {\n    if (!mouseOnly(mapBrowserEvent)) {\n      return;\n    }\n\n    const map = mapBrowserEvent.map;\n    const view = map.getView();\n    if (view.getConstraints().rotation === disable) {\n      return;\n    }\n    const size = map.getSize();\n    const offset = mapBrowserEvent.pixel;\n    const theta = Math.atan2(size[1] / 2 - offset[1], offset[0] - size[0] / 2);\n    if (this.lastAngle_ !== undefined) {\n      const delta = theta - this.lastAngle_;\n      view.adjustRotationInternal(-delta);\n    }\n    this.lastAngle_ = theta;\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleUpEvent(mapBrowserEvent) {\n    if (!mouseOnly(mapBrowserEvent)) {\n      return true;\n    }\n\n    const map = mapBrowserEvent.map;\n    const view = map.getView();\n    view.endInteraction(this.duration_);\n    return false;\n  }\n\n  /**\n   * Handle pointer down events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleDownEvent(mapBrowserEvent) {\n    if (!mouseOnly(mapBrowserEvent)) {\n      return false;\n    }\n\n    if (\n      mouseActionButton(mapBrowserEvent) &&\n      this.condition_(mapBrowserEvent)\n    ) {\n      const map = mapBrowserEvent.map;\n      map.getView().beginInteraction();\n      this.lastAngle_ = undefined;\n      return true;\n    }\n    return false;\n  }\n}\n\nexport default DragRotate;\n","/**\n * @module ol/interaction/DragBox\n */\n// FIXME draw drag box\nimport Event from '../events/Event.js';\nimport PointerInteraction from './Pointer.js';\nimport RenderBox from '../render/Box.js';\nimport {mouseActionButton} from '../events/condition.js';\n\n/**\n * A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and two\n * {@link module:ol/pixel~Pixel}s and returns a `{boolean}`. If the condition is met,\n * true should be returned.\n * @typedef {function(this: ?, import(\"../MapBrowserEvent.js\").default, import(\"../pixel.js\").Pixel, import(\"../pixel.js\").Pixel):boolean} EndCondition\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-dragbox'] CSS class name for styling the box.\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean\n * to indicate whether that event should be handled.\n * Default is {@link ol/events/condition~mouseActionButton}.\n * @property {number} [minArea=64] The minimum area of the box in pixel, this value is used by the default\n * `boxEndCondition` function.\n * @property {EndCondition} [boxEndCondition] A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and two\n * {@link module:ol/pixel~Pixel}s to indicate whether a `boxend` event should be fired.\n * Default is `true` if the area of the box is bigger than the `minArea` option.\n * @property {function(this:DragBox, import(\"../MapBrowserEvent.js\").default):void} [onBoxEnd] Code to execute just\n * before `boxend` is fired.\n */\n\n/**\n * @enum {string}\n */\nconst DragBoxEventType = {\n  /**\n   * Triggered upon drag box start.\n   * @event DragBoxEvent#boxstart\n   * @api\n   */\n  BOXSTART: 'boxstart',\n\n  /**\n   * Triggered on drag when box is active.\n   * @event DragBoxEvent#boxdrag\n   * @api\n   */\n  BOXDRAG: 'boxdrag',\n\n  /**\n   * Triggered upon drag box end.\n   * @event DragBoxEvent#boxend\n   * @api\n   */\n  BOXEND: 'boxend',\n\n  /**\n   * Triggered upon drag box canceled.\n   * @event DragBoxEvent#boxcancel\n   * @api\n   */\n  BOXCANCEL: 'boxcancel',\n};\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/DragBox~DragBox} instances are instances of\n * this type.\n */\nexport class DragBoxEvent extends Event {\n  /**\n   * @param {string} type The event type.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate The event coordinate.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Originating event.\n   */\n  constructor(type, coordinate, mapBrowserEvent) {\n    super(type);\n\n    /**\n     * The coordinate of the drag event.\n     * @const\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @api\n     */\n    this.coordinate = coordinate;\n\n    /**\n     * @const\n     * @type {import(\"../MapBrowserEvent.js\").default}\n     * @api\n     */\n    this.mapBrowserEvent = mapBrowserEvent;\n  }\n}\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'boxcancel'|'boxdrag'|'boxend'|'boxstart', DragBoxEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'boxcancel'|'boxdrag'|'boxend', Return>} DragBoxOnSignature\n */\n\n/**\n * @classdesc\n * Allows the user to draw a vector box by clicking and dragging on the map,\n * normally combined with an {@link module:ol/events/condition} that limits\n * it to when the shift or other key is held down. This is used, for example,\n * for zooming to a specific area of the map\n * (see {@link module:ol/interaction/DragZoom~DragZoom} and\n * {@link module:ol/interaction/DragRotateAndZoom~DragRotateAndZoom}).\n *\n * @fires DragBoxEvent\n * @api\n */\nclass DragBox extends PointerInteraction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n\n    /***\n     * @type {DragBoxOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {DragBoxOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {DragBoxOnSignature<void>}\n     */\n    this.un;\n\n    options = options ? options : {};\n\n    /**\n     * @type {import(\"../render/Box.js\").default}\n     * @private\n     */\n    this.box_ = new RenderBox(options.className || 'ol-dragbox');\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.minArea_ = options.minArea !== undefined ? options.minArea : 64;\n\n    if (options.onBoxEnd) {\n      this.onBoxEnd = options.onBoxEnd;\n    }\n\n    /**\n     * @type {import(\"../pixel.js\").Pixel}\n     * @private\n     */\n    this.startPixel_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.condition_ = options.condition ? options.condition : mouseActionButton;\n\n    /**\n     * @private\n     * @type {EndCondition}\n     */\n    this.boxEndCondition_ = options.boxEndCondition\n      ? options.boxEndCondition\n      : this.defaultBoxEndCondition;\n  }\n\n  /**\n   * The default condition for determining whether the boxend event\n   * should fire.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent The originating MapBrowserEvent\n   *     leading to the box end.\n   * @param {import(\"../pixel.js\").Pixel} startPixel The starting pixel of the box.\n   * @param {import(\"../pixel.js\").Pixel} endPixel The end pixel of the box.\n   * @return {boolean} Whether or not the boxend condition should be fired.\n   */\n  defaultBoxEndCondition(mapBrowserEvent, startPixel, endPixel) {\n    const width = endPixel[0] - startPixel[0];\n    const height = endPixel[1] - startPixel[1];\n    return width * width + height * height >= this.minArea_;\n  }\n\n  /**\n   * Returns geometry of last drawn box.\n   * @return {import(\"../geom/Polygon.js\").default} Geometry.\n   * @api\n   */\n  getGeometry() {\n    return this.box_.getGeometry();\n  }\n\n  /**\n   * Handle pointer drag events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   */\n  handleDragEvent(mapBrowserEvent) {\n    this.box_.setPixels(this.startPixel_, mapBrowserEvent.pixel);\n\n    this.dispatchEvent(\n      new DragBoxEvent(\n        DragBoxEventType.BOXDRAG,\n        mapBrowserEvent.coordinate,\n        mapBrowserEvent\n      )\n    );\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleUpEvent(mapBrowserEvent) {\n    this.box_.setMap(null);\n\n    const completeBox = this.boxEndCondition_(\n      mapBrowserEvent,\n      this.startPixel_,\n      mapBrowserEvent.pixel\n    );\n    if (completeBox) {\n      this.onBoxEnd(mapBrowserEvent);\n    }\n    this.dispatchEvent(\n      new DragBoxEvent(\n        completeBox ? DragBoxEventType.BOXEND : DragBoxEventType.BOXCANCEL,\n        mapBrowserEvent.coordinate,\n        mapBrowserEvent\n      )\n    );\n    return false;\n  }\n\n  /**\n   * Handle pointer down events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleDownEvent(mapBrowserEvent) {\n    if (this.condition_(mapBrowserEvent)) {\n      this.startPixel_ = mapBrowserEvent.pixel;\n      this.box_.setMap(mapBrowserEvent.map);\n      this.box_.setPixels(this.startPixel_, this.startPixel_);\n      this.dispatchEvent(\n        new DragBoxEvent(\n          DragBoxEventType.BOXSTART,\n          mapBrowserEvent.coordinate,\n          mapBrowserEvent\n        )\n      );\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Function to execute just before `onboxend` is fired\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   */\n  onBoxEnd(event) {}\n}\n\nexport default DragBox;\n","/**\n * @module ol/interaction/DragZoom\n */\nimport DragBox from './DragBox.js';\nimport {easeOut} from '../easing.js';\nimport {shiftKeyOnly} from '../events/condition.js';\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-dragzoom'] CSS class name for styling the\n * box.\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * Default is {@link module:ol/events/condition.shiftKeyOnly}.\n * @property {number} [duration=200] Animation duration in milliseconds.\n * @property {boolean} [out=false] Use interaction for zooming out.\n * @property {number} [minArea=64] The minimum area of the box in pixel, this value is used by the parent default\n * `boxEndCondition` function.\n */\n\n/**\n * @classdesc\n * Allows the user to zoom the map by clicking and dragging on the map,\n * normally combined with an {@link module:ol/events/condition} that limits\n * it to when a key, shift by default, is held down.\n *\n * To change the style of the box, use CSS and the `.ol-dragzoom` selector, or\n * your custom one configured with `className`.\n * @api\n */\nclass DragZoom extends DragBox {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const condition = options.condition ? options.condition : shiftKeyOnly;\n\n    super({\n      condition: condition,\n      className: options.className || 'ol-dragzoom',\n      minArea: options.minArea,\n    });\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 200;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.out_ = options.out !== undefined ? options.out : false;\n  }\n\n  /**\n   * Function to execute just before `onboxend` is fired\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   */\n  onBoxEnd(event) {\n    const map = this.getMap();\n    const view = /** @type {!import(\"../View.js\").default} */ (map.getView());\n    let geometry = this.getGeometry();\n\n    if (this.out_) {\n      const rotatedExtent = view.rotatedExtentForGeometry(geometry);\n      const resolution = view.getResolutionForExtentInternal(rotatedExtent);\n      const factor = view.getResolution() / resolution;\n      geometry = geometry.clone();\n      geometry.scale(factor * factor);\n    }\n\n    view.fitInternal(geometry, {\n      duration: this.duration_,\n      easing: easeOut,\n    });\n  }\n}\n\nexport default DragZoom;\n","/**\n * @module ol/interaction/KeyboardPan\n */\nimport EventType from '../events/EventType.js';\nimport Interaction, {pan} from './Interaction.js';\nimport KeyCode from '../events/KeyCode.js';\nimport {noModifierKeys, targetNotEditable} from '../events/condition.js';\nimport {rotate as rotateCoordinate} from '../coordinate.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled. Default is\n * {@link module:ol/events/condition.noModifierKeys} and\n * {@link module:ol/events/condition.targetNotEditable}.\n * @property {number} [duration=100] Animation duration in milliseconds.\n * @property {number} [pixelDelta=128] The amount of pixels to pan on each key\n * press.\n */\n\n/**\n * @classdesc\n * Allows the user to pan the map using keyboard arrows.\n * Note that, although this interaction is by default included in maps,\n * the keys can only be used when browser focus is on the element to which\n * the keyboard events are attached. By default, this is the map div,\n * though you can change this with the `keyboardEventTarget` in\n * {@link module:ol/Map~Map}. `document` never loses focus but, for any other\n * element, focus will have to be on, and returned to, this element if the keys\n * are to function.\n * See also {@link module:ol/interaction/KeyboardZoom~KeyboardZoom}.\n * @api\n */\nclass KeyboardPan extends Interaction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n\n    options = options || {};\n\n    /**\n     * @private\n     * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Browser event.\n     * @return {boolean} Combined condition result.\n     */\n    this.defaultCondition_ = function (mapBrowserEvent) {\n      return (\n        noModifierKeys(mapBrowserEvent) && targetNotEditable(mapBrowserEvent)\n      );\n    };\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.condition_ =\n      options.condition !== undefined\n        ? options.condition\n        : this.defaultCondition_;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 100;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelDelta_ =\n      options.pixelDelta !== undefined ? options.pixelDelta : 128;\n  }\n\n  /**\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a\n   * `KeyEvent`, and decides the direction to pan to (if an arrow key was\n   * pressed).\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   */\n  handleEvent(mapBrowserEvent) {\n    let stopEvent = false;\n    if (mapBrowserEvent.type == EventType.KEYDOWN) {\n      const keyEvent = /** @type {KeyboardEvent} */ (\n        mapBrowserEvent.originalEvent\n      );\n      const keyCode = keyEvent.keyCode;\n      if (\n        this.condition_(mapBrowserEvent) &&\n        (keyCode == KeyCode.DOWN ||\n          keyCode == KeyCode.LEFT ||\n          keyCode == KeyCode.RIGHT ||\n          keyCode == KeyCode.UP)\n      ) {\n        const map = mapBrowserEvent.map;\n        const view = map.getView();\n        const mapUnitsDelta = view.getResolution() * this.pixelDelta_;\n        let deltaX = 0,\n          deltaY = 0;\n        if (keyCode == KeyCode.DOWN) {\n          deltaY = -mapUnitsDelta;\n        } else if (keyCode == KeyCode.LEFT) {\n          deltaX = -mapUnitsDelta;\n        } else if (keyCode == KeyCode.RIGHT) {\n          deltaX = mapUnitsDelta;\n        } else {\n          deltaY = mapUnitsDelta;\n        }\n        const delta = [deltaX, deltaY];\n        rotateCoordinate(delta, view.getRotation());\n        pan(view, delta, this.duration_);\n        keyEvent.preventDefault();\n        stopEvent = true;\n      }\n    }\n    return !stopEvent;\n  }\n}\n\nexport default KeyboardPan;\n","/**\n * @module ol/interaction/KeyboardZoom\n */\nimport EventType from '../events/EventType.js';\nimport Interaction, {zoomByDelta} from './Interaction.js';\nimport {targetNotEditable} from '../events/condition.js';\n\n/**\n * @typedef {Object} Options\n * @property {number} [duration=100] Animation duration in milliseconds.\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled. Default is\n * {@link module:ol/events/condition.targetNotEditable}.\n * @property {number} [delta=1] The zoom level delta on each key press.\n */\n\n/**\n * @classdesc\n * Allows the user to zoom the map using keyboard + and -.\n * Note that, although this interaction is by default included in maps,\n * the keys can only be used when browser focus is on the element to which\n * the keyboard events are attached. By default, this is the map div,\n * though you can change this with the `keyboardEventTarget` in\n * {@link module:ol/Map~Map}. `document` never loses focus but, for any other\n * element, focus will have to be on, and returned to, this element if the keys\n * are to function.\n * See also {@link module:ol/interaction/KeyboardPan~KeyboardPan}.\n * @api\n */\nclass KeyboardZoom extends Interaction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n\n    options = options ? options : {};\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.condition_ = options.condition ? options.condition : targetNotEditable;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.delta_ = options.delta ? options.delta : 1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 100;\n  }\n\n  /**\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a\n   * `KeyEvent`, and decides whether to zoom in or out (depending on whether the\n   * key pressed was '+' or '-').\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   */\n  handleEvent(mapBrowserEvent) {\n    let stopEvent = false;\n    if (\n      mapBrowserEvent.type == EventType.KEYDOWN ||\n      mapBrowserEvent.type == EventType.KEYPRESS\n    ) {\n      const keyEvent = /** @type {KeyboardEvent} */ (\n        mapBrowserEvent.originalEvent\n      );\n      const charCode = keyEvent.charCode;\n      if (\n        this.condition_(mapBrowserEvent) &&\n        (charCode == '+'.charCodeAt(0) || charCode == '-'.charCodeAt(0))\n      ) {\n        const map = mapBrowserEvent.map;\n        const delta =\n          charCode == '+'.charCodeAt(0) ? this.delta_ : -this.delta_;\n        const view = map.getView();\n        zoomByDelta(view, delta, undefined, this.duration_);\n        keyEvent.preventDefault();\n        stopEvent = true;\n      }\n    }\n    return !stopEvent;\n  }\n}\n\nexport default KeyboardZoom;\n","/**\n * @module ol/interaction/MouseWheelZoom\n */\nimport EventType from '../events/EventType.js';\nimport Interaction, {zoomByDelta} from './Interaction.js';\nimport {DEVICE_PIXEL_RATIO, FIREFOX} from '../has.js';\nimport {all, always, focusWithTabindex} from '../events/condition.js';\nimport {clamp} from '../math.js';\n\n/**\n * @typedef {'trackpad' | 'wheel'} Mode\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled. Default is\n * {@link module:ol/events/condition.always}.\n * @property {boolean} [onFocusOnly=false] When the map's target has a `tabindex` attribute set,\n * the interaction will only handle events when the map has the focus.\n * @property {number} [maxDelta=1] Maximum mouse wheel delta.\n * @property {number} [duration=250] Animation duration in milliseconds.\n * @property {number} [timeout=80] Mouse wheel timeout duration in milliseconds.\n * @property {boolean} [useAnchor=true] Enable zooming using the mouse's\n * location as the anchor. When set to `false`, zooming in and out will zoom to\n * the center of the screen instead of zooming on the mouse's location.\n * @property {boolean} [constrainResolution=false] If true, the mouse wheel zoom\n * event will always animate to the closest zoom level after an interaction;\n * false means intermediary zoom levels are allowed.\n */\n\n/**\n * @classdesc\n * Allows the user to zoom the map by scrolling the mouse wheel.\n * @api\n */\nclass MouseWheelZoom extends Interaction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    super(\n      /** @type {import(\"./Interaction.js\").InteractionOptions} */ (options)\n    );\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.totalDelta_ = 0;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.lastDelta_ = 0;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = options.maxDelta !== undefined ? options.maxDelta : 1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 250;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.timeout_ = options.timeout !== undefined ? options.timeout : 80;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.useAnchor_ =\n      options.useAnchor !== undefined ? options.useAnchor : true;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.constrainResolution_ =\n      options.constrainResolution !== undefined\n        ? options.constrainResolution\n        : false;\n\n    const condition = options.condition ? options.condition : always;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.condition_ = options.onFocusOnly\n      ? all(focusWithTabindex, condition)\n      : condition;\n\n    /**\n     * @private\n     * @type {?import(\"../coordinate.js\").Coordinate}\n     */\n    this.lastAnchor_ = null;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.startTime_ = undefined;\n\n    /**\n     * @private\n     * @type {?}\n     */\n    this.timeoutId_;\n\n    /**\n     * @private\n     * @type {Mode|undefined}\n     */\n    this.mode_ = undefined;\n\n    /**\n     * Trackpad events separated by this delay will be considered separate\n     * interactions.\n     * @type {number}\n     */\n    this.trackpadEventGap_ = 400;\n\n    /**\n     * @type {?}\n     */\n    this.trackpadTimeoutId_;\n\n    /**\n     * The number of delta values per zoom level\n     * @private\n     * @type {number}\n     */\n    this.deltaPerZoom_ = 300;\n  }\n\n  /**\n   * @private\n   */\n  endInteraction_() {\n    this.trackpadTimeoutId_ = undefined;\n    const map = this.getMap();\n    if (!map) {\n      return;\n    }\n    const view = map.getView();\n    view.endInteraction(\n      undefined,\n      this.lastDelta_ ? (this.lastDelta_ > 0 ? 1 : -1) : 0,\n      this.lastAnchor_\n    );\n  }\n\n  /**\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a mousewheel-event) and eventually\n   * zooms the map.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   */\n  handleEvent(mapBrowserEvent) {\n    if (!this.condition_(mapBrowserEvent)) {\n      return true;\n    }\n    const type = mapBrowserEvent.type;\n    if (type !== EventType.WHEEL) {\n      return true;\n    }\n\n    const map = mapBrowserEvent.map;\n    const wheelEvent = /** @type {WheelEvent} */ (\n      mapBrowserEvent.originalEvent\n    );\n    wheelEvent.preventDefault();\n\n    if (this.useAnchor_) {\n      this.lastAnchor_ = mapBrowserEvent.coordinate;\n    }\n\n    // Delta normalisation inspired by\n    // https://github.com/mapbox/mapbox-gl-js/blob/001c7b9/js/ui/handler/scroll_zoom.js\n    let delta;\n    if (mapBrowserEvent.type == EventType.WHEEL) {\n      delta = wheelEvent.deltaY;\n      if (FIREFOX && wheelEvent.deltaMode === WheelEvent.DOM_DELTA_PIXEL) {\n        delta /= DEVICE_PIXEL_RATIO;\n      }\n      if (wheelEvent.deltaMode === WheelEvent.DOM_DELTA_LINE) {\n        delta *= 40;\n      }\n    }\n\n    if (delta === 0) {\n      return false;\n    }\n    this.lastDelta_ = delta;\n\n    const now = Date.now();\n\n    if (this.startTime_ === undefined) {\n      this.startTime_ = now;\n    }\n\n    if (!this.mode_ || now - this.startTime_ > this.trackpadEventGap_) {\n      this.mode_ = Math.abs(delta) < 4 ? 'trackpad' : 'wheel';\n    }\n\n    const view = map.getView();\n    if (\n      this.mode_ === 'trackpad' &&\n      !(view.getConstrainResolution() || this.constrainResolution_)\n    ) {\n      if (this.trackpadTimeoutId_) {\n        clearTimeout(this.trackpadTimeoutId_);\n      } else {\n        if (view.getAnimating()) {\n          view.cancelAnimations();\n        }\n        view.beginInteraction();\n      }\n      this.trackpadTimeoutId_ = setTimeout(\n        this.endInteraction_.bind(this),\n        this.timeout_\n      );\n      view.adjustZoom(-delta / this.deltaPerZoom_, this.lastAnchor_);\n      this.startTime_ = now;\n      return false;\n    }\n\n    this.totalDelta_ += delta;\n\n    const timeLeft = Math.max(this.timeout_ - (now - this.startTime_), 0);\n\n    clearTimeout(this.timeoutId_);\n    this.timeoutId_ = setTimeout(\n      this.handleWheelZoom_.bind(this, map),\n      timeLeft\n    );\n\n    return false;\n  }\n\n  /**\n   * @private\n   * @param {import(\"../Map.js\").default} map Map.\n   */\n  handleWheelZoom_(map) {\n    const view = map.getView();\n    if (view.getAnimating()) {\n      view.cancelAnimations();\n    }\n    let delta =\n      -clamp(\n        this.totalDelta_,\n        -this.maxDelta_ * this.deltaPerZoom_,\n        this.maxDelta_ * this.deltaPerZoom_\n      ) / this.deltaPerZoom_;\n    if (view.getConstrainResolution() || this.constrainResolution_) {\n      // view has a zoom constraint, zoom by 1\n      delta = delta ? (delta > 0 ? 1 : -1) : 0;\n    }\n    zoomByDelta(view, delta, this.lastAnchor_, this.duration_);\n\n    this.mode_ = undefined;\n    this.totalDelta_ = 0;\n    this.lastAnchor_ = null;\n    this.startTime_ = undefined;\n    this.timeoutId_ = undefined;\n  }\n\n  /**\n   * Enable or disable using the mouse's location as an anchor when zooming\n   * @param {boolean} useAnchor true to zoom to the mouse's location, false\n   * to zoom to the center of the map\n   * @api\n   */\n  setMouseAnchor(useAnchor) {\n    this.useAnchor_ = useAnchor;\n    if (!useAnchor) {\n      this.lastAnchor_ = null;\n    }\n  }\n}\n\nexport default MouseWheelZoom;\n","/**\n * @module ol/interaction/PinchRotate\n */\nimport PointerInteraction, {\n  centroid as centroidFromPointers,\n} from './Pointer.js';\nimport {FALSE} from '../functions.js';\nimport {disable} from '../rotationconstraint.js';\n\n/**\n * @typedef {Object} Options\n * @property {number} [duration=250] The duration of the animation in\n * milliseconds.\n * @property {number} [threshold=0.3] Minimal angle in radians to start a rotation.\n */\n\n/**\n * @classdesc\n * Allows the user to rotate the map by twisting with two fingers\n * on a touch screen.\n * @api\n */\nclass PinchRotate extends PointerInteraction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const pointerOptions = /** @type {import(\"./Pointer.js\").Options} */ (\n      options\n    );\n\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n\n    super(pointerOptions);\n\n    /**\n     * @private\n     * @type {import(\"../coordinate.js\").Coordinate}\n     */\n    this.anchor_ = null;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.lastAngle_ = undefined;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.rotating_ = false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.rotationDelta_ = 0.0;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.threshold_ = options.threshold !== undefined ? options.threshold : 0.3;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 250;\n  }\n\n  /**\n   * Handle pointer drag events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   */\n  handleDragEvent(mapBrowserEvent) {\n    let rotationDelta = 0.0;\n\n    const touch0 = this.targetPointers[0];\n    const touch1 = this.targetPointers[1];\n\n    // angle between touches\n    const angle = Math.atan2(\n      touch1.clientY - touch0.clientY,\n      touch1.clientX - touch0.clientX\n    );\n\n    if (this.lastAngle_ !== undefined) {\n      const delta = angle - this.lastAngle_;\n      this.rotationDelta_ += delta;\n      if (!this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_) {\n        this.rotating_ = true;\n      }\n      rotationDelta = delta;\n    }\n    this.lastAngle_ = angle;\n\n    const map = mapBrowserEvent.map;\n    const view = map.getView();\n    if (view.getConstraints().rotation === disable) {\n      return;\n    }\n\n    // rotate anchor point.\n    // FIXME: should be the intersection point between the lines:\n    //     touch0,touch1 and previousTouch0,previousTouch1\n    this.anchor_ = map.getCoordinateFromPixelInternal(\n      map.getEventPixel(centroidFromPointers(this.targetPointers))\n    );\n\n    // rotate\n    if (this.rotating_) {\n      map.render();\n      view.adjustRotationInternal(rotationDelta, this.anchor_);\n    }\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleUpEvent(mapBrowserEvent) {\n    if (this.targetPointers.length < 2) {\n      const map = mapBrowserEvent.map;\n      const view = map.getView();\n      view.endInteraction(this.duration_);\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Handle pointer down events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleDownEvent(mapBrowserEvent) {\n    if (this.targetPointers.length >= 2) {\n      const map = mapBrowserEvent.map;\n      this.anchor_ = null;\n      this.lastAngle_ = undefined;\n      this.rotating_ = false;\n      this.rotationDelta_ = 0.0;\n      if (!this.handlingDownUpSequence) {\n        map.getView().beginInteraction();\n      }\n      return true;\n    }\n    return false;\n  }\n}\n\nexport default PinchRotate;\n","/**\n * @module ol/interaction/PinchZoom\n */\nimport PointerInteraction, {\n  centroid as centroidFromPointers,\n} from './Pointer.js';\nimport {FALSE} from '../functions.js';\n\n/**\n * @typedef {Object} Options\n * @property {number} [duration=400] Animation duration in milliseconds.\n */\n\n/**\n * @classdesc\n * Allows the user to zoom the map by pinching with two fingers\n * on a touch screen.\n * @api\n */\nclass PinchZoom extends PointerInteraction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const pointerOptions = /** @type {import(\"./Pointer.js\").Options} */ (\n      options\n    );\n\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n\n    super(pointerOptions);\n\n    /**\n     * @private\n     * @type {import(\"../coordinate.js\").Coordinate}\n     */\n    this.anchor_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 400;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.lastDistance_ = undefined;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.lastScaleDelta_ = 1;\n  }\n\n  /**\n   * Handle pointer drag events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   */\n  handleDragEvent(mapBrowserEvent) {\n    let scaleDelta = 1.0;\n\n    const touch0 = this.targetPointers[0];\n    const touch1 = this.targetPointers[1];\n    const dx = touch0.clientX - touch1.clientX;\n    const dy = touch0.clientY - touch1.clientY;\n\n    // distance between touches\n    const distance = Math.sqrt(dx * dx + dy * dy);\n\n    if (this.lastDistance_ !== undefined) {\n      scaleDelta = this.lastDistance_ / distance;\n    }\n    this.lastDistance_ = distance;\n\n    const map = mapBrowserEvent.map;\n    const view = map.getView();\n\n    if (scaleDelta != 1.0) {\n      this.lastScaleDelta_ = scaleDelta;\n    }\n\n    // scale anchor point.\n    this.anchor_ = map.getCoordinateFromPixelInternal(\n      map.getEventPixel(centroidFromPointers(this.targetPointers))\n    );\n\n    // scale, bypass the resolution constraint\n    map.render();\n    view.adjustResolutionInternal(scaleDelta, this.anchor_);\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleUpEvent(mapBrowserEvent) {\n    if (this.targetPointers.length < 2) {\n      const map = mapBrowserEvent.map;\n      const view = map.getView();\n      const direction = this.lastScaleDelta_ > 1 ? 1 : -1;\n      view.endInteraction(this.duration_, direction);\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Handle pointer down events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleDownEvent(mapBrowserEvent) {\n    if (this.targetPointers.length >= 2) {\n      const map = mapBrowserEvent.map;\n      this.anchor_ = null;\n      this.lastDistance_ = undefined;\n      this.lastScaleDelta_ = 1;\n      if (!this.handlingDownUpSequence) {\n        map.getView().beginInteraction();\n      }\n      return true;\n    }\n    return false;\n  }\n}\n\nexport default PinchZoom;\n","/**\n * @module ol/interaction/defaults\n */\nimport Collection from '../Collection.js';\nimport DoubleClickZoom from './DoubleClickZoom.js';\nimport DragPan from './DragPan.js';\nimport DragRotate from './DragRotate.js';\nimport DragZoom from './DragZoom.js';\nimport KeyboardPan from './KeyboardPan.js';\nimport KeyboardZoom from './KeyboardZoom.js';\nimport Kinetic from '../Kinetic.js';\nimport MouseWheelZoom from './MouseWheelZoom.js';\nimport PinchRotate from './PinchRotate.js';\nimport PinchZoom from './PinchZoom.js';\n\n/**\n * @typedef {Object} DefaultsOptions\n * @property {boolean} [altShiftDragRotate=true] Whether Alt-Shift-drag rotate is\n * desired.\n * @property {boolean} [onFocusOnly=false] Interact only when the map has the\n * focus. This affects the `MouseWheelZoom` and `DragPan` interactions and is\n * useful when page scroll is desired for maps that do not have the browser's\n * focus.\n * @property {boolean} [doubleClickZoom=true] Whether double click zoom is\n * desired.\n * @property {boolean} [keyboard=true] Whether keyboard interaction is desired.\n * @property {boolean} [mouseWheelZoom=true] Whether mousewheel zoom is desired.\n * @property {boolean} [shiftDragZoom=true] Whether Shift-drag zoom is desired.\n * @property {boolean} [dragPan=true] Whether drag pan is desired.\n * @property {boolean} [pinchRotate=true] Whether pinch rotate is desired.\n * @property {boolean} [pinchZoom=true] Whether pinch zoom is desired.\n * @property {number} [zoomDelta] Zoom level delta when using keyboard or double click zoom.\n * @property {number} [zoomDuration] Duration of the zoom animation in\n * milliseconds.\n */\n\n/**\n * Set of interactions included in maps by default. Specific interactions can be\n * excluded by setting the appropriate option to false in the constructor\n * options, but the order of the interactions is fixed.  If you want to specify\n * a different order for interactions, you will need to create your own\n * {@link module:ol/interaction/Interaction~Interaction} instances and insert\n * them into a {@link module:ol/Collection~Collection} in the order you want\n * before creating your {@link module:ol/Map~Map} instance. Changing the order can\n * be of interest if the event propagation needs to be stopped at a point.\n * The default set of interactions, in sequence, is:\n * * {@link module:ol/interaction/DragRotate~DragRotate}\n * * {@link module:ol/interaction/DoubleClickZoom~DoubleClickZoom}\n * * {@link module:ol/interaction/DragPan~DragPan}\n * * {@link module:ol/interaction/PinchRotate~PinchRotate}\n * * {@link module:ol/interaction/PinchZoom~PinchZoom}\n * * {@link module:ol/interaction/KeyboardPan~KeyboardPan}\n * * {@link module:ol/interaction/KeyboardZoom~KeyboardZoom}\n * * {@link module:ol/interaction/MouseWheelZoom~MouseWheelZoom}\n * * {@link module:ol/interaction/DragZoom~DragZoom}\n *\n * @param {DefaultsOptions} [options] Defaults options.\n * @return {Collection<import(\"./Interaction.js\").default>}\n * A collection of interactions to be used with the {@link module:ol/Map~Map}\n * constructor's `interactions` option.\n * @api\n */\nexport function defaults(options) {\n  options = options ? options : {};\n\n  /** @type {Collection<import(\"./Interaction.js\").default>} */\n  const interactions = new Collection();\n\n  const kinetic = new Kinetic(-0.005, 0.05, 100);\n\n  const altShiftDragRotate =\n    options.altShiftDragRotate !== undefined\n      ? options.altShiftDragRotate\n      : true;\n  if (altShiftDragRotate) {\n    interactions.push(new DragRotate());\n  }\n\n  const doubleClickZoom =\n    options.doubleClickZoom !== undefined ? options.doubleClickZoom : true;\n  if (doubleClickZoom) {\n    interactions.push(\n      new DoubleClickZoom({\n        delta: options.zoomDelta,\n        duration: options.zoomDuration,\n      })\n    );\n  }\n\n  const dragPan = options.dragPan !== undefined ? options.dragPan : true;\n  if (dragPan) {\n    interactions.push(\n      new DragPan({\n        onFocusOnly: options.onFocusOnly,\n        kinetic: kinetic,\n      })\n    );\n  }\n\n  const pinchRotate =\n    options.pinchRotate !== undefined ? options.pinchRotate : true;\n  if (pinchRotate) {\n    interactions.push(new PinchRotate());\n  }\n\n  const pinchZoom = options.pinchZoom !== undefined ? options.pinchZoom : true;\n  if (pinchZoom) {\n    interactions.push(\n      new PinchZoom({\n        duration: options.zoomDuration,\n      })\n    );\n  }\n\n  const keyboard = options.keyboard !== undefined ? options.keyboard : true;\n  if (keyboard) {\n    interactions.push(new KeyboardPan());\n    interactions.push(\n      new KeyboardZoom({\n        delta: options.zoomDelta,\n        duration: options.zoomDuration,\n      })\n    );\n  }\n\n  const mouseWheelZoom =\n    options.mouseWheelZoom !== undefined ? options.mouseWheelZoom : true;\n  if (mouseWheelZoom) {\n    interactions.push(\n      new MouseWheelZoom({\n        onFocusOnly: options.onFocusOnly,\n        duration: options.zoomDuration,\n      })\n    );\n  }\n\n  const shiftDragZoom =\n    options.shiftDragZoom !== undefined ? options.shiftDragZoom : true;\n  if (shiftDragZoom) {\n    interactions.push(\n      new DragZoom({\n        duration: options.zoomDuration,\n      })\n    );\n  }\n\n  return interactions;\n}\n","/**\n * @module ol/layer/Base\n */\nimport BaseObject from '../Object.js';\nimport LayerProperty from './Property.js';\nimport {abstract} from '../util.js';\nimport {assert} from '../asserts.js';\nimport {clamp} from '../math.js';\n\n/**\n * A css color, or a function called with a view resolution returning a css color.\n *\n * @typedef {string|function(number):string} BackgroundColor\n * @api\n */\n\n/**\n * @typedef {import(\"../ObjectEventType\").Types|'change:extent'|'change:maxResolution'|'change:maxZoom'|\n *    'change:minResolution'|'change:minZoom'|'change:opacity'|'change:visible'|'change:zIndex'} BaseLayerObjectEventTypes\n */\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<BaseLayerObjectEventTypes, import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|BaseLayerObjectEventTypes, Return>} BaseLayerOnSignature\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {BackgroundColor} [background] Background color for the layer. If not specified, no background\n * will be rendered.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Note that with {@link module:ol/layer/Base~BaseLayer} and all its subclasses, any property set in\n * the options is set as a {@link module:ol/Object~BaseObject} property on the layer object, so\n * is observable, and has get/set accessors.\n *\n * @api\n */\nclass BaseLayer extends BaseObject {\n  /**\n   * @param {Options} options Layer options.\n   */\n  constructor(options) {\n    super();\n\n    /***\n     * @type {BaseLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {BaseLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {BaseLayerOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @type {BackgroundColor|false}\n     * @private\n     */\n    this.background_ = options.background;\n\n    /**\n     * @type {Object<string, *>}\n     */\n    const properties = Object.assign({}, options);\n    if (typeof options.properties === 'object') {\n      delete properties.properties;\n      Object.assign(properties, options.properties);\n    }\n\n    properties[LayerProperty.OPACITY] =\n      options.opacity !== undefined ? options.opacity : 1;\n    assert(typeof properties[LayerProperty.OPACITY] === 'number', 64); // Layer opacity must be a number\n\n    properties[LayerProperty.VISIBLE] =\n      options.visible !== undefined ? options.visible : true;\n    properties[LayerProperty.Z_INDEX] = options.zIndex;\n    properties[LayerProperty.MAX_RESOLUTION] =\n      options.maxResolution !== undefined ? options.maxResolution : Infinity;\n    properties[LayerProperty.MIN_RESOLUTION] =\n      options.minResolution !== undefined ? options.minResolution : 0;\n    properties[LayerProperty.MIN_ZOOM] =\n      options.minZoom !== undefined ? options.minZoom : -Infinity;\n    properties[LayerProperty.MAX_ZOOM] =\n      options.maxZoom !== undefined ? options.maxZoom : Infinity;\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.className_ =\n      properties.className !== undefined ? properties.className : 'ol-layer';\n    delete properties.className;\n\n    this.setProperties(properties);\n\n    /**\n     * @type {import(\"./Layer.js\").State}\n     * @private\n     */\n    this.state_ = null;\n  }\n\n  /**\n   * Get the background for this layer.\n   * @return {BackgroundColor|false} Layer background.\n   */\n  getBackground() {\n    return this.background_;\n  }\n\n  /**\n   * @return {string} CSS class name.\n   */\n  getClassName() {\n    return this.className_;\n  }\n\n  /**\n   * This method is not meant to be called by layers or layer renderers because the state\n   * is incorrect if the layer is included in a layer group.\n   *\n   * @param {boolean} [managed] Layer is managed.\n   * @return {import(\"./Layer.js\").State} Layer state.\n   */\n  getLayerState(managed) {\n    /** @type {import(\"./Layer.js\").State} */\n    const state =\n      this.state_ ||\n      /** @type {?} */ ({\n        layer: this,\n        managed: managed === undefined ? true : managed,\n      });\n    const zIndex = this.getZIndex();\n    state.opacity = clamp(Math.round(this.getOpacity() * 100) / 100, 0, 1);\n    state.visible = this.getVisible();\n    state.extent = this.getExtent();\n    state.zIndex = zIndex === undefined && !state.managed ? Infinity : zIndex;\n    state.maxResolution = this.getMaxResolution();\n    state.minResolution = Math.max(this.getMinResolution(), 0);\n    state.minZoom = this.getMinZoom();\n    state.maxZoom = this.getMaxZoom();\n    this.state_ = state;\n\n    return state;\n  }\n\n  /**\n   * @abstract\n   * @param {Array<import(\"./Layer.js\").default>} [array] Array of layers (to be\n   *     modified in place).\n   * @return {Array<import(\"./Layer.js\").default>} Array of layers.\n   */\n  getLayersArray(array) {\n    return abstract();\n  }\n\n  /**\n   * @abstract\n   * @param {Array<import(\"./Layer.js\").State>} [states] Optional list of layer\n   *     states (to be modified in place).\n   * @return {Array<import(\"./Layer.js\").State>} List of layer states.\n   */\n  getLayerStatesArray(states) {\n    return abstract();\n  }\n\n  /**\n   * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it\n   * will be visible regardless of extent.\n   * @return {import(\"../extent.js\").Extent|undefined} The layer extent.\n   * @observable\n   * @api\n   */\n  getExtent() {\n    return /** @type {import(\"../extent.js\").Extent|undefined} */ (\n      this.get(LayerProperty.EXTENT)\n    );\n  }\n\n  /**\n   * Return the maximum resolution of the layer.\n   * @return {number} The maximum resolution of the layer.\n   * @observable\n   * @api\n   */\n  getMaxResolution() {\n    return /** @type {number} */ (this.get(LayerProperty.MAX_RESOLUTION));\n  }\n\n  /**\n   * Return the minimum resolution of the layer.\n   * @return {number} The minimum resolution of the layer.\n   * @observable\n   * @api\n   */\n  getMinResolution() {\n    return /** @type {number} */ (this.get(LayerProperty.MIN_RESOLUTION));\n  }\n\n  /**\n   * Return the minimum zoom level of the layer.\n   * @return {number} The minimum zoom level of the layer.\n   * @observable\n   * @api\n   */\n  getMinZoom() {\n    return /** @type {number} */ (this.get(LayerProperty.MIN_ZOOM));\n  }\n\n  /**\n   * Return the maximum zoom level of the layer.\n   * @return {number} The maximum zoom level of the layer.\n   * @observable\n   * @api\n   */\n  getMaxZoom() {\n    return /** @type {number} */ (this.get(LayerProperty.MAX_ZOOM));\n  }\n\n  /**\n   * Return the opacity of the layer (between 0 and 1).\n   * @return {number} The opacity of the layer.\n   * @observable\n   * @api\n   */\n  getOpacity() {\n    return /** @type {number} */ (this.get(LayerProperty.OPACITY));\n  }\n\n  /**\n   * @abstract\n   * @return {import(\"../source/Source.js\").State} Source state.\n   */\n  getSourceState() {\n    return abstract();\n  }\n\n  /**\n   * Return the visibility of the layer (`true` or `false`).\n   * @return {boolean} The visibility of the layer.\n   * @observable\n   * @api\n   */\n  getVisible() {\n    return /** @type {boolean} */ (this.get(LayerProperty.VISIBLE));\n  }\n\n  /**\n   * Return the Z-index of the layer, which is used to order layers before\n   * rendering. The default Z-index is 0.\n   * @return {number} The Z-index of the layer.\n   * @observable\n   * @api\n   */\n  getZIndex() {\n    return /** @type {number} */ (this.get(LayerProperty.Z_INDEX));\n  }\n\n  /**\n   * Sets the background color.\n   * @param {BackgroundColor} [background] Background color.\n   */\n  setBackground(background) {\n    this.background_ = background;\n    this.changed();\n  }\n\n  /**\n   * Set the extent at which the layer is visible.  If `undefined`, the layer\n   * will be visible at all extents.\n   * @param {import(\"../extent.js\").Extent|undefined} extent The extent of the layer.\n   * @observable\n   * @api\n   */\n  setExtent(extent) {\n    this.set(LayerProperty.EXTENT, extent);\n  }\n\n  /**\n   * Set the maximum resolution at which the layer is visible.\n   * @param {number} maxResolution The maximum resolution of the layer.\n   * @observable\n   * @api\n   */\n  setMaxResolution(maxResolution) {\n    this.set(LayerProperty.MAX_RESOLUTION, maxResolution);\n  }\n\n  /**\n   * Set the minimum resolution at which the layer is visible.\n   * @param {number} minResolution The minimum resolution of the layer.\n   * @observable\n   * @api\n   */\n  setMinResolution(minResolution) {\n    this.set(LayerProperty.MIN_RESOLUTION, minResolution);\n  }\n\n  /**\n   * Set the maximum zoom (exclusive) at which the layer is visible.\n   * Note that the zoom levels for layer visibility are based on the\n   * view zoom level, which may be different from a tile source zoom level.\n   * @param {number} maxZoom The maximum zoom of the layer.\n   * @observable\n   * @api\n   */\n  setMaxZoom(maxZoom) {\n    this.set(LayerProperty.MAX_ZOOM, maxZoom);\n  }\n\n  /**\n   * Set the minimum zoom (inclusive) at which the layer is visible.\n   * Note that the zoom levels for layer visibility are based on the\n   * view zoom level, which may be different from a tile source zoom level.\n   * @param {number} minZoom The minimum zoom of the layer.\n   * @observable\n   * @api\n   */\n  setMinZoom(minZoom) {\n    this.set(LayerProperty.MIN_ZOOM, minZoom);\n  }\n\n  /**\n   * Set the opacity of the layer, allowed values range from 0 to 1.\n   * @param {number} opacity The opacity of the layer.\n   * @observable\n   * @api\n   */\n  setOpacity(opacity) {\n    assert(typeof opacity === 'number', 64); // Layer opacity must be a number\n    this.set(LayerProperty.OPACITY, opacity);\n  }\n\n  /**\n   * Set the visibility of the layer (`true` or `false`).\n   * @param {boolean} visible The visibility of the layer.\n   * @observable\n   * @api\n   */\n  setVisible(visible) {\n    this.set(LayerProperty.VISIBLE, visible);\n  }\n\n  /**\n   * Set Z-index of the layer, which is used to order layers before rendering.\n   * The default Z-index is 0.\n   * @param {number} zindex The z-index of the layer.\n   * @observable\n   * @api\n   */\n  setZIndex(zindex) {\n    this.set(LayerProperty.Z_INDEX, zindex);\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    if (this.state_) {\n      this.state_.layer = null;\n      this.state_ = null;\n    }\n    super.disposeInternal();\n  }\n}\n\nexport default BaseLayer;\n","/**\n * @module ol/layer/BaseTile\n */\nimport Layer from './Layer.js';\nimport TileProperty from './TileProperty.js';\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./Base\").BaseLayerObjectEventTypes|\n *     import(\"./Layer.js\").LayerEventType|'change:preload'|'change:useInterimTilesOnError', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../render/EventType\").LayerRenderEventTypes, import(\"../render/Event\").default, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"./Base\").BaseLayerObjectEventTypes|\n *   import(\"./Layer.js\").LayerEventType|'change:preload'|'change:useInterimTilesOnError'|import(\"../render/EventType\").LayerRenderEventTypes, Return>} BaseTileLayerOnSignature\n */\n\n/**\n * @template {import(\"../source/Tile.js\").default} TileSourceType\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`\n * means no preloading.\n * @property {TileSourceType} [source] Source for this layer.\n * @property {import(\"../Map.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\n * use {@link import(\"../Map.js\").default#addLayer map.addLayer()}.\n * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n\n/**\n * @classdesc\n * For layer sources that provide pre-rendered, tiled images in grids that are\n * organized by zoom levels for specific resolutions.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/Tile.js\").default} TileSourceType\n * @template {import(\"../renderer/Layer.js\").default} RendererType\n * @extends {Layer<TileSourceType, RendererType>}\n * @api\n */\nclass BaseTileLayer extends Layer {\n  /**\n   * @param {Options<TileSourceType>} [options] Tile layer options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const baseOptions = Object.assign({}, options);\n\n    delete baseOptions.preload;\n    delete baseOptions.useInterimTilesOnError;\n    super(baseOptions);\n\n    /***\n     * @type {BaseTileLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {BaseTileLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {BaseTileLayerOnSignature<void>}\n     */\n    this.un;\n\n    this.setPreload(options.preload !== undefined ? options.preload : 0);\n    this.setUseInterimTilesOnError(\n      options.useInterimTilesOnError !== undefined\n        ? options.useInterimTilesOnError\n        : true\n    );\n  }\n\n  /**\n   * Return the level as number to which we will preload tiles up to.\n   * @return {number} The level to preload tiles up to.\n   * @observable\n   * @api\n   */\n  getPreload() {\n    return /** @type {number} */ (this.get(TileProperty.PRELOAD));\n  }\n\n  /**\n   * Set the level as number to which we will preload tiles up to.\n   * @param {number} preload The level to preload tiles up to.\n   * @observable\n   * @api\n   */\n  setPreload(preload) {\n    this.set(TileProperty.PRELOAD, preload);\n  }\n\n  /**\n   * Whether we use interim tiles on error.\n   * @return {boolean} Use interim tiles on error.\n   * @observable\n   * @api\n   */\n  getUseInterimTilesOnError() {\n    return /** @type {boolean} */ (\n      this.get(TileProperty.USE_INTERIM_TILES_ON_ERROR)\n    );\n  }\n\n  /**\n   * Set whether we use interim tiles on error.\n   * @param {boolean} useInterimTilesOnError Use interim tiles on error.\n   * @observable\n   * @api\n   */\n  setUseInterimTilesOnError(useInterimTilesOnError) {\n    this.set(TileProperty.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);\n  }\n\n  /**\n   * Get data for a pixel location.  The return type depends on the source data.  For image tiles,\n   * a four element RGBA array will be returned.  For data tiles, the array length will match the\n   * number of bands in the dataset.  For requests outside the layer extent, `null` will be returned.\n   * Data for a image tiles can only be retrieved if the source's `crossOrigin` property is set.\n   *\n   * ```js\n   * // display layer data on every pointer move\n   * map.on('pointermove', (event) => {\n   *   console.log(layer.getData(event.pixel));\n   * });\n   * ```\n   * @param {import(\"../pixel\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\n   * @api\n   */\n  getData(pixel) {\n    return super.getData(pixel);\n  }\n}\n\nexport default BaseTileLayer;\n","/**\n * @module ol/layer/BaseVector\n */\nimport Layer from './Layer.js';\nimport RBush from 'rbush';\nimport Style, {\n  createDefaultStyle,\n  toFunction as toStyleFunction,\n} from '../style/Style.js';\nimport {toStyle} from '../style/flat.js';\n\n/**\n * @template {import(\"../source/Vector.js\").default|import(\"../source/VectorTile.js\").default} VectorSourceType\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {import(\"../render.js\").OrderFunction} [renderOrder] Render order. Function to be used when sorting\n * features before rendering. By default features are drawn in the order that they are created. Use\n * `null` to avoid the sort, but get an undefined draw order.\n * @property {number} [renderBuffer=100] The buffer in pixels around the viewport extent used by the\n * renderer when getting features from the vector source for the rendering or hit-detection.\n * Recommended value: the size of the largest symbol, line width or label.\n * @property {VectorSourceType} [source] Source.\n * @property {import(\"../Map.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\n * use [map.addLayer()]{@link import(\"../Map.js\").default#addLayer}.\n * @property {boolean} [declutter=false] Declutter images and text. Decluttering is applied to all\n * image and text styles of all Vector and VectorTile layers that have set this to `true`. The priority\n * is defined by the z-index of the layer, the `zIndex` of the style and the render order of features.\n * Higher z-index means higher priority. Within the same z-index, a feature rendered before another has\n * higher priority.\n *\n * As an optimization decluttered features from layers with the same `className` are rendered above\n * the fill and stroke styles of all of those layers regardless of z-index.  To opt out of this\n * behavior and place declutterd features with their own layer configure the layer with a `className`\n * other than `ol-layer`.\n * @property {import(\"../style/Style.js\").StyleLike|import(\"../style/flat.js\").FlatStyleLike|null} [style] Layer style. When set to `null`, only\n * features that have their own style will be rendered. See {@link module:ol/style/Style~Style} for the default style\n * which will be used if this is not set.\n * @property {import(\"./Base.js\").BackgroundColor} [background] Background color for the layer. If not specified, no background\n * will be rendered.\n * @property {boolean} [updateWhileAnimating=false] When set to `true`, feature batches will\n * be recreated during animations. This means that no vectors will be shown clipped, but the\n * setting will have a performance impact for large amounts of vector data. When set to `false`,\n * batches will be recreated when no animation is active.\n * @property {boolean} [updateWhileInteracting=false] When set to `true`, feature batches will\n * be recreated during interactions. See also `updateWhileAnimating`.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n\n/**\n * @enum {string}\n * @private\n */\nconst Property = {\n  RENDER_ORDER: 'renderOrder',\n};\n\n/**\n * @classdesc\n * Vector data that is rendered client-side.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/Vector.js\").default|import(\"../source/VectorTile.js\").default} VectorSourceType\n * @template {import(\"../renderer/canvas/VectorLayer.js\").default|import(\"../renderer/canvas/VectorTileLayer.js\").default|import(\"../renderer/canvas/VectorImageLayer.js\").default|import(\"../renderer/webgl/PointsLayer.js\").default} RendererType\n * @extends {Layer<VectorSourceType, RendererType>}\n * @api\n */\nclass BaseVectorLayer extends Layer {\n  /**\n   * @param {Options<VectorSourceType>} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const baseOptions = Object.assign({}, options);\n\n    delete baseOptions.style;\n    delete baseOptions.renderBuffer;\n    delete baseOptions.updateWhileAnimating;\n    delete baseOptions.updateWhileInteracting;\n    super(baseOptions);\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.declutter_ =\n      options.declutter !== undefined ? options.declutter : false;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.renderBuffer_ =\n      options.renderBuffer !== undefined ? options.renderBuffer : 100;\n\n    /**\n     * User provided style.\n     * @type {import(\"../style/Style.js\").StyleLike}\n     * @private\n     */\n    this.style_ = null;\n\n    /**\n     * Style function for use within the library.\n     * @type {import(\"../style/Style.js\").StyleFunction|undefined}\n     * @private\n     */\n    this.styleFunction_ = undefined;\n\n    this.setStyle(options.style);\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.updateWhileAnimating_ =\n      options.updateWhileAnimating !== undefined\n        ? options.updateWhileAnimating\n        : false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.updateWhileInteracting_ =\n      options.updateWhileInteracting !== undefined\n        ? options.updateWhileInteracting\n        : false;\n  }\n\n  /**\n   * @return {boolean} Declutter.\n   */\n  getDeclutter() {\n    return this.declutter_;\n  }\n\n  /**\n   * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise\n   * that resolves with an array of features. The array will either contain the topmost feature\n   * when a hit was detected, or it will be empty.\n   *\n   * The hit detection algorithm used for this method is optimized for performance, but is less\n   * accurate than the one used in [map.getFeaturesAtPixel()]{@link import(\"../Map.js\").default#getFeaturesAtPixel}.\n   * Text is not considered, and icons are only represented by their bounding box instead of the exact\n   * image.\n   *\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../Feature\").FeatureLike>>} Promise that resolves with an array of features.\n   * @api\n   */\n  getFeatures(pixel) {\n    return super.getFeatures(pixel);\n  }\n\n  /**\n   * @return {number|undefined} Render buffer.\n   */\n  getRenderBuffer() {\n    return this.renderBuffer_;\n  }\n\n  /**\n   * @return {function(import(\"../Feature.js\").default, import(\"../Feature.js\").default): number|null|undefined} Render\n   *     order.\n   */\n  getRenderOrder() {\n    return /** @type {import(\"../render.js\").OrderFunction|null|undefined} */ (\n      this.get(Property.RENDER_ORDER)\n    );\n  }\n\n  /**\n   * Get the style for features.  This returns whatever was passed to the `style`\n   * option at construction or to the `setStyle` method.\n   * @return {import(\"../style/Style.js\").StyleLike|null|undefined} Layer style.\n   * @api\n   */\n  getStyle() {\n    return this.style_;\n  }\n\n  /**\n   * Get the style function.\n   * @return {import(\"../style/Style.js\").StyleFunction|undefined} Layer style function.\n   * @api\n   */\n  getStyleFunction() {\n    return this.styleFunction_;\n  }\n\n  /**\n   * @return {boolean} Whether the rendered layer should be updated while\n   *     animating.\n   */\n  getUpdateWhileAnimating() {\n    return this.updateWhileAnimating_;\n  }\n\n  /**\n   * @return {boolean} Whether the rendered layer should be updated while\n   *     interacting.\n   */\n  getUpdateWhileInteracting() {\n    return this.updateWhileInteracting_;\n  }\n\n  /**\n   * Render declutter items for this layer\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   */\n  renderDeclutter(frameState) {\n    if (!frameState.declutterTree) {\n      frameState.declutterTree = new RBush(9);\n    }\n    /** @type {*} */ (this.getRenderer()).renderDeclutter(frameState);\n  }\n\n  /**\n   * @param {import(\"../render.js\").OrderFunction|null|undefined} renderOrder\n   *     Render order.\n   */\n  setRenderOrder(renderOrder) {\n    this.set(Property.RENDER_ORDER, renderOrder);\n  }\n\n  /**\n   * Set the style for features.  This can be a single style object, an array\n   * of styles, or a function that takes a feature and resolution and returns\n   * an array of styles. If set to `null`, the layer has no style (a `null` style),\n   * so only features that have their own styles will be rendered in the layer. Call\n   * `setStyle()` without arguments to reset to the default style. See\n   * [the ol/style/Style module]{@link module:ol/style/Style~Style} for information on the default style.\n   *\n   * If your layer has a static style, you can use \"flat\" style object literals instead of\n   * using the `Style` and symbolizer constructors (`Fill`, `Stroke`, etc.).  See the documentation\n   * for the [flat style types]{@link module:ol/style/flat~FlatStyle} to see what properties are supported.\n   *\n   * @param {import(\"../style/Style.js\").StyleLike|import(\"../style/flat.js\").FlatStyleLike|null} [style] Layer style.\n   * @api\n   */\n  setStyle(style) {\n    /**\n     * @type {import(\"../style/Style.js\").StyleLike|null}\n     */\n    let styleLike;\n\n    if (style === undefined) {\n      styleLike = createDefaultStyle;\n    } else if (style === null) {\n      styleLike = null;\n    } else if (typeof style === 'function') {\n      styleLike = style;\n    } else if (style instanceof Style) {\n      styleLike = style;\n    } else if (Array.isArray(style)) {\n      const len = style.length;\n\n      /**\n       * @type {Array<Style>}\n       */\n      const styles = new Array(len);\n\n      for (let i = 0; i < len; ++i) {\n        const s = style[i];\n        if (s instanceof Style) {\n          styles[i] = s;\n        } else {\n          styles[i] = toStyle(s);\n        }\n      }\n      styleLike = styles;\n    } else {\n      styleLike = toStyle(style);\n    }\n\n    this.style_ = styleLike;\n    this.styleFunction_ =\n      style === null ? undefined : toStyleFunction(this.style_);\n    this.changed();\n  }\n}\n\nexport default BaseVectorLayer;\n","/**\n * @module ol/layer/Group\n */\nimport BaseLayer from './Base.js';\nimport Collection from '../Collection.js';\nimport CollectionEventType from '../CollectionEventType.js';\nimport Event from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport ObjectEventType from '../ObjectEventType.js';\nimport {assert} from '../asserts.js';\nimport {clear} from '../obj.js';\nimport {getIntersection} from '../extent.js';\nimport {getUid} from '../util.js';\nimport {listen, unlistenByKey} from '../events.js';\n\n/**\n * @typedef {'addlayer'|'removelayer'} EventType\n */\n\n/**\n * @classdesc\n * A layer group triggers 'addlayer' and 'removelayer' events when layers are added to or removed from\n * the group or one of its child groups.  When a layer group is added to or removed from another layer group,\n * a single event will be triggered (instead of one per layer in the group added or removed).\n */\nexport class GroupEvent extends Event {\n  /**\n   * @param {EventType} type The event type.\n   * @param {BaseLayer} layer The layer.\n   */\n  constructor(type, layer) {\n    super(type);\n\n    /**\n     * The added or removed layer.\n     * @type {BaseLayer}\n     * @api\n     */\n    this.layer = layer;\n  }\n}\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./Base\").BaseLayerObjectEventTypes|\n *     'change:layers', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"./Base\").BaseLayerObjectEventTypes|'change:layers', Return>} GroupOnSignature\n */\n\n/**\n * @typedef {Object} Options\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {Array<import(\"./Base.js\").default>|Collection<import(\"./Base.js\").default>} [layers] Child layers.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n\n/**\n * @enum {string}\n * @private\n */\nconst Property = {\n  LAYERS: 'layers',\n};\n\n/**\n * @classdesc\n * A {@link module:ol/Collection~Collection} of layers that are handled together.\n *\n * A generic `change` event is triggered when the group/Collection changes.\n *\n * @api\n */\nclass LayerGroup extends BaseLayer {\n  /**\n   * @param {Options} [options] Layer options.\n   */\n  constructor(options) {\n    options = options || {};\n    const baseOptions = /** @type {Options} */ (Object.assign({}, options));\n    delete baseOptions.layers;\n\n    let layers = options.layers;\n\n    super(baseOptions);\n\n    /***\n     * @type {GroupOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {GroupOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {GroupOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @private\n     * @type {Array<import(\"../events.js\").EventsKey>}\n     */\n    this.layersListenerKeys_ = [];\n\n    /**\n     * @private\n     * @type {Object<string, Array<import(\"../events.js\").EventsKey>>}\n     */\n    this.listenerKeys_ = {};\n\n    this.addChangeListener(Property.LAYERS, this.handleLayersChanged_);\n\n    if (layers) {\n      if (Array.isArray(layers)) {\n        layers = new Collection(layers.slice(), {unique: true});\n      } else {\n        assert(typeof (/** @type {?} */ (layers).getArray) === 'function', 43); // Expected `layers` to be an array or a `Collection`\n      }\n    } else {\n      layers = new Collection(undefined, {unique: true});\n    }\n\n    this.setLayers(layers);\n  }\n\n  /**\n   * @private\n   */\n  handleLayerChange_() {\n    this.changed();\n  }\n\n  /**\n   * @private\n   */\n  handleLayersChanged_() {\n    this.layersListenerKeys_.forEach(unlistenByKey);\n    this.layersListenerKeys_.length = 0;\n\n    const layers = this.getLayers();\n    this.layersListenerKeys_.push(\n      listen(layers, CollectionEventType.ADD, this.handleLayersAdd_, this),\n      listen(layers, CollectionEventType.REMOVE, this.handleLayersRemove_, this)\n    );\n\n    for (const id in this.listenerKeys_) {\n      this.listenerKeys_[id].forEach(unlistenByKey);\n    }\n    clear(this.listenerKeys_);\n\n    const layersArray = layers.getArray();\n    for (let i = 0, ii = layersArray.length; i < ii; i++) {\n      const layer = layersArray[i];\n      this.registerLayerListeners_(layer);\n      this.dispatchEvent(new GroupEvent('addlayer', layer));\n    }\n    this.changed();\n  }\n\n  /**\n   * @param {BaseLayer} layer The layer.\n   */\n  registerLayerListeners_(layer) {\n    const listenerKeys = [\n      listen(\n        layer,\n        ObjectEventType.PROPERTYCHANGE,\n        this.handleLayerChange_,\n        this\n      ),\n      listen(layer, EventType.CHANGE, this.handleLayerChange_, this),\n    ];\n\n    if (layer instanceof LayerGroup) {\n      listenerKeys.push(\n        listen(layer, 'addlayer', this.handleLayerGroupAdd_, this),\n        listen(layer, 'removelayer', this.handleLayerGroupRemove_, this)\n      );\n    }\n\n    this.listenerKeys_[getUid(layer)] = listenerKeys;\n  }\n\n  /**\n   * @param {GroupEvent} event The layer group event.\n   */\n  handleLayerGroupAdd_(event) {\n    this.dispatchEvent(new GroupEvent('addlayer', event.layer));\n  }\n\n  /**\n   * @param {GroupEvent} event The layer group event.\n   */\n  handleLayerGroupRemove_(event) {\n    this.dispatchEvent(new GroupEvent('removelayer', event.layer));\n  }\n\n  /**\n   * @param {import(\"../Collection.js\").CollectionEvent<import(\"./Base.js\").default>} collectionEvent CollectionEvent.\n   * @private\n   */\n  handleLayersAdd_(collectionEvent) {\n    const layer = collectionEvent.element;\n    this.registerLayerListeners_(layer);\n    this.dispatchEvent(new GroupEvent('addlayer', layer));\n    this.changed();\n  }\n\n  /**\n   * @param {import(\"../Collection.js\").CollectionEvent<import(\"./Base.js\").default>} collectionEvent CollectionEvent.\n   * @private\n   */\n  handleLayersRemove_(collectionEvent) {\n    const layer = collectionEvent.element;\n    const key = getUid(layer);\n    this.listenerKeys_[key].forEach(unlistenByKey);\n    delete this.listenerKeys_[key];\n    this.dispatchEvent(new GroupEvent('removelayer', layer));\n    this.changed();\n  }\n\n  /**\n   * Returns the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}\n   * in this group.\n   * @return {!Collection<import(\"./Base.js\").default>} Collection of\n   *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.\n   * @observable\n   * @api\n   */\n  getLayers() {\n    return /** @type {!Collection<import(\"./Base.js\").default>} */ (\n      this.get(Property.LAYERS)\n    );\n  }\n\n  /**\n   * Set the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}\n   * in this group.\n   * @param {!Collection<import(\"./Base.js\").default>} layers Collection of\n   *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.\n   * @observable\n   * @api\n   */\n  setLayers(layers) {\n    const collection = this.getLayers();\n    if (collection) {\n      const currentLayers = collection.getArray();\n      for (let i = 0, ii = currentLayers.length; i < ii; ++i) {\n        this.dispatchEvent(new GroupEvent('removelayer', currentLayers[i]));\n      }\n    }\n\n    this.set(Property.LAYERS, layers);\n  }\n\n  /**\n   * @param {Array<import(\"./Layer.js\").default>} [array] Array of layers (to be modified in place).\n   * @return {Array<import(\"./Layer.js\").default>} Array of layers.\n   */\n  getLayersArray(array) {\n    array = array !== undefined ? array : [];\n    this.getLayers().forEach(function (layer) {\n      layer.getLayersArray(array);\n    });\n    return array;\n  }\n\n  /**\n   * Get the layer states list and use this groups z-index as the default\n   * for all layers in this and nested groups, if it is unset at this point.\n   * If dest is not provided and this group's z-index is undefined\n   * 0 is used a the default z-index.\n   * @param {Array<import(\"./Layer.js\").State>} [dest] Optional list\n   * of layer states (to be modified in place).\n   * @return {Array<import(\"./Layer.js\").State>} List of layer states.\n   */\n  getLayerStatesArray(dest) {\n    const states = dest !== undefined ? dest : [];\n    const pos = states.length;\n\n    this.getLayers().forEach(function (layer) {\n      layer.getLayerStatesArray(states);\n    });\n\n    const ownLayerState = this.getLayerState();\n    let defaultZIndex = ownLayerState.zIndex;\n    if (!dest && ownLayerState.zIndex === undefined) {\n      defaultZIndex = 0;\n    }\n    for (let i = pos, ii = states.length; i < ii; i++) {\n      const layerState = states[i];\n      layerState.opacity *= ownLayerState.opacity;\n      layerState.visible = layerState.visible && ownLayerState.visible;\n      layerState.maxResolution = Math.min(\n        layerState.maxResolution,\n        ownLayerState.maxResolution\n      );\n      layerState.minResolution = Math.max(\n        layerState.minResolution,\n        ownLayerState.minResolution\n      );\n      layerState.minZoom = Math.max(layerState.minZoom, ownLayerState.minZoom);\n      layerState.maxZoom = Math.min(layerState.maxZoom, ownLayerState.maxZoom);\n      if (ownLayerState.extent !== undefined) {\n        if (layerState.extent !== undefined) {\n          layerState.extent = getIntersection(\n            layerState.extent,\n            ownLayerState.extent\n          );\n        } else {\n          layerState.extent = ownLayerState.extent;\n        }\n      }\n      if (layerState.zIndex === undefined) {\n        layerState.zIndex = defaultZIndex;\n      }\n    }\n\n    return states;\n  }\n\n  /**\n   * @return {import(\"../source/Source.js\").State} Source state.\n   */\n  getSourceState() {\n    return 'ready';\n  }\n}\n\nexport default LayerGroup;\n","/**\n * @module ol/layer/Heatmap\n */\nimport BaseVector from './BaseVector.js';\nimport WebGLPointsLayerRenderer from '../renderer/webgl/PointsLayer.js';\nimport {clamp} from '../math.js';\nimport {createCanvasContext2D} from '../dom.js';\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {Array<string>} [gradient=['#00f', '#0ff', '#0f0', '#ff0', '#f00']] The color gradient\n * of the heatmap, specified as an array of CSS color strings.\n * @property {number} [radius=8] Radius size in pixels.\n * @property {number} [blur=15] Blur size in pixels.\n * @property {string|function(import(\"../Feature.js\").default):number} [weight='weight'] The feature\n * attribute to use for the weight or a function that returns a weight from a feature. Weight values\n * should range from 0 to 1 (and values outside will be clamped to that range).\n * @property {import(\"../source/Vector.js\").default<import(\"../geom/Point.js\").default>} [source] Point source.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n\n/**\n * @enum {string}\n * @private\n */\nconst Property = {\n  BLUR: 'blur',\n  GRADIENT: 'gradient',\n  RADIUS: 'radius',\n};\n\n/**\n * @const\n * @type {Array<string>}\n */\nconst DEFAULT_GRADIENT = ['#00f', '#0ff', '#0f0', '#ff0', '#f00'];\n\n/**\n * @classdesc\n * Layer for rendering vector data as a heatmap.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @fires import(\"../render/Event.js\").RenderEvent\n * @extends {BaseVector<import(\"../source/Vector.js\").default, WebGLPointsLayerRenderer>}\n * @api\n */\nclass Heatmap extends BaseVector {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const baseOptions = Object.assign({}, options);\n\n    delete baseOptions.gradient;\n    delete baseOptions.radius;\n    delete baseOptions.blur;\n    delete baseOptions.weight;\n    super(baseOptions);\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.gradient_ = null;\n\n    this.addChangeListener(Property.GRADIENT, this.handleGradientChanged_);\n\n    this.setGradient(options.gradient ? options.gradient : DEFAULT_GRADIENT);\n\n    this.setBlur(options.blur !== undefined ? options.blur : 15);\n\n    this.setRadius(options.radius !== undefined ? options.radius : 8);\n\n    const weight = options.weight ? options.weight : 'weight';\n    if (typeof weight === 'string') {\n      this.weightFunction_ = function (feature) {\n        return feature.get(weight);\n      };\n    } else {\n      this.weightFunction_ = weight;\n    }\n\n    // For performance reasons, don't sort the features before rendering.\n    // The render order is not relevant for a heatmap representation.\n    this.setRenderOrder(null);\n  }\n\n  /**\n   * Return the blur size in pixels.\n   * @return {number} Blur size in pixels.\n   * @api\n   * @observable\n   */\n  getBlur() {\n    return /** @type {number} */ (this.get(Property.BLUR));\n  }\n\n  /**\n   * Return the gradient colors as array of strings.\n   * @return {Array<string>} Colors.\n   * @api\n   * @observable\n   */\n  getGradient() {\n    return /** @type {Array<string>} */ (this.get(Property.GRADIENT));\n  }\n\n  /**\n   * Return the size of the radius in pixels.\n   * @return {number} Radius size in pixel.\n   * @api\n   * @observable\n   */\n  getRadius() {\n    return /** @type {number} */ (this.get(Property.RADIUS));\n  }\n\n  /**\n   * @private\n   */\n  handleGradientChanged_() {\n    this.gradient_ = createGradient(this.getGradient());\n  }\n\n  /**\n   * Set the blur size in pixels.\n   * @param {number} blur Blur size in pixels.\n   * @api\n   * @observable\n   */\n  setBlur(blur) {\n    this.set(Property.BLUR, blur);\n  }\n\n  /**\n   * Set the gradient colors as array of strings.\n   * @param {Array<string>} colors Gradient.\n   * @api\n   * @observable\n   */\n  setGradient(colors) {\n    this.set(Property.GRADIENT, colors);\n  }\n\n  /**\n   * Set the size of the radius in pixels.\n   * @param {number} radius Radius size in pixel.\n   * @api\n   * @observable\n   */\n  setRadius(radius) {\n    this.set(Property.RADIUS, radius);\n  }\n\n  createRenderer() {\n    return new WebGLPointsLayerRenderer(this, {\n      className: this.getClassName(),\n      attributes: [\n        {\n          name: 'weight',\n          callback: (feature) => {\n            const weight = this.weightFunction_(feature);\n            return weight !== undefined ? clamp(weight, 0, 1) : 1;\n          },\n        },\n      ],\n      vertexShader: `\n        precision mediump float;\n        uniform mat4 u_projectionMatrix;\n        uniform mat4 u_offsetScaleMatrix;\n        uniform float u_size;\n        attribute vec2 a_position;\n        attribute float a_index;\n        attribute float a_weight;\n\n        varying vec2 v_texCoord;\n        varying float v_weight;\n\n        void main(void) {\n          mat4 offsetMatrix = u_offsetScaleMatrix;\n          float offsetX = a_index == 0.0 || a_index == 3.0 ? -u_size / 2.0 : u_size / 2.0;\n          float offsetY = a_index == 0.0 || a_index == 1.0 ? -u_size / 2.0 : u_size / 2.0;\n          vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\n          gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\n          float u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\n          float v = a_index == 0.0 || a_index == 1.0 ? 0.0 : 1.0;\n          v_texCoord = vec2(u, v);\n          v_weight = a_weight;\n        }`,\n      fragmentShader: `\n        precision mediump float;\n        uniform float u_blurSlope;\n\n        varying vec2 v_texCoord;\n        varying float v_weight;\n\n        void main(void) {\n          vec2 texCoord = v_texCoord * 2.0 - vec2(1.0, 1.0);\n          float sqRadius = texCoord.x * texCoord.x + texCoord.y * texCoord.y;\n          float value = (1.0 - sqrt(sqRadius)) * u_blurSlope;\n          float alpha = smoothstep(0.0, 1.0, value) * v_weight;\n          gl_FragColor = vec4(alpha, alpha, alpha, alpha);\n        }`,\n      hitVertexShader: `\n        precision mediump float;\n        uniform mat4 u_projectionMatrix;\n        uniform mat4 u_offsetScaleMatrix;\n        uniform float u_size;\n        attribute vec2 a_position;\n        attribute float a_index;\n        attribute float a_weight;\n        attribute vec4 a_hitColor;\n\n        varying vec2 v_texCoord;\n        varying float v_weight;\n        varying vec4 v_hitColor;\n\n        void main(void) {\n          mat4 offsetMatrix = u_offsetScaleMatrix;\n          float offsetX = a_index == 0.0 || a_index == 3.0 ? -u_size / 2.0 : u_size / 2.0;\n          float offsetY = a_index == 0.0 || a_index == 1.0 ? -u_size / 2.0 : u_size / 2.0;\n          vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\n          gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\n          float u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\n          float v = a_index == 0.0 || a_index == 1.0 ? 0.0 : 1.0;\n          v_texCoord = vec2(u, v);\n          v_hitColor = a_hitColor;\n          v_weight = a_weight;\n        }`,\n      hitFragmentShader: `\n        precision mediump float;\n        uniform float u_blurSlope;\n\n        varying vec2 v_texCoord;\n        varying float v_weight;\n        varying vec4 v_hitColor;\n\n        void main(void) {\n          vec2 texCoord = v_texCoord * 2.0 - vec2(1.0, 1.0);\n          float sqRadius = texCoord.x * texCoord.x + texCoord.y * texCoord.y;\n          float value = (1.0 - sqrt(sqRadius)) * u_blurSlope;\n          float alpha = smoothstep(0.0, 1.0, value) * v_weight;\n          if (alpha < 0.05) {\n            discard;\n          }\n\n          gl_FragColor = v_hitColor;\n        }`,\n      uniforms: {\n        u_size: () => {\n          return (this.get(Property.RADIUS) + this.get(Property.BLUR)) * 2;\n        },\n        u_blurSlope: () => {\n          return (\n            this.get(Property.RADIUS) / Math.max(1, this.get(Property.BLUR))\n          );\n        },\n      },\n      postProcesses: [\n        {\n          fragmentShader: `\n            precision mediump float;\n\n            uniform sampler2D u_image;\n            uniform sampler2D u_gradientTexture;\n            uniform float u_opacity;\n\n            varying vec2 v_texCoord;\n\n            void main() {\n              vec4 color = texture2D(u_image, v_texCoord);\n              gl_FragColor.a = color.a * u_opacity;\n              gl_FragColor.rgb = texture2D(u_gradientTexture, vec2(0.5, color.a)).rgb;\n              gl_FragColor.rgb *= gl_FragColor.a;\n            }`,\n          uniforms: {\n            u_gradientTexture: () => {\n              return this.gradient_;\n            },\n            u_opacity: () => {\n              return this.getOpacity();\n            },\n          },\n        },\n      ],\n    });\n  }\n\n  renderDeclutter() {}\n}\n\n/**\n * @param {Array<string>} colors A list of colored.\n * @return {HTMLCanvasElement} canvas with gradient texture.\n */\nfunction createGradient(colors) {\n  const width = 1;\n  const height = 256;\n  const context = createCanvasContext2D(width, height);\n\n  const gradient = context.createLinearGradient(0, 0, width, height);\n  const step = 1 / (colors.length - 1);\n  for (let i = 0, ii = colors.length; i < ii; ++i) {\n    gradient.addColorStop(i * step, colors[i]);\n  }\n\n  context.fillStyle = gradient;\n  context.fillRect(0, 0, width, height);\n\n  return context.canvas;\n}\n\nexport default Heatmap;\n","/**\n * @module ol/layer/BaseImage\n */\nimport Layer from './Layer.js';\n\n/**\n * @template {import(\"../source/Image.js\").default} ImageSourceType\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {import(\"../Map.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\n * use {@link import(\"../Map.js\").default#addLayer map.addLayer()}.\n * @property {ImageSourceType} [source] Source for this layer.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n\n/**\n * @classdesc\n * Server-rendered images that are available for arbitrary extents and\n * resolutions.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/Image.js\").default} ImageSourceType\n * @template {import(\"../renderer/Layer.js\").default} RendererType\n * @extends {Layer<ImageSourceType, RendererType>}\n * @api\n */\nclass BaseImageLayer extends Layer {\n  /**\n   * @param {Options<ImageSourceType>} [options] Layer options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n    super(options);\n  }\n}\n\nexport default BaseImageLayer;\n","/**\n * @module ol/layer/Image\n */\nimport BaseImageLayer from './BaseImage.js';\nimport CanvasImageLayerRenderer from '../renderer/canvas/ImageLayer.js';\n\n/**\n * @classdesc\n * Server-rendered images that are available for arbitrary extents and\n * resolutions.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/Image.js\").default} ImageSourceType\n * @extends {BaseImageLayer<ImageSourceType, CanvasImageLayerRenderer>}\n * @api\n */\nclass ImageLayer extends BaseImageLayer {\n  /**\n   * @param {import(\"./BaseImage.js\").Options<ImageSourceType>} [options] Layer options.\n   */\n  constructor(options) {\n    super(options);\n  }\n\n  createRenderer() {\n    return new CanvasImageLayerRenderer(this);\n  }\n\n  /**\n   * Get data for a pixel location.  A four element RGBA array will be returned.  For requests outside the\n   * layer extent, `null` will be returned.  Data for an image can only be retrieved if the\n   * source's `crossOrigin` property is set.\n   *\n   * ```js\n   * // display layer data on every pointer move\n   * map.on('pointermove', (event) => {\n   *   console.log(layer.getData(event.pixel));\n   * });\n   * ```\n   * @param {import(\"../pixel\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\n   * @api\n   */\n  getData(pixel) {\n    return super.getData(pixel);\n  }\n}\n\nexport default ImageLayer;\n","/**\n * @module ol/layer/Layer\n */\nimport BaseLayer from './Base.js';\nimport EventType from '../events/EventType.js';\nimport LayerProperty from './Property.js';\nimport RenderEventType from '../render/EventType.js';\nimport {assert} from '../asserts.js';\nimport {listen, unlistenByKey} from '../events.js';\n\n/**\n * @typedef {function(import(\"../Map.js\").FrameState):HTMLElement} RenderFunction\n */\n\n/**\n * @typedef {'sourceready'|'change:source'} LayerEventType\n */\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./Base\").BaseLayerObjectEventTypes|\n *     LayerEventType, import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../render/EventType\").LayerRenderEventTypes, import(\"../render/Event\").default, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"./Base\").BaseLayerObjectEventTypes|LayerEventType|\n *     import(\"../render/EventType\").LayerRenderEventTypes, Return>} LayerOnSignature\n */\n\n/**\n * @template {import(\"../source/Source.js\").default} [SourceType=import(\"../source/Source.js\").default]\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {SourceType} [source] Source for this layer.  If not provided to the constructor,\n * the source can be set by calling {@link module:ol/layer/Layer~Layer#setSource layer.setSource(source)} after\n * construction.\n * @property {import(\"../Map.js\").default|null} [map] Map.\n * @property {RenderFunction} [render] Render function. Takes the frame state as input and is expected to return an\n * HTML element. Will overwrite the default rendering for the layer.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n\n/**\n * @typedef {Object} State\n * @property {import(\"./Layer.js\").default} layer Layer.\n * @property {number} opacity Opacity, the value is rounded to two digits to appear after the decimal point.\n * @property {boolean} visible Visible.\n * @property {boolean} managed Managed.\n * @property {import(\"../extent.js\").Extent} [extent] Extent.\n * @property {number} zIndex ZIndex.\n * @property {number} maxResolution Maximum resolution.\n * @property {number} minResolution Minimum resolution.\n * @property {number} minZoom Minimum zoom.\n * @property {number} maxZoom Maximum zoom.\n */\n\n/**\n * @classdesc\n * Base class from which all layer types are derived. This should only be instantiated\n * in the case where a custom layer is added to the map with a custom `render` function.\n * Such a function can be specified in the `options` object, and is expected to return an HTML element.\n *\n * A visual representation of raster or vector map data.\n * Layers group together those properties that pertain to how the data is to be\n * displayed, irrespective of the source of that data.\n *\n * Layers are usually added to a map with [map.addLayer()]{@link import(\"../Map.js\").default#addLayer}.\n * Components like {@link module:ol/interaction/Draw~Draw} use unmanaged layers\n * internally. These unmanaged layers are associated with the map using\n * [layer.setMap()]{@link module:ol/layer/Layer~Layer#setMap} instead.\n *\n * A generic `change` event is fired when the state of the source changes.\n * A `sourceready` event is fired when the layer's source is ready.\n *\n * @fires import(\"../render/Event.js\").RenderEvent#prerender\n * @fires import(\"../render/Event.js\").RenderEvent#postrender\n * @fires import(\"../events/Event.js\").BaseEvent#sourceready\n *\n * @template {import(\"../source/Source.js\").default} [SourceType=import(\"../source/Source.js\").default]\n * @template {import(\"../renderer/Layer.js\").default} [RendererType=import(\"../renderer/Layer.js\").default]\n * @api\n */\nclass Layer extends BaseLayer {\n  /**\n   * @param {Options<SourceType>} options Layer options.\n   */\n  constructor(options) {\n    const baseOptions = Object.assign({}, options);\n    delete baseOptions.source;\n\n    super(baseOptions);\n\n    /***\n     * @type {LayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {LayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {LayerOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @private\n     * @type {?import(\"../events.js\").EventsKey}\n     */\n    this.mapPrecomposeKey_ = null;\n\n    /**\n     * @private\n     * @type {?import(\"../events.js\").EventsKey}\n     */\n    this.mapRenderKey_ = null;\n\n    /**\n     * @private\n     * @type {?import(\"../events.js\").EventsKey}\n     */\n    this.sourceChangeKey_ = null;\n\n    /**\n     * @private\n     * @type {RendererType}\n     */\n    this.renderer_ = null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.sourceReady_ = false;\n\n    /**\n     * @protected\n     * @type {boolean}\n     */\n    this.rendered = false;\n\n    // Overwrite default render method with a custom one\n    if (options.render) {\n      this.render = options.render;\n    }\n\n    if (options.map) {\n      this.setMap(options.map);\n    }\n\n    this.addChangeListener(\n      LayerProperty.SOURCE,\n      this.handleSourcePropertyChange_\n    );\n\n    const source = options.source\n      ? /** @type {SourceType} */ (options.source)\n      : null;\n    this.setSource(source);\n  }\n\n  /**\n   * @param {Array<import(\"./Layer.js\").default>} [array] Array of layers (to be modified in place).\n   * @return {Array<import(\"./Layer.js\").default>} Array of layers.\n   */\n  getLayersArray(array) {\n    array = array ? array : [];\n    array.push(this);\n    return array;\n  }\n\n  /**\n   * @param {Array<import(\"./Layer.js\").State>} [states] Optional list of layer states (to be modified in place).\n   * @return {Array<import(\"./Layer.js\").State>} List of layer states.\n   */\n  getLayerStatesArray(states) {\n    states = states ? states : [];\n    states.push(this.getLayerState());\n    return states;\n  }\n\n  /**\n   * Get the layer source.\n   * @return {SourceType|null} The layer source (or `null` if not yet set).\n   * @observable\n   * @api\n   */\n  getSource() {\n    return /** @type {SourceType} */ (this.get(LayerProperty.SOURCE)) || null;\n  }\n\n  /**\n   * @return {SourceType|null} The source being rendered.\n   */\n  getRenderSource() {\n    return this.getSource();\n  }\n\n  /**\n   * @return {import(\"../source/Source.js\").State} Source state.\n   */\n  getSourceState() {\n    const source = this.getSource();\n    return !source ? 'undefined' : source.getState();\n  }\n\n  /**\n   * @private\n   */\n  handleSourceChange_() {\n    this.changed();\n    if (this.sourceReady_ || this.getSource().getState() !== 'ready') {\n      return;\n    }\n    this.sourceReady_ = true;\n    this.dispatchEvent('sourceready');\n  }\n\n  /**\n   * @private\n   */\n  handleSourcePropertyChange_() {\n    if (this.sourceChangeKey_) {\n      unlistenByKey(this.sourceChangeKey_);\n      this.sourceChangeKey_ = null;\n    }\n    this.sourceReady_ = false;\n    const source = this.getSource();\n    if (source) {\n      this.sourceChangeKey_ = listen(\n        source,\n        EventType.CHANGE,\n        this.handleSourceChange_,\n        this\n      );\n      if (source.getState() === 'ready') {\n        this.sourceReady_ = true;\n        setTimeout(() => {\n          this.dispatchEvent('sourceready');\n        }, 0);\n      }\n    }\n    this.changed();\n  }\n\n  /**\n   * @param {import(\"../pixel\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../Feature\").FeatureLike>>} Promise that resolves with\n   * an array of features.\n   */\n  getFeatures(pixel) {\n    if (!this.renderer_) {\n      return Promise.resolve([]);\n    }\n    return this.renderer_.getFeatures(pixel);\n  }\n\n  /**\n   * @param {import(\"../pixel\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\n   */\n  getData(pixel) {\n    if (!this.renderer_ || !this.rendered) {\n      return null;\n    }\n    return this.renderer_.getData(pixel);\n  }\n\n  /**\n   * In charge to manage the rendering of the layer. One layer type is\n   * bounded with one layer renderer.\n   * @param {?import(\"../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target which the renderer may (but need not) use\n   * for rendering its content.\n   * @return {HTMLElement} The rendered element.\n   */\n  render(frameState, target) {\n    const layerRenderer = this.getRenderer();\n\n    if (layerRenderer.prepareFrame(frameState)) {\n      this.rendered = true;\n      return layerRenderer.renderFrame(frameState, target);\n    }\n  }\n\n  /**\n   * Called when a layer is not visible during a map render.\n   */\n  unrender() {\n    this.rendered = false;\n  }\n\n  /**\n   * For use inside the library only.\n   * @param {import(\"../Map.js\").default|null} map Map.\n   */\n  setMapInternal(map) {\n    if (!map) {\n      this.unrender();\n    }\n    this.set(LayerProperty.MAP, map);\n  }\n\n  /**\n   * For use inside the library only.\n   * @return {import(\"../Map.js\").default|null} Map.\n   */\n  getMapInternal() {\n    return this.get(LayerProperty.MAP);\n  }\n\n  /**\n   * Sets the layer to be rendered on top of other layers on a map. The map will\n   * not manage this layer in its layers collection. This\n   * is useful for temporary layers. To remove an unmanaged layer from the map,\n   * use `#setMap(null)`.\n   *\n   * To add the layer to a map and have it managed by the map, use\n   * {@link module:ol/Map~Map#addLayer} instead.\n   * @param {import(\"../Map.js\").default|null} map Map.\n   * @api\n   */\n  setMap(map) {\n    if (this.mapPrecomposeKey_) {\n      unlistenByKey(this.mapPrecomposeKey_);\n      this.mapPrecomposeKey_ = null;\n    }\n    if (!map) {\n      this.changed();\n    }\n    if (this.mapRenderKey_) {\n      unlistenByKey(this.mapRenderKey_);\n      this.mapRenderKey_ = null;\n    }\n    if (map) {\n      this.mapPrecomposeKey_ = listen(\n        map,\n        RenderEventType.PRECOMPOSE,\n        function (evt) {\n          const renderEvent =\n            /** @type {import(\"../render/Event.js\").default} */ (evt);\n          const layerStatesArray = renderEvent.frameState.layerStatesArray;\n          const layerState = this.getLayerState(false);\n          // A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both.\n          assert(\n            !layerStatesArray.some(function (arrayLayerState) {\n              return arrayLayerState.layer === layerState.layer;\n            }),\n            67\n          );\n          layerStatesArray.push(layerState);\n        },\n        this\n      );\n      this.mapRenderKey_ = listen(this, EventType.CHANGE, map.render, map);\n      this.changed();\n    }\n  }\n\n  /**\n   * Set the layer source.\n   * @param {SourceType|null} source The layer source.\n   * @observable\n   * @api\n   */\n  setSource(source) {\n    this.set(LayerProperty.SOURCE, source);\n  }\n\n  /**\n   * Get the renderer for this layer.\n   * @return {RendererType|null} The layer renderer.\n   */\n  getRenderer() {\n    if (!this.renderer_) {\n      this.renderer_ = this.createRenderer();\n    }\n    return this.renderer_;\n  }\n\n  /**\n   * @return {boolean} The layer has a renderer.\n   */\n  hasRenderer() {\n    return !!this.renderer_;\n  }\n\n  /**\n   * Create a renderer for this layer.\n   * @return {RendererType} A layer renderer.\n   * @protected\n   */\n  createRenderer() {\n    return null;\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    if (this.renderer_) {\n      this.renderer_.dispose();\n      delete this.renderer_;\n    }\n\n    this.setSource(null);\n    super.disposeInternal();\n  }\n}\n\n/**\n * Return `true` if the layer is visible and if the provided view state\n * has resolution and zoom levels that are in range of the layer's min/max.\n * @param {State} layerState Layer state.\n * @param {import(\"../View.js\").State} viewState View state.\n * @return {boolean} The layer is visible at the given view state.\n */\nexport function inView(layerState, viewState) {\n  if (!layerState.visible) {\n    return false;\n  }\n  const resolution = viewState.resolution;\n  if (\n    resolution < layerState.minResolution ||\n    resolution >= layerState.maxResolution\n  ) {\n    return false;\n  }\n  const zoom = viewState.zoom;\n  return zoom > layerState.minZoom && zoom <= layerState.maxZoom;\n}\n\nexport default Layer;\n","/**\n * @module ol/layer/Property\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  OPACITY: 'opacity',\n  VISIBLE: 'visible',\n  EXTENT: 'extent',\n  Z_INDEX: 'zIndex',\n  MAX_RESOLUTION: 'maxResolution',\n  MIN_RESOLUTION: 'minResolution',\n  MAX_ZOOM: 'maxZoom',\n  MIN_ZOOM: 'minZoom',\n  SOURCE: 'source',\n  MAP: 'map',\n};\n","/**\n * @module ol/layer/Tile\n */\nimport BaseTileLayer from './BaseTile.js';\nimport CanvasTileLayerRenderer from '../renderer/canvas/TileLayer.js';\n\n/**\n * @classdesc\n * For layer sources that provide pre-rendered, tiled images in grids that are\n * organized by zoom levels for specific resolutions.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/Tile.js\").default} TileSourceType\n * @extends BaseTileLayer<TileSourceType, CanvasTileLayerRenderer>\n * @api\n */\nclass TileLayer extends BaseTileLayer {\n  /**\n   * @param {import(\"./BaseTile.js\").Options<TileSourceType>} [options] Tile layer options.\n   */\n  constructor(options) {\n    super(options);\n  }\n\n  createRenderer() {\n    return new CanvasTileLayerRenderer(this);\n  }\n}\n\nexport default TileLayer;\n","/**\n * @module ol/layer/TileProperty\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  PRELOAD: 'preload',\n  USE_INTERIM_TILES_ON_ERROR: 'useInterimTilesOnError',\n};\n","/**\n * @module ol/layer/Vector\n */\nimport BaseVectorLayer from './BaseVector.js';\nimport CanvasVectorLayerRenderer from '../renderer/canvas/VectorLayer.js';\n\n/**\n * @classdesc\n * Vector data is rendered client-side, as vectors. This layer type provides most accurate rendering\n * even during animations. Points and labels stay upright on rotated views. For very large\n * amounts of vector data, performance may suffer during pan and zoom animations. In this case,\n * try {@link module:ol/layer/VectorImage~VectorImageLayer}.\n *\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/Vector.js\").default} VectorSourceType\n * @extends {BaseVectorLayer<VectorSourceType, CanvasVectorLayerRenderer>}\n * @api\n */\nclass VectorLayer extends BaseVectorLayer {\n  /**\n   * @param {import(\"./BaseVector.js\").Options<VectorSourceType>} [options] Options.\n   */\n  constructor(options) {\n    super(options);\n  }\n\n  createRenderer() {\n    return new CanvasVectorLayerRenderer(this);\n  }\n}\n\nexport default VectorLayer;\n","/**\n * @module ol/layer/VectorTile\n */\nimport BaseVectorLayer from './BaseVector.js';\nimport CanvasVectorTileLayerRenderer from '../renderer/canvas/VectorTileLayer.js';\nimport TileProperty from './TileProperty.js';\nimport {assert} from '../asserts.js';\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./Base\").BaseLayerObjectEventTypes|\n *     import(\"./Layer.js\").LayerEventType|'change:preload'|'change:useInterimTilesOnError', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../render/EventType\").LayerRenderEventTypes, import(\"../render/Event\").default, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"./Base\").BaseLayerObjectEventTypes|\n *     import(\"./Layer.js\").LayerEventType|'change:preload'|'change:useInterimTilesOnError'|import(\"../render/EventType\").LayerRenderEventTypes, Return>} VectorTileLayerOnSignature\n */\n\n/**\n * @typedef {'hybrid' | 'vector'} VectorTileRenderType\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {import(\"../render.js\").OrderFunction} [renderOrder] Render order. Function to be used when sorting\n * features before rendering. By default features are drawn in the order that they are created. Use\n * `null` to avoid the sort, but get an undefined draw order.\n * @property {number} [renderBuffer=100] The buffer in pixels around the tile extent used by the\n * renderer when getting features from the vector tile for the rendering or hit-detection.\n * Recommended value: Vector tiles are usually generated with a buffer, so this value should match\n * the largest possible buffer of the used tiles. It should be at least the size of the largest\n * point symbol or line width.\n * @property {VectorTileRenderType} [renderMode='hybrid'] Render mode for vector tiles:\n *  * `'hybrid'`: Polygon and line elements are rendered as images, so pixels are scaled during zoom\n *    animations. Point symbols and texts are accurately rendered as vectors and can stay upright on\n *    rotated views.\n *  * `'vector'`: Everything is rendered as vectors. Use this mode for improved performance on vector\n *    tile layers with only a few rendered features (e.g. for highlighting a subset of features of\n *    another layer with the same source).\n * @property {import(\"../source/VectorTile.js\").default} [source] Source.\n * @property {import(\"../Map.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\n * use [map.addLayer()]{@link import(\"../Map.js\").default#addLayer}.\n * @property {boolean} [declutter=false] Declutter images and text. Decluttering is applied to all\n * image and text styles of all Vector and VectorTile layers that have set this to `true`. The priority\n * is defined by the z-index of the layer, the `zIndex` of the style and the render order of features.\n * Higher z-index means higher priority. Within the same z-index, a feature rendered before another has\n * higher priority.\n *\n * As an optimization decluttered features from layers with the same `className` are rendered above\n * the fill and stroke styles of all of those layers regardless of z-index.  To opt out of this\n * behavior and place declutterd features with their own layer configure the layer with a `className`\n * other than `ol-layer`.\n * @property {import(\"../style/Style.js\").StyleLike|null} [style] Layer style. When set to `null`, only\n * features that have their own style will be rendered. See {@link module:ol/style/Style~Style} for the default style\n * which will be used if this is not set.\n * @property {import(\"./Base.js\").BackgroundColor|false} [background] Background color for the layer. If not specified, no\n * background will be rendered.\n * @property {boolean} [updateWhileAnimating=false] When set to `true`, feature batches will be\n * recreated during animations. This means that no vectors will be shown clipped, but the setting\n * will have a performance impact for large amounts of vector data. When set to `false`, batches\n * will be recreated when no animation is active.\n * @property {boolean} [updateWhileInteracting=false] When set to `true`, feature batches will be\n * recreated during interactions. See also `updateWhileAnimating`.\n * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`\n * means no preloading.\n * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n\n/**\n * @classdesc\n * Layer for vector tile data that is rendered client-side.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @param {Options} [options] Options.\n * @extends {BaseVectorLayer<import(\"../source/VectorTile.js\").default, CanvasVectorTileLayerRenderer>}\n * @api\n */\nclass VectorTileLayer extends BaseVectorLayer {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const baseOptions = /** @type {Object} */ (Object.assign({}, options));\n    delete baseOptions.preload;\n    delete baseOptions.useInterimTilesOnError;\n\n    super(\n      /** @type {import(\"./BaseVector.js\").Options<import(\"../source/VectorTile.js\").default>} */ (\n        baseOptions\n      )\n    );\n\n    /***\n     * @type {VectorTileLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {VectorTileLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {VectorTileLayerOnSignature<void>}\n     */\n    this.un;\n\n    const renderMode = options.renderMode || 'hybrid';\n    // `renderMode` must be `'hybrid'` or `'vector'`.\n    assert(renderMode == 'hybrid' || renderMode == 'vector', 28);\n\n    /**\n     * @private\n     * @type {VectorTileRenderType}\n     */\n    this.renderMode_ = renderMode;\n\n    this.setPreload(options.preload ? options.preload : 0);\n    this.setUseInterimTilesOnError(\n      options.useInterimTilesOnError !== undefined\n        ? options.useInterimTilesOnError\n        : true\n    );\n\n    /**\n     * @return {import(\"./Base.js\").BackgroundColor} Background color.\n     * @function\n     * @api\n     */\n    this.getBackground;\n\n    /**\n     * @param {import(\"./Base.js\").BackgroundColor} background Background color.\n     * @function\n     * @api\n     */\n    this.setBackground;\n  }\n\n  createRenderer() {\n    return new CanvasVectorTileLayerRenderer(this);\n  }\n\n  /**\n   * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise\n   * that resolves with an array of features. The array will either contain the topmost feature\n   * when a hit was detected, or it will be empty.\n   *\n   * The hit detection algorithm used for this method is optimized for performance, but is less\n   * accurate than the one used in [map.getFeaturesAtPixel()]{@link import(\"../Map.js\").default#getFeaturesAtPixel}.\n   * Text is not considered, and icons are only represented by their bounding box instead of the exact\n   * image.\n   *\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../Feature\").FeatureLike>>} Promise that resolves with an array of features.\n   * @api\n   */\n  getFeatures(pixel) {\n    return super.getFeatures(pixel);\n  }\n\n  /**\n   * @return {VectorTileRenderType} The render mode.\n   */\n  getRenderMode() {\n    return this.renderMode_;\n  }\n\n  /**\n   * Return the level as number to which we will preload tiles up to.\n   * @return {number} The level to preload tiles up to.\n   * @observable\n   * @api\n   */\n  getPreload() {\n    return /** @type {number} */ (this.get(TileProperty.PRELOAD));\n  }\n\n  /**\n   * Whether we use interim tiles on error.\n   * @return {boolean} Use interim tiles on error.\n   * @observable\n   * @api\n   */\n  getUseInterimTilesOnError() {\n    return /** @type {boolean} */ (\n      this.get(TileProperty.USE_INTERIM_TILES_ON_ERROR)\n    );\n  }\n\n  /**\n   * Set the level as number to which we will preload tiles up to.\n   * @param {number} preload The level to preload tiles up to.\n   * @observable\n   * @api\n   */\n  setPreload(preload) {\n    this.set(TileProperty.PRELOAD, preload);\n  }\n\n  /**\n   * Set whether we use interim tiles on error.\n   * @param {boolean} useInterimTilesOnError Use interim tiles on error.\n   * @observable\n   * @api\n   */\n  setUseInterimTilesOnError(useInterimTilesOnError) {\n    this.set(TileProperty.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);\n  }\n}\n\nexport default VectorTileLayer;\n","/**\n * @module ol/loadingstrategy\n */\n\nimport {fromUserExtent, fromUserResolution, toUserExtent} from './proj.js';\n\n/**\n * Strategy function for loading all features with a single request.\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number} resolution Resolution.\n * @return {Array<import(\"./extent.js\").Extent>} Extents.\n * @api\n */\nexport function all(extent, resolution) {\n  return [[-Infinity, -Infinity, Infinity, Infinity]];\n}\n\n/**\n * Strategy function for loading features based on the view's extent and\n * resolution.\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number} resolution Resolution.\n * @return {Array<import(\"./extent.js\").Extent>} Extents.\n * @api\n */\nexport function bbox(extent, resolution) {\n  return [extent];\n}\n\n/**\n * Creates a strategy function for loading features based on a tile grid.\n * @param {import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {function(import(\"./extent.js\").Extent, number, import(\"./proj.js\").Projection): Array<import(\"./extent.js\").Extent>} Loading strategy.\n * @api\n */\nexport function tile(tileGrid) {\n  return (\n    /**\n     * @param {import(\"./extent.js\").Extent} extent Extent.\n     * @param {number} resolution Resolution.\n     * @param {import(\"./proj.js\").Projection} projection Projection.\n     * @return {Array<import(\"./extent.js\").Extent>} Extents.\n     */\n    function (extent, resolution, projection) {\n      const z = tileGrid.getZForResolution(\n        fromUserResolution(resolution, projection)\n      );\n      const tileRange = tileGrid.getTileRangeForExtentAndZ(\n        fromUserExtent(extent, projection),\n        z\n      );\n      /** @type {Array<import(\"./extent.js\").Extent>} */\n      const extents = [];\n      /** @type {import(\"./tilecoord.js\").TileCoord} */\n      const tileCoord = [z, 0, 0];\n      for (\n        tileCoord[1] = tileRange.minX;\n        tileCoord[1] <= tileRange.maxX;\n        ++tileCoord[1]\n      ) {\n        for (\n          tileCoord[2] = tileRange.minY;\n          tileCoord[2] <= tileRange.maxY;\n          ++tileCoord[2]\n        ) {\n          extents.push(\n            toUserExtent(tileGrid.getTileCoordExtent(tileCoord), projection)\n          );\n        }\n      }\n      return extents;\n    }\n  );\n}\n","/**\n * @module ol/obj\n */\n\n/**\n * Removes all properties from an object.\n * @param {Object} object The object to clear.\n */\nexport function clear(object) {\n  for (const property in object) {\n    delete object[property];\n  }\n}\n\n/**\n * Determine if an object has any properties.\n * @param {Object} object The object to check.\n * @return {boolean} The object is empty.\n */\nexport function isEmpty(object) {\n  let property;\n  for (property in object) {\n    return false;\n  }\n  return !property;\n}\n"],"names":["ua","navigator","userAgent","toLowerCase","FIREFOX","includes","SAFARI","SAFARI_BUG_237906","test","WEBKIT","MAC","DEVICE_PIXEL_RATIO","devicePixelRatio","WORKER_OFFSCREEN_CANVAS","WorkerGlobalScope","OffscreenCanvas","self","IMAGE_DECODE","Image","prototype","decode","PASSIVE_EVENT_LISTENERS","passive","options","Object","defineProperty","get","window","addEventListener","removeEventListener","error","Interaction","constructor","super","this","on","once","un","handleEvent","map_","setActive","getActive","getMap","mapBrowserEvent","active","set","setMap","map","pan","view","delta","duration","currentCenter","getCenterInternal","center","animateInternal","undefined","easing","getConstrainedCenter","zoomByDelta","anchor","currentZoom","getZoom","newZoom","getConstrainedZoom","newResolution","getResolutionForZoom","getAnimating","cancelAnimations","animate","resolution","PointerInteraction","handleDownEvent","handleDragEvent","handleMoveEvent","handleUpEvent","stopDown","handlingDownUpSequence","targetPointers","getPointerCount","length","originalEvent","stopEvent","updateTrackedPointers_","type","preventDefault","handledUp","handled","activePointers","centroid","pointerEvents","clientX","clientY","i","ACTIVE","SelectEventType","SELECT","SelectEvent","selected","deselected","originalFeatureStyles","Select","layerFilter","boundAddFeature_","addFeature_","bind","boundRemoveFeature_","removeFeature_","condition_","condition","addCondition_","addCondition","removeCondition_","removeCondition","toggleCondition_","toggleCondition","multi_","multi","filter_","filter","hitTolerance_","hitTolerance","style_","style","getDefaultStyleFunction","features_","features","layers","layer","layerFilter_","featureLayerAssociation_","addFeatureLayerAssociation_","feature","getFeatures","getHitTolerance","getLayer","setHitTolerance","currentMap","forEach","restorePreviousStyle_","applySelectedStyle_","evt","element","getAllLayers","find","getSource","hasFeature","getStyle","key","setStyle","interactions","getInteractions","getArray","interaction","lastIndexOf","removeFeatureLayerAssociation_","add","remove","toggle","forEachFeatureAtPixel","pixel","push","getLength","item","index","indexOf","splice","extend","j","dispatchEvent","styles","createEditingStyle","getGeometry","getType","DoubleClickZoom","delta_","duration_","MapBrowserEventType","browserEvent","coordinate","shiftKey","getView","DragPan","Pointer","kinetic_","kinetic","lastCentroid","lastPointersCount_","panning_","onFocusOnly","noKinetic_","beginInteraction","getEventPixel","update","getResolution","getRotation","adjustCenterInternal","begin","end","distance","getDistance","angle","getAngle","centerpx","getPixelFromCoordinateInternal","dest","getCoordinateFromPixelInternal","Math","cos","sin","endInteraction","DragRotate","lastAngle_","getConstraints","rotation","size","getSize","offset","theta","atan2","adjustRotationInternal","DragBoxEventType","BOXSTART","BOXDRAG","BOXEND","BOXCANCEL","DragBoxEvent","Event","DragBox","box_","className","minArea_","minArea","onBoxEnd","startPixel_","boxEndCondition_","boxEndCondition","defaultBoxEndCondition","startPixel","endPixel","width","height","setPixels","completeBox","event","DragZoom","out_","out","geometry","rotatedExtent","rotatedExtentForGeometry","getResolutionForExtentInternal","factor","clone","scale","fitInternal","KeyboardPan","defaultCondition_","pixelDelta_","pixelDelta","EventType","keyEvent","keyCode","KeyCode","mapUnitsDelta","deltaX","deltaY","KeyboardZoom","charCode","charCodeAt","MouseWheelZoom","totalDelta_","lastDelta_","maxDelta_","maxDelta","timeout_","timeout","useAnchor_","useAnchor","constrainResolution_","constrainResolution","lastAnchor_","startTime_","timeoutId_","mode_","trackpadEventGap_","trackpadTimeoutId_","deltaPerZoom_","endInteraction_","wheelEvent","deltaMode","WheelEvent","DOM_DELTA_PIXEL","DOM_DELTA_LINE","now","Date","abs","getConstrainResolution","clearTimeout","setTimeout","adjustZoom","timeLeft","max","handleWheelZoom_","setMouseAnchor","PinchRotate","pointerOptions","anchor_","rotating_","rotationDelta_","threshold_","threshold","rotationDelta","touch0","touch1","render","PinchZoom","lastDistance_","lastScaleDelta_","scaleDelta","dx","dy","sqrt","adjustResolutionInternal","direction","defaults","Collection","Kinetic","altShiftDragRotate","doubleClickZoom","zoomDelta","zoomDuration","dragPan","pinchRotate","pinchZoom","keyboard","mouseWheelZoom","shiftDragZoom","BaseLayer","background_","background","properties","assign","opacity","visible","zIndex","maxResolution","Infinity","minResolution","minZoom","maxZoom","className_","setProperties","state_","getBackground","getClassName","getLayerState","managed","state","getZIndex","round","getOpacity","getVisible","extent","getExtent","getMaxResolution","getMinResolution","getMinZoom","getMaxZoom","getLayersArray","array","getLayerStatesArray","states","getSourceState","setBackground","changed","setExtent","setMaxResolution","setMinResolution","setMaxZoom","setMinZoom","setOpacity","setVisible","setZIndex","zindex","disposeInternal","BaseTileLayer","baseOptions","preload","useInterimTilesOnError","setPreload","setUseInterimTilesOnError","getPreload","getUseInterimTilesOnError","getData","Property","RENDER_ORDER","BaseVectorLayer","renderBuffer","updateWhileAnimating","updateWhileInteracting","declutter_","declutter","renderBuffer_","styleFunction_","updateWhileAnimating_","updateWhileInteracting_","getDeclutter","getRenderBuffer","getRenderOrder","getStyleFunction","getUpdateWhileAnimating","getUpdateWhileInteracting","renderDeclutter","frameState","declutterTree","getRenderer","setRenderOrder","renderOrder","styleLike","createDefaultStyle","Array","isArray","len","s","GroupEvent","LAYERS","LayerGroup","layersListenerKeys_","listenerKeys_","addChangeListener","handleLayersChanged_","slice","unique","setLayers","handleLayerChange_","getLayers","handleLayersAdd_","handleLayersRemove_","id","layersArray","ii","registerLayerListeners_","listenerKeys","handleLayerGroupAdd_","handleLayerGroupRemove_","collectionEvent","collection","currentLayers","pos","ownLayerState","defaultZIndex","layerState","min","BLUR","GRADIENT","RADIUS","DEFAULT_GRADIENT","Heatmap","gradient","radius","blur","weight","gradient_","handleGradientChanged_","setGradient","setBlur","setRadius","weightFunction_","getBlur","getGradient","getRadius","createGradient","colors","createRenderer","attributes","name","callback","vertexShader","fragmentShader","hitVertexShader","hitFragmentShader","uniforms","u_size","u_blurSlope","postProcesses","u_gradientTexture","u_opacity","context","createLinearGradient","step","addColorStop","fillStyle","fillRect","canvas","BaseImageLayer","Layer","ImageLayer","BaseImage","source","mapPrecomposeKey_","mapRenderKey_","sourceChangeKey_","renderer_","sourceReady_","rendered","handleSourcePropertyChange_","setSource","getRenderSource","getState","handleSourceChange_","Promise","resolve","target","layerRenderer","prepareFrame","renderFrame","unrender","setMapInternal","getMapInternal","renderEvent","layerStatesArray","some","arrayLayerState","hasRenderer","dispose","inView","viewState","zoom","OPACITY","VISIBLE","EXTENT","Z_INDEX","MAX_RESOLUTION","MIN_RESOLUTION","MAX_ZOOM","MIN_ZOOM","SOURCE","MAP","TileLayer","PRELOAD","USE_INTERIM_TILES_ON_ERROR","VectorLayer","VectorTileLayer","renderMode","renderMode_","getRenderMode","all","clear","object","property","isEmpty"],"sourceRoot":""}
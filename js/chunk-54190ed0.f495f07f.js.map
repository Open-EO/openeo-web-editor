{"version":3,"sources":["webpack:///./node_modules/ol/extent/Relationship.js","webpack:///./node_modules/ol/extent.js","webpack:///./node_modules/ol/util.js","webpack:///./node_modules/ol/proj.js","webpack:///./node_modules/ol/extent/Corner.js","webpack:///./node_modules/ol/obj.js","webpack:///./node_modules/ol/sphere.js","webpack:///./node_modules/ol/math.js","webpack:///./node_modules/ol/AssertionError.js","webpack:///./node_modules/ol/proj/epsg4326.js","webpack:///./node_modules/ol/asserts.js","webpack:///./node_modules/ol/proj/epsg3857.js","webpack:///./node_modules/ol/coordinate.js","webpack:///./node_modules/ol/string.js","webpack:///./node_modules/ol/proj/proj4.js","webpack:///./node_modules/ol/proj/projections.js","webpack:///./node_modules/ol/proj/transforms.js","webpack:///./node_modules/ol/proj/Projection.js","webpack:///./node_modules/ol/geom/GeometryType.js","webpack:///./node_modules/ol/proj/Units.js"],"names":["UNKNOWN","INTERSECTING","ABOVE","RIGHT","BELOW","LEFT","boundingExtent","coordinates","extent","createEmpty","i","ii","length","extendCoordinate","_boundingExtentXYs","xs","ys","opt_extent","minX","Math","min","apply","minY","maxX","max","maxY","createOrUpdate","buffer","value","clone","slice","closestSquaredDistanceXY","x","y","dx","dy","containsCoordinate","coordinate","containsXY","containsExtent","extent1","extent2","coordinateRelationship","relationship","Infinity","createOrUpdateEmpty","createOrUpdateFromCoordinate","createOrUpdateFromFlatCoordinates","flatCoordinates","offset","end","stride","extendFlatCoordinates","equals","extend","extendXY","forEachCorner","callback","val","getBottomLeft","getBottomRight","getTopRight","getTopLeft","getArea","area","isEmpty","getWidth","getHeight","getCenter","getCorner","corner","BOTTOM_LEFT","BOTTOM_RIGHT","TOP_LEFT","TOP_RIGHT","getForViewAndSize","center","resolution","rotation","size","cosRotation","cos","sinRotation","sin","xCos","xSin","yCos","ySin","x0","x1","x2","x3","y0","y1","y2","y3","getIntersection","intersection","intersects","returnOrUpdate","intersectsSegment","start","startRel","endRel","startX","startY","endX","endY","slope","applyTransform","transformFn","opt_stops","width","height","push","l","wrapX","projection","projectionExtent","getExtent","canWrapX","worldWidth","worldsAway","floor","abstract","Error","uidCounter_","getUid","obj","ol_uid","String","VERSION","showCoordinateWarning","disableCoordinateWarning","opt_disable","hide","undefined","cloneTransform","input","opt_output","opt_dimension","output","identityTransform","addProjection","getCode","addProjections","projections","forEach","get","projectionLike","getPointResolution","point","opt_units","pointResolution","getter","getPointResolutionFunc","getUnits","metersPerUnit","getMetersPerUnit","units","DEGREES","toEPSG4326_1","getTransformFromProjections","vertices","addEquivalentProjections","source","destination","addEquivalentTransforms","projections1","projections2","forwardTransform","inverseTransform","projection1","projection2","createProjection","defaultCode","createTransformFromCoordinateTransform","coordTransform","dimension","Array","j","addCoordinateTransforms","forward","inverse","sourceProj","destProj","fromLonLat","opt_projection","transform","equivalent","equalUnits","transformFunc","sourceProjection","destinationProjection","sourceCode","destinationCode","getTransform","transformExtent","userProjection","getUserProjection","toUserCoordinate","fromUserCoordinate","destProjection","console","warn","toUserExtent","fromUserExtent","toUserResolution","sourceUnits","userUnits","fromUserResolution","createSafeCoordinateTransform","coord","transformed","sourceX","sourceY","sourceExtent","sourceExtentWidth","addCommon","assign","Object","target","var_sources","TypeError","arguments","key","hasOwnProperty","clear","object","property","getValues","values","DEFAULT_RADIUS","getDistance","c1","c2","opt_radius","radius","lat1","lat2","deltaLatBy2","deltaLonBy2","a","atan2","sqrt","distance","bearing","lon1","dByR","lat","asin","lon","clamp","cosh","exp","log2","log","LOG2E","squaredSegmentDistance","t","squaredDistance","solveLinearSystem","mat","n","maxRow","maxEl","abs","r","absValue","tmp","coef","k","m","toDegrees","angleInRadians","PI","toRadians","angleInDegrees","modulo","b","lerp","toFixed","decimals","factor","pow","round","ceil","__extends","extendStatics","d","setPrototypeOf","__proto__","p","prototype","call","__","this","constructor","create","AssertionError","_super","code","_this","path","split","message","name","RADIUS","EXTENT","METERS_PER_UNIT","EPSG4326Projection","opt_axisOrientation","axisOrientation","global","worldExtent","PROJECTIONS","assert","assertion","errorCode","HALF_SIZE","WORLD_EXTENT","MAX_SAFE_Y","tan","EPSG3857Projection","METERS","fromEPSG4326","toEPSG4326","atan","add","delta","closestOnCircle","circle","getRadius","closestOnSegment","segment","along","coordinate1","coordinate2","rotate","angle","cosAngle","sinAngle","scale","coord1","coord2","squaredDistanceToSegment","getWorldsAway","opt_sourceExtentWidth","padNumber","number","opt_precision","numberString","decimal","indexOf","join","register","proj4","projCodes","keys","defs","len","def","projName","axis","to_meter","code1","proj1","code2","proj2","cache","replace","transforms","Projection","options","code_","units_","extent_","worldExtent_","axisOrientation_","global_","canWrapX_","getPointResolutionFunc_","defaultTileGrid_","metersPerUnit_","getWorldExtent","getAxisOrientation","isGlobal","setGlobal","getDefaultTileGrid","setDefaultTileGrid","tileGrid","setExtent","setWorldExtent","setGetPointResolution","func","POINT","LINE_STRING","LINEAR_RING","POLYGON","MULTI_POINT","MULTI_LINE_STRING","MULTI_POLYGON","GEOMETRY_COLLECTION","CIRCLE","Units","RADIANS","FEET","PIXELS","TILE_PIXELS","USFEET","unitByCode","fromCode"],"mappings":"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","file":"js/chunk-54190ed0.f495f07f.js","sourcesContent":["/**\n * @module ol/extent/Relationship\n */\n/**\n * Relationship to an extent.\n * @enum {number}\n */\nexport default {\n    UNKNOWN: 0,\n    INTERSECTING: 1,\n    ABOVE: 2,\n    RIGHT: 4,\n    BELOW: 8,\n    LEFT: 16,\n};\n//# sourceMappingURL=Relationship.js.map","/**\n * @module ol/extent\n */\nimport Corner from './extent/Corner.js';\nimport Relationship from './extent/Relationship.js';\nimport { assert } from './asserts.js';\n/**\n * An array of numbers representing an extent: `[minx, miny, maxx, maxy]`.\n * @typedef {Array<number>} Extent\n * @api\n */\n/**\n * Build an extent that includes all given coordinates.\n *\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates Coordinates.\n * @return {Extent} Bounding extent.\n * @api\n */\nexport function boundingExtent(coordinates) {\n    var extent = createEmpty();\n    for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n        extendCoordinate(extent, coordinates[i]);\n    }\n    return extent;\n}\n/**\n * @param {Array<number>} xs Xs.\n * @param {Array<number>} ys Ys.\n * @param {Extent} [opt_extent] Destination extent.\n * @private\n * @return {Extent} Extent.\n */\nfunction _boundingExtentXYs(xs, ys, opt_extent) {\n    var minX = Math.min.apply(null, xs);\n    var minY = Math.min.apply(null, ys);\n    var maxX = Math.max.apply(null, xs);\n    var maxY = Math.max.apply(null, ys);\n    return createOrUpdate(minX, minY, maxX, maxY, opt_extent);\n}\n/**\n * Return extent increased by the provided value.\n * @param {Extent} extent Extent.\n * @param {number} value The amount by which the extent should be buffered.\n * @param {Extent} [opt_extent] Extent.\n * @return {Extent} Extent.\n * @api\n */\nexport function buffer(extent, value, opt_extent) {\n    if (opt_extent) {\n        opt_extent[0] = extent[0] - value;\n        opt_extent[1] = extent[1] - value;\n        opt_extent[2] = extent[2] + value;\n        opt_extent[3] = extent[3] + value;\n        return opt_extent;\n    }\n    else {\n        return [\n            extent[0] - value,\n            extent[1] - value,\n            extent[2] + value,\n            extent[3] + value,\n        ];\n    }\n}\n/**\n * Creates a clone of an extent.\n *\n * @param {Extent} extent Extent to clone.\n * @param {Extent} [opt_extent] Extent.\n * @return {Extent} The clone.\n */\nexport function clone(extent, opt_extent) {\n    if (opt_extent) {\n        opt_extent[0] = extent[0];\n        opt_extent[1] = extent[1];\n        opt_extent[2] = extent[2];\n        opt_extent[3] = extent[3];\n        return opt_extent;\n    }\n    else {\n        return extent.slice();\n    }\n}\n/**\n * @param {Extent} extent Extent.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {number} Closest squared distance.\n */\nexport function closestSquaredDistanceXY(extent, x, y) {\n    var dx, dy;\n    if (x < extent[0]) {\n        dx = extent[0] - x;\n    }\n    else if (extent[2] < x) {\n        dx = x - extent[2];\n    }\n    else {\n        dx = 0;\n    }\n    if (y < extent[1]) {\n        dy = extent[1] - y;\n    }\n    else if (extent[3] < y) {\n        dy = y - extent[3];\n    }\n    else {\n        dy = 0;\n    }\n    return dx * dx + dy * dy;\n}\n/**\n * Check if the passed coordinate is contained or on the edge of the extent.\n *\n * @param {Extent} extent Extent.\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n * @return {boolean} The coordinate is contained in the extent.\n * @api\n */\nexport function containsCoordinate(extent, coordinate) {\n    return containsXY(extent, coordinate[0], coordinate[1]);\n}\n/**\n * Check if one extent contains another.\n *\n * An extent is deemed contained if it lies completely within the other extent,\n * including if they share one or more edges.\n *\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @return {boolean} The second extent is contained by or on the edge of the\n *     first.\n * @api\n */\nexport function containsExtent(extent1, extent2) {\n    return (extent1[0] <= extent2[0] &&\n        extent2[2] <= extent1[2] &&\n        extent1[1] <= extent2[1] &&\n        extent2[3] <= extent1[3]);\n}\n/**\n * Check if the passed coordinate is contained or on the edge of the extent.\n *\n * @param {Extent} extent Extent.\n * @param {number} x X coordinate.\n * @param {number} y Y coordinate.\n * @return {boolean} The x, y values are contained in the extent.\n * @api\n */\nexport function containsXY(extent, x, y) {\n    return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];\n}\n/**\n * Get the relationship between a coordinate and extent.\n * @param {Extent} extent The extent.\n * @param {import(\"./coordinate.js\").Coordinate} coordinate The coordinate.\n * @return {import(\"./extent/Relationship.js\").default} The relationship (bitwise compare with\n *     import(\"./extent/Relationship.js\").Relationship).\n */\nexport function coordinateRelationship(extent, coordinate) {\n    var minX = extent[0];\n    var minY = extent[1];\n    var maxX = extent[2];\n    var maxY = extent[3];\n    var x = coordinate[0];\n    var y = coordinate[1];\n    var relationship = Relationship.UNKNOWN;\n    if (x < minX) {\n        relationship = relationship | Relationship.LEFT;\n    }\n    else if (x > maxX) {\n        relationship = relationship | Relationship.RIGHT;\n    }\n    if (y < minY) {\n        relationship = relationship | Relationship.BELOW;\n    }\n    else if (y > maxY) {\n        relationship = relationship | Relationship.ABOVE;\n    }\n    if (relationship === Relationship.UNKNOWN) {\n        relationship = Relationship.INTERSECTING;\n    }\n    return relationship;\n}\n/**\n * Create an empty extent.\n * @return {Extent} Empty extent.\n * @api\n */\nexport function createEmpty() {\n    return [Infinity, Infinity, -Infinity, -Infinity];\n}\n/**\n * Create a new extent or update the provided extent.\n * @param {number} minX Minimum X.\n * @param {number} minY Minimum Y.\n * @param {number} maxX Maximum X.\n * @param {number} maxY Maximum Y.\n * @param {Extent} [opt_extent] Destination extent.\n * @return {Extent} Extent.\n */\nexport function createOrUpdate(minX, minY, maxX, maxY, opt_extent) {\n    if (opt_extent) {\n        opt_extent[0] = minX;\n        opt_extent[1] = minY;\n        opt_extent[2] = maxX;\n        opt_extent[3] = maxY;\n        return opt_extent;\n    }\n    else {\n        return [minX, minY, maxX, maxY];\n    }\n}\n/**\n * Create a new empty extent or make the provided one empty.\n * @param {Extent} [opt_extent] Extent.\n * @return {Extent} Extent.\n */\nexport function createOrUpdateEmpty(opt_extent) {\n    return createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, opt_extent);\n}\n/**\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n * @param {Extent} [opt_extent] Extent.\n * @return {Extent} Extent.\n */\nexport function createOrUpdateFromCoordinate(coordinate, opt_extent) {\n    var x = coordinate[0];\n    var y = coordinate[1];\n    return createOrUpdate(x, y, x, y, opt_extent);\n}\n/**\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates Coordinates.\n * @param {Extent} [opt_extent] Extent.\n * @return {Extent} Extent.\n */\nexport function createOrUpdateFromCoordinates(coordinates, opt_extent) {\n    var extent = createOrUpdateEmpty(opt_extent);\n    return extendCoordinates(extent, coordinates);\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {Extent} [opt_extent] Extent.\n * @return {Extent} Extent.\n */\nexport function createOrUpdateFromFlatCoordinates(flatCoordinates, offset, end, stride, opt_extent) {\n    var extent = createOrUpdateEmpty(opt_extent);\n    return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);\n}\n/**\n * @param {Array<Array<import(\"./coordinate.js\").Coordinate>>} rings Rings.\n * @param {Extent} [opt_extent] Extent.\n * @return {Extent} Extent.\n */\nexport function createOrUpdateFromRings(rings, opt_extent) {\n    var extent = createOrUpdateEmpty(opt_extent);\n    return extendRings(extent, rings);\n}\n/**\n * Determine if two extents are equivalent.\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @return {boolean} The two extents are equivalent.\n * @api\n */\nexport function equals(extent1, extent2) {\n    return (extent1[0] == extent2[0] &&\n        extent1[2] == extent2[2] &&\n        extent1[1] == extent2[1] &&\n        extent1[3] == extent2[3]);\n}\n/**\n * Determine if two extents are approximately equivalent.\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @param {number} tolerance Tolerance in extent coordinate units.\n * @return {boolean} The two extents differ by less than the tolerance.\n */\nexport function approximatelyEquals(extent1, extent2, tolerance) {\n    return (Math.abs(extent1[0] - extent2[0]) < tolerance &&\n        Math.abs(extent1[2] - extent2[2]) < tolerance &&\n        Math.abs(extent1[1] - extent2[1]) < tolerance &&\n        Math.abs(extent1[3] - extent2[3]) < tolerance);\n}\n/**\n * Modify an extent to include another extent.\n * @param {Extent} extent1 The extent to be modified.\n * @param {Extent} extent2 The extent that will be included in the first.\n * @return {Extent} A reference to the first (extended) extent.\n * @api\n */\nexport function extend(extent1, extent2) {\n    if (extent2[0] < extent1[0]) {\n        extent1[0] = extent2[0];\n    }\n    if (extent2[2] > extent1[2]) {\n        extent1[2] = extent2[2];\n    }\n    if (extent2[1] < extent1[1]) {\n        extent1[1] = extent2[1];\n    }\n    if (extent2[3] > extent1[3]) {\n        extent1[3] = extent2[3];\n    }\n    return extent1;\n}\n/**\n * @param {Extent} extent Extent.\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n */\nexport function extendCoordinate(extent, coordinate) {\n    if (coordinate[0] < extent[0]) {\n        extent[0] = coordinate[0];\n    }\n    if (coordinate[0] > extent[2]) {\n        extent[2] = coordinate[0];\n    }\n    if (coordinate[1] < extent[1]) {\n        extent[1] = coordinate[1];\n    }\n    if (coordinate[1] > extent[3]) {\n        extent[3] = coordinate[1];\n    }\n}\n/**\n * @param {Extent} extent Extent.\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates Coordinates.\n * @return {Extent} Extent.\n */\nexport function extendCoordinates(extent, coordinates) {\n    for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n        extendCoordinate(extent, coordinates[i]);\n    }\n    return extent;\n}\n/**\n * @param {Extent} extent Extent.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {Extent} Extent.\n */\nexport function extendFlatCoordinates(extent, flatCoordinates, offset, end, stride) {\n    for (; offset < end; offset += stride) {\n        extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);\n    }\n    return extent;\n}\n/**\n * @param {Extent} extent Extent.\n * @param {Array<Array<import(\"./coordinate.js\").Coordinate>>} rings Rings.\n * @return {Extent} Extent.\n */\nexport function extendRings(extent, rings) {\n    for (var i = 0, ii = rings.length; i < ii; ++i) {\n        extendCoordinates(extent, rings[i]);\n    }\n    return extent;\n}\n/**\n * @param {Extent} extent Extent.\n * @param {number} x X.\n * @param {number} y Y.\n */\nexport function extendXY(extent, x, y) {\n    extent[0] = Math.min(extent[0], x);\n    extent[1] = Math.min(extent[1], y);\n    extent[2] = Math.max(extent[2], x);\n    extent[3] = Math.max(extent[3], y);\n}\n/**\n * This function calls `callback` for each corner of the extent. If the\n * callback returns a truthy value the function returns that value\n * immediately. Otherwise the function returns `false`.\n * @param {Extent} extent Extent.\n * @param {function(import(\"./coordinate.js\").Coordinate): S} callback Callback.\n * @return {S|boolean} Value.\n * @template S\n */\nexport function forEachCorner(extent, callback) {\n    var val;\n    val = callback(getBottomLeft(extent));\n    if (val) {\n        return val;\n    }\n    val = callback(getBottomRight(extent));\n    if (val) {\n        return val;\n    }\n    val = callback(getTopRight(extent));\n    if (val) {\n        return val;\n    }\n    val = callback(getTopLeft(extent));\n    if (val) {\n        return val;\n    }\n    return false;\n}\n/**\n * Get the size of an extent.\n * @param {Extent} extent Extent.\n * @return {number} Area.\n * @api\n */\nexport function getArea(extent) {\n    var area = 0;\n    if (!isEmpty(extent)) {\n        area = getWidth(extent) * getHeight(extent);\n    }\n    return area;\n}\n/**\n * Get the bottom left coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import(\"./coordinate.js\").Coordinate} Bottom left coordinate.\n * @api\n */\nexport function getBottomLeft(extent) {\n    return [extent[0], extent[1]];\n}\n/**\n * Get the bottom right coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import(\"./coordinate.js\").Coordinate} Bottom right coordinate.\n * @api\n */\nexport function getBottomRight(extent) {\n    return [extent[2], extent[1]];\n}\n/**\n * Get the center coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import(\"./coordinate.js\").Coordinate} Center.\n * @api\n */\nexport function getCenter(extent) {\n    return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];\n}\n/**\n * Get a corner coordinate of an extent.\n * @param {Extent} extent Extent.\n * @param {import(\"./extent/Corner.js\").default} corner Corner.\n * @return {import(\"./coordinate.js\").Coordinate} Corner coordinate.\n */\nexport function getCorner(extent, corner) {\n    var coordinate;\n    if (corner === Corner.BOTTOM_LEFT) {\n        coordinate = getBottomLeft(extent);\n    }\n    else if (corner === Corner.BOTTOM_RIGHT) {\n        coordinate = getBottomRight(extent);\n    }\n    else if (corner === Corner.TOP_LEFT) {\n        coordinate = getTopLeft(extent);\n    }\n    else if (corner === Corner.TOP_RIGHT) {\n        coordinate = getTopRight(extent);\n    }\n    else {\n        assert(false, 13); // Invalid corner\n    }\n    return coordinate;\n}\n/**\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @return {number} Enlarged area.\n */\nexport function getEnlargedArea(extent1, extent2) {\n    var minX = Math.min(extent1[0], extent2[0]);\n    var minY = Math.min(extent1[1], extent2[1]);\n    var maxX = Math.max(extent1[2], extent2[2]);\n    var maxY = Math.max(extent1[3], extent2[3]);\n    return (maxX - minX) * (maxY - minY);\n}\n/**\n * @param {import(\"./coordinate.js\").Coordinate} center Center.\n * @param {number} resolution Resolution.\n * @param {number} rotation Rotation.\n * @param {import(\"./size.js\").Size} size Size.\n * @param {Extent} [opt_extent] Destination extent.\n * @return {Extent} Extent.\n */\nexport function getForViewAndSize(center, resolution, rotation, size, opt_extent) {\n    var dx = (resolution * size[0]) / 2;\n    var dy = (resolution * size[1]) / 2;\n    var cosRotation = Math.cos(rotation);\n    var sinRotation = Math.sin(rotation);\n    var xCos = dx * cosRotation;\n    var xSin = dx * sinRotation;\n    var yCos = dy * cosRotation;\n    var ySin = dy * sinRotation;\n    var x = center[0];\n    var y = center[1];\n    var x0 = x - xCos + ySin;\n    var x1 = x - xCos - ySin;\n    var x2 = x + xCos - ySin;\n    var x3 = x + xCos + ySin;\n    var y0 = y - xSin - yCos;\n    var y1 = y - xSin + yCos;\n    var y2 = y + xSin + yCos;\n    var y3 = y + xSin - yCos;\n    return createOrUpdate(Math.min(x0, x1, x2, x3), Math.min(y0, y1, y2, y3), Math.max(x0, x1, x2, x3), Math.max(y0, y1, y2, y3), opt_extent);\n}\n/**\n * Get the height of an extent.\n * @param {Extent} extent Extent.\n * @return {number} Height.\n * @api\n */\nexport function getHeight(extent) {\n    return extent[3] - extent[1];\n}\n/**\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @return {number} Intersection area.\n */\nexport function getIntersectionArea(extent1, extent2) {\n    var intersection = getIntersection(extent1, extent2);\n    return getArea(intersection);\n}\n/**\n * Get the intersection of two extents.\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @param {Extent} [opt_extent] Optional extent to populate with intersection.\n * @return {Extent} Intersecting extent.\n * @api\n */\nexport function getIntersection(extent1, extent2, opt_extent) {\n    var intersection = opt_extent ? opt_extent : createEmpty();\n    if (intersects(extent1, extent2)) {\n        if (extent1[0] > extent2[0]) {\n            intersection[0] = extent1[0];\n        }\n        else {\n            intersection[0] = extent2[0];\n        }\n        if (extent1[1] > extent2[1]) {\n            intersection[1] = extent1[1];\n        }\n        else {\n            intersection[1] = extent2[1];\n        }\n        if (extent1[2] < extent2[2]) {\n            intersection[2] = extent1[2];\n        }\n        else {\n            intersection[2] = extent2[2];\n        }\n        if (extent1[3] < extent2[3]) {\n            intersection[3] = extent1[3];\n        }\n        else {\n            intersection[3] = extent2[3];\n        }\n    }\n    else {\n        createOrUpdateEmpty(intersection);\n    }\n    return intersection;\n}\n/**\n * @param {Extent} extent Extent.\n * @return {number} Margin.\n */\nexport function getMargin(extent) {\n    return getWidth(extent) + getHeight(extent);\n}\n/**\n * Get the size (width, height) of an extent.\n * @param {Extent} extent The extent.\n * @return {import(\"./size.js\").Size} The extent size.\n * @api\n */\nexport function getSize(extent) {\n    return [extent[2] - extent[0], extent[3] - extent[1]];\n}\n/**\n * Get the top left coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import(\"./coordinate.js\").Coordinate} Top left coordinate.\n * @api\n */\nexport function getTopLeft(extent) {\n    return [extent[0], extent[3]];\n}\n/**\n * Get the top right coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import(\"./coordinate.js\").Coordinate} Top right coordinate.\n * @api\n */\nexport function getTopRight(extent) {\n    return [extent[2], extent[3]];\n}\n/**\n * Get the width of an extent.\n * @param {Extent} extent Extent.\n * @return {number} Width.\n * @api\n */\nexport function getWidth(extent) {\n    return extent[2] - extent[0];\n}\n/**\n * Determine if one extent intersects another.\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent.\n * @return {boolean} The two extents intersect.\n * @api\n */\nexport function intersects(extent1, extent2) {\n    return (extent1[0] <= extent2[2] &&\n        extent1[2] >= extent2[0] &&\n        extent1[1] <= extent2[3] &&\n        extent1[3] >= extent2[1]);\n}\n/**\n * Determine if an extent is empty.\n * @param {Extent} extent Extent.\n * @return {boolean} Is empty.\n * @api\n */\nexport function isEmpty(extent) {\n    return extent[2] < extent[0] || extent[3] < extent[1];\n}\n/**\n * @param {Extent} extent Extent.\n * @param {Extent} [opt_extent] Extent.\n * @return {Extent} Extent.\n */\nexport function returnOrUpdate(extent, opt_extent) {\n    if (opt_extent) {\n        opt_extent[0] = extent[0];\n        opt_extent[1] = extent[1];\n        opt_extent[2] = extent[2];\n        opt_extent[3] = extent[3];\n        return opt_extent;\n    }\n    else {\n        return extent;\n    }\n}\n/**\n * @param {Extent} extent Extent.\n * @param {number} value Value.\n */\nexport function scaleFromCenter(extent, value) {\n    var deltaX = ((extent[2] - extent[0]) / 2) * (value - 1);\n    var deltaY = ((extent[3] - extent[1]) / 2) * (value - 1);\n    extent[0] -= deltaX;\n    extent[2] += deltaX;\n    extent[1] -= deltaY;\n    extent[3] += deltaY;\n}\n/**\n * Determine if the segment between two coordinates intersects (crosses,\n * touches, or is contained by) the provided extent.\n * @param {Extent} extent The extent.\n * @param {import(\"./coordinate.js\").Coordinate} start Segment start coordinate.\n * @param {import(\"./coordinate.js\").Coordinate} end Segment end coordinate.\n * @return {boolean} The segment intersects the extent.\n */\nexport function intersectsSegment(extent, start, end) {\n    var intersects = false;\n    var startRel = coordinateRelationship(extent, start);\n    var endRel = coordinateRelationship(extent, end);\n    if (startRel === Relationship.INTERSECTING ||\n        endRel === Relationship.INTERSECTING) {\n        intersects = true;\n    }\n    else {\n        var minX = extent[0];\n        var minY = extent[1];\n        var maxX = extent[2];\n        var maxY = extent[3];\n        var startX = start[0];\n        var startY = start[1];\n        var endX = end[0];\n        var endY = end[1];\n        var slope = (endY - startY) / (endX - startX);\n        var x = void 0, y = void 0;\n        if (!!(endRel & Relationship.ABOVE) && !(startRel & Relationship.ABOVE)) {\n            // potentially intersects top\n            x = endX - (endY - maxY) / slope;\n            intersects = x >= minX && x <= maxX;\n        }\n        if (!intersects &&\n            !!(endRel & Relationship.RIGHT) &&\n            !(startRel & Relationship.RIGHT)) {\n            // potentially intersects right\n            y = endY - (endX - maxX) * slope;\n            intersects = y >= minY && y <= maxY;\n        }\n        if (!intersects &&\n            !!(endRel & Relationship.BELOW) &&\n            !(startRel & Relationship.BELOW)) {\n            // potentially intersects bottom\n            x = endX - (endY - minY) / slope;\n            intersects = x >= minX && x <= maxX;\n        }\n        if (!intersects &&\n            !!(endRel & Relationship.LEFT) &&\n            !(startRel & Relationship.LEFT)) {\n            // potentially intersects left\n            y = endY - (endX - minX) * slope;\n            intersects = y >= minY && y <= maxY;\n        }\n    }\n    return intersects;\n}\n/**\n * Apply a transform function to the extent.\n * @param {Extent} extent Extent.\n * @param {import(\"./proj.js\").TransformFunction} transformFn Transform function.\n * Called with `[minX, minY, maxX, maxY]` extent coordinates.\n * @param {Extent} [opt_extent] Destination extent.\n * @param {number} [opt_stops] Number of stops per side used for the transform.\n * By default only the corners are used.\n * @return {Extent} Extent.\n * @api\n */\nexport function applyTransform(extent, transformFn, opt_extent, opt_stops) {\n    var coordinates = [];\n    if (opt_stops > 1) {\n        var width = extent[2] - extent[0];\n        var height = extent[3] - extent[1];\n        for (var i = 0; i < opt_stops; ++i) {\n            coordinates.push(extent[0] + (width * i) / opt_stops, extent[1], extent[2], extent[1] + (height * i) / opt_stops, extent[2] - (width * i) / opt_stops, extent[3], extent[0], extent[3] - (height * i) / opt_stops);\n        }\n    }\n    else {\n        coordinates = [\n            extent[0],\n            extent[1],\n            extent[2],\n            extent[1],\n            extent[2],\n            extent[3],\n            extent[0],\n            extent[3],\n        ];\n    }\n    transformFn(coordinates, coordinates, 2);\n    var xs = [];\n    var ys = [];\n    for (var i = 0, l = coordinates.length; i < l; i += 2) {\n        xs.push(coordinates[i]);\n        ys.push(coordinates[i + 1]);\n    }\n    return _boundingExtentXYs(xs, ys, opt_extent);\n}\n/**\n * Modifies the provided extent in-place to be within the real world\n * extent.\n *\n * @param {Extent} extent Extent.\n * @param {import(\"./proj/Projection.js\").default} projection Projection\n * @return {Extent} The extent within the real world extent.\n */\nexport function wrapX(extent, projection) {\n    var projectionExtent = projection.getExtent();\n    var center = getCenter(extent);\n    if (projection.canWrapX() &&\n        (center[0] < projectionExtent[0] || center[0] >= projectionExtent[2])) {\n        var worldWidth = getWidth(projectionExtent);\n        var worldsAway = Math.floor((center[0] - projectionExtent[0]) / worldWidth);\n        var offset = worldsAway * worldWidth;\n        extent[0] -= offset;\n        extent[2] -= offset;\n    }\n    return extent;\n}\n//# sourceMappingURL=extent.js.map","/**\n * @module ol/util\n */\n/**\n * @return {?} Any return.\n */\nexport function abstract() {\n    return /** @type {?} */ ((function () {\n        throw new Error('Unimplemented abstract method.');\n    })());\n}\n/**\n * Counter for getUid.\n * @type {number}\n * @private\n */\nvar uidCounter_ = 0;\n/**\n * Gets a unique ID for an object. This mutates the object so that further calls\n * with the same object as a parameter returns the same value. Unique IDs are generated\n * as a strictly increasing sequence. Adapted from goog.getUid.\n *\n * @param {Object} obj The object to get the unique ID for.\n * @return {string} The unique ID for the object.\n * @api\n */\nexport function getUid(obj) {\n    return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));\n}\n/**\n * OpenLayers version.\n * @type {string}\n */\nexport var VERSION = '6.14.1';\n//# sourceMappingURL=util.js.map","/**\n * @module ol/proj\n */\n/**\n * The ol/proj module stores:\n * * a list of {@link module:ol/proj/Projection~Projection}\n * objects, one for each projection supported by the application\n * * a list of transform functions needed to convert coordinates in one projection\n * into another.\n *\n * The static functions are the methods used to maintain these.\n * Each transform function can handle not only simple coordinate pairs, but also\n * large arrays of coordinates such as vector geometries.\n *\n * When loaded, the library adds projection objects for EPSG:4326 (WGS84\n * geographic coordinates) and EPSG:3857 (Web or Spherical Mercator, as used\n * for example by Bing Maps or OpenStreetMap), together with the relevant\n * transform functions.\n *\n * Additional transforms may be added by using the http://proj4js.org/\n * library (version 2.2 or later). You can use the full build supplied by\n * Proj4js, or create a custom build to support those projections you need; see\n * the Proj4js website for how to do this. You also need the Proj4js definitions\n * for the required projections. These definitions can be obtained from\n * https://epsg.io/, and are a JS function, so can be loaded in a script\n * tag (as in the examples) or pasted into your application.\n *\n * After all required projection definitions are added to proj4's registry (by\n * using `proj4.defs()`), simply call `register(proj4)` from the `ol/proj/proj4`\n * package. Existing transforms are not changed by this function. See\n * examples/wms-image-custom-proj for an example of this.\n *\n * Additional projection definitions can be registered with `proj4.defs()` any\n * time. Just make sure to call `register(proj4)` again; for example, with user-supplied data where you don't\n * know in advance what projections are needed, you can initially load minimal\n * support and then load whichever are requested.\n *\n * Note that Proj4js does not support projection extents. If you want to add\n * one for creating default tile grids, you can add it after the Projection\n * object has been created with `setExtent`, for example,\n * `get('EPSG:1234').setExtent(extent)`.\n *\n * In addition to Proj4js support, any transform functions can be added with\n * {@link module:ol/proj.addCoordinateTransforms}. To use this, you must first create\n * a {@link module:ol/proj/Projection~Projection} object for the new projection and add it with\n * {@link module:ol/proj.addProjection}. You can then add the forward and inverse\n * functions with {@link module:ol/proj.addCoordinateTransforms}. See\n * examples/wms-custom-proj for an example of this.\n *\n * Note that if no transforms are needed and you only need to define the\n * projection, just add a {@link module:ol/proj/Projection~Projection} with\n * {@link module:ol/proj.addProjection}. See examples/wms-no-proj for an example of\n * this.\n */\nimport Projection from './proj/Projection.js';\nimport Units, { METERS_PER_UNIT } from './proj/Units.js';\nimport { PROJECTIONS as EPSG3857_PROJECTIONS, fromEPSG4326, toEPSG4326, } from './proj/epsg3857.js';\nimport { PROJECTIONS as EPSG4326_PROJECTIONS } from './proj/epsg4326.js';\nimport { add as addProj, clear as clearProj, get as getProj, } from './proj/projections.js';\nimport { add as addTransformFunc, clear as clearTransformFuncs, get as getTransformFunc, } from './proj/transforms.js';\nimport { applyTransform, getWidth } from './extent.js';\nimport { clamp, modulo } from './math.js';\nimport { equals, getWorldsAway } from './coordinate.js';\nimport { getDistance } from './sphere.js';\n/**\n * A projection as {@link module:ol/proj/Projection~Projection}, SRS identifier\n * string or undefined.\n * @typedef {Projection|string|undefined} ProjectionLike\n * @api\n */\n/**\n * A transform function accepts an array of input coordinate values, an optional\n * output array, and an optional dimension (default should be 2).  The function\n * transforms the input coordinate values, populates the output array, and\n * returns the output array.\n *\n * @typedef {function(Array<number>, Array<number>=, number=): Array<number>} TransformFunction\n * @api\n */\nexport { METERS_PER_UNIT };\nexport { Projection };\nvar showCoordinateWarning = true;\n/**\n * @param {boolean} [opt_disable = true] Disable console info about `useGeographic()`\n */\nexport function disableCoordinateWarning(opt_disable) {\n    var hide = opt_disable === undefined ? true : opt_disable;\n    showCoordinateWarning = !hide;\n}\n/**\n * @param {Array<number>} input Input coordinate array.\n * @param {Array<number>} [opt_output] Output array of coordinate values.\n * @param {number} [opt_dimension] Dimension.\n * @return {Array<number>} Output coordinate array (new array, same coordinate\n *     values).\n */\nexport function cloneTransform(input, opt_output, opt_dimension) {\n    var output;\n    if (opt_output !== undefined) {\n        for (var i = 0, ii = input.length; i < ii; ++i) {\n            opt_output[i] = input[i];\n        }\n        output = opt_output;\n    }\n    else {\n        output = input.slice();\n    }\n    return output;\n}\n/**\n * @param {Array<number>} input Input coordinate array.\n * @param {Array<number>} [opt_output] Output array of coordinate values.\n * @param {number} [opt_dimension] Dimension.\n * @return {Array<number>} Input coordinate array (same array as input).\n */\nexport function identityTransform(input, opt_output, opt_dimension) {\n    if (opt_output !== undefined && input !== opt_output) {\n        for (var i = 0, ii = input.length; i < ii; ++i) {\n            opt_output[i] = input[i];\n        }\n        input = opt_output;\n    }\n    return input;\n}\n/**\n * Add a Projection object to the list of supported projections that can be\n * looked up by their code.\n *\n * @param {Projection} projection Projection instance.\n * @api\n */\nexport function addProjection(projection) {\n    addProj(projection.getCode(), projection);\n    addTransformFunc(projection, projection, cloneTransform);\n}\n/**\n * @param {Array<Projection>} projections Projections.\n */\nexport function addProjections(projections) {\n    projections.forEach(addProjection);\n}\n/**\n * Fetches a Projection object for the code specified.\n *\n * @param {ProjectionLike} projectionLike Either a code string which is\n *     a combination of authority and identifier such as \"EPSG:4326\", or an\n *     existing projection object, or undefined.\n * @return {Projection|null} Projection object, or null if not in list.\n * @api\n */\nexport function get(projectionLike) {\n    return typeof projectionLike === 'string'\n        ? getProj(/** @type {string} */ (projectionLike))\n        : /** @type {Projection} */ (projectionLike) || null;\n}\n/**\n * Get the resolution of the point in degrees or distance units.\n * For projections with degrees as the unit this will simply return the\n * provided resolution. For other projections the point resolution is\n * by default estimated by transforming the `point` pixel to EPSG:4326,\n * measuring its width and height on the normal sphere,\n * and taking the average of the width and height.\n * A custom function can be provided for a specific projection, either\n * by setting the `getPointResolution` option in the\n * {@link module:ol/proj/Projection~Projection} constructor or by using\n * {@link module:ol/proj/Projection~Projection#setGetPointResolution} to change an existing\n * projection object.\n * @param {ProjectionLike} projection The projection.\n * @param {number} resolution Nominal resolution in projection units.\n * @param {import(\"./coordinate.js\").Coordinate} point Point to find adjusted resolution at.\n * @param {import(\"./proj/Units.js\").default} [opt_units] Units to get the point resolution in.\n * Default is the projection's units.\n * @return {number} Point resolution.\n * @api\n */\nexport function getPointResolution(projection, resolution, point, opt_units) {\n    projection = get(projection);\n    var pointResolution;\n    var getter = projection.getPointResolutionFunc();\n    if (getter) {\n        pointResolution = getter(resolution, point);\n        if (opt_units && opt_units !== projection.getUnits()) {\n            var metersPerUnit = projection.getMetersPerUnit();\n            if (metersPerUnit) {\n                pointResolution =\n                    (pointResolution * metersPerUnit) / METERS_PER_UNIT[opt_units];\n            }\n        }\n    }\n    else {\n        var units = projection.getUnits();\n        if ((units == Units.DEGREES && !opt_units) || opt_units == Units.DEGREES) {\n            pointResolution = resolution;\n        }\n        else {\n            // Estimate point resolution by transforming the center pixel to EPSG:4326,\n            // measuring its width and height on the normal sphere, and taking the\n            // average of the width and height.\n            var toEPSG4326_1 = getTransformFromProjections(projection, get('EPSG:4326'));\n            if (toEPSG4326_1 === identityTransform && units !== Units.DEGREES) {\n                // no transform is available\n                pointResolution = resolution * projection.getMetersPerUnit();\n            }\n            else {\n                var vertices = [\n                    point[0] - resolution / 2,\n                    point[1],\n                    point[0] + resolution / 2,\n                    point[1],\n                    point[0],\n                    point[1] - resolution / 2,\n                    point[0],\n                    point[1] + resolution / 2,\n                ];\n                vertices = toEPSG4326_1(vertices, vertices, 2);\n                var width = getDistance(vertices.slice(0, 2), vertices.slice(2, 4));\n                var height = getDistance(vertices.slice(4, 6), vertices.slice(6, 8));\n                pointResolution = (width + height) / 2;\n            }\n            var metersPerUnit = opt_units\n                ? METERS_PER_UNIT[opt_units]\n                : projection.getMetersPerUnit();\n            if (metersPerUnit !== undefined) {\n                pointResolution /= metersPerUnit;\n            }\n        }\n    }\n    return pointResolution;\n}\n/**\n * Registers transformation functions that don't alter coordinates. Those allow\n * to transform between projections with equal meaning.\n *\n * @param {Array<Projection>} projections Projections.\n * @api\n */\nexport function addEquivalentProjections(projections) {\n    addProjections(projections);\n    projections.forEach(function (source) {\n        projections.forEach(function (destination) {\n            if (source !== destination) {\n                addTransformFunc(source, destination, cloneTransform);\n            }\n        });\n    });\n}\n/**\n * Registers transformation functions to convert coordinates in any projection\n * in projection1 to any projection in projection2.\n *\n * @param {Array<Projection>} projections1 Projections with equal\n *     meaning.\n * @param {Array<Projection>} projections2 Projections with equal\n *     meaning.\n * @param {TransformFunction} forwardTransform Transformation from any\n *   projection in projection1 to any projection in projection2.\n * @param {TransformFunction} inverseTransform Transform from any projection\n *   in projection2 to any projection in projection1..\n */\nexport function addEquivalentTransforms(projections1, projections2, forwardTransform, inverseTransform) {\n    projections1.forEach(function (projection1) {\n        projections2.forEach(function (projection2) {\n            addTransformFunc(projection1, projection2, forwardTransform);\n            addTransformFunc(projection2, projection1, inverseTransform);\n        });\n    });\n}\n/**\n * Clear all cached projections and transforms.\n */\nexport function clearAllProjections() {\n    clearProj();\n    clearTransformFuncs();\n}\n/**\n * @param {Projection|string|undefined} projection Projection.\n * @param {string} defaultCode Default code.\n * @return {Projection} Projection.\n */\nexport function createProjection(projection, defaultCode) {\n    if (!projection) {\n        return get(defaultCode);\n    }\n    else if (typeof projection === 'string') {\n        return get(projection);\n    }\n    else {\n        return /** @type {Projection} */ (projection);\n    }\n}\n/**\n * Creates a {@link module:ol/proj~TransformFunction} from a simple 2D coordinate transform\n * function.\n * @param {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} coordTransform Coordinate\n *     transform.\n * @return {TransformFunction} Transform function.\n */\nexport function createTransformFromCoordinateTransform(coordTransform) {\n    return (\n    /**\n     * @param {Array<number>} input Input.\n     * @param {Array<number>} [opt_output] Output.\n     * @param {number} [opt_dimension] Dimension.\n     * @return {Array<number>} Output.\n     */\n    function (input, opt_output, opt_dimension) {\n        var length = input.length;\n        var dimension = opt_dimension !== undefined ? opt_dimension : 2;\n        var output = opt_output !== undefined ? opt_output : new Array(length);\n        for (var i = 0; i < length; i += dimension) {\n            var point = coordTransform([input[i], input[i + 1]]);\n            output[i] = point[0];\n            output[i + 1] = point[1];\n            for (var j = dimension - 1; j >= 2; --j) {\n                output[i + j] = input[i + j];\n            }\n        }\n        return output;\n    });\n}\n/**\n * Registers coordinate transform functions to convert coordinates between the\n * source projection and the destination projection.\n * The forward and inverse functions convert coordinate pairs; this function\n * converts these into the functions used internally which also handle\n * extents and coordinate arrays.\n *\n * @param {ProjectionLike} source Source projection.\n * @param {ProjectionLike} destination Destination projection.\n * @param {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} forward The forward transform\n *     function (that is, from the source projection to the destination\n *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns\n *     the transformed {@link module:ol/coordinate~Coordinate}.\n * @param {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} inverse The inverse transform\n *     function (that is, from the destination projection to the source\n *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns\n *     the transformed {@link module:ol/coordinate~Coordinate}.\n * @api\n */\nexport function addCoordinateTransforms(source, destination, forward, inverse) {\n    var sourceProj = get(source);\n    var destProj = get(destination);\n    addTransformFunc(sourceProj, destProj, createTransformFromCoordinateTransform(forward));\n    addTransformFunc(destProj, sourceProj, createTransformFromCoordinateTransform(inverse));\n}\n/**\n * Transforms a coordinate from longitude/latitude to a different projection.\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate as longitude and latitude, i.e.\n *     an array with longitude as 1st and latitude as 2nd element.\n * @param {ProjectionLike} [opt_projection] Target projection. The\n *     default is Web Mercator, i.e. 'EPSG:3857'.\n * @return {import(\"./coordinate.js\").Coordinate} Coordinate projected to the target projection.\n * @api\n */\nexport function fromLonLat(coordinate, opt_projection) {\n    disableCoordinateWarning();\n    return transform(coordinate, 'EPSG:4326', opt_projection !== undefined ? opt_projection : 'EPSG:3857');\n}\n/**\n * Transforms a coordinate to longitude/latitude.\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Projected coordinate.\n * @param {ProjectionLike} [opt_projection] Projection of the coordinate.\n *     The default is Web Mercator, i.e. 'EPSG:3857'.\n * @return {import(\"./coordinate.js\").Coordinate} Coordinate as longitude and latitude, i.e. an array\n *     with longitude as 1st and latitude as 2nd element.\n * @api\n */\nexport function toLonLat(coordinate, opt_projection) {\n    var lonLat = transform(coordinate, opt_projection !== undefined ? opt_projection : 'EPSG:3857', 'EPSG:4326');\n    var lon = lonLat[0];\n    if (lon < -180 || lon > 180) {\n        lonLat[0] = modulo(lon + 180, 360) - 180;\n    }\n    return lonLat;\n}\n/**\n * Checks if two projections are the same, that is every coordinate in one\n * projection does represent the same geographic point as the same coordinate in\n * the other projection.\n *\n * @param {Projection} projection1 Projection 1.\n * @param {Projection} projection2 Projection 2.\n * @return {boolean} Equivalent.\n * @api\n */\nexport function equivalent(projection1, projection2) {\n    if (projection1 === projection2) {\n        return true;\n    }\n    var equalUnits = projection1.getUnits() === projection2.getUnits();\n    if (projection1.getCode() === projection2.getCode()) {\n        return equalUnits;\n    }\n    else {\n        var transformFunc = getTransformFromProjections(projection1, projection2);\n        return transformFunc === cloneTransform && equalUnits;\n    }\n}\n/**\n * Searches in the list of transform functions for the function for converting\n * coordinates from the source projection to the destination projection.\n *\n * @param {Projection} sourceProjection Source Projection object.\n * @param {Projection} destinationProjection Destination Projection\n *     object.\n * @return {TransformFunction} Transform function.\n */\nexport function getTransformFromProjections(sourceProjection, destinationProjection) {\n    var sourceCode = sourceProjection.getCode();\n    var destinationCode = destinationProjection.getCode();\n    var transformFunc = getTransformFunc(sourceCode, destinationCode);\n    if (!transformFunc) {\n        transformFunc = identityTransform;\n    }\n    return transformFunc;\n}\n/**\n * Given the projection-like objects, searches for a transformation\n * function to convert a coordinates array from the source projection to the\n * destination projection.\n *\n * @param {ProjectionLike} source Source.\n * @param {ProjectionLike} destination Destination.\n * @return {TransformFunction} Transform function.\n * @api\n */\nexport function getTransform(source, destination) {\n    var sourceProjection = get(source);\n    var destinationProjection = get(destination);\n    return getTransformFromProjections(sourceProjection, destinationProjection);\n}\n/**\n * Transforms a coordinate from source projection to destination projection.\n * This returns a new coordinate (and does not modify the original).\n *\n * See {@link module:ol/proj.transformExtent} for extent transformation.\n * See the transform method of {@link module:ol/geom/Geometry~Geometry} and its\n * subclasses for geometry transforms.\n *\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n * @param {ProjectionLike} source Source projection-like.\n * @param {ProjectionLike} destination Destination projection-like.\n * @return {import(\"./coordinate.js\").Coordinate} Coordinate.\n * @api\n */\nexport function transform(coordinate, source, destination) {\n    var transformFunc = getTransform(source, destination);\n    return transformFunc(coordinate, undefined, coordinate.length);\n}\n/**\n * Transforms an extent from source projection to destination projection.  This\n * returns a new extent (and does not modify the original).\n *\n * @param {import(\"./extent.js\").Extent} extent The extent to transform.\n * @param {ProjectionLike} source Source projection-like.\n * @param {ProjectionLike} destination Destination projection-like.\n * @param {number} [opt_stops] Number of stops per side used for the transform.\n * By default only the corners are used.\n * @return {import(\"./extent.js\").Extent} The transformed extent.\n * @api\n */\nexport function transformExtent(extent, source, destination, opt_stops) {\n    var transformFunc = getTransform(source, destination);\n    return applyTransform(extent, transformFunc, undefined, opt_stops);\n}\n/**\n * Transforms the given point to the destination projection.\n *\n * @param {import(\"./coordinate.js\").Coordinate} point Point.\n * @param {Projection} sourceProjection Source projection.\n * @param {Projection} destinationProjection Destination projection.\n * @return {import(\"./coordinate.js\").Coordinate} Point.\n */\nexport function transformWithProjections(point, sourceProjection, destinationProjection) {\n    var transformFunc = getTransformFromProjections(sourceProjection, destinationProjection);\n    return transformFunc(point);\n}\n/**\n * @type {Projection|null}\n */\nvar userProjection = null;\n/**\n * Set the projection for coordinates supplied from and returned by API methods.\n * This includes all API methods except for those interacting with tile grids.\n * @param {ProjectionLike} projection The user projection.\n * @api\n */\nexport function setUserProjection(projection) {\n    userProjection = get(projection);\n}\n/**\n * Clear the user projection if set.\n * @api\n */\nexport function clearUserProjection() {\n    userProjection = null;\n}\n/**\n * Get the projection for coordinates supplied from and returned by API methods.\n * Note that this method is not yet a part of the stable API.  Support for user\n * projections is not yet complete and should be considered experimental.\n * @return {Projection|null} The user projection (or null if not set).\n * @api\n */\nexport function getUserProjection() {\n    return userProjection;\n}\n/**\n * Use geographic coordinates (WGS-84 datum) in API methods.  This includes all API\n * methods except for those interacting with tile grids.\n * @api\n */\nexport function useGeographic() {\n    setUserProjection('EPSG:4326');\n}\n/**\n * Return a coordinate transformed into the user projection.  If no user projection\n * is set, the original coordinate is returned.\n * @param {Array<number>} coordinate Input coordinate.\n * @param {ProjectionLike} sourceProjection The input coordinate projection.\n * @return {Array<number>} The input coordinate in the user projection.\n */\nexport function toUserCoordinate(coordinate, sourceProjection) {\n    if (!userProjection) {\n        return coordinate;\n    }\n    return transform(coordinate, sourceProjection, userProjection);\n}\n/**\n * Return a coordinate transformed from the user projection.  If no user projection\n * is set, the original coordinate is returned.\n * @param {Array<number>} coordinate Input coordinate.\n * @param {ProjectionLike} destProjection The destination projection.\n * @return {Array<number>} The input coordinate transformed.\n */\nexport function fromUserCoordinate(coordinate, destProjection) {\n    if (!userProjection) {\n        if (showCoordinateWarning &&\n            !equals(coordinate, [0, 0]) &&\n            coordinate[0] >= -180 &&\n            coordinate[0] <= 180 &&\n            coordinate[1] >= -90 &&\n            coordinate[1] <= 90) {\n            showCoordinateWarning = false;\n            // eslint-disable-next-line no-console\n            console.warn('Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates.');\n        }\n        return coordinate;\n    }\n    return transform(coordinate, userProjection, destProjection);\n}\n/**\n * Return an extent transformed into the user projection.  If no user projection\n * is set, the original extent is returned.\n * @param {import(\"./extent.js\").Extent} extent Input extent.\n * @param {ProjectionLike} sourceProjection The input extent projection.\n * @return {import(\"./extent.js\").Extent} The input extent in the user projection.\n */\nexport function toUserExtent(extent, sourceProjection) {\n    if (!userProjection) {\n        return extent;\n    }\n    return transformExtent(extent, sourceProjection, userProjection);\n}\n/**\n * Return an extent transformed from the user projection.  If no user projection\n * is set, the original extent is returned.\n * @param {import(\"./extent.js\").Extent} extent Input extent.\n * @param {ProjectionLike} destProjection The destination projection.\n * @return {import(\"./extent.js\").Extent} The input extent transformed.\n */\nexport function fromUserExtent(extent, destProjection) {\n    if (!userProjection) {\n        return extent;\n    }\n    return transformExtent(extent, userProjection, destProjection);\n}\n/**\n * Return the resolution in user projection units per pixel. If no user projection\n * is set, or source or user projection are missing units, the original resolution\n * is returned.\n * @param {number} resolution Resolution in input projection units per pixel.\n * @param {ProjectionLike} sourceProjection The input projection.\n * @return {number} Resolution in user projection units per pixel.\n */\nexport function toUserResolution(resolution, sourceProjection) {\n    if (!userProjection) {\n        return resolution;\n    }\n    var sourceUnits = get(sourceProjection).getUnits();\n    var userUnits = userProjection.getUnits();\n    return sourceUnits && userUnits\n        ? (resolution * METERS_PER_UNIT[sourceUnits]) / METERS_PER_UNIT[userUnits]\n        : resolution;\n}\n/**\n * Return the resolution in user projection units per pixel. If no user projection\n * is set, or source or user projection are missing units, the original resolution\n * is returned.\n * @param {number} resolution Resolution in user projection units per pixel.\n * @param {ProjectionLike} destProjection The destination projection.\n * @return {number} Resolution in destination projection units per pixel.\n */\nexport function fromUserResolution(resolution, destProjection) {\n    if (!userProjection) {\n        return resolution;\n    }\n    var sourceUnits = get(destProjection).getUnits();\n    var userUnits = userProjection.getUnits();\n    return sourceUnits && userUnits\n        ? (resolution * METERS_PER_UNIT[userUnits]) / METERS_PER_UNIT[sourceUnits]\n        : resolution;\n}\n/**\n * Creates a safe coordinate transform function from a coordinate transform function.\n * \"Safe\" means that it can handle wrapping of x-coordinates for global projections,\n * and that coordinates exceeding the source projection validity extent's range will be\n * clamped to the validity range.\n * @param {Projection} sourceProj Source projection.\n * @param {Projection} destProj Destination projection.\n * @param {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} transform Transform function (source to destiation).\n * @return {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} Safe transform function (source to destiation).\n */\nexport function createSafeCoordinateTransform(sourceProj, destProj, transform) {\n    return function (coord) {\n        var sourceX = coord[0];\n        var sourceY = coord[1];\n        var transformed, worldsAway;\n        if (sourceProj.canWrapX()) {\n            var sourceExtent = sourceProj.getExtent();\n            var sourceExtentWidth = getWidth(sourceExtent);\n            worldsAway = getWorldsAway(coord, sourceProj, sourceExtentWidth);\n            if (worldsAway) {\n                // Move x to the real world\n                sourceX = sourceX - worldsAway * sourceExtentWidth;\n            }\n            sourceX = clamp(sourceX, sourceExtent[0], sourceExtent[2]);\n            sourceY = clamp(sourceY, sourceExtent[1], sourceExtent[3]);\n            transformed = transform([sourceX, sourceY]);\n        }\n        else {\n            transformed = transform(coord);\n        }\n        if (worldsAway && destProj.canWrapX()) {\n            // Move transformed coordinate back to the offset world\n            transformed[0] += worldsAway * getWidth(destProj.getExtent());\n        }\n        return transformed;\n    };\n}\n/**\n * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called\n * by when this module is executed and should only need to be called again after\n * `clearAllProjections()` is called (e.g. in tests).\n */\nexport function addCommon() {\n    // Add transformations that don't alter coordinates to convert within set of\n    // projections with equal meaning.\n    addEquivalentProjections(EPSG3857_PROJECTIONS);\n    addEquivalentProjections(EPSG4326_PROJECTIONS);\n    // Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like\n    // coordinates and back.\n    addEquivalentTransforms(EPSG4326_PROJECTIONS, EPSG3857_PROJECTIONS, fromEPSG4326, toEPSG4326);\n}\naddCommon();\n//# sourceMappingURL=proj.js.map","/**\n * @module ol/extent/Corner\n */\n/**\n * Extent corner.\n * @enum {string}\n */\nexport default {\n    BOTTOM_LEFT: 'bottom-left',\n    BOTTOM_RIGHT: 'bottom-right',\n    TOP_LEFT: 'top-left',\n    TOP_RIGHT: 'top-right',\n};\n//# sourceMappingURL=Corner.js.map","/**\n * @module ol/obj\n */\n/**\n * Polyfill for Object.assign().  Assigns enumerable and own properties from\n * one or more source objects to a target object.\n * See https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign.\n *\n * @param {!Object} target The target object.\n * @param {...Object} var_sources The source object(s).\n * @return {!Object} The modified target object.\n */\nexport var assign = typeof Object.assign === 'function'\n    ? Object.assign\n    : function (target, var_sources) {\n        if (target === undefined || target === null) {\n            throw new TypeError('Cannot convert undefined or null to object');\n        }\n        var output = Object(target);\n        for (var i = 1, ii = arguments.length; i < ii; ++i) {\n            var source = arguments[i];\n            if (source !== undefined && source !== null) {\n                for (var key in source) {\n                    if (source.hasOwnProperty(key)) {\n                        output[key] = source[key];\n                    }\n                }\n            }\n        }\n        return output;\n    };\n/**\n * Removes all properties from an object.\n * @param {Object} object The object to clear.\n */\nexport function clear(object) {\n    for (var property in object) {\n        delete object[property];\n    }\n}\n/**\n * Polyfill for Object.values().  Get an array of property values from an object.\n * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values\n *\n * @param {!Object<K,V>} object The object from which to get the values.\n * @return {!Array<V>} The property values.\n * @template K,V\n */\nexport var getValues = typeof Object.values === 'function'\n    ? Object.values\n    : function (object) {\n        var values = [];\n        for (var property in object) {\n            values.push(object[property]);\n        }\n        return values;\n    };\n/**\n * Determine if an object has any properties.\n * @param {Object} object The object to check.\n * @return {boolean} The object is empty.\n */\nexport function isEmpty(object) {\n    var property;\n    for (property in object) {\n        return false;\n    }\n    return !property;\n}\n//# sourceMappingURL=obj.js.map","/**\n * @module ol/sphere\n */\nimport GeometryType from './geom/GeometryType.js';\nimport { toDegrees, toRadians } from './math.js';\n/**\n * Object literal with options for the {@link getLength} or {@link getArea}\n * functions.\n * @typedef {Object} SphereMetricOptions\n * @property {import(\"./proj.js\").ProjectionLike} [projection='EPSG:3857']\n * Projection of the  geometry.  By default, the geometry is assumed to be in\n * Web Mercator.\n * @property {number} [radius=6371008.8] Sphere radius.  By default, the\n * [mean Earth radius](https://en.wikipedia.org/wiki/Earth_radius#Mean_radius)\n * for the WGS84 ellipsoid is used.\n */\n/**\n * The mean Earth radius (1/3 * (2a + b)) for the WGS84 ellipsoid.\n * https://en.wikipedia.org/wiki/Earth_radius#Mean_radius\n * @type {number}\n */\nexport var DEFAULT_RADIUS = 6371008.8;\n/**\n * Get the great circle distance (in meters) between two geographic coordinates.\n * @param {Array} c1 Starting coordinate.\n * @param {Array} c2 Ending coordinate.\n * @param {number} [opt_radius] The sphere radius to use.  Defaults to the Earth's\n *     mean radius using the WGS84 ellipsoid.\n * @return {number} The great circle distance between the points (in meters).\n * @api\n */\nexport function getDistance(c1, c2, opt_radius) {\n    var radius = opt_radius || DEFAULT_RADIUS;\n    var lat1 = toRadians(c1[1]);\n    var lat2 = toRadians(c2[1]);\n    var deltaLatBy2 = (lat2 - lat1) / 2;\n    var deltaLonBy2 = toRadians(c2[0] - c1[0]) / 2;\n    var a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) +\n        Math.sin(deltaLonBy2) *\n            Math.sin(deltaLonBy2) *\n            Math.cos(lat1) *\n            Math.cos(lat2);\n    return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n}\n/**\n * Get the cumulative great circle length of linestring coordinates (geographic).\n * @param {Array} coordinates Linestring coordinates.\n * @param {number} radius The sphere radius to use.\n * @return {number} The length (in meters).\n */\nfunction getLengthInternal(coordinates, radius) {\n    var length = 0;\n    for (var i = 0, ii = coordinates.length; i < ii - 1; ++i) {\n        length += getDistance(coordinates[i], coordinates[i + 1], radius);\n    }\n    return length;\n}\n/**\n * Get the spherical length of a geometry.  This length is the sum of the\n * great circle distances between coordinates.  For polygons, the length is\n * the sum of all rings.  For points, the length is zero.  For multi-part\n * geometries, the length is the sum of the length of each part.\n * @param {import(\"./geom/Geometry.js\").default} geometry A geometry.\n * @param {SphereMetricOptions} [opt_options] Options for the\n * length calculation.  By default, geometries are assumed to be in 'EPSG:3857'.\n * You can change this by providing a `projection` option.\n * @return {number} The spherical length (in meters).\n * @api\n */\nexport function getLength(geometry, opt_options) {\n    var options = opt_options || {};\n    var radius = options.radius || DEFAULT_RADIUS;\n    var projection = options.projection || 'EPSG:3857';\n    var type = geometry.getType();\n    if (type !== GeometryType.GEOMETRY_COLLECTION) {\n        geometry = geometry.clone().transform(projection, 'EPSG:4326');\n    }\n    var length = 0;\n    var coordinates, coords, i, ii, j, jj;\n    switch (type) {\n        case GeometryType.POINT:\n        case GeometryType.MULTI_POINT: {\n            break;\n        }\n        case GeometryType.LINE_STRING:\n        case GeometryType.LINEAR_RING: {\n            coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (geometry).getCoordinates();\n            length = getLengthInternal(coordinates, radius);\n            break;\n        }\n        case GeometryType.MULTI_LINE_STRING:\n        case GeometryType.POLYGON: {\n            coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (geometry).getCoordinates();\n            for (i = 0, ii = coordinates.length; i < ii; ++i) {\n                length += getLengthInternal(coordinates[i], radius);\n            }\n            break;\n        }\n        case GeometryType.MULTI_POLYGON: {\n            coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (geometry).getCoordinates();\n            for (i = 0, ii = coordinates.length; i < ii; ++i) {\n                coords = coordinates[i];\n                for (j = 0, jj = coords.length; j < jj; ++j) {\n                    length += getLengthInternal(coords[j], radius);\n                }\n            }\n            break;\n        }\n        case GeometryType.GEOMETRY_COLLECTION: {\n            var geometries = \n            /** @type {import(\"./geom/GeometryCollection.js\").default} */ (geometry).getGeometries();\n            for (i = 0, ii = geometries.length; i < ii; ++i) {\n                length += getLength(geometries[i], opt_options);\n            }\n            break;\n        }\n        default: {\n            throw new Error('Unsupported geometry type: ' + type);\n        }\n    }\n    return length;\n}\n/**\n * Returns the spherical area for a list of coordinates.\n *\n * [Reference](https://trs.jpl.nasa.gov/handle/2014/40409)\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for\n * Polygons on a Sphere\", JPL Publication 07-03, Jet Propulsion\n * Laboratory, Pasadena, CA, June 2007\n *\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates List of coordinates of a linear\n * ring. If the ring is oriented clockwise, the area will be positive,\n * otherwise it will be negative.\n * @param {number} radius The sphere radius.\n * @return {number} Area (in square meters).\n */\nfunction getAreaInternal(coordinates, radius) {\n    var area = 0;\n    var len = coordinates.length;\n    var x1 = coordinates[len - 1][0];\n    var y1 = coordinates[len - 1][1];\n    for (var i = 0; i < len; i++) {\n        var x2 = coordinates[i][0];\n        var y2 = coordinates[i][1];\n        area +=\n            toRadians(x2 - x1) *\n                (2 + Math.sin(toRadians(y1)) + Math.sin(toRadians(y2)));\n        x1 = x2;\n        y1 = y2;\n    }\n    return (area * radius * radius) / 2.0;\n}\n/**\n * Get the spherical area of a geometry.  This is the area (in meters) assuming\n * that polygon edges are segments of great circles on a sphere.\n * @param {import(\"./geom/Geometry.js\").default} geometry A geometry.\n * @param {SphereMetricOptions} [opt_options] Options for the area\n *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.\n *     You can change this by providing a `projection` option.\n * @return {number} The spherical area (in square meters).\n * @api\n */\nexport function getArea(geometry, opt_options) {\n    var options = opt_options || {};\n    var radius = options.radius || DEFAULT_RADIUS;\n    var projection = options.projection || 'EPSG:3857';\n    var type = geometry.getType();\n    if (type !== GeometryType.GEOMETRY_COLLECTION) {\n        geometry = geometry.clone().transform(projection, 'EPSG:4326');\n    }\n    var area = 0;\n    var coordinates, coords, i, ii, j, jj;\n    switch (type) {\n        case GeometryType.POINT:\n        case GeometryType.MULTI_POINT:\n        case GeometryType.LINE_STRING:\n        case GeometryType.MULTI_LINE_STRING:\n        case GeometryType.LINEAR_RING: {\n            break;\n        }\n        case GeometryType.POLYGON: {\n            coordinates = /** @type {import(\"./geom/Polygon.js\").default} */ (geometry).getCoordinates();\n            area = Math.abs(getAreaInternal(coordinates[0], radius));\n            for (i = 1, ii = coordinates.length; i < ii; ++i) {\n                area -= Math.abs(getAreaInternal(coordinates[i], radius));\n            }\n            break;\n        }\n        case GeometryType.MULTI_POLYGON: {\n            coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (geometry).getCoordinates();\n            for (i = 0, ii = coordinates.length; i < ii; ++i) {\n                coords = coordinates[i];\n                area += Math.abs(getAreaInternal(coords[0], radius));\n                for (j = 1, jj = coords.length; j < jj; ++j) {\n                    area -= Math.abs(getAreaInternal(coords[j], radius));\n                }\n            }\n            break;\n        }\n        case GeometryType.GEOMETRY_COLLECTION: {\n            var geometries = \n            /** @type {import(\"./geom/GeometryCollection.js\").default} */ (geometry).getGeometries();\n            for (i = 0, ii = geometries.length; i < ii; ++i) {\n                area += getArea(geometries[i], opt_options);\n            }\n            break;\n        }\n        default: {\n            throw new Error('Unsupported geometry type: ' + type);\n        }\n    }\n    return area;\n}\n/**\n * Returns the coordinate at the given distance and bearing from `c1`.\n *\n * @param {import(\"./coordinate.js\").Coordinate} c1 The origin point (`[lon, lat]` in degrees).\n * @param {number} distance The great-circle distance between the origin\n *     point and the target point.\n * @param {number} bearing The bearing (in radians).\n * @param {number} [opt_radius] The sphere radius to use.  Defaults to the Earth's\n *     mean radius using the WGS84 ellipsoid.\n * @return {import(\"./coordinate.js\").Coordinate} The target point.\n */\nexport function offset(c1, distance, bearing, opt_radius) {\n    var radius = opt_radius || DEFAULT_RADIUS;\n    var lat1 = toRadians(c1[1]);\n    var lon1 = toRadians(c1[0]);\n    var dByR = distance / radius;\n    var lat = Math.asin(Math.sin(lat1) * Math.cos(dByR) +\n        Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing));\n    var lon = lon1 +\n        Math.atan2(Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1), Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat));\n    return [toDegrees(lon), toDegrees(lat)];\n}\n//# sourceMappingURL=sphere.js.map","/**\n * @module ol/math\n */\n/**\n * Takes a number and clamps it to within the provided bounds.\n * @param {number} value The input number.\n * @param {number} min The minimum value to return.\n * @param {number} max The maximum value to return.\n * @return {number} The input number if it is within bounds, or the nearest\n *     number within the bounds.\n */\nexport function clamp(value, min, max) {\n    return Math.min(Math.max(value, min), max);\n}\n/**\n * Return the hyperbolic cosine of a given number. The method will use the\n * native `Math.cosh` function if it is available, otherwise the hyperbolic\n * cosine will be calculated via the reference implementation of the Mozilla\n * developer network.\n *\n * @param {number} x X.\n * @return {number} Hyperbolic cosine of x.\n */\nexport var cosh = (function () {\n    // Wrapped in a iife, to save the overhead of checking for the native\n    // implementation on every invocation.\n    var cosh;\n    if ('cosh' in Math) {\n        // The environment supports the native Math.cosh function, use it\n        cosh = Math.cosh;\n    }\n    else {\n        //  else, use the reference implementation of MDN:\n        cosh = function (x) {\n            var y = /** @type {Math} */ (Math).exp(x);\n            return (y + 1 / y) / 2;\n        };\n    }\n    return cosh;\n})();\n/**\n * Return the base 2 logarithm of a given number. The method will use the\n * native `Math.log2` function if it is available, otherwise the base 2\n * logarithm will be calculated via the reference implementation of the\n * Mozilla developer network.\n *\n * @param {number} x X.\n * @return {number} Base 2 logarithm of x.\n */\nexport var log2 = (function () {\n    // Wrapped in a iife, to save the overhead of checking for the native\n    // implementation on every invocation.\n    var log2;\n    if ('log2' in Math) {\n        // The environment supports the native Math.log2 function, use it\n        log2 = Math.log2;\n    }\n    else {\n        //  else, use the reference implementation of MDN:\n        log2 = function (x) {\n            return Math.log(x) * Math.LOG2E;\n        };\n    }\n    return log2;\n})();\n/**\n * Returns the square of the closest distance between the point (x, y) and the\n * line segment (x1, y1) to (x2, y2).\n * @param {number} x X.\n * @param {number} y Y.\n * @param {number} x1 X1.\n * @param {number} y1 Y1.\n * @param {number} x2 X2.\n * @param {number} y2 Y2.\n * @return {number} Squared distance.\n */\nexport function squaredSegmentDistance(x, y, x1, y1, x2, y2) {\n    var dx = x2 - x1;\n    var dy = y2 - y1;\n    if (dx !== 0 || dy !== 0) {\n        var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\n        if (t > 1) {\n            x1 = x2;\n            y1 = y2;\n        }\n        else if (t > 0) {\n            x1 += dx * t;\n            y1 += dy * t;\n        }\n    }\n    return squaredDistance(x, y, x1, y1);\n}\n/**\n * Returns the square of the distance between the points (x1, y1) and (x2, y2).\n * @param {number} x1 X1.\n * @param {number} y1 Y1.\n * @param {number} x2 X2.\n * @param {number} y2 Y2.\n * @return {number} Squared distance.\n */\nexport function squaredDistance(x1, y1, x2, y2) {\n    var dx = x2 - x1;\n    var dy = y2 - y1;\n    return dx * dx + dy * dy;\n}\n/**\n * Solves system of linear equations using Gaussian elimination method.\n *\n * @param {Array<Array<number>>} mat Augmented matrix (n x n + 1 column)\n *                                     in row-major order.\n * @return {Array<number>} The resulting vector.\n */\nexport function solveLinearSystem(mat) {\n    var n = mat.length;\n    for (var i = 0; i < n; i++) {\n        // Find max in the i-th column (ignoring i - 1 first rows)\n        var maxRow = i;\n        var maxEl = Math.abs(mat[i][i]);\n        for (var r = i + 1; r < n; r++) {\n            var absValue = Math.abs(mat[r][i]);\n            if (absValue > maxEl) {\n                maxEl = absValue;\n                maxRow = r;\n            }\n        }\n        if (maxEl === 0) {\n            return null; // matrix is singular\n        }\n        // Swap max row with i-th (current) row\n        var tmp = mat[maxRow];\n        mat[maxRow] = mat[i];\n        mat[i] = tmp;\n        // Subtract the i-th row to make all the remaining rows 0 in the i-th column\n        for (var j = i + 1; j < n; j++) {\n            var coef = -mat[j][i] / mat[i][i];\n            for (var k = i; k < n + 1; k++) {\n                if (i == k) {\n                    mat[j][k] = 0;\n                }\n                else {\n                    mat[j][k] += coef * mat[i][k];\n                }\n            }\n        }\n    }\n    // Solve Ax=b for upper triangular matrix A (mat)\n    var x = new Array(n);\n    for (var l = n - 1; l >= 0; l--) {\n        x[l] = mat[l][n] / mat[l][l];\n        for (var m = l - 1; m >= 0; m--) {\n            mat[m][n] -= mat[m][l] * x[l];\n        }\n    }\n    return x;\n}\n/**\n * Converts radians to to degrees.\n *\n * @param {number} angleInRadians Angle in radians.\n * @return {number} Angle in degrees.\n */\nexport function toDegrees(angleInRadians) {\n    return (angleInRadians * 180) / Math.PI;\n}\n/**\n * Converts degrees to radians.\n *\n * @param {number} angleInDegrees Angle in degrees.\n * @return {number} Angle in radians.\n */\nexport function toRadians(angleInDegrees) {\n    return (angleInDegrees * Math.PI) / 180;\n}\n/**\n * Returns the modulo of a / b, depending on the sign of b.\n *\n * @param {number} a Dividend.\n * @param {number} b Divisor.\n * @return {number} Modulo.\n */\nexport function modulo(a, b) {\n    var r = a % b;\n    return r * b < 0 ? r + b : r;\n}\n/**\n * Calculates the linearly interpolated value of x between a and b.\n *\n * @param {number} a Number\n * @param {number} b Number\n * @param {number} x Value to be interpolated.\n * @return {number} Interpolated value.\n */\nexport function lerp(a, b, x) {\n    return a + x * (b - a);\n}\n/**\n * Returns a number with a limited number of decimal digits.\n * @param {number} n The input number.\n * @param {number} decimals The maximum number of decimal digits.\n * @return {number} The input number with a limited number of decimal digits.\n */\nexport function toFixed(n, decimals) {\n    var factor = Math.pow(10, decimals);\n    return Math.round(n * factor) / factor;\n}\n/**\n * Rounds a number to the nearest integer value considering only the given number\n * of decimal digits (with rounding on the final digit).\n * @param {number} n The input number.\n * @param {number} decimals The maximum number of decimal digits.\n * @return {number} The nearest integer.\n */\nexport function round(n, decimals) {\n    return Math.round(toFixed(n, decimals));\n}\n/**\n * Rounds a number to the next smaller integer considering only the given number\n * of decimal digits (with rounding on the final digit).\n * @param {number} n The input number.\n * @param {number} decimals The maximum number of decimal digits.\n * @return {number} The next smaller integer.\n */\nexport function floor(n, decimals) {\n    return Math.floor(toFixed(n, decimals));\n}\n/**\n * Rounds a number to the next bigger integer considering only the given number\n * of decimal digits (with rounding on the final digit).\n * @param {number} n The input number.\n * @param {number} decimals The maximum number of decimal digits.\n * @return {number} The next bigger integer.\n */\nexport function ceil(n, decimals) {\n    return Math.ceil(toFixed(n, decimals));\n}\n//# sourceMappingURL=math.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/AssertionError\n */\nimport { VERSION } from './util.js';\n/**\n * Error object thrown when an assertion failed. This is an ECMA-262 Error,\n * extended with a `code` property.\n * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error.\n */\nvar AssertionError = /** @class */ (function (_super) {\n    __extends(AssertionError, _super);\n    /**\n     * @param {number} code Error code.\n     */\n    function AssertionError(code) {\n        var _this = this;\n        var path = VERSION === 'latest' ? VERSION : 'v' + VERSION.split('-')[0];\n        var message = 'Assertion failed. See https://openlayers.org/en/' +\n            path +\n            '/doc/errors/#' +\n            code +\n            ' for details.';\n        _this = _super.call(this, message) || this;\n        /**\n         * Error code. The meaning of the code can be found on\n         * https://openlayers.org/en/latest/doc/errors/ (replace `latest` with\n         * the version found in the OpenLayers script's header comment if a version\n         * other than the latest is used).\n         * @type {number}\n         * @api\n         */\n        _this.code = code;\n        /**\n         * @type {string}\n         */\n        _this.name = 'AssertionError';\n        // Re-assign message, see https://github.com/Rich-Harris/buble/issues/40\n        _this.message = message;\n        return _this;\n    }\n    return AssertionError;\n}(Error));\nexport default AssertionError;\n//# sourceMappingURL=AssertionError.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/proj/epsg4326\n */\nimport Projection from './Projection.js';\nimport Units from './Units.js';\n/**\n * Semi-major radius of the WGS84 ellipsoid.\n *\n * @const\n * @type {number}\n */\nexport var RADIUS = 6378137;\n/**\n * Extent of the EPSG:4326 projection which is the whole world.\n *\n * @const\n * @type {import(\"../extent.js\").Extent}\n */\nexport var EXTENT = [-180, -90, 180, 90];\n/**\n * @const\n * @type {number}\n */\nexport var METERS_PER_UNIT = (Math.PI * RADIUS) / 180;\n/**\n * @classdesc\n * Projection object for WGS84 geographic coordinates (EPSG:4326).\n *\n * Note that OpenLayers does not strictly comply with the EPSG definition.\n * The EPSG registry defines 4326 as a CRS for Latitude,Longitude (y,x).\n * OpenLayers treats EPSG:4326 as a pseudo-projection, with x,y coordinates.\n */\nvar EPSG4326Projection = /** @class */ (function (_super) {\n    __extends(EPSG4326Projection, _super);\n    /**\n     * @param {string} code Code.\n     * @param {string} [opt_axisOrientation] Axis orientation.\n     */\n    function EPSG4326Projection(code, opt_axisOrientation) {\n        return _super.call(this, {\n            code: code,\n            units: Units.DEGREES,\n            extent: EXTENT,\n            axisOrientation: opt_axisOrientation,\n            global: true,\n            metersPerUnit: METERS_PER_UNIT,\n            worldExtent: EXTENT,\n        }) || this;\n    }\n    return EPSG4326Projection;\n}(Projection));\n/**\n * Projections equal to EPSG:4326.\n *\n * @const\n * @type {Array<import(\"./Projection.js\").default>}\n */\nexport var PROJECTIONS = [\n    new EPSG4326Projection('CRS:84'),\n    new EPSG4326Projection('EPSG:4326', 'neu'),\n    new EPSG4326Projection('urn:ogc:def:crs:OGC:1.3:CRS84'),\n    new EPSG4326Projection('urn:ogc:def:crs:OGC:2:84'),\n    new EPSG4326Projection('http://www.opengis.net/def/crs/OGC/1.3/CRS84'),\n    new EPSG4326Projection('http://www.opengis.net/gml/srs/epsg.xml#4326', 'neu'),\n    new EPSG4326Projection('http://www.opengis.net/def/crs/EPSG/0/4326', 'neu'),\n];\n//# sourceMappingURL=epsg4326.js.map","/**\n * @module ol/asserts\n */\nimport AssertionError from './AssertionError.js';\n/**\n * @param {*} assertion Assertion we expected to be truthy.\n * @param {number} errorCode Error code.\n */\nexport function assert(assertion, errorCode) {\n    if (!assertion) {\n        throw new AssertionError(errorCode);\n    }\n}\n//# sourceMappingURL=asserts.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/proj/epsg3857\n */\nimport Projection from './Projection.js';\nimport Units from './Units.js';\nimport { cosh } from '../math.js';\n/**\n * Radius of WGS84 sphere\n *\n * @const\n * @type {number}\n */\nexport var RADIUS = 6378137;\n/**\n * @const\n * @type {number}\n */\nexport var HALF_SIZE = Math.PI * RADIUS;\n/**\n * @const\n * @type {import(\"../extent.js\").Extent}\n */\nexport var EXTENT = [-HALF_SIZE, -HALF_SIZE, HALF_SIZE, HALF_SIZE];\n/**\n * @const\n * @type {import(\"../extent.js\").Extent}\n */\nexport var WORLD_EXTENT = [-180, -85, 180, 85];\n/**\n * Maximum safe value in y direction\n * @const\n * @type {number}\n */\nexport var MAX_SAFE_Y = RADIUS * Math.log(Math.tan(Math.PI / 2));\n/**\n * @classdesc\n * Projection object for web/spherical Mercator (EPSG:3857).\n */\nvar EPSG3857Projection = /** @class */ (function (_super) {\n    __extends(EPSG3857Projection, _super);\n    /**\n     * @param {string} code Code.\n     */\n    function EPSG3857Projection(code) {\n        return _super.call(this, {\n            code: code,\n            units: Units.METERS,\n            extent: EXTENT,\n            global: true,\n            worldExtent: WORLD_EXTENT,\n            getPointResolution: function (resolution, point) {\n                return resolution / cosh(point[1] / RADIUS);\n            },\n        }) || this;\n    }\n    return EPSG3857Projection;\n}(Projection));\n/**\n * Projections equal to EPSG:3857.\n *\n * @const\n * @type {Array<import(\"./Projection.js\").default>}\n */\nexport var PROJECTIONS = [\n    new EPSG3857Projection('EPSG:3857'),\n    new EPSG3857Projection('EPSG:102100'),\n    new EPSG3857Projection('EPSG:102113'),\n    new EPSG3857Projection('EPSG:900913'),\n    new EPSG3857Projection('http://www.opengis.net/def/crs/EPSG/0/3857'),\n    new EPSG3857Projection('http://www.opengis.net/gml/srs/epsg.xml#3857'),\n];\n/**\n * Transformation from EPSG:4326 to EPSG:3857.\n *\n * @param {Array<number>} input Input array of coordinate values.\n * @param {Array<number>} [opt_output] Output array of coordinate values.\n * @param {number} [opt_dimension] Dimension (default is `2`).\n * @return {Array<number>} Output array of coordinate values.\n */\nexport function fromEPSG4326(input, opt_output, opt_dimension) {\n    var length = input.length;\n    var dimension = opt_dimension > 1 ? opt_dimension : 2;\n    var output = opt_output;\n    if (output === undefined) {\n        if (dimension > 2) {\n            // preserve values beyond second dimension\n            output = input.slice();\n        }\n        else {\n            output = new Array(length);\n        }\n    }\n    for (var i = 0; i < length; i += dimension) {\n        output[i] = (HALF_SIZE * input[i]) / 180;\n        var y = RADIUS * Math.log(Math.tan((Math.PI * (+input[i + 1] + 90)) / 360));\n        if (y > MAX_SAFE_Y) {\n            y = MAX_SAFE_Y;\n        }\n        else if (y < -MAX_SAFE_Y) {\n            y = -MAX_SAFE_Y;\n        }\n        output[i + 1] = y;\n    }\n    return output;\n}\n/**\n * Transformation from EPSG:3857 to EPSG:4326.\n *\n * @param {Array<number>} input Input array of coordinate values.\n * @param {Array<number>} [opt_output] Output array of coordinate values.\n * @param {number} [opt_dimension] Dimension (default is `2`).\n * @return {Array<number>} Output array of coordinate values.\n */\nexport function toEPSG4326(input, opt_output, opt_dimension) {\n    var length = input.length;\n    var dimension = opt_dimension > 1 ? opt_dimension : 2;\n    var output = opt_output;\n    if (output === undefined) {\n        if (dimension > 2) {\n            // preserve values beyond second dimension\n            output = input.slice();\n        }\n        else {\n            output = new Array(length);\n        }\n    }\n    for (var i = 0; i < length; i += dimension) {\n        output[i] = (180 * input[i]) / HALF_SIZE;\n        output[i + 1] =\n            (360 * Math.atan(Math.exp(input[i + 1] / RADIUS))) / Math.PI - 90;\n    }\n    return output;\n}\n//# sourceMappingURL=epsg3857.js.map","/**\n * @module ol/coordinate\n */\nimport { getWidth } from './extent.js';\nimport { modulo } from './math.js';\nimport { padNumber } from './string.js';\n/**\n * An array of numbers representing an xy coordinate. Example: `[16, 48]`.\n * @typedef {Array<number>} Coordinate\n * @api\n */\n/**\n * A function that takes a {@link module:ol/coordinate~Coordinate} and\n * transforms it into a `{string}`.\n *\n * @typedef {function((Coordinate|undefined)): string} CoordinateFormat\n * @api\n */\n/**\n * Add `delta` to `coordinate`. `coordinate` is modified in place and returned\n * by the function.\n *\n * Example:\n *\n *     import {add} from 'ol/coordinate';\n *\n *     var coord = [7.85, 47.983333];\n *     add(coord, [-2, 4]);\n *     // coord is now [5.85, 51.983333]\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {Coordinate} delta Delta.\n * @return {Coordinate} The input coordinate adjusted by\n * the given delta.\n * @api\n */\nexport function add(coordinate, delta) {\n    coordinate[0] += +delta[0];\n    coordinate[1] += +delta[1];\n    return coordinate;\n}\n/**\n * Calculates the point closest to the passed coordinate on the passed circle.\n *\n * @param {Coordinate} coordinate The coordinate.\n * @param {import(\"./geom/Circle.js\").default} circle The circle.\n * @return {Coordinate} Closest point on the circumference.\n */\nexport function closestOnCircle(coordinate, circle) {\n    var r = circle.getRadius();\n    var center = circle.getCenter();\n    var x0 = center[0];\n    var y0 = center[1];\n    var x1 = coordinate[0];\n    var y1 = coordinate[1];\n    var dx = x1 - x0;\n    var dy = y1 - y0;\n    if (dx === 0 && dy === 0) {\n        dx = 1;\n    }\n    var d = Math.sqrt(dx * dx + dy * dy);\n    var x = x0 + (r * dx) / d;\n    var y = y0 + (r * dy) / d;\n    return [x, y];\n}\n/**\n * Calculates the point closest to the passed coordinate on the passed segment.\n * This is the foot of the perpendicular of the coordinate to the segment when\n * the foot is on the segment, or the closest segment coordinate when the foot\n * is outside the segment.\n *\n * @param {Coordinate} coordinate The coordinate.\n * @param {Array<Coordinate>} segment The two coordinates\n * of the segment.\n * @return {Coordinate} The foot of the perpendicular of\n * the coordinate to the segment.\n */\nexport function closestOnSegment(coordinate, segment) {\n    var x0 = coordinate[0];\n    var y0 = coordinate[1];\n    var start = segment[0];\n    var end = segment[1];\n    var x1 = start[0];\n    var y1 = start[1];\n    var x2 = end[0];\n    var y2 = end[1];\n    var dx = x2 - x1;\n    var dy = y2 - y1;\n    var along = dx === 0 && dy === 0\n        ? 0\n        : (dx * (x0 - x1) + dy * (y0 - y1)) / (dx * dx + dy * dy || 0);\n    var x, y;\n    if (along <= 0) {\n        x = x1;\n        y = y1;\n    }\n    else if (along >= 1) {\n        x = x2;\n        y = y2;\n    }\n    else {\n        x = x1 + along * dx;\n        y = y1 + along * dy;\n    }\n    return [x, y];\n}\n/**\n * Returns a {@link module:ol/coordinate~CoordinateFormat} function that can be\n * used to format\n * a {Coordinate} to a string.\n *\n * Example without specifying the fractional digits:\n *\n *     import {createStringXY} from 'ol/coordinate';\n *\n *     var coord = [7.85, 47.983333];\n *     var stringifyFunc = createStringXY();\n *     var out = stringifyFunc(coord);\n *     // out is now '8, 48'\n *\n * Example with explicitly specifying 2 fractional digits:\n *\n *     import {createStringXY} from 'ol/coordinate';\n *\n *     var coord = [7.85, 47.983333];\n *     var stringifyFunc = createStringXY(2);\n *     var out = stringifyFunc(coord);\n *     // out is now '7.85, 47.98'\n *\n * @param {number} [opt_fractionDigits] The number of digits to include\n *    after the decimal point. Default is `0`.\n * @return {CoordinateFormat} Coordinate format.\n * @api\n */\nexport function createStringXY(opt_fractionDigits) {\n    return (\n    /**\n     * @param {Coordinate} coordinate Coordinate.\n     * @return {string} String XY.\n     */\n    function (coordinate) {\n        return toStringXY(coordinate, opt_fractionDigits);\n    });\n}\n/**\n * @param {string} hemispheres Hemispheres.\n * @param {number} degrees Degrees.\n * @param {number} [opt_fractionDigits] The number of digits to include\n *    after the decimal point. Default is `0`.\n * @return {string} String.\n */\nexport function degreesToStringHDMS(hemispheres, degrees, opt_fractionDigits) {\n    var normalizedDegrees = modulo(degrees + 180, 360) - 180;\n    var x = Math.abs(3600 * normalizedDegrees);\n    var dflPrecision = opt_fractionDigits || 0;\n    var precision = Math.pow(10, dflPrecision);\n    var deg = Math.floor(x / 3600);\n    var min = Math.floor((x - deg * 3600) / 60);\n    var sec = x - deg * 3600 - min * 60;\n    sec = Math.ceil(sec * precision) / precision;\n    if (sec >= 60) {\n        sec = 0;\n        min += 1;\n    }\n    if (min >= 60) {\n        min = 0;\n        deg += 1;\n    }\n    return (deg +\n        '\\u00b0 ' +\n        padNumber(min, 2) +\n        '\\u2032 ' +\n        padNumber(sec, 2, dflPrecision) +\n        '\\u2033' +\n        (normalizedDegrees == 0\n            ? ''\n            : ' ' + hemispheres.charAt(normalizedDegrees < 0 ? 1 : 0)));\n}\n/**\n * Transforms the given {@link module:ol/coordinate~Coordinate} to a string\n * using the given string template. The strings `{x}` and `{y}` in the template\n * will be replaced with the first and second coordinate values respectively.\n *\n * Example without specifying the fractional digits:\n *\n *     import {format} from 'ol/coordinate';\n *\n *     var coord = [7.85, 47.983333];\n *     var template = 'Coordinate is ({x}|{y}).';\n *     var out = format(coord, template);\n *     // out is now 'Coordinate is (8|48).'\n *\n * Example explicitly specifying the fractional digits:\n *\n *     import {format} from 'ol/coordinate';\n *\n *     var coord = [7.85, 47.983333];\n *     var template = 'Coordinate is ({x}|{y}).';\n *     var out = format(coord, template, 2);\n *     // out is now 'Coordinate is (7.85|47.98).'\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {string} template A template string with `{x}` and `{y}` placeholders\n *     that will be replaced by first and second coordinate values.\n * @param {number} [opt_fractionDigits] The number of digits to include\n *    after the decimal point. Default is `0`.\n * @return {string} Formatted coordinate.\n * @api\n */\nexport function format(coordinate, template, opt_fractionDigits) {\n    if (coordinate) {\n        return template\n            .replace('{x}', coordinate[0].toFixed(opt_fractionDigits))\n            .replace('{y}', coordinate[1].toFixed(opt_fractionDigits));\n    }\n    else {\n        return '';\n    }\n}\n/**\n * @param {Coordinate} coordinate1 First coordinate.\n * @param {Coordinate} coordinate2 Second coordinate.\n * @return {boolean} The two coordinates are equal.\n */\nexport function equals(coordinate1, coordinate2) {\n    var equals = true;\n    for (var i = coordinate1.length - 1; i >= 0; --i) {\n        if (coordinate1[i] != coordinate2[i]) {\n            equals = false;\n            break;\n        }\n    }\n    return equals;\n}\n/**\n * Rotate `coordinate` by `angle`. `coordinate` is modified in place and\n * returned by the function.\n *\n * Example:\n *\n *     import {rotate} from 'ol/coordinate';\n *\n *     var coord = [7.85, 47.983333];\n *     var rotateRadians = Math.PI / 2; // 90 degrees\n *     rotate(coord, rotateRadians);\n *     // coord is now [-47.983333, 7.85]\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {number} angle Angle in radian.\n * @return {Coordinate} Coordinate.\n * @api\n */\nexport function rotate(coordinate, angle) {\n    var cosAngle = Math.cos(angle);\n    var sinAngle = Math.sin(angle);\n    var x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;\n    var y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;\n    coordinate[0] = x;\n    coordinate[1] = y;\n    return coordinate;\n}\n/**\n * Scale `coordinate` by `scale`. `coordinate` is modified in place and returned\n * by the function.\n *\n * Example:\n *\n *     import {scale as scaleCoordinate} from 'ol/coordinate';\n *\n *     var coord = [7.85, 47.983333];\n *     var scale = 1.2;\n *     scaleCoordinate(coord, scale);\n *     // coord is now [9.42, 57.5799996]\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {number} scale Scale factor.\n * @return {Coordinate} Coordinate.\n */\nexport function scale(coordinate, scale) {\n    coordinate[0] *= scale;\n    coordinate[1] *= scale;\n    return coordinate;\n}\n/**\n * @param {Coordinate} coord1 First coordinate.\n * @param {Coordinate} coord2 Second coordinate.\n * @return {number} Squared distance between coord1 and coord2.\n */\nexport function squaredDistance(coord1, coord2) {\n    var dx = coord1[0] - coord2[0];\n    var dy = coord1[1] - coord2[1];\n    return dx * dx + dy * dy;\n}\n/**\n * @param {Coordinate} coord1 First coordinate.\n * @param {Coordinate} coord2 Second coordinate.\n * @return {number} Distance between coord1 and coord2.\n */\nexport function distance(coord1, coord2) {\n    return Math.sqrt(squaredDistance(coord1, coord2));\n}\n/**\n * Calculate the squared distance from a coordinate to a line segment.\n *\n * @param {Coordinate} coordinate Coordinate of the point.\n * @param {Array<Coordinate>} segment Line segment (2\n * coordinates).\n * @return {number} Squared distance from the point to the line segment.\n */\nexport function squaredDistanceToSegment(coordinate, segment) {\n    return squaredDistance(coordinate, closestOnSegment(coordinate, segment));\n}\n/**\n * Format a geographic coordinate with the hemisphere, degrees, minutes, and\n * seconds.\n *\n * Example without specifying fractional digits:\n *\n *     import {toStringHDMS} from 'ol/coordinate';\n *\n *     var coord = [7.85, 47.983333];\n *     var out = toStringHDMS(coord);\n *     // out is now '47 58 60 N 7 50 60 E'\n *\n * Example explicitly specifying 1 fractional digit:\n *\n *     import {toStringHDMS} from 'ol/coordinate';\n *\n *     var coord = [7.85, 47.983333];\n *     var out = toStringHDMS(coord, 1);\n *     // out is now '47 58 60.0 N 7 50 60.0 E'\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {number} [opt_fractionDigits] The number of digits to include\n *    after the decimal point. Default is `0`.\n * @return {string} Hemisphere, degrees, minutes and seconds.\n * @api\n */\nexport function toStringHDMS(coordinate, opt_fractionDigits) {\n    if (coordinate) {\n        return (degreesToStringHDMS('NS', coordinate[1], opt_fractionDigits) +\n            ' ' +\n            degreesToStringHDMS('EW', coordinate[0], opt_fractionDigits));\n    }\n    else {\n        return '';\n    }\n}\n/**\n * Format a coordinate as a comma delimited string.\n *\n * Example without specifying fractional digits:\n *\n *     import {toStringXY} from 'ol/coordinate';\n *\n *     var coord = [7.85, 47.983333];\n *     var out = toStringXY(coord);\n *     // out is now '8, 48'\n *\n * Example explicitly specifying 1 fractional digit:\n *\n *     import {toStringXY} from 'ol/coordinate';\n *\n *     var coord = [7.85, 47.983333];\n *     var out = toStringXY(coord, 1);\n *     // out is now '7.8, 48.0'\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {number} [opt_fractionDigits] The number of digits to include\n *    after the decimal point. Default is `0`.\n * @return {string} XY.\n * @api\n */\nexport function toStringXY(coordinate, opt_fractionDigits) {\n    return format(coordinate, '{x}, {y}', opt_fractionDigits);\n}\n/**\n * Modifies the provided coordinate in-place to be within the real world\n * extent. The lower projection extent boundary is inclusive, the upper one\n * exclusive.\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {Coordinate} The coordinate within the real world extent.\n */\nexport function wrapX(coordinate, projection) {\n    if (projection.canWrapX()) {\n        var worldWidth = getWidth(projection.getExtent());\n        var worldsAway = getWorldsAway(coordinate, projection, worldWidth);\n        if (worldsAway) {\n            coordinate[0] -= worldsAway * worldWidth;\n        }\n    }\n    return coordinate;\n}\n/**\n * @param {Coordinate} coordinate Coordinate.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @param {number} [opt_sourceExtentWidth] Width of the source extent.\n * @return {number} Offset in world widths.\n */\nexport function getWorldsAway(coordinate, projection, opt_sourceExtentWidth) {\n    var projectionExtent = projection.getExtent();\n    var worldsAway = 0;\n    if (projection.canWrapX() &&\n        (coordinate[0] < projectionExtent[0] || coordinate[0] > projectionExtent[2])) {\n        var sourceExtentWidth = opt_sourceExtentWidth || getWidth(projectionExtent);\n        worldsAway = Math.floor((coordinate[0] - projectionExtent[0]) / sourceExtentWidth);\n    }\n    return worldsAway;\n}\n//# sourceMappingURL=coordinate.js.map","/**\n * @module ol/string\n */\n/**\n * @param {number} number Number to be formatted\n * @param {number} width The desired width\n * @param {number} [opt_precision] Precision of the output string (i.e. number of decimal places)\n * @return {string} Formatted string\n */\nexport function padNumber(number, width, opt_precision) {\n    var numberString = opt_precision !== undefined ? number.toFixed(opt_precision) : '' + number;\n    var decimal = numberString.indexOf('.');\n    decimal = decimal === -1 ? numberString.length : decimal;\n    return decimal > width\n        ? numberString\n        : new Array(1 + width - decimal).join('0') + numberString;\n}\n/**\n * Adapted from https://github.com/omichelsen/compare-versions/blob/master/index.js\n * @param {string|number} v1 First version\n * @param {string|number} v2 Second version\n * @return {number} Value\n */\nexport function compareVersions(v1, v2) {\n    var s1 = ('' + v1).split('.');\n    var s2 = ('' + v2).split('.');\n    for (var i = 0; i < Math.max(s1.length, s2.length); i++) {\n        var n1 = parseInt(s1[i] || '0', 10);\n        var n2 = parseInt(s2[i] || '0', 10);\n        if (n1 > n2) {\n            return 1;\n        }\n        if (n2 > n1) {\n            return -1;\n        }\n    }\n    return 0;\n}\n//# sourceMappingURL=string.js.map","/**\n * @module ol/proj/proj4\n */\nimport Projection from './Projection.js';\nimport Units from './Units.js';\nimport { addCoordinateTransforms, addEquivalentProjections, addProjection, createSafeCoordinateTransform, get, } from '../proj.js';\nimport { get as getTransform } from './transforms.js';\n/**\n * Make projections defined in proj4 (with `proj4.defs()`) available in\n * OpenLayers.\n *\n * This function should be called whenever changes are made to the proj4\n * registry, e.g. after calling `proj4.defs()`. Existing transforms will not be\n * modified by this function.\n *\n * @param {?} proj4 Proj4.\n * @api\n */\nexport function register(proj4) {\n    var projCodes = Object.keys(proj4.defs);\n    var len = projCodes.length;\n    var i, j;\n    for (i = 0; i < len; ++i) {\n        var code = projCodes[i];\n        if (!get(code)) {\n            var def = proj4.defs(code);\n            var units = def.units;\n            if (!units && def.projName === 'longlat') {\n                units = Units.DEGREES;\n            }\n            addProjection(new Projection({\n                code: code,\n                axisOrientation: def.axis,\n                metersPerUnit: def.to_meter,\n                units: units,\n            }));\n        }\n    }\n    for (i = 0; i < len; ++i) {\n        var code1 = projCodes[i];\n        var proj1 = get(code1);\n        for (j = 0; j < len; ++j) {\n            var code2 = projCodes[j];\n            var proj2 = get(code2);\n            if (!getTransform(code1, code2)) {\n                if (proj4.defs[code1] === proj4.defs[code2]) {\n                    addEquivalentProjections([proj1, proj2]);\n                }\n                else {\n                    var transform = proj4(code1, code2);\n                    addCoordinateTransforms(proj1, proj2, createSafeCoordinateTransform(proj1, proj2, transform.forward), createSafeCoordinateTransform(proj2, proj1, transform.inverse));\n                }\n            }\n        }\n    }\n}\n//# sourceMappingURL=proj4.js.map","/**\n * @module ol/proj/projections\n */\n/**\n * @type {Object<string, import(\"./Projection.js\").default>}\n */\nvar cache = {};\n/**\n * Clear the projections cache.\n */\nexport function clear() {\n    cache = {};\n}\n/**\n * Get a cached projection by code.\n * @param {string} code The code for the projection.\n * @return {import(\"./Projection.js\").default} The projection (if cached).\n */\nexport function get(code) {\n    return (cache[code] ||\n        cache[code.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\\w+)$/, 'EPSG:$3')] ||\n        null);\n}\n/**\n * Add a projection to the cache.\n * @param {string} code The projection code.\n * @param {import(\"./Projection.js\").default} projection The projection to cache.\n */\nexport function add(code, projection) {\n    cache[code] = projection;\n}\n//# sourceMappingURL=projections.js.map","/**\n * @module ol/proj/transforms\n */\nimport { isEmpty } from '../obj.js';\n/**\n * @private\n * @type {!Object<string, Object<string, import(\"../proj.js\").TransformFunction>>}\n */\nvar transforms = {};\n/**\n * Clear the transform cache.\n */\nexport function clear() {\n    transforms = {};\n}\n/**\n * Registers a conversion function to convert coordinates from the source\n * projection to the destination projection.\n *\n * @param {import(\"./Projection.js\").default} source Source.\n * @param {import(\"./Projection.js\").default} destination Destination.\n * @param {import(\"../proj.js\").TransformFunction} transformFn Transform.\n */\nexport function add(source, destination, transformFn) {\n    var sourceCode = source.getCode();\n    var destinationCode = destination.getCode();\n    if (!(sourceCode in transforms)) {\n        transforms[sourceCode] = {};\n    }\n    transforms[sourceCode][destinationCode] = transformFn;\n}\n/**\n * Unregisters the conversion function to convert coordinates from the source\n * projection to the destination projection.  This method is used to clean up\n * cached transforms during testing.\n *\n * @param {import(\"./Projection.js\").default} source Source projection.\n * @param {import(\"./Projection.js\").default} destination Destination projection.\n * @return {import(\"../proj.js\").TransformFunction} transformFn The unregistered transform.\n */\nexport function remove(source, destination) {\n    var sourceCode = source.getCode();\n    var destinationCode = destination.getCode();\n    var transform = transforms[sourceCode][destinationCode];\n    delete transforms[sourceCode][destinationCode];\n    if (isEmpty(transforms[sourceCode])) {\n        delete transforms[sourceCode];\n    }\n    return transform;\n}\n/**\n * Get a transform given a source code and a destination code.\n * @param {string} sourceCode The code for the source projection.\n * @param {string} destinationCode The code for the destination projection.\n * @return {import(\"../proj.js\").TransformFunction|undefined} The transform function (if found).\n */\nexport function get(sourceCode, destinationCode) {\n    var transform;\n    if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {\n        transform = transforms[sourceCode][destinationCode];\n    }\n    return transform;\n}\n//# sourceMappingURL=transforms.js.map","/**\n * @module ol/proj/Projection\n */\nimport { METERS_PER_UNIT } from './Units.js';\n/**\n * @typedef {Object} Options\n * @property {string} code The SRS identifier code, e.g. `EPSG:4326`.\n * @property {import(\"./Units.js\").default|string} [units] Units. Required unless a\n * proj4 projection is defined for `code`.\n * @property {import(\"../extent.js\").Extent} [extent] The validity extent for the SRS.\n * @property {string} [axisOrientation='enu'] The axis orientation as specified in Proj4.\n * @property {boolean} [global=false] Whether the projection is valid for the whole globe.\n * @property {number} [metersPerUnit] The meters per unit for the SRS.\n * If not provided, the `units` are used to get the meters per unit from the {@link module:ol/proj/Units~METERS_PER_UNIT}\n * lookup table.\n * @property {import(\"../extent.js\").Extent} [worldExtent] The world extent for the SRS.\n * @property {function(number, import(\"../coordinate.js\").Coordinate):number} [getPointResolution]\n * Function to determine resolution at a point. The function is called with a\n * `number` view resolution and a {@link module:ol/coordinate~Coordinate Coordinate} as arguments, and returns\n * the `number` resolution in projection units at the passed coordinate. If this is `undefined`,\n * the default {@link module:ol/proj.getPointResolution getPointResolution()} function will be used.\n */\n/**\n * @classdesc\n * Projection definition class. One of these is created for each projection\n * supported in the application and stored in the {@link module:ol/proj} namespace.\n * You can use these in applications, but this is not required, as API params\n * and options use {@link module:ol/proj~ProjectionLike} which means the simple string\n * code will suffice.\n *\n * You can use {@link module:ol/proj.get} to retrieve the object for a particular\n * projection.\n *\n * The library includes definitions for `EPSG:4326` and `EPSG:3857`, together\n * with the following aliases:\n * * `EPSG:4326`: CRS:84, urn:ogc:def:crs:EPSG:6.6:4326,\n *     urn:ogc:def:crs:OGC:1.3:CRS84, urn:ogc:def:crs:OGC:2:84,\n *     http://www.opengis.net/gml/srs/epsg.xml#4326,\n *     urn:x-ogc:def:crs:EPSG:4326\n * * `EPSG:3857`: EPSG:102100, EPSG:102113, EPSG:900913,\n *     urn:ogc:def:crs:EPSG:6.18:3:3857,\n *     http://www.opengis.net/gml/srs/epsg.xml#3857\n *\n * If you use [proj4js](https://github.com/proj4js/proj4js), aliases can\n * be added using `proj4.defs()`. After all required projection definitions are\n * added, call the {@link module:ol/proj/proj4.register} function.\n *\n * @api\n */\nvar Projection = /** @class */ (function () {\n    /**\n     * @param {Options} options Projection options.\n     */\n    function Projection(options) {\n        /**\n         * @private\n         * @type {string}\n         */\n        this.code_ = options.code;\n        /**\n         * Units of projected coordinates. When set to `TILE_PIXELS`, a\n         * `this.extent_` and `this.worldExtent_` must be configured properly for each\n         * tile.\n         * @private\n         * @type {import(\"./Units.js\").default}\n         */\n        this.units_ = /** @type {import(\"./Units.js\").default} */ (options.units);\n        /**\n         * Validity extent of the projection in projected coordinates. For projections\n         * with `TILE_PIXELS` units, this is the extent of the tile in\n         * tile pixel space.\n         * @private\n         * @type {import(\"../extent.js\").Extent}\n         */\n        this.extent_ = options.extent !== undefined ? options.extent : null;\n        /**\n         * Extent of the world in EPSG:4326. For projections with\n         * `TILE_PIXELS` units, this is the extent of the tile in\n         * projected coordinate space.\n         * @private\n         * @type {import(\"../extent.js\").Extent}\n         */\n        this.worldExtent_ =\n            options.worldExtent !== undefined ? options.worldExtent : null;\n        /**\n         * @private\n         * @type {string}\n         */\n        this.axisOrientation_ =\n            options.axisOrientation !== undefined ? options.axisOrientation : 'enu';\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this.global_ = options.global !== undefined ? options.global : false;\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this.canWrapX_ = !!(this.global_ && this.extent_);\n        /**\n         * @private\n         * @type {function(number, import(\"../coordinate.js\").Coordinate):number|undefined}\n         */\n        this.getPointResolutionFunc_ = options.getPointResolution;\n        /**\n         * @private\n         * @type {import(\"../tilegrid/TileGrid.js\").default}\n         */\n        this.defaultTileGrid_ = null;\n        /**\n         * @private\n         * @type {number|undefined}\n         */\n        this.metersPerUnit_ = options.metersPerUnit;\n    }\n    /**\n     * @return {boolean} The projection is suitable for wrapping the x-axis\n     */\n    Projection.prototype.canWrapX = function () {\n        return this.canWrapX_;\n    };\n    /**\n     * Get the code for this projection, e.g. 'EPSG:4326'.\n     * @return {string} Code.\n     * @api\n     */\n    Projection.prototype.getCode = function () {\n        return this.code_;\n    };\n    /**\n     * Get the validity extent for this projection.\n     * @return {import(\"../extent.js\").Extent} Extent.\n     * @api\n     */\n    Projection.prototype.getExtent = function () {\n        return this.extent_;\n    };\n    /**\n     * Get the units of this projection.\n     * @return {import(\"./Units.js\").default} Units.\n     * @api\n     */\n    Projection.prototype.getUnits = function () {\n        return this.units_;\n    };\n    /**\n     * Get the amount of meters per unit of this projection.  If the projection is\n     * not configured with `metersPerUnit` or a units identifier, the return is\n     * `undefined`.\n     * @return {number|undefined} Meters.\n     * @api\n     */\n    Projection.prototype.getMetersPerUnit = function () {\n        return this.metersPerUnit_ || METERS_PER_UNIT[this.units_];\n    };\n    /**\n     * Get the world extent for this projection.\n     * @return {import(\"../extent.js\").Extent} Extent.\n     * @api\n     */\n    Projection.prototype.getWorldExtent = function () {\n        return this.worldExtent_;\n    };\n    /**\n     * Get the axis orientation of this projection.\n     * Example values are:\n     * enu - the default easting, northing, elevation.\n     * neu - northing, easting, up - useful for \"lat/long\" geographic coordinates,\n     *     or south orientated transverse mercator.\n     * wnu - westing, northing, up - some planetary coordinate systems have\n     *     \"west positive\" coordinate systems\n     * @return {string} Axis orientation.\n     * @api\n     */\n    Projection.prototype.getAxisOrientation = function () {\n        return this.axisOrientation_;\n    };\n    /**\n     * Is this projection a global projection which spans the whole world?\n     * @return {boolean} Whether the projection is global.\n     * @api\n     */\n    Projection.prototype.isGlobal = function () {\n        return this.global_;\n    };\n    /**\n     * Set if the projection is a global projection which spans the whole world\n     * @param {boolean} global Whether the projection is global.\n     * @api\n     */\n    Projection.prototype.setGlobal = function (global) {\n        this.global_ = global;\n        this.canWrapX_ = !!(global && this.extent_);\n    };\n    /**\n     * @return {import(\"../tilegrid/TileGrid.js\").default} The default tile grid.\n     */\n    Projection.prototype.getDefaultTileGrid = function () {\n        return this.defaultTileGrid_;\n    };\n    /**\n     * @param {import(\"../tilegrid/TileGrid.js\").default} tileGrid The default tile grid.\n     */\n    Projection.prototype.setDefaultTileGrid = function (tileGrid) {\n        this.defaultTileGrid_ = tileGrid;\n    };\n    /**\n     * Set the validity extent for this projection.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @api\n     */\n    Projection.prototype.setExtent = function (extent) {\n        this.extent_ = extent;\n        this.canWrapX_ = !!(this.global_ && extent);\n    };\n    /**\n     * Set the world extent for this projection.\n     * @param {import(\"../extent.js\").Extent} worldExtent World extent\n     *     [minlon, minlat, maxlon, maxlat].\n     * @api\n     */\n    Projection.prototype.setWorldExtent = function (worldExtent) {\n        this.worldExtent_ = worldExtent;\n    };\n    /**\n     * Set the getPointResolution function (see {@link module:ol/proj.getPointResolution}\n     * for this projection.\n     * @param {function(number, import(\"../coordinate.js\").Coordinate):number} func Function\n     * @api\n     */\n    Projection.prototype.setGetPointResolution = function (func) {\n        this.getPointResolutionFunc_ = func;\n    };\n    /**\n     * Get the custom point resolution function for this projection (if set).\n     * @return {function(number, import(\"../coordinate.js\").Coordinate):number|undefined} The custom point\n     * resolution function (if set).\n     */\n    Projection.prototype.getPointResolutionFunc = function () {\n        return this.getPointResolutionFunc_;\n    };\n    return Projection;\n}());\nexport default Projection;\n//# sourceMappingURL=Projection.js.map","/**\n * @module ol/geom/GeometryType\n */\n/**\n * The geometry type. One of `'Point'`, `'LineString'`, `'LinearRing'`,\n * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,\n * `'GeometryCollection'`, `'Circle'`.\n * @enum {string}\n */\nexport default {\n    POINT: 'Point',\n    LINE_STRING: 'LineString',\n    LINEAR_RING: 'LinearRing',\n    POLYGON: 'Polygon',\n    MULTI_POINT: 'MultiPoint',\n    MULTI_LINE_STRING: 'MultiLineString',\n    MULTI_POLYGON: 'MultiPolygon',\n    GEOMETRY_COLLECTION: 'GeometryCollection',\n    CIRCLE: 'Circle',\n};\n//# sourceMappingURL=GeometryType.js.map","/**\n * @module ol/proj/Units\n */\n/**\n * Projection units: `'degrees'`, `'ft'`, `'m'`, `'pixels'`, `'tile-pixels'` or\n * `'us-ft'`.\n * @enum {string}\n */\nvar Units = {\n    /**\n     * Radians\n     * @api\n     */\n    RADIANS: 'radians',\n    /**\n     * Degrees\n     * @api\n     */\n    DEGREES: 'degrees',\n    /**\n     * Feet\n     * @api\n     */\n    FEET: 'ft',\n    /**\n     * Meters\n     * @api\n     */\n    METERS: 'm',\n    /**\n     * Pixels\n     * @api\n     */\n    PIXELS: 'pixels',\n    /**\n     * Tile Pixels\n     * @api\n     */\n    TILE_PIXELS: 'tile-pixels',\n    /**\n     * US Feet\n     * @api\n     */\n    USFEET: 'us-ft',\n};\n/**\n * See http://duff.ess.washington.edu/data/raster/drg/docs/geotiff.txt\n * @type {Object<number, Units>}\n */\nvar unitByCode = {\n    '9001': Units.METERS,\n    '9002': Units.FEET,\n    '9003': Units.USFEET,\n    '9101': Units.RADIANS,\n    '9102': Units.DEGREES,\n};\n/**\n * @param {number} code Unit code.\n * @return {Units} Units.\n */\nexport function fromCode(code) {\n    return unitByCode[code];\n}\n/**\n * Meters per unit lookup table.\n * @const\n * @type {Object<Units, number>}\n * @api\n */\nexport var METERS_PER_UNIT = {};\n// use the radius of the Normal sphere\nMETERS_PER_UNIT[Units.RADIANS] = 6370997 / (2 * Math.PI);\nMETERS_PER_UNIT[Units.DEGREES] = (2 * Math.PI * 6370997) / 360;\nMETERS_PER_UNIT[Units.FEET] = 0.3048;\nMETERS_PER_UNIT[Units.METERS] = 1;\nMETERS_PER_UNIT[Units.USFEET] = 1200 / 3937;\nexport default Units;\n//# sourceMappingURL=Units.js.map"],"sourceRoot":""}
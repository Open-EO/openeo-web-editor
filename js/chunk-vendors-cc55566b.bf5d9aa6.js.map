{"version":3,"file":"js/chunk-vendors-cc55566b.bf5d9aa6.js","mappings":"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","sources":["webpack://@openeo/web-editor/./node_modules/@openeo/js-processgraphs/src/jsonschema.js","webpack://@openeo/web-editor/./node_modules/@openeo/js-processgraphs/src/main.js","webpack://@openeo/web-editor/./node_modules/@openeo/js-processgraphs/src/utils.js","webpack://@openeo/web-editor/./node_modules/@openeo/js-processgraphs/src/processgraph.js","webpack://@openeo/web-editor/./node_modules/@openeo/js-processgraphs/src/error.js","webpack://@openeo/web-editor/./node_modules/@openeo/js-processgraphs/src/registry.js","webpack://@openeo/web-editor/./node_modules/@openeo/js-processgraphs/src/keywords.js","webpack://@openeo/web-editor/./node_modules/@openeo/js-processgraphs/src/process.js","webpack://@openeo/web-editor/./node_modules/@openeo/js-processgraphs/src/errorlist.js","webpack://@openeo/web-editor/./node_modules/@openeo/js-processgraphs/src/node.js"],"sourcesContent":["const Ajv = require('ajv');\nconst Utils = require('./utils');\nconst ProcessUtils = require('@openeo/js-commons/src/processUtils.js');\nconst keywords = require('./keywords');\n\nvar geoJsonSchema = require(\"../assets/GeoJSON.json\");\nvar subtypeSchemas = require(\"../assets/subtype-schemas.json\");\n\n/**\n * JSON Schema Validator.\n * \n * @class\n */\nclass JsonSchemaValidator {\n\n\tconstructor() {\n\t\tthis.ajv = new Ajv({\n\t\t\tschemaId: 'auto',\n\t\t\tformat: 'full',\n\t\t\taddUsedSchema: false\n\t\t});\n\t\t// Add subtype + GeoJSON schemas\n\t\tthis.ajv.addSchema(geoJsonSchema);\n\t\t// Add openEO specific keywords\n\t\tthis.ajv.addKeyword('parameters', Object.assign(keywords.parameters, {\n\t\t\tvalid: true,\n\t\t\terrors: true\n\t\t}));\n\t\tthis.ajv.addKeyword('returns', Object.assign(keywords.returns, {\n\t\t\tvalid: true,\n\t\t\terrors: true\n\t\t}));\n\t\tthis.ajv.addKeyword('subtype', Object.assign(keywords.subtype, {\n\t\t\tvalidate: async (subtype, data, schema) => await this.validateSubtype(subtype, data, schema),\n\t\t\tasync: true,\n\t\t\terrors: true\n\t\t}));\n\n\t\tthis.collections = null;\n\t\tthis.epsgCodes = null;\n\t\tthis.fileFormats = {\n\t\t\tinput: null,\n\t\t\toutput: null\n\t\t};\n\t\tthis.processRegistry = null;\n\t\tthis.udfRuntimes = null;\n\t}\n\n\tgetFunctionName(subtype) {\n\t\t// compute the function name (camelCase), e.g. for `band-name` it will be `validateBandName`\n\t\treturn \"validate\" + subtype.replace(/(^|\\-)(\\w)/g, (a, b, char) => char.toUpperCase());\n\t}\n\n\tmakeSchema(schema, $async = false) {\n\t\tschema = Utils.deepClone(schema);\n\n\t\t// Make array of schemas to a anyOf schema\n\t\tif (Array.isArray(schema)) {\n\t\t\tschema = {\n\t\t\t\tanyOf: schema\n\t\t\t};\n\t\t}\n\n\t\t// Set applicable JSON Schema draft version if not already set\n\t\tif (typeof schema.$schema === 'undefined') {\n\t\t\tschema.$schema = \"http://json-schema.org/draft-07/schema#\";\n\t\t}\n\n\t\t// Set async execution\n\t\tif ($async) {\n\t\t\tschema.$async = true;\n\t\t\tif (Utils.isObject(schema.definitions)) {\n\t\t\t\tfor(let key in schema.definitions) {\n\t\t\t\t\tschema.definitions[key].$async = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn schema;\n\t}\n\n\tasync validateValue(value, schema) {\n\t\tschema = this.makeSchema(schema, true);\n\n\t\ttry {\n\t\t\tawait this.ajv.validate(schema, value);\n\t\t\treturn [];\n\t\t} catch (e) {\n\t\t\tif (Array.isArray(e.errors)) {\n\t\t\t\treturn e.errors.map(e => e.message);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}\n\n\tasync validateSubtype(subtype, data, schema) {\n\t\tif (typeof subtypeSchemas.definitions[subtype] !== 'undefined') {\n\t\t\tschema = this.makeSchema(subtypeSchemas, true);\n\t\t\t// Make the schema for this subtype the default schema to be checked\n\t\t\tschema = Object.assign({}, subtypeSchemas.definitions[subtype], schema);\n\t\t\tif (subtype === 'process-graph') {\n\t\t\t\t// Special case: all validation will be done in validateProcessGraph()\n\t\t\t\tdelete schema.required;\n\t\t\t\tdelete schema.properties;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tschema = this.makeSchema(schema, true);\n\t\t}\n\n\t\t// Remove subtype to avoid recursion\n\t\tdelete schema.subtype;\n\n\t\tlet validated = await this.ajv.validate(schema, data);\n\t\tlet funcName = this.getFunctionName(subtype);\n\t\tif (validated && typeof this[funcName] === 'function') {\n\t\t\treturn await this[funcName](data);\n\t\t}\n\t\telse {\n\t\t\treturn validated;\n\t\t}\n\t}\n\n\tsetUdfRuntimes(udfRuntimes) {\n\t\tif (!Utils.isObject(udfRuntimes)) {\n\t\t\treturn;\n\t\t}\n\t\tthis.udfRuntimes = udfRuntimes;\n\t}\n\n\tsetCollections(collections) {\n\t\tif (!Array.isArray(collections)) {\n\t\t\treturn;\n\t\t}\n\t\tthis.collections = [];\n\t\tfor(let c of collections) {\n\t\t\tif (Utils.isObject(c) && typeof c.id === 'string') {\n\t\t\t\tthis.collections.push(c.id);\n\t\t\t}\n\t\t\telse if (typeof c === 'string') {\n\t\t\t\tthis.collections.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Expects API compatible file formats (see GET /file_formats).\n\tsetFileFormats(fileFormats) {\n\t\tif (!Utils.isObject(fileFormats)) {\n\t\t\treturn;\n\t\t}\n\t\tfor(let io of ['input', 'output']) {\n\t\t\tthis.fileFormats[io] = {};\n\t\t\tif (!Utils.isObject(fileFormats[io])) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (let key in fileFormats[io]) {\n\t\t\t\tthis.fileFormats[io][key.toUpperCase()] = fileFormats[io][key];\n\t\t\t}\n\t\t}\n\t}\n\n\tsetEpsgCodes(epsgCodes) {\n\t\tif (Array.isArray(epsgCodes)) {\n\t\t\tthis.epsgCodes = epsgCodes.map(v => parseInt(v, 10));\n\t\t}\n\t}\n\n\tasync validateCollectionId(data) {\n\t\tif (Array.isArray(this.collections) && !this.collections.find(c => c === data)) {\n\t\t\tthrow new Ajv.ValidationError([{\n\t\t\t\tmessage: \"Collection with id '\" + data + \"' doesn't exist.\"\n\t\t\t}]);\n\t\t}\n\t\treturn true;\n\t}\n\n\tasync validateUdfRuntime(data) {\n\t\tif (Utils.isObject(this.udfRuntimes) && !(data in this.udfRuntimes)) {\n\t\t\tthrow new Ajv.ValidationError([{\n\t\t\t\tmessage: \"UDF runtime '\" + data + \"' is not supported.\"\n\t\t\t}]);\n\t\t}\n\t\treturn true;\n\t}\n\n\tasync validateEpsgCode(data) {\n\t\tif (Array.isArray(this.epsgCodes)) {\n\t\t\tif (this.epsgCodes.includes(data)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t// Rough check for valid numbers as we don't want to maintain a full epsg code list in this repo.\n\t\telse if (data >= 2000) {\n\t\t\treturn true;\n\t\t}\n\n\t\tthrow new Ajv.ValidationError([{\n\t\t\tmessage: \"Invalid EPSG code '\" + data + \"' specified.\"\n\t\t}]);\n\t}\n\t\n\tasync validateInputFormat(data) {\n\t\tif (Utils.isObject(this.fileFormats.input) && !(data.toUpperCase() in this.fileFormats.input)) {\n\t\t\tthrow new Ajv.ValidationError([{\n\t\t\t\tmessage: \"Input format  '\" + data + \"' not supported.\"\n\t\t\t}]);\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tasync validateOutputFormat(data) {\n\t\tif (Utils.isObject(this.fileFormats.output) && !(data.toUpperCase() in this.fileFormats.output)) {\n\t\t\tthrow new Ajv.ValidationError([{\n\t\t\t\tmessage: \"Output format  '\" + data + \"' not supported.\"\n\t\t\t}]);\n\t\t}\n\t\treturn true;\n\t}\n\n\tasync validateProjDefinition(data) {\n\t\t// To be overridden by end-user application, just doing a very basic check here.\n\t\tif (!data.toLowerCase().includes(\"+proj\")) {\n\t\t\tthrow new Ajv.ValidationError([{\n\t\t\t\tmessage: \"Invalid PROJ string specified (doesn't contain '+proj').\"\n\t\t\t}]);\n\t\t}\n\t\treturn true;\n\t}\n\n\tasync validateWkt2Definition(data) {\n\t\t// To be overridden by end-user application, just doing a very basic check here based on code ported over from proj4js\n\t\tvar codeWords = [\n\t\t\t'BOUNDCRS',\n\t\t\t'COMPOUNDCRS',\n\t\t\t'ENGCRS', 'ENGINEERINGCRS',\n\t\t\t'GEODCRS', 'GEODETICCRS',\n\t\t\t'GEOGCRS', 'GEOGRAPHICCRS',\n\t\t\t'PARAMETRICCRS',\n\t\t\t'PROJCRS', 'PROJECTEDCRS',\n\t\t\t'TIMECRS',\n\t\t\t'VERTCRS', 'VERTICALCRS'\n\t\t];\n\t\tdata = data.toUpperCase();\n\t\tif (!codeWords.some(word => data.indexOf(word) !== -1)) {\n\t\t\tthrow new Ajv.ValidationError([{\n\t\t\t\tmessage: \"Invalid WKT2 string specified.\"\n\t\t\t}]);\n\t\t}\n\t\treturn true;\n\t}\n\n\tasync validateTemporalInterval(data) {\n\t\tif (data[0] === null && data[1] === null) {\n\t\t\tthrow new Ajv.ValidationError([{\n\t\t\t\tmessage: \"Temporal interval must not be open on both ends.\"\n\t\t\t}]);\n\t\t}\n\t\telse if (data[0] !== null && data[1] !== null) {\n\t\t\tlet date1 = new Date(data[0]);\n\t\t\tlet date2 = new Date(data[1]);\n\t\t\tif (date2.getTime() < date1.getTime()) {\n\t\t\t\tthrow new Ajv.ValidationError([{\n\t\t\t\t\tmessage: \"The second timestamp can't be before the first timestamp.\"\n\t\t\t\t}]);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tasync validateTemporalIntervals(data) {\n\t\tfor(let interval of data) {\n\t\t\t// throws if invalid\n\t\t\tawait this.validateTemporalInterval(interval);\n\t\t}\n\t\treturn true;\n\t}\n\n\tsetProcessGraphParser(processGraph) {\n\t\tthis.processGraph = processGraph;\n\t}\n\n\tasync validateProcessGraph(data) {\n\t\ttry {\n\t\t\tconst ProcessGraph = require('./processgraph');\n\t\t\tvar parser;\n\t\t\tif (data instanceof ProcessGraph) {\n\t\t\t\tparser = data;\n\t\t\t}\n\t\t\telse if (this.processGraph) {\n\t\t\t\tparser = this.processGraph.createProcessGraphInstance(data);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tparser = new ProcessGraph(data, null, this);\n\t\t\t}\n\t\t\tawait parser.validate();\n\t\t\treturn true;\n\t\t} catch (error) {\n\t\t\tthrow new Ajv.ValidationError([{\n\t\t\t\tmessage: error.message\n\t\t\t}]);\n\t\t}\n\t}\n\n\t// Checks whether the valueSchema is compatible to the paramSchema.\n\t// So would a value compatible with valueSchema be accepted by paramSchema?\n\t// allowValueAsElements: If true, it checks whether the valueSchema would be allowed as part of an array or object. For example number could be allowed as part of an array of numbers.\n\tstatic isSchemaCompatible(paramSchema, valueSchema, strict = false, allowValueAsElements = false) {\n\t\tvar paramSchemas = ProcessUtils.normalizeJsonSchema(paramSchema, true);\n\t\tvar valueSchemas = ProcessUtils.normalizeJsonSchema(valueSchema, true);\n\n\t\tvar compatible = paramSchemas.findIndex(ps => {\n\t\t\tfor(var i in valueSchemas) {\n\t\t\t\tvar vs = valueSchemas[i];\n\t\t\t\tif (typeof ps.type !== 'string' || (!strict && typeof vs.type !== 'string')) { // \"any\" type is always compatible\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse if (\n\t\t\t\t\tps.type === vs.type ||\n\t\t\t\t\t(allowValueAsElements && (ps.type === 'array' || ps.type === 'object')) ||\n\t\t\t\t\t(ps.type === 'number' && vs.type === 'integer') ||\n\t\t\t\t\t(!strict && ps.type === 'integer' && vs.type === 'number')\n\t\t\t\t) {\n\t\t\t\t\tif (ps.type === 'array' && Utils.isObject(ps.items))  {\n\t\t\t\t\t\tconst checkArray = (schema) => { // jshint ignore:line\n\t\t\t\t\t\t\tif (allowValueAsElements && JsonSchemaValidator.isSchemaCompatible(schema, vs, strict)) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (Utils.isObject(vs.items) && JsonSchemaValidator.isSchemaCompatible(schema, vs.items, strict)) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t};\n\t\t\t\t\t\tif (Array.isArray(ps.items.anyOf) || Array.isArray(ps.items.oneOf)) {\n\t\t\t\t\t\t\treturn (ps.items.anyOf || ps.items.oneOf).some(checkArray);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn checkArray(ps.items);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (ps.type === 'object') {\n\t\t\t\t\t\tif (ps.subtype === vs.subtype) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (ps.subtype === 'datacube' || vs.subtype === 'datacube') {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// ToDo: Check properties, required properties etc.\n\t\t\t\t\t\t// If allowValueAsElements is true, all types are allowed to be part of the object.\n\t\t\t\t\t\telse if (Utils.isObject(ps.properties) && Utils.isObject(vs.properties)) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Check subtypes\n\t\t\t\t\telse if (!strict && (typeof ps.subtype !== 'string' || typeof vs.subtype !== 'string')) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse if (typeof ps.subtype !== 'string') { // types without subtype always accepts the same type with a subtype\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse if (ps.subtype === vs.subtype) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t});\n\n\t\treturn compatible !== -1;\n\t}\n\n}\n\nmodule.exports = JsonSchemaValidator;","const BaseProcess = require('./process');\nconst ErrorList = require('./errorlist');\nconst JsonSchemaValidator = require('./jsonschema');\nconst ProcessGraph = require('./processgraph');\nconst ProcessGraphError = require('./error');\nconst ProcessGraphNode = require('./node');\nconst ProcessRegistry = require('./registry');\nconst Utils = require('./utils');\n\nmodule.exports = {\n\tBaseProcess,\n\tErrorList,\n\tJsonSchemaValidator,\n\tProcessGraph,\n\tProcessGraphError,\n\tProcessGraphNode,\n\tProcessRegistry,\n\tUtils\n};","const CommonUtils = require('@openeo/js-commons/src/utils.js');\n\n/**\n * Utilities\n * \n * @class\n */\nclass Utils extends CommonUtils {\n\n\t/**\n\t * Checks whether a value contains references (from_parameter, from_node).\n\t * \n\t * Doesn't return references from ProcessGraph objects if checkCallbacks is set to true.\n\t * \n\t * @param {*} value \n\t * @param {boolean} checkProcess - Set to `false` to not check for refs in a process if provided as value.\n\t * @param {boolean} checkCallbacks - Set to `true` to also check for refs in callbacks. Only applies if `checkProcess` is true.\n\t * @returns {boolean}\n\t */\n\tstatic containsRef(value, checkProcess = true, checkCallbacks = false) {\n\t\tlet type = Utils.getType(value);\n\t\tswitch(type) {\n\t\t\tcase 'result':\n\t\t\tcase 'parameter':\n\t\t\t\treturn true;\n\t\t\tcase 'callback':\n\t\t\t\tif (checkProcess && Utils.containsRef(value.process_graph, checkCallbacks, checkCallbacks)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'array':\n\t\t\tcase 'object':\n\t\t\t\tfor(let key in value) {\n\t\t\t\t\tif (Utils.containsRef(value[key], checkProcess, checkCallbacks)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Returns all distinct references (from_parameter, from_node) contained in a value.\n\t * \n\t * Doesn't return references from ProcessGraph objects if checkCallbacks is set to true.\n\t * \n\t * @param {*} value \n\t * @param {boolean} getFromProcess - Set to `false` to not get refs from a process if provided as value.\n\t * @param {boolean} getFromCallbacks - Set to `true` to also include refs in callbacks. Only applies if `getFromProcess` is true.\n\t * @returns {boolean}\n\t */\n\tstatic getRefs(value, getFromProcess = true, getFromCallbacks = false) {\n\t\tvar store = [];\n\t\tvar type = Utils.getType(value);\n\t\tswitch(type) {\n\t\t\tcase 'result':\n\t\t\tcase 'parameter':\n\t\t\t\tstore.push(value);\n\t\t\t\tbreak;\n\t\t\tcase 'callback':\n\t\t\t\tif (getFromProcess) {\n\t\t\t\t\tstore = store.concat(Utils.getRefs(value.process_graph, getFromCallbacks, getFromCallbacks));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'array':\n\t\t\tcase 'object':\n\t\t\t\tfor(var key in value) {\n\t\t\t\t\tstore = store.concat(Utils.getRefs(value[key], getFromProcess, getFromCallbacks));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\treturn Utils.unique(store, true);\n\t}\n\n\t/**\n\t * Returns the type of the value.\n\t * \n\t * Similar to typeof, but gives more details for objects (array, parameter, callback, result, null, object).\n\t * \n\t * @param {*} value \n\t * @returns {string}\n\t */\n\tstatic getType(value) {\n\t\tconst ProcessGraph = require('./processgraph');\n\t\tif (typeof value === 'object') {\n\t\t\tif (value === null) {\n\t\t\t\treturn 'null';\n\t\t\t}\n\t\t\telse if (Array.isArray(value)) {\n\t\t\t\treturn 'array';\n\t\t\t}\n\t\t\telse if(value.hasOwnProperty(\"process_graph\") || value instanceof ProcessGraph) {\n\t\t\t\treturn 'callback';\n\t\t\t}\n\t\t\telse if(value.hasOwnProperty(\"from_node\")) {\n\t\t\t\treturn 'result';\n\t\t\t}\n\t\t\telse if(value.hasOwnProperty(\"from_parameter\")) {\n\t\t\t\treturn 'parameter';\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn 'object';\n\t\t\t}\n\t\t}\n\t\treturn (typeof value);\n\t}\n\n}\n\nmodule.exports = Utils;","const BaseProcess = require('./process');\nconst ErrorList = require('./errorlist');\nconst JsonSchemaValidator = require('./jsonschema');\nconst ProcessGraphError = require('./error');\nconst ProcessGraphNode = require('./node');\nconst Utils = require('./utils');\nconst ProcessUtils = require('@openeo/js-commons/src/processUtils.js');\n\nconst processKeys = [\n\t'id',\n\t'summary',\n\t'description',\n\t'categories',\n\t'parameters',\n\t'returns',\n\t'deprecated',\n\t'experimental',\n\t'exceptions',\n\t'examples',\n\t'links',\n\t'process_graph'\n];\n\n/**\n * Process parser, validator and executor.\n * \n * @class\n */\nclass ProcessGraph {\n\n\t// ToDo: Also parse and validate other parts of the process, e.g. id, parameters, etc.\n\n\tconstructor(process, processRegistry = null, jsonSchemaValidator = null) {\n\t\tthis.process = process;\n\t\tthis.nodes = {};\n\t\tthis.startNodes = [];\n\t\tthis.resultNode = null;\n\t\tthis.children = [];\n\t\tthis.parentNode = null;\n\t\tthis.parsed = false;\n\t\tthis.validated = false;\n\t\tthis.errors = new ErrorList();\n\t\tthis.callbackParameters = [];\n\t\t// Sub process graphs need to copy these:\n\t\tthis.processRegistry = processRegistry;\n\t\tthis.jsonSchemaValidator = jsonSchemaValidator;\n\t\tthis.arguments = {};\n\t\tthis.allowEmptyGraph = false;\n\t\tthis.fillProcessParameters = false;\n\t\tthis.allowUndefinedParameterRefs = true;\n\t}\n\n\ttoJSON() {\n\t\treturn this.process;\n\t}\n\n\tgetJsonSchemaValidator() {\n\t\tif (this.jsonSchemaValidator === null) {\n\t\t\tthis.jsonSchemaValidator = this.createJsonSchemaValidatorInstance();\n\t\t}\n\t\tthis.jsonSchemaValidator.setProcessGraphParser(this);\n\t\treturn this.jsonSchemaValidator;\n\t}\n\n\tcreateJsonSchemaValidatorInstance() {\n\t\treturn new JsonSchemaValidator();\n\t}\n\n\tcreateNodeInstance(nodeObj, id, parent) {\n\t\treturn new ProcessGraphNode(nodeObj, id, parent);\n\t}\n\n\tcreateProcessGraphInstance(process) {\n\t\tlet pg = new ProcessGraph(process, this.processRegistry, this.getJsonSchemaValidator());\n\t\treturn this.copyProcessGraphInstanceProperties(pg);\n\t}\n\n\tcreateProcessInstance(process) {\n\t\treturn new BaseProcess(process);\n\t}\n\n\tcopyProcessGraphInstanceProperties(pg) {\n\t\tpg.allowEmptyGraph = this.allowEmptyGraph;\n\t\tpg.fillProcessParameters = this.fillProcessParameters;\n\t\tpg.allowUndefinedParameterRefs = this.allowUndefinedParameterRefs;\n\t\treturn pg;\n\t}\n\n\tcreateChildProcessGraph(process, node, parameterPath = []) {\n\t\tvar pg = this.createProcessGraphInstance(process);\n\t\tpg.setArguments(this.arguments);\n\t\tpg.setParentNode(node);\n\t\tif (parameterPath.length > 0) {\n\t\t\tlet parameterName = parameterPath.shift();\n\t\t\tpg.setCallbackParameters(ProcessUtils.getCallbackParametersForProcess(pg.getParentProcess(), parameterName, parameterPath));\n\t\t}\n\t\tpg.parse();\n\t\tthis.children.push(pg);\n\t\treturn pg;\n\t}\n\n\tgetParentNode() {\n\t\treturn this.parentNode;\n\t}\n\n\tgetParent() {\n\t\tif (this.parentNode) {\n\t\t\treturn this.parentNode.getProcessGraph();\n\t\t}\n\t\treturn null;\n\t}\n\n\tsetParentNode(parent) {\n\t\tif (parent instanceof ProcessGraphNode) {\n\t\t\tthis.parentNode = parent;\n\t\t}\n\t\telse {\n\t\t\tthis.parentNode = null;\n\t\t}\n\t}\n\n\tisValid() {\n\t\treturn this.validated && this.errors.count() === 0;\n\t}\n\n\taddError(error) {\n\t\tthis.errors.add(error);\n\t}\n\n\tallowUndefinedParameters(allow = true) {\n\t\tif (!allow) {\n\t\t\tthis.fillProcessParameters = false;\n\t\t}\n\t\tthis.allowUndefinedParameterRefs = allow;\n\t}\n\n\tfillUndefinedParameters(fill = true) {\n\t\tif (fill) {\n\t\t\tthis.allowUndefinedParameterRefs = true;\n\t\t}\n\t\tthis.fillProcessParameters = fill;\n\t}\n\n\tallowEmpty(allow = true) {\n\t\tthis.allowEmptyGraph = allow;\n\t}\n\n\tparse() {\n\t\tif (this.parsed) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst makeError = (errorId) => {\n\t\t\tif (this.getParentProcessId()) {\n\t\t\t\treturn new ProcessGraphError(\n\t\t\t\t\terrorId + 'Callback',\n\t\t\t\t\t{\n\t\t\t\t\t\tprocess_id: this.getParentProcessId(),\n\t\t\t\t\t\tnode_id: this.parentNode ? this.parentNode.id : 'N/A'\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn new ProcessGraphError(errorId);\n\t\t\t}\n\t\t};\n\n\t\tif (!Utils.isObject(this.process)) {\n\t\t\tthrow makeError('ProcessMissing');\n\t\t}\n\n\t\tif (Utils.size(this.process.process_graph) === 0) {\n\t\t\tif (this.allowEmptyGraph) {\n\t\t\t\tlet hasProcessKey = Object.keys(this.process).find(key => processKeys.includes(key));\n\t\t\t\tif (Utils.size(this.process) === 0 || hasProcessKey) {\n\t\t\t\t\tthis.parsed = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow makeError('ProcessGraphMissing');\n\t\t}\n\n\t\tthis.nodes = Utils.mapObjectValues(this.process.process_graph, (pg, id) => this.createNodeInstance(pg, id, this));\n\n\t\tfor(let id in this.nodes) {\n\t\t\tvar node = this.nodes[id];\n\t\t\tif (node.isResultNode) {\n\t\t\t\tif (this.resultNode !== null) {\n\t\t\t\t\tthrow makeError('MultipleResultNodes');\n\t\t\t\t}\n\t\t\t\tthis.resultNode = node;\n\t\t\t}\n\n\t\t\tthis.parseNodeArguments(id, node);\n\t\t}\n\t\tif (this.resultNode === null) {\n\t\t\tthrow makeError('ResultNodeMissing');\n\t\t}\n\n\t\t// Find/Cache start nodes, only possible after parseNodeArguments have been called for all nodes\n\t\t// Sort nodes to ensure a consistent execution order\n\t\tthis.startNodes = Object.values(this.nodes).filter(node => node.isStartNode()).sort((a,b) => a.id.localeCompare(b.id));\n\t\tif (this.startNodes.length === 0) {\n\t\t\tthrow makeError('StartNodeMissing');\n\t\t}\n\n\t\tthis.parsed = true;\n\t}\n\n\tasync validate(throwOnErrors = true) {\n\t\tif (this.validated) {\n\t\t\tif (throwOnErrors && this.errors.count() > 0) {\n\t\t\t\tthrow this.errors.first();\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn this.errors;\n\t\t\t}\n\t\t}\n\n\t\tthis.validated = true;\n\n\t\t// Parse\n\t\ttry {\n\t\t\tthis.parse();\n\t\t} catch (error) {\n\t\t\tthis.addError(error);\n\t\t\tif (throwOnErrors) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\n\t\t// Validate\n\t\tawait this.validateNodes(this.getStartNodes(), throwOnErrors);\n\t\treturn this.errors;\n\t}\n\n\tasync execute(args = null) {\n\t\tthis.allowUndefinedParameters(false);\n\t\tthis.setArguments(args);\n\t\tawait this.validate();\n\t\tthis.reset();\n\t\tawait this.executeNodes(this.getStartNodes());\n\t\treturn this.getResultNode();\n\t}\n\n\tasync validateNodes(nodes, throwOnErrors, previousNode = null) {\n\t\tif (nodes.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar promises = nodes.map(async (node) => {\n\t\t\t// Validate this node after all dependencies are available\n\t\t\tif (!node.solveDependency(previousNode)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Get process and validate\n\t\t\ttry {\n\t\t\t\tawait this.validateNode(node);\n\t\t\t} catch (e) {\n\t\t\t\tif (e instanceof ErrorList) {\n\t\t\t\t\tthis.errors.merge(e);\n\t\t\t\t\tif (throwOnErrors) {\n\t\t\t\t\t\tthrow e.first();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.addError(e);\n\t\t\t\t\tif (throwOnErrors) {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tawait this.validateNodes(node.getNextNodes(), throwOnErrors, node);\n\t\t});\n\n\t\tawait Promise.all(promises);\n\t}\n\n\tasync validateNode(node) {\n\t\tvar process = this.getProcess(node);\n\t\tif (process) {\n\t\t\treturn await process.validate(node);\n\t\t}\n\t}\n\n\tasync executeNodes(nodes, previousNode = null) {\n\t\tif (nodes.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar promises = nodes.map(async (node) => {\n\t\t\t// Execute this node after all dependencies are available\n\t\t\tif (!node.solveDependency(previousNode)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar result = await this.executeNode(node);\n\t\t\tnode.setResult(result);\n\n\t\t\t// Execute next nodes in chain\n\t\t\tawait this.executeNodes(node.getNextNodes(), node);\n\n\t\t});\n\n\t\treturn await Promise.all(promises);\n\t}\n\n\tasync executeNode(node) {\n\t\tvar process = this.getProcess(node);\n\t\treturn await process.execute(node);\n\t}\n\n\tparseNodeArguments(nodeId, node, parameterPath = [], args = undefined) {\n\t\tif (typeof args === 'undefined') {\n\t\t\targs = node.arguments;\n\t\t}\n\t\tfor(let argumentName in args) {\n\t\t\tlet arg = args[argumentName];\n\t\t\t// Make a \"path\" that consists of the parameter name and the keys of arrays/objects, if applicable.\n\t\t\tlet path = parameterPath.concat([argumentName]);\n\t\t\tlet type = Utils.getType(arg);\n\t\t\tswitch(type) {\n\t\t\t\tcase 'result':\n\t\t\t\t\t// Connect the nodes with each other\n\t\t\t\t\tvar prevNode = this.nodes[arg.from_node];\n\t\t\t\t\tif (typeof prevNode === 'undefined') {\n\t\t\t\t\t\tthrow new ProcessGraphError('ReferencedNodeMissing', {node_id: arg.from_node});\n\t\t\t\t\t}\n\t\t\t\t\tnode.addPreviousNode(prevNode);\n\t\t\t\t\tprevNode.addNextNode(node);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'callback':\n\t\t\t\t\t// Create a new process graph for the callback\n\t\t\t\t\targs[argumentName] = this.createChildProcessGraph(arg, node, path);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'parameter':\n\t\t\t\t\t// If we found a parameter and it's not defined yet (includes that it's not a callback parameter) and fillProcessParameters is set to true: Add it to the process spec.\n\t\t\t\t\tif (this.fillProcessParameters && !this.hasParameter(arg.from_parameter)) {\n\t\t\t\t\t\tthis.addProcessParameter(arg.from_parameter);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'array':\n\t\t\t\tcase 'object':\n\t\t\t\t\t// Parse everything hidden in arrays and objects\n\t\t\t\t\tthis.parseNodeArguments(nodeId, node, path, arg);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tsetCallbackParameters(parameters) {\n\t\tthis.callbackParameters = parameters;\n\t}\n\n\tgetCallbackParameter(name) {\n\t\treturn this.getCallbackParameters().find(p => p.name === name) || null;\n\t}\n\n\tgetCallbackParameters() {\t\t\n\t\treturn this.callbackParameters;\n\t}\n\n\taddProcessParameter(name, description = '', schema = {}) {\n\t\tif (!Array.isArray(this.process.parameters)) {\n\t\t\tthis.process.parameters = [];\n\t\t}\n\t\tthis.process.parameters.push({\n\t\t\tname, description, schema\n\t\t});\n\t}\n\n\thasParameterDefault(name) {\n\t\treturn this.getParameterDefault(name) !== undefined;\n\t}\n\n\tgetParameterDefault(name) {\n\t\tlet param = this.getParameter(name);\n\t\tif (param !== null) {\n\t\t\treturn param.default;\n\t\t}\n\t\treturn undefined;\n\t}\n\n\thasParameter(name) {\n\t\treturn this.getParameter(name) !== null;\n\t}\n\n\tgetProcessParameters(includeUndefined = false) {\n\t\tlet parameters = Array.isArray(this.process.parameters) ? this.process.parameters.slice(0) : [];\n\t\tif (includeUndefined && !this.fillProcessParameters) {\n\t\t\tfor (let key in this.nodes) {\n\t\t\t\tlet refs = this.nodes[key].getRefs();\n\t\t\t\tfor(let ref of refs) {\n\t\t\t\t\tif (ref.from_parameter && !parameters.find(other => other.name === ref.from_parameter)) { // jshint ignore:line\n\t\t\t\t\t\tparameters.push({\n\t\t\t\t\t\t\tname: ref.from_parameter,\n\t\t\t\t\t\t\tdescription: '',\n\t\t\t\t\t\t\tschema: {}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn parameters;\n\t}\n\n\tgetProcessParameter(name, includeUndefined = false) {\n\t\treturn this.getProcessParameters(includeUndefined).find(p => p.name === name) || null;\n\t}\n\n\tgetParameter(name) {\n\t\tlet callbackParam = this.getCallbackParameter(name);\n\t\tlet processParam = this.getProcessParameter(name);\n\t\tif (callbackParam && processParam) {\n\t\t\t// ToDo: Take https://github.com/Open-EO/openeo-api/issues/332 into account\n\t\t\treturn Object.assign({}, callbackParam, processParam);\n\t\t}\n\t\telse if (callbackParam) {\n\t\t\treturn callbackParam;\n\t\t}\n\t\telse if (processParam) {\n\t\t\treturn processParam;\n\t\t}\n\t\treturn null;\n\t}\n\n\tsetArguments(args) {\n\t\tif (Utils.isObject(args)) {\n\t\t\tObject.assign(this.arguments, args);\n\t\t}\n\t}\n\n\thasArgument(name) {\n\t\treturn typeof this.arguments[name] !== 'undefined';\n\t}\n\n\tgetArgument(name) {\n\t\treturn this.arguments[name];\n\t}\n\n\treset() {\n\t\tfor(var id in this.nodes) {\n\t\t\tthis.nodes[id].reset();\n\t\t}\n\t\tthis.children.forEach(child => child.reset());\n\t}\n\n\tgetResultNode() {\n\t\treturn this.resultNode;\n\t}\n\n\tgetStartNodes() {\n\t\treturn this.startNodes;\n\t}\n\n\tgetStartNodeIds() {\n\t\treturn this.startNodes.map(node => node.id);\n\t}\n\n\tgetNode(nodeId) {\n\t\treturn nodeId in this.nodes ? this.nodes[nodeId] : null;\n\t}\n\n\tgetNodeCount() {\n\t\treturn Utils.size(this.nodes);\n\t}\n\n\tgetNodes() {\n\t\treturn this.nodes;\n\t}\n\n\tgetErrors() {\n\t\treturn this.errors;\n\t}\n\n\t/**\n\t * Gets the process for the given process ID or node.\n\t * \n\t * @param {ProcessGraphNode|string} process \n\t * @param {?string} [namespace=null]\n\t * @returns {object|null}\n\t * @throws {ProcessGraphError} - ProcessUnsupported\n\t */\n\tgetProcess(process, namespace = null) {\n\t\tif (this.processRegistry === null) {\n\t\t\treturn null;\n\t\t}\n\t\tlet id;\n\t\tif (process instanceof ProcessGraphNode) {\n\t\t\tid = process.process_id;\n\t\t\tnamespace = process.namespace;\n\t\t}\n\t\telse {\n\t\t\tid = process;\n\t\t}\n\t\tlet spec = this.processRegistry.get(id, namespace);\n\t\tif (spec === null) {\n\t\t\tthrow new ProcessGraphError('ProcessUnsupported', {process: id, namespace: namespace || 'n/a'});\n\t\t}\n\t\treturn this.createProcessInstance(spec);\n\t}\n\n\tgetParentProcessId() {\n\t\tif(this.getParentNode()) {\n\t\t\treturn this.getParentNode().process_id;\n\t\t}\n\t\treturn null;\n\t}\n\n\tgetParentProcess() {\n\t\tif (this.processRegistry === null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this.processRegistry.get(this.getParentProcessId());\n\t}\n\n}\n\nmodule.exports = ProcessGraph;","const Utils = require('./utils');\n\nconst MESSAGES = {\n\t\"MultipleResultNodes\": \"Multiple result nodes specified for the process.\",\n\t\"StartNodeMissing\": \"No start nodes found for the process.\",\n\t\"ResultNodeMissing\": \"No result node found for the process.\",\n\t\"ReferencedNodeMissing\": \"Referenced process node '{node_id}' doesn't exist.\",\n\t\"NodeIdInvalid\": \"Invalid node id specified in the process.\",\n\t\"NodeInvalid\": \"Process node '{node_id}' is not a valid object.\",\n\t\"ProcessIdMissing\": \"Process node '{node_id}' doesn't contain a process id.\",\n\t\"ProcessGraphParameterMissing\": \"Invalid parameter '{argument}' referenced in process node '{node_id}' (process: {process_id}, namespace: {namespace}).\",\n\t\"ProcessUnsupported\": \"Process '{process}' (namespace: {namespace}) is not supported.\",\n\t\"ProcessArgumentUnsupported\": \"Process '{process}' (namespace: {namespace}) does not support the following arguments: {arguments}\",\n\t\"ProcessArgumentRequired\": \"Process '{process}' (namespace: {namespace}) requires argument '{argument}'.\",\n\t\"ProcessArgumentInvalid\": \"The argument '{argument}' in process '{process}' (namespace: {namespace}) is invalid: {reason}\",\n\t\"ProcessGraphMissing\": \"No process graph specified\",\n\t\"ProcessMissing\": \"No process specified\"\n};\n\n/**\n * An error class for this library.\n * \n * @class\n */\nclass ProcessGraphError extends Error {\n\n\tconstructor(codeOrMsg, variables = {}) {\n\t\tsuper();\n\t\tthis.variables = variables;\n\t\tif (typeof MESSAGES[codeOrMsg] === 'string') {\n\t\t\tthis.code = codeOrMsg;\n\t\t\tthis.message = Utils.replacePlaceholders(MESSAGES[codeOrMsg], variables);\n\t\t}\n\t\telse {\n\t\t\tthis.code = codeOrMsg.replace(/[^\\w\\d]+/g, '');\n\t\t\tthis.message = codeOrMsg;\n\t\t}\n\t}\n\n\ttoJSON() {\n\t\treturn {\n\t\t\tcode: this.code,\n\t\t\tmessage: this.message\n\t\t};\n\t}\n\n}\n\nmodule.exports = ProcessGraphError;","const CommonProcessRegistry = require('@openeo/js-commons/src/processRegistry');\n\n/**\n * Central registry for processes.\n * \n * Implementation has been moved to @openeo/js-commons.\n * This wrapper here is only available for backward compatibility.\n * \n * @todo Remove in 2.0.0.\n * @augments CommonProcessRegistry\n * @class\n * @deprecated\n */\nclass ProcessRegistry extends CommonProcessRegistry {\n\n}\n\nmodule.exports = ProcessRegistry;","module.exports = {\n\tsubtype: {\n\t\tmetaSchema: {\n\t\t\ttype: \"string\"\n\t\t}\n\t},\n\tparameters: {\n\t\tdependencies: [\n\t\t\t\"subtype\"\n\t\t],\n\t\tmetaSchema: {\n\t\t\ttype: \"array\",\n\t\t\titems: {\n\t\t\t\ttype: \"object\",\n\t\t\t\trequired: [\n\t\t\t\t\t\"name\",\n\t\t\t\t\t\"description\",\n\t\t\t\t\t\"schema\"\n\t\t\t\t],\n\t\t\t\tproperties: {\n\t\t\t\t\tname: {\n\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\tpattern: \"^\\\\w+$\"\n\t\t\t\t\t},\n\t\t\t\t\tdescription: {\n\t\t\t\t\t\ttype: \"string\"\n\t\t\t\t\t},\n\t\t\t\t\toptional: {\n\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\tdefault: false\n\t\t\t\t\t},\n\t\t\t\t\tdeprecated: {\n\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\tdefault: false\n\t\t\t\t\t},\n\t\t\t\t\texperimental: {\n\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\tdefault: false\n\t\t\t\t\t},\n\t\t\t\t\tdefault: {\n\t\t\t\t\t\t// Any type\n\t\t\t\t\t},\n\t\t\t\t\tschema: {\n\t\t\t\t\t\toneOf: [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"$ref\": \"http://json-schema.org/draft-07/schema\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\t\titems: {\n\t\t\t\t\t\t\t\t\t\"$ref\": \"http://json-schema.org/draft-07/schema\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\treturns: {\n\t\tdependencies: [\n\t\t\t\"subtype\"\n\t\t],\n\t\tmetaSchema: {\n\t\t\ttype: \"object\",\n\t\t\trequired: [\n\t\t\t\t\"schema\"\n\t\t\t],\n\t\t\tproperties: {\n\t\t\t\tdescription: {\n\t\t\t\t\ttype: \"string\"\n\t\t\t\t},\n\t\t\t\tschema: {\n\t\t\t\t\toneOf: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"$ref\": \"http://json-schema.org/draft-07/schema\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\titems: {\n\t\t\t\t\t\t\t\t\"$ref\": \"http://json-schema.org/draft-07/schema\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};","const JsonSchemaValidator = require('./jsonschema');\nconst ProcessGraphError = require('./error');\nconst ProcessUtils = require('@openeo/js-commons/src/processUtils');\nconst Utils = require('./utils');\n\n/**\n * Base Process class\n * \n * @class\n */\nclass BaseProcess {\n\n\tconstructor(spec) {\n\t\t// Make properties easily accessible \n\t\tObject.assign(this, spec);\n\n\t\tif (typeof this.id !== 'string') {\n\t\t\tthrow new Error(\"Invalid process specified, no id given.\");\n\t\t}\n\t\tif (!Array.isArray(this.parameters)) {\n\t\t\tthis.parameters = [];\n\t\t}\n\t}\n\n\ttoJSON() {\n\t\treturn Utils.omitFromObject(this, [\"validate\", \"validateArgument\", \"execute\", \"test\"]);\n\t}\n\n\tasync validate(node) {\n\t\t// Check for arguments we don't support and throw error\n\t\tlet unsupportedArgs = node.getArgumentNames().filter(name => this.parameters.findIndex(p => p.name === name) === -1);\n\t\tif (unsupportedArgs.length > 0) {\n\t\t\tthrow new ProcessGraphError('ProcessArgumentUnsupported', {\n\t\t\t\tprocess: this.id,\n\t\t\t\tnamespace: this.namespace || 'n/a',\n\t\t\t\targuments: unsupportedArgs\n\t\t\t});\n\t\t}\n\n\t\t// Validate against JSON Schema\n\t\tfor(let key in this.parameters) {\n\t\t\tlet param = this.parameters[key];\n\n\t\t\tif (!node.hasArgument(param.name)) {\n\t\t\t\tif (!param.optional) {\n\t\t\t\t\tthrow new ProcessGraphError('ProcessArgumentRequired', {\n\t\t\t\t\t\tprocess: this.id,\n\t\t\t\t\t\tnamespace: this.namespace || 'n/a',\n\t\t\t\t\t\targument: param.name\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet arg = node.getParsedArgument(param.name);\n\t\t\tlet rawArg = node.getRawArgument(param.name);\n\t\t\tawait this.validateArgument(arg, rawArg, node, param);\n\t\t}\n\t}\n\n\tasync validateArgument(arg, rawArg, node, param, path = null) {\n\t\tif (!path) {\n\t\t\tpath = param.name;\n\t\t}\n\t\tlet argType = Utils.getType(arg);\n\t\tlet pg = node.getProcessGraph();\n\t\tswitch(argType) {\n\t\t\tcase 'parameter':\n\t\t\t\t// Validate callback parameters (no value available yet)\n\t\t\t\tlet callbackParam = pg.getCallbackParameter(arg.from_parameter);\n\t\t\t\tif (callbackParam) {\n\t\t\t\t\tif (!JsonSchemaValidator.isSchemaCompatible(param.schema, callbackParam.schema)) {\n\t\t\t\t\t\tthrow new ProcessGraphError('ProcessArgumentInvalid', {\n\t\t\t\t\t\t\tprocess: this.id,\n\t\t\t\t\t\t\tnamespace: this.namespace || 'n/a',\n\t\t\t\t\t\t\targument: path,\n\t\t\t\t\t\t\treason: \"Schema for parameter '\" + arg.from_parameter + \"' not compatible with reference\"\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Validate all other parameters\n\t\t\t\tlet value = node.getProcessGraphParameterValue(arg.from_parameter);\n\t\t\t\tlet parameter = pg.getProcessParameter(arg.from_parameter);\n\t\t\t\tif (Utils.isObject(parameter) && parameter.schema) {\n\t\t\t\t\tif (typeof value !== 'undefined') {\n\t\t\t\t\t\tawait this.validateArgument(value, rawArg, node, parameter, path);\n\t\t\t\t\t}\n\t\t\t\t\tif (!JsonSchemaValidator.isSchemaCompatible(param.schema, parameter.schema)) {\n\t\t\t\t\t\tthrow new ProcessGraphError('ProcessArgumentInvalid', {\n\t\t\t\t\t\t\tprocess: this.id,\n\t\t\t\t\t\t\tnamespace: this.namespace || 'n/a',\n\t\t\t\t\t\t\targument: path,\n\t\t\t\t\t\t\treason: \"Schema for parameter '\" + arg.from_parameter + \"' not compatible\"\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// else: Parameter not available, everything is valid\n\t\t\t\tbreak;\n\t\t\tcase 'result':\n\t\t\t\tlet resultNode = pg.getNode(arg.from_node);\n\t\t\t\tlet process = pg.getProcess(resultNode);\n\t\t\t\tif (!JsonSchemaValidator.isSchemaCompatible(param.schema, process.returns.schema)) {\n\t\t\t\t\tthrow new ProcessGraphError('ProcessArgumentInvalid', {\n\t\t\t\t\t\tprocess: this.id,\n\t\t\t\t\t\tnamespace: this.namespace || 'n/a',\n\t\t\t\t\t\targument: path,\n\t\t\t\t\t\treason: \"Schema for result '\" + arg.from_node + \"' not compatible\"\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'array':\n\t\t\tcase 'object':\n\t\t\t\tlet schemas = ProcessUtils.normalizeJsonSchema(param.schema).filter(schema => ['array', 'object'].includes(schema.type));\n\t\t\t\t// Check if it is expected to be a process. If yes, do normal validation. Handles the issue discussed in https://github.com/Open-EO/openeo-js-processgraphs/issues/4\n\t\t\t\tlet isProcessGraphSchema = (schemas.length === 1 && schemas[0].subtype === 'process-graph');\n\t\t\t\tif (Utils.containsRef(rawArg) && !isProcessGraphSchema) {\n\t\t\t\t\t// This tries to at least be compliant to one of the element schemas\n\t\t\t\t\t// It's better than validating nothing, but it's still not 100% correct\n\t\t\t\t\tfor(var key in arg) {\n\t\t\t\t\t\tlet elementSchema = schemas.map(schema =>  ProcessUtils.getElementJsonSchema(schema, key)).filter(schema => Object.keys(schema).length); // jshint ignore:line\n\t\t\t\t\t\tif (elementSchema.length > 0) {\n\t\t\t\t\t\t\tlet validated = 0;\n\t\t\t\t\t\t\tlet lastError = null;\n\t\t\t\t\t\t\tfor(let schema of elementSchema) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t// ToDo: Check against JSON schema required property\n\t\t\t\t\t\t\t\t\tawait this.validateArgument(arg[key], rawArg[key], node, {schema}, path + '/' + key);\n\t\t\t\t\t\t\t\t\tvalidated++;\n\t\t\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\t\t\tlastError = error;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (validated === 0 && lastError) {\n\t\t\t\t\t\t\t\tthrow lastError;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Use default behavior below, so no break; needed\n\t\t\t\t} // jshint ignore:line\n\t\t\tdefault:\n\t\t\t\tlet validator = node.getProcessGraph().getJsonSchemaValidator();\n\t\t\t\t// Validate against JSON schema\n\t\t\t\tlet errors = await validator.validateValue(arg, param.schema);\n\t\t\t\tif (errors.length > 0) {\n\t\t\t\t\tthrow new ProcessGraphError('ProcessArgumentInvalid', {\n\t\t\t\t\t\tprocess: this.id,\n\t\t\t\t\t\tnamespace: this.namespace || 'n/a',\n\t\t\t\t\t\targument: path,\n\t\t\t\t\t\treason: errors\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t}\n\t}\n\n\t/* istanbul ignore next */\n\tasync execute(/*node*/) {\n\t\tthrow new Error(`execute not implemented yet for process '${this.id}' (namespace: ${this.namespace || 'n/a'})`);\n\t}\n\n\t/* istanbul ignore next */\n\ttest() {\n\t\t// Run the tests from the examples\n\t\tthrow new Error(`test not implemented yet for process '${this.id}' (namespace: ${this.namespace || 'n/a'})`);\n\t}\n\n}\n\nmodule.exports =  BaseProcess;","/**\n * A list of errors.\n * \n * @class\n */\nclass ErrorList {\n\n\tconstructor() {\n\t\tthis.errors = [];\n\t}\n\n\tfirst() {\n\t\treturn this.errors[0] || null;\n\t}\n\n\tlast() {\n\t\treturn this.errors[this.errors.length-1] || null;\n\t}\n\n\tmerge(errorList) {\n\t\tthis.errors = this.errors.concat(errorList.getAll());\n\t}\n\t\n\tadd(error) {\n\t\tthis.errors.push(error);\n\t}\n\n\tcount() {\n\t\treturn this.errors.length;\n\t}\n\n\ttoJSON() {\n\t\treturn this.errors.map(e => {\n\t\t\tif (typeof e.toJSON === 'function') {\n\t\t\t\treturn e.toJSON();\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn {\n\t\t\t\t\tcode: 'InternalError',\n\t\t\t\t\tmessage: e.message\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\t}\n\n\tgetMessage() {\n\t\tvar msg = '';\n\t\tfor (var i in this.errors) {\n\t\t\tmsg += (parseInt(i, 10)+1) + \". \" + this.errors[i].message + \"\\r\\n\";\n\t\t}\n\t\treturn msg.trim();\n\t}\n\n\tgetAll() {\n\t\treturn this.errors;\n\t}\n\n}\n\nmodule.exports = ErrorList;","const ProcessGraphError = require('./error');\nconst Utils = require('./utils');\n\n/**\n * A Process graph node.\n * \n * @class\n */\nclass ProcessGraphNode {\n\n\tconstructor(node, id, parent = null) {\n\t\tif (typeof id !== 'string' || id.length === 0) {\n\t\t\tthrow new ProcessGraphError('NodeIdInvalid');\n\t\t}\n\t\tif (!Utils.isObject(node)) {\n\t\t\tthrow new ProcessGraphError('NodeInvalid', {node_id: id});\n\t\t}\n\t\tif (typeof node.process_id !== 'string') {\n\t\t\tthrow new ProcessGraphError('ProcessIdMissing', {node_id: id});\n\t\t}\n\n\t\tthis.id = id;\n\t\tthis.processGraph = parent;\n\t\tthis.source = node;\n\t\tthis.process_id = node.process_id;\n\t\tthis.namespace = node.namespace || null;\n\t\tthis.arguments = Utils.isObject(node.arguments) ? Utils.deepClone(node.arguments) : {};\n\t\tthis.description = node.description || null;\n\t\tthis.isResultNode = node.result || false;\n\t\tthis.expectsFrom = []; // From which node do we expect results from\n\t\tthis.receivedFrom = []; // From which node have received results from so far\n\t\tthis.passesTo = [];\n\t\tthis.computedResult = undefined;\n\t}\n\n\ttoJSON() {\n\t\tlet args = Utils.mapObjectValues(this.arguments, arg => Utils.isObject(arg) && typeof arg.toJSON === 'function' ? arg.toJSON() : arg);\n\t\treturn Object.assign({}, this.source, {\n\t\t\tprocess_id: this.process_id,\n\t\t\tnamespace: this.namespace,\n\t\t\tdescription: this.description,\n\t\t\targuments: args,\n\t\t\tresult: this.isResultNode\n\t\t});\n\t}\n\n\tgetProcessGraph() {\n\t\treturn this.processGraph;\n\t}\n\n\tgetParent() {\n\t\tif (this.processGraph !== null) {\n\t\t\treturn this.processGraph.getParentNode();\n\t\t}\n\t\treturn null;\n\t}\n\n\tgetArgumentNames() {\n\t\treturn Object.keys(this.arguments);\n\t}\n\n\thasArgument(name) {\n\t\treturn typeof this.arguments[name] !== 'undefined';\n\t}\n\n\tgetArgumentType(name) {\n\t\treturn Utils.getType(this.getRawArgument(name));\n\t}\n\n\tgetRawArgument(name) {\n\t\treturn Utils.isObject(this.source.arguments) ? this.source.arguments[name] : undefined;\n\t}\n\n\tgetParsedArgument(name) {\n\t\treturn this.arguments[name];\n\t}\n\n\tgetArgument(name, defaultValue = undefined) {\n\t\tif (typeof this.arguments[name] === 'undefined') {\n\t\t\treturn defaultValue;\n\t\t}\n\t\treturn this.evaluateArgument(this.arguments[name]);\n\t}\n\n\tgetArgumentRefs(name) {\n\t\treturn Utils.getRefs(this.getRawArgument(name), false);\n\t}\n\n\tgetRefs() {\n\t\treturn Utils.getRefs(this.source.arguments, false);\n\t}\n\n\tgetProcessGraphParameterValue(name) {\n\t\t// 1. Check local parameter, then check parents\n\t\t// 2. Check parents\n\t\t// 3. Try to get default value\n\t\t// 4. Fail if no value is available\n\t\tlet defaultValue;\n\t\tlet pg = this.processGraph;\n\t\tdo {\n\t\t\tif (pg.hasArgument(name)) {\n\t\t\t\treturn pg.getArgument(name);\n\t\t\t}\n\t\t\tif (pg.hasParameterDefault(name)) {\n\t\t\t\tdefaultValue = pg.getParameterDefault(name);\n\t\t\t}\n\t\t\tpg = pg.getParent();\n\t\t} while (pg !== null);\n\n\t\tif (typeof defaultValue !== 'undefined') {\n\t\t\treturn defaultValue;\n\t\t}\n\n\t\tif (!this.processGraph.allowUndefinedParameterRefs) {\n\t\t\tthrow new ProcessGraphError('ProcessGraphParameterMissing', {\n\t\t\t\targument: name,\n\t\t\t\tnode_id: this.id,\n\t\t\t\tprocess_id: this.process_id,\n\t\t\t\tnamespace: this.namespace || 'n/a'\n\t\t\t});\n\t\t}\n\t}\n\n\tevaluateArgument(arg) {\n\t\tvar type = Utils.getType(arg);\n\t\tswitch(type) {\n\t\t\tcase 'result':\n\t\t\t\treturn this.processGraph.getNode(arg.from_node).getResult();\n\t\t\tcase 'callback':\n\t\t\t\treturn arg;\n\t\t\tcase 'parameter':\n\t\t\t\treturn this.getProcessGraphParameterValue(arg.from_parameter);\n\t\t\tcase 'array':\n\t\t\tcase 'object':\n\t\t\t\tlet copy = type === 'array' ? [] : {};\n\t\t\t\tfor(var i in arg) {\n\t\t\t\t\tcopy[i] = this.evaluateArgument(arg[i]);\n\t\t\t\t}\n\t\t\t\treturn copy;\n\t\t\tdefault:\n\t\t\t\treturn arg;\n\t\t}\n\t}\n\n\tisStartNode() {\n\t\treturn (this.expectsFrom.length === 0);\n\t}\n\n\taddPreviousNode(node) {\n\t\tif (!this.expectsFrom.find(other => other.id === node.id)) {\n\t\t\tthis.expectsFrom.push(node);\n\t\t}\n\t}\n\n\tgetPreviousNodes() {\n\t\t// Sort nodes to ensure a consistent execution order\n\t\treturn this.expectsFrom.sort((a,b) => a.id.localeCompare(b.id));\n\t}\n\n\taddNextNode(node) {\n\t\tif (!this.passesTo.find(other => other.id === node.id)) {\n\t\t\tthis.passesTo.push(node);\n\t\t}\n\t}\n\n\tgetNextNodes() {\n\t\t// Sort nodes to ensure a consistent execution order\n\t\treturn this.passesTo.sort((a,b) => a.id.localeCompare(b.id));\n\t}\n\n\treset() {\n\t\tthis.computedResult = undefined;\n\t\tthis.receivedFrom = [];\n\t}\n\n\tgetDescription() {\n\t\treturn this.description;\n\t}\n\n\tsetDescription(description) {\n\t\tif (typeof description === 'string') {\n\t\t\tthis.description = description;\n\t\t}\n\t\telse {\n\t\t\tthis.description = null;\n\t\t}\n\t}\n\n\tsetResult(result) {\n\t\tthis.computedResult = result;\n\t}\n\n\tgetResult() {\n\t\treturn this.computedResult;\n\t}\n\n\tsolveDependency(dependencyNode) {\n\t\tif (dependencyNode !== null && this.expectsFrom.includes(dependencyNode)) {\n\t\t\tthis.receivedFrom.push(dependencyNode);\n\t\t}\n\t\treturn (this.expectsFrom.length === this.receivedFrom.length); // all dependencies solved?\n\t}\n\n}\n\nmodule.exports = ProcessGraphNode;"],"names":["Ajv","Utils","ProcessUtils","keywords","geoJsonSchema","subtypeSchemas","JsonSchemaValidator","constructor","this","ajv","schemaId","format","addUsedSchema","addSchema","addKeyword","Object","assign","parameters","valid","errors","returns","subtype","validate","async","data","schema","validateSubtype","collections","epsgCodes","fileFormats","input","output","processRegistry","udfRuntimes","getFunctionName","replace","a","b","char","toUpperCase","makeSchema","$async","deepClone","Array","isArray","anyOf","$schema","isObject","definitions","key","validateValue","value","e","map","message","required","properties","validated","funcName","setUdfRuntimes","setCollections","c","id","push","setFileFormats","io","setEpsgCodes","v","parseInt","validateCollectionId","find","ValidationError","validateUdfRuntime","validateEpsgCode","includes","validateInputFormat","validateOutputFormat","validateProjDefinition","toLowerCase","validateWkt2Definition","codeWords","some","word","indexOf","validateTemporalInterval","date1","Date","date2","getTime","validateTemporalIntervals","interval","setProcessGraphParser","processGraph","validateProcessGraph","ProcessGraph","parser","createProcessGraphInstance","error","isSchemaCompatible","paramSchema","valueSchema","strict","allowValueAsElements","paramSchemas","normalizeJsonSchema","valueSchemas","compatible","findIndex","ps","i","vs","type","items","checkArray","oneOf","module","exports","BaseProcess","ErrorList","ProcessGraphError","ProcessGraphNode","ProcessRegistry","CommonUtils","containsRef","checkProcess","checkCallbacks","getType","process_graph","getRefs","getFromProcess","getFromCallbacks","store","concat","unique","hasOwnProperty","processKeys","process","jsonSchemaValidator","nodes","startNodes","resultNode","children","parentNode","parsed","callbackParameters","arguments","allowEmptyGraph","fillProcessParameters","allowUndefinedParameterRefs","toJSON","getJsonSchemaValidator","createJsonSchemaValidatorInstance","createNodeInstance","nodeObj","parent","pg","copyProcessGraphInstanceProperties","createProcessInstance","createChildProcessGraph","node","parameterPath","setArguments","setParentNode","length","parameterName","shift","setCallbackParameters","getCallbackParametersForProcess","getParentProcess","parse","getParentNode","getParent","getProcessGraph","isValid","count","addError","add","allowUndefinedParameters","allow","fillUndefinedParameters","fill","allowEmpty","makeError","errorId","getParentProcessId","process_id","node_id","size","hasProcessKey","keys","mapObjectValues","isResultNode","parseNodeArguments","values","filter","isStartNode","sort","localeCompare","throwOnErrors","first","validateNodes","getStartNodes","execute","args","reset","executeNodes","getResultNode","previousNode","promises","solveDependency","validateNode","merge","getNextNodes","Promise","all","getProcess","result","executeNode","setResult","nodeId","undefined","argumentName","arg","path","prevNode","from_node","addPreviousNode","addNextNode","hasParameter","from_parameter","addProcessParameter","getCallbackParameter","name","getCallbackParameters","p","description","hasParameterDefault","getParameterDefault","param","getParameter","default","getProcessParameters","includeUndefined","slice","refs","ref","other","getProcessParameter","callbackParam","processParam","hasArgument","getArgument","forEach","child","getStartNodeIds","getNode","getNodeCount","getNodes","getErrors","namespace","spec","get","MESSAGES","Error","codeOrMsg","variables","super","code","replacePlaceholders","CommonProcessRegistry","metaSchema","dependencies","pattern","optional","deprecated","experimental","omitFromObject","unsupportedArgs","getArgumentNames","argument","getParsedArgument","rawArg","getRawArgument","validateArgument","argType","reason","getProcessGraphParameterValue","parameter","schemas","isProcessGraphSchema","elementSchema","getElementJsonSchema","lastError","validator","test","last","errorList","getAll","getMessage","msg","trim","source","expectsFrom","receivedFrom","passesTo","computedResult","getArgumentType","defaultValue","evaluateArgument","getArgumentRefs","getResult","copy","getPreviousNodes","getDescription","setDescription","dependencyNode"],"sourceRoot":""}
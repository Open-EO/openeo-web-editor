{"version":3,"sources":["webpack:///./node_modules/intersects/line-polygon.js","webpack:///./node_modules/intersects/box-box.js","webpack:///./node_modules/intersects/lineToLine.js","webpack:///./node_modules/jsonlint-mod/web/jsonlint.js","webpack:///./node_modules/intersects/lineToPolygon.js","webpack:///./node_modules/intersects/line-box.js","webpack:///./node_modules/intersects/polygon-polygon.js","webpack:///./node_modules/intersects/line-point.js","webpack:///./node_modules/mgrs/mgrs.js","webpack:///./node_modules/intersects/polygon-point.js","webpack:///./node_modules/intersects/box-line.js","webpack:///./node_modules/mdurl/encode.js","webpack:///./node_modules/intersects/line-line.js","webpack:///./node_modules/intersects/box-point.js"],"names":["polygonPoint","lineLine","module","exports","x1","y1","x2","y2","points","tolerance","length","i","j","w1","h1","w2","h2","x3","y3","x4","y4","s1_x","s1_y","s2_x","s2_y","s","t","require","___dougJSONParse","at","ch","text","value","escapee","\"","b","f","n","r","error","m","name","message","next","c","charAt","number","string","isFinite","hex","uffff","parseInt","String","fromCharCode","white","word","array","arr","push","object","key","obj","Object","hasOwnProperty","call","source","reviver","result","walk","holder","k","v","val","prototype","undefined","jsonlint","parser","trace","yy","symbols_","terminals_","2","4","6","8","10","11","14","17","18","21","22","23","24","productions_","performAction","yytext","yyleng","yylineno","yystate","$$","_$","$0","this","$","replace","Number","table","3","5","7","9","12","13","15","16","1","19","20","25","defaultActions","parseError","str","hash","Error","parse","input","self","stack","vstack","lstack","recovering","TERROR","EOF","lexer","setInput","yylloc","yyloc","popStack","lex","token","symbol","preErrorSymbol","state","action","p","len","newState","expected","yyval","errStr","showPosition","join","match","line","loc","toString","Array","first_line","last_line","first_column","last_column","slice","_input","_more","_less","done","matched","conditionStack","lines","unput","more","less","pastInput","past","substr","upcomingInput","pre","tempMatch","index","rules","_currentRules","options","flex","begin","condition","popState","pop","conditions","topState","pushState","yy_","$avoiding_name_collisions","YY_START","origParse","dougJSONParse","e","test","linesUntilError","substring","split","col","l","toLowerCase","SyntaxError","apply","arguments","main","args","process","readFileSync","cwd","path","read","charset","argv","thickness","angle","Math","atan2","PI","half","cos","sin","boxPoint","xb","yb","wb","hb","points1","points2","minA","maxA","projected","minB","maxB","a","polygons","polygon","i1","i2","normal","x","y","distanceSquared","sqrt","pow","xp","yp","abs","NUM_100K_SETS","SET_ORIGIN_COLUMN_LETTERS","SET_ORIGIN_ROW_LETTERS","A","I","O","V","Z","forward","ll","accuracy","encode","LLtoUTM","lat","lon","inverse","mgrs","bbox","UTMtoLL","decode","toUpperCase","left","bottom","right","top","toPoint","degToRad","deg","radToDeg","rad","LongOrigin","eccPrimeSquared","N","T","C","M","LongOriginRad","ZoneNumber","Lat","Long","eccSquared","k0","LatRad","LongRad","floor","tan","UTMEasting","UTMNorthing","northing","round","easting","zoneNumber","zoneLetter","getLetterDesignator","utm","N1","T1","C1","R1","D","mu","phi1Rad","e1","topRight","LetterDesignator","seasting","snorthing","get100kID","setParm","get100kSetForZone","setColumn","setRow","getLetter100kID","column","row","parm","colOrigin","charCodeAt","rowOrigin","colInt","rowInt","rollover","twoLetter","mgrsString","testChar","hunK","sb","set","east100k","getEastingFromChar","north100k","getNorthingFromChar","getMinNorthing","remainder","accuracyBonus","sepEastingString","sepNorthingString","sep","sepEasting","sepNorthing","parseFloat","curCol","eastingValue","rewindMarker","curRow","northingValue","linePoint","p2x","p2y","p1x","p1y","lineBox","encodeCache","getEncodeCache","exclude","cache","keepEscaped","code","nextCode","defaultChars","encodeURIComponent","componentChars","lineToPolygon","polygonPolygon","linePolygon","lineToLine","lineLineThickness","thickness1","thickness2"],"mappings":"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","file":"js/chunk-525a546e.e4d41cff.js","sourcesContent":["var polygonPoint = require('./polygon-point')\nvar lineLine = require('./lineToLine')\n\n/**\n * line-polygon collision\n @param {number} x1 point 1 of line\n @param {number} y1 point 1 of line\n @param {number} x2 point 2 of line\n @param {number} y2 point 2 of line\n @param {number[]} points of polygon\n @param {tolerance=1} maximum distance of point to polygon's edges that triggers collision (see pointLine)\n */\nmodule.exports = function linePolygon(x1, y1, x2, y2, points, tolerance)\n{\n    var length = points.length\n\n    // check if first point is inside the shape (this covers if the line is completely enclosed by the shape)\n    if (polygonPoint(points, x1, y1, tolerance))\n    {\n        return true\n    }\n\n    // check for intersections for all of the sides\n    for (var i = 0; i < length; i += 2)\n    {\n        var j = (i + 2) % length\n        if (lineLine(x1, y1, x2, y2, points[i], points[i + 1], points[j], points[j + 1]))\n        {\n            return true\n        }\n    }\n    return false\n}\n","'use strict'\n\n/**\n * box-box collision\n * @param {number} x1 top-left corner of first box\n * @param {number} y1 top-left corner of first box\n * @param {number} w1 width of first box\n * @param {number} h1 height of first box\n * @param {number} x2 top-left corner of second box\n * @param {number} y2 top-left corner of second box\n * @param {number} w2 width of second box\n * @param {number} h2 height of second box\n */\nmodule.exports = function boxBox(x1, y1, w1, h1, x2, y2, w2, h2)\n{\n    return x1 < x2 + w2 && x1 + w1 > x2 && y1 < y2 + h2 && y1 + h1 > y2\n}\n","'use strict'\n\n/**\n * lineToLine helper function (to avoid circular dependencies)\n * from http://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect\n * @param {number} x1 first point in line 1\n * @param {number} y1 first point in line 1\n * @param {number} x2 second point in line 1\n * @param {number} y2 second point in line 1\n * @param {number} x3 first point in line 2\n * @param {number} y3 first point in line 2\n * @param {number} x4 second point in line 2\n * @param {number} y4 second point in line 2\n * @return {boolean}\n */\nmodule.exports = function lineToLine(x1, y1, x2, y2, x3, y3, x4, y4)\n{\n    var s1_x = x2 - x1\n    var s1_y = y2 - y1\n    var s2_x = x4 - x3\n    var s2_y = y4 - y3\n    var s = (-s1_y * (x1 - x3) + s1_x * (y1 - y3)) / (-s2_x * s1_y + s1_x * s2_y)\n    var t = (s2_x * (y1 - y3) - s2_y * (x1 - x3)) / (-s2_x * s1_y + s1_x * s2_y)\n    return s >= 0 && s <= 1 && t >= 0 && t <= 1\n}","var jsonlint = (function(){var require=true,module=false;var exports={};/*\n    json_parse.js\n    2016-05-02\n\n    Public Domain.\n\n    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.\n\n    This file creates a json_parse function.\n\n        json_parse(text, reviver)\n            This method parses a JSON text to produce an object or array.\n            It can throw a SyntaxError exception.\n\n            The optional reviver parameter is a function that can filter and\n            transform the results. It receives each of the keys and values,\n            and its return value is used instead of the original value.\n            If it returns what it received, then the structure is not modified.\n            If it returns undefined then the member is deleted.\n\n            Example:\n\n            // Parse the text. Values that look like ISO date strings will\n            // be converted to Date objects.\n\n            myData = json_parse(text, function (key, value) {\n                var a;\n                if (typeof value === \"string\") {\n                    a =\n/^(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2}(?:\\.\\d*)?)Z$/.exec(value);\n                    if (a) {\n                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],\n                            +a[5], +a[6]));\n                    }\n                }\n                return value;\n            });\n\n    This is a reference implementation. You are free to copy, modify, or\n    redistribute.\n\n    This code should be minified before deployment.\n    See http://javascript.crockford.com/jsmin.html\n\n    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO\n    NOT CONTROL.\n*/\n\n/*jslint for */\n\n/*property\n    at, b, call, charAt, f, fromCharCode, hasOwnProperty, message, n, name,\n    prototype, push, r, t, text\n*/\n\nvar ___dougJSONParse = (function () {\n    \"use strict\";\n\n// This is a function that can parse a JSON text, producing a JavaScript\n// data structure. It is a simple, recursive descent parser. It does not use\n// eval or regular expressions, so it can be used as a model for implementing\n// a JSON parser in other languages.\n\n// We are defining the function inside of another function to avoid creating\n// global variables.\n\n    var at;     // The index of the current character\n    var ch;     // The current character\n    var escapee = {\n        \"\\\"\": \"\\\"\",\n        \"\\\\\": \"\\\\\",\n        \"/\": \"/\",\n        b: \"\\b\",\n        f: \"\\f\",\n        n: \"\\n\",\n        r: \"\\r\",\n        t: \"\\t\"\n    };\n    var text;\n\n    var error = function (m) {\n\n// Call error when something is wrong.\n\n        throw {\n            name: \"SyntaxError\",\n            message: m,\n            at: at,\n            text: text\n        };\n    };\n\n    var next = function (c) {\n\n// If a c parameter is provided, verify that it matches the current character.\n\n        if (c && c !== ch) {\n            error(\"Expected '\" + c + \"' instead of '\" + ch + \"'\");\n        }\n\n// Get the next character. When there are no more characters,\n// return the empty string.\n\n        ch = text.charAt(at);\n        at += 1;\n        return ch;\n    };\n\n    var number = function () {\n\n// Parse a number value.\n\n        var value;\n        var string = \"\";\n\n        if (ch === \"-\") {\n            string = \"-\";\n            next(\"-\");\n        }\n        while (ch >= \"0\" && ch <= \"9\") {\n            string += ch;\n            next();\n        }\n        if (ch === \".\") {\n            string += \".\";\n            while (next() && ch >= \"0\" && ch <= \"9\") {\n                string += ch;\n            }\n        }\n        if (ch === \"e\" || ch === \"E\") {\n            string += ch;\n            next();\n            if (ch === \"-\" || ch === \"+\") {\n                string += ch;\n                next();\n            }\n            while (ch >= \"0\" && ch <= \"9\") {\n                string += ch;\n                next();\n            }\n        }\n        value = +string;\n        if (!isFinite(value)) {\n            error(\"Bad number\");\n        } else {\n            return value;\n        }\n    };\n\n    var string = function () {\n\n// Parse a string value.\n\n        var hex;\n        var i;\n        var value = \"\";\n        var uffff;\n\n// When parsing for string values, we must look for \" and \\ characters.\n\n        if (ch === \"\\\"\") {\n            while (next()) {\n                if (ch === \"\\\"\") {\n                    next();\n                    return value;\n                }\n                if (ch === \"\\\\\") {\n                    next();\n                    if (ch === \"u\") {\n                        uffff = 0;\n                        for (i = 0; i < 4; i += 1) {\n                            hex = parseInt(next(), 16);\n                            if (!isFinite(hex)) {\n                                break;\n                            }\n                            uffff = uffff * 16 + hex;\n                        }\n                        value += String.fromCharCode(uffff);\n                    } else if (typeof escapee[ch] === \"string\") {\n                        value += escapee[ch];\n                    } else {\n                        break;\n                    }\n                } else {\n                    value += ch;\n                }\n            }\n        }\n        error(\"Bad string\");\n    };\n\n    var white = function () {\n\n// Skip whitespace.\n\n        while (ch && ch <= \" \") {\n            next();\n        }\n    };\n\n    var word = function () {\n\n// true, false, or null.\n\n        switch (ch) {\n        case \"t\":\n            next(\"t\");\n            next(\"r\");\n            next(\"u\");\n            next(\"e\");\n            return true;\n        case \"f\":\n            next(\"f\");\n            next(\"a\");\n            next(\"l\");\n            next(\"s\");\n            next(\"e\");\n            return false;\n        case \"n\":\n            next(\"n\");\n            next(\"u\");\n            next(\"l\");\n            next(\"l\");\n            return null;\n        }\n        error(\"Unexpected '\" + ch + \"'\");\n    };\n\n    var value;  // Place holder for the value function.\n\n    var array = function () {\n\n// Parse an array value.\n\n        var arr = [];\n\n        if (ch === \"[\") {\n            next(\"[\");\n            white();\n            if (ch === \"]\") {\n                next(\"]\");\n                return arr;   // empty array\n            }\n            while (ch) {\n                arr.push(value());\n                white();\n                if (ch === \"]\") {\n                    next(\"]\");\n                    return arr;\n                }\n                next(\",\");\n                white();\n            }\n        }\n        error(\"Bad array\");\n    };\n\n    var object = function () {\n\n// Parse an object value.\n\n        var key;\n        var obj = {};\n\n        if (ch === \"{\") {\n            next(\"{\");\n            white();\n            if (ch === \"}\") {\n                next(\"}\");\n                return obj;   // empty object\n            }\n            while (ch) {\n                key = string();\n                white();\n                next(\":\");\n                if (Object.hasOwnProperty.call(obj, key)) {\n                    error(\"Duplicate key '\" + key + \"'\");\n                }\n                obj[key] = value();\n                white();\n                if (ch === \"}\") {\n                    next(\"}\");\n                    return obj;\n                }\n                next(\",\");\n                white();\n            }\n        }\n        error(\"Bad object\");\n    };\n\n    value = function () {\n\n// Parse a JSON value. It could be an object, an array, a string, a number,\n// or a word.\n\n        white();\n        switch (ch) {\n        case \"{\":\n            return object();\n        case \"[\":\n            return array();\n        case \"\\\"\":\n            return string();\n        case \"-\":\n            return number();\n        default:\n            return (ch >= \"0\" && ch <= \"9\")\n                ? number()\n                : word();\n        }\n    };\n\n// Return the json_parse function. It will have access to all of the above\n// functions and variables.\n\n    return function (source, reviver) {\n        var result;\n\n        text = source;\n        at = 0;\n        ch = \" \";\n        result = value();\n        white();\n        if (ch) {\n            error(\"Syntax error\");\n        }\n\n// If there is a reviver function, we recursively walk the new structure,\n// passing each name/value pair to the reviver function for possible\n// transformation, starting with a temporary root object that holds the result\n// in an empty key. If there is not a reviver function, we simply return the\n// result.\n\n        return (typeof reviver === \"function\")\n            ? (function walk(holder, key) {\n                var k;\n                var v;\n                var val = holder[key];\n                if (val && typeof val === \"object\") {\n                    for (k in val) {\n                        if (Object.prototype.hasOwnProperty.call(val, k)) {\n                            v = walk(val, k);\n                            if (v !== undefined) {\n                                val[k] = v;\n                            } else {\n                                delete val[k];\n                            }\n                        }\n                    }\n                }\n                return reviver.call(holder, key, val);\n            }({\"\": result}, \"\"))\n            : result;\n    };\n}());\n\nif(typeof module === 'object' && module.exports) {\n    module.exports = ___dougJSONParse;\n}\n/* Jison generated parser */\nvar jsonlint = (function(){\nvar parser = {trace: function trace() { },\nyy: {},\nsymbols_: {\"error\":2,\"JSONString\":3,\"STRING\":4,\"JSONNumber\":5,\"NUMBER\":6,\"JSONNullLiteral\":7,\"NULL\":8,\"JSONBooleanLiteral\":9,\"TRUE\":10,\"FALSE\":11,\"JSONText\":12,\"JSONValue\":13,\"EOF\":14,\"JSONObject\":15,\"JSONArray\":16,\"{\":17,\"}\":18,\"JSONMemberList\":19,\"JSONMember\":20,\":\":21,\",\":22,\"[\":23,\"]\":24,\"JSONElementList\":25,\"$accept\":0,\"$end\":1},\nterminals_: {2:\"error\",4:\"STRING\",6:\"NUMBER\",8:\"NULL\",10:\"TRUE\",11:\"FALSE\",14:\"EOF\",17:\"{\",18:\"}\",21:\":\",22:\",\",23:\"[\",24:\"]\"},\nproductions_: [0,[3,1],[5,1],[7,1],[9,1],[9,1],[12,2],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[15,2],[15,3],[20,3],[19,1],[19,3],[16,2],[16,3],[25,1],[25,3]],\nperformAction: function anonymous(yytext,yyleng,yylineno,yy,yystate,$$,_$) {\n\nvar $0 = $$.length - 1;\nswitch (yystate) {\ncase 1: // replace escaped characters with actual character\n          this.$ = yytext.replace(/\\\\(\\\\|\")/g, \"$\"+\"1\")\n                     .replace(/\\\\n/g,'\\n')\n                     .replace(/\\\\r/g,'\\r')\n                     .replace(/\\\\t/g,'\\t')\n                     .replace(/\\\\v/g,'\\v')\n                     .replace(/\\\\f/g,'\\f')\n                     .replace(/\\\\b/g,'\\b');\n\nbreak;\ncase 2:this.$ = Number(yytext);\nbreak;\ncase 3:this.$ = null;\nbreak;\ncase 4:this.$ = true;\nbreak;\ncase 5:this.$ = false;\nbreak;\ncase 6:return this.$ = $$[$0-1];\nbreak;\ncase 13:this.$ = {};\nbreak;\ncase 14:this.$ = $$[$0-1];\nbreak;\ncase 15:this.$ = [$$[$0-2], $$[$0]];\nbreak;\ncase 16:this.$ = {}; this.$[$$[$0][0]] = $$[$0][1];\nbreak;\ncase 17:this.$ = $$[$0-2]; $$[$0-2][$$[$0][0]] = $$[$0][1];\nbreak;\ncase 18:this.$ = [];\nbreak;\ncase 19:this.$ = $$[$0-1];\nbreak;\ncase 20:this.$ = [$$[$0]];\nbreak;\ncase 21:this.$ = $$[$0-2]; $$[$0-2].push($$[$0]);\nbreak;\n}\n},\ntable: [{3:5,4:[1,12],5:6,6:[1,13],7:3,8:[1,9],9:4,10:[1,10],11:[1,11],12:1,13:2,15:7,16:8,17:[1,14],23:[1,15]},{1:[3]},{14:[1,16]},{14:[2,7],18:[2,7],22:[2,7],24:[2,7]},{14:[2,8],18:[2,8],22:[2,8],24:[2,8]},{14:[2,9],18:[2,9],22:[2,9],24:[2,9]},{14:[2,10],18:[2,10],22:[2,10],24:[2,10]},{14:[2,11],18:[2,11],22:[2,11],24:[2,11]},{14:[2,12],18:[2,12],22:[2,12],24:[2,12]},{14:[2,3],18:[2,3],22:[2,3],24:[2,3]},{14:[2,4],18:[2,4],22:[2,4],24:[2,4]},{14:[2,5],18:[2,5],22:[2,5],24:[2,5]},{14:[2,1],18:[2,1],21:[2,1],22:[2,1],24:[2,1]},{14:[2,2],18:[2,2],22:[2,2],24:[2,2]},{3:20,4:[1,12],18:[1,17],19:18,20:19},{3:5,4:[1,12],5:6,6:[1,13],7:3,8:[1,9],9:4,10:[1,10],11:[1,11],13:23,15:7,16:8,17:[1,14],23:[1,15],24:[1,21],25:22},{1:[2,6]},{14:[2,13],18:[2,13],22:[2,13],24:[2,13]},{18:[1,24],22:[1,25]},{18:[2,16],22:[2,16]},{21:[1,26]},{14:[2,18],18:[2,18],22:[2,18],24:[2,18]},{22:[1,28],24:[1,27]},{22:[2,20],24:[2,20]},{14:[2,14],18:[2,14],22:[2,14],24:[2,14]},{3:20,4:[1,12],20:29},{3:5,4:[1,12],5:6,6:[1,13],7:3,8:[1,9],9:4,10:[1,10],11:[1,11],13:30,15:7,16:8,17:[1,14],23:[1,15]},{14:[2,19],18:[2,19],22:[2,19],24:[2,19]},{3:5,4:[1,12],5:6,6:[1,13],7:3,8:[1,9],9:4,10:[1,10],11:[1,11],13:31,15:7,16:8,17:[1,14],23:[1,15]},{18:[2,17],22:[2,17]},{18:[2,15],22:[2,15]},{22:[2,21],24:[2,21]}],\ndefaultActions: {16:[2,6]},\nparseError: function parseError(str, hash) {\n    throw new Error(str);\n},\nparse: function parse(input) {\n    var self = this,\n        stack = [0],\n        vstack = [null], // semantic value stack\n        lstack = [], // location stack\n        table = this.table,\n        yytext = '',\n        yylineno = 0,\n        yyleng = 0,\n        recovering = 0,\n        TERROR = 2,\n        EOF = 1;\n\n    //this.reductionCount = this.shiftCount = 0;\n\n    this.lexer.setInput(input);\n    this.lexer.yy = this.yy;\n    this.yy.lexer = this.lexer;\n    if (typeof this.lexer.yylloc == 'undefined')\n        this.lexer.yylloc = {};\n    var yyloc = this.lexer.yylloc;\n    lstack.push(yyloc);\n\n    if (typeof this.yy.parseError === 'function')\n        this.parseError = this.yy.parseError;\n\n    function popStack (n) {\n        stack.length = stack.length - 2*n;\n        vstack.length = vstack.length - n;\n        lstack.length = lstack.length - n;\n    }\n\n    function lex() {\n        var token;\n        token = self.lexer.lex() || 1; // $end = 1\n        // if token isn't its numeric value, convert\n        if (typeof token !== 'number') {\n            token = self.symbols_[token] || token;\n        }\n        return token;\n    }\n\n    var symbol, preErrorSymbol, state, action, a, r, yyval={},p,len,newState, expected;\n    while (true) {\n        // retreive state number from top of stack\n        state = stack[stack.length-1];\n\n        // use default actions if available\n        if (this.defaultActions[state]) {\n            action = this.defaultActions[state];\n        } else {\n            if (symbol == null)\n                symbol = lex();\n            // read action for current state and first input\n            action = table[state] && table[state][symbol];\n        }\n\n        // handle parse error\n        _handle_error:\n        if (typeof action === 'undefined' || !action.length || !action[0]) {\n\n            if (!recovering) {\n                // Report error\n                expected = [];\n                for (p in table[state]) if (this.terminals_[p] && p > 2) {\n                    expected.push(\"'\"+this.terminals_[p]+\"'\");\n                }\n                var errStr = '';\n                if (this.lexer.showPosition) {\n                    errStr = 'Parse error on line '+(yylineno+1)+\":\\n\"+this.lexer.showPosition()+\"\\nExpecting \"+expected.join(', ') + \", got '\" + this.terminals_[symbol]+ \"'\";\n                } else {\n                    errStr = 'Parse error on line '+(yylineno+1)+\": Unexpected \" +\n                                  (symbol == 1 /*EOF*/ ? \"end of input\" :\n                                              (\"'\"+(this.terminals_[symbol] || symbol)+\"'\"));\n                }\n                this.parseError(errStr,\n                    {text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected});\n            }\n\n            // just recovered from another error\n            if (recovering == 3) {\n                if (symbol == EOF) {\n                    throw new Error(errStr || 'Parsing halted.');\n                }\n\n                // discard current lookahead and grab another\n                yyleng = this.lexer.yyleng;\n                yytext = this.lexer.yytext;\n                yylineno = this.lexer.yylineno;\n                yyloc = this.lexer.yylloc;\n                symbol = lex();\n            }\n\n            // try to recover from error\n            while (1) {\n                // check for error recovery rule in this state\n                if ((TERROR.toString()) in table[state]) {\n                    break;\n                }\n                if (state == 0) {\n                    throw new Error(errStr || 'Parsing halted.');\n                }\n                popStack(1);\n                state = stack[stack.length-1];\n            }\n\n            preErrorSymbol = symbol; // save the lookahead token\n            symbol = TERROR;         // insert generic error symbol as new lookahead\n            state = stack[stack.length-1];\n            action = table[state] && table[state][TERROR];\n            recovering = 3; // allow 3 real symbols to be shifted before reporting a new error\n        }\n\n        // this shouldn't happen, unless resolve defaults are off\n        if (action[0] instanceof Array && action.length > 1) {\n            throw new Error('Parse Error: multiple actions possible at state: '+state+', token: '+symbol);\n        }\n\n        switch (action[0]) {\n\n            case 1: // shift\n                //this.shiftCount++;\n\n                stack.push(symbol);\n                vstack.push(this.lexer.yytext);\n                lstack.push(this.lexer.yylloc);\n                stack.push(action[1]); // push state\n                symbol = null;\n                if (!preErrorSymbol) { // normal execution/no error\n                    yyleng = this.lexer.yyleng;\n                    yytext = this.lexer.yytext;\n                    yylineno = this.lexer.yylineno;\n                    yyloc = this.lexer.yylloc;\n                    if (recovering > 0)\n                        recovering--;\n                } else { // error just occurred, resume old lookahead f/ before error\n                    symbol = preErrorSymbol;\n                    preErrorSymbol = null;\n                }\n                break;\n\n            case 2: // reduce\n                //this.reductionCount++;\n\n                len = this.productions_[action[1]][1];\n\n                // perform semantic action\n                yyval.$ = vstack[vstack.length-len]; // default to $$ = $1\n                // default location, uses first token for firsts, last for lasts\n                yyval._$ = {\n                    first_line: lstack[lstack.length-(len||1)].first_line,\n                    last_line: lstack[lstack.length-1].last_line,\n                    first_column: lstack[lstack.length-(len||1)].first_column,\n                    last_column: lstack[lstack.length-1].last_column\n                };\n                r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);\n\n                if (typeof r !== 'undefined') {\n                    return r;\n                }\n\n                // pop off stack\n                if (len) {\n                    stack = stack.slice(0,-1*len*2);\n                    vstack = vstack.slice(0, -1*len);\n                    lstack = lstack.slice(0, -1*len);\n                }\n\n                stack.push(this.productions_[action[1]][0]);    // push nonterminal (reduce)\n                vstack.push(yyval.$);\n                lstack.push(yyval._$);\n                // goto new state = table[STATE][NONTERMINAL]\n                newState = table[stack[stack.length-2]][stack[stack.length-1]];\n                stack.push(newState);\n                break;\n\n            case 3: // accept\n                return true;\n        }\n\n    }\n\n    return true;\n}};\n/* Jison generated lexer */\nvar lexer = (function(){\nvar lexer = ({EOF:1,\nparseError:function parseError(str, hash) {\n        if (this.yy.parseError) {\n            this.yy.parseError(str, hash);\n        } else {\n            throw new Error(str);\n        }\n    },\nsetInput:function (input) {\n        this._input = input;\n        this._more = this._less = this.done = false;\n        this.yylineno = this.yyleng = 0;\n        this.yytext = this.matched = this.match = '';\n        this.conditionStack = ['INITIAL'];\n        this.yylloc = {first_line:1,first_column:0,last_line:1,last_column:0};\n        return this;\n    },\ninput:function () {\n        var ch = this._input[0];\n        this.yytext+=ch;\n        this.yyleng++;\n        this.match+=ch;\n        this.matched+=ch;\n        var lines = ch.match(/\\n/);\n        if (lines) this.yylineno++;\n        this._input = this._input.slice(1);\n        return ch;\n    },\nunput:function (ch) {\n        this._input = ch + this._input;\n        return this;\n    },\nmore:function () {\n        this._more = true;\n        return this;\n    },\nless:function (n) {\n        this._input = this.match.slice(n) + this._input;\n    },\npastInput:function () {\n        var past = this.matched.substr(0, this.matched.length - this.match.length);\n        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\\n/g, \"\");\n    },\nupcomingInput:function () {\n        var next = this.match;\n        if (next.length < 20) {\n            next += this._input.substr(0, 20-next.length);\n        }\n        return (next.substr(0,20)+(next.length > 20 ? '...':'')).replace(/\\n/g, \"\");\n    },\nshowPosition:function () {\n        var pre = this.pastInput();\n        var c = new Array(pre.length + 1).join(\"-\");\n        return pre + this.upcomingInput() + \"\\n\" + c+\"^\";\n    },\nnext:function () {\n        if (this.done) {\n            return this.EOF;\n        }\n        if (!this._input) this.done = true;\n\n        var token,\n            match,\n            tempMatch,\n            index,\n            col,\n            lines;\n        if (!this._more) {\n            this.yytext = '';\n            this.match = '';\n        }\n        var rules = this._currentRules();\n        for (var i=0;i < rules.length; i++) {\n            tempMatch = this._input.match(this.rules[rules[i]]);\n            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n                match = tempMatch;\n                index = i;\n                if (!this.options.flex) break;\n            }\n        }\n        if (match) {\n            lines = match[0].match(/\\n.*/g);\n            if (lines) this.yylineno += lines.length;\n            this.yylloc = {first_line: this.yylloc.last_line,\n                           last_line: this.yylineno+1,\n                           first_column: this.yylloc.last_column,\n                           last_column: lines ? lines[lines.length-1].length-1 : this.yylloc.last_column + match[0].length}\n            this.yytext += match[0];\n            this.match += match[0];\n            this.yyleng = this.yytext.length;\n            this._more = false;\n            this._input = this._input.slice(match[0].length);\n            this.matched += match[0];\n            token = this.performAction.call(this, this.yy, this, rules[index],this.conditionStack[this.conditionStack.length-1]);\n            if (this.done && this._input) this.done = false;\n            if (token) return token;\n            else return;\n        }\n        if (this._input === \"\") {\n            return this.EOF;\n        } else {\n            this.parseError('Lexical error on line '+(this.yylineno+1)+'. Unrecognized text.\\n'+this.showPosition(),\n                    {text: \"\", token: null, line: this.yylineno});\n        }\n    },\nlex:function lex() {\n        var r = this.next();\n        if (typeof r !== 'undefined') {\n            return r;\n        } else {\n            return this.lex();\n        }\n    },\nbegin:function begin(condition) {\n        this.conditionStack.push(condition);\n    },\npopState:function popState() {\n        return this.conditionStack.pop();\n    },\n_currentRules:function _currentRules() {\n        return this.conditions[this.conditionStack[this.conditionStack.length-1]].rules;\n    },\ntopState:function () {\n        return this.conditionStack[this.conditionStack.length-2];\n    },\npushState:function begin(condition) {\n        this.begin(condition);\n    }});\nlexer.options = {};\nlexer.performAction = function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {\n\nvar YYSTATE=YY_START\nswitch($avoiding_name_collisions) {\ncase 0:/* skip whitespace */\nbreak;\ncase 1:return 6\nbreak;\ncase 2:yy_.yytext = yy_.yytext.substr(1,yy_.yyleng-2); return 4\nbreak;\ncase 3:return 17\nbreak;\ncase 4:return 18\nbreak;\ncase 5:return 23\nbreak;\ncase 6:return 24\nbreak;\ncase 7:return 22\nbreak;\ncase 8:return 21\nbreak;\ncase 9:return 10\nbreak;\ncase 10:return 11\nbreak;\ncase 11:return 8\nbreak;\ncase 12:return 14\nbreak;\ncase 13:return 'INVALID'\nbreak;\n}\n};\nlexer.rules = [/^(?:\\s+)/,/^(?:(-?([0-9]|[1-9][0-9]+))(\\.[0-9]+)?([eE][-+]?[0-9]+)?\\b)/,/^(?:\"(?:\\\\[\\\\\"bfnrt/]|\\\\u[a-fA-F0-9]{4}|[^\\\\\\0-\\x09\\x0a-\\x1f\"])*\")/,/^(?:\\{)/,/^(?:\\})/,/^(?:\\[)/,/^(?:\\])/,/^(?:,)/,/^(?::)/,/^(?:true\\b)/,/^(?:false\\b)/,/^(?:null\\b)/,/^(?:$)/,/^(?:.)/];\nlexer.conditions = {\"INITIAL\":{\"rules\":[0,1,2,3,4,5,6,7,8,9,10,11,12,13],\"inclusive\":true}};\n\n\n;\nreturn lexer;})()\nparser.lexer = lexer;\nreturn parser;\n})();\n\nvar origParse = jsonlint.parse;\n\njsonlint.parse = function(input) {\n    var result = origParse.call(jsonlint, input);\n    var dougJSONParse = typeof ___dougJSONParse === 'undefined' ? require('./doug-json-parse') : ___dougJSONParse;\n    try {\n        dougJSONParse(input);\n    } catch(e) {\n        if(/Duplicate key|Bad string|Unexpected/.test(e.message)) {\n            var linesUntilError = input.substring(0, e.at).split('\\n');\n            var line = linesUntilError.length;\n            var col = linesUntilError[line - 1].length - 1;\n\n            this.parseError(e.message, {line: line, col: col, message: e.message.replace(/./, function(l) { return l.toLowerCase(); })});\n            throw SyntaxError(e.message + ' on line ' + line);\n        }\n    }\n\n    return result;\n}\n\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {\nexports.parser = jsonlint;\nexports.parse = function () { return jsonlint.parse.apply(jsonlint, arguments); }\nexports.main = function commonjsMain(args) {\n    if (!args[1])\n        throw new Error('Usage: '+args[0]+' FILE');\n    if (typeof process !== 'undefined') {\n        var source = require('fs').readFileSync(require('path').join(process.cwd(), args[1]), \"utf8\");\n    } else {\n        var cwd = require(\"file\").path(require(\"file\").cwd());\n        var source = cwd.join(args[1]).read({charset: \"utf-8\"});\n    }\n    return exports.parser.parse(source);\n}\nif (typeof module !== 'undefined' && require.main === module) {\n  exports.main(typeof process !== 'undefined' ? process.argv.slice(1) : require(\"system\").args);\n}\n}\nreturn exports;})();if(typeof module === 'object' && module.exports) module.exports = jsonlint;\n","'use strict'\n\n/**\n * turns a line into a polygon using thickness\n * @param {number} x1 first point of line\n * @param {number} y1 first point of line\n * @param {number} x2 second point of line\n * @param {number} y2 second point of line\n * @param {number} thickness of line\n */\nmodule.exports = function lineToPolygon(x1, y1, x2, y2, thickness)\n{\n    const angle = Math.atan2(y2 - y1, x2 - x1) - Math.PI / 2\n    const half = thickness / 2\n    const cos = Math.cos(angle) * half\n    const sin = Math.sin(angle) * half\n    return [\n        x1 - cos, y1 - sin,\n        x2 - cos, y2 - sin,\n        x2 + cos, y2 + sin,\n        x1 + cos, y1 + sin\n    ]\n}","'use strict'\n\nvar boxPoint = require('./box-point')\nvar lineLine = require('./line-line')\n\n/**\n * line-box collision\n number @param {number} x1 point 1 of line\n number @param {number} y1 point 1 of line\n number @param {number} x2 point 2 of line\n number @param {number} y2 point 2 of line\n number @param {number} xb top-left of box\n number @param {number} yb top-left of box\n number @param {number} wb width of box\n number @param {number} hb height of box\n */\nmodule.exports = function lineBox(x1, y1, x2, y2, xb, yb, wb, hb)\n{\n    if (boxPoint(xb, yb, wb, hb, x1, y1) || boxPoint(xb, yb, wb, hb, x2, y2))\n    {\n        return true\n    }\n    return lineLine(x1, y1, x2, y2, xb, yb, xb + wb, yb) ||\n        lineLine(x1, y1, x2, y2, xb + wb, yb, xb + wb, yb + hb) ||\n        lineLine(x1, y1, x2, y2, xb, yb + hb, xb + wb, yb + hb) ||\n        lineLine(x1, y1, x2, y2, xb, yb, xb, yb + hb)\n}\n","'use strict'\n\n/**\n * polygon-polygon collision\n * based on http://stackoverflow.com/questions/10962379/how-to-check-intersection-between-2-rotated-rectangles\n * @param {number[]} points1 [x1, y1, x2, y2, ... xn, yn] of first polygon\n * @param {number[]} points2 [x1, y1, x2, y2, ... xn, yn] of second polygon\n * @return {boolean}\n */\nmodule.exports = function polygonPolygon(points1, points2)\n{\n    var a = points1\n    var b = points2\n    var polygons = [a, b]\n    var minA, maxA, projected, minB, maxB, j\n    for (var i = 0; i < polygons.length; i++)\n    {\n        var polygon = polygons[i]\n        for (var i1 = 0; i1 < polygon.length; i1 += 2)\n        {\n            var i2 = (i1 + 2) % polygon.length\n            var normal = { x: polygon[i2 + 1] - polygon[i1 + 1], y: polygon[i1] - polygon[i2] }\n            minA = maxA = null\n            for (j = 0; j < a.length; j += 2)\n            {\n                projected = normal.x * a[j] + normal.y * a[j + 1]\n                if (minA === null || projected < minA)\n                {\n                    minA = projected\n                }\n                if (maxA === null || projected > maxA)\n                {\n                    maxA = projected\n                }\n            }\n            minB = maxB = null\n            for (j = 0; j < b.length; j += 2)\n            {\n                projected = normal.x * b[j] + normal.y * b[j + 1]\n                if (minB === null || projected < minB)\n                {\n                    minB = projected\n                }\n                if (maxB === null || projected > maxB)\n                {\n                    maxB = projected\n                }\n            }\n            if (maxA < minB || maxB < minA)\n            {\n                return false\n            }\n        }\n    }\n    return true\n}\n","'use strict'\n\nfunction distanceSquared(x1, y1, x2, y2)\n{\n    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2))\n}\n\n/**\n * line-point collision\n * from https://stackoverflow.com/a/17693146/1955997\n * @param {number} x1 first point in line\n * @param {number} y1 first point in line\n * @param {number} x2 second point in line\n * @param {number} y2 second point in line\n * @param {number} xp point\n * @param {number} yp point\n * @param {number} [tolerance=1]\n * @return {boolean}\n */\nmodule.exports = function linePoint(x1, y1, x2, y2, xp, yp, tolerance)\n{\n    tolerance = tolerance || 1\n    return Math.abs(distanceSquared(x1, y1, x2, y2) - (distanceSquared(x1, y1, xp, yp) + distanceSquared(x2, y2, xp, yp))) <= tolerance\n}","\n\n\n/**\n * UTM zones are grouped, and assigned to one of a group of 6\n * sets.\n *\n * {int} @private\n */\nvar NUM_100K_SETS = 6;\n\n/**\n * The column letters (for easting) of the lower left value, per\n * set.\n *\n * {string} @private\n */\nvar SET_ORIGIN_COLUMN_LETTERS = 'AJSAJS';\n\n/**\n * The row letters (for northing) of the lower left value, per\n * set.\n *\n * {string} @private\n */\nvar SET_ORIGIN_ROW_LETTERS = 'AFAFAF';\n\nvar A = 65; // A\nvar I = 73; // I\nvar O = 79; // O\nvar V = 86; // V\nvar Z = 90; // Z\nexport default {\n  forward: forward,\n  inverse: inverse,\n  toPoint: toPoint\n};\n/**\n * Conversion of lat/lon to MGRS.\n *\n * @param {object} ll Object literal with lat and lon properties on a\n *     WGS84 ellipsoid.\n * @param {int} accuracy Accuracy in digits (5 for 1 m, 4 for 10 m, 3 for\n *      100 m, 2 for 1000 m or 1 for 10000 m). Optional, default is 5.\n * @return {string} the MGRS string for the given location and accuracy.\n */\nexport function forward(ll, accuracy) {\n  accuracy = accuracy || 5; // default accuracy 1m\n  return encode(LLtoUTM({\n    lat: ll[1],\n    lon: ll[0]\n  }), accuracy);\n};\n\n/**\n * Conversion of MGRS to lat/lon.\n *\n * @param {string} mgrs MGRS string.\n * @return {array} An array with left (longitude), bottom (latitude), right\n *     (longitude) and top (latitude) values in WGS84, representing the\n *     bounding box for the provided MGRS reference.\n */\nexport function inverse(mgrs) {\n  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));\n  if (bbox.lat && bbox.lon) {\n    return [bbox.lon, bbox.lat, bbox.lon, bbox.lat];\n  }\n  return [bbox.left, bbox.bottom, bbox.right, bbox.top];\n};\n\nexport function toPoint(mgrs) {\n  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));\n  if (bbox.lat && bbox.lon) {\n    return [bbox.lon, bbox.lat];\n  }\n  return [(bbox.left + bbox.right) / 2, (bbox.top + bbox.bottom) / 2];\n};\n/**\n * Conversion from degrees to radians.\n *\n * @private\n * @param {number} deg the angle in degrees.\n * @return {number} the angle in radians.\n */\nfunction degToRad(deg) {\n  return (deg * (Math.PI / 180.0));\n}\n\n/**\n * Conversion from radians to degrees.\n *\n * @private\n * @param {number} rad the angle in radians.\n * @return {number} the angle in degrees.\n */\nfunction radToDeg(rad) {\n  return (180.0 * (rad / Math.PI));\n}\n\n/**\n * Converts a set of Longitude and Latitude co-ordinates to UTM\n * using the WGS84 ellipsoid.\n *\n * @private\n * @param {object} ll Object literal with lat and lon properties\n *     representing the WGS84 coordinate to be converted.\n * @return {object} Object literal containing the UTM value with easting,\n *     northing, zoneNumber and zoneLetter properties, and an optional\n *     accuracy property in digits. Returns null if the conversion failed.\n */\nfunction LLtoUTM(ll) {\n  var Lat = ll.lat;\n  var Long = ll.lon;\n  var a = 6378137.0; //ellip.radius;\n  var eccSquared = 0.00669438; //ellip.eccsq;\n  var k0 = 0.9996;\n  var LongOrigin;\n  var eccPrimeSquared;\n  var N, T, C, A, M;\n  var LatRad = degToRad(Lat);\n  var LongRad = degToRad(Long);\n  var LongOriginRad;\n  var ZoneNumber;\n  // (int)\n  ZoneNumber = Math.floor((Long + 180) / 6) + 1;\n\n  //Make sure the longitude 180.00 is in Zone 60\n  if (Long === 180) {\n    ZoneNumber = 60;\n  }\n\n  // Special zone for Norway\n  if (Lat >= 56.0 && Lat < 64.0 && Long >= 3.0 && Long < 12.0) {\n    ZoneNumber = 32;\n  }\n\n  // Special zones for Svalbard\n  if (Lat >= 72.0 && Lat < 84.0) {\n    if (Long >= 0.0 && Long < 9.0) {\n      ZoneNumber = 31;\n    }\n    else if (Long >= 9.0 && Long < 21.0) {\n      ZoneNumber = 33;\n    }\n    else if (Long >= 21.0 && Long < 33.0) {\n      ZoneNumber = 35;\n    }\n    else if (Long >= 33.0 && Long < 42.0) {\n      ZoneNumber = 37;\n    }\n  }\n\n  LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3; //+3 puts origin\n  // in middle of\n  // zone\n  LongOriginRad = degToRad(LongOrigin);\n\n  eccPrimeSquared = (eccSquared) / (1 - eccSquared);\n\n  N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));\n  T = Math.tan(LatRad) * Math.tan(LatRad);\n  C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);\n  A = Math.cos(LatRad) * (LongRad - LongOriginRad);\n\n  M = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - (35 * eccSquared * eccSquared * eccSquared / 3072) * Math.sin(6 * LatRad));\n\n  var UTMEasting = (k0 * N * (A + (1 - T + C) * A * A * A / 6.0 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A * A * A * A * A / 120.0) + 500000.0);\n\n  var UTMNorthing = (k0 * (M + N * Math.tan(LatRad) * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * A * A * A * A / 24.0 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A * A * A * A * A * A / 720.0)));\n  if (Lat < 0.0) {\n    UTMNorthing += 10000000.0; //10000000 meter offset for\n    // southern hemisphere\n  }\n\n  return {\n    northing: Math.round(UTMNorthing),\n    easting: Math.round(UTMEasting),\n    zoneNumber: ZoneNumber,\n    zoneLetter: getLetterDesignator(Lat)\n  };\n}\n\n/**\n * Converts UTM coords to lat/long, using the WGS84 ellipsoid. This is a convenience\n * class where the Zone can be specified as a single string eg.\"60N\" which\n * is then broken down into the ZoneNumber and ZoneLetter.\n *\n * @private\n * @param {object} utm An object literal with northing, easting, zoneNumber\n *     and zoneLetter properties. If an optional accuracy property is\n *     provided (in meters), a bounding box will be returned instead of\n *     latitude and longitude.\n * @return {object} An object literal containing either lat and lon values\n *     (if no accuracy was provided), or top, right, bottom and left values\n *     for the bounding box calculated according to the provided accuracy.\n *     Returns null if the conversion failed.\n */\nfunction UTMtoLL(utm) {\n\n  var UTMNorthing = utm.northing;\n  var UTMEasting = utm.easting;\n  var zoneLetter = utm.zoneLetter;\n  var zoneNumber = utm.zoneNumber;\n  // check the ZoneNummber is valid\n  if (zoneNumber < 0 || zoneNumber > 60) {\n    return null;\n  }\n\n  var k0 = 0.9996;\n  var a = 6378137.0; //ellip.radius;\n  var eccSquared = 0.00669438; //ellip.eccsq;\n  var eccPrimeSquared;\n  var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));\n  var N1, T1, C1, R1, D, M;\n  var LongOrigin;\n  var mu, phi1Rad;\n\n  // remove 500,000 meter offset for longitude\n  var x = UTMEasting - 500000.0;\n  var y = UTMNorthing;\n\n  // We must know somehow if we are in the Northern or Southern\n  // hemisphere, this is the only time we use the letter So even\n  // if the Zone letter isn't exactly correct it should indicate\n  // the hemisphere correctly\n  if (zoneLetter < 'N') {\n    y -= 10000000.0; // remove 10,000,000 meter offset used\n    // for southern hemisphere\n  }\n\n  // There are 60 zones with zone 1 being at West -180 to -174\n  LongOrigin = (zoneNumber - 1) * 6 - 180 + 3; // +3 puts origin\n  // in middle of\n  // zone\n\n  eccPrimeSquared = (eccSquared) / (1 - eccSquared);\n\n  M = y / k0;\n  mu = M / (a * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));\n\n  phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + (151 * e1 * e1 * e1 / 96) * Math.sin(6 * mu);\n  // double phi1 = ProjMath.radToDeg(phi1Rad);\n\n  N1 = a / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));\n  T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);\n  C1 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);\n  R1 = a * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);\n  D = x / (N1 * k0);\n\n  var lat = phi1Rad - (N1 * Math.tan(phi1Rad) / R1) * (D * D / 2 - (5 + 3 * T1 + 10 * C1 - 4 * C1 * C1 - 9 * eccPrimeSquared) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C1 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C1 * C1) * D * D * D * D * D * D / 720);\n  lat = radToDeg(lat);\n\n  var lon = (D - (1 + 2 * T1 + C1) * D * D * D / 6 + (5 - 2 * C1 + 28 * T1 - 3 * C1 * C1 + 8 * eccPrimeSquared + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad);\n  lon = LongOrigin + radToDeg(lon);\n\n  var result;\n  if (utm.accuracy) {\n    var topRight = UTMtoLL({\n      northing: utm.northing + utm.accuracy,\n      easting: utm.easting + utm.accuracy,\n      zoneLetter: utm.zoneLetter,\n      zoneNumber: utm.zoneNumber\n    });\n    result = {\n      top: topRight.lat,\n      right: topRight.lon,\n      bottom: lat,\n      left: lon\n    };\n  }\n  else {\n    result = {\n      lat: lat,\n      lon: lon\n    };\n  }\n  return result;\n}\n\n/**\n * Calculates the MGRS letter designator for the given latitude.\n *\n * @private\n * @param {number} lat The latitude in WGS84 to get the letter designator\n *     for.\n * @return {char} The letter designator.\n */\nfunction getLetterDesignator(lat) {\n  //This is here as an error flag to show that the Latitude is\n  //outside MGRS limits\n  var LetterDesignator = 'Z';\n\n  if ((84 >= lat) && (lat >= 72)) {\n    LetterDesignator = 'X';\n  }\n  else if ((72 > lat) && (lat >= 64)) {\n    LetterDesignator = 'W';\n  }\n  else if ((64 > lat) && (lat >= 56)) {\n    LetterDesignator = 'V';\n  }\n  else if ((56 > lat) && (lat >= 48)) {\n    LetterDesignator = 'U';\n  }\n  else if ((48 > lat) && (lat >= 40)) {\n    LetterDesignator = 'T';\n  }\n  else if ((40 > lat) && (lat >= 32)) {\n    LetterDesignator = 'S';\n  }\n  else if ((32 > lat) && (lat >= 24)) {\n    LetterDesignator = 'R';\n  }\n  else if ((24 > lat) && (lat >= 16)) {\n    LetterDesignator = 'Q';\n  }\n  else if ((16 > lat) && (lat >= 8)) {\n    LetterDesignator = 'P';\n  }\n  else if ((8 > lat) && (lat >= 0)) {\n    LetterDesignator = 'N';\n  }\n  else if ((0 > lat) && (lat >= -8)) {\n    LetterDesignator = 'M';\n  }\n  else if ((-8 > lat) && (lat >= -16)) {\n    LetterDesignator = 'L';\n  }\n  else if ((-16 > lat) && (lat >= -24)) {\n    LetterDesignator = 'K';\n  }\n  else if ((-24 > lat) && (lat >= -32)) {\n    LetterDesignator = 'J';\n  }\n  else if ((-32 > lat) && (lat >= -40)) {\n    LetterDesignator = 'H';\n  }\n  else if ((-40 > lat) && (lat >= -48)) {\n    LetterDesignator = 'G';\n  }\n  else if ((-48 > lat) && (lat >= -56)) {\n    LetterDesignator = 'F';\n  }\n  else if ((-56 > lat) && (lat >= -64)) {\n    LetterDesignator = 'E';\n  }\n  else if ((-64 > lat) && (lat >= -72)) {\n    LetterDesignator = 'D';\n  }\n  else if ((-72 > lat) && (lat >= -80)) {\n    LetterDesignator = 'C';\n  }\n  return LetterDesignator;\n}\n\n/**\n * Encodes a UTM location as MGRS string.\n *\n * @private\n * @param {object} utm An object literal with easting, northing,\n *     zoneLetter, zoneNumber\n * @param {number} accuracy Accuracy in digits (1-5).\n * @return {string} MGRS string for the given UTM location.\n */\nfunction encode(utm, accuracy) {\n  // prepend with leading zeroes\n  var seasting = \"00000\" + utm.easting,\n    snorthing = \"00000\" + utm.northing;\n\n  return utm.zoneNumber + utm.zoneLetter + get100kID(utm.easting, utm.northing, utm.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);\n}\n\n/**\n * Get the two letter 100k designator for a given UTM easting,\n * northing and zone number value.\n *\n * @private\n * @param {number} easting\n * @param {number} northing\n * @param {number} zoneNumber\n * @return the two letter 100k designator for the given UTM location.\n */\nfunction get100kID(easting, northing, zoneNumber) {\n  var setParm = get100kSetForZone(zoneNumber);\n  var setColumn = Math.floor(easting / 100000);\n  var setRow = Math.floor(northing / 100000) % 20;\n  return getLetter100kID(setColumn, setRow, setParm);\n}\n\n/**\n * Given a UTM zone number, figure out the MGRS 100K set it is in.\n *\n * @private\n * @param {number} i An UTM zone number.\n * @return {number} the 100k set the UTM zone is in.\n */\nfunction get100kSetForZone(i) {\n  var setParm = i % NUM_100K_SETS;\n  if (setParm === 0) {\n    setParm = NUM_100K_SETS;\n  }\n\n  return setParm;\n}\n\n/**\n * Get the two-letter MGRS 100k designator given information\n * translated from the UTM northing, easting and zone number.\n *\n * @private\n * @param {number} column the column index as it relates to the MGRS\n *        100k set spreadsheet, created from the UTM easting.\n *        Values are 1-8.\n * @param {number} row the row index as it relates to the MGRS 100k set\n *        spreadsheet, created from the UTM northing value. Values\n *        are from 0-19.\n * @param {number} parm the set block, as it relates to the MGRS 100k set\n *        spreadsheet, created from the UTM zone. Values are from\n *        1-60.\n * @return two letter MGRS 100k code.\n */\nfunction getLetter100kID(column, row, parm) {\n  // colOrigin and rowOrigin are the letters at the origin of the set\n  var index = parm - 1;\n  var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index);\n  var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index);\n\n  // colInt and rowInt are the letters to build to return\n  var colInt = colOrigin + column - 1;\n  var rowInt = rowOrigin + row;\n  var rollover = false;\n\n  if (colInt > Z) {\n    colInt = colInt - Z + A - 1;\n    rollover = true;\n  }\n\n  if (colInt === I || (colOrigin < I && colInt > I) || ((colInt > I || colOrigin < I) && rollover)) {\n    colInt++;\n  }\n\n  if (colInt === O || (colOrigin < O && colInt > O) || ((colInt > O || colOrigin < O) && rollover)) {\n    colInt++;\n\n    if (colInt === I) {\n      colInt++;\n    }\n  }\n\n  if (colInt > Z) {\n    colInt = colInt - Z + A - 1;\n  }\n\n  if (rowInt > V) {\n    rowInt = rowInt - V + A - 1;\n    rollover = true;\n  }\n  else {\n    rollover = false;\n  }\n\n  if (((rowInt === I) || ((rowOrigin < I) && (rowInt > I))) || (((rowInt > I) || (rowOrigin < I)) && rollover)) {\n    rowInt++;\n  }\n\n  if (((rowInt === O) || ((rowOrigin < O) && (rowInt > O))) || (((rowInt > O) || (rowOrigin < O)) && rollover)) {\n    rowInt++;\n\n    if (rowInt === I) {\n      rowInt++;\n    }\n  }\n\n  if (rowInt > V) {\n    rowInt = rowInt - V + A - 1;\n  }\n\n  var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);\n  return twoLetter;\n}\n\n/**\n * Decode the UTM parameters from a MGRS string.\n *\n * @private\n * @param {string} mgrsString an UPPERCASE coordinate string is expected.\n * @return {object} An object literal with easting, northing, zoneLetter,\n *     zoneNumber and accuracy (in meters) properties.\n */\nfunction decode(mgrsString) {\n\n  if (mgrsString && mgrsString.length === 0) {\n    throw (\"MGRSPoint coverting from nothing\");\n  }\n\n  var length = mgrsString.length;\n\n  var hunK = null;\n  var sb = \"\";\n  var testChar;\n  var i = 0;\n\n  // get Zone number\n  while (!(/[A-Z]/).test(testChar = mgrsString.charAt(i))) {\n    if (i >= 2) {\n      throw (\"MGRSPoint bad conversion from: \" + mgrsString);\n    }\n    sb += testChar;\n    i++;\n  }\n\n  var zoneNumber = parseInt(sb, 10);\n\n  if (i === 0 || i + 3 > length) {\n    // A good MGRS string has to be 4-5 digits long,\n    // ##AAA/#AAA at least.\n    throw (\"MGRSPoint bad conversion from: \" + mgrsString);\n  }\n\n  var zoneLetter = mgrsString.charAt(i++);\n\n  // Should we check the zone letter here? Why not.\n  if (zoneLetter <= 'A' || zoneLetter === 'B' || zoneLetter === 'Y' || zoneLetter >= 'Z' || zoneLetter === 'I' || zoneLetter === 'O') {\n    throw (\"MGRSPoint zone letter \" + zoneLetter + \" not handled: \" + mgrsString);\n  }\n\n  hunK = mgrsString.substring(i, i += 2);\n\n  var set = get100kSetForZone(zoneNumber);\n\n  var east100k = getEastingFromChar(hunK.charAt(0), set);\n  var north100k = getNorthingFromChar(hunK.charAt(1), set);\n\n  // We have a bug where the northing may be 2000000 too low.\n  // How\n  // do we know when to roll over?\n\n  while (north100k < getMinNorthing(zoneLetter)) {\n    north100k += 2000000;\n  }\n\n  // calculate the char index for easting/northing separator\n  var remainder = length - i;\n\n  if (remainder % 2 !== 0) {\n    throw (\"MGRSPoint has to have an even number \\nof digits after the zone letter and two 100km letters - front \\nhalf for easting meters, second half for \\nnorthing meters\" + mgrsString);\n  }\n\n  var sep = remainder / 2;\n\n  var sepEasting = 0.0;\n  var sepNorthing = 0.0;\n  var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;\n  if (sep > 0) {\n    accuracyBonus = 100000.0 / Math.pow(10, sep);\n    sepEastingString = mgrsString.substring(i, i + sep);\n    sepEasting = parseFloat(sepEastingString) * accuracyBonus;\n    sepNorthingString = mgrsString.substring(i + sep);\n    sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;\n  }\n\n  easting = sepEasting + east100k;\n  northing = sepNorthing + north100k;\n\n  return {\n    easting: easting,\n    northing: northing,\n    zoneLetter: zoneLetter,\n    zoneNumber: zoneNumber,\n    accuracy: accuracyBonus\n  };\n}\n\n/**\n * Given the first letter from a two-letter MGRS 100k zone, and given the\n * MGRS table set for the zone number, figure out the easting value that\n * should be added to the other, secondary easting value.\n *\n * @private\n * @param {char} e The first letter from a two-letter MGRS 100k zone.\n * @param {number} set The MGRS table set for the zone number.\n * @return {number} The easting value for the given letter and set.\n */\nfunction getEastingFromChar(e, set) {\n  // colOrigin is the letter at the origin of the set for the\n  // column\n  var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1);\n  var eastingValue = 100000.0;\n  var rewindMarker = false;\n\n  while (curCol !== e.charCodeAt(0)) {\n    curCol++;\n    if (curCol === I) {\n      curCol++;\n    }\n    if (curCol === O) {\n      curCol++;\n    }\n    if (curCol > Z) {\n      if (rewindMarker) {\n        throw (\"Bad character: \" + e);\n      }\n      curCol = A;\n      rewindMarker = true;\n    }\n    eastingValue += 100000.0;\n  }\n\n  return eastingValue;\n}\n\n/**\n * Given the second letter from a two-letter MGRS 100k zone, and given the\n * MGRS table set for the zone number, figure out the northing value that\n * should be added to the other, secondary northing value. You have to\n * remember that Northings are determined from the equator, and the vertical\n * cycle of letters mean a 2000000 additional northing meters. This happens\n * approx. every 18 degrees of latitude. This method does *NOT* count any\n * additional northings. You have to figure out how many 2000000 meters need\n * to be added for the zone letter of the MGRS coordinate.\n *\n * @private\n * @param {char} n Second letter of the MGRS 100k zone\n * @param {number} set The MGRS table set number, which is dependent on the\n *     UTM zone number.\n * @return {number} The northing value for the given letter and set.\n */\nfunction getNorthingFromChar(n, set) {\n\n  if (n > 'V') {\n    throw (\"MGRSPoint given invalid Northing \" + n);\n  }\n\n  // rowOrigin is the letter at the origin of the set for the\n  // column\n  var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1);\n  var northingValue = 0.0;\n  var rewindMarker = false;\n\n  while (curRow !== n.charCodeAt(0)) {\n    curRow++;\n    if (curRow === I) {\n      curRow++;\n    }\n    if (curRow === O) {\n      curRow++;\n    }\n    // fixing a bug making whole application hang in this loop\n    // when 'n' is a wrong character\n    if (curRow > V) {\n      if (rewindMarker) { // making sure that this loop ends\n        throw (\"Bad character: \" + n);\n      }\n      curRow = A;\n      rewindMarker = true;\n    }\n    northingValue += 100000.0;\n  }\n\n  return northingValue;\n}\n\n/**\n * The function getMinNorthing returns the minimum northing value of a MGRS\n * zone.\n *\n * Ported from Geotrans' c Lattitude_Band_Value structure table.\n *\n * @private\n * @param {char} zoneLetter The MGRS zone to get the min northing for.\n * @return {number}\n */\nfunction getMinNorthing(zoneLetter) {\n  var northing;\n  switch (zoneLetter) {\n  case 'C':\n    northing = 1100000.0;\n    break;\n  case 'D':\n    northing = 2000000.0;\n    break;\n  case 'E':\n    northing = 2800000.0;\n    break;\n  case 'F':\n    northing = 3700000.0;\n    break;\n  case 'G':\n    northing = 4600000.0;\n    break;\n  case 'H':\n    northing = 5500000.0;\n    break;\n  case 'J':\n    northing = 6400000.0;\n    break;\n  case 'K':\n    northing = 7300000.0;\n    break;\n  case 'L':\n    northing = 8200000.0;\n    break;\n  case 'M':\n    northing = 9100000.0;\n    break;\n  case 'N':\n    northing = 0.0;\n    break;\n  case 'P':\n    northing = 800000.0;\n    break;\n  case 'Q':\n    northing = 1700000.0;\n    break;\n  case 'R':\n    northing = 2600000.0;\n    break;\n  case 'S':\n    northing = 3500000.0;\n    break;\n  case 'T':\n    northing = 4400000.0;\n    break;\n  case 'U':\n    northing = 5300000.0;\n    break;\n  case 'V':\n    northing = 6200000.0;\n    break;\n  case 'W':\n    northing = 7000000.0;\n    break;\n  case 'X':\n    northing = 7900000.0;\n    break;\n  default:\n    northing = -1.0;\n  }\n  if (northing >= 0.0) {\n    return northing;\n  }\n  else {\n    throw (\"Invalid zone letter: \" + zoneLetter);\n  }\n\n}\n","'use strict'\n\nconst linePoint = require('./line-point')\n\n/**\n * polygon-point collision\n * based on https://stackoverflow.com/a/17490923/1955997\n * @param {number[]} points [x1, y1, x2, y2, ... xn, yn] of polygon\n * @param {number} x of point\n * @param {number} y of point\n * @param {number} [tolerance=1] maximum distance of point to polygon's edges that triggers collision (see pointLine)\n */\nmodule.exports = function polygonPoint(points, x, y, tolerance)\n{\n    var length = points.length\n    var c = false\n    var i, j\n    for (i = 0, j = length - 2; i < length; i += 2)\n    {\n        if (((points[i + 1] > y) !== (points[j + 1] > y)) && (x < (points[j] - points[i]) * (y - points[i + 1]) / (points[j + 1] - points[i + 1]) + points[i]))\n        {\n            c = !c\n        }\n        j = i\n    }\n    if (c)\n    {\n        return true\n    }\n    for (i = 0; i < length; i += 2)\n    {\n        var p1x = points[i]\n        var p1y = points[i + 1]\n        var p2x, p2y\n        if (i === length - 2)\n        {\n            p2x = points[0]\n            p2y = points[1]\n        }\n        else\n        {\n            p2x = points[i + 2]\n            p2y = points[i + 3]\n        }\n        if (linePoint(p1x, p1y, p2x, p2y, x, y, tolerance))\n        {\n            return true\n        }\n    }\n    return false\n}\n","'use strict'\n\nvar lineBox = require('./line-box')\n\n/**\n * box-line collision\n * @param {number} xb top-left corner of box\n * @param {number} yb top-left corner of box\n * @param {number} wb width of box\n * @param {number} hb height of box\n * @param {number} x1 first point of line\n * @param {number} y1 first point of line\n * @param {number} x2 second point of line\n * @param {number} y2 second point of line\n */\nmodule.exports = function boxLine(xb, yb, wb, hb, x1, y1, x2, y2)\n{\n    return lineBox(x1, y1, x2, y2, xb, yb, wb, hb)\n}\n","\n'use strict';\n\n\nvar encodeCache = {};\n\n\n// Create a lookup array where anything but characters in `chars` string\n// and alphanumeric chars is percent-encoded.\n//\nfunction getEncodeCache(exclude) {\n  var i, ch, cache = encodeCache[exclude];\n  if (cache) { return cache; }\n\n  cache = encodeCache[exclude] = [];\n\n  for (i = 0; i < 128; i++) {\n    ch = String.fromCharCode(i);\n\n    if (/^[0-9a-z]$/i.test(ch)) {\n      // always allow unencoded alphanumeric characters\n      cache.push(ch);\n    } else {\n      cache.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2));\n    }\n  }\n\n  for (i = 0; i < exclude.length; i++) {\n    cache[exclude.charCodeAt(i)] = exclude[i];\n  }\n\n  return cache;\n}\n\n\n// Encode unsafe characters with percent-encoding, skipping already\n// encoded sequences.\n//\n//  - string       - string to encode\n//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)\n//  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)\n//\nfunction encode(string, exclude, keepEscaped) {\n  var i, l, code, nextCode, cache,\n      result = '';\n\n  if (typeof exclude !== 'string') {\n    // encode(string, keepEscaped)\n    keepEscaped  = exclude;\n    exclude = encode.defaultChars;\n  }\n\n  if (typeof keepEscaped === 'undefined') {\n    keepEscaped = true;\n  }\n\n  cache = getEncodeCache(exclude);\n\n  for (i = 0, l = string.length; i < l; i++) {\n    code = string.charCodeAt(i);\n\n    if (keepEscaped && code === 0x25 /* % */ && i + 2 < l) {\n      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {\n        result += string.slice(i, i + 3);\n        i += 2;\n        continue;\n      }\n    }\n\n    if (code < 128) {\n      result += cache[code];\n      continue;\n    }\n\n    if (code >= 0xD800 && code <= 0xDFFF) {\n      if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {\n        nextCode = string.charCodeAt(i + 1);\n        if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {\n          result += encodeURIComponent(string[i] + string[i + 1]);\n          i++;\n          continue;\n        }\n      }\n      result += '%EF%BF%BD';\n      continue;\n    }\n\n    result += encodeURIComponent(string[i]);\n  }\n\n  return result;\n}\n\nencode.defaultChars   = \";/?:@&=+$,-_.!~*'()#\";\nencode.componentChars = \"-_.!~*'()\";\n\n\nmodule.exports = encode;\n","'use strict'\n\nconst lineToPolygon = require('./lineToPolygon')\nconst polygonPolygon = require('./polygon-polygon')\nconst linePolygon = require('./line-polygon')\nconst lineToLine = require('./lineToLine')\n\n/**\n * line-line collision\n * from http://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect\n * @param {number} x1 first point in line 1\n * @param {number} y1 first point in line 1\n * @param {number} x2 second point in line 1\n * @param {number} y2 second point in line 1\n * @param {number} x3 first point in line 2\n * @param {number} y3 first point in line 2\n * @param {number} x4 second point in line 2\n * @param {number} y4 second point in line 2\n * @param {number} [thickness1] of line 1 (the line is centered in its thickness--see demo)\n * @param {number} [thickness2] of line 2 (the line is centered in its thickness--see demo)\n * @return {boolean}\n */\nmodule.exports = function lineLine(x1, y1, x2, y2, x3, y3, x4, y4, thickness1, thickness2)\n{\n    if (thickness1 || thickness2)\n    {\n        return lineLineThickness(x1, y1, x2, y2, x3, y3, x4, y4, thickness1, thickness2)\n    }\n    else\n    {\n        return lineToLine(x1, y1, x2, y2, x3, y3, x4, y4)\n    }\n}\n\nfunction lineLineThickness(x1, y1, x2, y2, x3, y3, x4, y4, thickness1, thickness2)\n{\n    if (thickness1 && thickness2)\n    {\n        return polygonPolygon(lineToPolygon(x1, y1, x2, y2, thickness1), lineToPolygon(x3, y3, x4, y4, thickness2))\n    }\n    else if (thickness1)\n    {\n        return linePolygon(x3, y3, x4, y4, lineToPolygon(x1, y1, x2, y2, thickness1))\n    }\n    else if (thickness2)\n    {\n        return linePolygon(x1, y1, x2, y2, lineToPolygon(x3, y3, x4, y4, thickness1))\n    }\n}","'use strict'\n\n/**\n * box-point collision\n * @param {number} x1 top-left corner of box\n * @param {number} y1 top-left corner of box\n * @param {number} w1 width of box\n * @param {number} h1 height of box\n * @param {number} x2 of point\n * @param {number} y2 of point\n * @return {boolean}\n */\nmodule.exports = function boxPoint(x1, y1, w1, h1, x2, y2)\n{\n    return x2 >= x1 && x2 <= x1 + w1 && y2 >= y1 && y2 <= y1 + h1\n}\n"],"sourceRoot":""}
{"version":3,"sources":["webpack:///./node_modules/ol/reproj.js","webpack:///./node_modules/ol/reproj/Triangulation.js","webpack:///./node_modules/ol/reproj/Tile.js","webpack:///./node_modules/ol/size.js","webpack:///./node_modules/ol/rotationconstraint.js","webpack:///./node_modules/ol/reproj/common.js","webpack:///./node_modules/ol/resolutionconstraint.js"],"names":["brokenDiagonalRendering_","MAX_SUBDIVISION","MAX_TRIANGLE_WIDTH","Triangulation","sourceProj","targetProj","targetExtent","maxSourceExtent","errorThreshold","opt_destinationResolution","this","sourceProj_","targetProj_","transformInvCache","transformInv","transformInv_","c","key","maxSourceExtent_","errorThresholdSquared_","triangles_","wrapsXInSource_","canWrapXInSource_","canWrapX","getExtent","sourceWorldWidth_","targetWorldWidth_","destinationTopLeft","destinationTopRight","destinationBottomRight","destinationBottomLeft","sourceTopLeft","sourceTopRight","sourceBottomRight","sourceBottomLeft","maxSubdivision","Math","max","ceil","addQuad_","leftBound_1","Infinity","forEach","triangle","i","arr","min","source","newTriangle","minX","maxX","bind","prototype","addTriangle_","a","b","aSrc","bSrc","cSrc","push","target","d","dSrc","sourceQuadExtent","sourceCoverageX","sourceWorldWidth","wrapsX","needsSubdivision","isGlobal","targetQuadExtent","targetCoverageX","isFinite","isNotFinite","center","centerSrc","dx","centerSrcEstimX","dy","centerSrcErrorSquared","abs","bc","bcSrc","da","daSrc","ab","abSrc","cd","cdSrc","calculateSourceExtent","extent","src","getTriangles","drawTestTriangle","ctx","u1","v1","u2","v2","beginPath","moveTo","lineTo","closePath","save","clip","fillRect","restore","verifyBrokenDiagonalRendering","data","offset","isBrokenDiagonalRendering","undefined","document","createElement","getContext","globalCompositeOperation","fillStyle","getImageData","calculateSourceResolution","targetCenter","targetResolution","sourceCenter","sourceResolution","targetMetersPerUnit","getMetersPerUnit","sourceMetersPerUnit","sourceExtent","compensationFactor","calculateSourceExtentResolution","corner","render","width","height","pixelRatio","triangulation","sources","gutter","opt_renderEdges","opt_contextOptions","context","round","length","canvas","pixelRound","value","scale","sourceDataExtent","canvasWidthInUnits","canvasHeightInUnits","stitchContext","stitchScale","xPos","yPos","srcWidth","srcHeight","image","drawImage","targetTopLeft","x0","y0","x1","y1","x2","y2","u0","v0","sourceNumericalShiftX","sourceNumericalShiftY","augmentedMatrix","affineCoefs","steps","ud","vd","step","transform","translate","strokeStyle","lineWidth","stroke","__extends","extendStatics","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","call","TypeError","String","__","constructor","create","_super","ReprojTile","sourceTileGrid","targetTileGrid","tileCoord","wrappedTileCoord","getTileFunction","opt_errorThreshold","_this","TileState","IDLE","renderEdges_","contextOptions_","pixelRatio_","gutter_","canvas_","sourceTileGrid_","targetTileGrid_","wrappedTileCoord_","sourceTiles_","sourcesListenerKeys_","sourceZ_","getTileCoordExtent","maxTargetExtent","limitedTargetExtent","state","EMPTY","sourceProjExtent","getResolution","errorThresholdInPixels","triangulation_","getZForResolution","sourceRange","getTileRangeForExtentAndZ","srcX","srcY","minY","maxY","tile","getImage","reproject_","getState","LOADED","ERROR","z","size","getTileSize","changed","load","LOADING","leftToLoad_1","sourceListenKey_1","EventType","CHANGE","e","unlistenSources_","setTimeout","Tile","hasArea","ratio","opt_size","toSize","isArray","disable","rotation","none","createSnapToN","n","theta","PI","opt_isMoving","floor","createSnapToZero","opt_tolerance","tolerance","ERROR_THRESHOLD","ENABLE_RASTER_REPROJECTION","getViewportClampedResolution","resolution","maxExtent","viewportSize","showFullExtent","xResolution","yResolution","getSmoothClampedResolution","maxResolution","minResolution","result","log","createSnapToResolutions","resolutions","opt_smooth","opt_maxExtent","opt_showFullExtent","direction","cappedMaxRes","smooth","capped","createSnapToPower","power","opt_minResolution","minZoomLevel","cappedZoomLevel","zoomLevel","newResolution","pow","createMinMaxResolution"],"mappings":"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","file":"js/chunk-6cab871c.c1bc90e2.js","sourcesContent":["/**\n * @module ol/reproj\n */\nimport { IMAGE_SMOOTHING_DISABLED } from './source/common.js';\nimport { assign } from './obj.js';\nimport { containsCoordinate, createEmpty, extend, forEachCorner, getCenter, getHeight, getTopLeft, getWidth, } from './extent.js';\nimport { createCanvasContext2D } from './dom.js';\nimport { getPointResolution, transform } from './proj.js';\nimport { solveLinearSystem } from './math.js';\nvar brokenDiagonalRendering_;\n/**\n * This draws a small triangle into a canvas by setting the triangle as the clip region\n * and then drawing a (too large) rectangle\n *\n * @param {CanvasRenderingContext2D} ctx The context in which to draw the triangle\n * @param {number} u1 The x-coordinate of the second point. The first point is 0,0.\n * @param {number} v1 The y-coordinate of the second point.\n * @param {number} u2 The x-coordinate of the third point.\n * @param {number} v2 The y-coordinate of the third point.\n */\nfunction drawTestTriangle(ctx, u1, v1, u2, v2) {\n    ctx.beginPath();\n    ctx.moveTo(0, 0);\n    ctx.lineTo(u1, v1);\n    ctx.lineTo(u2, v2);\n    ctx.closePath();\n    ctx.save();\n    ctx.clip();\n    ctx.fillRect(0, 0, Math.max(u1, u2) + 1, Math.max(v1, v2));\n    ctx.restore();\n}\n/**\n * Given the data from getImageData, see if the right values appear at the provided offset.\n * Returns true if either the color or transparency is off\n *\n * @param {Uint8ClampedArray} data The data returned from getImageData\n * @param {number} offset The pixel offset from the start of data.\n * @return {boolean} true if the diagonal rendering is broken\n */\nfunction verifyBrokenDiagonalRendering(data, offset) {\n    // the values ought to be close to the rgba(210, 0, 0, 0.75)\n    return (Math.abs(data[offset * 4] - 210) > 2 ||\n        Math.abs(data[offset * 4 + 3] - 0.75 * 255) > 2);\n}\n/**\n * Determines if the current browser configuration can render triangular clip regions correctly.\n * This value is cached so the function is only expensive the first time called.\n * Firefox on Windows (as of now) does not if HWA is enabled. See https://bugzilla.mozilla.org/show_bug.cgi?id=1606976\n * IE also doesn't. Chrome works, and everything seems to work on OSX and Android. This function caches the\n * result. I suppose that it is conceivably possible that a browser might flip modes while the app is\n * running, but lets hope not.\n *\n * @return {boolean} true if the Diagonal Rendering is broken.\n */\nfunction isBrokenDiagonalRendering() {\n    if (brokenDiagonalRendering_ === undefined) {\n        var ctx = document.createElement('canvas').getContext('2d');\n        ctx.globalCompositeOperation = 'lighter';\n        ctx.fillStyle = 'rgba(210, 0, 0, 0.75)';\n        drawTestTriangle(ctx, 4, 5, 4, 0);\n        drawTestTriangle(ctx, 4, 5, 0, 5);\n        var data = ctx.getImageData(0, 0, 3, 3).data;\n        brokenDiagonalRendering_ =\n            verifyBrokenDiagonalRendering(data, 0) ||\n                verifyBrokenDiagonalRendering(data, 4) ||\n                verifyBrokenDiagonalRendering(data, 8);\n    }\n    return brokenDiagonalRendering_;\n}\n/**\n * Calculates ideal resolution to use from the source in order to achieve\n * pixel mapping as close as possible to 1:1 during reprojection.\n * The resolution is calculated regardless of what resolutions\n * are actually available in the dataset (TileGrid, Image, ...).\n *\n * @param {import(\"./proj/Projection.js\").default} sourceProj Source projection.\n * @param {import(\"./proj/Projection.js\").default} targetProj Target projection.\n * @param {import(\"./coordinate.js\").Coordinate} targetCenter Target center.\n * @param {number} targetResolution Target resolution.\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\n */\nexport function calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution) {\n    var sourceCenter = transform(targetCenter, targetProj, sourceProj);\n    // calculate the ideal resolution of the source data\n    var sourceResolution = getPointResolution(targetProj, targetResolution, targetCenter);\n    var targetMetersPerUnit = targetProj.getMetersPerUnit();\n    if (targetMetersPerUnit !== undefined) {\n        sourceResolution *= targetMetersPerUnit;\n    }\n    var sourceMetersPerUnit = sourceProj.getMetersPerUnit();\n    if (sourceMetersPerUnit !== undefined) {\n        sourceResolution /= sourceMetersPerUnit;\n    }\n    // Based on the projection properties, the point resolution at the specified\n    // coordinates may be slightly different. We need to reverse-compensate this\n    // in order to achieve optimal results.\n    var sourceExtent = sourceProj.getExtent();\n    if (!sourceExtent || containsCoordinate(sourceExtent, sourceCenter)) {\n        var compensationFactor = getPointResolution(sourceProj, sourceResolution, sourceCenter) /\n            sourceResolution;\n        if (isFinite(compensationFactor) && compensationFactor > 0) {\n            sourceResolution /= compensationFactor;\n        }\n    }\n    return sourceResolution;\n}\n/**\n * Calculates ideal resolution to use from the source in order to achieve\n * pixel mapping as close as possible to 1:1 during reprojection.\n * The resolution is calculated regardless of what resolutions\n * are actually available in the dataset (TileGrid, Image, ...).\n *\n * @param {import(\"./proj/Projection.js\").default} sourceProj Source projection.\n * @param {import(\"./proj/Projection.js\").default} targetProj Target projection.\n * @param {import(\"./extent.js\").Extent} targetExtent Target extent\n * @param {number} targetResolution Target resolution.\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\n */\nexport function calculateSourceExtentResolution(sourceProj, targetProj, targetExtent, targetResolution) {\n    var targetCenter = getCenter(targetExtent);\n    var sourceResolution = calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution);\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n        forEachCorner(targetExtent, function (corner) {\n            sourceResolution = calculateSourceResolution(sourceProj, targetProj, corner, targetResolution);\n            return isFinite(sourceResolution) && sourceResolution > 0;\n        });\n    }\n    return sourceResolution;\n}\n/**\n * @typedef {Object} ImageExtent\n * @property {import(\"./extent.js\").Extent} extent Extent.\n * @property {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.\n */\n/**\n * Renders the source data into new canvas based on the triangulation.\n *\n * @param {number} width Width of the canvas.\n * @param {number} height Height of the canvas.\n * @param {number} pixelRatio Pixel ratio.\n * @param {number} sourceResolution Source resolution.\n * @param {import(\"./extent.js\").Extent} sourceExtent Extent of the data source.\n * @param {number} targetResolution Target resolution.\n * @param {import(\"./extent.js\").Extent} targetExtent Target extent.\n * @param {import(\"./reproj/Triangulation.js\").default} triangulation Calculated triangulation.\n * @param {Array<ImageExtent>} sources Array of sources.\n * @param {number} gutter Gutter of the sources.\n * @param {boolean} [opt_renderEdges] Render reprojection edges.\n * @param {object} [opt_contextOptions] Properties to set on the canvas context.\n * @return {HTMLCanvasElement} Canvas with reprojected data.\n */\nexport function render(width, height, pixelRatio, sourceResolution, sourceExtent, targetResolution, targetExtent, triangulation, sources, gutter, opt_renderEdges, opt_contextOptions) {\n    var context = createCanvasContext2D(Math.round(pixelRatio * width), Math.round(pixelRatio * height));\n    assign(context, opt_contextOptions);\n    if (sources.length === 0) {\n        return context.canvas;\n    }\n    context.scale(pixelRatio, pixelRatio);\n    function pixelRound(value) {\n        return Math.round(value * pixelRatio) / pixelRatio;\n    }\n    context.globalCompositeOperation = 'lighter';\n    var sourceDataExtent = createEmpty();\n    sources.forEach(function (src, i, arr) {\n        extend(sourceDataExtent, src.extent);\n    });\n    var canvasWidthInUnits = getWidth(sourceDataExtent);\n    var canvasHeightInUnits = getHeight(sourceDataExtent);\n    var stitchContext = createCanvasContext2D(Math.round((pixelRatio * canvasWidthInUnits) / sourceResolution), Math.round((pixelRatio * canvasHeightInUnits) / sourceResolution));\n    assign(stitchContext, opt_contextOptions);\n    var stitchScale = pixelRatio / sourceResolution;\n    sources.forEach(function (src, i, arr) {\n        var xPos = src.extent[0] - sourceDataExtent[0];\n        var yPos = -(src.extent[3] - sourceDataExtent[3]);\n        var srcWidth = getWidth(src.extent);\n        var srcHeight = getHeight(src.extent);\n        // This test should never fail -- but it does. Need to find a fix the upstream condition\n        if (src.image.width > 0 && src.image.height > 0) {\n            stitchContext.drawImage(src.image, gutter, gutter, src.image.width - 2 * gutter, src.image.height - 2 * gutter, xPos * stitchScale, yPos * stitchScale, srcWidth * stitchScale, srcHeight * stitchScale);\n        }\n    });\n    var targetTopLeft = getTopLeft(targetExtent);\n    triangulation.getTriangles().forEach(function (triangle, i, arr) {\n        /* Calculate affine transform (src -> dst)\n         * Resulting matrix can be used to transform coordinate\n         * from `sourceProjection` to destination pixels.\n         *\n         * To optimize number of context calls and increase numerical stability,\n         * we also do the following operations:\n         * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)\n         * here before solving the linear system so [ui, vi] are pixel coordinates.\n         *\n         * Src points: xi, yi\n         * Dst points: ui, vi\n         * Affine coefficients: aij\n         *\n         * | x0 y0 1  0  0 0 |   |a00|   |u0|\n         * | x1 y1 1  0  0 0 |   |a01|   |u1|\n         * | x2 y2 1  0  0 0 | x |a02| = |u2|\n         * |  0  0 0 x0 y0 1 |   |a10|   |v0|\n         * |  0  0 0 x1 y1 1 |   |a11|   |v1|\n         * |  0  0 0 x2 y2 1 |   |a12|   |v2|\n         */\n        var source = triangle.source;\n        var target = triangle.target;\n        var x0 = source[0][0], y0 = source[0][1];\n        var x1 = source[1][0], y1 = source[1][1];\n        var x2 = source[2][0], y2 = source[2][1];\n        // Make sure that everything is on pixel boundaries\n        var u0 = pixelRound((target[0][0] - targetTopLeft[0]) / targetResolution);\n        var v0 = pixelRound(-(target[0][1] - targetTopLeft[1]) / targetResolution);\n        var u1 = pixelRound((target[1][0] - targetTopLeft[0]) / targetResolution);\n        var v1 = pixelRound(-(target[1][1] - targetTopLeft[1]) / targetResolution);\n        var u2 = pixelRound((target[2][0] - targetTopLeft[0]) / targetResolution);\n        var v2 = pixelRound(-(target[2][1] - targetTopLeft[1]) / targetResolution);\n        // Shift all the source points to improve numerical stability\n        // of all the subsequent calculations. The [x0, y0] is used here.\n        // This is also used to simplify the linear system.\n        var sourceNumericalShiftX = x0;\n        var sourceNumericalShiftY = y0;\n        x0 = 0;\n        y0 = 0;\n        x1 -= sourceNumericalShiftX;\n        y1 -= sourceNumericalShiftY;\n        x2 -= sourceNumericalShiftX;\n        y2 -= sourceNumericalShiftY;\n        var augmentedMatrix = [\n            [x1, y1, 0, 0, u1 - u0],\n            [x2, y2, 0, 0, u2 - u0],\n            [0, 0, x1, y1, v1 - v0],\n            [0, 0, x2, y2, v2 - v0],\n        ];\n        var affineCoefs = solveLinearSystem(augmentedMatrix);\n        if (!affineCoefs) {\n            return;\n        }\n        context.save();\n        context.beginPath();\n        if (isBrokenDiagonalRendering() ||\n            opt_contextOptions === IMAGE_SMOOTHING_DISABLED) {\n            // Make sure that all lines are horizontal or vertical\n            context.moveTo(u1, v1);\n            // This is the diagonal line. Do it in 4 steps\n            var steps = 4;\n            var ud = u0 - u1;\n            var vd = v0 - v1;\n            for (var step = 0; step < steps; step++) {\n                // Go horizontally\n                context.lineTo(u1 + pixelRound(((step + 1) * ud) / steps), v1 + pixelRound((step * vd) / (steps - 1)));\n                // Go vertically\n                if (step != steps - 1) {\n                    context.lineTo(u1 + pixelRound(((step + 1) * ud) / steps), v1 + pixelRound(((step + 1) * vd) / (steps - 1)));\n                }\n            }\n            // We are almost at u0r, v0r\n            context.lineTo(u2, v2);\n        }\n        else {\n            context.moveTo(u1, v1);\n            context.lineTo(u0, v0);\n            context.lineTo(u2, v2);\n        }\n        context.clip();\n        context.transform(affineCoefs[0], affineCoefs[2], affineCoefs[1], affineCoefs[3], u0, v0);\n        context.translate(sourceDataExtent[0] - sourceNumericalShiftX, sourceDataExtent[3] - sourceNumericalShiftY);\n        context.scale(sourceResolution / pixelRatio, -sourceResolution / pixelRatio);\n        context.drawImage(stitchContext.canvas, 0, 0);\n        context.restore();\n    });\n    if (opt_renderEdges) {\n        context.save();\n        context.globalCompositeOperation = 'source-over';\n        context.strokeStyle = 'black';\n        context.lineWidth = 1;\n        triangulation.getTriangles().forEach(function (triangle, i, arr) {\n            var target = triangle.target;\n            var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;\n            var v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;\n            var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;\n            var v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;\n            var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;\n            var v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;\n            context.beginPath();\n            context.moveTo(u1, v1);\n            context.lineTo(u0, v0);\n            context.lineTo(u2, v2);\n            context.closePath();\n            context.stroke();\n        });\n        context.restore();\n    }\n    return context.canvas;\n}\n//# sourceMappingURL=reproj.js.map","/**\n * @module ol/reproj/Triangulation\n */\nimport { boundingExtent, createEmpty, extendCoordinate, getArea, getBottomLeft, getBottomRight, getTopLeft, getTopRight, getWidth, intersects, } from '../extent.js';\nimport { getTransform } from '../proj.js';\nimport { log2, modulo } from '../math.js';\n/**\n * Single triangle; consists of 3 source points and 3 target points.\n * @typedef {Object} Triangle\n * @property {Array<import(\"../coordinate.js\").Coordinate>} source Source.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} target Target.\n */\n/**\n * Maximum number of subdivision steps during raster reprojection triangulation.\n * Prevents high memory usage and large number of proj4 calls (for certain\n * transformations and areas). At most `2*(2^this)` triangles are created for\n * each triangulated extent (tile/image).\n * @type {number}\n */\nvar MAX_SUBDIVISION = 10;\n/**\n * Maximum allowed size of triangle relative to world width. When transforming\n * corners of world extent between certain projections, the resulting\n * triangulation seems to have zero error and no subdivision is performed. If\n * the triangle width is more than this (relative to world width; 0-1),\n * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.\n * @type {number}\n */\nvar MAX_TRIANGLE_WIDTH = 0.25;\n/**\n * @classdesc\n * Class containing triangulation of the given target extent.\n * Used for determining source data and the reprojection itself.\n */\nvar Triangulation = /** @class */ (function () {\n    /**\n     * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n     * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n     * @param {import(\"../extent.js\").Extent} targetExtent Target extent to triangulate.\n     * @param {import(\"../extent.js\").Extent} maxSourceExtent Maximal source extent that can be used.\n     * @param {number} errorThreshold Acceptable error (in source units).\n     * @param {?number} opt_destinationResolution The (optional) resolution of the destination.\n     */\n    function Triangulation(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold, opt_destinationResolution) {\n        /**\n         * @type {import(\"../proj/Projection.js\").default}\n         * @private\n         */\n        this.sourceProj_ = sourceProj;\n        /**\n         * @type {import(\"../proj/Projection.js\").default}\n         * @private\n         */\n        this.targetProj_ = targetProj;\n        /** @type {!Object<string, import(\"../coordinate.js\").Coordinate>} */\n        var transformInvCache = {};\n        var transformInv = getTransform(this.targetProj_, this.sourceProj_);\n        /**\n         * @param {import(\"../coordinate.js\").Coordinate} c A coordinate.\n         * @return {import(\"../coordinate.js\").Coordinate} Transformed coordinate.\n         * @private\n         */\n        this.transformInv_ = function (c) {\n            var key = c[0] + '/' + c[1];\n            if (!transformInvCache[key]) {\n                transformInvCache[key] = transformInv(c);\n            }\n            return transformInvCache[key];\n        };\n        /**\n         * @type {import(\"../extent.js\").Extent}\n         * @private\n         */\n        this.maxSourceExtent_ = maxSourceExtent;\n        /**\n         * @type {number}\n         * @private\n         */\n        this.errorThresholdSquared_ = errorThreshold * errorThreshold;\n        /**\n         * @type {Array<Triangle>}\n         * @private\n         */\n        this.triangles_ = [];\n        /**\n         * Indicates that the triangulation crosses edge of the source projection.\n         * @type {boolean}\n         * @private\n         */\n        this.wrapsXInSource_ = false;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this.canWrapXInSource_ =\n            this.sourceProj_.canWrapX() &&\n                !!maxSourceExtent &&\n                !!this.sourceProj_.getExtent() &&\n                getWidth(maxSourceExtent) == getWidth(this.sourceProj_.getExtent());\n        /**\n         * @type {?number}\n         * @private\n         */\n        this.sourceWorldWidth_ = this.sourceProj_.getExtent()\n            ? getWidth(this.sourceProj_.getExtent())\n            : null;\n        /**\n         * @type {?number}\n         * @private\n         */\n        this.targetWorldWidth_ = this.targetProj_.getExtent()\n            ? getWidth(this.targetProj_.getExtent())\n            : null;\n        var destinationTopLeft = getTopLeft(targetExtent);\n        var destinationTopRight = getTopRight(targetExtent);\n        var destinationBottomRight = getBottomRight(targetExtent);\n        var destinationBottomLeft = getBottomLeft(targetExtent);\n        var sourceTopLeft = this.transformInv_(destinationTopLeft);\n        var sourceTopRight = this.transformInv_(destinationTopRight);\n        var sourceBottomRight = this.transformInv_(destinationBottomRight);\n        var sourceBottomLeft = this.transformInv_(destinationBottomLeft);\n        /*\n         * The maxSubdivision controls how many splittings of the target area can\n         * be done. The idea here is to do a linear mapping of the target areas\n         * but the actual overal reprojection (can be) extremely non-linear. The\n         * default value of MAX_SUBDIVISION was chosen based on mapping a 256x256\n         * tile size. However this function is also called to remap canvas rendered\n         * layers which can be much larger. This calculation increases the maxSubdivision\n         * value by the right factor so that each 256x256 pixel area has\n         * MAX_SUBDIVISION divisions.\n         */\n        var maxSubdivision = MAX_SUBDIVISION +\n            (opt_destinationResolution\n                ? Math.max(0, Math.ceil(log2(getArea(targetExtent) /\n                    (opt_destinationResolution *\n                        opt_destinationResolution *\n                        256 *\n                        256))))\n                : 0);\n        this.addQuad_(destinationTopLeft, destinationTopRight, destinationBottomRight, destinationBottomLeft, sourceTopLeft, sourceTopRight, sourceBottomRight, sourceBottomLeft, maxSubdivision);\n        if (this.wrapsXInSource_) {\n            var leftBound_1 = Infinity;\n            this.triangles_.forEach(function (triangle, i, arr) {\n                leftBound_1 = Math.min(leftBound_1, triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]);\n            });\n            // Shift triangles to be as close to `leftBound` as possible\n            // (if the distance is more than `worldWidth / 2` it can be closer.\n            this.triangles_.forEach(function (triangle) {\n                if (Math.max(triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]) -\n                    leftBound_1 >\n                    this.sourceWorldWidth_ / 2) {\n                    var newTriangle = [\n                        [triangle.source[0][0], triangle.source[0][1]],\n                        [triangle.source[1][0], triangle.source[1][1]],\n                        [triangle.source[2][0], triangle.source[2][1]],\n                    ];\n                    if (newTriangle[0][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {\n                        newTriangle[0][0] -= this.sourceWorldWidth_;\n                    }\n                    if (newTriangle[1][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {\n                        newTriangle[1][0] -= this.sourceWorldWidth_;\n                    }\n                    if (newTriangle[2][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {\n                        newTriangle[2][0] -= this.sourceWorldWidth_;\n                    }\n                    // Rarely (if the extent contains both the dateline and prime meridian)\n                    // the shift can in turn break some triangles.\n                    // Detect this here and don't shift in such cases.\n                    var minX = Math.min(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);\n                    var maxX = Math.max(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);\n                    if (maxX - minX < this.sourceWorldWidth_ / 2) {\n                        triangle.source = newTriangle;\n                    }\n                }\n            }.bind(this));\n        }\n        transformInvCache = {};\n    }\n    /**\n     * Adds triangle to the triangulation.\n     * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n     * @private\n     */\n    Triangulation.prototype.addTriangle_ = function (a, b, c, aSrc, bSrc, cSrc) {\n        this.triangles_.push({\n            source: [aSrc, bSrc, cSrc],\n            target: [a, b, c],\n        });\n    };\n    /**\n     * Adds quad (points in clock-wise order) to the triangulation\n     * (and reprojects the vertices) if valid.\n     * Performs quad subdivision if needed to increase precision.\n     *\n     * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} d The target d coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} dSrc The source d coordinate.\n     * @param {number} maxSubdivision Maximal allowed subdivision of the quad.\n     * @private\n     */\n    Triangulation.prototype.addQuad_ = function (a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {\n        var sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);\n        var sourceCoverageX = this.sourceWorldWidth_\n            ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_\n            : null;\n        var sourceWorldWidth = /** @type {number} */ (this.sourceWorldWidth_);\n        // when the quad is wrapped in the source projection\n        // it covers most of the projection extent, but not fully\n        var wrapsX = this.sourceProj_.canWrapX() &&\n            sourceCoverageX > 0.5 &&\n            sourceCoverageX < 1;\n        var needsSubdivision = false;\n        if (maxSubdivision > 0) {\n            if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {\n                var targetQuadExtent = boundingExtent([a, b, c, d]);\n                var targetCoverageX = getWidth(targetQuadExtent) / this.targetWorldWidth_;\n                needsSubdivision =\n                    targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n            }\n            if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {\n                needsSubdivision =\n                    sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n            }\n        }\n        if (!needsSubdivision && this.maxSourceExtent_) {\n            if (isFinite(sourceQuadExtent[0]) &&\n                isFinite(sourceQuadExtent[1]) &&\n                isFinite(sourceQuadExtent[2]) &&\n                isFinite(sourceQuadExtent[3])) {\n                if (!intersects(sourceQuadExtent, this.maxSourceExtent_)) {\n                    // whole quad outside source projection extent -> ignore\n                    return;\n                }\n            }\n        }\n        var isNotFinite = 0;\n        if (!needsSubdivision) {\n            if (!isFinite(aSrc[0]) ||\n                !isFinite(aSrc[1]) ||\n                !isFinite(bSrc[0]) ||\n                !isFinite(bSrc[1]) ||\n                !isFinite(cSrc[0]) ||\n                !isFinite(cSrc[1]) ||\n                !isFinite(dSrc[0]) ||\n                !isFinite(dSrc[1])) {\n                if (maxSubdivision > 0) {\n                    needsSubdivision = true;\n                }\n                else {\n                    // It might be the case that only 1 of the points is infinite. In this case\n                    // we can draw a single triangle with the other three points\n                    isNotFinite =\n                        (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) +\n                            (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) +\n                            (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) +\n                            (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);\n                    if (isNotFinite != 1 &&\n                        isNotFinite != 2 &&\n                        isNotFinite != 4 &&\n                        isNotFinite != 8) {\n                        return;\n                    }\n                }\n            }\n        }\n        if (maxSubdivision > 0) {\n            if (!needsSubdivision) {\n                var center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];\n                var centerSrc = this.transformInv_(center);\n                var dx = void 0;\n                if (wrapsX) {\n                    var centerSrcEstimX = (modulo(aSrc[0], sourceWorldWidth) +\n                        modulo(cSrc[0], sourceWorldWidth)) /\n                        2;\n                    dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);\n                }\n                else {\n                    dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];\n                }\n                var dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];\n                var centerSrcErrorSquared = dx * dx + dy * dy;\n                needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;\n            }\n            if (needsSubdivision) {\n                if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {\n                    // split horizontally (top & bottom)\n                    var bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];\n                    var bcSrc = this.transformInv_(bc);\n                    var da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];\n                    var daSrc = this.transformInv_(da);\n                    this.addQuad_(a, b, bc, da, aSrc, bSrc, bcSrc, daSrc, maxSubdivision - 1);\n                    this.addQuad_(da, bc, c, d, daSrc, bcSrc, cSrc, dSrc, maxSubdivision - 1);\n                }\n                else {\n                    // split vertically (left & right)\n                    var ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\n                    var abSrc = this.transformInv_(ab);\n                    var cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];\n                    var cdSrc = this.transformInv_(cd);\n                    this.addQuad_(a, ab, cd, d, aSrc, abSrc, cdSrc, dSrc, maxSubdivision - 1);\n                    this.addQuad_(ab, b, c, cd, abSrc, bSrc, cSrc, cdSrc, maxSubdivision - 1);\n                }\n                return;\n            }\n        }\n        if (wrapsX) {\n            if (!this.canWrapXInSource_) {\n                return;\n            }\n            this.wrapsXInSource_ = true;\n        }\n        // Exactly zero or one of *Src is not finite\n        // The triangles must have the diagonal line as the first side\n        // This is to allow easy code in reproj.s to make it straight for broken\n        // browsers that can't handle diagonal clipping\n        if ((isNotFinite & 0xb) == 0) {\n            this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);\n        }\n        if ((isNotFinite & 0xe) == 0) {\n            this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);\n        }\n        if (isNotFinite) {\n            // Try the other two triangles\n            if ((isNotFinite & 0xd) == 0) {\n                this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);\n            }\n            if ((isNotFinite & 0x7) == 0) {\n                this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);\n            }\n        }\n    };\n    /**\n     * Calculates extent of the 'source' coordinates from all the triangles.\n     *\n     * @return {import(\"../extent.js\").Extent} Calculated extent.\n     */\n    Triangulation.prototype.calculateSourceExtent = function () {\n        var extent = createEmpty();\n        this.triangles_.forEach(function (triangle, i, arr) {\n            var src = triangle.source;\n            extendCoordinate(extent, src[0]);\n            extendCoordinate(extent, src[1]);\n            extendCoordinate(extent, src[2]);\n        });\n        return extent;\n    };\n    /**\n     * @return {Array<Triangle>} Array of the calculated triangles.\n     */\n    Triangulation.prototype.getTriangles = function () {\n        return this.triangles_;\n    };\n    return Triangulation;\n}());\nexport default Triangulation;\n//# sourceMappingURL=Triangulation.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/reproj/Tile\n */\nimport { ERROR_THRESHOLD } from './common.js';\nimport EventType from '../events/EventType.js';\nimport Tile from '../Tile.js';\nimport TileState from '../TileState.js';\nimport Triangulation from './Triangulation.js';\nimport { calculateSourceExtentResolution, render as renderReprojected, } from '../reproj.js';\nimport { clamp } from '../math.js';\nimport { getArea, getIntersection } from '../extent.js';\nimport { listen, unlistenByKey } from '../events.js';\n/**\n * @typedef {function(number, number, number, number) : import(\"../Tile.js\").default} FunctionType\n */\n/**\n * @classdesc\n * Class encapsulating single reprojected tile.\n * See {@link module:ol/source/TileImage~TileImage}.\n *\n */\nvar ReprojTile = /** @class */ (function (_super) {\n    __extends(ReprojTile, _super);\n    /**\n     * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n     * @param {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n     * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n     * @param {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n     * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n     * @param {import(\"../tilecoord.js\").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {number} gutter Gutter of the source tiles.\n     * @param {FunctionType} getTileFunction\n     *     Function returning source tiles (z, x, y, pixelRatio).\n     * @param {number} [opt_errorThreshold] Acceptable reprojection error (in px).\n     * @param {boolean} [opt_renderEdges] Render reprojection edges.\n     * @param {object} [opt_contextOptions] Properties to set on the canvas context.\n     */\n    function ReprojTile(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, opt_errorThreshold, opt_renderEdges, opt_contextOptions) {\n        var _this = _super.call(this, tileCoord, TileState.IDLE) || this;\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _this.renderEdges_ = opt_renderEdges !== undefined ? opt_renderEdges : false;\n        /**\n         * @private\n         * @type {object}\n         */\n        _this.contextOptions_ = opt_contextOptions;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.pixelRatio_ = pixelRatio;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.gutter_ = gutter;\n        /**\n         * @private\n         * @type {HTMLCanvasElement}\n         */\n        _this.canvas_ = null;\n        /**\n         * @private\n         * @type {import(\"../tilegrid/TileGrid.js\").default}\n         */\n        _this.sourceTileGrid_ = sourceTileGrid;\n        /**\n         * @private\n         * @type {import(\"../tilegrid/TileGrid.js\").default}\n         */\n        _this.targetTileGrid_ = targetTileGrid;\n        /**\n         * @private\n         * @type {import(\"../tilecoord.js\").TileCoord}\n         */\n        _this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\n        /**\n         * @private\n         * @type {!Array<import(\"../Tile.js\").default>}\n         */\n        _this.sourceTiles_ = [];\n        /**\n         * @private\n         * @type {?Array<import(\"../events.js\").EventsKey>}\n         */\n        _this.sourcesListenerKeys_ = null;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.sourceZ_ = 0;\n        var targetExtent = targetTileGrid.getTileCoordExtent(_this.wrappedTileCoord_);\n        var maxTargetExtent = _this.targetTileGrid_.getExtent();\n        var maxSourceExtent = _this.sourceTileGrid_.getExtent();\n        var limitedTargetExtent = maxTargetExtent\n            ? getIntersection(targetExtent, maxTargetExtent)\n            : targetExtent;\n        if (getArea(limitedTargetExtent) === 0) {\n            // Tile is completely outside range -> EMPTY\n            // TODO: is it actually correct that the source even creates the tile ?\n            _this.state = TileState.EMPTY;\n            return _this;\n        }\n        var sourceProjExtent = sourceProj.getExtent();\n        if (sourceProjExtent) {\n            if (!maxSourceExtent) {\n                maxSourceExtent = sourceProjExtent;\n            }\n            else {\n                maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n            }\n        }\n        var targetResolution = targetTileGrid.getResolution(_this.wrappedTileCoord_[0]);\n        var sourceResolution = calculateSourceExtentResolution(sourceProj, targetProj, limitedTargetExtent, targetResolution);\n        if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n            // invalid sourceResolution -> EMPTY\n            // probably edges of the projections when no extent is defined\n            _this.state = TileState.EMPTY;\n            return _this;\n        }\n        var errorThresholdInPixels = opt_errorThreshold !== undefined ? opt_errorThreshold : ERROR_THRESHOLD;\n        /**\n         * @private\n         * @type {!import(\"./Triangulation.js\").default}\n         */\n        _this.triangulation_ = new Triangulation(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution);\n        if (_this.triangulation_.getTriangles().length === 0) {\n            // no valid triangles -> EMPTY\n            _this.state = TileState.EMPTY;\n            return _this;\n        }\n        _this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\n        var sourceExtent = _this.triangulation_.calculateSourceExtent();\n        if (maxSourceExtent) {\n            if (sourceProj.canWrapX()) {\n                sourceExtent[1] = clamp(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);\n                sourceExtent[3] = clamp(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);\n            }\n            else {\n                sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n            }\n        }\n        if (!getArea(sourceExtent)) {\n            _this.state = TileState.EMPTY;\n        }\n        else {\n            var sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(sourceExtent, _this.sourceZ_);\n            for (var srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n                for (var srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n                    var tile = getTileFunction(_this.sourceZ_, srcX, srcY, pixelRatio);\n                    if (tile) {\n                        _this.sourceTiles_.push(tile);\n                    }\n                }\n            }\n            if (_this.sourceTiles_.length === 0) {\n                _this.state = TileState.EMPTY;\n            }\n        }\n        return _this;\n    }\n    /**\n     * Get the HTML Canvas element for this tile.\n     * @return {HTMLCanvasElement} Canvas.\n     */\n    ReprojTile.prototype.getImage = function () {\n        return this.canvas_;\n    };\n    /**\n     * @private\n     */\n    ReprojTile.prototype.reproject_ = function () {\n        var sources = [];\n        this.sourceTiles_.forEach(function (tile, i, arr) {\n            if (tile && tile.getState() == TileState.LOADED) {\n                sources.push({\n                    extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),\n                    image: tile.getImage(),\n                });\n            }\n        }.bind(this));\n        this.sourceTiles_.length = 0;\n        if (sources.length === 0) {\n            this.state = TileState.ERROR;\n        }\n        else {\n            var z = this.wrappedTileCoord_[0];\n            var size = this.targetTileGrid_.getTileSize(z);\n            var width = typeof size === 'number' ? size : size[0];\n            var height = typeof size === 'number' ? size : size[1];\n            var targetResolution = this.targetTileGrid_.getResolution(z);\n            var sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);\n            var targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);\n            this.canvas_ = renderReprojected(width, height, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, this.renderEdges_, this.contextOptions_);\n            this.state = TileState.LOADED;\n        }\n        this.changed();\n    };\n    /**\n     * Load not yet loaded URI.\n     */\n    ReprojTile.prototype.load = function () {\n        if (this.state == TileState.IDLE) {\n            this.state = TileState.LOADING;\n            this.changed();\n            var leftToLoad_1 = 0;\n            this.sourcesListenerKeys_ = [];\n            this.sourceTiles_.forEach(function (tile, i, arr) {\n                var state = tile.getState();\n                if (state == TileState.IDLE || state == TileState.LOADING) {\n                    leftToLoad_1++;\n                    var sourceListenKey_1 = listen(tile, EventType.CHANGE, function (e) {\n                        var state = tile.getState();\n                        if (state == TileState.LOADED ||\n                            state == TileState.ERROR ||\n                            state == TileState.EMPTY) {\n                            unlistenByKey(sourceListenKey_1);\n                            leftToLoad_1--;\n                            if (leftToLoad_1 === 0) {\n                                this.unlistenSources_();\n                                this.reproject_();\n                            }\n                        }\n                    }, this);\n                    this.sourcesListenerKeys_.push(sourceListenKey_1);\n                }\n            }.bind(this));\n            if (leftToLoad_1 === 0) {\n                setTimeout(this.reproject_.bind(this), 0);\n            }\n            else {\n                this.sourceTiles_.forEach(function (tile, i, arr) {\n                    var state = tile.getState();\n                    if (state == TileState.IDLE) {\n                        tile.load();\n                    }\n                });\n            }\n        }\n    };\n    /**\n     * @private\n     */\n    ReprojTile.prototype.unlistenSources_ = function () {\n        this.sourcesListenerKeys_.forEach(unlistenByKey);\n        this.sourcesListenerKeys_ = null;\n    };\n    return ReprojTile;\n}(Tile));\nexport default ReprojTile;\n//# sourceMappingURL=Tile.js.map","/**\n * @module ol/size\n */\n/**\n * An array of numbers representing a size: `[width, height]`.\n * @typedef {Array<number>} Size\n * @api\n */\n/**\n * Returns a buffered size.\n * @param {Size} size Size.\n * @param {number} num The amount by which to buffer.\n * @param {Size} [opt_size] Optional reusable size array.\n * @return {Size} The buffered size.\n */\nexport function buffer(size, num, opt_size) {\n    if (opt_size === undefined) {\n        opt_size = [0, 0];\n    }\n    opt_size[0] = size[0] + 2 * num;\n    opt_size[1] = size[1] + 2 * num;\n    return opt_size;\n}\n/**\n * Determines if a size has a positive area.\n * @param {Size} size The size to test.\n * @return {boolean} The size has a positive area.\n */\nexport function hasArea(size) {\n    return size[0] > 0 && size[1] > 0;\n}\n/**\n * Returns a size scaled by a ratio. The result will be an array of integers.\n * @param {Size} size Size.\n * @param {number} ratio Ratio.\n * @param {Size} [opt_size] Optional reusable size array.\n * @return {Size} The scaled size.\n */\nexport function scale(size, ratio, opt_size) {\n    if (opt_size === undefined) {\n        opt_size = [0, 0];\n    }\n    opt_size[0] = (size[0] * ratio + 0.5) | 0;\n    opt_size[1] = (size[1] * ratio + 0.5) | 0;\n    return opt_size;\n}\n/**\n * Returns an `Size` array for the passed in number (meaning: square) or\n * `Size` array.\n * (meaning: non-square),\n * @param {number|Size} size Width and height.\n * @param {Size} [opt_size] Optional reusable size array.\n * @return {Size} Size.\n * @api\n */\nexport function toSize(size, opt_size) {\n    if (Array.isArray(size)) {\n        return size;\n    }\n    else {\n        if (opt_size === undefined) {\n            opt_size = [size, size];\n        }\n        else {\n            opt_size[0] = size;\n            opt_size[1] = size;\n        }\n        return opt_size;\n    }\n}\n//# sourceMappingURL=size.js.map","/**\n * @module ol/rotationconstraint\n */\nimport { toRadians } from './math.js';\n/**\n * @typedef {function((number|undefined), boolean=): (number|undefined)} Type\n */\n/**\n * @param {number|undefined} rotation Rotation.\n * @return {number|undefined} Rotation.\n */\nexport function disable(rotation) {\n    if (rotation !== undefined) {\n        return 0;\n    }\n    else {\n        return undefined;\n    }\n}\n/**\n * @param {number|undefined} rotation Rotation.\n * @return {number|undefined} Rotation.\n */\nexport function none(rotation) {\n    if (rotation !== undefined) {\n        return rotation;\n    }\n    else {\n        return undefined;\n    }\n}\n/**\n * @param {number} n N.\n * @return {Type} Rotation constraint.\n */\nexport function createSnapToN(n) {\n    var theta = (2 * Math.PI) / n;\n    return (\n    /**\n     * @param {number|undefined} rotation Rotation.\n     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Rotation.\n     */\n    function (rotation, opt_isMoving) {\n        if (opt_isMoving) {\n            return rotation;\n        }\n        if (rotation !== undefined) {\n            rotation = Math.floor(rotation / theta + 0.5) * theta;\n            return rotation;\n        }\n        else {\n            return undefined;\n        }\n    });\n}\n/**\n * @param {number} [opt_tolerance] Tolerance.\n * @return {Type} Rotation constraint.\n */\nexport function createSnapToZero(opt_tolerance) {\n    var tolerance = opt_tolerance || toRadians(5);\n    return (\n    /**\n     * @param {number|undefined} rotation Rotation.\n     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Rotation.\n     */\n    function (rotation, opt_isMoving) {\n        if (opt_isMoving) {\n            return rotation;\n        }\n        if (rotation !== undefined) {\n            if (Math.abs(rotation) <= tolerance) {\n                return 0;\n            }\n            else {\n                return rotation;\n            }\n        }\n        else {\n            return undefined;\n        }\n    });\n}\n//# sourceMappingURL=rotationconstraint.js.map","/**\n * @module ol/reproj/common\n */\n/**\n * Default maximum allowed threshold  (in pixels) for reprojection\n * triangulation.\n * @type {number}\n */\nexport var ERROR_THRESHOLD = 0.5;\n/**\n * Enable automatic reprojection of raster sources. Default is `true`.\n * TODO: decide if we want to expose this as a build flag or remove it\n * @type {boolean}\n */\nexport var ENABLE_RASTER_REPROJECTION = true;\n//# sourceMappingURL=common.js.map","/**\n * @module ol/resolutionconstraint\n */\nimport { clamp } from './math.js';\nimport { getHeight, getWidth } from './extent.js';\nimport { linearFindNearest } from './array.js';\n/**\n * @typedef {function((number|undefined), number, import(\"./size.js\").Size, boolean=): (number|undefined)} Type\n */\n/**\n * Returns a modified resolution taking into account the viewport size and maximum\n * allowed extent.\n * @param {number} resolution Resolution\n * @param {import(\"./extent.js\").Extent} maxExtent Maximum allowed extent.\n * @param {import(\"./size.js\").Size} viewportSize Viewport size.\n * @param {boolean} showFullExtent Whether to show the full extent.\n * @return {number} Capped resolution.\n */\nfunction getViewportClampedResolution(resolution, maxExtent, viewportSize, showFullExtent) {\n    var xResolution = getWidth(maxExtent) / viewportSize[0];\n    var yResolution = getHeight(maxExtent) / viewportSize[1];\n    if (showFullExtent) {\n        return Math.min(resolution, Math.max(xResolution, yResolution));\n    }\n    return Math.min(resolution, Math.min(xResolution, yResolution));\n}\n/**\n * Returns a modified resolution to be between maxResolution and minResolution while\n * still allowing the value to be slightly out of bounds.\n * Note: the computation is based on the logarithm function (ln):\n *  - at 1, ln(x) is 0\n *  - above 1, ln(x) keeps increasing but at a much slower pace than x\n * The final result is clamped to prevent getting too far away from bounds.\n * @param {number} resolution Resolution.\n * @param {number} maxResolution Max resolution.\n * @param {number} minResolution Min resolution.\n * @return {number} Smoothed resolution.\n */\nfunction getSmoothClampedResolution(resolution, maxResolution, minResolution) {\n    var result = Math.min(resolution, maxResolution);\n    var ratio = 50;\n    result *=\n        Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio +\n            1;\n    if (minResolution) {\n        result = Math.max(result, minResolution);\n        result /=\n            Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) /\n                ratio +\n                1;\n    }\n    return clamp(result, minResolution / 2, maxResolution * 2);\n}\n/**\n * @param {Array<number>} resolutions Resolutions.\n * @param {boolean} [opt_smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\n * @param {import(\"./extent.js\").Extent} [opt_maxExtent] Maximum allowed extent.\n * @param {boolean} [opt_showFullExtent] If true, allows us to show the full extent. Default: false.\n * @return {Type} Zoom function.\n */\nexport function createSnapToResolutions(resolutions, opt_smooth, opt_maxExtent, opt_showFullExtent) {\n    return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} direction Direction.\n     * @param {import(\"./size.js\").Size} size Viewport size.\n     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, direction, size, opt_isMoving) {\n        if (resolution !== undefined) {\n            var maxResolution = resolutions[0];\n            var minResolution = resolutions[resolutions.length - 1];\n            var cappedMaxRes = opt_maxExtent\n                ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent)\n                : maxResolution;\n            // during interacting or animating, allow intermediary values\n            if (opt_isMoving) {\n                var smooth = opt_smooth !== undefined ? opt_smooth : true;\n                if (!smooth) {\n                    return clamp(resolution, minResolution, cappedMaxRes);\n                }\n                return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);\n            }\n            var capped = Math.min(cappedMaxRes, resolution);\n            var z = Math.floor(linearFindNearest(resolutions, capped, direction));\n            if (resolutions[z] > cappedMaxRes && z < resolutions.length - 1) {\n                return resolutions[z + 1];\n            }\n            return resolutions[z];\n        }\n        else {\n            return undefined;\n        }\n    });\n}\n/**\n * @param {number} power Power.\n * @param {number} maxResolution Maximum resolution.\n * @param {number} [opt_minResolution] Minimum resolution.\n * @param {boolean} [opt_smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\n * @param {import(\"./extent.js\").Extent} [opt_maxExtent] Maximum allowed extent.\n * @param {boolean} [opt_showFullExtent] If true, allows us to show the full extent. Default: false.\n * @return {Type} Zoom function.\n */\nexport function createSnapToPower(power, maxResolution, opt_minResolution, opt_smooth, opt_maxExtent, opt_showFullExtent) {\n    return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} direction Direction.\n     * @param {import(\"./size.js\").Size} size Viewport size.\n     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, direction, size, opt_isMoving) {\n        if (resolution !== undefined) {\n            var cappedMaxRes = opt_maxExtent\n                ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent)\n                : maxResolution;\n            var minResolution = opt_minResolution !== undefined ? opt_minResolution : 0;\n            // during interacting or animating, allow intermediary values\n            if (opt_isMoving) {\n                var smooth = opt_smooth !== undefined ? opt_smooth : true;\n                if (!smooth) {\n                    return clamp(resolution, minResolution, cappedMaxRes);\n                }\n                return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);\n            }\n            var tolerance = 1e-9;\n            var minZoomLevel = Math.ceil(Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance);\n            var offset = -direction * (0.5 - tolerance) + 0.5;\n            var capped = Math.min(cappedMaxRes, resolution);\n            var cappedZoomLevel = Math.floor(Math.log(maxResolution / capped) / Math.log(power) + offset);\n            var zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);\n            var newResolution = maxResolution / Math.pow(power, zoomLevel);\n            return clamp(newResolution, minResolution, cappedMaxRes);\n        }\n        else {\n            return undefined;\n        }\n    });\n}\n/**\n * @param {number} maxResolution Max resolution.\n * @param {number} minResolution Min resolution.\n * @param {boolean} [opt_smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\n * @param {import(\"./extent.js\").Extent} [opt_maxExtent] Maximum allowed extent.\n * @param {boolean} [opt_showFullExtent] If true, allows us to show the full extent. Default: false.\n * @return {Type} Zoom function.\n */\nexport function createMinMaxResolution(maxResolution, minResolution, opt_smooth, opt_maxExtent, opt_showFullExtent) {\n    return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} direction Direction.\n     * @param {import(\"./size.js\").Size} size Viewport size.\n     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, direction, size, opt_isMoving) {\n        if (resolution !== undefined) {\n            var cappedMaxRes = opt_maxExtent\n                ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent)\n                : maxResolution;\n            var smooth = opt_smooth !== undefined ? opt_smooth : true;\n            if (!smooth || !opt_isMoving) {\n                return clamp(resolution, minResolution, cappedMaxRes);\n            }\n            return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);\n        }\n        else {\n            return undefined;\n        }\n    });\n}\n//# sourceMappingURL=resolutionconstraint.js.map"],"sourceRoot":""}
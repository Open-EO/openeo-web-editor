{"version":3,"file":"js/5624.56a54c83.js","mappings":"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","sources":["webpack://@openeo/web-editor/./node_modules/ol/functions.js","webpack://@openeo/web-editor/./node_modules/ol/geom/Geometry.js","webpack://@openeo/web-editor/./node_modules/ol/geom/GeometryCollection.js","webpack://@openeo/web-editor/./node_modules/ol/geom/LineString.js","webpack://@openeo/web-editor/./node_modules/ol/geom/LinearRing.js","webpack://@openeo/web-editor/./node_modules/ol/geom/MultiLineString.js","webpack://@openeo/web-editor/./node_modules/ol/geom/MultiPoint.js","webpack://@openeo/web-editor/./node_modules/ol/geom/MultiPolygon.js","webpack://@openeo/web-editor/./node_modules/ol/geom/Point.js","webpack://@openeo/web-editor/./node_modules/ol/geom/Polygon.js","webpack://@openeo/web-editor/./node_modules/ol/geom/SimpleGeometry.js","webpack://@openeo/web-editor/./node_modules/ol/geom/flat/area.js","webpack://@openeo/web-editor/./node_modules/ol/geom/flat/center.js","webpack://@openeo/web-editor/./node_modules/ol/geom/flat/closest.js","webpack://@openeo/web-editor/./node_modules/ol/geom/flat/contains.js","webpack://@openeo/web-editor/./node_modules/ol/geom/flat/deflate.js","webpack://@openeo/web-editor/./node_modules/ol/geom/flat/inflate.js","webpack://@openeo/web-editor/./node_modules/ol/geom/flat/interiorpoint.js","webpack://@openeo/web-editor/./node_modules/ol/geom/flat/interpolate.js","webpack://@openeo/web-editor/./node_modules/ol/geom/flat/intersectsextent.js","webpack://@openeo/web-editor/./node_modules/ol/geom/flat/length.js","webpack://@openeo/web-editor/./node_modules/ol/geom/flat/linechunk.js","webpack://@openeo/web-editor/./node_modules/ol/geom/flat/reverse.js","webpack://@openeo/web-editor/./node_modules/ol/geom/flat/orient.js","webpack://@openeo/web-editor/./node_modules/ol/geom/flat/segments.js","webpack://@openeo/web-editor/./node_modules/ol/geom/flat/simplify.js","webpack://@openeo/web-editor/./node_modules/ol/geom/flat/straightchunk.js","webpack://@openeo/web-editor/./node_modules/ol/geom/flat/textpath.js","webpack://@openeo/web-editor/./node_modules/ol/geom/flat/transform.js"],"sourcesContent":["/**\n * @module ol/functions\n */\n\nimport {equals as arrayEquals} from './array.js';\n\n/**\n * Always returns true.\n * @return {boolean} true.\n */\nexport function TRUE() {\n  return true;\n}\n\n/**\n * Always returns false.\n * @return {boolean} false.\n */\nexport function FALSE() {\n  return false;\n}\n\n/**\n * A reusable function, used e.g. as a default for callbacks.\n *\n * @return {void} Nothing.\n */\nexport function VOID() {}\n\n/**\n * Wrap a function in another function that remembers the last return.  If the\n * returned function is called twice in a row with the same arguments and the same\n * this object, it will return the value from the first call in the second call.\n *\n * @param {function(...any): ReturnType} fn The function to memoize.\n * @return {function(...any): ReturnType} The memoized function.\n * @template ReturnType\n */\nexport function memoizeOne(fn) {\n  let called = false;\n\n  /** @type {ReturnType} */\n  let lastResult;\n\n  /** @type {Array<any>} */\n  let lastArgs;\n\n  let lastThis;\n\n  return function () {\n    const nextArgs = Array.prototype.slice.call(arguments);\n    if (!called || this !== lastThis || !arrayEquals(nextArgs, lastArgs)) {\n      called = true;\n      lastThis = this;\n      lastArgs = nextArgs;\n      lastResult = fn.apply(this, arguments);\n    }\n    return lastResult;\n  };\n}\n\n/**\n * @template T\n * @param {function(): (T | Promise<T>)} getter A function that returns a value or a promise for a value.\n * @return {Promise<T>} A promise for the value.\n */\nexport function toPromise(getter) {\n  function promiseGetter() {\n    let value;\n    try {\n      value = getter();\n    } catch (err) {\n      return Promise.reject(err);\n    }\n    if (value instanceof Promise) {\n      return value;\n    }\n    return Promise.resolve(value);\n  }\n  return promiseGetter();\n}\n","/**\n * @module ol/geom/Geometry\n */\nimport BaseObject from '../Object.js';\nimport {abstract} from '../util.js';\nimport {\n  compose as composeTransform,\n  create as createTransform,\n} from '../transform.js';\nimport {\n  createEmpty,\n  createOrUpdateEmpty,\n  getHeight,\n  returnOrUpdate,\n} from '../extent.js';\nimport {get as getProjection, getTransform} from '../proj.js';\nimport {memoizeOne} from '../functions.js';\nimport {transform2D} from './flat/transform.js';\n\n/**\n * @typedef {'XY' | 'XYZ' | 'XYM' | 'XYZM'} GeometryLayout\n * The coordinate layout for geometries, indicating whether a 3rd or 4th z ('Z')\n * or measure ('M') coordinate is available.\n */\n\n/**\n * @typedef {'Point' | 'LineString' | 'LinearRing' | 'Polygon' | 'MultiPoint' | 'MultiLineString' | 'MultiPolygon' | 'GeometryCollection' | 'Circle'} Type\n * The geometry type.  One of `'Point'`, `'LineString'`, `'LinearRing'`,\n * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,\n * `'GeometryCollection'`, or `'Circle'`.\n */\n\n/**\n * @type {import(\"../transform.js\").Transform}\n */\nconst tmpTransform = createTransform();\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for vector geometries.\n *\n * To get notified of changes to the geometry, register a listener for the\n * generic `change` event on your geometry instance.\n *\n * @abstract\n * @api\n */\nclass Geometry extends BaseObject {\n  constructor() {\n    super();\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.extent_ = createEmpty();\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.extentRevision_ = -1;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.simplifiedGeometryRevision = 0;\n\n    /**\n     * Get a transformed and simplified version of the geometry.\n     * @abstract\n     * @param {number} revision The geometry revision.\n     * @param {number} squaredTolerance Squared tolerance.\n     * @param {import(\"../proj.js\").TransformFunction} [transform] Optional transform function.\n     * @return {Geometry} Simplified geometry.\n     */\n    this.simplifyTransformedInternal = memoizeOne(\n      (revision, squaredTolerance, transform) => {\n        if (!transform) {\n          return this.getSimplifiedGeometry(squaredTolerance);\n        }\n        const clone = this.clone();\n        clone.applyTransform(transform);\n        return clone.getSimplifiedGeometry(squaredTolerance);\n      },\n    );\n  }\n\n  /**\n   * Get a transformed and simplified version of the geometry.\n   * @abstract\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../proj.js\").TransformFunction} [transform] Optional transform function.\n   * @return {Geometry} Simplified geometry.\n   */\n  simplifyTransformed(squaredTolerance, transform) {\n    return this.simplifyTransformedInternal(\n      this.getRevision(),\n      squaredTolerance,\n      transform,\n    );\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @abstract\n   * @return {!Geometry} Clone.\n   */\n  clone() {\n    return abstract();\n  }\n\n  /**\n   * @abstract\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    return abstract();\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @return {boolean} Contains (x, y).\n   */\n  containsXY(x, y) {\n    const coord = this.getClosestPoint([x, y]);\n    return coord[0] === x && coord[1] === y;\n  }\n\n  /**\n   * Return the closest point of the geometry to the passed point as\n   * {@link module:ol/coordinate~Coordinate coordinate}.\n   * @param {import(\"../coordinate.js\").Coordinate} point Point.\n   * @param {import(\"../coordinate.js\").Coordinate} [closestPoint] Closest point.\n   * @return {import(\"../coordinate.js\").Coordinate} Closest point.\n   * @api\n   */\n  getClosestPoint(point, closestPoint) {\n    closestPoint = closestPoint ? closestPoint : [NaN, NaN];\n    this.closestPointXY(point[0], point[1], closestPoint, Infinity);\n    return closestPoint;\n  }\n\n  /**\n   * Returns true if this geometry includes the specified coordinate. If the\n   * coordinate is on the boundary of the geometry, returns false.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @return {boolean} Contains coordinate.\n   * @api\n   */\n  intersectsCoordinate(coordinate) {\n    return this.containsXY(coordinate[0], coordinate[1]);\n  }\n\n  /**\n   * @abstract\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @protected\n   * @return {import(\"../extent.js\").Extent} extent Extent.\n   */\n  computeExtent(extent) {\n    return abstract();\n  }\n\n  /**\n   * Get the extent of the geometry.\n   * @param {import(\"../extent.js\").Extent} [extent] Extent.\n   * @return {import(\"../extent.js\").Extent} extent Extent.\n   * @api\n   */\n  getExtent(extent) {\n    if (this.extentRevision_ != this.getRevision()) {\n      const extent = this.computeExtent(this.extent_);\n      if (isNaN(extent[0]) || isNaN(extent[1])) {\n        createOrUpdateEmpty(extent);\n      }\n      this.extentRevision_ = this.getRevision();\n    }\n    return returnOrUpdate(this.extent_, extent);\n  }\n\n  /**\n   * Rotate the geometry around a given coordinate. This modifies the geometry\n   * coordinates in place.\n   * @abstract\n   * @param {number} angle Rotation angle in radians.\n   * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\n   * @api\n   */\n  rotate(angle, anchor) {\n    abstract();\n  }\n\n  /**\n   * Scale the geometry (with an optional origin).  This modifies the geometry\n   * coordinates in place.\n   * @abstract\n   * @param {number} sx The scaling factor in the x-direction.\n   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).\n   * @param {import(\"../coordinate.js\").Coordinate} [anchor] The scale origin (defaults to the center\n   *     of the geometry extent).\n   * @api\n   */\n  scale(sx, sy, anchor) {\n    abstract();\n  }\n\n  /**\n   * Create a simplified version of this geometry.  For linestrings, this uses\n   * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)\n   * algorithm.  For polygons, a quantization-based\n   * simplification is used to preserve topology.\n   * @param {number} tolerance The tolerance distance for simplification.\n   * @return {Geometry} A new, simplified version of the original geometry.\n   * @api\n   */\n  simplify(tolerance) {\n    return this.getSimplifiedGeometry(tolerance * tolerance);\n  }\n\n  /**\n   * Create a simplified version of this geometry using the Douglas Peucker\n   * algorithm.\n   * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.\n   * @abstract\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {Geometry} Simplified geometry.\n   */\n  getSimplifiedGeometry(squaredTolerance) {\n    return abstract();\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @abstract\n   * @return {Type} Geometry type.\n   */\n  getType() {\n    return abstract();\n  }\n\n  /**\n   * Apply a transform function to the coordinates of the geometry.\n   * The geometry is modified in place.\n   * If you do not want the geometry modified in place, first `clone()` it and\n   * then use this function on the clone.\n   * @abstract\n   * @param {import(\"../proj.js\").TransformFunction} transformFn Transform function.\n   * Called with a flat array of geometry coordinates.\n   */\n  applyTransform(transformFn) {\n    abstract();\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @abstract\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   */\n  intersectsExtent(extent) {\n    return abstract();\n  }\n\n  /**\n   * Translate the geometry.  This modifies the geometry coordinates in place.  If\n   * instead you want a new geometry, first `clone()` this geometry.\n   * @abstract\n   * @param {number} deltaX Delta X.\n   * @param {number} deltaY Delta Y.\n   * @api\n   */\n  translate(deltaX, deltaY) {\n    abstract();\n  }\n\n  /**\n   * Transform each coordinate of the geometry from one coordinate reference\n   * system to another. The geometry is modified in place.\n   * For example, a line will be transformed to a line and a circle to a circle.\n   * If you do not want the geometry modified in place, first `clone()` it and\n   * then use this function on the clone.\n   *\n   * @param {import(\"../proj.js\").ProjectionLike} source The current projection.  Can be a\n   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n   * @param {import(\"../proj.js\").ProjectionLike} destination The desired projection.  Can be a\n   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n   * @return {this} This geometry.  Note that original geometry is\n   *     modified in place.\n   * @api\n   */\n  transform(source, destination) {\n    /** @type {import(\"../proj/Projection.js\").default} */\n    const sourceProj = getProjection(source);\n    const transformFn =\n      sourceProj.getUnits() == 'tile-pixels'\n        ? function (inCoordinates, outCoordinates, stride) {\n            const pixelExtent = sourceProj.getExtent();\n            const projectedExtent = sourceProj.getWorldExtent();\n            const scale = getHeight(projectedExtent) / getHeight(pixelExtent);\n            composeTransform(\n              tmpTransform,\n              projectedExtent[0],\n              projectedExtent[3],\n              scale,\n              -scale,\n              0,\n              0,\n              0,\n            );\n            transform2D(\n              inCoordinates,\n              0,\n              inCoordinates.length,\n              stride,\n              tmpTransform,\n              outCoordinates,\n            );\n            return getTransform(sourceProj, destination)(\n              inCoordinates,\n              outCoordinates,\n              stride,\n            );\n          }\n        : getTransform(sourceProj, destination);\n    this.applyTransform(transformFn);\n    return this;\n  }\n}\n\nexport default Geometry;\n","/**\n * @module ol/geom/GeometryCollection\n */\nimport EventType from '../events/EventType.js';\nimport Geometry from './Geometry.js';\nimport {\n  closestSquaredDistanceXY,\n  createOrUpdateEmpty,\n  extend,\n  getCenter,\n} from '../extent.js';\nimport {listen, unlistenByKey} from '../events.js';\n\n/**\n * @classdesc\n * An array of {@link module:ol/geom/Geometry~Geometry} objects.\n *\n * @api\n */\nclass GeometryCollection extends Geometry {\n  /**\n   * @param {Array<Geometry>} geometries Geometries.\n   */\n  constructor(geometries) {\n    super();\n\n    /**\n     * @private\n     * @type {Array<Geometry>}\n     */\n    this.geometries_ = geometries;\n\n    /**\n     * @type {Array<import(\"../events.js\").EventsKey>}\n     */\n    this.changeEventsKeys_ = [];\n\n    this.listenGeometriesChange_();\n  }\n\n  /**\n   * @private\n   */\n  unlistenGeometriesChange_() {\n    this.changeEventsKeys_.forEach(unlistenByKey);\n    this.changeEventsKeys_.length = 0;\n  }\n\n  /**\n   * @private\n   */\n  listenGeometriesChange_() {\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      this.changeEventsKeys_.push(\n        listen(geometries[i], EventType.CHANGE, this.changed, this),\n      );\n    }\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!GeometryCollection} Clone.\n   * @api\n   */\n  clone() {\n    const geometryCollection = new GeometryCollection(\n      cloneGeometries(this.geometries_),\n    );\n    geometryCollection.applyProperties(this);\n    return geometryCollection;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      minSquaredDistance = geometries[i].closestPointXY(\n        x,\n        y,\n        closestPoint,\n        minSquaredDistance,\n      );\n    }\n    return minSquaredDistance;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @return {boolean} Contains (x, y).\n   */\n  containsXY(x, y) {\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      if (geometries[i].containsXY(x, y)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @protected\n   * @return {import(\"../extent.js\").Extent} extent Extent.\n   */\n  computeExtent(extent) {\n    createOrUpdateEmpty(extent);\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      extend(extent, geometries[i].getExtent());\n    }\n    return extent;\n  }\n\n  /**\n   * Return the geometries that make up this geometry collection.\n   * @return {Array<Geometry>} Geometries.\n   * @api\n   */\n  getGeometries() {\n    return cloneGeometries(this.geometries_);\n  }\n\n  /**\n   * @return {Array<Geometry>} Geometries.\n   */\n  getGeometriesArray() {\n    return this.geometries_;\n  }\n\n  /**\n   * @return {Array<Geometry>} Geometries.\n   */\n  getGeometriesArrayRecursive() {\n    /** @type {Array<Geometry>} */\n    let geometriesArray = [];\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      if (geometries[i].getType() === this.getType()) {\n        geometriesArray = geometriesArray.concat(\n          /** @type {GeometryCollection} */ (\n            geometries[i]\n          ).getGeometriesArrayRecursive(),\n        );\n      } else {\n        geometriesArray.push(geometries[i]);\n      }\n    }\n    return geometriesArray;\n  }\n\n  /**\n   * Create a simplified version of this geometry using the Douglas Peucker algorithm.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {GeometryCollection} Simplified GeometryCollection.\n   */\n  getSimplifiedGeometry(squaredTolerance) {\n    if (this.simplifiedGeometryRevision !== this.getRevision()) {\n      this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n      this.simplifiedGeometryRevision = this.getRevision();\n    }\n    if (\n      squaredTolerance < 0 ||\n      (this.simplifiedGeometryMaxMinSquaredTolerance !== 0 &&\n        squaredTolerance < this.simplifiedGeometryMaxMinSquaredTolerance)\n    ) {\n      return this;\n    }\n\n    const simplifiedGeometries = [];\n    const geometries = this.geometries_;\n    let simplified = false;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      const geometry = geometries[i];\n      const simplifiedGeometry =\n        geometry.getSimplifiedGeometry(squaredTolerance);\n      simplifiedGeometries.push(simplifiedGeometry);\n      if (simplifiedGeometry !== geometry) {\n        simplified = true;\n      }\n    }\n    if (simplified) {\n      const simplifiedGeometryCollection = new GeometryCollection(\n        simplifiedGeometries,\n      );\n      return simplifiedGeometryCollection;\n    }\n    this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;\n    return this;\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   */\n  getType() {\n    return 'GeometryCollection';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   */\n  intersectsExtent(extent) {\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      if (geometries[i].intersectsExtent(extent)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @return {boolean} Is empty.\n   */\n  isEmpty() {\n    return this.geometries_.length === 0;\n  }\n\n  /**\n   * Rotate the geometry around a given coordinate. This modifies the geometry\n   * coordinates in place.\n   * @param {number} angle Rotation angle in radians.\n   * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\n   * @api\n   */\n  rotate(angle, anchor) {\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      geometries[i].rotate(angle, anchor);\n    }\n    this.changed();\n  }\n\n  /**\n   * Scale the geometry (with an optional origin).  This modifies the geometry\n   * coordinates in place.\n   * @abstract\n   * @param {number} sx The scaling factor in the x-direction.\n   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).\n   * @param {import(\"../coordinate.js\").Coordinate} [anchor] The scale origin (defaults to the center\n   *     of the geometry extent).\n   * @api\n   */\n  scale(sx, sy, anchor) {\n    if (!anchor) {\n      anchor = getCenter(this.getExtent());\n    }\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      geometries[i].scale(sx, sy, anchor);\n    }\n    this.changed();\n  }\n\n  /**\n   * Set the geometries that make up this geometry collection.\n   * @param {Array<Geometry>} geometries Geometries.\n   * @api\n   */\n  setGeometries(geometries) {\n    this.setGeometriesArray(cloneGeometries(geometries));\n  }\n\n  /**\n   * @param {Array<Geometry>} geometries Geometries.\n   */\n  setGeometriesArray(geometries) {\n    this.unlistenGeometriesChange_();\n    this.geometries_ = geometries;\n    this.listenGeometriesChange_();\n    this.changed();\n  }\n\n  /**\n   * Apply a transform function to the coordinates of the geometry.\n   * The geometry is modified in place.\n   * If you do not want the geometry modified in place, first `clone()` it and\n   * then use this function on the clone.\n   * @param {import(\"../proj.js\").TransformFunction} transformFn Transform function.\n   * Called with a flat array of geometry coordinates.\n   * @api\n   */\n  applyTransform(transformFn) {\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      geometries[i].applyTransform(transformFn);\n    }\n    this.changed();\n  }\n\n  /**\n   * Translate the geometry.  This modifies the geometry coordinates in place.  If\n   * instead you want a new geometry, first `clone()` this geometry.\n   * @param {number} deltaX Delta X.\n   * @param {number} deltaY Delta Y.\n   * @api\n   */\n  translate(deltaX, deltaY) {\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      geometries[i].translate(deltaX, deltaY);\n    }\n    this.changed();\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    this.unlistenGeometriesChange_();\n    super.disposeInternal();\n  }\n}\n\n/**\n * @param {Array<Geometry>} geometries Geometries.\n * @return {Array<Geometry>} Cloned geometries.\n */\nfunction cloneGeometries(geometries) {\n  return geometries.map((geometry) => geometry.clone());\n}\n\nexport default GeometryCollection;\n","/**\n * @module ol/geom/LineString\n */\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {assignClosestPoint, maxSquaredDelta} from './flat/closest.js';\nimport {closestSquaredDistanceXY} from '../extent.js';\nimport {deflateCoordinates} from './flat/deflate.js';\nimport {douglasPeucker} from './flat/simplify.js';\nimport {extend} from '../array.js';\nimport {forEach as forEachSegment} from './flat/segments.js';\nimport {inflateCoordinates} from './flat/inflate.js';\nimport {interpolatePoint, lineStringCoordinateAtM} from './flat/interpolate.js';\nimport {intersectsLineString} from './flat/intersectsextent.js';\nimport {lineStringLength} from './flat/length.js';\n\n/**\n * @classdesc\n * Linestring geometry.\n *\n * @api\n */\nclass LineString extends SimpleGeometry {\n  /**\n   * @param {Array<import(\"../coordinate.js\").Coordinate>|Array<number>} coordinates Coordinates.\n   *     For internal use, flat coordinates in combination with `layout` are also accepted.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   */\n  constructor(coordinates, layout) {\n    super();\n\n    /**\n     * @private\n     * @type {import(\"../coordinate.js\").Coordinate|null}\n     */\n    this.flatMidpoint_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.flatMidpointRevision_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n\n    if (layout !== undefined && !Array.isArray(coordinates[0])) {\n      this.setFlatCoordinates(\n        layout,\n        /** @type {Array<number>} */ (coordinates),\n      );\n    } else {\n      this.setCoordinates(\n        /** @type {Array<import(\"../coordinate.js\").Coordinate>} */ (\n          coordinates\n        ),\n        layout,\n      );\n    }\n  }\n\n  /**\n   * Append the passed coordinate to the coordinates of the linestring.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @api\n   */\n  appendCoordinate(coordinate) {\n    extend(this.flatCoordinates, coordinate);\n    this.changed();\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!LineString} Clone.\n   * @api\n   */\n  clone() {\n    const lineString = new LineString(\n      this.flatCoordinates.slice(),\n      this.layout,\n    );\n    lineString.applyProperties(this);\n    return lineString;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(\n        maxSquaredDelta(\n          this.flatCoordinates,\n          0,\n          this.flatCoordinates.length,\n          this.stride,\n          0,\n        ),\n      );\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestPoint(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      this.maxDelta_,\n      false,\n      x,\n      y,\n      closestPoint,\n      minSquaredDistance,\n    );\n  }\n\n  /**\n   * Iterate over each segment, calling the provided callback.\n   * If the callback returns a truthy value the function returns that\n   * value immediately. Otherwise the function returns `false`.\n   *\n   * @param {function(this: S, import(\"../coordinate.js\").Coordinate, import(\"../coordinate.js\").Coordinate): T} callback Function\n   *     called for each segment. The function will receive two arguments, the start and end coordinates of the segment.\n   * @return {T|boolean} Value.\n   * @template T,S\n   * @api\n   */\n  forEachSegment(callback) {\n    return forEachSegment(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      callback,\n    );\n  }\n\n  /**\n   * Returns the coordinate at `m` using linear interpolation, or `null` if no\n   * such coordinate exists.\n   *\n   * `extrapolate` controls extrapolation beyond the range of Ms in the\n   * MultiLineString. If `extrapolate` is `true` then Ms less than the first\n   * M will return the first coordinate and Ms greater than the last M will\n   * return the last coordinate.\n   *\n   * @param {number} m M.\n   * @param {boolean} [extrapolate] Extrapolate. Default is `false`.\n   * @return {import(\"../coordinate.js\").Coordinate|null} Coordinate.\n   * @api\n   */\n  getCoordinateAtM(m, extrapolate) {\n    if (this.layout != 'XYM' && this.layout != 'XYZM') {\n      return null;\n    }\n    extrapolate = extrapolate !== undefined ? extrapolate : false;\n    return lineStringCoordinateAtM(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      m,\n      extrapolate,\n    );\n  }\n\n  /**\n   * Return the coordinates of the linestring.\n   * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates.\n   * @api\n   */\n  getCoordinates() {\n    return inflateCoordinates(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n    );\n  }\n\n  /**\n   * Return the coordinate at the provided fraction along the linestring.\n   * The `fraction` is a number between 0 and 1, where 0 is the start of the\n   * linestring and 1 is the end.\n   * @param {number} fraction Fraction.\n   * @param {import(\"../coordinate.js\").Coordinate} [dest] Optional coordinate whose values will\n   *     be modified. If not provided, a new coordinate will be returned.\n   * @return {import(\"../coordinate.js\").Coordinate} Coordinate of the interpolated point.\n   * @api\n   */\n  getCoordinateAt(fraction, dest) {\n    return interpolatePoint(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      fraction,\n      dest,\n      this.stride,\n    );\n  }\n\n  /**\n   * Return the length of the linestring on projected plane.\n   * @return {number} Length (on projected plane).\n   * @api\n   */\n  getLength() {\n    return lineStringLength(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n    );\n  }\n\n  /**\n   * @return {Array<number>} Flat midpoint.\n   */\n  getFlatMidpoint() {\n    if (this.flatMidpointRevision_ != this.getRevision()) {\n      this.flatMidpoint_ = this.getCoordinateAt(\n        0.5,\n        this.flatMidpoint_ ?? undefined,\n      );\n      this.flatMidpointRevision_ = this.getRevision();\n    }\n    return /** @type {Array<number>} */ (this.flatMidpoint_);\n  }\n\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {LineString} Simplified LineString.\n   * @protected\n   */\n  getSimplifiedGeometryInternal(squaredTolerance) {\n    /** @type {Array<number>} */\n    const simplifiedFlatCoordinates = [];\n    simplifiedFlatCoordinates.length = douglasPeucker(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      squaredTolerance,\n      simplifiedFlatCoordinates,\n      0,\n    );\n    return new LineString(simplifiedFlatCoordinates, 'XY');\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   */\n  getType() {\n    return 'LineString';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   */\n  intersectsExtent(extent) {\n    return intersectsLineString(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      extent,\n    );\n  }\n\n  /**\n   * Set the coordinates of the linestring.\n   * @param {!Array<import(\"../coordinate.js\").Coordinate>} coordinates Coordinates.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @api\n   */\n  setCoordinates(coordinates, layout) {\n    this.setLayout(layout, coordinates, 1);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    this.flatCoordinates.length = deflateCoordinates(\n      this.flatCoordinates,\n      0,\n      coordinates,\n      this.stride,\n    );\n    this.changed();\n  }\n}\n\nexport default LineString;\n","/**\n * @module ol/geom/LinearRing\n */\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {assignClosestPoint, maxSquaredDelta} from './flat/closest.js';\nimport {closestSquaredDistanceXY} from '../extent.js';\nimport {deflateCoordinates} from './flat/deflate.js';\nimport {douglasPeucker} from './flat/simplify.js';\nimport {inflateCoordinates} from './flat/inflate.js';\nimport {linearRing as linearRingArea} from './flat/area.js';\n\n/**\n * @classdesc\n * Linear ring geometry. Only used as part of polygon; cannot be rendered\n * on its own.\n *\n * @api\n */\nclass LinearRing extends SimpleGeometry {\n  /**\n   * @param {Array<import(\"../coordinate.js\").Coordinate>|Array<number>} coordinates Coordinates.\n   *     For internal use, flat coordinates in combination with `layout` are also accepted.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   */\n  constructor(coordinates, layout) {\n    super();\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n\n    if (layout !== undefined && !Array.isArray(coordinates[0])) {\n      this.setFlatCoordinates(\n        layout,\n        /** @type {Array<number>} */ (coordinates),\n      );\n    } else {\n      this.setCoordinates(\n        /** @type {Array<import(\"../coordinate.js\").Coordinate>} */ (\n          coordinates\n        ),\n        layout,\n      );\n    }\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!LinearRing} Clone.\n   * @api\n   */\n  clone() {\n    return new LinearRing(this.flatCoordinates.slice(), this.layout);\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(\n        maxSquaredDelta(\n          this.flatCoordinates,\n          0,\n          this.flatCoordinates.length,\n          this.stride,\n          0,\n        ),\n      );\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestPoint(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      this.maxDelta_,\n      true,\n      x,\n      y,\n      closestPoint,\n      minSquaredDistance,\n    );\n  }\n\n  /**\n   * Return the area of the linear ring on projected plane.\n   * @return {number} Area (on projected plane).\n   * @api\n   */\n  getArea() {\n    return linearRingArea(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n    );\n  }\n\n  /**\n   * Return the coordinates of the linear ring.\n   * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates.\n   * @api\n   */\n  getCoordinates() {\n    return inflateCoordinates(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n    );\n  }\n\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {LinearRing} Simplified LinearRing.\n   * @protected\n   */\n  getSimplifiedGeometryInternal(squaredTolerance) {\n    /** @type {Array<number>} */\n    const simplifiedFlatCoordinates = [];\n    simplifiedFlatCoordinates.length = douglasPeucker(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      squaredTolerance,\n      simplifiedFlatCoordinates,\n      0,\n    );\n    return new LinearRing(simplifiedFlatCoordinates, 'XY');\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   */\n  getType() {\n    return 'LinearRing';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   */\n  intersectsExtent(extent) {\n    return false;\n  }\n\n  /**\n   * Set the coordinates of the linear ring.\n   * @param {!Array<import(\"../coordinate.js\").Coordinate>} coordinates Coordinates.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @api\n   */\n  setCoordinates(coordinates, layout) {\n    this.setLayout(layout, coordinates, 1);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    this.flatCoordinates.length = deflateCoordinates(\n      this.flatCoordinates,\n      0,\n      coordinates,\n      this.stride,\n    );\n    this.changed();\n  }\n}\n\nexport default LinearRing;\n","/**\n * @module ol/geom/MultiLineString\n */\nimport LineString from './LineString.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {arrayMaxSquaredDelta, assignClosestArrayPoint} from './flat/closest.js';\nimport {closestSquaredDistanceXY} from '../extent.js';\nimport {deflateCoordinatesArray} from './flat/deflate.js';\nimport {douglasPeuckerArray} from './flat/simplify.js';\nimport {extend} from '../array.js';\nimport {inflateCoordinatesArray} from './flat/inflate.js';\nimport {\n  interpolatePoint,\n  lineStringsCoordinateAtM,\n} from './flat/interpolate.js';\nimport {intersectsLineStringArray} from './flat/intersectsextent.js';\n\n/**\n * @classdesc\n * Multi-linestring geometry.\n *\n * @api\n */\nclass MultiLineString extends SimpleGeometry {\n  /**\n   * @param {Array<Array<import(\"../coordinate.js\").Coordinate>|LineString>|Array<number>} coordinates\n   *     Coordinates or LineString geometries. (For internal use, flat coordinates in\n   *     combination with `layout` and `ends` are also accepted.)\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @param {Array<number>} [ends] Flat coordinate ends for internal use.\n   */\n  constructor(coordinates, layout, ends) {\n    super();\n\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    this.ends_ = [];\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n\n    if (Array.isArray(coordinates[0])) {\n      this.setCoordinates(\n        /** @type {Array<Array<import(\"../coordinate.js\").Coordinate>>} */ (\n          coordinates\n        ),\n        layout,\n      );\n    } else if (layout !== undefined && ends) {\n      this.setFlatCoordinates(\n        layout,\n        /** @type {Array<number>} */ (coordinates),\n      );\n      this.ends_ = ends;\n    } else {\n      const lineStrings = /** @type {Array<LineString>} */ (coordinates);\n      /** @type {Array<number>} */\n      const flatCoordinates = [];\n      const ends = [];\n      for (let i = 0, ii = lineStrings.length; i < ii; ++i) {\n        const lineString = lineStrings[i];\n        extend(flatCoordinates, lineString.getFlatCoordinates());\n        ends.push(flatCoordinates.length);\n      }\n      const layout =\n        lineStrings.length === 0\n          ? this.getLayout()\n          : lineStrings[0].getLayout();\n      this.setFlatCoordinates(layout, flatCoordinates);\n      this.ends_ = ends;\n    }\n  }\n\n  /**\n   * Append the passed linestring to the multilinestring.\n   * @param {LineString} lineString LineString.\n   * @api\n   */\n  appendLineString(lineString) {\n    extend(this.flatCoordinates, lineString.getFlatCoordinates().slice());\n    this.ends_.push(this.flatCoordinates.length);\n    this.changed();\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!MultiLineString} Clone.\n   * @api\n   */\n  clone() {\n    const multiLineString = new MultiLineString(\n      this.flatCoordinates.slice(),\n      this.layout,\n      this.ends_.slice(),\n    );\n    multiLineString.applyProperties(this);\n    return multiLineString;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(\n        arrayMaxSquaredDelta(\n          this.flatCoordinates,\n          0,\n          this.ends_,\n          this.stride,\n          0,\n        ),\n      );\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestArrayPoint(\n      this.flatCoordinates,\n      0,\n      this.ends_,\n      this.stride,\n      this.maxDelta_,\n      false,\n      x,\n      y,\n      closestPoint,\n      minSquaredDistance,\n    );\n  }\n\n  /**\n   * Returns the coordinate at `m` using linear interpolation, or `null` if no\n   * such coordinate exists.\n   *\n   * `extrapolate` controls extrapolation beyond the range of Ms in the\n   * MultiLineString. If `extrapolate` is `true` then Ms less than the first\n   * M will return the first coordinate and Ms greater than the last M will\n   * return the last coordinate.\n   *\n   * `interpolate` controls interpolation between consecutive LineStrings\n   * within the MultiLineString. If `interpolate` is `true` the coordinates\n   * will be linearly interpolated between the last coordinate of one LineString\n   * and the first coordinate of the next LineString.  If `interpolate` is\n   * `false` then the function will return `null` for Ms falling between\n   * LineStrings.\n   *\n   * @param {number} m M.\n   * @param {boolean} [extrapolate] Extrapolate. Default is `false`.\n   * @param {boolean} [interpolate] Interpolate. Default is `false`.\n   * @return {import(\"../coordinate.js\").Coordinate|null} Coordinate.\n   * @api\n   */\n  getCoordinateAtM(m, extrapolate, interpolate) {\n    if (\n      (this.layout != 'XYM' && this.layout != 'XYZM') ||\n      this.flatCoordinates.length === 0\n    ) {\n      return null;\n    }\n    extrapolate = extrapolate !== undefined ? extrapolate : false;\n    interpolate = interpolate !== undefined ? interpolate : false;\n    return lineStringsCoordinateAtM(\n      this.flatCoordinates,\n      0,\n      this.ends_,\n      this.stride,\n      m,\n      extrapolate,\n      interpolate,\n    );\n  }\n\n  /**\n   * Return the coordinates of the multilinestring.\n   * @return {Array<Array<import(\"../coordinate.js\").Coordinate>>} Coordinates.\n   * @api\n   */\n  getCoordinates() {\n    return inflateCoordinatesArray(\n      this.flatCoordinates,\n      0,\n      this.ends_,\n      this.stride,\n    );\n  }\n\n  /**\n   * @return {Array<number>} Ends.\n   */\n  getEnds() {\n    return this.ends_;\n  }\n\n  /**\n   * Return the linestring at the specified index.\n   * @param {number} index Index.\n   * @return {LineString} LineString.\n   * @api\n   */\n  getLineString(index) {\n    if (index < 0 || this.ends_.length <= index) {\n      return null;\n    }\n    return new LineString(\n      this.flatCoordinates.slice(\n        index === 0 ? 0 : this.ends_[index - 1],\n        this.ends_[index],\n      ),\n      this.layout,\n    );\n  }\n\n  /**\n   * Return the linestrings of this multilinestring.\n   * @return {Array<LineString>} LineStrings.\n   * @api\n   */\n  getLineStrings() {\n    const flatCoordinates = this.flatCoordinates;\n    const ends = this.ends_;\n    const layout = this.layout;\n    /** @type {Array<LineString>} */\n    const lineStrings = [];\n    let offset = 0;\n    for (let i = 0, ii = ends.length; i < ii; ++i) {\n      const end = ends[i];\n      const lineString = new LineString(\n        flatCoordinates.slice(offset, end),\n        layout,\n      );\n      lineStrings.push(lineString);\n      offset = end;\n    }\n    return lineStrings;\n  }\n\n  /**\n   * @return {Array<number>} Flat midpoints.\n   */\n  getFlatMidpoints() {\n    /** @type {Array<number>} */\n    const midpoints = [];\n    const flatCoordinates = this.flatCoordinates;\n    let offset = 0;\n    const ends = this.ends_;\n    const stride = this.stride;\n    for (let i = 0, ii = ends.length; i < ii; ++i) {\n      const end = ends[i];\n      const midpoint = interpolatePoint(\n        flatCoordinates,\n        offset,\n        end,\n        stride,\n        0.5,\n      );\n      extend(midpoints, midpoint);\n      offset = end;\n    }\n    return midpoints;\n  }\n\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {MultiLineString} Simplified MultiLineString.\n   * @protected\n   */\n  getSimplifiedGeometryInternal(squaredTolerance) {\n    /** @type {Array<number>} */\n    const simplifiedFlatCoordinates = [];\n    /** @type {Array<number>} */\n    const simplifiedEnds = [];\n    simplifiedFlatCoordinates.length = douglasPeuckerArray(\n      this.flatCoordinates,\n      0,\n      this.ends_,\n      this.stride,\n      squaredTolerance,\n      simplifiedFlatCoordinates,\n      0,\n      simplifiedEnds,\n    );\n    return new MultiLineString(simplifiedFlatCoordinates, 'XY', simplifiedEnds);\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   */\n  getType() {\n    return 'MultiLineString';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   */\n  intersectsExtent(extent) {\n    return intersectsLineStringArray(\n      this.flatCoordinates,\n      0,\n      this.ends_,\n      this.stride,\n      extent,\n    );\n  }\n\n  /**\n   * Set the coordinates of the multilinestring.\n   * @param {!Array<Array<import(\"../coordinate.js\").Coordinate>>} coordinates Coordinates.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @api\n   */\n  setCoordinates(coordinates, layout) {\n    this.setLayout(layout, coordinates, 2);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    const ends = deflateCoordinatesArray(\n      this.flatCoordinates,\n      0,\n      coordinates,\n      this.stride,\n      this.ends_,\n    );\n    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];\n    this.changed();\n  }\n}\n\nexport default MultiLineString;\n","/**\n * @module ol/geom/MultiPoint\n */\nimport Point from './Point.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {closestSquaredDistanceXY, containsXY} from '../extent.js';\nimport {deflateCoordinates} from './flat/deflate.js';\nimport {extend} from '../array.js';\nimport {inflateCoordinates} from './flat/inflate.js';\nimport {squaredDistance as squaredDx} from '../math.js';\n\n/**\n * @classdesc\n * Multi-point geometry.\n *\n * @api\n */\nclass MultiPoint extends SimpleGeometry {\n  /**\n   * @param {Array<import(\"../coordinate.js\").Coordinate>|Array<number>} coordinates Coordinates.\n   *     For internal use, flat coordinates in combination with `layout` are also accepted.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   */\n  constructor(coordinates, layout) {\n    super();\n    if (layout && !Array.isArray(coordinates[0])) {\n      this.setFlatCoordinates(\n        layout,\n        /** @type {Array<number>} */ (coordinates),\n      );\n    } else {\n      this.setCoordinates(\n        /** @type {Array<import(\"../coordinate.js\").Coordinate>} */ (\n          coordinates\n        ),\n        layout,\n      );\n    }\n  }\n\n  /**\n   * Append the passed point to this multipoint.\n   * @param {Point} point Point.\n   * @api\n   */\n  appendPoint(point) {\n    extend(this.flatCoordinates, point.getFlatCoordinates());\n    this.changed();\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!MultiPoint} Clone.\n   * @api\n   */\n  clone() {\n    const multiPoint = new MultiPoint(\n      this.flatCoordinates.slice(),\n      this.layout,\n    );\n    multiPoint.applyProperties(this);\n    return multiPoint;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    const flatCoordinates = this.flatCoordinates;\n    const stride = this.stride;\n    for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n      const squaredDistance = squaredDx(\n        x,\n        y,\n        flatCoordinates[i],\n        flatCoordinates[i + 1],\n      );\n      if (squaredDistance < minSquaredDistance) {\n        minSquaredDistance = squaredDistance;\n        for (let j = 0; j < stride; ++j) {\n          closestPoint[j] = flatCoordinates[i + j];\n        }\n        closestPoint.length = stride;\n      }\n    }\n    return minSquaredDistance;\n  }\n\n  /**\n   * Return the coordinates of the multipoint.\n   * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates.\n   * @api\n   */\n  getCoordinates() {\n    return inflateCoordinates(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n    );\n  }\n\n  /**\n   * Return the point at the specified index.\n   * @param {number} index Index.\n   * @return {Point} Point.\n   * @api\n   */\n  getPoint(index) {\n    const n = this.flatCoordinates.length / this.stride;\n    if (index < 0 || n <= index) {\n      return null;\n    }\n    return new Point(\n      this.flatCoordinates.slice(\n        index * this.stride,\n        (index + 1) * this.stride,\n      ),\n      this.layout,\n    );\n  }\n\n  /**\n   * Return the points of this multipoint.\n   * @return {Array<Point>} Points.\n   * @api\n   */\n  getPoints() {\n    const flatCoordinates = this.flatCoordinates;\n    const layout = this.layout;\n    const stride = this.stride;\n    /** @type {Array<Point>} */\n    const points = [];\n    for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n      const point = new Point(flatCoordinates.slice(i, i + stride), layout);\n      points.push(point);\n    }\n    return points;\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   */\n  getType() {\n    return 'MultiPoint';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   */\n  intersectsExtent(extent) {\n    const flatCoordinates = this.flatCoordinates;\n    const stride = this.stride;\n    for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n      const x = flatCoordinates[i];\n      const y = flatCoordinates[i + 1];\n      if (containsXY(extent, x, y)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Set the coordinates of the multipoint.\n   * @param {!Array<import(\"../coordinate.js\").Coordinate>} coordinates Coordinates.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @api\n   */\n  setCoordinates(coordinates, layout) {\n    this.setLayout(layout, coordinates, 1);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    this.flatCoordinates.length = deflateCoordinates(\n      this.flatCoordinates,\n      0,\n      coordinates,\n      this.stride,\n    );\n    this.changed();\n  }\n}\n\nexport default MultiPoint;\n","/**\n * @module ol/geom/MultiPolygon\n */\nimport MultiPoint from './MultiPoint.js';\nimport Polygon from './Polygon.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {\n  assignClosestMultiArrayPoint,\n  multiArrayMaxSquaredDelta,\n} from './flat/closest.js';\nimport {closestSquaredDistanceXY} from '../extent.js';\nimport {deflateMultiCoordinatesArray} from './flat/deflate.js';\nimport {extend} from '../array.js';\nimport {getInteriorPointsOfMultiArray} from './flat/interiorpoint.js';\nimport {inflateMultiCoordinatesArray} from './flat/inflate.js';\nimport {intersectsLinearRingMultiArray} from './flat/intersectsextent.js';\nimport {\n  linearRingssAreOriented,\n  orientLinearRingsArray,\n} from './flat/orient.js';\nimport {linearRingss as linearRingssArea} from './flat/area.js';\nimport {linearRingss as linearRingssCenter} from './flat/center.js';\nimport {linearRingssContainsXY} from './flat/contains.js';\nimport {quantizeMultiArray} from './flat/simplify.js';\n\n/**\n * @classdesc\n * Multi-polygon geometry.\n *\n * @api\n */\nclass MultiPolygon extends SimpleGeometry {\n  /**\n   * @param {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.\n   *     For internal use, flat coordinates in combination with `layout` and `endss` are also accepted.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @param {Array<Array<number>>} [endss] Array of ends for internal use with flat coordinates.\n   */\n  constructor(coordinates, layout, endss) {\n    super();\n\n    /**\n     * @type {Array<Array<number>>}\n     * @private\n     */\n    this.endss_ = [];\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.flatInteriorPointsRevision_ = -1;\n\n    /**\n     * @private\n     * @type {Array<number>|null}\n     */\n    this.flatInteriorPoints_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.orientedRevision_ = -1;\n\n    /**\n     * @private\n     * @type {Array<number>|null}\n     */\n    this.orientedFlatCoordinates_ = null;\n\n    if (!endss && !Array.isArray(coordinates[0])) {\n      const polygons = /** @type {Array<Polygon>} */ (coordinates);\n      /** @type {Array<number>} */\n      const flatCoordinates = [];\n      const thisEndss = [];\n      for (let i = 0, ii = polygons.length; i < ii; ++i) {\n        const polygon = polygons[i];\n        const offset = flatCoordinates.length;\n        const ends = polygon.getEnds();\n        for (let j = 0, jj = ends.length; j < jj; ++j) {\n          ends[j] += offset;\n        }\n        extend(flatCoordinates, polygon.getFlatCoordinates());\n        thisEndss.push(ends);\n      }\n      layout =\n        polygons.length === 0 ? this.getLayout() : polygons[0].getLayout();\n      coordinates = flatCoordinates;\n      endss = thisEndss;\n    }\n    if (layout !== undefined && endss) {\n      this.setFlatCoordinates(\n        layout,\n        /** @type {Array<number>} */ (coordinates),\n      );\n      this.endss_ = endss;\n    } else {\n      this.setCoordinates(\n        /** @type {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} */ (\n          coordinates\n        ),\n        layout,\n      );\n    }\n  }\n\n  /**\n   * Append the passed polygon to this multipolygon.\n   * @param {Polygon} polygon Polygon.\n   * @api\n   */\n  appendPolygon(polygon) {\n    /** @type {Array<number>} */\n    let ends;\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = polygon.getFlatCoordinates().slice();\n      ends = polygon.getEnds().slice();\n      this.endss_.push();\n    } else {\n      const offset = this.flatCoordinates.length;\n      extend(this.flatCoordinates, polygon.getFlatCoordinates());\n      ends = polygon.getEnds().slice();\n      for (let i = 0, ii = ends.length; i < ii; ++i) {\n        ends[i] += offset;\n      }\n    }\n    this.endss_.push(ends);\n    this.changed();\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!MultiPolygon} Clone.\n   * @api\n   */\n  clone() {\n    const len = this.endss_.length;\n    const newEndss = new Array(len);\n    for (let i = 0; i < len; ++i) {\n      newEndss[i] = this.endss_[i].slice();\n    }\n\n    const multiPolygon = new MultiPolygon(\n      this.flatCoordinates.slice(),\n      this.layout,\n      newEndss,\n    );\n    multiPolygon.applyProperties(this);\n\n    return multiPolygon;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(\n        multiArrayMaxSquaredDelta(\n          this.flatCoordinates,\n          0,\n          this.endss_,\n          this.stride,\n          0,\n        ),\n      );\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestMultiArrayPoint(\n      this.getOrientedFlatCoordinates(),\n      0,\n      this.endss_,\n      this.stride,\n      this.maxDelta_,\n      true,\n      x,\n      y,\n      closestPoint,\n      minSquaredDistance,\n    );\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @return {boolean} Contains (x, y).\n   */\n  containsXY(x, y) {\n    return linearRingssContainsXY(\n      this.getOrientedFlatCoordinates(),\n      0,\n      this.endss_,\n      this.stride,\n      x,\n      y,\n    );\n  }\n\n  /**\n   * Return the area of the multipolygon on projected plane.\n   * @return {number} Area (on projected plane).\n   * @api\n   */\n  getArea() {\n    return linearRingssArea(\n      this.getOrientedFlatCoordinates(),\n      0,\n      this.endss_,\n      this.stride,\n    );\n  }\n\n  /**\n   * Get the coordinate array for this geometry.  This array has the structure\n   * of a GeoJSON coordinate array for multi-polygons.\n   *\n   * @param {boolean} [right] Orient coordinates according to the right-hand\n   *     rule (counter-clockwise for exterior and clockwise for interior rings).\n   *     If `false`, coordinates will be oriented according to the left-hand rule\n   *     (clockwise for exterior and counter-clockwise for interior rings).\n   *     By default, coordinate orientation will depend on how the geometry was\n   *     constructed.\n   * @return {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} Coordinates.\n   * @api\n   */\n  getCoordinates(right) {\n    let flatCoordinates;\n    if (right !== undefined) {\n      flatCoordinates = this.getOrientedFlatCoordinates().slice();\n      orientLinearRingsArray(\n        flatCoordinates,\n        0,\n        this.endss_,\n        this.stride,\n        right,\n      );\n    } else {\n      flatCoordinates = this.flatCoordinates;\n    }\n\n    return inflateMultiCoordinatesArray(\n      flatCoordinates,\n      0,\n      this.endss_,\n      this.stride,\n    );\n  }\n\n  /**\n   * @return {Array<Array<number>>} Endss.\n   */\n  getEndss() {\n    return this.endss_;\n  }\n\n  /**\n   * @return {Array<number>} Flat interior points.\n   */\n  getFlatInteriorPoints() {\n    if (this.flatInteriorPointsRevision_ != this.getRevision()) {\n      const flatCenters = linearRingssCenter(\n        this.flatCoordinates,\n        0,\n        this.endss_,\n        this.stride,\n      );\n      this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(\n        this.getOrientedFlatCoordinates(),\n        0,\n        this.endss_,\n        this.stride,\n        flatCenters,\n      );\n      this.flatInteriorPointsRevision_ = this.getRevision();\n    }\n    return /** @type {Array<number>} */ (this.flatInteriorPoints_);\n  }\n\n  /**\n   * Return the interior points as {@link module:ol/geom/MultiPoint~MultiPoint multipoint}.\n   * @return {MultiPoint} Interior points as XYM coordinates, where M is\n   * the length of the horizontal intersection that the point belongs to.\n   * @api\n   */\n  getInteriorPoints() {\n    return new MultiPoint(this.getFlatInteriorPoints().slice(), 'XYM');\n  }\n\n  /**\n   * @return {Array<number>} Oriented flat coordinates.\n   */\n  getOrientedFlatCoordinates() {\n    if (this.orientedRevision_ != this.getRevision()) {\n      const flatCoordinates = this.flatCoordinates;\n      if (\n        linearRingssAreOriented(flatCoordinates, 0, this.endss_, this.stride)\n      ) {\n        this.orientedFlatCoordinates_ = flatCoordinates;\n      } else {\n        this.orientedFlatCoordinates_ = flatCoordinates.slice();\n        this.orientedFlatCoordinates_.length = orientLinearRingsArray(\n          this.orientedFlatCoordinates_,\n          0,\n          this.endss_,\n          this.stride,\n        );\n      }\n      this.orientedRevision_ = this.getRevision();\n    }\n    return /** @type {Array<number>} */ (this.orientedFlatCoordinates_);\n  }\n\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {MultiPolygon} Simplified MultiPolygon.\n   * @protected\n   */\n  getSimplifiedGeometryInternal(squaredTolerance) {\n    /** @type {Array<number>} */\n    const simplifiedFlatCoordinates = [];\n    /** @type {Array<Array<number>>} */\n    const simplifiedEndss = [];\n    simplifiedFlatCoordinates.length = quantizeMultiArray(\n      this.flatCoordinates,\n      0,\n      this.endss_,\n      this.stride,\n      Math.sqrt(squaredTolerance),\n      simplifiedFlatCoordinates,\n      0,\n      simplifiedEndss,\n    );\n    return new MultiPolygon(simplifiedFlatCoordinates, 'XY', simplifiedEndss);\n  }\n\n  /**\n   * Return the polygon at the specified index.\n   * @param {number} index Index.\n   * @return {Polygon} Polygon.\n   * @api\n   */\n  getPolygon(index) {\n    if (index < 0 || this.endss_.length <= index) {\n      return null;\n    }\n    let offset;\n    if (index === 0) {\n      offset = 0;\n    } else {\n      const prevEnds = this.endss_[index - 1];\n      offset = prevEnds[prevEnds.length - 1];\n    }\n    const ends = this.endss_[index].slice();\n    const end = ends[ends.length - 1];\n    if (offset !== 0) {\n      for (let i = 0, ii = ends.length; i < ii; ++i) {\n        ends[i] -= offset;\n      }\n    }\n    return new Polygon(\n      this.flatCoordinates.slice(offset, end),\n      this.layout,\n      ends,\n    );\n  }\n\n  /**\n   * Return the polygons of this multipolygon.\n   * @return {Array<Polygon>} Polygons.\n   * @api\n   */\n  getPolygons() {\n    const layout = this.layout;\n    const flatCoordinates = this.flatCoordinates;\n    const endss = this.endss_;\n    const polygons = [];\n    let offset = 0;\n    for (let i = 0, ii = endss.length; i < ii; ++i) {\n      const ends = endss[i].slice();\n      const end = ends[ends.length - 1];\n      if (offset !== 0) {\n        for (let j = 0, jj = ends.length; j < jj; ++j) {\n          ends[j] -= offset;\n        }\n      }\n      const polygon = new Polygon(\n        flatCoordinates.slice(offset, end),\n        layout,\n        ends,\n      );\n      polygons.push(polygon);\n      offset = end;\n    }\n    return polygons;\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   */\n  getType() {\n    return 'MultiPolygon';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   */\n  intersectsExtent(extent) {\n    return intersectsLinearRingMultiArray(\n      this.getOrientedFlatCoordinates(),\n      0,\n      this.endss_,\n      this.stride,\n      extent,\n    );\n  }\n\n  /**\n   * Set the coordinates of the multipolygon.\n   * @param {!Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} coordinates Coordinates.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @api\n   */\n  setCoordinates(coordinates, layout) {\n    this.setLayout(layout, coordinates, 3);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    const endss = deflateMultiCoordinatesArray(\n      this.flatCoordinates,\n      0,\n      coordinates,\n      this.stride,\n      this.endss_,\n    );\n    if (endss.length === 0) {\n      this.flatCoordinates.length = 0;\n    } else {\n      const lastEnds = endss[endss.length - 1];\n      this.flatCoordinates.length =\n        lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];\n    }\n    this.changed();\n  }\n}\n\nexport default MultiPolygon;\n","/**\n * @module ol/geom/Point\n */\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {containsXY, createOrUpdateFromCoordinate} from '../extent.js';\nimport {deflateCoordinate} from './flat/deflate.js';\nimport {squaredDistance as squaredDx} from '../math.js';\n\n/**\n * @classdesc\n * Point geometry.\n *\n * @api\n */\nclass Point extends SimpleGeometry {\n  /**\n   * @param {import(\"../coordinate.js\").Coordinate} coordinates Coordinates.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   */\n  constructor(coordinates, layout) {\n    super();\n    this.setCoordinates(coordinates, layout);\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!Point} Clone.\n   * @api\n   */\n  clone() {\n    const point = new Point(this.flatCoordinates.slice(), this.layout);\n    point.applyProperties(this);\n    return point;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    const flatCoordinates = this.flatCoordinates;\n    const squaredDistance = squaredDx(\n      x,\n      y,\n      flatCoordinates[0],\n      flatCoordinates[1],\n    );\n    if (squaredDistance < minSquaredDistance) {\n      const stride = this.stride;\n      for (let i = 0; i < stride; ++i) {\n        closestPoint[i] = flatCoordinates[i];\n      }\n      closestPoint.length = stride;\n      return squaredDistance;\n    }\n    return minSquaredDistance;\n  }\n\n  /**\n   * Return the coordinate of the point.\n   * @return {import(\"../coordinate.js\").Coordinate} Coordinates.\n   * @api\n   */\n  getCoordinates() {\n    return this.flatCoordinates.slice();\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @protected\n   * @return {import(\"../extent.js\").Extent} extent Extent.\n   */\n  computeExtent(extent) {\n    return createOrUpdateFromCoordinate(this.flatCoordinates, extent);\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   */\n  getType() {\n    return 'Point';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   */\n  intersectsExtent(extent) {\n    return containsXY(extent, this.flatCoordinates[0], this.flatCoordinates[1]);\n  }\n\n  /**\n   * @param {!Array<*>} coordinates Coordinates.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @api\n   */\n  setCoordinates(coordinates, layout) {\n    this.setLayout(layout, coordinates, 0);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    this.flatCoordinates.length = deflateCoordinate(\n      this.flatCoordinates,\n      0,\n      coordinates,\n      this.stride,\n    );\n    this.changed();\n  }\n}\n\nexport default Point;\n","/**\n * @module ol/geom/Polygon\n */\nimport LinearRing from './LinearRing.js';\nimport Point from './Point.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {arrayMaxSquaredDelta, assignClosestArrayPoint} from './flat/closest.js';\nimport {closestSquaredDistanceXY, getCenter, isEmpty} from '../extent.js';\nimport {deflateCoordinatesArray} from './flat/deflate.js';\nimport {extend} from '../array.js';\nimport {getInteriorPointOfArray} from './flat/interiorpoint.js';\nimport {inflateCoordinatesArray} from './flat/inflate.js';\nimport {intersectsLinearRingArray} from './flat/intersectsextent.js';\nimport {linearRingsAreOriented, orientLinearRings} from './flat/orient.js';\nimport {linearRings as linearRingsArea} from './flat/area.js';\nimport {linearRingsContainsXY} from './flat/contains.js';\nimport {modulo} from '../math.js';\nimport {quantizeArray} from './flat/simplify.js';\nimport {offset as sphereOffset} from '../sphere.js';\n\n/**\n * @classdesc\n * Polygon geometry.\n *\n * @api\n */\nclass Polygon extends SimpleGeometry {\n  /**\n   * @param {!Array<Array<import(\"../coordinate.js\").Coordinate>>|!Array<number>} coordinates\n   *     Array of linear rings that define the polygon. The first linear ring of the\n   *     array defines the outer-boundary or surface of the polygon. Each subsequent\n   *     linear ring defines a hole in the surface of the polygon. A linear ring is\n   *     an array of vertices' coordinates where the first coordinate and the last are\n   *     equivalent. (For internal use, flat coordinates in combination with\n   *     `layout` and `ends` are also accepted.)\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @param {Array<number>} [ends] Ends (for internal use with flat coordinates).\n   */\n  constructor(coordinates, layout, ends) {\n    super();\n\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    this.ends_ = [];\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.flatInteriorPointRevision_ = -1;\n\n    /**\n     * @private\n     * @type {import(\"../coordinate.js\").Coordinate|null}\n     */\n    this.flatInteriorPoint_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.orientedRevision_ = -1;\n\n    /**\n     * @private\n     * @type {Array<number>|null}\n     */\n    this.orientedFlatCoordinates_ = null;\n\n    if (layout !== undefined && ends) {\n      this.setFlatCoordinates(\n        layout,\n        /** @type {Array<number>} */ (coordinates),\n      );\n      this.ends_ = ends;\n    } else {\n      this.setCoordinates(\n        /** @type {Array<Array<import(\"../coordinate.js\").Coordinate>>} */ (\n          coordinates\n        ),\n        layout,\n      );\n    }\n  }\n\n  /**\n   * Append the passed linear ring to this polygon.\n   * @param {LinearRing} linearRing Linear ring.\n   * @api\n   */\n  appendLinearRing(linearRing) {\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = linearRing.getFlatCoordinates().slice();\n    } else {\n      extend(this.flatCoordinates, linearRing.getFlatCoordinates());\n    }\n    this.ends_.push(this.flatCoordinates.length);\n    this.changed();\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!Polygon} Clone.\n   * @api\n   */\n  clone() {\n    const polygon = new Polygon(\n      this.flatCoordinates.slice(),\n      this.layout,\n      this.ends_.slice(),\n    );\n    polygon.applyProperties(this);\n    return polygon;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(\n        arrayMaxSquaredDelta(\n          this.flatCoordinates,\n          0,\n          this.ends_,\n          this.stride,\n          0,\n        ),\n      );\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestArrayPoint(\n      this.flatCoordinates,\n      0,\n      this.ends_,\n      this.stride,\n      this.maxDelta_,\n      true,\n      x,\n      y,\n      closestPoint,\n      minSquaredDistance,\n    );\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @return {boolean} Contains (x, y).\n   */\n  containsXY(x, y) {\n    return linearRingsContainsXY(\n      this.getOrientedFlatCoordinates(),\n      0,\n      this.ends_,\n      this.stride,\n      x,\n      y,\n    );\n  }\n\n  /**\n   * Return the area of the polygon on projected plane.\n   * @return {number} Area (on projected plane).\n   * @api\n   */\n  getArea() {\n    return linearRingsArea(\n      this.getOrientedFlatCoordinates(),\n      0,\n      this.ends_,\n      this.stride,\n    );\n  }\n\n  /**\n   * Get the coordinate array for this geometry.  This array has the structure\n   * of a GeoJSON coordinate array for polygons.\n   *\n   * @param {boolean} [right] Orient coordinates according to the right-hand\n   *     rule (counter-clockwise for exterior and clockwise for interior rings).\n   *     If `false`, coordinates will be oriented according to the left-hand rule\n   *     (clockwise for exterior and counter-clockwise for interior rings).\n   *     By default, coordinate orientation will depend on how the geometry was\n   *     constructed.\n   * @return {Array<Array<import(\"../coordinate.js\").Coordinate>>} Coordinates.\n   * @api\n   */\n  getCoordinates(right) {\n    let flatCoordinates;\n    if (right !== undefined) {\n      flatCoordinates = this.getOrientedFlatCoordinates().slice();\n      orientLinearRings(flatCoordinates, 0, this.ends_, this.stride, right);\n    } else {\n      flatCoordinates = this.flatCoordinates;\n    }\n\n    return inflateCoordinatesArray(flatCoordinates, 0, this.ends_, this.stride);\n  }\n\n  /**\n   * @return {Array<number>} Ends.\n   */\n  getEnds() {\n    return this.ends_;\n  }\n\n  /**\n   * @return {Array<number>} Interior point.\n   */\n  getFlatInteriorPoint() {\n    if (this.flatInteriorPointRevision_ != this.getRevision()) {\n      const flatCenter = getCenter(this.getExtent());\n      this.flatInteriorPoint_ = getInteriorPointOfArray(\n        this.getOrientedFlatCoordinates(),\n        0,\n        this.ends_,\n        this.stride,\n        flatCenter,\n        0,\n      );\n      this.flatInteriorPointRevision_ = this.getRevision();\n    }\n    return /** @type {import(\"../coordinate.js\").Coordinate} */ (\n      this.flatInteriorPoint_\n    );\n  }\n\n  /**\n   * Return an interior point of the polygon.\n   * @return {Point} Interior point as XYM coordinate, where M is the\n   * length of the horizontal intersection that the point belongs to.\n   * @api\n   */\n  getInteriorPoint() {\n    return new Point(this.getFlatInteriorPoint(), 'XYM');\n  }\n\n  /**\n   * Return the number of rings of the polygon,  this includes the exterior\n   * ring and any interior rings.\n   *\n   * @return {number} Number of rings.\n   * @api\n   */\n  getLinearRingCount() {\n    return this.ends_.length;\n  }\n\n  /**\n   * Return the Nth linear ring of the polygon geometry. Return `null` if the\n   * given index is out of range.\n   * The exterior linear ring is available at index `0` and the interior rings\n   * at index `1` and beyond.\n   *\n   * @param {number} index Index.\n   * @return {LinearRing|null} Linear ring.\n   * @api\n   */\n  getLinearRing(index) {\n    if (index < 0 || this.ends_.length <= index) {\n      return null;\n    }\n    return new LinearRing(\n      this.flatCoordinates.slice(\n        index === 0 ? 0 : this.ends_[index - 1],\n        this.ends_[index],\n      ),\n      this.layout,\n    );\n  }\n\n  /**\n   * Return the linear rings of the polygon.\n   * @return {Array<LinearRing>} Linear rings.\n   * @api\n   */\n  getLinearRings() {\n    const layout = this.layout;\n    const flatCoordinates = this.flatCoordinates;\n    const ends = this.ends_;\n    const linearRings = [];\n    let offset = 0;\n    for (let i = 0, ii = ends.length; i < ii; ++i) {\n      const end = ends[i];\n      const linearRing = new LinearRing(\n        flatCoordinates.slice(offset, end),\n        layout,\n      );\n      linearRings.push(linearRing);\n      offset = end;\n    }\n    return linearRings;\n  }\n\n  /**\n   * @return {Array<number>} Oriented flat coordinates.\n   */\n  getOrientedFlatCoordinates() {\n    if (this.orientedRevision_ != this.getRevision()) {\n      const flatCoordinates = this.flatCoordinates;\n      if (linearRingsAreOriented(flatCoordinates, 0, this.ends_, this.stride)) {\n        this.orientedFlatCoordinates_ = flatCoordinates;\n      } else {\n        this.orientedFlatCoordinates_ = flatCoordinates.slice();\n        this.orientedFlatCoordinates_.length = orientLinearRings(\n          this.orientedFlatCoordinates_,\n          0,\n          this.ends_,\n          this.stride,\n        );\n      }\n      this.orientedRevision_ = this.getRevision();\n    }\n    return /** @type {Array<number>} */ (this.orientedFlatCoordinates_);\n  }\n\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {Polygon} Simplified Polygon.\n   * @protected\n   */\n  getSimplifiedGeometryInternal(squaredTolerance) {\n    /** @type {Array<number>} */\n    const simplifiedFlatCoordinates = [];\n    /** @type {Array<number>} */\n    const simplifiedEnds = [];\n    simplifiedFlatCoordinates.length = quantizeArray(\n      this.flatCoordinates,\n      0,\n      this.ends_,\n      this.stride,\n      Math.sqrt(squaredTolerance),\n      simplifiedFlatCoordinates,\n      0,\n      simplifiedEnds,\n    );\n    return new Polygon(simplifiedFlatCoordinates, 'XY', simplifiedEnds);\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   */\n  getType() {\n    return 'Polygon';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   */\n  intersectsExtent(extent) {\n    return intersectsLinearRingArray(\n      this.getOrientedFlatCoordinates(),\n      0,\n      this.ends_,\n      this.stride,\n      extent,\n    );\n  }\n\n  /**\n   * Set the coordinates of the polygon.\n   * @param {!Array<Array<import(\"../coordinate.js\").Coordinate>>} coordinates Coordinates.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @api\n   */\n  setCoordinates(coordinates, layout) {\n    this.setLayout(layout, coordinates, 2);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    const ends = deflateCoordinatesArray(\n      this.flatCoordinates,\n      0,\n      coordinates,\n      this.stride,\n      this.ends_,\n    );\n    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];\n    this.changed();\n  }\n}\n\nexport default Polygon;\n\n/**\n * Create an approximation of a circle on the surface of a sphere.\n * @param {import(\"../coordinate.js\").Coordinate} center Center (`[lon, lat]` in degrees).\n * @param {number} radius The great-circle distance from the center to\n *     the polygon vertices in meters.\n * @param {number} [n] Optional number of vertices for the resulting\n *     polygon. Default is `32`.\n * @param {number} [sphereRadius] Optional radius for the sphere (defaults to\n *     the Earth's mean radius using the WGS84 ellipsoid).\n * @return {Polygon} The \"circular\" polygon.\n * @api\n */\nexport function circular(center, radius, n, sphereRadius) {\n  n = n ? n : 32;\n  /** @type {Array<number>} */\n  const flatCoordinates = [];\n  for (let i = 0; i < n; ++i) {\n    extend(\n      flatCoordinates,\n      sphereOffset(center, radius, (2 * Math.PI * i) / n, sphereRadius),\n    );\n  }\n  flatCoordinates.push(flatCoordinates[0], flatCoordinates[1]);\n  return new Polygon(flatCoordinates, 'XY', [flatCoordinates.length]);\n}\n\n/**\n * Create a polygon from an extent. The layout used is `XY`.\n * @param {import(\"../extent.js\").Extent} extent The extent.\n * @return {Polygon} The polygon.\n * @api\n */\nexport function fromExtent(extent) {\n  if (isEmpty(extent)) {\n    throw new Error('Cannot create polygon from empty extent');\n  }\n  const minX = extent[0];\n  const minY = extent[1];\n  const maxX = extent[2];\n  const maxY = extent[3];\n  const flatCoordinates = [\n    minX,\n    minY,\n    minX,\n    maxY,\n    maxX,\n    maxY,\n    maxX,\n    minY,\n    minX,\n    minY,\n  ];\n  return new Polygon(flatCoordinates, 'XY', [flatCoordinates.length]);\n}\n\n/**\n * Create a regular polygon from a circle.\n * @param {import(\"./Circle.js\").default} circle Circle geometry.\n * @param {number} [sides] Number of sides of the polygon. Default is 32.\n * @param {number} [angle] Start angle for the first vertex of the polygon in\n *     counter-clockwise radians. 0 means East. Default is 0.\n * @return {Polygon} Polygon geometry.\n * @api\n */\nexport function fromCircle(circle, sides, angle) {\n  sides = sides ? sides : 32;\n  const stride = circle.getStride();\n  const layout = circle.getLayout();\n  const center = circle.getCenter();\n  const arrayLength = stride * (sides + 1);\n  const flatCoordinates = new Array(arrayLength);\n  for (let i = 0; i < arrayLength; i += stride) {\n    flatCoordinates[i] = 0;\n    flatCoordinates[i + 1] = 0;\n    for (let j = 2; j < stride; j++) {\n      flatCoordinates[i + j] = center[j];\n    }\n  }\n  const ends = [flatCoordinates.length];\n  const polygon = new Polygon(flatCoordinates, layout, ends);\n  makeRegular(polygon, center, circle.getRadius(), angle);\n  return polygon;\n}\n\n/**\n * Modify the coordinates of a polygon to make it a regular polygon.\n * @param {Polygon} polygon Polygon geometry.\n * @param {import(\"../coordinate.js\").Coordinate} center Center of the regular polygon.\n * @param {number} radius Radius of the regular polygon.\n * @param {number} [angle] Start angle for the first vertex of the polygon in\n *     counter-clockwise radians. 0 means East. Default is 0.\n */\nexport function makeRegular(polygon, center, radius, angle) {\n  const flatCoordinates = polygon.getFlatCoordinates();\n  const stride = polygon.getStride();\n  const sides = flatCoordinates.length / stride - 1;\n  const startAngle = angle ? angle : 0;\n  for (let i = 0; i <= sides; ++i) {\n    const offset = i * stride;\n    const angle = startAngle + (modulo(i, sides) * 2 * Math.PI) / sides;\n    flatCoordinates[offset] = center[0] + radius * Math.cos(angle);\n    flatCoordinates[offset + 1] = center[1] + radius * Math.sin(angle);\n  }\n  polygon.changed();\n}\n","/**\n * @module ol/geom/SimpleGeometry\n */\nimport Geometry from './Geometry.js';\nimport {abstract} from '../util.js';\nimport {createOrUpdateFromFlatCoordinates, getCenter} from '../extent.js';\nimport {rotate, scale, transform2D, translate} from './flat/transform.js';\n\n/**\n * @classdesc\n * Abstract base class; only used for creating subclasses; do not instantiate\n * in apps, as cannot be rendered.\n *\n * @abstract\n * @api\n */\nclass SimpleGeometry extends Geometry {\n  constructor() {\n    super();\n\n    /**\n     * @protected\n     * @type {import(\"./Geometry.js\").GeometryLayout}\n     */\n    this.layout = 'XY';\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.stride = 2;\n\n    /**\n     * @protected\n     * @type {Array<number>}\n     */\n    this.flatCoordinates;\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @protected\n   * @return {import(\"../extent.js\").Extent} extent Extent.\n   */\n  computeExtent(extent) {\n    return createOrUpdateFromFlatCoordinates(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      extent,\n    );\n  }\n\n  /**\n   * @abstract\n   * @return {Array<*> | null} Coordinates.\n   */\n  getCoordinates() {\n    return abstract();\n  }\n\n  /**\n   * Return the first coordinate of the geometry.\n   * @return {import(\"../coordinate.js\").Coordinate} First coordinate.\n   * @api\n   */\n  getFirstCoordinate() {\n    return this.flatCoordinates.slice(0, this.stride);\n  }\n\n  /**\n   * @return {Array<number>} Flat coordinates.\n   */\n  getFlatCoordinates() {\n    return this.flatCoordinates;\n  }\n\n  /**\n   * Return the last coordinate of the geometry.\n   * @return {import(\"../coordinate.js\").Coordinate} Last point.\n   * @api\n   */\n  getLastCoordinate() {\n    return this.flatCoordinates.slice(\n      this.flatCoordinates.length - this.stride,\n    );\n  }\n\n  /**\n   * Return the {@link import(\"./Geometry.js\").GeometryLayout layout} of the geometry.\n   * @return {import(\"./Geometry.js\").GeometryLayout} Layout.\n   * @api\n   */\n  getLayout() {\n    return this.layout;\n  }\n\n  /**\n   * Create a simplified version of this geometry using the Douglas Peucker algorithm.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {SimpleGeometry} Simplified geometry.\n   */\n  getSimplifiedGeometry(squaredTolerance) {\n    if (this.simplifiedGeometryRevision !== this.getRevision()) {\n      this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n      this.simplifiedGeometryRevision = this.getRevision();\n    }\n    // If squaredTolerance is negative or if we know that simplification will not\n    // have any effect then just return this.\n    if (\n      squaredTolerance < 0 ||\n      (this.simplifiedGeometryMaxMinSquaredTolerance !== 0 &&\n        squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance)\n    ) {\n      return this;\n    }\n\n    const simplifiedGeometry =\n      this.getSimplifiedGeometryInternal(squaredTolerance);\n    const simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();\n    if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {\n      return simplifiedGeometry;\n    }\n    // Simplification did not actually remove any coordinates.  We now know\n    // that any calls to getSimplifiedGeometry with a squaredTolerance less\n    // than or equal to the current squaredTolerance will also not have any\n    // effect.  This allows us to short circuit simplification (saving CPU\n    // cycles) and prevents the cache of simplified geometries from filling\n    // up with useless identical copies of this geometry (saving memory).\n    this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;\n    return this;\n  }\n\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {SimpleGeometry} Simplified geometry.\n   * @protected\n   */\n  getSimplifiedGeometryInternal(squaredTolerance) {\n    return this;\n  }\n\n  /**\n   * @return {number} Stride.\n   */\n  getStride() {\n    return this.stride;\n  }\n\n  /**\n   * @param {import(\"./Geometry.js\").GeometryLayout} layout Layout.\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   */\n  setFlatCoordinates(layout, flatCoordinates) {\n    this.stride = getStrideForLayout(layout);\n    this.layout = layout;\n    this.flatCoordinates = flatCoordinates;\n  }\n\n  /**\n   * @abstract\n   * @param {!Array<*>} coordinates Coordinates.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   */\n  setCoordinates(coordinates, layout) {\n    abstract();\n  }\n\n  /**\n   * @param {import(\"./Geometry.js\").GeometryLayout|undefined} layout Layout.\n   * @param {Array<*>} coordinates Coordinates.\n   * @param {number} nesting Nesting.\n   * @protected\n   */\n  setLayout(layout, coordinates, nesting) {\n    let stride;\n    if (layout) {\n      stride = getStrideForLayout(layout);\n    } else {\n      for (let i = 0; i < nesting; ++i) {\n        if (coordinates.length === 0) {\n          this.layout = 'XY';\n          this.stride = 2;\n          return;\n        }\n        coordinates = /** @type {Array<unknown>} */ (coordinates[0]);\n      }\n      stride = coordinates.length;\n      layout = getLayoutForStride(stride);\n    }\n    this.layout = layout;\n    this.stride = stride;\n  }\n\n  /**\n   * Apply a transform function to the coordinates of the geometry.\n   * The geometry is modified in place.\n   * If you do not want the geometry modified in place, first `clone()` it and\n   * then use this function on the clone.\n   * @param {import(\"../proj.js\").TransformFunction} transformFn Transform function.\n   * Called with a flat array of geometry coordinates.\n   * @api\n   */\n  applyTransform(transformFn) {\n    if (this.flatCoordinates) {\n      transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);\n      this.changed();\n    }\n  }\n\n  /**\n   * Rotate the geometry around a given coordinate. This modifies the geometry\n   * coordinates in place.\n   * @param {number} angle Rotation angle in counter-clockwise radians.\n   * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\n   * @api\n   */\n  rotate(angle, anchor) {\n    const flatCoordinates = this.getFlatCoordinates();\n    if (flatCoordinates) {\n      const stride = this.getStride();\n      rotate(\n        flatCoordinates,\n        0,\n        flatCoordinates.length,\n        stride,\n        angle,\n        anchor,\n        flatCoordinates,\n      );\n      this.changed();\n    }\n  }\n\n  /**\n   * Scale the geometry (with an optional origin).  This modifies the geometry\n   * coordinates in place.\n   * @param {number} sx The scaling factor in the x-direction.\n   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).\n   * @param {import(\"../coordinate.js\").Coordinate} [anchor] The scale origin (defaults to the center\n   *     of the geometry extent).\n   * @api\n   */\n  scale(sx, sy, anchor) {\n    if (sy === undefined) {\n      sy = sx;\n    }\n    if (!anchor) {\n      anchor = getCenter(this.getExtent());\n    }\n    const flatCoordinates = this.getFlatCoordinates();\n    if (flatCoordinates) {\n      const stride = this.getStride();\n      scale(\n        flatCoordinates,\n        0,\n        flatCoordinates.length,\n        stride,\n        sx,\n        sy,\n        anchor,\n        flatCoordinates,\n      );\n      this.changed();\n    }\n  }\n\n  /**\n   * Translate the geometry.  This modifies the geometry coordinates in place.  If\n   * instead you want a new geometry, first `clone()` this geometry.\n   * @param {number} deltaX Delta X.\n   * @param {number} deltaY Delta Y.\n   * @api\n   */\n  translate(deltaX, deltaY) {\n    const flatCoordinates = this.getFlatCoordinates();\n    if (flatCoordinates) {\n      const stride = this.getStride();\n      translate(\n        flatCoordinates,\n        0,\n        flatCoordinates.length,\n        stride,\n        deltaX,\n        deltaY,\n        flatCoordinates,\n      );\n      this.changed();\n    }\n  }\n}\n\n/**\n * @param {number} stride Stride.\n * @return {import(\"./Geometry.js\").GeometryLayout} layout Layout.\n */\nexport function getLayoutForStride(stride) {\n  let layout;\n  if (stride == 2) {\n    layout = 'XY';\n  } else if (stride == 3) {\n    layout = 'XYZ';\n  } else if (stride == 4) {\n    layout = 'XYZM';\n  }\n  return /** @type {import(\"./Geometry.js\").GeometryLayout} */ (layout);\n}\n\n/**\n * @param {import(\"./Geometry.js\").GeometryLayout} layout Layout.\n * @return {number} Stride.\n */\nexport function getStrideForLayout(layout) {\n  let stride;\n  if (layout == 'XY') {\n    stride = 2;\n  } else if (layout == 'XYZ' || layout == 'XYM') {\n    stride = 3;\n  } else if (layout == 'XYZM') {\n    stride = 4;\n  }\n  return /** @type {number} */ (stride);\n}\n\n/**\n * @param {SimpleGeometry} simpleGeometry Simple geometry.\n * @param {import(\"../transform.js\").Transform} transform Transform.\n * @param {Array<number>} [dest] Destination.\n * @return {Array<number>} Transformed flat coordinates.\n */\nexport function transformGeom2D(simpleGeometry, transform, dest) {\n  const flatCoordinates = simpleGeometry.getFlatCoordinates();\n  if (!flatCoordinates) {\n    return null;\n  }\n  const stride = simpleGeometry.getStride();\n  return transform2D(\n    flatCoordinates,\n    0,\n    flatCoordinates.length,\n    stride,\n    transform,\n    dest,\n  );\n}\n\nexport default SimpleGeometry;\n","/**\n * @module ol/geom/flat/area\n */\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {number} Area.\n */\nexport function linearRing(flatCoordinates, offset, end, stride) {\n  let twiceArea = 0;\n  let x1 = flatCoordinates[end - stride];\n  let y1 = flatCoordinates[end - stride + 1];\n  for (; offset < end; offset += stride) {\n    const x2 = flatCoordinates[offset];\n    const y2 = flatCoordinates[offset + 1];\n    twiceArea += y1 * x2 - x1 * y2;\n    x1 = x2;\n    y1 = y2;\n  }\n  return twiceArea / 2;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @return {number} Area.\n */\nexport function linearRings(flatCoordinates, offset, ends, stride) {\n  let area = 0;\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    area += linearRing(flatCoordinates, offset, end, stride);\n    offset = end;\n  }\n  return area;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @return {number} Area.\n */\nexport function linearRingss(flatCoordinates, offset, endss, stride) {\n  let area = 0;\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    area += linearRings(flatCoordinates, offset, ends, stride);\n    offset = ends[ends.length - 1];\n  }\n  return area;\n}\n","/**\n * @module ol/geom/flat/center\n */\nimport {createEmpty, createOrUpdateFromFlatCoordinates} from '../../extent.js';\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @return {Array<number>} Flat centers.\n */\nexport function linearRingss(flatCoordinates, offset, endss, stride) {\n  const flatCenters = [];\n  let extent = createEmpty();\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    extent = createOrUpdateFromFlatCoordinates(\n      flatCoordinates,\n      offset,\n      ends[0],\n      stride,\n    );\n    flatCenters.push((extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2);\n    offset = ends[ends.length - 1];\n  }\n  return flatCenters;\n}\n","/**\n * @module ol/geom/flat/closest\n */\nimport {lerp, squaredDistance as squaredDx} from '../../math.js';\n\n/**\n * Returns the point on the 2D line segment flatCoordinates[offset1] to\n * flatCoordinates[offset2] that is closest to the point (x, y).  Extra\n * dimensions are linearly interpolated.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset1 Offset 1.\n * @param {number} offset2 Offset 2.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n */\nfunction assignClosest(\n  flatCoordinates,\n  offset1,\n  offset2,\n  stride,\n  x,\n  y,\n  closestPoint,\n) {\n  const x1 = flatCoordinates[offset1];\n  const y1 = flatCoordinates[offset1 + 1];\n  const dx = flatCoordinates[offset2] - x1;\n  const dy = flatCoordinates[offset2 + 1] - y1;\n  let offset;\n  if (dx === 0 && dy === 0) {\n    offset = offset1;\n  } else {\n    const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\n    if (t > 1) {\n      offset = offset2;\n    } else if (t > 0) {\n      for (let i = 0; i < stride; ++i) {\n        closestPoint[i] = lerp(\n          flatCoordinates[offset1 + i],\n          flatCoordinates[offset2 + i],\n          t,\n        );\n      }\n      closestPoint.length = stride;\n      return;\n    } else {\n      offset = offset1;\n    }\n  }\n  for (let i = 0; i < stride; ++i) {\n    closestPoint[i] = flatCoordinates[offset + i];\n  }\n  closestPoint.length = stride;\n}\n\n/**\n * Return the squared of the largest distance between any pair of consecutive\n * coordinates.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\nexport function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {\n  let x1 = flatCoordinates[offset];\n  let y1 = flatCoordinates[offset + 1];\n  for (offset += stride; offset < end; offset += stride) {\n    const x2 = flatCoordinates[offset];\n    const y2 = flatCoordinates[offset + 1];\n    const squaredDelta = squaredDx(x1, y1, x2, y2);\n    if (squaredDelta > max) {\n      max = squaredDelta;\n    }\n    x1 = x2;\n    y1 = y2;\n  }\n  return max;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\nexport function arrayMaxSquaredDelta(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  max,\n) {\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    max = maxSquaredDelta(flatCoordinates, offset, end, stride, max);\n    offset = end;\n  }\n  return max;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\nexport function multiArrayMaxSquaredDelta(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  max,\n) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    max = arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max);\n    offset = ends[ends.length - 1];\n  }\n  return max;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>} [tmpPoint] Temporary point object.\n * @return {number} Minimum squared distance.\n */\nexport function assignClosestPoint(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  maxDelta,\n  isRing,\n  x,\n  y,\n  closestPoint,\n  minSquaredDistance,\n  tmpPoint,\n) {\n  if (offset == end) {\n    return minSquaredDistance;\n  }\n  let i, squaredDistance;\n  if (maxDelta === 0) {\n    // All points are identical, so just test the first point.\n    squaredDistance = squaredDx(\n      x,\n      y,\n      flatCoordinates[offset],\n      flatCoordinates[offset + 1],\n    );\n    if (squaredDistance < minSquaredDistance) {\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = flatCoordinates[offset + i];\n      }\n      closestPoint.length = stride;\n      return squaredDistance;\n    }\n    return minSquaredDistance;\n  }\n  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];\n  let index = offset + stride;\n  while (index < end) {\n    assignClosest(\n      flatCoordinates,\n      index - stride,\n      index,\n      stride,\n      x,\n      y,\n      tmpPoint,\n    );\n    squaredDistance = squaredDx(x, y, tmpPoint[0], tmpPoint[1]);\n    if (squaredDistance < minSquaredDistance) {\n      minSquaredDistance = squaredDistance;\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = tmpPoint[i];\n      }\n      closestPoint.length = stride;\n      index += stride;\n    } else {\n      // Skip ahead multiple points, because we know that all the skipped\n      // points cannot be any closer than the closest point we have found so\n      // far.  We know this because we know how close the current point is, how\n      // close the closest point we have found so far is, and the maximum\n      // distance between consecutive points.  For example, if we're currently\n      // at distance 10, the best we've found so far is 3, and that the maximum\n      // distance between consecutive points is 2, then we'll need to skip at\n      // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of\n      // finding a closer point.  We use Math.max(..., 1) to ensure that we\n      // always advance at least one point, to avoid an infinite loop.\n      index +=\n        stride *\n        Math.max(\n          ((Math.sqrt(squaredDistance) - Math.sqrt(minSquaredDistance)) /\n            maxDelta) |\n            0,\n          1,\n        );\n    }\n  }\n  if (isRing) {\n    // Check the closing segment.\n    assignClosest(\n      flatCoordinates,\n      end - stride,\n      offset,\n      stride,\n      x,\n      y,\n      tmpPoint,\n    );\n    squaredDistance = squaredDx(x, y, tmpPoint[0], tmpPoint[1]);\n    if (squaredDistance < minSquaredDistance) {\n      minSquaredDistance = squaredDistance;\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = tmpPoint[i];\n      }\n      closestPoint.length = stride;\n    }\n  }\n  return minSquaredDistance;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>} [tmpPoint] Temporary point object.\n * @return {number} Minimum squared distance.\n */\nexport function assignClosestArrayPoint(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  maxDelta,\n  isRing,\n  x,\n  y,\n  closestPoint,\n  minSquaredDistance,\n  tmpPoint,\n) {\n  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    minSquaredDistance = assignClosestPoint(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      maxDelta,\n      isRing,\n      x,\n      y,\n      closestPoint,\n      minSquaredDistance,\n      tmpPoint,\n    );\n    offset = end;\n  }\n  return minSquaredDistance;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>} [tmpPoint] Temporary point object.\n * @return {number} Minimum squared distance.\n */\nexport function assignClosestMultiArrayPoint(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  maxDelta,\n  isRing,\n  x,\n  y,\n  closestPoint,\n  minSquaredDistance,\n  tmpPoint,\n) {\n  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    minSquaredDistance = assignClosestArrayPoint(\n      flatCoordinates,\n      offset,\n      ends,\n      stride,\n      maxDelta,\n      isRing,\n      x,\n      y,\n      closestPoint,\n      minSquaredDistance,\n      tmpPoint,\n    );\n    offset = ends[ends.length - 1];\n  }\n  return minSquaredDistance;\n}\n","/**\n * @module ol/geom/flat/contains\n */\nimport {forEachCorner} from '../../extent.js';\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} Contains extent.\n */\nexport function linearRingContainsExtent(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  extent,\n) {\n  const outside = forEachCorner(\n    extent,\n    /**\n     * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @return {boolean} Contains (x, y).\n     */\n    function (coordinate) {\n      return !linearRingContainsXY(\n        flatCoordinates,\n        offset,\n        end,\n        stride,\n        coordinate[0],\n        coordinate[1],\n      );\n    },\n  );\n  return !outside;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\nexport function linearRingContainsXY(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  x,\n  y,\n) {\n  // https://geomalgorithms.com/a03-_inclusion.html\n  // Copyright 2000 softSurfer, 2012 Dan Sunday\n  // This code may be freely used and modified for any purpose\n  // providing that this copyright notice is included with it.\n  // SoftSurfer makes no warranty for this code, and cannot be held\n  // liable for any real or imagined damage resulting from its use.\n  // Users of this code must verify correctness for their application.\n  let wn = 0;\n  let x1 = flatCoordinates[end - stride];\n  let y1 = flatCoordinates[end - stride + 1];\n  for (; offset < end; offset += stride) {\n    const x2 = flatCoordinates[offset];\n    const y2 = flatCoordinates[offset + 1];\n    if (y1 <= y) {\n      if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) {\n        wn++;\n      }\n    } else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) {\n      wn--;\n    }\n    x1 = x2;\n    y1 = y2;\n  }\n  return wn !== 0;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\nexport function linearRingsContainsXY(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  x,\n  y,\n) {\n  if (ends.length === 0) {\n    return false;\n  }\n  if (!linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) {\n    return false;\n  }\n  for (let i = 1, ii = ends.length; i < ii; ++i) {\n    if (\n      linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\nexport function linearRingssContainsXY(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  x,\n  y,\n) {\n  if (endss.length === 0) {\n    return false;\n  }\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {\n      return true;\n    }\n    offset = ends[ends.length - 1];\n  }\n  return false;\n}\n","/**\n * @module ol/geom/flat/deflate\n */\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n * @param {number} stride Stride.\n * @return {number} offset Offset.\n */\nexport function deflateCoordinate(flatCoordinates, offset, coordinate, stride) {\n  for (let i = 0, ii = coordinate.length; i < ii; ++i) {\n    flatCoordinates[offset++] = coordinate[i];\n  }\n  return offset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<import(\"../../coordinate.js\").Coordinate>} coordinates Coordinates.\n * @param {number} stride Stride.\n * @return {number} offset Offset.\n */\nexport function deflateCoordinates(\n  flatCoordinates,\n  offset,\n  coordinates,\n  stride,\n) {\n  for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n    const coordinate = coordinates[i];\n    for (let j = 0; j < stride; ++j) {\n      flatCoordinates[offset++] = coordinate[j];\n    }\n  }\n  return offset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<import(\"../../coordinate.js\").Coordinate>>} coordinatess Coordinatess.\n * @param {number} stride Stride.\n * @param {Array<number>} [ends] Ends.\n * @return {Array<number>} Ends.\n */\nexport function deflateCoordinatesArray(\n  flatCoordinates,\n  offset,\n  coordinatess,\n  stride,\n  ends,\n) {\n  ends = ends ? ends : [];\n  let i = 0;\n  for (let j = 0, jj = coordinatess.length; j < jj; ++j) {\n    const end = deflateCoordinates(\n      flatCoordinates,\n      offset,\n      coordinatess[j],\n      stride,\n    );\n    ends[i++] = end;\n    offset = end;\n  }\n  ends.length = i;\n  return ends;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<Array<import(\"../../coordinate.js\").Coordinate>>>} coordinatesss Coordinatesss.\n * @param {number} stride Stride.\n * @param {Array<Array<number>>} [endss] Endss.\n * @return {Array<Array<number>>} Endss.\n */\nexport function deflateMultiCoordinatesArray(\n  flatCoordinates,\n  offset,\n  coordinatesss,\n  stride,\n  endss,\n) {\n  endss = endss ? endss : [];\n  let i = 0;\n  for (let j = 0, jj = coordinatesss.length; j < jj; ++j) {\n    const ends = deflateCoordinatesArray(\n      flatCoordinates,\n      offset,\n      coordinatesss[j],\n      stride,\n      endss[i],\n    );\n    if (ends.length === 0) {\n      ends[0] = offset;\n    }\n    endss[i++] = ends;\n    offset = ends[ends.length - 1];\n  }\n  endss.length = i;\n  return endss;\n}\n","/**\n * @module ol/geom/flat/inflate\n */\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {Array<import(\"../../coordinate.js\").Coordinate>} [coordinates] Coordinates.\n * @return {Array<import(\"../../coordinate.js\").Coordinate>} Coordinates.\n */\nexport function inflateCoordinates(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  coordinates,\n) {\n  coordinates = coordinates !== undefined ? coordinates : [];\n  let i = 0;\n  for (let j = offset; j < end; j += stride) {\n    coordinates[i++] = flatCoordinates.slice(j, j + stride);\n  }\n  coordinates.length = i;\n  return coordinates;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {Array<Array<import(\"../../coordinate.js\").Coordinate>>} [coordinatess] Coordinatess.\n * @return {Array<Array<import(\"../../coordinate.js\").Coordinate>>} Coordinatess.\n */\nexport function inflateCoordinatesArray(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  coordinatess,\n) {\n  coordinatess = coordinatess !== undefined ? coordinatess : [];\n  let i = 0;\n  for (let j = 0, jj = ends.length; j < jj; ++j) {\n    const end = ends[j];\n    coordinatess[i++] = inflateCoordinates(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      coordinatess[i],\n    );\n    offset = end;\n  }\n  coordinatess.length = i;\n  return coordinatess;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {Array<Array<Array<import(\"../../coordinate.js\").Coordinate>>>} [coordinatesss]\n *     Coordinatesss.\n * @return {Array<Array<Array<import(\"../../coordinate.js\").Coordinate>>>} Coordinatesss.\n */\nexport function inflateMultiCoordinatesArray(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  coordinatesss,\n) {\n  coordinatesss = coordinatesss !== undefined ? coordinatesss : [];\n  let i = 0;\n  for (let j = 0, jj = endss.length; j < jj; ++j) {\n    const ends = endss[j];\n    coordinatesss[i++] =\n      ends.length === 1 && ends[0] === offset\n        ? []\n        : inflateCoordinatesArray(\n            flatCoordinates,\n            offset,\n            ends,\n            stride,\n            coordinatesss[i],\n          );\n    offset = ends[ends.length - 1];\n  }\n  coordinatesss.length = i;\n  return coordinatesss;\n}\n","/**\n * @module ol/geom/flat/interiorpoint\n */\nimport {ascending} from '../../array.js';\nimport {linearRingsContainsXY} from './contains.js';\n\n/**\n * Calculates a point that is likely to lie in the interior of the linear rings.\n * Inspired by JTS's com.vividsolutions.jts.geom.Geometry#getInteriorPoint.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {Array<number>} flatCenters Flat centers.\n * @param {number} flatCentersOffset Flat center offset.\n * @param {Array<number>} [dest] Destination.\n * @return {Array<number>} Destination point as XYM coordinate, where M is the\n * length of the horizontal intersection that the point belongs to.\n */\nexport function getInteriorPointOfArray(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  flatCenters,\n  flatCentersOffset,\n  dest,\n) {\n  let i, ii, x, x1, x2, y1, y2;\n  const y = flatCenters[flatCentersOffset + 1];\n  /** @type {Array<number>} */\n  const intersections = [];\n  // Calculate intersections with the horizontal line\n  for (let r = 0, rr = ends.length; r < rr; ++r) {\n    const end = ends[r];\n    x1 = flatCoordinates[end - stride];\n    y1 = flatCoordinates[end - stride + 1];\n    for (i = offset; i < end; i += stride) {\n      x2 = flatCoordinates[i];\n      y2 = flatCoordinates[i + 1];\n      if ((y <= y1 && y2 <= y) || (y1 <= y && y <= y2)) {\n        x = ((y - y1) / (y2 - y1)) * (x2 - x1) + x1;\n        intersections.push(x);\n      }\n      x1 = x2;\n      y1 = y2;\n    }\n  }\n  // Find the longest segment of the horizontal line that has its center point\n  // inside the linear ring.\n  let pointX = NaN;\n  let maxSegmentLength = -Infinity;\n  intersections.sort(ascending);\n  x1 = intersections[0];\n  for (i = 1, ii = intersections.length; i < ii; ++i) {\n    x2 = intersections[i];\n    const segmentLength = Math.abs(x2 - x1);\n    if (segmentLength > maxSegmentLength) {\n      x = (x1 + x2) / 2;\n      if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {\n        pointX = x;\n        maxSegmentLength = segmentLength;\n      }\n    }\n    x1 = x2;\n  }\n  if (isNaN(pointX)) {\n    // There is no horizontal line that has its center point inside the linear\n    // ring.  Use the center of the the linear ring's extent.\n    pointX = flatCenters[flatCentersOffset];\n  }\n  if (dest) {\n    dest.push(pointX, y, maxSegmentLength);\n    return dest;\n  }\n  return [pointX, y, maxSegmentLength];\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {Array<number>} flatCenters Flat centers.\n * @return {Array<number>} Interior points as XYM coordinates, where M is the\n * length of the horizontal intersection that the point belongs to.\n */\nexport function getInteriorPointsOfMultiArray(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  flatCenters,\n) {\n  /** @type {Array<number>} */\n  let interiorPoints = [];\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    interiorPoints = getInteriorPointOfArray(\n      flatCoordinates,\n      offset,\n      ends,\n      stride,\n      flatCenters,\n      2 * i,\n      interiorPoints,\n    );\n    offset = ends[ends.length - 1];\n  }\n  return interiorPoints;\n}\n","/**\n * @module ol/geom/flat/interpolate\n */\nimport {binarySearch} from '../../array.js';\nimport {lerp} from '../../math.js';\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} fraction Fraction.\n * @param {Array<number>} [dest] Destination.\n * @param {number} [dimension] Destination dimension (default is `2`)\n * @return {Array<number>} Destination.\n */\nexport function interpolatePoint(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  fraction,\n  dest,\n  dimension,\n) {\n  let o, t;\n  const n = (end - offset) / stride;\n  if (n === 1) {\n    o = offset;\n  } else if (n === 2) {\n    o = offset;\n    t = fraction;\n  } else if (n !== 0) {\n    let x1 = flatCoordinates[offset];\n    let y1 = flatCoordinates[offset + 1];\n    let length = 0;\n    const cumulativeLengths = [0];\n    for (let i = offset + stride; i < end; i += stride) {\n      const x2 = flatCoordinates[i];\n      const y2 = flatCoordinates[i + 1];\n      length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n      cumulativeLengths.push(length);\n      x1 = x2;\n      y1 = y2;\n    }\n    const target = fraction * length;\n    const index = binarySearch(cumulativeLengths, target);\n    if (index < 0) {\n      t =\n        (target - cumulativeLengths[-index - 2]) /\n        (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);\n      o = offset + (-index - 2) * stride;\n    } else {\n      o = offset + index * stride;\n    }\n  }\n  dimension = dimension > 1 ? dimension : 2;\n  dest = dest ? dest : new Array(dimension);\n  for (let i = 0; i < dimension; ++i) {\n    dest[i] =\n      o === undefined\n        ? NaN\n        : t === undefined\n          ? flatCoordinates[o + i]\n          : lerp(flatCoordinates[o + i], flatCoordinates[o + stride + i], t);\n  }\n  return dest;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @return {import(\"../../coordinate.js\").Coordinate|null} Coordinate.\n */\nexport function lineStringCoordinateAtM(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  m,\n  extrapolate,\n) {\n  if (end == offset) {\n    return null;\n  }\n  let coordinate;\n  if (m < flatCoordinates[offset + stride - 1]) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(offset, offset + stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    }\n    return null;\n  }\n  if (flatCoordinates[end - 1] < m) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(end - stride, end);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    }\n    return null;\n  }\n  // FIXME use O(1) search\n  if (m == flatCoordinates[offset + stride - 1]) {\n    return flatCoordinates.slice(offset, offset + stride);\n  }\n  let lo = offset / stride;\n  let hi = end / stride;\n  while (lo < hi) {\n    const mid = (lo + hi) >> 1;\n    if (m < flatCoordinates[(mid + 1) * stride - 1]) {\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n  const m0 = flatCoordinates[lo * stride - 1];\n  if (m == m0) {\n    return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);\n  }\n  const m1 = flatCoordinates[(lo + 1) * stride - 1];\n  const t = (m - m0) / (m1 - m0);\n  coordinate = [];\n  for (let i = 0; i < stride - 1; ++i) {\n    coordinate.push(\n      lerp(\n        flatCoordinates[(lo - 1) * stride + i],\n        flatCoordinates[lo * stride + i],\n        t,\n      ),\n    );\n  }\n  coordinate.push(m);\n  return coordinate;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @param {boolean} interpolate Interpolate.\n * @return {import(\"../../coordinate.js\").Coordinate|null} Coordinate.\n */\nexport function lineStringsCoordinateAtM(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  m,\n  extrapolate,\n  interpolate,\n) {\n  if (interpolate) {\n    return lineStringCoordinateAtM(\n      flatCoordinates,\n      offset,\n      ends[ends.length - 1],\n      stride,\n      m,\n      extrapolate,\n    );\n  }\n  let coordinate;\n  if (m < flatCoordinates[stride - 1]) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(0, stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    }\n    return null;\n  }\n  if (flatCoordinates[flatCoordinates.length - 1] < m) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(flatCoordinates.length - stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    }\n    return null;\n  }\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    if (offset == end) {\n      continue;\n    }\n    if (m < flatCoordinates[offset + stride - 1]) {\n      return null;\n    }\n    if (m <= flatCoordinates[end - 1]) {\n      return lineStringCoordinateAtM(\n        flatCoordinates,\n        offset,\n        end,\n        stride,\n        m,\n        false,\n      );\n    }\n    offset = end;\n  }\n  return null;\n}\n","/**\n * @module ol/geom/flat/intersectsextent\n */\nimport {\n  containsExtent,\n  createEmpty,\n  extendFlatCoordinates,\n  intersects,\n  intersectsSegment,\n} from '../../extent.js';\nimport {forEach as forEachSegment} from './segments.js';\nimport {linearRingContainsExtent, linearRingContainsXY} from './contains.js';\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLineString(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  extent,\n) {\n  const coordinatesExtent = extendFlatCoordinates(\n    createEmpty(),\n    flatCoordinates,\n    offset,\n    end,\n    stride,\n  );\n  if (!intersects(extent, coordinatesExtent)) {\n    return false;\n  }\n  if (containsExtent(extent, coordinatesExtent)) {\n    return true;\n  }\n  if (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2]) {\n    return true;\n  }\n  if (coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3]) {\n    return true;\n  }\n  return forEachSegment(\n    flatCoordinates,\n    offset,\n    end,\n    stride,\n    /**\n     * @param {import(\"../../coordinate.js\").Coordinate} point1 Start point.\n     * @param {import(\"../../coordinate.js\").Coordinate} point2 End point.\n     * @return {boolean} `true` if the segment and the extent intersect,\n     *     `false` otherwise.\n     */\n    function (point1, point2) {\n      return intersectsSegment(extent, point1, point2);\n    },\n  );\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLineStringArray(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  extent,\n) {\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    if (\n      intersectsLineString(flatCoordinates, offset, ends[i], stride, extent)\n    ) {\n      return true;\n    }\n    offset = ends[i];\n  }\n  return false;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLinearRing(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  extent,\n) {\n  if (intersectsLineString(flatCoordinates, offset, end, stride, extent)) {\n    return true;\n  }\n  if (\n    linearRingContainsXY(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      extent[0],\n      extent[1],\n    )\n  ) {\n    return true;\n  }\n  if (\n    linearRingContainsXY(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      extent[0],\n      extent[3],\n    )\n  ) {\n    return true;\n  }\n  if (\n    linearRingContainsXY(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      extent[2],\n      extent[1],\n    )\n  ) {\n    return true;\n  }\n  if (\n    linearRingContainsXY(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      extent[2],\n      extent[3],\n    )\n  ) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLinearRingArray(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  extent,\n) {\n  if (!intersectsLinearRing(flatCoordinates, offset, ends[0], stride, extent)) {\n    return false;\n  }\n  if (ends.length === 1) {\n    return true;\n  }\n  for (let i = 1, ii = ends.length; i < ii; ++i) {\n    if (\n      linearRingContainsExtent(\n        flatCoordinates,\n        ends[i - 1],\n        ends[i],\n        stride,\n        extent,\n      )\n    ) {\n      if (\n        !intersectsLineString(\n          flatCoordinates,\n          ends[i - 1],\n          ends[i],\n          stride,\n          extent,\n        )\n      ) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLinearRingMultiArray(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  extent,\n) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    if (\n      intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent)\n    ) {\n      return true;\n    }\n    offset = ends[ends.length - 1];\n  }\n  return false;\n}\n","/**\n * @module ol/geom/flat/length\n */\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {number} Length.\n */\nexport function lineStringLength(flatCoordinates, offset, end, stride) {\n  let x1 = flatCoordinates[offset];\n  let y1 = flatCoordinates[offset + 1];\n  let length = 0;\n  for (let i = offset + stride; i < end; i += stride) {\n    const x2 = flatCoordinates[i];\n    const y2 = flatCoordinates[i + 1];\n    length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n    x1 = x2;\n    y1 = y2;\n  }\n  return length;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {number} Perimeter.\n */\nexport function linearRingLength(flatCoordinates, offset, end, stride) {\n  let perimeter = lineStringLength(flatCoordinates, offset, end, stride);\n  const dx = flatCoordinates[end - stride] - flatCoordinates[offset];\n  const dy = flatCoordinates[end - stride + 1] - flatCoordinates[offset + 1];\n  perimeter += Math.sqrt(dx * dx + dy * dy);\n  return perimeter;\n}\n","import {lerp} from '../../math.js';\n\n/**\n * Creates chunks of equal length from a linestring\n * @param {number} chunkLength Length of each chunk.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Start offset of the `flatCoordinates`.\n * @param {number} end End offset of the `flatCoordinates`.\n * @param {number} stride Stride.\n * @return {Array<Array<number>>} Chunks of linestrings with stride 2.\n */\nexport function lineChunk(chunkLength, flatCoordinates, offset, end, stride) {\n  const chunks = [];\n  let cursor = offset;\n  let chunkM = 0;\n  let currentChunk = flatCoordinates.slice(offset, 2);\n  while (chunkM < chunkLength && cursor + stride < end) {\n    const [x1, y1] = currentChunk.slice(-2);\n    const x2 = flatCoordinates[cursor + stride];\n    const y2 = flatCoordinates[cursor + stride + 1];\n    const segmentLength = Math.sqrt(\n      (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1),\n    );\n    chunkM += segmentLength;\n    if (chunkM >= chunkLength) {\n      const m = (chunkLength - chunkM + segmentLength) / segmentLength;\n      const x = lerp(x1, x2, m);\n      const y = lerp(y1, y2, m);\n      currentChunk.push(x, y);\n      chunks.push(currentChunk);\n      currentChunk = [x, y];\n      if (chunkM == chunkLength) {\n        cursor += stride;\n      }\n      chunkM = 0;\n    } else if (chunkM < chunkLength) {\n      currentChunk.push(\n        flatCoordinates[cursor + stride],\n        flatCoordinates[cursor + stride + 1],\n      );\n      cursor += stride;\n    } else {\n      const missing = segmentLength - chunkM;\n      const x = lerp(x1, x2, missing / segmentLength);\n      const y = lerp(y1, y2, missing / segmentLength);\n      currentChunk.push(x, y);\n      chunks.push(currentChunk);\n      currentChunk = [x, y];\n      chunkM = 0;\n      cursor += stride;\n    }\n  }\n  if (chunkM > 0) {\n    chunks.push(currentChunk);\n  }\n  return chunks;\n}\n","/**\n * @module ol/geom/flat/reverse\n */\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n */\nexport function coordinates(flatCoordinates, offset, end, stride) {\n  while (offset < end - stride) {\n    for (let i = 0; i < stride; ++i) {\n      const tmp = flatCoordinates[offset + i];\n      flatCoordinates[offset + i] = flatCoordinates[end - stride + i];\n      flatCoordinates[end - stride + i] = tmp;\n    }\n    offset += stride;\n    end -= stride;\n  }\n}\n","/**\n * @module ol/geom/flat/orient\n */\nimport {coordinates as reverseCoordinates} from './reverse.js';\n\n/**\n * Is the linear ring oriented clockwise in a coordinate system with a bottom-left\n * coordinate origin? For a coordinate system with a top-left coordinate origin,\n * the ring's orientation is clockwise when this function returns false.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {boolean|undefined} Is clockwise.\n */\nexport function linearRingIsClockwise(flatCoordinates, offset, end, stride) {\n  // https://stackoverflow.com/q/1165647/clockwise-method#1165943\n  // https://github.com/OSGeo/gdal/blob/master/gdal/ogr/ogrlinearring.cpp\n  let edge = 0;\n  let x1 = flatCoordinates[end - stride];\n  let y1 = flatCoordinates[end - stride + 1];\n  for (; offset < end; offset += stride) {\n    const x2 = flatCoordinates[offset];\n    const y2 = flatCoordinates[offset + 1];\n    edge += (x2 - x1) * (y2 + y1);\n    x1 = x2;\n    y1 = y2;\n  }\n  return edge === 0 ? undefined : edge > 0;\n}\n\n/**\n * Determines if linear rings are oriented.  By default, left-hand orientation\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n * To test for right-hand orientation, use the `right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean} [right] Test for right-hand orientation\n *     (counter-clockwise exterior ring and clockwise interior rings).\n * @return {boolean} Rings are correctly oriented.\n */\nexport function linearRingsAreOriented(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  right,\n) {\n  right = right !== undefined ? right : false;\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    const isClockwise = linearRingIsClockwise(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n    );\n    if (i === 0) {\n      if ((right && isClockwise) || (!right && !isClockwise)) {\n        return false;\n      }\n    } else {\n      if ((right && !isClockwise) || (!right && isClockwise)) {\n        return false;\n      }\n    }\n    offset = end;\n  }\n  return true;\n}\n\n/**\n * Determines if linear rings are oriented.  By default, left-hand orientation\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n * To test for right-hand orientation, use the `right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Array of array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean} [right] Test for right-hand orientation\n *     (counter-clockwise exterior ring and clockwise interior rings).\n * @return {boolean} Rings are correctly oriented.\n */\nexport function linearRingssAreOriented(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  right,\n) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    if (!linearRingsAreOriented(flatCoordinates, offset, ends, stride, right)) {\n      return false;\n    }\n    if (ends.length) {\n      offset = ends[ends.length - 1];\n    }\n  }\n  return true;\n}\n\n/**\n * Orient coordinates in a flat array of linear rings.  By default, rings\n * are oriented following the left-hand rule (clockwise for exterior and\n * counter-clockwise for interior rings).  To orient according to the\n * right-hand rule, use the `right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {boolean} [right] Follow the right-hand rule for orientation.\n * @return {number} End.\n */\nexport function orientLinearRings(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  right,\n) {\n  right = right !== undefined ? right : false;\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    const isClockwise = linearRingIsClockwise(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n    );\n    const reverse =\n      i === 0\n        ? (right && isClockwise) || (!right && !isClockwise)\n        : (right && !isClockwise) || (!right && isClockwise);\n    if (reverse) {\n      reverseCoordinates(flatCoordinates, offset, end, stride);\n    }\n    offset = end;\n  }\n  return offset;\n}\n\n/**\n * Orient coordinates in a flat array of linear rings.  By default, rings\n * are oriented following the left-hand rule (clockwise for exterior and\n * counter-clockwise for interior rings).  To orient according to the\n * right-hand rule, use the `right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Array of array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean} [right] Follow the right-hand rule for orientation.\n * @return {number} End.\n */\nexport function orientLinearRingsArray(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  right,\n) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    offset = orientLinearRings(\n      flatCoordinates,\n      offset,\n      endss[i],\n      stride,\n      right,\n    );\n  }\n  return offset;\n}\n\n/**\n * Return a two-dimensional endss\n * @param {Array<number>} flatCoordinates Flat coordinates\n * @param {Array<number>} ends Linear ring end indexes\n * @return {Array<Array<number>>} Two dimensional endss array that can\n * be used to construct a MultiPolygon\n */\nexport function inflateEnds(flatCoordinates, ends) {\n  const endss = [];\n  let offset = 0;\n  let prevEndIndex = 0;\n  let startOrientation;\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    // classifies an array of rings into polygons with outer rings and holes\n    const orientation = linearRingIsClockwise(flatCoordinates, offset, end, 2);\n    if (startOrientation === undefined) {\n      startOrientation = orientation;\n    }\n    if (orientation === startOrientation) {\n      endss.push(ends.slice(prevEndIndex, i + 1));\n    } else {\n      if (endss.length === 0) {\n        continue;\n      }\n      endss[endss.length - 1].push(ends[prevEndIndex]);\n    }\n    prevEndIndex = i + 1;\n    offset = end;\n  }\n  return endss;\n}\n","/**\n * @module ol/geom/flat/segments\n */\n\n/**\n * This function calls `callback` for each segment of the flat coordinates\n * array. If the callback returns a truthy value the function returns that\n * value immediately. Otherwise the function returns `false`.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {function(import(\"../../coordinate.js\").Coordinate, import(\"../../coordinate.js\").Coordinate): T} callback Function\n *     called for each segment.\n * @return {T|boolean} Value.\n * @template T\n */\nexport function forEach(flatCoordinates, offset, end, stride, callback) {\n  let ret;\n  offset += stride;\n  for (; offset < end; offset += stride) {\n    ret = callback(\n      flatCoordinates.slice(offset - stride, offset),\n      flatCoordinates.slice(offset, offset + stride),\n    );\n    if (ret) {\n      return ret;\n    }\n  }\n  return false;\n}\n","/**\n * @module ol/geom/flat/simplify\n */\n// Based on simplify-js https://github.com/mourner/simplify-js\n// Copyright (c) 2012, Vladimir Agafonkin\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n//    1. Redistributions of source code must retain the above copyright notice,\n//       this list of conditions and the following disclaimer.\n//\n//    2. Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n\nimport {squaredDistance, squaredSegmentDistance} from '../../math.js';\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {boolean} highQuality Highest quality.\n * @param {Array<number>} [simplifiedFlatCoordinates] Simplified flat\n *     coordinates.\n * @return {Array<number>} Simplified line string.\n */\nexport function simplifyLineString(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  squaredTolerance,\n  highQuality,\n  simplifiedFlatCoordinates,\n) {\n  simplifiedFlatCoordinates =\n    simplifiedFlatCoordinates !== undefined ? simplifiedFlatCoordinates : [];\n  if (!highQuality) {\n    end = radialDistance(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      squaredTolerance,\n      simplifiedFlatCoordinates,\n      0,\n    );\n    flatCoordinates = simplifiedFlatCoordinates;\n    offset = 0;\n    stride = 2;\n  }\n  simplifiedFlatCoordinates.length = douglasPeucker(\n    flatCoordinates,\n    offset,\n    end,\n    stride,\n    squaredTolerance,\n    simplifiedFlatCoordinates,\n    0,\n  );\n  return simplifiedFlatCoordinates;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\nexport function douglasPeucker(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  squaredTolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset,\n) {\n  const n = (end - offset) / stride;\n  if (n < 3) {\n    for (; offset < end; offset += stride) {\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n        flatCoordinates[offset + 1];\n    }\n    return simplifiedOffset;\n  }\n  /** @type {Array<number>} */\n  const markers = new Array(n);\n  markers[0] = 1;\n  markers[n - 1] = 1;\n  /** @type {Array<number>} */\n  const stack = [offset, end - stride];\n  let index = 0;\n  while (stack.length > 0) {\n    const last = stack.pop();\n    const first = stack.pop();\n    let maxSquaredDistance = 0;\n    const x1 = flatCoordinates[first];\n    const y1 = flatCoordinates[first + 1];\n    const x2 = flatCoordinates[last];\n    const y2 = flatCoordinates[last + 1];\n    for (let i = first + stride; i < last; i += stride) {\n      const x = flatCoordinates[i];\n      const y = flatCoordinates[i + 1];\n      const squaredDistance = squaredSegmentDistance(x, y, x1, y1, x2, y2);\n      if (squaredDistance > maxSquaredDistance) {\n        index = i;\n        maxSquaredDistance = squaredDistance;\n      }\n    }\n    if (maxSquaredDistance > squaredTolerance) {\n      markers[(index - offset) / stride] = 1;\n      if (first + stride < index) {\n        stack.push(first, index);\n      }\n      if (index + stride < last) {\n        stack.push(index, last);\n      }\n    }\n  }\n  for (let i = 0; i < n; ++i) {\n    if (markers[i]) {\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n        flatCoordinates[offset + i * stride];\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n        flatCoordinates[offset + i * stride + 1];\n    }\n  }\n  return simplifiedOffset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<number>} simplifiedEnds Simplified ends.\n * @return {number} Simplified offset.\n */\nexport function douglasPeuckerArray(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  squaredTolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset,\n  simplifiedEnds,\n) {\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    simplifiedOffset = douglasPeucker(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      squaredTolerance,\n      simplifiedFlatCoordinates,\n      simplifiedOffset,\n    );\n    simplifiedEnds.push(simplifiedOffset);\n    offset = end;\n  }\n  return simplifiedOffset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<Array<number>>} simplifiedEndss Simplified endss.\n * @return {number} Simplified offset.\n */\nexport function douglasPeuckerMultiArray(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  squaredTolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset,\n  simplifiedEndss,\n) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    /** @type {Array<number>} */\n    const simplifiedEnds = [];\n    simplifiedOffset = douglasPeuckerArray(\n      flatCoordinates,\n      offset,\n      ends,\n      stride,\n      squaredTolerance,\n      simplifiedFlatCoordinates,\n      simplifiedOffset,\n      simplifiedEnds,\n    );\n    simplifiedEndss.push(simplifiedEnds);\n    offset = ends[ends.length - 1];\n  }\n  return simplifiedOffset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\nexport function radialDistance(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  squaredTolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset,\n) {\n  if (end <= offset + stride) {\n    // zero or one point, no simplification possible, so copy and return\n    for (; offset < end; offset += stride) {\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n        flatCoordinates[offset + 1];\n    }\n    return simplifiedOffset;\n  }\n  let x1 = flatCoordinates[offset];\n  let y1 = flatCoordinates[offset + 1];\n  // copy first point\n  simplifiedFlatCoordinates[simplifiedOffset++] = x1;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y1;\n  let x2 = x1;\n  let y2 = y1;\n  for (offset += stride; offset < end; offset += stride) {\n    x2 = flatCoordinates[offset];\n    y2 = flatCoordinates[offset + 1];\n    if (squaredDistance(x1, y1, x2, y2) > squaredTolerance) {\n      // copy point at offset\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n      x1 = x2;\n      y1 = y2;\n    }\n  }\n  if (x2 != x1 || y2 != y1) {\n    // copy last point\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n  }\n  return simplifiedOffset;\n}\n\n/**\n * @param {number} value Value.\n * @param {number} tolerance Tolerance.\n * @return {number} Rounded value.\n */\nexport function snap(value, tolerance) {\n  return tolerance * Math.round(value / tolerance);\n}\n\n/**\n * Simplifies a line string using an algorithm designed by Tim Schaub.\n * Coordinates are snapped to the nearest value in a virtual grid and\n * consecutive duplicate coordinates are discarded.  This effectively preserves\n * topology as the simplification of any subsection of a line string is\n * independent of the rest of the line string.  This means that, for examples,\n * the common edge between two polygons will be simplified to the same line\n * string independently in both polygons.  This implementation uses a single\n * pass over the coordinates and eliminates intermediate collinear points.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\nexport function quantize(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  tolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset,\n) {\n  // do nothing if the line is empty\n  if (offset == end) {\n    return simplifiedOffset;\n  }\n  // snap the first coordinate (P1)\n  let x1 = snap(flatCoordinates[offset], tolerance);\n  let y1 = snap(flatCoordinates[offset + 1], tolerance);\n  offset += stride;\n  // add the first coordinate to the output\n  simplifiedFlatCoordinates[simplifiedOffset++] = x1;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y1;\n  // find the next coordinate that does not snap to the same value as the first\n  // coordinate (P2)\n  let x2, y2;\n  do {\n    x2 = snap(flatCoordinates[offset], tolerance);\n    y2 = snap(flatCoordinates[offset + 1], tolerance);\n    offset += stride;\n    if (offset == end) {\n      // all coordinates snap to the same value, the line collapses to a point\n      // push the last snapped value anyway to ensure that the output contains\n      // at least two points\n      // FIXME should we really return at least two points anyway?\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n      return simplifiedOffset;\n    }\n  } while (x2 == x1 && y2 == y1);\n  while (offset < end) {\n    // snap the next coordinate (P3)\n    const x3 = snap(flatCoordinates[offset], tolerance);\n    const y3 = snap(flatCoordinates[offset + 1], tolerance);\n    offset += stride;\n    // skip P3 if it is equal to P2\n    if (x3 == x2 && y3 == y2) {\n      continue;\n    }\n    // calculate the delta between P1 and P2\n    const dx1 = x2 - x1;\n    const dy1 = y2 - y1;\n    // calculate the delta between P3 and P1\n    const dx2 = x3 - x1;\n    const dy2 = y3 - y1;\n    // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from\n    // P1 in the same direction then P2 is on the straight line between P1 and\n    // P3\n    if (\n      dx1 * dy2 == dy1 * dx2 &&\n      ((dx1 < 0 && dx2 < dx1) || dx1 == dx2 || (dx1 > 0 && dx2 > dx1)) &&\n      ((dy1 < 0 && dy2 < dy1) || dy1 == dy2 || (dy1 > 0 && dy2 > dy1))\n    ) {\n      // discard P2 and set P2 = P3\n      x2 = x3;\n      y2 = y3;\n      continue;\n    }\n    // either P1, P2, and P3 are not colinear, or they are colinear but P3 is\n    // between P3 and P1 or on the opposite half of the line to P2.  add P2,\n    // and continue with P1 = P2 and P2 = P3\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n    x1 = x2;\n    y1 = y2;\n    x2 = x3;\n    y2 = y3;\n  }\n  // add the last point (P2)\n  simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n  return simplifiedOffset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<number>} simplifiedEnds Simplified ends.\n * @return {number} Simplified offset.\n */\nexport function quantizeArray(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  tolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset,\n  simplifiedEnds,\n) {\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    simplifiedOffset = quantize(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      tolerance,\n      simplifiedFlatCoordinates,\n      simplifiedOffset,\n    );\n    simplifiedEnds.push(simplifiedOffset);\n    offset = end;\n  }\n  return simplifiedOffset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<Array<number>>} simplifiedEndss Simplified endss.\n * @return {number} Simplified offset.\n */\nexport function quantizeMultiArray(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  tolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset,\n  simplifiedEndss,\n) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    /** @type {Array<number>} */\n    const simplifiedEnds = [];\n    simplifiedOffset = quantizeArray(\n      flatCoordinates,\n      offset,\n      ends,\n      stride,\n      tolerance,\n      simplifiedFlatCoordinates,\n      simplifiedOffset,\n      simplifiedEnds,\n    );\n    simplifiedEndss.push(simplifiedEnds);\n    offset = ends[ends.length - 1];\n  }\n  return simplifiedOffset;\n}\n","/**\n * @module ol/geom/flat/straightchunk\n */\n\n/**\n * @param {number} maxAngle Maximum acceptable angle delta between segments.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {Array<number>} Start and end of the first suitable chunk of the\n * given `flatCoordinates`.\n */\nexport function matchingChunk(maxAngle, flatCoordinates, offset, end, stride) {\n  let chunkStart = offset;\n  let chunkEnd = offset;\n  let chunkM = 0;\n  let m = 0;\n  let start = offset;\n  let acos, i, m12, m23, x1, y1, x12, y12, x23, y23;\n  for (i = offset; i < end; i += stride) {\n    const x2 = flatCoordinates[i];\n    const y2 = flatCoordinates[i + 1];\n    if (x1 !== undefined) {\n      x23 = x2 - x1;\n      y23 = y2 - y1;\n      m23 = Math.sqrt(x23 * x23 + y23 * y23);\n      if (x12 !== undefined) {\n        m += m12;\n        acos = Math.acos((x12 * x23 + y12 * y23) / (m12 * m23));\n        if (acos > maxAngle) {\n          if (m > chunkM) {\n            chunkM = m;\n            chunkStart = start;\n            chunkEnd = i;\n          }\n          m = 0;\n          start = i - stride;\n        }\n      }\n      m12 = m23;\n      x12 = x23;\n      y12 = y23;\n    }\n    x1 = x2;\n    y1 = y2;\n  }\n  m += m23;\n  return m > chunkM ? [start, i] : [chunkStart, chunkEnd];\n}\n","/**\n * @module ol/geom/flat/textpath\n */\nimport {lerp} from '../../math.js';\nimport {rotate} from './transform.js';\n\n/**\n * @param {Array<number>} flatCoordinates Path to put text on.\n * @param {number} offset Start offset of the `flatCoordinates`.\n * @param {number} end End offset of the `flatCoordinates`.\n * @param {number} stride Stride.\n * @param {string} text Text to place on the path.\n * @param {number} startM m along the path where the text starts.\n * @param {number} maxAngle Max angle between adjacent chars in radians.\n * @param {number} scale The product of the text scale and the device pixel ratio.\n * @param {function(string, string, Object<string, number>):number} measureAndCacheTextWidth Measure and cache text width.\n * @param {string} font The font.\n * @param {Object<string, number>} cache A cache of measured widths.\n * @param {number} rotation Rotation to apply to the flatCoordinates to determine whether text needs to be reversed.\n * @return {Array<Array<*>>|null} The result array (or null if `maxAngle` was\n * exceeded). Entries of the array are x, y, anchorX, angle, chunk.\n */\nexport function drawTextOnPath(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  text,\n  startM,\n  maxAngle,\n  scale,\n  measureAndCacheTextWidth,\n  font,\n  cache,\n  rotation,\n) {\n  let x2 = flatCoordinates[offset];\n  let y2 = flatCoordinates[offset + 1];\n  let x1 = 0;\n  let y1 = 0;\n  let segmentLength = 0;\n  let segmentM = 0;\n\n  function advance() {\n    x1 = x2;\n    y1 = y2;\n    offset += stride;\n    x2 = flatCoordinates[offset];\n    y2 = flatCoordinates[offset + 1];\n    segmentM += segmentLength;\n    segmentLength = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n  }\n  do {\n    advance();\n  } while (offset < end - stride && segmentM + segmentLength < startM);\n\n  let interpolate =\n    segmentLength === 0 ? 0 : (startM - segmentM) / segmentLength;\n  const beginX = lerp(x1, x2, interpolate);\n  const beginY = lerp(y1, y2, interpolate);\n\n  const startOffset = offset - stride;\n  const startLength = segmentM;\n  const endM = startM + scale * measureAndCacheTextWidth(font, text, cache);\n  while (offset < end - stride && segmentM + segmentLength < endM) {\n    advance();\n  }\n  interpolate = segmentLength === 0 ? 0 : (endM - segmentM) / segmentLength;\n  const endX = lerp(x1, x2, interpolate);\n  const endY = lerp(y1, y2, interpolate);\n\n  // Keep text upright\n  let reverse;\n  if (rotation) {\n    const flat = [beginX, beginY, endX, endY];\n    rotate(flat, 0, 4, 2, rotation, flat, flat);\n    reverse = flat[0] > flat[2];\n  } else {\n    reverse = beginX > endX;\n  }\n\n  const PI = Math.PI;\n  const result = [];\n  const singleSegment = startOffset + stride === offset;\n\n  offset = startOffset;\n  segmentLength = 0;\n  segmentM = startLength;\n  x2 = flatCoordinates[offset];\n  y2 = flatCoordinates[offset + 1];\n\n  let previousAngle;\n  // All on the same segment\n  if (singleSegment) {\n    advance();\n\n    previousAngle = Math.atan2(y2 - y1, x2 - x1);\n    if (reverse) {\n      previousAngle += previousAngle > 0 ? -PI : PI;\n    }\n    const x = (endX + beginX) / 2;\n    const y = (endY + beginY) / 2;\n    result[0] = [x, y, (endM - startM) / 2, previousAngle, text];\n    return result;\n  }\n\n  // rendering across line segments\n  text = text.replace(/\\n/g, ' '); // ensure rendering in single-line as all calculations below don't handle multi-lines\n\n  for (let i = 0, ii = text.length; i < ii; ) {\n    advance();\n    let angle = Math.atan2(y2 - y1, x2 - x1);\n    if (reverse) {\n      angle += angle > 0 ? -PI : PI;\n    }\n    if (previousAngle !== undefined) {\n      let delta = angle - previousAngle;\n      delta += delta > PI ? -2 * PI : delta < -PI ? 2 * PI : 0;\n      if (Math.abs(delta) > maxAngle) {\n        return null;\n      }\n    }\n    previousAngle = angle;\n\n    const iStart = i;\n    let charLength = 0;\n    for (; i < ii; ++i) {\n      const index = reverse ? ii - i - 1 : i;\n      const len = scale * measureAndCacheTextWidth(font, text[index], cache);\n      if (\n        offset + stride < end &&\n        segmentM + segmentLength < startM + charLength + len / 2\n      ) {\n        break;\n      }\n      charLength += len;\n    }\n    if (i === iStart) {\n      continue;\n    }\n    const chars = reverse\n      ? text.substring(ii - iStart, ii - i)\n      : text.substring(iStart, i);\n    interpolate =\n      segmentLength === 0\n        ? 0\n        : (startM + charLength / 2 - segmentM) / segmentLength;\n    const x = lerp(x1, x2, interpolate);\n    const y = lerp(y1, y2, interpolate);\n    result.push([x, y, charLength / 2, angle, chars]);\n    startM += charLength;\n  }\n  return result;\n}\n","/**\n * @module ol/geom/flat/transform\n */\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../transform.js\").Transform} transform Transform.\n * @param {Array<number>} [dest] Destination.\n * @return {Array<number>} Transformed coordinates.\n */\nexport function transform2D(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  transform,\n  dest,\n) {\n  dest = dest ? dest : [];\n  let i = 0;\n  for (let j = offset; j < end; j += stride) {\n    const x = flatCoordinates[j];\n    const y = flatCoordinates[j + 1];\n    dest[i++] = transform[0] * x + transform[2] * y + transform[4];\n    dest[i++] = transform[1] * x + transform[3] * y + transform[5];\n  }\n  if (dest && dest.length != i) {\n    dest.length = i;\n  }\n  return dest;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} angle Angle.\n * @param {Array<number>} anchor Rotation anchor point.\n * @param {Array<number>} [dest] Destination.\n * @return {Array<number>} Transformed coordinates.\n */\nexport function rotate(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  angle,\n  anchor,\n  dest,\n) {\n  dest = dest ? dest : [];\n  const cos = Math.cos(angle);\n  const sin = Math.sin(angle);\n  const anchorX = anchor[0];\n  const anchorY = anchor[1];\n  let i = 0;\n  for (let j = offset; j < end; j += stride) {\n    const deltaX = flatCoordinates[j] - anchorX;\n    const deltaY = flatCoordinates[j + 1] - anchorY;\n    dest[i++] = anchorX + deltaX * cos - deltaY * sin;\n    dest[i++] = anchorY + deltaX * sin + deltaY * cos;\n    for (let k = j + 2; k < j + stride; ++k) {\n      dest[i++] = flatCoordinates[k];\n    }\n  }\n  if (dest && dest.length != i) {\n    dest.length = i;\n  }\n  return dest;\n}\n\n/**\n * Scale the coordinates.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} sx Scale factor in the x-direction.\n * @param {number} sy Scale factor in the y-direction.\n * @param {Array<number>} anchor Scale anchor point.\n * @param {Array<number>} [dest] Destination.\n * @return {Array<number>} Transformed coordinates.\n */\nexport function scale(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  sx,\n  sy,\n  anchor,\n  dest,\n) {\n  dest = dest ? dest : [];\n  const anchorX = anchor[0];\n  const anchorY = anchor[1];\n  let i = 0;\n  for (let j = offset; j < end; j += stride) {\n    const deltaX = flatCoordinates[j] - anchorX;\n    const deltaY = flatCoordinates[j + 1] - anchorY;\n    dest[i++] = anchorX + sx * deltaX;\n    dest[i++] = anchorY + sy * deltaY;\n    for (let k = j + 2; k < j + stride; ++k) {\n      dest[i++] = flatCoordinates[k];\n    }\n  }\n  if (dest && dest.length != i) {\n    dest.length = i;\n  }\n  return dest;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} deltaX Delta X.\n * @param {number} deltaY Delta Y.\n * @param {Array<number>} [dest] Destination.\n * @return {Array<number>} Transformed coordinates.\n */\nexport function translate(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  deltaX,\n  deltaY,\n  dest,\n) {\n  dest = dest ? dest : [];\n  let i = 0;\n  for (let j = offset; j < end; j += stride) {\n    dest[i++] = flatCoordinates[j] + deltaX;\n    dest[i++] = flatCoordinates[j + 1] + deltaY;\n    for (let k = j + 2; k < j + stride; ++k) {\n      dest[i++] = flatCoordinates[k];\n    }\n  }\n  if (dest && dest.length != i) {\n    dest.length = i;\n  }\n  return dest;\n}\n"],"names":["TRUE","FALSE","VOID","memoizeOne","fn","lastResult","lastArgs","lastThis","called","nextArgs","Array","prototype","slice","call","arguments","this","apply","toPromise","getter","promiseGetter","value","err","Promise","reject","resolve","tmpTransform","Geometry","constructor","super","extent_","extentRevision_","simplifiedGeometryMaxMinSquaredTolerance","simplifiedGeometryRevision","simplifyTransformedInternal","revision","squaredTolerance","transform","getSimplifiedGeometry","clone","applyTransform","simplifyTransformed","getRevision","closestPointXY","x","y","closestPoint","minSquaredDistance","containsXY","coord","getClosestPoint","point","NaN","Infinity","intersectsCoordinate","coordinate","computeExtent","extent","getExtent","isNaN","rotate","angle","anchor","scale","sx","sy","simplify","tolerance","getType","transformFn","intersectsExtent","translate","deltaX","deltaY","source","destination","sourceProj","get","getUnits","inCoordinates","outCoordinates","stride","pixelExtent","projectedExtent","getWorldExtent","length","getTransform","GeometryCollection","geometries","geometries_","changeEventsKeys_","listenGeometriesChange_","unlistenGeometriesChange_","forEach","i","ii","push","CHANGE","changed","geometryCollection","cloneGeometries","applyProperties","getGeometries","getGeometriesArray","getGeometriesArrayRecursive","geometriesArray","concat","simplifiedGeometries","simplified","geometry","simplifiedGeometry","simplifiedGeometryCollection","isEmpty","setGeometries","setGeometriesArray","disposeInternal","map","LineString","coordinates","layout","flatMidpoint_","flatMidpointRevision_","maxDelta_","maxDeltaRevision_","undefined","isArray","setCoordinates","setFlatCoordinates","appendCoordinate","flatCoordinates","lineString","Math","sqrt","forEachSegment","callback","getCoordinateAtM","m","extrapolate","getCoordinates","getCoordinateAt","fraction","dest","getLength","getFlatMidpoint","getSimplifiedGeometryInternal","simplifiedFlatCoordinates","setLayout","LinearRing","getArea","MultiLineString","ends","ends_","lineStrings","getFlatCoordinates","getLayout","appendLineString","multiLineString","interpolate","getEnds","getLineString","index","getLineStrings","offset","end","getFlatMidpoints","midpoints","midpoint","simplifiedEnds","MultiPoint","appendPoint","multiPoint","squaredDistance","j","getPoint","n","getPoints","points","MultiPolygon","endss","endss_","flatInteriorPointsRevision_","flatInteriorPoints_","orientedRevision_","orientedFlatCoordinates_","polygons","thisEndss","polygon","jj","appendPolygon","len","newEndss","multiPolygon","getOrientedFlatCoordinates","right","getEndss","getFlatInteriorPoints","flatCenters","getInteriorPoints","simplifiedEndss","getPolygon","prevEnds","getPolygons","lastEnds","Point","Polygon","flatInteriorPointRevision_","flatInteriorPoint_","appendLinearRing","linearRing","getFlatInteriorPoint","flatCenter","getInteriorPoint","getLinearRingCount","getLinearRing","getLinearRings","linearRings","fromExtent","Error","minX","minY","maxX","maxY","fromCircle","circle","sides","getStride","center","getCenter","arrayLength","makeRegular","getRadius","radius","startAngle","PI","cos","sin","SimpleGeometry","getFirstCoordinate","getLastCoordinate","getStrideForLayout","nesting","getLayoutForStride","transformGeom2D","simpleGeometry","twiceArea","x1","y1","x2","y2","area","linearRingss","assignClosest","offset1","offset2","dx","dy","t","maxSquaredDelta","max","squaredDelta","arrayMaxSquaredDelta","multiArrayMaxSquaredDelta","assignClosestPoint","maxDelta","isRing","tmpPoint","assignClosestArrayPoint","assignClosestMultiArrayPoint","linearRingContainsExtent","outside","linearRingContainsXY","wn","linearRingsContainsXY","linearRingssContainsXY","deflateCoordinate","deflateCoordinates","deflateCoordinatesArray","coordinatess","deflateMultiCoordinatesArray","coordinatesss","inflateCoordinates","inflateCoordinatesArray","inflateMultiCoordinatesArray","getInteriorPointOfArray","flatCentersOffset","intersections","r","rr","pointX","maxSegmentLength","sort","segmentLength","abs","getInteriorPointsOfMultiArray","interiorPoints","interpolatePoint","dimension","o","cumulativeLengths","target","lineStringCoordinateAtM","lo","hi","mid","m0","m1","lineStringsCoordinateAtM","intersectsLineString","coordinatesExtent","point1","point2","intersectsLineStringArray","intersectsLinearRing","intersectsLinearRingArray","intersectsLinearRingMultiArray","lineStringLength","lineChunk","chunkLength","chunks","cursor","chunkM","currentChunk","missing","tmp","linearRingIsClockwise","edge","linearRingsAreOriented","isClockwise","linearRingssAreOriented","orientLinearRings","reverse","orientLinearRingsArray","inflateEnds","startOrientation","prevEndIndex","orientation","ret","douglasPeucker","simplifiedOffset","markers","stack","last","pop","first","maxSquaredDistance","douglasPeuckerArray","snap","round","quantize","x3","y3","dx1","dy1","dx2","dy2","quantizeArray","quantizeMultiArray","matchingChunk","maxAngle","acos","m12","m23","x12","y12","x23","y23","chunkStart","chunkEnd","start","drawTextOnPath","text","startM","measureAndCacheTextWidth","font","cache","rotation","segmentM","advance","beginX","beginY","startOffset","startLength","endM","endX","endY","flat","result","singleSegment","previousAngle","atan2","replace","delta","iStart","charLength","chars","substring","transform2D","anchorX","anchorY","k"],"sourceRoot":""}
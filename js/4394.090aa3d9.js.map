{"version":3,"file":"js/4394.090aa3d9.js","mappings":"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","sources":["webpack://@openeo/web-editor/./node_modules/ol-ext/interaction/ModifyFeature.js","webpack://@openeo/web-editor/./node_modules/ol-ext/interaction/DrawHole.js","webpack://@openeo/web-editor/./node_modules/ol-ext/geom/GeomUtils.js","webpack://@openeo/web-editor/./node_modules/ol-ext/style/defaultStyle.js","webpack://@openeo/web-editor/./node_modules/ol-ext/interaction/Delete.js","webpack://@openeo/web-editor/./node_modules/ol-ext/control/TextButton.js","webpack://@openeo/web-editor/./node_modules/ol-ext/interaction/DrawRegular.js","webpack://@openeo/web-editor/./node_modules/ol-ext/source/Vector.js","webpack://@openeo/web-editor/./node_modules/ol-ext/interaction/UndoRedo.js","webpack://@openeo/web-editor/./node_modules/ol-ext/control/Toggle.js","webpack://@openeo/web-editor/./node_modules/ol-ext/interaction/Split.js","webpack://@openeo/web-editor/./node_modules/ol/interaction/Draw.js","webpack://@openeo/web-editor/./node_modules/ol-ext/interaction/Transform.js","webpack://@openeo/web-editor/./node_modules/ol-ext/interaction/Offset.js","webpack://@openeo/web-editor/./node_modules/ol/interaction/Extent.js","webpack://@openeo/web-editor/./node_modules/ol/events/SnapEvent.js","webpack://@openeo/web-editor/./node_modules/ol/interaction/Snap.js","webpack://@openeo/web-editor/./node_modules/ol-ext/geom/LineStringSplitAt.js","webpack://@openeo/web-editor/./node_modules/ol/geom/Circle.js"],"sourcesContent":["/*\tCopyright (c) 2016 Jean-Marc VIGLINO, \r\n  released under the CeCILL-B license (French BSD license)\r\n  (http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).\r\n*/\r\n\r\nimport ol_style_Style from 'ol/style/Style.js'\r\nimport ol_style_Stroke from 'ol/style/Stroke.js'\r\nimport ol_source_Vector from 'ol/source/Vector.js'\r\nimport ol_style_Fill from 'ol/style/Fill.js'\r\nimport ol_style_Circle from 'ol/style/Circle.js'\r\nimport ol_layer_Vector from 'ol/layer/Vector.js'\r\nimport ol_geom_Point from 'ol/geom/Point.js'\r\nimport ol_Feature from 'ol/Feature.js'\r\nimport ol_geom_LineString from 'ol/geom/LineString.js'\r\nimport ol_interaction_Interaction from 'ol/interaction/Interaction.js'\r\nimport {ol_coordinate_dist2d, ol_coordinate_equal} from \"../geom/GeomUtils.js\";\r\nimport {boundingExtent as ol_extent_boundingExtent} from 'ol/extent.js'\r\nimport {buffer as ol_extent_buffer} from 'ol/extent.js'\r\nimport {altKeyOnly as ol_events_condition_altKeyOnly} from 'ol/events/condition.js'\r\nimport {primaryAction as ol_events_condition_primaryAction} from 'ol/events/condition.js'\r\nimport {always as ol_events_condition_always} from 'ol/events/condition.js'\r\n\r\nimport ol_ext_element from '../util/element.js'\r\nimport '../geom/LineStringSplitAt.js'\r\n\r\n/** Interaction for modifying feature geometries. Similar to the core ol/interaction/Modify.\r\n * The interaction is more suitable to use to handle feature modification: only features concerned \r\n * by the modification are passed to the events (instead of all feature with ol/interaction/Modify)\r\n * - the modifystart event is fired before the feature is modified (no points still inserted)\r\n * - the modifyend event is fired after the modification\r\n * - it fires a modifying event\r\n * @constructor\r\n * @extends {ol_interaction_Interaction}\r\n * @fires modifystart\r\n * @fires modifying\r\n * @fires modifyend\r\n * @fires select\r\n * @param {*} options\r\n *\t@param {ol.source.Vector} options.source a source to modify (configured with useSpatialIndex set to true)\r\n *\t@param {ol.source.Vector|Array<ol.source.Vector>} options.sources a list of source to modify (configured with useSpatialIndex set to true)\r\n *  @param {ol.Collection.<ol.Feature>} options.features collection of feature to modify\r\n *  @param {integer} options.pixelTolerance Pixel tolerance for considering the pointer close enough to a segment or vertex for editing. Default is 10.\r\n *  @param {function|undefined} options.filter a filter that takes a feature and return true if it can be modified, default always true.\r\n *  @param {ol.style.Style | Array<ol.style.Style> | undefined} options.style Style for the sketch features.\r\n *  @param {ol.EventsConditionType | undefined} options.condition A function that takes an ol.MapBrowserEvent and returns a boolean to indicate whether that event will be considered to add or move a vertex to the sketch. Default is ol.events.condition.primaryAction.\r\n *  @param {ol.EventsConditionType | undefined} options.deleteCondition A function that takes an ol.MapBrowserEvent and returns a boolean to indicate whether that event should be handled. By default, ol.events.condition.singleClick with ol.events.condition.altKeyOnly results in a vertex deletion.\r\n *  @param {ol.EventsConditionType | undefined} options.insertVertexCondition A function that takes an ol.MapBrowserEvent and returns a boolean to indicate whether a new vertex can be added to the sketch features. Default is ol.events.condition.always\r\n *  @param {boolean} options.wrapX Wrap the world horizontally on the sketch overlay, default false\r\n */\r\nvar ol_interaction_ModifyFeature = class olinteractionModifyFeature extends ol_interaction_Interaction {\r\n  constructor(options) {\r\n    options = options || {}\r\n\r\n    var dragging, modifying\r\n    super({\r\n      handleEvent: function (e) {\r\n        switch (e.type) {\r\n          case 'pointerdown': {\r\n            dragging = this.handleDownEvent(e)\r\n            modifying = dragging || this._deleteCondition(e)\r\n            return !dragging\r\n          }\r\n          case 'pointerup': {\r\n            dragging = false\r\n            return this.handleUpEvent(e)\r\n          }\r\n          case 'pointerdrag': {\r\n            if (dragging)\r\n              return this.handleDragEvent(e)\r\n            else\r\n              return true\r\n          }\r\n          case 'pointermove': {\r\n            if (!dragging){\r\n              return this.handleMoveEvent(e)\r\n            } else {\r\n              return false\r\n            }\r\n          }\r\n          case 'singleclick':\r\n          case 'click': {\r\n            // Prevent click when modifying\r\n            return !modifying\r\n          }\r\n          default: return true\r\n        }\r\n      }\r\n    })\r\n\r\n    // Snap distance (in px)\r\n    this.snapDistance_ = options.pixelTolerance || 10\r\n    // Split tolerance between the calculated intersection and the geometry\r\n    this.tolerance_ = 1e-10\r\n    // Cursor\r\n    this.cursor_ = options.cursor\r\n\r\n    // List of source to split\r\n    this.sources_ = options.sources ? (options.sources instanceof Array) ? options.sources : [options.sources] : []\r\n    if (options.source) {\r\n      this.sources_.push(options.source)\r\n    }\r\n    if (options.features) {\r\n      this.sources_.push(new ol_source_Vector({ features: options.features }))\r\n    }\r\n    // Get all features candidate\r\n    this.filterSplit_ = options.filter || function () { return true }\r\n\r\n    this._condition = options.condition || ol_events_condition_primaryAction\r\n    this._deleteCondition = options.deleteCondition || ol_events_condition_altKeyOnly\r\n    this._insertVertexCondition = options.insertVertexCondition || ol_events_condition_always\r\n\r\n    // Default style\r\n    var sketchStyle = function () {\r\n      return [new ol_style_Style({\r\n        image: new ol_style_Circle({\r\n          radius: 6,\r\n          fill: new ol_style_Fill({ color: [0, 153, 255, 1] }),\r\n          stroke: new ol_style_Stroke({ color: '#FFF', width: 1.25 })\r\n        })\r\n      })\r\n      ]\r\n    }\r\n\r\n    // Custom style\r\n    if (options.style) {\r\n      if (typeof (options.style) === 'function') {\r\n        sketchStyle = options.style\r\n      } else {\r\n        sketchStyle = function () { return options.style }\r\n      }\r\n    }\r\n\r\n    // Create a new overlay for the sketch\r\n    this.overlayLayer_ = new ol_layer_Vector({\r\n      source: new ol_source_Vector({\r\n        useSpatialIndex: false\r\n      }),\r\n      name: 'Modify overlay',\r\n      displayInLayerSwitcher: false,\r\n      style: sketchStyle,\r\n      wrapX: options.wrapX\r\n    })\r\n\r\n  }\r\n  /**\r\n   * Remove the interaction from its current map, if any,  and attach it to a new\r\n   * map, if any. Pass `null` to just remove the interaction from the current map.\r\n   * @param {ol.Map} map Map.\r\n   * @api stable\r\n   */\r\n  setMap(map) {\r\n    if (this.getMap()) this.getMap().removeLayer(this.overlayLayer_)\r\n    super.setMap(map)\r\n    this.overlayLayer_.setMap(map)\r\n  }\r\n  /**\r\n   * Activate or deactivate the interaction + remove the sketch.\r\n   * @param {boolean} active.\r\n   * @api stable\r\n   */\r\n  setActive(active) {\r\n    super.setActive(active)\r\n    if (this.overlayLayer_) this.overlayLayer_.getSource().clear()\r\n  }\r\n  /** Change the filter function\r\n   * @param {function|undefined} options.filter a filter that takes a feature and return true if it can be modified, default always true.\r\n   */\r\n  setFilter(filter) {\r\n    if (typeof (filter) === 'function')\r\n      this.filterSplit_ = filter\r\n    else if (filter === undefined)\r\n      this.filterSplit_ = function () { return true }\r\n  }\r\n  /** Get closest feature at pixel\r\n   * @param {ol.Pixel}\r\n   * @return {*}\r\n   * @private\r\n   */\r\n  getClosestFeature(e) {\r\n    var f, c, d = this.snapDistance_ + 1\r\n    for (var i = 0; i < this.sources_.length; i++) {\r\n      var source = this.sources_[i]\r\n      f = source.getClosestFeatureToCoordinate(e.coordinate)\r\n      if (f && this.filterSplit_(f)) {\r\n        var ci = f.getGeometry().getClosestPoint(e.coordinate)\r\n        var di = ol_coordinate_dist2d(e.coordinate, ci) / e.frameState.viewState.resolution\r\n        if (di < d) {\r\n          d = di\r\n          c = ci\r\n        }\r\n        break\r\n      }\r\n    }\r\n    if (d > this.snapDistance_) {\r\n      if (this.currentFeature)\r\n        this.dispatchEvent({ type: 'select', selected: [], deselected: [this.currentFeature] })\r\n      this.currentFeature = null\r\n      return false\r\n    } else {\r\n      // Snap to node\r\n      var coord = this.getNearestCoord(c, f.getGeometry())\r\n      if (coord) {\r\n        coord = coord.coord\r\n        var p = this.getMap().getPixelFromCoordinate(coord)\r\n        if (ol_coordinate_dist2d(e.pixel, p) < this.snapDistance_) {\r\n          c = coord\r\n        }\r\n        //\r\n        if (this.currentFeature !== f)\r\n          this.dispatchEvent({ type: 'select', selected: [f], deselected: [this.currentFeature] })\r\n        this.currentFeature = f\r\n        return { source: source, feature: f, coord: c }\r\n      }\r\n    }\r\n  }\r\n  /** Get nearest coordinate in a list\r\n  * @param {ol.coordinate} pt the point to find nearest\r\n  * @param {ol.geom} coords list of coordinates\r\n  * @return {*} the nearest point with a coord (projected point), dist (distance to the geom), ring (if Polygon)\r\n  */\r\n  getNearestCoord(pt, geom) {\r\n    var i, l, p, p0, dm\r\n    switch (geom.getType()) {\r\n      case 'Point': {\r\n        return { coord: geom.getCoordinates(), dist: ol_coordinate_dist2d(geom.getCoordinates(), pt) }\r\n      }\r\n      case 'MultiPoint': {\r\n        return this.getNearestCoord(pt, new ol_geom_LineString(geom.getCoordinates()))\r\n      }\r\n      case 'LineString':\r\n      case 'LinearRing': {\r\n        var d\r\n        dm = Number.MAX_VALUE\r\n        var coords = geom.getCoordinates()\r\n        for (i = 0; i < coords.length; i++) {\r\n          d = ol_coordinate_dist2d(pt, coords[i])\r\n          if (d < dm) {\r\n            dm = d\r\n            p0 = coords[i]\r\n          }\r\n        }\r\n        return { coord: p0, dist: dm }\r\n      }\r\n      case 'MultiLineString': {\r\n        var lstring = geom.getLineStrings()\r\n        p0 = false, dm = Number.MAX_VALUE\r\n        for (i = 0; l = lstring[i]; i++) {\r\n          p = this.getNearestCoord(pt, l)\r\n          if (p && p.dist < dm) {\r\n            p0 = p\r\n            dm = p.dist\r\n            p0.ring = i\r\n          }\r\n        }\r\n        return p0\r\n      }\r\n      case 'Polygon': {\r\n        var lring = geom.getLinearRings()\r\n        p0 = false\r\n        dm = Number.MAX_VALUE\r\n        for (i = 0; l = lring[i]; i++) {\r\n          p = this.getNearestCoord(pt, l)\r\n          if (p && p.dist < dm) {\r\n            p0 = p\r\n            dm = p.dist\r\n            p0.ring = i\r\n          }\r\n        }\r\n        return p0\r\n      }\r\n      case 'MultiPolygon': {\r\n        var poly = geom.getPolygons()\r\n        p0 = false\r\n        dm = Number.MAX_VALUE\r\n        for (i = 0; l = poly[i]; i++) {\r\n          p = this.getNearestCoord(pt, l)\r\n          if (p && p.dist < dm) {\r\n            p0 = p\r\n            dm = p.dist\r\n            p0.poly = i\r\n          }\r\n        }\r\n        return p0\r\n      }\r\n      case 'GeometryCollection': {\r\n        var g = geom.getGeometries()\r\n        p0 = false\r\n        dm = Number.MAX_VALUE\r\n        for (i = 0; l = g[i]; i++) {\r\n          p = this.getNearestCoord(pt, l)\r\n          if (p && p.dist < dm) {\r\n            p0 = p\r\n            dm = p.dist\r\n            p0.geom = i\r\n          }\r\n        }\r\n        return p0\r\n      }\r\n      default: return false\r\n    }\r\n  }\r\n  /** Get arcs concerned by a modification\r\n   * @param {ol.geom} geom the geometry concerned\r\n   * @param {ol.coordinate} coord pointed coordinates\r\n   */\r\n  getArcs(geom, coord) {\r\n    var arcs = false\r\n    var coords, i, s, l, g\r\n    switch (geom.getType()) {\r\n      case 'Point': {\r\n        if (ol_coordinate_equal(coord, geom.getCoordinates())) {\r\n          arcs = {\r\n            geom: geom,\r\n            type: geom.getType(),\r\n            coord1: [],\r\n            coord2: [],\r\n            node: true\r\n          }\r\n        }\r\n        break\r\n      }\r\n      case 'MultiPoint': {\r\n        coords = geom.getCoordinates()\r\n        for (i = 0; i < coords.length; i++) {\r\n          if (ol_coordinate_equal(coord, coords[i])) {\r\n            arcs = {\r\n              geom: geom,\r\n              type: geom.getType(),\r\n              index: i,\r\n              coord1: [],\r\n              coord2: [],\r\n              node: true\r\n            }\r\n            break\r\n          }\r\n        }\r\n        break\r\n      }\r\n      case 'LinearRing':\r\n      case 'LineString': {\r\n        var p = geom.getClosestPoint(coord)\r\n        if (ol_coordinate_dist2d(p, coord) < 1.5 * this.tolerance_) {\r\n          var split\r\n          // Split the line in two\r\n          if (geom.getType() === 'LinearRing') {\r\n            g = new ol_geom_LineString(geom.getCoordinates())\r\n            split = g.splitAt(coord, this.tolerance_)\r\n          } else {\r\n            split = geom.splitAt(coord, this.tolerance_)\r\n          }\r\n          // If more than 2\r\n          if (split.length > 2) {\r\n            coords = split[1].getCoordinates()\r\n            for (i = 2; s = split[i]; i++) {\r\n              var c = s.getCoordinates()\r\n              c.shift()\r\n              coords = coords.concat(c)\r\n            }\r\n            split = [split[0], new ol_geom_LineString(coords)]\r\n          }\r\n          // Split in two\r\n          if (split.length === 2) {\r\n            var c0 = split[0].getCoordinates()\r\n            var c1 = split[1].getCoordinates()\r\n            var nbpt = c0.length + c1.length - 1\r\n            c0.pop()\r\n            c1.shift()\r\n            arcs = {\r\n              geom: geom,\r\n              type: geom.getType(),\r\n              coord1: c0,\r\n              coord2: c1,\r\n              node: (geom.getCoordinates().length === nbpt),\r\n              closed: false\r\n            }\r\n          } else if (split.length === 1) {\r\n            s = split[0].getCoordinates()\r\n            var start = ol_coordinate_equal(s[0], coord)\r\n            var end = ol_coordinate_equal(s[s.length - 1], coord)\r\n            // Move first point\r\n            if (start) {\r\n              s.shift()\r\n              if (end)\r\n                s.pop()\r\n              arcs = {\r\n                geom: geom,\r\n                type: geom.getType(),\r\n                coord1: [],\r\n                coord2: s,\r\n                node: true,\r\n                closed: end\r\n              }\r\n            } else if (end) {\r\n              // Move last point\r\n              s.pop()\r\n              arcs = {\r\n                geom: geom,\r\n                type: geom.getType(),\r\n                coord1: s,\r\n                coord2: [],\r\n                node: true,\r\n                closed: false\r\n              }\r\n            }\r\n          }\r\n        }\r\n        break\r\n      }\r\n      case 'MultiLineString': {\r\n        var lstring = geom.getLineStrings()\r\n        for (i = 0; l = lstring[i]; i++) {\r\n          arcs = this.getArcs(l, coord)\r\n          if (arcs) {\r\n            arcs.geom = geom\r\n            arcs.type = geom.getType()\r\n            arcs.lstring = i\r\n            break\r\n          }\r\n        }\r\n        break\r\n      }\r\n      case 'Polygon': {\r\n        var lring = geom.getLinearRings()\r\n        for (i = 0; l = lring[i]; i++) {\r\n          arcs = this.getArcs(l, coord)\r\n          if (arcs) {\r\n            arcs.geom = geom\r\n            arcs.type = geom.getType()\r\n            arcs.index = i\r\n            break\r\n          }\r\n        }\r\n        break\r\n      }\r\n      case 'MultiPolygon': {\r\n        var poly = geom.getPolygons()\r\n        for (i = 0; l = poly[i]; i++) {\r\n          arcs = this.getArcs(l, coord)\r\n          if (arcs) {\r\n            arcs.geom = geom\r\n            arcs.type = geom.getType()\r\n            arcs.poly = i\r\n            break\r\n          }\r\n        }\r\n        break\r\n      }\r\n      case 'GeometryCollection': {\r\n        g = geom.getGeometries()\r\n        for (i = 0; l = g[i]; i++) {\r\n          arcs = this.getArcs(l, coord)\r\n          if (arcs) {\r\n            arcs.geom = geom\r\n            arcs.g = i\r\n            arcs.typeg = arcs.type\r\n            arcs.type = geom.getType()\r\n            break\r\n          }\r\n        }\r\n        break\r\n      }\r\n      default: {\r\n        console.error('ol/interaction/ModifyFeature ' + geom.getType() + ' not supported!')\r\n        break\r\n      }\r\n    }\r\n    return arcs\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} evt Map browser event.\r\n   * @return {boolean} `true` to start the drag sequence.\r\n   */\r\n  handleDownEvent(evt) {\r\n    if (!this.getActive())\r\n      return false\r\n\r\n    // Something to move ?\r\n    var current = this.getClosestFeature(evt)\r\n\r\n    if (current && (this._condition(evt) || this._deleteCondition(evt))) {\r\n      var features = []\r\n      this.arcs = []\r\n\r\n      // Get features concerned\r\n      this.sources_.forEach(function (s) {\r\n        var extent = ol_extent_buffer(ol_extent_boundingExtent([current.coord]), this.tolerance_)\r\n        features = features.concat(features, s.getFeaturesInExtent(extent))\r\n      }.bind(this))\r\n\r\n      // Get arcs concerned\r\n      this._modifiedFeatures = []\r\n      features.forEach(function (f) {\r\n        var a = this.getArcs(f.getGeometry(), current.coord)\r\n        if (a) {\r\n          if (this._insertVertexCondition(evt) || a.node) {\r\n            a.feature = f\r\n            this._modifiedFeatures.push(f)\r\n            this.arcs.push(a)\r\n          }\r\n        }\r\n      }.bind(this))\r\n\r\n      if (this._modifiedFeatures.length) {\r\n        if (this._deleteCondition(evt)) {\r\n          return !this._removePoint(current, evt)\r\n        } else {\r\n          this.dispatchEvent({\r\n            type: 'modifystart',\r\n            coordinate: current.coord,\r\n            originalEvent: evt.originalEvent,\r\n            features: this._modifiedFeatures\r\n          })\r\n          this.handleDragEvent({\r\n            coordinate: current.coord,\r\n            originalEvent: evt.originalEvent\r\n          })\r\n          return true\r\n        }\r\n      } else {\r\n        return true\r\n      }\r\n    } else {\r\n      return false\r\n    }\r\n  }\r\n  /** Get modified features\r\n   * @return {Array<ol.Feature>} list of modified features\r\n   */\r\n  getModifiedFeatures() {\r\n    return this._modifiedFeatures || []\r\n  }\r\n  /** Removes the vertex currently being pointed.\r\n   */\r\n  removePoint() {\r\n    this._removePoint({}, {})\r\n  }\r\n  /**\r\n   * @private\r\n   */\r\n  _getModification(a) {\r\n    var coords = a.coord1.concat(a.coord2)\r\n    switch (a.type) {\r\n      case 'LineString': {\r\n        if (a.closed)\r\n          coords.push(coords[0])\r\n        if (coords.length > 1) {\r\n          if (a.geom.getCoordinates().length != coords.length) {\r\n            a.coords = coords\r\n            return true\r\n          }\r\n        }\r\n        break\r\n      }\r\n      case 'MultiLineString': {\r\n        if (a.closed)\r\n          coords.push(coords[0])\r\n        if (coords.length > 1) {\r\n          var c = a.geom.getCoordinates()\r\n          if (c[a.lstring].length != coords.length) {\r\n            c[a.lstring] = coords\r\n            a.coords = c\r\n            return true\r\n          }\r\n        }\r\n        break\r\n      }\r\n      case 'Polygon': {\r\n        if (a.closed)\r\n          coords.push(coords[0])\r\n        if (coords.length > 3) {\r\n          c = a.geom.getCoordinates()\r\n          if (c[a.index].length != coords.length) {\r\n            c[a.index] = coords\r\n            a.coords = c\r\n            return true\r\n          }\r\n        }\r\n        break\r\n      }\r\n      case 'MultiPolygon': {\r\n        if (a.closed)\r\n          coords.push(coords[0])\r\n        if (coords.length > 3) {\r\n          c = a.geom.getCoordinates()\r\n          if (c[a.poly][a.index].length != coords.length) {\r\n            c[a.poly][a.index] = coords\r\n            a.coords = c\r\n            return true\r\n          }\r\n        }\r\n        break\r\n      }\r\n      case 'GeometryCollection': {\r\n        a.type = a.typeg\r\n        var geom = a.geom\r\n        var geoms = geom.getGeometries()\r\n        a.geom = geoms[a.g]\r\n        var found = this._getModification(a)\r\n        // Restore current arc\r\n        geom.setGeometries(geoms)\r\n        a.geom = geom\r\n        a.type = 'GeometryCollection'\r\n        return found\r\n      }\r\n      default: {\r\n        //console.error('ol/interaction/ModifyFeature '+a.type+' not supported!');\r\n        break\r\n      }\r\n    }\r\n    return false\r\n  }\r\n  /** Removes the vertex currently being pointed.\r\n   * @private\r\n   */\r\n  _removePoint(current, evt) {\r\n    if (!this.arcs)\r\n      return false\r\n\r\n    this.overlayLayer_.getSource().clear()\r\n\r\n    var found = false\r\n    // Get all modifications\r\n    this.arcs.forEach(function (a) {\r\n      found = found || this._getModification(a)\r\n    }.bind(this))\r\n\r\n    // Almost one point is removed\r\n    if (found) {\r\n      this.dispatchEvent({\r\n        type: 'modifystart',\r\n        coordinate: current.coord,\r\n        originalEvent: evt.originalEvent,\r\n        features: this._modifiedFeatures\r\n      })\r\n      this.arcs.forEach(function (a) {\r\n        if (a.geom.getType() === 'GeometryCollection') {\r\n          if (a.coords) {\r\n            var geoms = a.geom.getGeometries()\r\n            geoms[a.g].setCoordinates(a.coords)\r\n            a.geom.setGeometries(geoms)\r\n          }\r\n        } else {\r\n          if (a.coords)\r\n            a.geom.setCoordinates(a.coords)\r\n        }\r\n      }.bind(this))\r\n      this.dispatchEvent({\r\n        type: 'modifyend',\r\n        coordinate: current.coord,\r\n        originalEvent: evt.originalEvent,\r\n        features: this._modifiedFeatures\r\n      })\r\n    }\r\n\r\n    this.arcs = []\r\n    return found\r\n  }\r\n  /**\r\n   * @private\r\n   */\r\n  handleUpEvent(e) {\r\n    if (!this.getActive())\r\n      return false\r\n    if (!this.arcs || !this.arcs.length)\r\n      return true\r\n\r\n    this.overlayLayer_.getSource().clear()\r\n    this.dispatchEvent({\r\n      type: 'modifyend',\r\n      coordinate: e.coordinate,\r\n      originalEvent: e.originalEvent,\r\n      features: this._modifiedFeatures\r\n    })\r\n\r\n    this.arcs = []\r\n    return true\r\n  }\r\n  /**\r\n   * @private\r\n   */\r\n  setArcCoordinates(a, coords) {\r\n    var c\r\n    switch (a.type) {\r\n      case 'Point': {\r\n        a.geom.setCoordinates(coords[0])\r\n        break\r\n      }\r\n      case 'MultiPoint': {\r\n        c = a.geom.getCoordinates()\r\n        c[a.index] = coords[0]\r\n        a.geom.setCoordinates(c)\r\n        break\r\n      }\r\n      case 'LineString': {\r\n        a.geom.setCoordinates(coords)\r\n        break\r\n      }\r\n      case 'MultiLineString': {\r\n        c = a.geom.getCoordinates()\r\n        c[a.lstring] = coords\r\n        a.geom.setCoordinates(c)\r\n        break\r\n      }\r\n      case 'Polygon': {\r\n        c = a.geom.getCoordinates()\r\n        c[a.index] = coords\r\n        a.geom.setCoordinates(c)\r\n        break\r\n      }\r\n      case 'MultiPolygon': {\r\n        c = a.geom.getCoordinates()\r\n        c[a.poly][a.index] = coords\r\n        a.geom.setCoordinates(c)\r\n        break\r\n      }\r\n      case 'GeometryCollection': {\r\n        a.type = a.typeg\r\n        var geom = a.geom\r\n        var geoms = geom.getGeometries()\r\n        a.geom = geoms[a.g]\r\n        this.setArcCoordinates(a, coords)\r\n        geom.setGeometries(geoms)\r\n        a.geom = geom\r\n        a.type = 'GeometryCollection'\r\n        break\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * @private\r\n   */\r\n  handleDragEvent(e) {\r\n    if (!this.getActive()) return false\r\n    if (!this.arcs) return true\r\n\r\n    // Show sketch\r\n    this.overlayLayer_.getSource().clear()\r\n    var p = new ol_Feature(new ol_geom_Point(e.coordinate))\r\n    this.overlayLayer_.getSource().addFeature(p)\r\n\r\n    // Nothing to do\r\n    if (!this.arcs.length) return true\r\n\r\n    // Move arcs\r\n    this.arcs.forEach(function (a) {\r\n      var coords = a.coord1.concat([e.coordinate], a.coord2)\r\n      if (a.closed) coords.push(e.coordinate)\r\n      this.setArcCoordinates(a, coords)\r\n    }.bind(this))\r\n\r\n    this.dispatchEvent({\r\n      type: 'modifying',\r\n      coordinate: e.coordinate,\r\n      originalEvent: e.originalEvent,\r\n      features: this._modifiedFeatures\r\n    })\r\n\r\n    return true\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} evt Event.\r\n   * @private\r\n   */\r\n  handleMoveEvent(e) {\r\n    if (!this.getActive()) return true\r\n\r\n    this.overlayLayer_.getSource().clear()\r\n    var current = this.getClosestFeature(e)\r\n\r\n    // Draw sketch\r\n    if (current) {\r\n      var p = new ol_Feature(new ol_geom_Point(current.coord))\r\n      this.overlayLayer_.getSource().addFeature(p)\r\n    }\r\n\r\n    // Show cursor\r\n    var element = e.map.getTargetElement()\r\n    if (this.cursor_) {\r\n      if (current) {\r\n        if (element.style.cursor != this.cursor_) {\r\n          this.previousCursor_ = element.style.cursor\r\n          ol_ext_element.setCursor(element, this.cursor_)\r\n        }\r\n      } else if (this.previousCursor_ !== undefined) {\r\n        ol_ext_element.setCursor(element, this.previousCursor_)\r\n        this.previousCursor_ = undefined\r\n      }\r\n    }\r\n    return true\r\n  }\r\n  /** Get the current feature to modify\r\n   * @return {ol.Feature}\r\n   */\r\n  getCurrentFeature() {\r\n    return this.currentFeature\r\n  }\r\n}\r\n\r\nexport default ol_interaction_ModifyFeature","/*\tCopyright (c) 2017 Jean-Marc VIGLINO, \r\n  released under the CeCILL-B license (French BSD license)\r\n  (http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).\r\n*/\r\n\r\nimport ol_geom_Polygon from 'ol/geom/Polygon.js'\r\nimport ol_geom_MultiPolygon from 'ol/geom/MultiPolygon.js'\r\nimport ol_geom_LinearRing from 'ol/geom/LinearRing.js'\r\nimport ol_interaction_Draw from 'ol/interaction/Draw.js'\r\nimport ol_interaction_Select from 'ol/interaction/Select.js'\r\n\r\n/** Interaction to draw holes in a polygon.\r\n * It fires a drawstart, drawend event when drawing the hole\r\n * and a modifystart, modifyend event before and after inserting the hole in the feature geometry.\r\n * @constructor\r\n * @extends {ol_interaction_Interaction}\r\n * @fires drawstart\r\n * @fires drawend\r\n * @fires modifystart\r\n * @fires modifyend\r\n * @param {olx.interaction.DrawHoleOptions} options extend olx.interaction.DrawOptions\r\n * \t@param {Array<ol.layer.Vector> | function | undefined} options.layers A list of layers from which polygons should be selected. Alternatively, a filter function can be provided. default: all visible layers\r\n * \t@param {Array<ol.Feature> | ol.Collection<ol.Feature> | function | undefined} options.featureFilter An array or a collection of features the interaction applies on or a function that takes a feature and a layer and returns true if the feature is a candidate\r\n * \t@param { ol.style.Style | Array<ol.style.Style> | StyleFunction | undefined }\tStyle for the selected features, default: default edit style\r\n * \t@param {function | undefined}\toptions.geometryFunction Draw interaction geometry function to customize the hole\r\n */\r\nvar ol_interaction_DrawHole = class olinteractionDrawHole extends ol_interaction_Draw {\r\n  constructor(options) {\r\n    options = options || {}\r\n    // Geometry function that test points inside the current selection\r\n    var _geometryFn = function(coordinates, geometry) {\r\n      var coord = coordinates[0].pop()\r\n      if (!this.getPolygon() || this.getPolygon().intersectsCoordinate(coord)) {\r\n        this.lastOKCoord = [coord[0], coord[1]]\r\n      }\r\n      coordinates[0].push([this.lastOKCoord[0], this.lastOKCoord[1]])\r\n  \r\n      if (geometry) {\r\n        geometry.setCoordinates([coordinates[0].concat([coordinates[0][0]])])\r\n      } else {\r\n        geometry = new ol_geom_Polygon(coordinates)\r\n      }\r\n      return geometry\r\n    }\r\n    var geomFn = options.geometryFunction\r\n    if (geomFn) {\r\n      options.geometryFunction = function (c, g, p) {\r\n        g = _geometryFn.bind(this)(c, g)\r\n        return geomFn.bind(this)(c, g, p)\r\n      }\r\n    } else {\r\n      options.geometryFunction = _geometryFn\r\n    }\r\n\r\n    // Create draw interaction\r\n    options.type = 'Polygon';\r\n    super(options)\r\n    \r\n    // Select interaction for the current feature\r\n    this._select = new ol_interaction_Select({ style: options.style })\r\n    this._select.setActive(false)\r\n\r\n    // Layer filter function\r\n    if (options.layers) {\r\n      if (typeof (options.layers) === 'function') {\r\n        this.layers_ = options.layers\r\n      } else if (options.layers.indexOf) {\r\n        this.layers_ = function (l) {\r\n          return (options.layers.indexOf(l) >= 0)\r\n        }\r\n      }\r\n    }\r\n\r\n    // Features to apply on \r\n    if (typeof (options.featureFilter) === 'function') {\r\n      this._features = options.featureFilter\r\n    } else if (options.featureFilter) {\r\n      var features = options.featureFilter\r\n      this._features = function (f) {\r\n        if (features.indexOf) {\r\n          return !!features[features.indexOf(f)]\r\n        } else {\r\n          return !!features.item(features.getArray().indexOf(f))\r\n        }\r\n      }\r\n    } else {\r\n      this._features = function () { return true }\r\n    }\r\n\r\n    // Start drawing if inside a feature\r\n    this.on('drawstart', this._startDrawing.bind(this))\r\n    // End drawing add the hole to the current Polygon\r\n    this.on('drawend', this._finishDrawing.bind(this))\r\n  }\r\n\r\n  /**\r\n   * Remove the interaction from its current map, if any,  and attach it to a new\r\n   * map, if any. Pass `null` to just remove the interaction from the current map.\r\n   * @param {ol.Map} map Map.\r\n   * @api stable\r\n   */\r\n  setMap(map) {\r\n    // Remove previous selection\r\n    if (this.getMap()) this.getMap().removeInteraction(this._select)\r\n    // Add new one\r\n    if (map) map.addInteraction(this._select)\r\n    super.setMap.call(this, map)\r\n  }\r\n  /**\r\n   * Activate/deactivate the interaction\r\n   * @param {boolean}\r\n   * @api stable\r\n   */\r\n  setActive(b) {\r\n    if (this._select) this._select.getFeatures().clear()\r\n    super.setActive.call(this, b)\r\n  }\r\n  /**\r\n   * Remove last point of the feature currently being drawn\r\n   * (test if points to remove before).\r\n   */\r\n  removeLastPoint() {\r\n    if (this._feature && this._feature.getGeometry().getCoordinates()[0].length > 2) {\r\n      super.removeLastPoint.call(this)\r\n    }\r\n  }\r\n  /**\r\n   * Get the current polygon to hole\r\n   * @return {ol.Feature}\r\n   */\r\n  getPolygon() {\r\n    return this._polygon\r\n    // return this._select.getFeatures().item(0).getGeometry();\r\n  }\r\n  /**\r\n   * Get current feature to add a hole and start drawing\r\n   * @param {ol_interaction_Draw.Event} e\r\n   * @private\r\n   */\r\n  _startDrawing(e) {\r\n    var map = this.getMap()\r\n    this._feature = e.feature\r\n    var coord = e.feature.getGeometry().getCoordinates()[0][0]\r\n    this._current = null\r\n    // Check object under the pointer\r\n    map.forEachFeatureAtPixel(\r\n      map.getPixelFromCoordinate(coord),\r\n      function (feature, layer) {\r\n        // Not yet found?\r\n        if (!this._current && this._features(feature, layer)) {\r\n          var poly = feature.getGeometry()\r\n          if (poly.getType() === \"Polygon\"\r\n            && poly.intersectsCoordinate(coord)) {\r\n            this._polygonIndex = false\r\n            this._polygon = poly\r\n            this._current = feature\r\n          } else if (poly.getType() === \"MultiPolygon\"\r\n            && poly.intersectsCoordinate(coord)) {\r\n            for (var i = 0, p; p = poly.getPolygon(i); i++) {\r\n              if (p.intersectsCoordinate(coord)) {\r\n                this._polygonIndex = i\r\n                this._polygon = p\r\n                this._current = feature\r\n                break\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }.bind(this), {\r\n      layerFilter: this.layers_\r\n    }\r\n    )\r\n    this._select.getFeatures().clear()\r\n    if (!this._current) {\r\n      this.setActive(false)\r\n      this.setActive(true)\r\n    } else {\r\n      this._select.getFeatures().push(this._current)\r\n    }\r\n  }\r\n  /**\r\n   * Stop drawing and add the sketch feature to the target feature.\r\n   * @param {ol_interaction_Draw.Event} e\r\n   * @private\r\n   */\r\n  _finishDrawing(e) {\r\n    // The feature is the hole\r\n    e.hole = e.feature\r\n    // Get the current feature\r\n    e.feature = this._select.getFeatures().item(0)\r\n    this.dispatchEvent({ type: 'modifystart', features: [this._current] })\r\n    // Create the hole\r\n    var c = e.hole.getGeometry().getCoordinates()[0]\r\n    if (c.length > 3) {\r\n      if (this._polygonIndex !== false) {\r\n        var geom = e.feature.getGeometry()\r\n        var newGeom = new ol_geom_MultiPolygon([])\r\n        for (var i = 0, pi; pi = geom.getPolygon(i); i++) {\r\n          if (i === this._polygonIndex) {\r\n            pi.appendLinearRing(new ol_geom_LinearRing(c))\r\n            newGeom.appendPolygon(pi)\r\n          } else {\r\n            newGeom.appendPolygon(pi)\r\n          }\r\n        }\r\n        e.feature.setGeometry(newGeom)\r\n      } else {\r\n        this.getPolygon().appendLinearRing(new ol_geom_LinearRing(c))\r\n      }\r\n    }\r\n    this.dispatchEvent({ type: 'modifyend', features: [this._current] })\r\n    // reset\r\n    this._feature = null\r\n    this._select.getFeatures().clear()\r\n  }\r\n  /**\r\n   * Function that is called when a geometry's coordinates are updated.\r\n   * @param {Array<ol.coordinate>} coordinates\r\n   * @param {ol_geom_Polygon} geometry\r\n   * @return {ol_geom_Polygon}\r\n   * @private\r\n   */\r\n  _geometryFn(coordinates, geometry) {\r\n    var coord = coordinates[0].pop()\r\n    if (!this.getPolygon() || this.getPolygon().intersectsCoordinate(coord)) {\r\n      this.lastOKCoord = [coord[0], coord[1]]\r\n    }\r\n    coordinates[0].push([this.lastOKCoord[0], this.lastOKCoord[1]])\r\n\r\n    if (geometry) {\r\n      geometry.setCoordinates([coordinates[0].concat([coordinates[0][0]])])\r\n    } else {\r\n      geometry = new ol_geom_Polygon(coordinates)\r\n    }\r\n    return geometry\r\n  }\r\n}\r\n\r\nexport default ol_interaction_DrawHole\r\n","/*\tCopyright (c) 2016 Jean-Marc VIGLINO, \r\n  released under the CeCILL-B license (French BSD license)\r\n  (http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).\r\n\r\n  Usefull function to handle geometric operations\r\n*/\r\n\r\nimport ol_geom_LineString from 'ol/geom/LineString.js'\r\nimport ol_geom_LinearRing from 'ol/geom/LinearRing.js'\r\nimport ol_geom_MultiLineString from 'ol/geom/MultiLineString.js'\r\nimport ol_geom_MultiPoint from 'ol/geom/MultiPoint.js'\r\nimport ol_geom_MultiPolygon from 'ol/geom/MultiPolygon.js'\r\nimport ol_geom_Point from 'ol/geom/Point.js'\r\nimport ol_geom_Polygon from 'ol/geom/Polygon.js'\r\nimport ol_geom_Circle from 'ol/geom/Circle.js'\r\nimport {getCenter as ol_extent_getCenter} from 'ol/extent.js'\r\nimport {buffer as ol_extent_buffer} from 'ol/extent.js'\r\n\r\n/** Distance beetween 2 points\r\n *\tUsefull geometric functions\r\n * @param {ol.Coordinate} p1 first point\r\n * @param {ol.Coordinate} p2 second point\r\n * @return {number} distance\r\n */\r\nvar ol_coordinate_dist2d = function(p1, p2) {\r\n  var dx = p1[0]-p2[0];\r\n  var dy = p1[1]-p2[1];\r\n  return Math.sqrt(dx*dx+dy*dy);\r\n}\r\n\r\n/** 2 points are equal\r\n *\tUsefull geometric functions\r\n * @param {ol.Coordinate} p1 first point\r\n * @param {ol.Coordinate} p2 second point\r\n * @return {boolean}\r\n */\r\nvar ol_coordinate_equal = function(p1, p2) {\r\n  return (p1[0]==p2[0] && p1[1]==p2[1]);\r\n}\r\n\r\n/** Get center coordinate of a feature\r\n * @param {ol.Feature} f\r\n * @return {ol.coordinate} the center\r\n */\r\nvar ol_coordinate_getFeatureCenter = function(f) {\r\n  return ol_coordinate_getGeomCenter (f.getGeometry());\r\n};\r\n\r\n/** Get center coordinate of a geometry\r\n* @param {ol.geom.Geometry} geom\r\n* @return {ol.Coordinate} the center\r\n*/\r\nvar ol_coordinate_getGeomCenter = function(geom) {\r\n  switch (geom.getType()) {\r\n    case 'Point': \r\n      return geom.getCoordinates();\r\n    case \"MultiPolygon\":\r\n      geom = geom.getPolygon(0);\r\n      // fallthrough\r\n    case \"Polygon\":\r\n      return geom.getInteriorPoint().getCoordinates();\r\n    default:\r\n      return geom.getClosestPoint(ol_extent_getCenter(geom.getExtent()));\r\n  }\r\n};\r\n\r\n/** Offset a polyline\r\n * @param {Array<ol.Coordinate>} coords\r\n * @param {number} offset\r\n * @return {Array<ol.Coordinate>} resulting coord\r\n * @see http://stackoverflow.com/a/11970006/796832\r\n * @see https://drive.google.com/viewerng/viewer?a=v&pid=sites&srcid=ZGVmYXVsdGRvbWFpbnxqa2dhZGdldHN0b3JlfGd4OjQ4MzI5M2Y0MjNmNzI2MjY\r\n */\r\nvar ol_coordinate_offsetCoords = function (coords, offset) {\r\n  var path = [];\r\n  var N = coords.length-1;\r\n  var max = N;\r\n  var mi, mi1, li, li1, ri, ri1, si, si1, Xi1, Yi1;\r\n  var p0, p1, p2;\r\n  var isClosed = ol_coordinate_equal(coords[0],coords[N]);\r\n  if (!isClosed) {\r\n    p0 = coords[0];\r\n    p1 = coords[1];\r\n    p2 = [\r\n      p0[0] + (p1[1] - p0[1]) / ol_coordinate_dist2d(p0,p1) *offset,\r\n      p0[1] - (p1[0] - p0[0]) / ol_coordinate_dist2d(p0,p1) *offset\r\n    ];\r\n    path.push(p2);\r\n    coords.push(coords[N])\r\n    N++;\r\n    max--;\r\n  }\r\n  for (var i = 0; i < max; i++) {\r\n    p0 = coords[i];\r\n    p1 = coords[(i+1) % N];\r\n    p2 = coords[(i+2) % N];\r\n\r\n    mi = (p1[1] - p0[1])/(p1[0] - p0[0]);\r\n    mi1 = (p2[1] - p1[1])/(p2[0] - p1[0]);\r\n    // Prevent alignements\r\n    if (Math.abs(mi-mi1) > 1e-10) {\r\n      li = Math.sqrt((p1[0] - p0[0])*(p1[0] - p0[0])+(p1[1] - p0[1])*(p1[1] - p0[1]));\r\n      li1 = Math.sqrt((p2[0] - p1[0])*(p2[0] - p1[0])+(p2[1] - p1[1])*(p2[1] - p1[1]));\r\n      ri = p0[0] + offset*(p1[1] - p0[1])/li;\r\n      ri1 = p1[0] + offset*(p2[1] - p1[1])/li1;\r\n      si = p0[1] - offset*(p1[0] - p0[0])/li;\r\n      si1 = p1[1] - offset*(p2[0] - p1[0])/li1;\r\n      Xi1 = (mi1*ri1-mi*ri+si-si1) / (mi1-mi);\r\n      Yi1 = (mi*mi1*(ri1-ri)+mi1*si-mi*si1) / (mi1-mi);\r\n\r\n      // Correction for vertical lines\r\n      if(p1[0] - p0[0] == 0) {\r\n        Xi1 = p1[0] + offset*(p1[1] - p0[1])/Math.abs(p1[1] - p0[1]);\r\n        Yi1 = mi1*Xi1 - mi1*ri1 + si1;\r\n      }\r\n      if (p2[0] - p1[0] == 0 ) {\r\n        Xi1 = p2[0] + offset*(p2[1] - p1[1])/Math.abs(p2[1] - p1[1]);\r\n        Yi1 = mi*Xi1 - mi*ri + si;\r\n      }\r\n\r\n      path.push([Xi1, Yi1]);\r\n    }\r\n  }\r\n  if (isClosed) {\r\n    path.push(path[0]);\r\n  } else {\r\n    coords.pop();\r\n    p0 = coords[coords.length-1];\r\n    p1 = coords[coords.length-2];\r\n    p2 = [\r\n      p0[0] - (p1[1] - p0[1]) / ol_coordinate_dist2d(p0,p1) *offset,\r\n      p0[1] + (p1[0] - p0[0]) / ol_coordinate_dist2d(p0,p1) *offset\r\n    ];\r\n    path.push(p2);\r\n  }\r\n  return path;\r\n}\r\n\r\n/** Find the segment a point belongs to\r\n * @param {ol.Coordinate} pt\r\n * @param {Array<ol.Coordinate>} coords\r\n * @return {} the index (-1 if not found) and the segment\r\n */\r\nvar ol_coordinate_findSegment = function (pt, coords) {\r\n  for (var i=0; i<coords.length-1; i++) {\r\n    var p0 = coords[i];\r\n    var p1 = coords[i+1];\r\n    if (ol_coordinate_equal(pt, p0) || ol_coordinate_equal(pt, p1)) {\r\n      return { index:1, segment: [p0,p1] };\r\n    } else {\r\n      var d0 = ol_coordinate_dist2d(p0,p1);\r\n      var v0 = [ (p1[0] - p0[0]) / d0, (p1[1] - p0[1]) / d0 ];\r\n      var d1 = ol_coordinate_dist2d(p0,pt);\r\n      var v1 = [ (pt[0] - p0[0]) / d1, (pt[1] - p0[1]) / d1 ];\r\n      if (Math.abs(v0[0]*v1[1] - v0[1]*v1[0]) < 1e-10) {\r\n        return { index:1, segment: [p0,p1] };\r\n      }\r\n    }\r\n  }\r\n  return { index: -1 };\r\n};\r\n\r\n/**\r\n * Split a Polygon geom with horizontal lines\r\n * @param {Array<ol.Coordinate>} geom\r\n * @param {number} y the y to split\r\n * @param {number} n contour index\r\n * @return {Array<Array<ol.Coordinate>>}\r\n */\r\nvar ol_coordinate_splitH = function (geom, y, n) {\r\n  var x, abs;\r\n  var list = [];\r\n  for (var i=0; i<geom.length-1; i++) {\r\n    // Hole separator?\r\n    if (!geom[i].length || !geom[i+1].length) continue;\r\n    // Intersect\r\n    if (geom[i][1]<=y && geom[i+1][1]>y || geom[i][1]>=y && geom[i+1][1]<y) {\r\n      abs = (y-geom[i][1]) / (geom[i+1][1]-geom[i][1]);\r\n      x = abs * (geom[i+1][0]-geom[i][0]) + geom[i][0];\r\n      list.push ({ contour: n, index: i, pt: [x,y], abs: abs });\r\n    }\r\n  }\r\n  // Sort x\r\n  list.sort(function(a,b) { return a.pt[0] - b.pt[0] });\r\n  // Horizontal segment\r\n  var result = [];\r\n  for (var j=0; j<list.length-1; j += 2) {\r\n    result.push([list[j], list[j+1]])\r\n  }\r\n  return result;\r\n};\r\n\r\n/** Create a geometry given a type and coordinates */\r\nvar ol_geom_createFromType = function (type, coordinates) {\r\n  switch (type) {\r\n    case 'LineString': return new ol_geom_LineString(coordinates);\r\n    case 'LinearRing': return new ol_geom_LinearRing(coordinates);\r\n    case 'MultiLineString': return new ol_geom_MultiLineString(coordinates);\r\n    case 'MultiPoint': return new ol_geom_MultiPoint(coordinates);\r\n    case 'MultiPolygon': return new ol_geom_MultiPolygon(coordinates);\r\n    case 'Point': return new ol_geom_Point(coordinates);\r\n    case 'Polygon': return new ol_geom_Polygon(coordinates);\r\n    default:\r\n      console.error('[createFromType] Unsupported type: '+type);\r\n      return null;\r\n  }\r\n};\r\n\r\nexport {ol_geom_createFromType}\r\nexport {ol_coordinate_dist2d, ol_coordinate_equal, ol_coordinate_findSegment, ol_coordinate_getFeatureCenter, ol_coordinate_getGeomCenter, ol_coordinate_offsetCoords, ol_coordinate_splitH}\r\n\r\n/** Intersect 2 lines\r\n * @param {Arrar<ol.coordinate>} d1\r\n * @param {Arrar<ol.coordinate>} d2\r\n */\r\nvar ol_coordinate_getIntersectionPoint = function (d1, d2) {\r\n  var d1x = d1[1][0] - d1[0][0];\r\n  var d1y = d1[1][1] - d1[0][1];\r\n  var d2x = d2[1][0] - d2[0][0];\r\n  var d2y = d2[1][1] - d2[0][1];\r\n  var det = d1x * d2y - d1y * d2x;\r\n  if (det != 0) {\r\n    var k = (d1x * d1[0][1] - d1x * d2[0][1] - d1y * d1[0][0] + d1y * d2[0][0]) / det;\r\n    return [d2[0][0] + k*d2x, d2[0][1] + k*d2y];\r\n  } else {\r\n    return false;\r\n  }\r\n};\r\n\r\nexport { ol_coordinate_getIntersectionPoint }\r\n\r\nvar ol_extent_intersection;\r\n\r\n(function() {\r\n// Split at x\r\nfunction splitX(pts, x) {\r\n  var pt;\r\n  for (let i=pts.length-1; i>0; i--) {\r\n    if ((pts[i][0]>x && pts[i-1][0]<x) || (pts[i][0]<x && pts[i-1][0]>x)) {\r\n      pt = [ x, (x - pts[i][0]) / (pts[i-1][0]-pts[i][0]) * (pts[i-1][1]-pts[i][1]) + pts[i][1]];\r\n      pts.splice(i, 0, pt);\r\n    }\r\n  }\r\n}\r\n// Split at y\r\nfunction splitY(pts, y) {\r\n  var pt;\r\n  for (let i=pts.length-1; i>0; i--) {\r\n    if ((pts[i][1]>y && pts[i-1][1]<y) || (pts[i][1]<y && pts[i-1][1]>y)) {\r\n      pt = [ (y - pts[i][1]) / (pts[i-1][1]-pts[i][1]) * (pts[i-1][0]-pts[i][0]) + pts[i][0], y];\r\n      pts.splice(i, 0, pt);\r\n    }\r\n  }\r\n}\r\n\r\n/** Fast polygon intersection with an extent (used for area calculation)\r\n * @param {ol_extent_Extent} extent\r\n * @param {ol_geom_Polygon|ol_geom_MultiPolygon} polygon\r\n * @returns {ol_geom_Polygon|ol_geom_MultiPolygon|null} return null if not a polygon geometry\r\n */\r\nol_extent_intersection = function(extent, polygon) {\r\n  var poly = (polygon.getType() === 'Polygon');\r\n  if (!poly && polygon.getType() !== 'MultiPolygon') return null;\r\n  var geom = polygon.getCoordinates();\r\n  if (poly) geom = [geom];\r\n  geom.forEach(function(g) {\r\n    g.forEach(function(c) {\r\n      splitX(c, extent[0]);\r\n      splitX(c, extent[2]);\r\n      splitY(c, extent[1]);\r\n      splitY(c, extent[3]);\r\n    });\r\n  })\r\n  // Snap geom to the extent \r\n  geom.forEach(function(g) {\r\n    g.forEach(function(c) {\r\n      c.forEach(function(p) {\r\n        if (p[0]<extent[0]) p[0] = extent[0];\r\n        else if (p[0]>extent[2]) p[0] = extent[2];\r\n        if (p[1]<extent[1]) p[1] = extent[1];\r\n        else if (p[1]>extent[3]) p[1] = extent[3];\r\n      })\r\n    })\r\n  })\r\n  if (poly) {\r\n    return new ol_geom_Polygon(geom[0]);\r\n  } else {\r\n    return new ol_geom_MultiPolygon(geom);\r\n  }\r\n};\r\n})();\r\n\r\nexport { ol_extent_intersection }\r\nexport { ol_extent_intersection as extentIntersection }\r\n\r\n/** Add points along a segment\r\n * @param {ol_Coordinate} p1 \r\n * @param {ol_Coordinate} p2 \r\n * @param {number} d \r\n * @param {boolean} start include starting point, default true\r\n * @returns {Array<ol_Coordinate>}\r\n */\r\nvar ol_coordinate_sampleAt = function(p1, p2, d, start) {\r\n  var pts = [];\r\n  if (start!==false) pts.push(p1);\r\n  var dl = ol_coordinate_dist2d(p1,p2);\r\n  if (dl) {\r\n    var nb = Math.round(dl/d);\r\n    if (nb>1) {\r\n      var dx = (p2[0]-p1[0]) / nb;\r\n      var dy = (p2[1]-p1[1]) / nb;\r\n      for (var i=1; i<nb; i++) {\r\n        pts.push([p1[0] + dx*i, p1[1] + dy*i])\r\n      }\r\n    }\r\n  }\r\n  pts.push(p2);\r\n  return pts;\r\n};\r\nexport { ol_coordinate_sampleAt }\r\n\r\n/** Sample a LineString at a distance\r\n * @param {number} d\r\n * @returns {ol_geom_LineString}\r\n */\r\nol_geom_LineString.prototype.sampleAt = function(d) {\r\n  var line = this.getCoordinates();\r\n  var result = [];\r\n  for (var i=1; i<line.length; i++) {\r\n    result = result.concat(ol_coordinate_sampleAt(line[i-1], line[i], d, i===1));\r\n  }\r\n  return new ol_geom_LineString(result);\r\n};\r\n\r\n/** Sample a MultiLineString at a distance\r\n * @param {number} d\r\n * @returns {ol_geom_MultiLineString}\r\n */\r\nol_geom_MultiLineString.prototype.sampleAt = function(d) {\r\n  var lines = this.getCoordinates();\r\n  var result = [];\r\n  lines.forEach(function(p) {\r\n    var l = [];\r\n    for (var i=1; i<p.length; i++) {\r\n      l = l.concat(ol_coordinate_sampleAt(p[i-1], p[i], d, i===1));\r\n    }\r\n    result.push(l);\r\n  })\r\n  return new ol_geom_MultiLineString(result);\r\n};\r\n\r\n/** Sample a Polygon at a distance\r\n * @param {number} d\r\n * @returns {ol_geom_Polygon}\r\n */\r\nol_geom_Polygon.prototype.sampleAt = function(res) {\r\n  var poly = this.getCoordinates();\r\n  var result = [];\r\n  poly.forEach(function(p) {\r\n    var l = [];\r\n    for (var i=1; i<p.length; i++) {\r\n      l = l.concat(ol_coordinate_sampleAt(p[i-1], p[i], res, i===1));\r\n    }\r\n    result.push(l);\r\n  })\r\n  return new ol_geom_Polygon(result);\r\n};\r\n\r\n/** Sample a MultiPolygon at a distance\r\n * @param {number} res\r\n * @returns {ol_geom_MultiPolygon}\r\n */\r\nol_geom_MultiPolygon.prototype.sampleAt = function(res) {\r\n  var mpoly = this.getCoordinates();\r\n  var result = [];\r\n  mpoly.forEach(function(poly) {\r\n    var a = [];\r\n    result.push(a);\r\n    poly.forEach(function(p) {\r\n      var l = [];\r\n      for (var i=1; i<p.length; i++) {\r\n        l = l.concat(ol_coordinate_sampleAt(p[i-1], p[i], res, i===1));\r\n      }\r\n      a.push(l);\r\n    })\r\n  });\r\n  return new ol_geom_MultiPolygon(result);\r\n};\r\n\r\n/** Intersect a geometry using a circle\r\n * @param {ol_geom_Geometry} geom\r\n * @param {number} resolution circle resolution to sample the polygon on the circle, default 1\r\n * @returns {ol_geom_Geometry}\r\n */\r\nol_geom_Circle.prototype.intersection = function(geom, resolution) {\r\n  if (geom.sampleAt) {\r\n    var ext = ol_extent_buffer(this.getCenter().concat(this.getCenter()), this.getRadius());\r\n    geom = ol_extent_intersection(ext, geom);\r\n    geom = geom.simplify(resolution);\r\n    var c = this.getCenter();\r\n    var r = this.getRadius();\r\n    //var res = (resolution||1) * r / 100;\r\n    var g = geom.sampleAt(resolution).getCoordinates();\r\n    switch (geom.getType()) {\r\n      case 'Polygon': g = [g];\r\n        // fallthrough\r\n      case 'MultiPolygon': {\r\n        var hasout = false;\r\n        // var hasin = false;\r\n        var result = [];\r\n        g.forEach(function(poly) {\r\n          var a = [];\r\n          result.push(a);\r\n          poly.forEach(function(ring) {\r\n            var l = [];\r\n            a.push(l);\r\n            ring.forEach(function(p) {\r\n              var d = ol_coordinate_dist2d(c, p);\r\n              if (d > r) {\r\n                hasout = true;\r\n                l.push([\r\n                  c[0] + r / d * (p[0]-c[0]),\r\n                  c[1] + r / d * (p[1]-c[1])\r\n                ]);\r\n              } else {\r\n                // hasin = true;\r\n                l.push(p);\r\n              }\r\n            });\r\n          })\r\n        });\r\n        if (!hasout) return geom;\r\n        if (geom.getType() === 'Polygon') {\r\n          return new ol_geom_Polygon(result[0]);\r\n        } else {\r\n          return new ol_geom_MultiPolygon(result);\r\n        }\r\n      }\r\n    }\r\n  } else {\r\n    console.warn('[ol/geom/Circle~intersection] Unsupported geometry type: '+geom.getType());\r\n  }\r\n  return geom;\r\n};\r\n","import ol_style_Style from 'ol/style/Style.js'\r\nimport ol_style_Circle from 'ol/style/Circle.js'\r\nimport ol_style_Stroke from 'ol/style/Stroke.js'\r\nimport ol_style_Fill from 'ol/style/Fill.js'\r\n\r\nvar ol_style_Style_defaultStyle;\r\n\r\n(function() {\r\n\r\n// Style\r\nvar white = [255, 255, 255, 1];\r\nvar blue = [0, 153, 255, 1];\r\nvar width = 3;\r\n\r\nvar defaultEditStyle = [\r\n  new ol_style_Style({\r\n    stroke: new ol_style_Stroke({ color: white, width: width + 2 })\r\n  }),\r\n  new ol_style_Style({\r\n    image: new ol_style_Circle({\r\n      radius: width * 2,\r\n      fill: new ol_style_Fill({ color: blue }),\r\n      stroke: new ol_style_Stroke({ color: white, width: width / 2 })\r\n    }),\r\n    stroke: new ol_style_Stroke({ color: blue, width: width }),\r\n    fill: new ol_style_Fill({\r\n      color: [255, 255, 255, 0.5]\r\n    })\r\n  })\r\n];\r\n\r\n/**\r\n * Get the default style\r\n * @param {boolean|*} [edit] true to get editing style or a { color, fillColor } object, default get default blue style\r\n * @return {Array<ol.style.Style>}\r\n */\r\nol_style_Style_defaultStyle = function(edit) {\r\n  if (edit===true) {\r\n    return defaultEditStyle;\r\n  } else {\r\n    edit = edit || {};\r\n    var fill = new ol_style_Fill({\r\n      color: edit.fillColor || 'rgba(255,255,255,0.4)'\r\n    });\r\n    var stroke = new ol_style_Stroke({\r\n      color: edit.color || '#3399CC',\r\n      width: 1.25\r\n    });\r\n    var style = new ol_style_Style({\r\n      image: new ol_style_Circle({\r\n        fill: fill,\r\n        stroke: stroke,\r\n        radius: 5\r\n      }),\r\n      fill: fill,\r\n      stroke: stroke\r\n    });\r\n    return [ style ];\r\n  }\r\n};\r\n\r\n})();\r\n\r\nexport default ol_style_Style_defaultStyle\r\n","/*\tCopyright (c) 2018 Jean-Marc VIGLINO, \r\n\treleased under the CeCILL-B license (French BSD license)\r\n\t(http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).\r\n*/\r\n\r\nimport ol_interaction_Select from 'ol/interaction/Select.js'\r\nimport ol_source_Vector from 'ol/source/Vector.js'\r\n\r\n/** A Select interaction to delete features on click.\r\n * @constructor\r\n * @extends {ol_interaction_Interaction}\r\n * @fires deletestart\r\n * @fires deleteend\r\n * @param {Object} options ol.interaction.Select options\r\n */\r\nvar ol_interaction_Delete = class olinteractionDelete extends ol_interaction_Select {\r\n  constructor(options) {\r\n    super(options);\r\n    this.on('select', function (e) {\r\n      this.getFeatures().clear();\r\n      this.delete(e.selected);\r\n    }.bind(this));\r\n  }\r\n  /** Get vector source of the map\r\n   * @return {Array<ol.source.Vector>}\r\n   */\r\n  _getSources(layers) {\r\n    if (!this.getMap())\r\n      return [];\r\n    if (!layers)\r\n      layers = this.getMap().getLayers();\r\n    var sources = [];\r\n    layers.forEach(function (l) {\r\n      // LayerGroup\r\n      if (l.getLayers) {\r\n        sources = sources.concat(this._getSources(l.getLayers()));\r\n      } else {\r\n        if (l.getSource && l.getSource() instanceof ol_source_Vector) {\r\n          sources.push(l.getSource());\r\n        }\r\n      }\r\n    }.bind(this));\r\n    return sources;\r\n  }\r\n  /** Delete features: remove the features from the map (from all layers in the map)\r\n   * @param {ol.Collection<ol.Feature>|Array<ol.Feature>} features The features to delete\r\n   * @api\r\n   */\r\n  delete(features) {\r\n    if (features && (features.length || features.getLength())) {\r\n      this.dispatchEvent({ type: 'deletestart', features: features });\r\n      var delFeatures = [];\r\n      // Get the sources concerned\r\n      this._getSources().forEach(function (source) {\r\n        try {\r\n          // Try to delete features in the source\r\n          features.forEach(function (f) {\r\n            source.removeFeature(f);\r\n            delFeatures.push(f);\r\n          });\r\n        } catch (e) { /* ok */ }\r\n      });\r\n      this.dispatchEvent({ type: 'deleteend', features: delFeatures });\r\n    }\r\n  }\r\n}\r\n\r\nexport default ol_interaction_Delete","/*\tCopyright (c) 2016 Jean-Marc VIGLINO,\r\nreleased under the CeCILL-B license (French BSD license)\r\n(http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).\r\n*/\r\n\r\nimport ol_control_Button from \"./Button.js\";\r\n\r\n/** A simple push button control drawn as text\r\n * @constructor\r\n * @extends {ol_control_Button}\r\n * @param {Object=} options Control options.\r\n *\t@param {String} options.className class of the control\r\n*\t@param {String} options.title title of the control\r\n*\t@param {String} options.html html to insert in the control\r\n*\t@param {function} options.handleClick callback when control is clicked (or use change:active event)\r\n*/\r\nvar ol_control_TextButton = class olcontrolTextButton extends ol_control_Button {\r\n  constructor(options) {\r\n    options = options || {};\r\n    options.className = (options.className || '') + ' ol-text-button';\r\n    super(options);\r\n  }\r\n}\r\n\r\nexport default ol_control_TextButton\r\n","/*\tCopyright (c) 2016 Jean-Marc VIGLINO, \r\n  released under the CeCILL-B license (French BSD license)\r\n  (http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).\r\n*/\r\n\r\nimport ol_interaction_Interaction from 'ol/interaction/Interaction.js'\r\nimport ol_style_Style_defaultStyle from '../style/defaultStyle.js'\r\nimport ol_Collection from 'ol/Collection.js'\r\nimport ol_layer_Vector from 'ol/layer/Vector.js'\r\nimport ol_source_Vector from 'ol/source/Vector.js'\r\nimport ol_geom_Circle from 'ol/geom/Circle.js'\r\nimport {fromCircle as ol_geom_Polygon_fromCircle} from 'ol/geom/Polygon.js'\r\nimport ol_geom_Point from 'ol/geom/Point.js'\r\nimport ol_geom_LineString from 'ol/geom/LineString.js'\r\nimport ol_geom_Polygon from 'ol/geom/Polygon.js'\r\nimport ol_Feature from 'ol/Feature.js'\r\n\r\n/** Interaction rotate\r\n * @constructor\r\n * @extends {ol_interaction_Interaction}\r\n * @fires drawstart, drawing, drawend, drawcancel\r\n * @param {olx.interaction.TransformOptions} options\r\n *  @param {Array<ol.Layer>} options.source Destination source for the drawn features\r\n *  @param {ol.Collection<ol.Feature>} options.features Destination collection for the drawn features \r\n *  @param {ol.style.Style | Array.<ol.style.Style> | ol.style.StyleFunction | undefined} options.style style for the sketch\r\n *  @param {integer} options.sides number of sides, default 0 = circle\r\n *  @param { ol.events.ConditionType | undefined } options.condition A function that takes an ol.MapBrowserEvent and returns a boolean that event should be handled. By default module:ol/events/condition.always.\r\n *  @param { ol.events.ConditionType | undefined } options.squareCondition A function that takes an ol.MapBrowserEvent and returns a boolean to draw square features. Default test shift key\r\n *  @param { ol.events.ConditionType | undefined } options.centerCondition A function that takes an ol.MapBrowserEvent and returns a boolean to draw centered features. Default check Ctrl key\r\n *  @param { bool } options.canRotate Allow rotation when centered + square, default: true\r\n *  @param { string } [options.geometryName=geometry] \r\n *  @param { number } options.clickTolerance click tolerance on touch devices, default: 6\r\n *  @param { number } options.maxCircleCoordinates Maximum number of point on a circle, default: 100\r\n */\r\nvar ol_interaction_DrawRegular = class olinteractionDrawRegular extends ol_interaction_Interaction {\r\n  constructor(options) {\r\n    options = options || {}\r\n    \r\n    super({\r\n      handleEvent: function(e) { return self.handleEvent_(e) }\r\n    })\r\n\r\n    var self = this;\r\n\r\n    this.squaredClickTolerance_ = options.clickTolerance ? options.clickTolerance * options.clickTolerance : 36\r\n    this.maxCircleCoordinates_ = options.maxCircleCoordinates || 100\r\n\r\n    // Collection of feature to transform \r\n    this.features_ = options.features\r\n    // List of layers to transform \r\n    this.source_ = options.source\r\n    // Square condition\r\n    this.conditionFn_ = options.condition\r\n    // Square condition\r\n    this.squareFn_ = options.squareCondition\r\n    // Centered condition\r\n    this.centeredFn_ = options.centerCondition\r\n    // Allow rotation when centered + square\r\n    this.canRotate_ = (options.canRotate !== false)\r\n    // Specify custom geometry name\r\n    this.geometryName_ = options.geometryName || 'geometry'\r\n\r\n    // Number of sides (default=0: circle)\r\n    this.setSides(options.sides)\r\n\r\n    // Style\r\n    var defaultStyle = ol_style_Style_defaultStyle(true)\r\n\r\n    // Create a new overlay layer for the sketch\r\n    this.sketch_ = new ol_Collection()\r\n    this.overlayLayer_ = new ol_layer_Vector({\r\n      source: new ol_source_Vector({\r\n        features: this.sketch_,\r\n        useSpatialIndex: false\r\n      }),\r\n      name: 'DrawRegular overlay',\r\n      displayInLayerSwitcher: false,\r\n      style: options.style || defaultStyle\r\n    })\r\n  }\r\n  /**\r\n   * Remove the interaction from its current map, if any,  and attach it to a new\r\n   * map, if any. Pass `null` to just remove the interaction from the current map.\r\n   * @param {ol.Map} map Map.\r\n   * @api stable\r\n   */\r\n  setMap(map) {\r\n    if (this.getMap()) this.getMap().removeLayer(this.overlayLayer_)\r\n    super.setMap(map)\r\n    this.overlayLayer_.setMap(map)\r\n  }\r\n  /**\r\n   * Activate/deactivate the interaction\r\n   * @param {boolean}\r\n   * @api stable\r\n   */\r\n  setActive(b) {\r\n    this.reset()\r\n    super.setActive(b)\r\n  }\r\n  /**\r\n   * Reset the interaction\r\n   * @api stable\r\n   */\r\n  reset() {\r\n    if (this.overlayLayer_) this.overlayLayer_.getSource().clear()\r\n    this.started_ = false\r\n  }\r\n  /**\r\n   * Set the number of sides.\r\n   * @param {int} number of sides.\r\n   * @api stable\r\n   */\r\n  setSides(nb) {\r\n    nb = parseInt(nb)\r\n    this.sides_ = nb > 2 ? nb : 0\r\n  }\r\n  /**\r\n   * Allow rotation when centered + square\r\n   * @param {bool}\r\n   * @api stable\r\n   */\r\n  canRotate(b) {\r\n    if (b === true || b === false)\r\n      this.canRotate_ = b\r\n    return this.canRotate_\r\n  }\r\n  /**\r\n   * Get the number of sides.\r\n   * @return {int} number of sides.\r\n   * @api stable\r\n   */\r\n  getSides() {\r\n    return this.sides_\r\n  }\r\n  /** Get geom of the current drawing\r\n  * @return {ol.geom.Polygon | ol.geom.Point}\r\n  */\r\n  getGeom_() {\r\n    this.overlayLayer_.getSource().clear()\r\n    if (!this.center_)\r\n      return false\r\n\r\n    var g\r\n    if (this.coord_) {\r\n      var center = this.center_\r\n      var coord = this.coord_\r\n\r\n      // Specific case: circle\r\n      var d, dmax, r, circle, centerPx\r\n      if (!this.sides_ && this.square_ && !this.centered_) {\r\n        center = [(coord[0] + center[0]) / 2, (coord[1] + center[1]) / 2]\r\n        d = [coord[0] - center[0], coord[1] - center[1]]\r\n        r = Math.sqrt(d[0] * d[0] + d[1] * d[1])\r\n        circle = new ol_geom_Circle(center, r, 'XY')\r\n        // Optimize points on the circle\r\n        centerPx = this.getMap().getPixelFromCoordinate(center)\r\n        dmax = Math.max(100, Math.abs(centerPx[0] - this.coordPx_[0]), Math.abs(centerPx[1] - this.coordPx_[1]))\r\n        dmax = Math.min(this.maxCircleCoordinates_, Math.round(dmax / 3))\r\n        return ol_geom_Polygon_fromCircle(circle, dmax, 0)\r\n      } else {\r\n        var hasrotation = this.canRotate_ && this.centered_ && this.square_\r\n        d = [coord[0] - center[0], coord[1] - center[1]]\r\n        if (this.square_ && !hasrotation) {\r\n          //var d = [coord[0] - center[0], coord[1] - center[1]];\r\n          var dm = Math.max(Math.abs(d[0]), Math.abs(d[1]))\r\n          coord = [\r\n            center[0] + (d[0] > 0 ? dm : -dm),\r\n            center[1] + (d[1] > 0 ? dm : -dm)\r\n          ]\r\n        }\r\n        r = Math.sqrt(d[0] * d[0] + d[1] * d[1])\r\n        if (r > 0) {\r\n          circle = new ol_geom_Circle(center, r, 'XY')\r\n          var a\r\n          if (hasrotation)\r\n            a = Math.atan2(d[1], d[0])\r\n          else\r\n            a = this.startAngle[this.sides_] || this.startAngle['default']\r\n\r\n          if (this.sides_) {\r\n            g = ol_geom_Polygon_fromCircle(circle, this.sides_, a)\r\n          } else {\r\n            // Optimize points on the circle\r\n            centerPx = this.getMap().getPixelFromCoordinate(this.center_)\r\n            dmax = Math.max(100, Math.abs(centerPx[0] - this.coordPx_[0]), Math.abs(centerPx[1] - this.coordPx_[1]))\r\n            dmax = Math.min(this.maxCircleCoordinates_, Math.round(dmax / (this.centered_ ? 3 : 5)))\r\n            g = ol_geom_Polygon_fromCircle(circle, dmax, 0)\r\n          }\r\n\r\n          if (hasrotation)\r\n            return g\r\n\r\n          // Scale polygon to fit extent\r\n          var ext = g.getExtent()\r\n          if (!this.centered_)\r\n            center = this.center_\r\n          else\r\n            center = [2 * this.center_[0] - this.coord_[0], 2 * this.center_[1] - this.coord_[1]]\r\n          var scx = (center[0] - coord[0]) / (ext[0] - ext[2])\r\n          var scy = (center[1] - coord[1]) / (ext[1] - ext[3])\r\n          if (this.square_) {\r\n            var sc = Math.min(Math.abs(scx), Math.abs(scy))\r\n            scx = Math.sign(scx) * sc\r\n            scy = Math.sign(scy) * sc\r\n          }\r\n          var t = [center[0] - ext[0] * scx, center[1] - ext[1] * scy]\r\n\r\n          g.applyTransform(function (g1, g2, dim) {\r\n            for (var i = 0; i < g1.length; i += dim) {\r\n              g2[i] = g1[i] * scx + t[0]\r\n              g2[i + 1] = g1[i + 1] * scy + t[1]\r\n            }\r\n            return g2\r\n          })\r\n          return g\r\n        }\r\n      }\r\n    }\r\n\r\n    // No geom => return a point\r\n    return new ol_geom_Point(this.center_)\r\n  }\r\n  /** Draw sketch\r\n  * @return {ol.Feature} The feature being drawn.\r\n  */\r\n  drawSketch_(evt) {\r\n    this.overlayLayer_.getSource().clear()\r\n    if (evt) {\r\n      this.square_ = this.squareFn_ ? this.squareFn_(evt) : evt.originalEvent.shiftKey\r\n      this.centered_ = this.centeredFn_ ? this.centeredFn_(evt) : evt.originalEvent.metaKey || evt.originalEvent.ctrlKey\r\n      var g = this.getGeom_()\r\n      if (g) {\r\n        var f = this.feature_\r\n\r\n        //f.setGeometry (g);\r\n        if (g.getType() === 'Polygon')\r\n          f.getGeometry().setCoordinates(g.getCoordinates())\r\n        this.overlayLayer_.getSource().addFeature(f)\r\n        if (this.coord_\r\n          && this.square_\r\n          && ((this.canRotate_ && this.centered_ && this.coord_) || (!this.sides_ && !this.centered_))) {\r\n          this.overlayLayer_.getSource().addFeature(new ol_Feature(new ol_geom_LineString([this.center_, this.coord_])))\r\n        }\r\n        return f\r\n      }\r\n    }\r\n  }\r\n  /** Draw sketch (Point)\r\n  */\r\n  drawPoint_(pt, noclear) {\r\n    if (!noclear) {\r\n      this.overlayLayer_.getSource().clear()\r\n    }\r\n    this.overlayLayer_.getSource().addFeature(new ol_Feature(new ol_geom_Point(pt)))\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} evt Map browser event.\r\n   */\r\n  handleEvent_(evt) {\r\n    var dx, dy\r\n    // Event date time\r\n    this._eventTime = new Date();\r\n    switch (evt.type) {\r\n      case \"pointerdown\": {\r\n        if (this.conditionFn_ && !this.conditionFn_(evt)) break\r\n        this.downPx_ = evt.pixel\r\n        this.start_(evt)\r\n        // Test long touch\r\n        var dt = 500\r\n        this._longTouch = false\r\n        setTimeout(function () {\r\n          this._longTouch = (new Date() - this._eventTime > .9 * dt)\r\n          if (this._longTouch)\r\n            this.handleMoveEvent_(evt)\r\n        }.bind(this), dt)\r\n        this.lastEvent = evt.type;\r\n        break\r\n      }\r\n      case \"pointerup\": {\r\n        // Started and fisrt move\r\n        if (this.started_ && this.coord_) {\r\n          dx = this.downPx_[0] - evt.pixel[0]\r\n          dy = this.downPx_[1] - evt.pixel[1]\r\n\r\n          if (dx * dx + dy * dy <= this.squaredClickTolerance_) {\r\n            // The pointer has moved\r\n            if (this.lastEvent == \"pointerdown\" || this.lastEvent == \"pointermove\" || this.lastEvent == \"keydown\") {\r\n              this.end_(evt)\r\n            }\r\n\r\n            // On touch device there is no move event : terminate = click on the same point\r\n            else {\r\n              dx = this.upPx_[0] - evt.pixel[0]\r\n              dy = this.upPx_[1] - evt.pixel[1]\r\n              if (dx * dx + dy * dy <= this.squaredClickTolerance_) {\r\n                this.end_(evt)\r\n              } else {\r\n                this.handleMoveEvent_(evt)\r\n                this.drawPoint_(evt.coordinate, true)\r\n              }\r\n            }\r\n          }\r\n        }\r\n        this.upPx_ = evt.pixel\r\n        break\r\n      }\r\n      case \"pointerdrag\": {\r\n        if (this.started_) {\r\n          var centerPx = this.getMap().getPixelFromCoordinate(this.center_)\r\n          dx = centerPx[0] - evt.pixel[0]\r\n          dy = centerPx[1] - evt.pixel[1]\r\n          if (dx * dx + dy * dy <= this.squaredClickTolerance_) {\r\n            this.reset()\r\n          }\r\n        }\r\n        return !this._longTouch\r\n        // break;\r\n      }\r\n      case \"pointermove\": {\r\n        if (this.started_) {\r\n          dx = this.downPx_[0] - evt.pixel[0]\r\n          dy = this.downPx_[1] - evt.pixel[1]\r\n          if (dx * dx + dy * dy > this.squaredClickTolerance_) {\r\n            this.handleMoveEvent_(evt)\r\n            this.lastEvent = evt.type\r\n          }\r\n        } else {\r\n          this.drawPoint_(evt.coordinate)\r\n        }\r\n        break\r\n      }\r\n      default: {\r\n        // Prevent zoom or other event on click/singleclick/dblclick\r\n        if (this.started_ && (evt.type === 'click' || evt.type === 'singleclick' || evt.type === 'dblclick')) {\r\n          //evt.stopPropagation();\r\n          return false\r\n        }\r\n        this.lastEvent = evt.type\r\n\r\n        break\r\n      }\r\n    }\r\n    return true\r\n  }\r\n  /** Stop drawing.\r\n   */\r\n  finishDrawing() {\r\n    if (this.started_ && this.coord_) {\r\n      this.end_({ pixel: this.upPx_, coordinate: this.coord_ })\r\n    }\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} evt Event.\r\n   */\r\n  handleMoveEvent_(evt) {\r\n    if (this.started_) {\r\n      this.coord_ = evt.coordinate\r\n      this.coordPx_ = evt.pixel\r\n      var f = this.drawSketch_(evt)\r\n      this.dispatchEvent({\r\n        type: 'drawing',\r\n        feature: f,\r\n        pixel: evt.pixel,\r\n        startCoordinate: this.center_,\r\n        coordinate: evt.coordinate,\r\n        square: this.square_,\r\n        centered: this.centered_\r\n      })\r\n    } else {\r\n      this.drawPoint_(evt.coordinate)\r\n    }\r\n  }\r\n  /** Start an new draw\r\n   * @param {ol.MapBrowserEvent} evt Map browser event.\r\n   * @return {boolean} `false` to stop the drag sequence.\r\n   */\r\n  start_(evt) {\r\n    if (!this.started_) {\r\n      this.started_ = true\r\n      this.center_ = evt.coordinate\r\n      this.coord_ = null\r\n      var f = this.feature_ = new ol_Feature({})\r\n      f.setGeometryName(this.geometryName_ || 'geometry')\r\n      f.setGeometry(new ol_geom_Polygon([[evt.coordinate, evt.coordinate, evt.coordinate]]))\r\n      this.drawSketch_(evt)\r\n      this.dispatchEvent({ type: 'drawstart', feature: f, pixel: evt.pixel, coordinate: evt.coordinate })\r\n    } else {\r\n      this.coord_ = evt.coordinate\r\n    }\r\n  }\r\n  /** End drawing\r\n   * @param {ol.MapBrowserEvent} evt Map browser event.\r\n   * @return {boolean} `false` to stop the drag sequence.\r\n   */\r\n  end_(evt) {\r\n    this.coord_ = evt.coordinate\r\n    this.started_ = false\r\n    if (this.coord_ && (this.center_[0] !== this.coord_[0] || this.center_[1] !== this.coord_[1])) {\r\n      var f = this.feature_\r\n\r\n      f.setGeometry(this.getGeom_())\r\n      if (this.source_)\r\n        this.source_.addFeature(f)\r\n      else if (this.features_)\r\n        this.features_.push(f)\r\n      this.dispatchEvent({ type: 'drawend', feature: f, pixel: evt.pixel, coordinate: evt.coordinate, square: this.square_, centered: this.centered_ })\r\n    } else {\r\n      this.dispatchEvent({ type: 'drawcancel', feature: null, pixel: evt.pixel, coordinate: evt.coordinate, square: this.square_, centered: this.centered_ })\r\n    }\r\n\r\n    this.center_ = this.coord_ = null\r\n    this.drawSketch_()\r\n  }\r\n}\r\n\r\n/** Default start angle array for each sides\r\n*/\r\nol_interaction_DrawRegular.prototype.startAngle = {\r\n  'default':Math.PI/2,\r\n  3: -Math.PI/2,\r\n  4: Math.PI/4\r\n};\r\n\r\nexport default ol_interaction_DrawRegular\r\n","import ol_source_Vector from 'ol/source/Vector.js'\r\n\r\n;(function () {\r\n  var clear = ol_source_Vector.prototype.clear;\r\n\r\n  /** Overwrite ol/source/Vector clear to fire clearstart / clearend event\r\n   */\r\n  ol_source_Vector.prototype.clear = function(opt_fast) {\r\n    this.dispatchEvent({ type: 'clearstart' });\r\n    clear.call(this, opt_fast)\r\n    this.dispatchEvent({ type: 'clearend' });\r\n  };\r\n})();\r\n","import ol_Collection from 'ol/Collection.js'\r\nimport ol_interaction_Interaction from 'ol/interaction/Interaction.js'\r\nimport ol_source_Vector from 'ol/source/Vector.js'\r\nimport {unByKey as ol_Observable_unByKey} from 'ol/Observable.js'\r\nimport '../source/Vector.js'\r\n\r\n/** Undo/redo interaction\r\n * @constructor\r\n * @extends {ol_interaction_Interaction}\r\n * @fires undo\r\n * @fires redo\r\n * @fires change:add\r\n * @fires change:remove\r\n * @fires change:clear\r\n * @param {Object} options\r\n *  @param {number=} options.maxLength max undo stack length (0=Infinity), default Infinity\r\n *  @param {Array<ol.Layer>} options.layers array of layers to undo/redo\r\n */\r\nvar ol_interaction_UndoRedo = class olinteractionUndoRedo extends ol_interaction_Interaction {\r\n  constructor(options) {\r\n    options = options || {}\r\n\r\n    super({\r\n      handleEvent: function () {\r\n        return true\r\n      }\r\n    })\r\n\r\n    //array of layers to undo/redo\r\n    this._layers = options.layers\r\n\r\n    this._undoStack = new ol_Collection()\r\n    this._redoStack = new ol_Collection()\r\n    // Zero level stack\r\n    this._undo = []\r\n    this._redo = []\r\n    this._undoStack.on('add', function (e) {\r\n      if (e.element.level === undefined) {\r\n        e.element.level = this._level\r\n        if (!e.element.level) {\r\n          e.element.view = {\r\n            center: this.getMap().getView().getCenter(),\r\n            zoom: this.getMap().getView().getZoom()\r\n          }\r\n          this._undo.push(e.element)\r\n        }\r\n      } else {\r\n        if (!e.element.level)\r\n          this._undo.push(this._redo.shift())\r\n      }\r\n      if (!e.element.level) {\r\n        this.dispatchEvent({\r\n          type: 'stack:add',\r\n          action: e.element\r\n        })\r\n      }\r\n      this._reduce()\r\n    }.bind(this))\r\n    this._undoStack.on('remove', function (e) {\r\n      if (!e.element.level) {\r\n        if (this._doShift) {\r\n          this._undo.shift()\r\n        } else {\r\n          if (this._undo.length)\r\n            this._redo.push(this._undo.pop())\r\n        }\r\n        if (!this._doClear) {\r\n          this.dispatchEvent({\r\n            type: 'stack:remove',\r\n            action: e.element,\r\n            shift: this._doShift\r\n          })\r\n        }\r\n      }\r\n    }.bind(this))\r\n    // Block counter\r\n    this._block = 0\r\n    this._level = 0\r\n    // Shift an undo action ?\r\n    this._doShift = false\r\n    // Start recording\r\n    this._record = true\r\n    // Custom definitions\r\n    this._defs = {}\r\n  }\r\n  /** Add a custom undo/redo\r\n   * @param {string} action the action key name\r\n   * @param {function} undoFn function called when undoing\r\n   * @param {function} redoFn function called when redoing\r\n   * @api\r\n   */\r\n  define(action, undoFn, redoFn) {\r\n    this._defs[action] = { undo: undoFn, redo: redoFn }\r\n  }\r\n  /** Get first level undo / redo length\r\n   * @param {string} [type] get redo stack length, default get undo\r\n   * @return {number}\r\n   */\r\n  length(type) {\r\n    return (type === 'redo') ? this._redo.length : this._undo.length\r\n  }\r\n  /** Set undo stack max length\r\n   * @param {number} length\r\n   */\r\n  setMaxLength(length) {\r\n    length = parseInt(length)\r\n    if (length && length < 0)\r\n      length = 0\r\n    this.set('maxLength', length)\r\n    this._reduce()\r\n  }\r\n  /** Get undo / redo size (includes all block levels)\r\n   * @param {string} [type] get redo stack length, default get undo\r\n   * @return {number}\r\n   */\r\n  size(type) {\r\n    return (type === 'redo') ? this._redoStack.getLength() : this._undoStack.getLength()\r\n  }\r\n  /** Set undo stack max size\r\n   * @param {number} size\r\n   */\r\n  setMaxSize(size) {\r\n    size = parseInt(size)\r\n    if (size && size < 0)\r\n      size = 0\r\n    this.set('maxSize', size)\r\n    this._reduce()\r\n  }\r\n  /** Reduce stack: shift undo to set size\r\n   * @private\r\n   */\r\n  _reduce() {\r\n    if (this.get('maxLength')) {\r\n      while (this.length() > this.get('maxLength')) {\r\n        this.shift()\r\n      }\r\n    }\r\n    if (this.get('maxSize')) {\r\n      while (this.length() > 1 && this.size() > this.get('maxSize')) {\r\n        this.shift()\r\n      }\r\n    }\r\n  }\r\n  /** Get first level undo / redo first level stack\r\n   * @param {string} [type] get redo stack, default get undo\r\n   * @return {Array<*>}\r\n   */\r\n  getStack(type) {\r\n    return (type === 'redo') ? this._redo : this._undo\r\n  }\r\n  /** Add a new custom undo/redo\r\n   * @param {string} action the action key name\r\n   * @param {any} prop an object that will be passed in the undo/redo functions of the action\r\n   * @param {string} name action name\r\n   * @return {boolean} true if the action is defined\r\n   */\r\n  push(action, prop, name) {\r\n    if (this._defs[action]) {\r\n      this._undoStack.push({\r\n        type: action,\r\n        name: name,\r\n        custom: true,\r\n        prop: prop\r\n      })\r\n      return true\r\n    } else {\r\n      console.warn('[UndoRedoInteraction]: \"' + action + '\" is not defined.')\r\n      return false\r\n    }\r\n  }\r\n  /** Remove undo action from the beginning of the stack.\r\n   * The action is not returned.\r\n   */\r\n  shift() {\r\n    this._doShift = true\r\n    var a = this._undoStack.removeAt(0)\r\n    this._doShift = false\r\n    // Remove all block\r\n    if (a.type === 'blockstart') {\r\n      a = this._undoStack.item(0)\r\n      while (this._undoStack.getLength() && a.level > 0) {\r\n        this._undoStack.removeAt(0)\r\n        a = this._undoStack.item(0)\r\n      }\r\n    }\r\n  }\r\n  /** Activate or deactivate the interaction, ie. records or not events on the map.\r\n   * @param {boolean} active\r\n   * @api stable\r\n   */\r\n  setActive(active) {\r\n    super.setActive(active)\r\n    this._record = active\r\n  }\r\n  /**\r\n   * Remove the interaction from its current map, if any, and attach it to a new\r\n   * map, if any. Pass `null` to just remove the interaction from the current map.\r\n   * @param {ol.Map} map Map.\r\n   * @api stable\r\n   */\r\n  setMap(map) {\r\n    if (this._mapListener) {\r\n      this._mapListener.forEach(function (l) { ol_Observable_unByKey(l) })\r\n    }\r\n    this._mapListener = []\r\n    super.setMap(map)\r\n    // Watch blocks\r\n    if (map) {\r\n      this._mapListener.push(map.on('undoblockstart', this.blockStart.bind(this)))\r\n      this._mapListener.push(map.on('undoblockend', this.blockEnd.bind(this)))\r\n    }\r\n    // Watch sources\r\n    this._watchSources()\r\n    this._watchInteractions()\r\n  }\r\n  /** Watch for changes in the map sources\r\n   * @private\r\n   */\r\n  _watchSources() {\r\n    var map = this.getMap()\r\n    // Clear listeners\r\n    if (this._sourceListener) {\r\n      this._sourceListener.forEach(function (l) { ol_Observable_unByKey(l) })\r\n    }\r\n    this._sourceListener = []\r\n\r\n    var self = this\r\n\r\n    // Ges vector layers \r\n    function getVectorLayers(layers, init) {\r\n      if (!init) {\r\n        init = []\r\n      }\r\n      layers.forEach(function (l) {\r\n        if (l.getSource && l.getSource() instanceof ol_source_Vector) {\r\n          if (!self._layers || self._layers.indexOf(l) >= 0) {\r\n            init.push(l)\r\n          }\r\n        } else if (l.getLayers) {\r\n          getVectorLayers(l.getLayers(), init)\r\n        }\r\n      })\r\n      return init\r\n    }\r\n\r\n    if (map) {\r\n      // Watch the vector sources in the map \r\n      var vectors = getVectorLayers(map.getLayers())\r\n      vectors.forEach((function (l) {\r\n        var s = l.getSource()\r\n        this._sourceListener.push(s.on(['addfeature', 'removefeature'], this._onAddRemove.bind(this)))\r\n        this._sourceListener.push(s.on('clearstart', function () {\r\n          this.blockStart('clear')\r\n        }.bind(this)))\r\n        this._sourceListener.push(s.on('clearend', this.blockEnd.bind(this)))\r\n      }).bind(this))\r\n\r\n      // Watch new inserted/removed\r\n      this._sourceListener.push(map.getLayers().on(['add', 'remove'], this._watchSources.bind(this)))\r\n    }\r\n  }\r\n  /** Watch for interactions\r\n   * @private\r\n   */\r\n  _watchInteractions() {\r\n    var map = this.getMap()\r\n    // Clear listeners\r\n    if (this._interactionListener) {\r\n      this._interactionListener.forEach(function (l) { ol_Observable_unByKey(l) })\r\n    }\r\n    this._interactionListener = []\r\n\r\n    if (map) {\r\n      // Watch the interactions in the map \r\n      map.getInteractions().forEach((function (i) {\r\n        this._interactionListener.push(i.on(\r\n          ['setattributestart', 'modifystart', 'rotatestart', 'translatestart', 'scalestart', 'deletestart', 'deleteend', 'beforesplit', 'aftersplit'],\r\n          this._onInteraction.bind(this)\r\n        ))\r\n      }).bind(this))\r\n\r\n      // Watch new inserted / unwatch removed\r\n      this._interactionListener.push(map.getInteractions().on(\r\n        ['add', 'remove'],\r\n        this._watchInteractions.bind(this)\r\n      ))\r\n    }\r\n  }\r\n  /** A feature is added / removed\r\n   */\r\n  _onAddRemove(e) {\r\n    if (this._record) {\r\n      this._redoStack.clear()\r\n      this._redo.length = 0\r\n      this._undoStack.push({\r\n        type: e.type,\r\n        source: e.target,\r\n        feature: e.feature\r\n      })\r\n    }\r\n  }\r\n  /** Perform an interaction\r\n   * @private\r\n   */\r\n  _onInteraction(e) {\r\n    var fn = this._onInteraction[e.type]\r\n    if (fn)\r\n      fn.call(this, e)\r\n  }\r\n  /** Start an undo block\r\n   * @param {string} [name] name f the action\r\n   * @api\r\n   */\r\n  blockStart(name) {\r\n    this._redoStack.clear()\r\n    this._redo.length = 0\r\n    this._undoStack.push({\r\n      type: 'blockstart',\r\n      name: name\r\n    })\r\n    this._level++\r\n  }\r\n  /** End an undo block\r\n   * @api\r\n   */\r\n  blockEnd() {\r\n    this._undoStack.push({ type: 'blockend' })\r\n    this._level--\r\n  }\r\n  /** handle undo/redo\r\n   * @private\r\n   */\r\n  _handleDo(e, undo) {\r\n    // Not active\r\n    if (!this.getActive())\r\n      return\r\n\r\n    // Stop recording while undoing\r\n    this._record = false\r\n    if (e.custom) {\r\n      if (this._defs[e.type]) {\r\n        if (undo)\r\n          this._defs[e.type].undo(e.prop)\r\n        else\r\n          this._defs[e.type].redo(e.prop)\r\n      } else {\r\n        console.warn('[UndoRedoInteraction]: \"' + e.type + '\" is not defined.')\r\n      }\r\n    } else {\r\n      switch (e.type) {\r\n        case 'addfeature': {\r\n          if (undo)\r\n            e.source.removeFeature(e.feature)\r\n          else\r\n            e.source.addFeature(e.feature)\r\n          break\r\n        }\r\n        case 'removefeature': {\r\n          if (undo)\r\n            e.source.addFeature(e.feature)\r\n          else\r\n            e.source.removeFeature(e.feature)\r\n          break\r\n        }\r\n        case 'changegeometry': {\r\n          var geom = e.feature.getGeometry()\r\n          e.feature.setGeometry(e.oldGeom)\r\n          e.oldGeom = geom\r\n          break\r\n        }\r\n        case 'changeattribute': {\r\n          var newp = e.newProperties\r\n          var oldp = e.oldProperties\r\n          for (var p in oldp) {\r\n            if (oldp === undefined)\r\n              e.feature.unset(p)\r\n            else\r\n              e.feature.set(p, oldp[p])\r\n          }\r\n          e.oldProperties = newp\r\n          e.newProperties = oldp\r\n          break\r\n        }\r\n        case 'blockstart': {\r\n          this._block += undo ? -1 : 1\r\n          break\r\n        }\r\n        case 'blockend': {\r\n          this._block += undo ? 1 : -1\r\n          break\r\n        }\r\n        default: {\r\n          console.warn('[UndoRedoInteraction]: \"' + e.type + '\" is not defined.')\r\n        }\r\n      }\r\n    }\r\n\r\n    // Handle block\r\n    if (this._block < 0)\r\n      this._block = 0\r\n    if (this._block) {\r\n      if (undo)\r\n        this.undo()\r\n      else\r\n        this.redo()\r\n    }\r\n    this._record = true\r\n\r\n    // Dispatch event\r\n    this.dispatchEvent({\r\n      type: undo ? 'undo' : 'redo',\r\n      action: e\r\n    })\r\n  }\r\n  /** Undo last operation\r\n   * @api\r\n   */\r\n  undo() {\r\n    var e = this._undoStack.item(this._undoStack.getLength() - 1)\r\n    if (!e)\r\n      return\r\n    this._redoStack.push(e)\r\n    this._undoStack.pop()\r\n    this._handleDo(e, true)\r\n  }\r\n  /** Redo last operation\r\n   * @api\r\n   */\r\n  redo() {\r\n    var e = this._redoStack.item(this._redoStack.getLength() - 1)\r\n    if (!e)\r\n      return\r\n    this._undoStack.push(e)\r\n    this._redoStack.pop()\r\n    this._handleDo(e, false)\r\n  }\r\n  /** Clear undo stack\r\n   * @api\r\n   */\r\n  clear() {\r\n    this._doClear = true\r\n    this._undo.length = this._redo.length = 0\r\n    this._undoStack.clear()\r\n    this._redoStack.clear()\r\n    this._doClear = false\r\n    this.dispatchEvent({ type: 'stack:clear' })\r\n  }\r\n  /** Check if undo is avaliable\r\n   * @return {number} the number of undo\r\n   * @api\r\n   */\r\n  hasUndo() {\r\n    return this._undoStack.getLength()\r\n  }\r\n  /** Check if redo is avaliable\r\n   * @return {number} the number of redo\r\n   * @api\r\n   */\r\n  hasRedo() {\r\n    return this._redoStack.getLength()\r\n  }\r\n}\r\n\r\n/** Set attribute\r\n * @private\r\n */\r\nol_interaction_UndoRedo.prototype._onInteraction.setattributestart = function(e) {\r\n  this.blockStart(e.target.get('name') || 'setattribute');\r\n  var newp = Object.assign({}, e.properties);\r\n  e.features.forEach(function(f) {\r\n    var oldp = {};\r\n    for (var p in newp) {\r\n      oldp[p] = f.get(p);\r\n    }\r\n    this._undoStack.push({\r\n      type: 'changeattribute', \r\n      feature: f,\r\n      newProperties: newp,\r\n      oldProperties: oldp\r\n    });\r\n  }.bind(this));\r\n  this.blockEnd();\r\n};\r\n\r\nol_interaction_UndoRedo.prototype._onInteraction.rotatestart = \r\nol_interaction_UndoRedo.prototype._onInteraction.translatestart = \r\nol_interaction_UndoRedo.prototype._onInteraction.scalestart = \r\nol_interaction_UndoRedo.prototype._onInteraction.modifystart = function (e) {\r\n  this.blockStart(e.type.replace(/start$/,''));\r\n  e.features.forEach(function(m) {\r\n    this._undoStack.push({ \r\n      type: 'changegeometry', \r\n      feature: m, \r\n      oldGeom: m.getGeometry().clone() \r\n    });\r\n  }.bind(this));\r\n  this.blockEnd();\r\n};\r\n\r\n\r\n/** @private\r\n */\r\nol_interaction_UndoRedo.prototype._onInteraction.beforesplit = function() {\r\n  // Check modify before split\r\n  var l = this._undoStack.getLength();\r\n  if (l>2 \r\n    && this._undoStack.item(l-1).type === 'blockend'\r\n    && this._undoStack.item(l-2).type === 'changegeometry') {\r\n    this._undoStack.pop();\r\n  } else {\r\n    this.blockStart('split');\r\n  }\r\n};\r\nol_interaction_UndoRedo.prototype._onInteraction.deletestart = function() {\r\n  this.blockStart('delete');\r\n}\r\n\r\n\r\n/** @private\r\n */\r\nol_interaction_UndoRedo.prototype._onInteraction.aftersplit =\r\nol_interaction_UndoRedo.prototype._onInteraction.deleteend =\r\nol_interaction_UndoRedo.prototype.blockEnd;\r\n\r\nexport default ol_interaction_UndoRedo\r\n","/*\tCopyright (c) 2016 Jean-Marc VIGLINO,\r\n  released under the CeCILL-B license (French BSD license)\r\n  (http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).\r\n*/\r\n\r\nimport ol_control_Button from './Button.js'\r\n\r\n/** A simple toggle control\r\n * The control can be created with an interaction to control its activation.\r\n *\r\n * @constructor\r\n * @extends {ol_control_Button}\r\n * @fires change:active, change:disable\r\n * @param {Object=} options Control options.\r\n *  @param {String} options.className class of the control\r\n *  @param {String} options.title title of the control\r\n *  @param {String} options.html html to insert in the control\r\n *  @param {ol.interaction} options.interaction interaction associated with the control\r\n *  @param {bool} options.active the control is created active, default false\r\n *  @param {bool} options.disable the control is created disabled, default false\r\n *  @param {ol.control.Bar} options.bar a subbar associated with the control (drawn when active if control is nested in a ol.control.Bar)\r\n *  @param {bool} options.autoActive the control will activate when shown in an ol.control.Bar, default false\r\n *  @param {function} options.onToggle callback when control is clicked (or use change:active event)\r\n */\r\nvar ol_control_Toggle = class olcontrolToggle extends ol_control_Button {\r\n  constructor(options) {\r\n    options = options || {};\r\n\r\n    if (options.toggleFn) {\r\n      options.onToggle = options.toggleFn; // compat old version\r\n    }\r\n    options.handleClick = function () {\r\n      self.toggle();\r\n      if (options.onToggle) {\r\n        options.onToggle.call(self, self.getActive());\r\n      }\r\n    };\r\n    options.className = (options.className || '') + ' ol-toggle';\r\n    super(options);\r\n\r\n    var self = this;\r\n\r\n    this.interaction_ = options.interaction;\r\n    if (this.interaction_) {\r\n      this.interaction_.setActive(options.active);\r\n      this.interaction_.on(\"change:active\", function () {\r\n        self.setActive(self.interaction_.getActive());\r\n      });\r\n    }\r\n\r\n    this.set(\"title\", options.title);\r\n\r\n    this.set(\"autoActivate\", options.autoActivate);\r\n    if (options.bar)\r\n      this.setSubBar(options.bar);\r\n\r\n    this.setActive(options.active);\r\n    this.setDisable(options.disable);\r\n  }\r\n  /**\r\n   * Set the map instance the control is associated with\r\n   * and add interaction attached to it to this map.\r\n   * @param {_ol_Map_} map The map instance.\r\n   */\r\n  setMap(map) {\r\n    if (!map && this.getMap()) {\r\n      if (this.interaction_) {\r\n        this.getMap().removeInteraction(this.interaction_);\r\n      }\r\n      if (this.subbar_)\r\n        this.getMap().removeControl(this.subbar_);\r\n    }\r\n\r\n    super.setMap(map);\r\n\r\n    if (map) {\r\n      if (this.interaction_)\r\n        map.addInteraction(this.interaction_);\r\n      if (this.subbar_)\r\n        map.addControl(this.subbar_);\r\n    }\r\n  }\r\n  /** Get the subbar associated with a control\r\n   * @return {ol_control_Bar}\r\n   */\r\n  getSubBar() {\r\n    return this.subbar_;\r\n  }\r\n  /** Set the subbar associated with a control\r\n   * @param {ol_control_Bar} [bar] a subbar if none remove the current subbar\r\n   */\r\n  setSubBar(bar) {\r\n    var map = this.getMap();\r\n    if (map && this.subbar_)\r\n      map.removeControl(this.subbar_);\r\n    this.subbar_ = bar;\r\n    if (bar) {\r\n      this.subbar_.setTarget(this.element);\r\n      this.subbar_.element.classList.add(\"ol-option-bar\");\r\n      if (map)\r\n        map.addControl(this.subbar_);\r\n    }\r\n  }\r\n  /**\r\n   * Test if the control is disabled.\r\n   * @return {bool}\r\n   * @api stable\r\n   */\r\n  getDisable() {\r\n    var button = this.element.querySelector('button');\r\n    return button && button.disabled;\r\n  }\r\n  /** Disable the control. If disable, the control will be deactivated too.\r\n  * @param {bool} b disable (or enable) the control, default false (enable)\r\n  */\r\n  setDisable(b) {\r\n    if (this.getDisable() == b) return;\r\n    this.element.querySelector('button').disabled = b;\r\n    if (b && this.getActive()) this.setActive(false);\r\n\r\n    this.dispatchEvent({ type: 'change:disable', key: 'disable', oldValue: !b, disable: b });\r\n  }\r\n  /**\r\n   * Test if the control is active.\r\n   * @return {bool}.\r\n   * @api stable\r\n   */\r\n  getActive() {\r\n    return this.element.classList.contains(\"ol-active\");\r\n  }\r\n  /** Toggle control state active/deactive\r\n   */\r\n  toggle() {\r\n    if (this.getActive())\r\n      this.setActive(false);\r\n    else\r\n      this.setActive(true);\r\n  }\r\n  /** Change control state\r\n   * @param {bool} b activate or deactivate the control, default false\r\n   */\r\n  setActive(b) {\r\n    if (this.interaction_)\r\n      this.interaction_.setActive(b);\r\n    if (this.subbar_)\r\n      this.subbar_.setActive(b);\r\n    if (this.getActive() === b)\r\n      return;\r\n    if (b)\r\n      this.element.classList.add(\"ol-active\");\r\n    else\r\n      this.element.classList.remove(\"ol-active\");\r\n\r\n    this.dispatchEvent({ type: 'change:active', key: 'active', oldValue: !b, active: b });\r\n  }\r\n  /** Set the control interaction\r\n  * @param {_ol_interaction_} i interaction to associate with the control\r\n  */\r\n  setInteraction(i) {\r\n    this.interaction_ = i;\r\n  }\r\n  /** Get the control interaction\r\n  * @return {_ol_interaction_} interaction associated with the control\r\n  */\r\n  getInteraction() {\r\n    return this.interaction_;\r\n  }\r\n}\r\n\r\nexport default ol_control_Toggle\r\n","/*\tCopyright (c) 2016 Jean-Marc VIGLINO, \r\n  released under the CeCILL-B license (French BSD license)\r\n  (http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).\r\n*/\r\n\r\nimport ol_interaction_Interaction from 'ol/interaction/Interaction.js'\r\nimport ol_style_Style from 'ol/style/Style.js'\r\nimport ol_style_Stroke from 'ol/style/Stroke.js'\r\nimport ol_source_Vector from 'ol/source/Vector.js'\r\nimport ol_style_Fill from 'ol/style/Fill.js'\r\nimport ol_style_Circle from 'ol/style/Circle.js'\r\nimport ol_layer_Vector from 'ol/layer/Vector.js'\r\nimport ol_geom_Point from 'ol/geom/Point.js'\r\nimport ol_Feature from 'ol/Feature.js'\r\nimport ol_geom_LineString from 'ol/geom/LineString.js'\r\nimport {ol_coordinate_dist2d} from \"../geom/GeomUtils.js\";\r\nimport '../geom/LineStringSplitAt.js'\r\nimport ol_ext_element from '../util/element.js'\r\n\r\n/** Interaction split interaction for splitting feature geometry\r\n * @constructor\r\n * @extends {ol_interaction_Interaction}\r\n * @fires  beforesplit, aftersplit, pointermove\r\n * @param {*} \r\n *  @param {ol.source.Vector|Array<ol.source.Vector>} [options.sources] a list of source to split (configured with useSpatialIndex set to true), if none use map visible layers.\r\n *  @param {ol.Collection.<ol.Feature>} options.features collection of feature to split (instead of a list of sources)\r\n *  @param {integer} options.snapDistance distance (in px) to snap to an object, default 25px\r\n *\t@param {string|undefined} options.cursor cursor name to display when hovering an objet\r\n *  @param {function|undefined} options.filter a filter that takes a feature and return true if it can be clipped, default always split.\r\n *  @param ol_style_Style | Array<ol_style_Style> | false | undefined} options.featureStyle Style for the selected features, choose false if you don't want feature selection. By default the default edit style is used.\r\n *  @param {ol_style_Style | Array<ol_style_Style> | undefined} options.sketchStyle Style for the sektch features. \r\n *  @param {function|undefined} options.tolerance Distance between the calculated intersection and a vertex on the source geometry below which the existing vertex will be used for the split.  Default is 1e-10.\r\n */\r\nvar ol_interaction_Split = class olinteractionSplit extends ol_interaction_Interaction {\r\n  constructor(options) {\r\n    if (!options)\r\n      options = {}\r\n\r\n    super({\r\n      handleEvent: function (e) {\r\n        switch (e.type) {\r\n          case \"singleclick\":\r\n            return this.handleDownEvent(e)\r\n          case \"pointermove\":\r\n            return this.handleMoveEvent(e)\r\n          default:\r\n            return true\r\n        }\r\n        //return true;\r\n      }\r\n    })\r\n\r\n    // Snap distance (in px)\r\n    this.snapDistance_ = options.snapDistance || 25\r\n    // Split tolerance between the calculated intersection and the geometry\r\n    this.tolerance_ = options.tolerance || 1e-10\r\n    // Cursor\r\n    this.cursor_ = options.cursor\r\n\r\n    // List of source to split\r\n    this.setSources(options.sources)\r\n\r\n    if (options.features) {\r\n      if (!this.sources_) this.sources_ = [];\r\n      this.sources_.push(new ol_source_Vector({ features: options.features }))\r\n    }\r\n\r\n    // Get all features candidate\r\n    this.filterSplit_ = options.filter || function () { return true }\r\n\r\n    // Default style\r\n    var white = [255, 255, 255, 1]\r\n    var blue = [0, 153, 255, 1]\r\n    var width = 3\r\n    var fill = new ol_style_Fill({ color: 'rgba(255,255,255,0.4)' })\r\n    var stroke = new ol_style_Stroke({\r\n      color: '#3399CC',\r\n      width: 1.25\r\n    })\r\n    var sketchStyle = [\r\n      new ol_style_Style({\r\n        image: new ol_style_Circle({\r\n          fill: fill,\r\n          stroke: stroke,\r\n          radius: 5\r\n        }),\r\n        fill: fill,\r\n        stroke: stroke\r\n      })\r\n    ]\r\n    var featureStyle = [\r\n      new ol_style_Style({\r\n        stroke: new ol_style_Stroke({\r\n          color: white,\r\n          width: width + 2\r\n        })\r\n      }),\r\n      new ol_style_Style({\r\n        image: new ol_style_Circle({\r\n          radius: 2 * width,\r\n          fill: new ol_style_Fill({\r\n            color: blue\r\n          }),\r\n          stroke: new ol_style_Stroke({\r\n            color: white,\r\n            width: width / 2\r\n          })\r\n        }),\r\n        stroke: new ol_style_Stroke({\r\n          color: blue,\r\n          width: width\r\n        })\r\n      }),\r\n    ]\r\n\r\n    // Custom style\r\n    if (options.sketchStyle)\r\n      sketchStyle = options.sketchStyle instanceof Array ? options.sketchStyle : [options.sketchStyle]\r\n    if (options.featureStyle)\r\n      featureStyle = options.featureStyle instanceof Array ? options.featureStyle : [options.featureStyle]\r\n\r\n    // Create a new overlay for the sketch\r\n    this.overlayLayer_ = new ol_layer_Vector({\r\n      source: new ol_source_Vector({\r\n        useSpatialIndex: false\r\n      }),\r\n      name: 'Split overlay',\r\n      displayInLayerSwitcher: false,\r\n      style: function (f) {\r\n        if (f._sketch_)\r\n          return sketchStyle\r\n        else\r\n          return featureStyle\r\n      }\r\n    })\r\n\r\n  }\r\n  /**\r\n   * Remove the interaction from its current map, if any,  and attach it to a new\r\n   * map, if any. Pass `null` to just remove the interaction from the current map.\r\n   * @param {ol.Map} map Map.\r\n   * @api stable\r\n   */\r\n  setMap(map) {\r\n    if (this.getMap()) {\r\n      this.getMap().removeLayer(this.overlayLayer_)\r\n    }\r\n    super.setMap(map)\r\n    this.overlayLayer_.setMap(map)\r\n  }\r\n  /** Get sources to split features in\r\n   * @return {Array<ol.source.Vector>}\r\n   */\r\n  getSources() {\r\n    if (!this.sources_ && this.getMap()) {\r\n      var sources = []\r\n      var getSources = function (layers) {\r\n        layers.forEach(function (layer) {\r\n          if (layer.getVisible()) {\r\n            if (layer.getSource && layer.getSource() instanceof ol_source_Vector) {\r\n              sources.unshift(layer.getSource())\r\n            } else if (layer.getLayers) {\r\n              getSources(layer.getLayers())\r\n            }\r\n          }\r\n        })\r\n      }\r\n      getSources(this.getMap().getLayers())\r\n      return sources\r\n    }\r\n    return this.sources_ || []\r\n  }\r\n  /** Set sources to split features in\r\n   * @param {ol.source.Vector|Array<ol.source.Vector>|boolean} [sources] if not defined get all map vector sources\r\n   */\r\n  setSources(sources) {\r\n    this.sources_ = sources ? (sources instanceof Array ? sources || false : [sources]) : false\r\n  }\r\n  /** Get closest feature at pixel\r\n   * @param {ol.Pixel}\r\n   * @return {ol.feature}\r\n   * @private\r\n   */\r\n  getClosestFeature(e) {\r\n    var source, f, c, g, d = this.snapDistance_ + 1\r\n    // Look for closest point in the sources\r\n    this.getSources().forEach(function (si) {\r\n      var fi = si.getClosestFeatureToCoordinate(e.coordinate)\r\n      if (fi && fi.getGeometry().splitAt) {\r\n        var ci = fi.getGeometry().getClosestPoint(e.coordinate)\r\n        var gi = new ol_geom_LineString([e.coordinate, ci])\r\n        var di = gi.getLength() / e.frameState.viewState.resolution\r\n        if (di < d) {\r\n          source = si\r\n          d = di\r\n          f = fi\r\n          g = gi\r\n          c = ci\r\n        }\r\n      }\r\n    })\r\n    // Snap ?\r\n    if (d > this.snapDistance_) {\r\n      return false\r\n    } else {\r\n      // Snap to node\r\n      var coord = this.getNearestCoord(c, f.getGeometry().getCoordinates())\r\n      var p = this.getMap().getPixelFromCoordinate(coord)\r\n      if (ol_coordinate_dist2d(e.pixel, p) < this.snapDistance_) {\r\n        c = coord\r\n      }\r\n      //\r\n      return { source: source, feature: f, coord: c, link: g }\r\n    }\r\n  }\r\n  /** Get nearest coordinate in a list\r\n  * @param {ol.coordinate} pt the point to find nearest\r\n  * @param {Array<ol.coordinate>} coords list of coordinates\r\n  * @return {ol.coordinate} the nearest coordinate in the list\r\n  */\r\n  getNearestCoord(pt, coords) {\r\n    var d, dm = Number.MAX_VALUE, p0\r\n    for (var i = 0; i < coords.length; i++) {\r\n      d = ol_coordinate_dist2d(pt, coords[i])\r\n      if (d < dm) {\r\n        dm = d\r\n        p0 = coords[i]\r\n      }\r\n    }\r\n    return p0\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} evt Map browser event.\r\n   * @return {boolean} `true` to start the drag sequence.\r\n   */\r\n  handleDownEvent(evt) {\r\n    // Something to split ?\r\n    var current = this.getClosestFeature(evt)\r\n\r\n    if (current) {\r\n      var self = this\r\n      self.overlayLayer_.getSource().clear()\r\n      var split = current.feature.getGeometry().splitAt(current.coord, this.tolerance_)\r\n      var i\r\n      if (split.length > 1) {\r\n        var tosplit = []\r\n        for (i = 0; i < split.length; i++) {\r\n          var f = current.feature.clone()\r\n          f.setGeometry(split[i])\r\n          tosplit.push(f)\r\n        }\r\n        self.dispatchEvent({ type: 'beforesplit', original: current.feature, features: tosplit })\r\n        current.source.dispatchEvent({ type: 'beforesplit', original: current.feature, features: tosplit })\r\n        current.source.removeFeature(current.feature)\r\n        for (i = 0; i < tosplit.length; i++) {\r\n          current.source.addFeature(tosplit[i])\r\n        }\r\n        self.dispatchEvent({ type: 'aftersplit', original: current.feature, features: tosplit })\r\n        current.source.dispatchEvent({ type: 'aftersplit', original: current.feature, features: tosplit })\r\n      }\r\n    }\r\n    return false\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} evt Event.\r\n   */\r\n  handleMoveEvent(e) {\r\n    var map = e.map\r\n    this.overlayLayer_.getSource().clear()\r\n    var current = this.getClosestFeature(e)\r\n\r\n    if (current && this.filterSplit_(current.feature)) {\r\n      var p, l\r\n      // Draw sketch\r\n      this.overlayLayer_.getSource().addFeature(current.feature)\r\n      p = new ol_Feature(new ol_geom_Point(current.coord))\r\n      p._sketch_ = true\r\n      this.overlayLayer_.getSource().addFeature(p)\r\n      //\r\n      l = new ol_Feature(current.link)\r\n      l._sketch_ = true\r\n      this.overlayLayer_.getSource().addFeature(l)\r\n      // move event\r\n      this.dispatchEvent({\r\n        type: 'pointermove',\r\n        coordinate: e.coordinate,\r\n        frameState: e.frameState,\r\n        originalEvent: e.originalEvent,\r\n        map: e.map,\r\n        pixel: e.pixel,\r\n        feature: current.feature,\r\n        linkGeometry: current.link\r\n      })\r\n    } else {\r\n      this.dispatchEvent(e)\r\n    }\r\n\r\n    var element = map.getTargetElement()\r\n    if (this.cursor_) {\r\n      if (current) {\r\n        if (element.style.cursor != this.cursor_) {\r\n          this.previousCursor_ = element.style.cursor\r\n          ol_ext_element.setCursor(element, this.cursor_)\r\n        }\r\n      } else if (this.previousCursor_ !== undefined) {\r\n        ol_ext_element.setCursor(element, this.previousCursor_)\r\n        this.previousCursor_ = undefined\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport default ol_interaction_Split\r\n","/**\n * @module ol/interaction/Draw\n */\nimport Circle from '../geom/Circle.js';\nimport Event from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport Feature from '../Feature.js';\nimport GeometryCollection from '../geom/GeometryCollection.js';\nimport InteractionProperty from './Property.js';\nimport LineString from '../geom/LineString.js';\nimport MapBrowserEvent from '../MapBrowserEvent.js';\nimport MapBrowserEventType from '../MapBrowserEventType.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport PointerInteraction from './Pointer.js';\nimport Polygon, {fromCircle, makeRegular} from '../geom/Polygon.js';\nimport VectorLayer from '../layer/Vector.js';\nimport VectorSource from '../source/Vector.js';\nimport {FALSE, TRUE} from '../functions.js';\nimport {\n  always,\n  never,\n  noModifierKeys,\n  shiftKeyOnly,\n} from '../events/condition.js';\nimport {\n  boundingExtent,\n  getBottomLeft,\n  getBottomRight,\n  getTopLeft,\n  getTopRight,\n} from '../extent.js';\nimport {clamp, squaredDistance, toFixed} from '../math.js';\nimport {createEditingStyle} from '../style/Style.js';\nimport {\n  distance,\n  squaredDistance as squaredCoordinateDistance,\n} from '../coordinate.js';\nimport {fromUserCoordinate, getUserProjection} from '../proj.js';\nimport {getStrideForLayout} from '../geom/SimpleGeometry.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../geom/Geometry.js\").Type} type Geometry type of\n * the geometries being drawn with this instance.\n * @property {number} [clickTolerance=6] The maximum distance in pixels between\n * \"down\" and \"up\" for a \"up\" event to be considered a \"click\" event and\n * actually add a point/vertex to the geometry being drawn.  The default of `6`\n * was chosen for the draw interaction to behave correctly on mouse as well as\n * on touch devices.\n * @property {import(\"../Collection.js\").default<Feature>} [features]\n * Destination collection for the drawn features.\n * @property {VectorSource} [source] Destination source for\n * the drawn features.\n * @property {number} [dragVertexDelay=500] Delay in milliseconds after pointerdown\n * before the current vertex can be dragged to its exact position.\n * @property {number} [snapTolerance=12] Pixel distance for snapping to the\n * drawing finish. Must be greater than `0`.\n * @property {boolean} [stopClick=false] Stop click, singleclick, and\n * doubleclick events from firing during drawing.\n * @property {number} [maxPoints] The number of points that can be drawn before\n * a polygon ring or line string is finished. By default there is no\n * restriction.\n * @property {number} [minPoints] The number of points that must be drawn\n * before a polygon ring or line string can be finished. Default is `3` for\n * polygon rings and `2` for line strings.\n * @property {import(\"../events/condition.js\").Condition} [finishCondition] A function\n * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether the drawing can be finished. Not used when drawing\n * POINT or MULTI_POINT geometries.\n * @property {import(\"../style/Style.js\").StyleLike|import(\"../style/flat.js\").FlatStyleLike} [style]\n * Style for sketch features. The draw interaction can have up to three sketch features, depending on the mode.\n * It will always contain a feature with a `Point` geometry that corresponds to the current cursor position.\n * If the mode is `LineString` or `Polygon`, and there is at least one drawn point, it will also contain a feature with\n * a `LineString` geometry that corresponds to the line between the already drawn points and the current cursor position.\n * If the mode is `Polygon`, and there is at least one drawn point, it will also contain a feature with a `Polygon`\n * geometry that corresponds to the polygon between the already drawn points and the current cursor position\n * (note that this polygon has only two points if only one point is drawn).\n * If the mode is `Circle`, and there is one point drawn, it will also contain a feature with a `Circle` geometry whose\n * center is the drawn point and the radius is determined by the distance between the drawn point and the cursor.\n * @property {GeometryFunction} [geometryFunction]\n * Function that is called when a geometry's coordinates are updated.\n * @property {string} [geometryName] Geometry name to use for features created\n * by the draw interaction.\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * By default {@link module:ol/events/condition.noModifierKeys}, i.e. a click,\n * adds a vertex or deactivates freehand drawing.\n * @property {boolean} [freehand=false] Operate in freehand mode for lines,\n * polygons, and circles.  This makes the interaction always operate in freehand\n * mode and takes precedence over any `freehandCondition` option.\n * @property {import(\"../events/condition.js\").Condition} [freehandCondition]\n * Condition that activates freehand drawing for lines and polygons. This\n * function takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and\n * returns a boolean to indicate whether that event should be handled. The\n * default is {@link module:ol/events/condition.shiftKeyOnly}, meaning that the\n * Shift key activates freehand drawing.\n * @property {boolean|import(\"../events/condition.js\").Condition} [trace=false] Trace a portion of another geometry.\n * Ignored when in freehand mode.\n * @property {VectorSource} [traceSource] Source for features to trace.  If tracing is active and a `traceSource` is\n * not provided, the interaction's `source` will be used.  Tracing requires that the interaction is configured with\n * either a `traceSource` or a `source`.\n * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch\n * overlay.\n * @property {import(\"../geom/Geometry.js\").GeometryLayout} [geometryLayout='XY'] Layout of the\n * feature geometries created by the draw interaction.\n */\n\n/**\n * Coordinate type when drawing points.\n * @typedef {import(\"../coordinate.js\").Coordinate} PointCoordType\n */\n\n/**\n * Coordinate type when drawing lines.\n * @typedef {Array<import(\"../coordinate.js\").Coordinate>} LineCoordType\n */\n\n/**\n * Coordinate type when drawing polygons.\n * @typedef {Array<Array<import(\"../coordinate.js\").Coordinate>>} PolyCoordType\n */\n\n/**\n * Types used for drawing coordinates.\n * @typedef {PointCoordType|LineCoordType|PolyCoordType} SketchCoordType\n */\n\n/**\n * @typedef {Object} TraceState\n * @property {boolean} active Tracing active.\n * @property {import(\"../pixel.js\").Pixel} [startPx] The initially clicked pixel location.\n * @property {Array<TraceTarget>} [targets] Targets available for tracing.\n * @property {number} [targetIndex] The index of the currently traced target.  A value of -1 indicates\n * that no trace target is active.\n */\n\n/**\n * @typedef {Object} TraceTarget\n * @property {Array<import(\"../coordinate.js\").Coordinate>} coordinates Target coordinates.\n * @property {boolean} ring The target coordinates are a linear ring.\n * @property {number} startIndex The index of first traced coordinate.  A fractional index represents an\n * edge intersection.  Index values for rings will wrap (may be negative or larger than coordinates length).\n * @property {number} endIndex The index of last traced coordinate.  Details from startIndex also apply here.\n */\n\n/**\n * Function that takes an array of coordinates and an optional existing geometry\n * and a projection as arguments, and returns a geometry. The optional existing\n * geometry is the geometry that is returned when the function is called without\n * a second argument.\n * @typedef {function(!SketchCoordType, import(\"../geom/SimpleGeometry.js\").default,\n *     import(\"../proj/Projection.js\").default):\n *     import(\"../geom/SimpleGeometry.js\").default} GeometryFunction\n */\n\n/**\n * @typedef {'Point' | 'LineString' | 'Polygon' | 'Circle'} Mode\n * Draw mode.  This collapses multi-part geometry types with their single-part\n * cousins.\n */\n\n/**\n * @enum {string}\n */\nconst DrawEventType = {\n  /**\n   * Triggered upon feature draw start\n   * @event DrawEvent#drawstart\n   * @api\n   */\n  DRAWSTART: 'drawstart',\n  /**\n   * Triggered upon feature draw end\n   * @event DrawEvent#drawend\n   * @api\n   */\n  DRAWEND: 'drawend',\n  /**\n   * Triggered upon feature draw abortion\n   * @event DrawEvent#drawabort\n   * @api\n   */\n  DRAWABORT: 'drawabort',\n};\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/Draw~Draw} instances are\n * instances of this type.\n */\nexport class DrawEvent extends Event {\n  /**\n   * @param {DrawEventType} type Type.\n   * @param {Feature} feature The feature drawn.\n   */\n  constructor(type, feature) {\n    super(type);\n\n    /**\n     * The feature being drawn.\n     * @type {Feature}\n     * @api\n     */\n    this.feature = feature;\n  }\n}\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} coordinate The coordinate.\n * @param {Array<Feature>} features The candidate features.\n * @return {Array<TraceTarget>} The trace targets.\n */\nfunction getTraceTargets(coordinate, features) {\n  /**\n   * @type {Array<TraceTarget>}\n   */\n  const targets = [];\n\n  for (let i = 0; i < features.length; ++i) {\n    const feature = features[i];\n    const geometry = feature.getGeometry();\n    appendGeometryTraceTargets(coordinate, geometry, targets);\n  }\n\n  return targets;\n}\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} a One coordinate.\n * @param {import(\"../coordinate.js\").Coordinate} b Another coordinate.\n * @return {number} The squared distance between the two coordinates.\n */\nfunction getSquaredDistance(a, b) {\n  return squaredDistance(a[0], a[1], b[0], b[1]);\n}\n\n/**\n * @param {LineCoordType} coordinates The ring coordinates.\n * @param {number} index The index.  May be wrapped.\n * @return {import(\"../coordinate.js\").Coordinate} The coordinate.\n */\nfunction getCoordinate(coordinates, index) {\n  const count = coordinates.length;\n  if (index < 0) {\n    return coordinates[index + count];\n  }\n  if (index >= count) {\n    return coordinates[index - count];\n  }\n  return coordinates[index];\n}\n\n/**\n * Get the cumulative squared distance along a ring path.  The end index index may be \"wrapped\" and it may\n * be less than the start index to indicate the direction of travel.  The start and end index may have\n * a fractional part to indicate a point between two coordinates.\n * @param {LineCoordType} coordinates Ring coordinates.\n * @param {number} startIndex The start index.\n * @param {number} endIndex The end index.\n * @return {number} The cumulative squared distance along the ring path.\n */\nfunction getCumulativeSquaredDistance(coordinates, startIndex, endIndex) {\n  let lowIndex, highIndex;\n  if (startIndex < endIndex) {\n    lowIndex = startIndex;\n    highIndex = endIndex;\n  } else {\n    lowIndex = endIndex;\n    highIndex = startIndex;\n  }\n  const lowWholeIndex = Math.ceil(lowIndex);\n  const highWholeIndex = Math.floor(highIndex);\n\n  if (lowWholeIndex > highWholeIndex) {\n    // both start and end are on the same segment\n    const start = interpolateCoordinate(coordinates, lowIndex);\n    const end = interpolateCoordinate(coordinates, highIndex);\n    return getSquaredDistance(start, end);\n  }\n\n  let sd = 0;\n\n  if (lowIndex < lowWholeIndex) {\n    const start = interpolateCoordinate(coordinates, lowIndex);\n    const end = getCoordinate(coordinates, lowWholeIndex);\n    sd += getSquaredDistance(start, end);\n  }\n\n  if (highWholeIndex < highIndex) {\n    const start = getCoordinate(coordinates, highWholeIndex);\n    const end = interpolateCoordinate(coordinates, highIndex);\n    sd += getSquaredDistance(start, end);\n  }\n\n  for (let i = lowWholeIndex; i < highWholeIndex - 1; ++i) {\n    const start = getCoordinate(coordinates, i);\n    const end = getCoordinate(coordinates, i + 1);\n    sd += getSquaredDistance(start, end);\n  }\n\n  return sd;\n}\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} coordinate The coordinate.\n * @param {import(\"../geom/Geometry.js\").default} geometry The candidate geometry.\n * @param {Array<TraceTarget>} targets The trace targets.\n */\nfunction appendGeometryTraceTargets(coordinate, geometry, targets) {\n  if (geometry instanceof LineString) {\n    appendTraceTarget(coordinate, geometry.getCoordinates(), false, targets);\n    return;\n  }\n  if (geometry instanceof MultiLineString) {\n    const coordinates = geometry.getCoordinates();\n    for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n      appendTraceTarget(coordinate, coordinates[i], false, targets);\n    }\n    return;\n  }\n  if (geometry instanceof Polygon) {\n    const coordinates = geometry.getCoordinates();\n    for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n      appendTraceTarget(coordinate, coordinates[i], true, targets);\n    }\n    return;\n  }\n  if (geometry instanceof MultiPolygon) {\n    const polys = geometry.getCoordinates();\n    for (let i = 0, ii = polys.length; i < ii; ++i) {\n      const coordinates = polys[i];\n      for (let j = 0, jj = coordinates.length; j < jj; ++j) {\n        appendTraceTarget(coordinate, coordinates[j], true, targets);\n      }\n    }\n    return;\n  }\n  if (geometry instanceof GeometryCollection) {\n    const geometries = geometry.getGeometries();\n    for (let i = 0; i < geometries.length; ++i) {\n      appendGeometryTraceTargets(coordinate, geometries[i], targets);\n    }\n    return;\n  }\n  // other types cannot be traced\n}\n\n/**\n * @typedef {Object} TraceTargetUpdateInfo\n * @property {number} index The new target index.\n * @property {number} endIndex The new segment end index.\n */\n\n/**\n * @type {TraceTargetUpdateInfo}\n */\nconst sharedUpdateInfo = {index: -1, endIndex: NaN};\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} coordinate The coordinate.\n * @param {TraceState} traceState The trace state.\n * @param {import(\"../Map.js\").default} map The map.\n * @param {number} snapTolerance The snap tolerance.\n * @return {TraceTargetUpdateInfo} Information about the new trace target.  The returned\n * object is reused between calls and must not be modified by the caller.\n */\nfunction getTraceTargetUpdate(coordinate, traceState, map, snapTolerance) {\n  const x = coordinate[0];\n  const y = coordinate[1];\n\n  let closestTargetDistance = Infinity;\n\n  let newTargetIndex = -1;\n  let newEndIndex = NaN;\n\n  for (\n    let targetIndex = 0;\n    targetIndex < traceState.targets.length;\n    ++targetIndex\n  ) {\n    const target = traceState.targets[targetIndex];\n    const coordinates = target.coordinates;\n\n    let minSegmentDistance = Infinity;\n    let endIndex;\n    for (\n      let coordinateIndex = 0;\n      coordinateIndex < coordinates.length - 1;\n      ++coordinateIndex\n    ) {\n      const start = coordinates[coordinateIndex];\n      const end = coordinates[coordinateIndex + 1];\n      const rel = getPointSegmentRelationship(x, y, start, end);\n      if (rel.squaredDistance < minSegmentDistance) {\n        minSegmentDistance = rel.squaredDistance;\n        endIndex = coordinateIndex + rel.along;\n      }\n    }\n\n    if (minSegmentDistance < closestTargetDistance) {\n      closestTargetDistance = minSegmentDistance;\n      if (target.ring && traceState.targetIndex === targetIndex) {\n        // same target, maintain the same trace direction\n        if (target.endIndex > target.startIndex) {\n          // forward trace\n          if (endIndex < target.startIndex) {\n            endIndex += coordinates.length;\n          }\n        } else if (target.endIndex < target.startIndex) {\n          // reverse trace\n          if (endIndex > target.startIndex) {\n            endIndex -= coordinates.length;\n          }\n        }\n      }\n      newEndIndex = endIndex;\n      newTargetIndex = targetIndex;\n    }\n  }\n\n  const newTarget = traceState.targets[newTargetIndex];\n  let considerBothDirections = newTarget.ring;\n  if (traceState.targetIndex === newTargetIndex && considerBothDirections) {\n    // only consider switching trace direction if close to the start\n    const newCoordinate = interpolateCoordinate(\n      newTarget.coordinates,\n      newEndIndex,\n    );\n    const pixel = map.getPixelFromCoordinate(newCoordinate);\n    if (distance(pixel, traceState.startPx) > snapTolerance) {\n      considerBothDirections = false;\n    }\n  }\n\n  if (considerBothDirections) {\n    const coordinates = newTarget.coordinates;\n    const count = coordinates.length;\n    const startIndex = newTarget.startIndex;\n    const endIndex = newEndIndex;\n    if (startIndex < endIndex) {\n      const forwardDistance = getCumulativeSquaredDistance(\n        coordinates,\n        startIndex,\n        endIndex,\n      );\n      const reverseDistance = getCumulativeSquaredDistance(\n        coordinates,\n        startIndex,\n        endIndex - count,\n      );\n      if (reverseDistance < forwardDistance) {\n        newEndIndex -= count;\n      }\n    } else {\n      const reverseDistance = getCumulativeSquaredDistance(\n        coordinates,\n        startIndex,\n        endIndex,\n      );\n      const forwardDistance = getCumulativeSquaredDistance(\n        coordinates,\n        startIndex,\n        endIndex + count,\n      );\n      if (forwardDistance < reverseDistance) {\n        newEndIndex += count;\n      }\n    }\n  }\n\n  sharedUpdateInfo.index = newTargetIndex;\n  sharedUpdateInfo.endIndex = newEndIndex;\n  return sharedUpdateInfo;\n}\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} coordinate The clicked coordinate.\n * @param {Array<import(\"../coordinate.js\").Coordinate>} coordinates The geometry component coordinates.\n * @param {boolean} ring The coordinates represent a linear ring.\n * @param {Array<TraceTarget>} targets The trace targets.\n */\nfunction appendTraceTarget(coordinate, coordinates, ring, targets) {\n  const x = coordinate[0];\n  const y = coordinate[1];\n  for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n    const start = coordinates[i];\n    const end = coordinates[i + 1];\n    const rel = getPointSegmentRelationship(x, y, start, end);\n    if (rel.squaredDistance === 0) {\n      const index = i + rel.along;\n      targets.push({\n        coordinates: coordinates,\n        ring: ring,\n        startIndex: index,\n        endIndex: index,\n      });\n      return;\n    }\n  }\n}\n\n/**\n * @typedef {Object} PointSegmentRelationship\n * @property {number} along The closest point expressed as a fraction along the segment length.\n * @property {number} squaredDistance The squared distance of the point to the segment.\n */\n\n/**\n * @type {PointSegmentRelationship}\n */\nconst sharedRel = {along: 0, squaredDistance: 0};\n\n/**\n * @param {number} x The point x.\n * @param {number} y The point y.\n * @param {import(\"../coordinate.js\").Coordinate} start The segment start.\n * @param {import(\"../coordinate.js\").Coordinate} end The segment end.\n * @return {PointSegmentRelationship} The point segment relationship.  The returned object is\n * shared between calls and must not be modified by the caller.\n */\nfunction getPointSegmentRelationship(x, y, start, end) {\n  const x1 = start[0];\n  const y1 = start[1];\n  const x2 = end[0];\n  const y2 = end[1];\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  let along = 0;\n  let px = x1;\n  let py = y1;\n  if (dx !== 0 || dy !== 0) {\n    along = clamp(((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy), 0, 1);\n    px += dx * along;\n    py += dy * along;\n  }\n\n  sharedRel.along = along;\n  sharedRel.squaredDistance = toFixed(squaredDistance(x, y, px, py), 10);\n  return sharedRel;\n}\n\n/**\n * @param {LineCoordType} coordinates The coordinates.\n * @param {number} index The index.  May be fractional and may wrap.\n * @return {import(\"../coordinate.js\").Coordinate} The interpolated coordinate.\n */\nfunction interpolateCoordinate(coordinates, index) {\n  const count = coordinates.length;\n\n  let startIndex = Math.floor(index);\n  const along = index - startIndex;\n  if (startIndex >= count) {\n    startIndex -= count;\n  } else if (startIndex < 0) {\n    startIndex += count;\n  }\n\n  let endIndex = startIndex + 1;\n  if (endIndex >= count) {\n    endIndex -= count;\n  }\n\n  const start = coordinates[startIndex];\n  const x0 = start[0];\n  const y0 = start[1];\n  const end = coordinates[endIndex];\n  const dx = end[0] - x0;\n  const dy = end[1] - y0;\n\n  return [x0 + dx * along, y0 + dy * along];\n}\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'drawabort'|'drawend'|'drawstart', DrawEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'drawabort'|'drawend'|'drawstart', Return>} DrawOnSignature\n */\n\n/**\n * @classdesc\n * Interaction for drawing feature geometries.\n *\n * @fires DrawEvent\n * @api\n */\nclass Draw extends PointerInteraction {\n  /**\n   * @param {Options} options Options.\n   */\n  constructor(options) {\n    const pointerOptions = /** @type {import(\"./Pointer.js\").Options} */ (\n      options\n    );\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n\n    super(pointerOptions);\n\n    /***\n     * @type {DrawOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {DrawOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {DrawOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.shouldHandle_ = false;\n\n    /**\n     * @type {import(\"../pixel.js\").Pixel}\n     * @private\n     */\n    this.downPx_ = null;\n\n    /**\n     * @type {ReturnType<typeof setTimeout>}\n     * @private\n     */\n    this.downTimeout_;\n\n    /**\n     * @type {number|undefined}\n     * @private\n     */\n    this.lastDragTime_;\n\n    /**\n     * Pointer type of the last pointermove event\n     * @type {string}\n     * @private\n     */\n    this.pointerType_;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.freehand_ = false;\n\n    /**\n     * Target source for drawn features.\n     * @type {VectorSource|null}\n     * @private\n     */\n    this.source_ = options.source ? options.source : null;\n\n    /**\n     * Target collection for drawn features.\n     * @type {import(\"../Collection.js\").default<Feature>|null}\n     * @private\n     */\n    this.features_ = options.features ? options.features : null;\n\n    /**\n     * Pixel distance for snapping.\n     * @type {number}\n     * @private\n     */\n    this.snapTolerance_ = options.snapTolerance ? options.snapTolerance : 12;\n\n    /**\n     * Geometry type.\n     * @type {import(\"../geom/Geometry.js\").Type}\n     * @private\n     */\n    this.type_ = /** @type {import(\"../geom/Geometry.js\").Type} */ (\n      options.type\n    );\n\n    /**\n     * Drawing mode (derived from geometry type.\n     * @type {Mode}\n     * @private\n     */\n    this.mode_ = getMode(this.type_);\n\n    /**\n     * Stop click, singleclick, and doubleclick events from firing during drawing.\n     * Default is `false`.\n     * @type {boolean}\n     * @private\n     */\n    this.stopClick_ = !!options.stopClick;\n\n    /**\n     * The number of points that must be drawn before a polygon ring or line\n     * string can be finished.  The default is 3 for polygon rings and 2 for\n     * line strings.\n     * @type {number}\n     * @private\n     */\n    this.minPoints_ = options.minPoints\n      ? options.minPoints\n      : this.mode_ === 'Polygon'\n        ? 3\n        : 2;\n\n    /**\n     * The number of points that can be drawn before a polygon ring or line string\n     * is finished. The default is no restriction.\n     * @type {number}\n     * @private\n     */\n    this.maxPoints_ =\n      this.mode_ === 'Circle'\n        ? 2\n        : options.maxPoints\n          ? options.maxPoints\n          : Infinity;\n\n    /**\n     * A function to decide if a potential finish coordinate is permissible\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.finishCondition_ = options.finishCondition\n      ? options.finishCondition\n      : TRUE;\n\n    /**\n     * @private\n     * @type {import(\"../geom/Geometry.js\").GeometryLayout}\n     */\n    this.geometryLayout_ = options.geometryLayout\n      ? options.geometryLayout\n      : 'XY';\n\n    let geometryFunction = options.geometryFunction;\n    if (!geometryFunction) {\n      const mode = this.mode_;\n      if (mode === 'Circle') {\n        /**\n         * @param {!LineCoordType} coordinates The coordinates.\n         * @param {import(\"../geom/SimpleGeometry.js\").default|undefined} geometry Optional geometry.\n         * @param {import(\"../proj/Projection.js\").default} projection The view projection.\n         * @return {import(\"../geom/SimpleGeometry.js\").default} A geometry.\n         */\n        geometryFunction = function (coordinates, geometry, projection) {\n          const circle = geometry\n            ? /** @type {Circle} */ (geometry)\n            : new Circle([NaN, NaN]);\n          const center = fromUserCoordinate(coordinates[0], projection);\n          const squaredLength = squaredCoordinateDistance(\n            center,\n            fromUserCoordinate(coordinates[coordinates.length - 1], projection),\n          );\n          circle.setCenterAndRadius(\n            center,\n            Math.sqrt(squaredLength),\n            this.geometryLayout_,\n          );\n          const userProjection = getUserProjection();\n          if (userProjection) {\n            circle.transform(projection, userProjection);\n          }\n          return circle;\n        };\n      } else {\n        let Constructor;\n        if (mode === 'Point') {\n          Constructor = Point;\n        } else if (mode === 'LineString') {\n          Constructor = LineString;\n        } else if (mode === 'Polygon') {\n          Constructor = Polygon;\n        }\n        /**\n         * @param {!LineCoordType} coordinates The coordinates.\n         * @param {import(\"../geom/SimpleGeometry.js\").default|undefined} geometry Optional geometry.\n         * @param {import(\"../proj/Projection.js\").default} projection The view projection.\n         * @return {import(\"../geom/SimpleGeometry.js\").default} A geometry.\n         */\n        geometryFunction = function (coordinates, geometry, projection) {\n          if (geometry) {\n            if (mode === 'Polygon') {\n              if (coordinates[0].length) {\n                // Add a closing coordinate to match the first\n                geometry.setCoordinates(\n                  [coordinates[0].concat([coordinates[0][0]])],\n                  this.geometryLayout_,\n                );\n              } else {\n                geometry.setCoordinates([], this.geometryLayout_);\n              }\n            } else {\n              geometry.setCoordinates(coordinates, this.geometryLayout_);\n            }\n          } else {\n            geometry = new Constructor(coordinates, this.geometryLayout_);\n          }\n          return geometry;\n        };\n      }\n    }\n\n    /**\n     * @type {GeometryFunction}\n     * @private\n     */\n    this.geometryFunction_ = geometryFunction;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.dragVertexDelay_ =\n      options.dragVertexDelay !== undefined ? options.dragVertexDelay : 500;\n\n    /**\n     * Finish coordinate for the feature (first point for polygons, last point for\n     * linestrings).\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    this.finishCoordinate_ = null;\n\n    /**\n     * Sketch feature.\n     * @type {Feature<import('../geom/SimpleGeometry.js').default>}\n     * @private\n     */\n    this.sketchFeature_ = null;\n\n    /**\n     * Sketch point.\n     * @type {Feature<Point>}\n     * @private\n     */\n    this.sketchPoint_ = null;\n\n    /**\n     * Sketch coordinates. Used when drawing a line or polygon.\n     * @type {SketchCoordType}\n     * @private\n     */\n    this.sketchCoords_ = null;\n\n    /**\n     * Sketch line. Used when drawing polygon.\n     * @type {Feature<LineString>}\n     * @private\n     */\n    this.sketchLine_ = null;\n\n    /**\n     * Sketch line coordinates. Used when drawing a polygon or circle.\n     * @type {LineCoordType}\n     * @private\n     */\n    this.sketchLineCoords_ = null;\n\n    /**\n     * Squared tolerance for handling up events.  If the squared distance\n     * between a down and up event is greater than this tolerance, up events\n     * will not be handled.\n     * @type {number}\n     * @private\n     */\n    this.squaredClickTolerance_ = options.clickTolerance\n      ? options.clickTolerance * options.clickTolerance\n      : 36;\n\n    /**\n     * Draw overlay where our sketch features are drawn.\n     * @type {VectorLayer}\n     * @private\n     */\n    this.overlay_ = new VectorLayer({\n      source: new VectorSource({\n        useSpatialIndex: false,\n        wrapX: options.wrapX ? options.wrapX : false,\n      }),\n      style: options.style ? options.style : getDefaultStyleFunction(),\n      updateWhileInteracting: true,\n    });\n\n    /**\n     * Name of the geometry attribute for newly created features.\n     * @type {string|undefined}\n     * @private\n     */\n    this.geometryName_ = options.geometryName;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.condition_ = options.condition ? options.condition : noModifierKeys;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.freehandCondition_;\n    if (options.freehand) {\n      this.freehandCondition_ = always;\n    } else {\n      this.freehandCondition_ = options.freehandCondition\n        ? options.freehandCondition\n        : shiftKeyOnly;\n    }\n\n    /**\n     * @type {import(\"../events/condition.js\").Condition}\n     * @private\n     */\n    this.traceCondition_;\n    this.setTrace(options.trace || false);\n\n    /**\n     * @type {TraceState}\n     * @private\n     */\n    this.traceState_ = {active: false};\n\n    /**\n     * @type {VectorSource|null}\n     * @private\n     */\n    this.traceSource_ = options.traceSource || options.source || null;\n\n    this.addChangeListener(InteractionProperty.ACTIVE, this.updateState_);\n  }\n\n  /**\n   * Toggle tracing mode or set a tracing condition.\n   *\n   * @param {boolean|import(\"../events/condition.js\").Condition} trace A boolean to toggle tracing mode or an event\n   *     condition that will be checked when a feature is clicked to determine if tracing should be active.\n   */\n  setTrace(trace) {\n    let condition;\n    if (!trace) {\n      condition = never;\n    } else if (trace === true) {\n      condition = always;\n    } else {\n      condition = trace;\n    }\n    this.traceCondition_ = condition;\n  }\n\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../Map.js\").default} map Map.\n   */\n  setMap(map) {\n    super.setMap(map);\n    this.updateState_();\n  }\n\n  /**\n   * Get the overlay layer that this interaction renders sketch features to.\n   * @return {VectorLayer} Overlay layer.\n   * @api\n   */\n  getOverlay() {\n    return this.overlay_;\n  }\n\n  /**\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may actually draw or finish the drawing.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   * @api\n   */\n  handleEvent(event) {\n    if (event.originalEvent.type === EventType.CONTEXTMENU) {\n      // Avoid context menu for long taps when drawing on mobile\n      event.originalEvent.preventDefault();\n    }\n    this.freehand_ = this.mode_ !== 'Point' && this.freehandCondition_(event);\n    let move = event.type === MapBrowserEventType.POINTERMOVE;\n    let pass = true;\n    if (\n      !this.freehand_ &&\n      this.lastDragTime_ &&\n      event.type === MapBrowserEventType.POINTERDRAG\n    ) {\n      const now = Date.now();\n      if (now - this.lastDragTime_ >= this.dragVertexDelay_) {\n        this.downPx_ = event.pixel;\n        this.shouldHandle_ = !this.freehand_;\n        move = true;\n      } else {\n        this.lastDragTime_ = undefined;\n      }\n      if (this.shouldHandle_ && this.downTimeout_ !== undefined) {\n        clearTimeout(this.downTimeout_);\n        this.downTimeout_ = undefined;\n      }\n    }\n    if (\n      this.freehand_ &&\n      event.type === MapBrowserEventType.POINTERDRAG &&\n      this.sketchFeature_ !== null\n    ) {\n      this.addToDrawing_(event.coordinate);\n      pass = false;\n    } else if (\n      this.freehand_ &&\n      event.type === MapBrowserEventType.POINTERDOWN\n    ) {\n      pass = false;\n    } else if (move && this.getPointerCount() < 2) {\n      pass = event.type === MapBrowserEventType.POINTERMOVE;\n      if (pass && this.freehand_) {\n        this.handlePointerMove_(event);\n        if (this.shouldHandle_) {\n          // Avoid page scrolling when freehand drawing on mobile\n          event.originalEvent.preventDefault();\n        }\n      } else if (\n        event.originalEvent.pointerType === 'mouse' ||\n        (event.type === MapBrowserEventType.POINTERDRAG &&\n          this.downTimeout_ === undefined)\n      ) {\n        this.handlePointerMove_(event);\n      }\n    } else if (event.type === MapBrowserEventType.DBLCLICK) {\n      pass = false;\n    }\n\n    return super.handleEvent(event) && pass;\n  }\n\n  /**\n   * Handle pointer down events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleDownEvent(event) {\n    this.shouldHandle_ = !this.freehand_;\n\n    if (this.freehand_) {\n      this.downPx_ = event.pixel;\n      if (!this.finishCoordinate_) {\n        this.startDrawing_(event.coordinate);\n      }\n      return true;\n    }\n\n    if (!this.condition_(event)) {\n      this.lastDragTime_ = undefined;\n      return false;\n    }\n\n    this.lastDragTime_ = Date.now();\n    this.downTimeout_ = setTimeout(() => {\n      this.handlePointerMove_(\n        new MapBrowserEvent(\n          MapBrowserEventType.POINTERMOVE,\n          event.map,\n          event.originalEvent,\n          false,\n          event.frameState,\n        ),\n      );\n    }, this.dragVertexDelay_);\n    this.downPx_ = event.pixel;\n    return true;\n  }\n\n  /**\n   * @private\n   */\n  deactivateTrace_() {\n    this.traceState_ = {active: false};\n  }\n\n  /**\n   * Activate or deactivate trace state based on a browser event.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @private\n   */\n  toggleTraceState_(event) {\n    if (!this.traceSource_ || !this.traceCondition_(event)) {\n      return;\n    }\n\n    if (this.traceState_.active) {\n      this.deactivateTrace_();\n      return;\n    }\n\n    const map = this.getMap();\n    const lowerLeft = map.getCoordinateFromPixel([\n      event.pixel[0] - this.snapTolerance_,\n      event.pixel[1] + this.snapTolerance_,\n    ]);\n    const upperRight = map.getCoordinateFromPixel([\n      event.pixel[0] + this.snapTolerance_,\n      event.pixel[1] - this.snapTolerance_,\n    ]);\n    const extent = boundingExtent([lowerLeft, upperRight]);\n    const features = this.traceSource_.getFeaturesInExtent(extent);\n    if (features.length === 0) {\n      return;\n    }\n\n    const targets = getTraceTargets(event.coordinate, features);\n    if (targets.length) {\n      this.traceState_ = {\n        active: true,\n        startPx: event.pixel.slice(),\n        targets: targets,\n        targetIndex: -1,\n      };\n    }\n  }\n\n  /**\n   * @param {TraceTarget} target The trace target.\n   * @param {number} endIndex The new end index of the trace.\n   * @private\n   */\n  addOrRemoveTracedCoordinates_(target, endIndex) {\n    // three cases to handle:\n    //  1. traced in the same direction and points need adding\n    //  2. traced in the same direction and points need removing\n    //  3. traced in a new direction\n    const previouslyForward = target.startIndex <= target.endIndex;\n    const currentlyForward = target.startIndex <= endIndex;\n    if (previouslyForward === currentlyForward) {\n      // same direction\n      if (\n        (previouslyForward && endIndex > target.endIndex) ||\n        (!previouslyForward && endIndex < target.endIndex)\n      ) {\n        // case 1 - add new points\n        this.addTracedCoordinates_(target, target.endIndex, endIndex);\n      } else if (\n        (previouslyForward && endIndex < target.endIndex) ||\n        (!previouslyForward && endIndex > target.endIndex)\n      ) {\n        // case 2 - remove old points\n        this.removeTracedCoordinates_(endIndex, target.endIndex);\n      }\n    } else {\n      // case 3 - remove old points, add new points\n      this.removeTracedCoordinates_(target.startIndex, target.endIndex);\n      this.addTracedCoordinates_(target, target.startIndex, endIndex);\n    }\n  }\n\n  /**\n   * @param {number} fromIndex The start index.\n   * @param {number} toIndex The end index.\n   * @private\n   */\n  removeTracedCoordinates_(fromIndex, toIndex) {\n    if (fromIndex === toIndex) {\n      return;\n    }\n\n    let remove = 0;\n    if (fromIndex < toIndex) {\n      const start = Math.ceil(fromIndex);\n      let end = Math.floor(toIndex);\n      if (end === toIndex) {\n        end -= 1;\n      }\n      remove = end - start + 1;\n    } else {\n      const start = Math.floor(fromIndex);\n      let end = Math.ceil(toIndex);\n      if (end === toIndex) {\n        end += 1;\n      }\n      remove = start - end + 1;\n    }\n\n    if (remove > 0) {\n      this.removeLastPoints_(remove);\n    }\n  }\n\n  /**\n   * @param {TraceTarget} target The trace target.\n   * @param {number} fromIndex The start index.\n   * @param {number} toIndex The end index.\n   * @private\n   */\n  addTracedCoordinates_(target, fromIndex, toIndex) {\n    if (fromIndex === toIndex) {\n      return;\n    }\n\n    const coordinates = [];\n    if (fromIndex < toIndex) {\n      // forward trace\n      const start = Math.ceil(fromIndex);\n      let end = Math.floor(toIndex);\n      if (end === toIndex) {\n        // if end is snapped to a vertex, it will be added later\n        end -= 1;\n      }\n      for (let i = start; i <= end; ++i) {\n        coordinates.push(getCoordinate(target.coordinates, i));\n      }\n    } else {\n      // reverse trace\n      const start = Math.floor(fromIndex);\n      let end = Math.ceil(toIndex);\n      if (end === toIndex) {\n        end += 1;\n      }\n      for (let i = start; i >= end; --i) {\n        coordinates.push(getCoordinate(target.coordinates, i));\n      }\n    }\n    if (coordinates.length) {\n      this.appendCoordinates(coordinates);\n    }\n  }\n\n  /**\n   * Update the trace.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @private\n   */\n  updateTrace_(event) {\n    const traceState = this.traceState_;\n    if (!traceState.active) {\n      return;\n    }\n\n    if (traceState.targetIndex === -1) {\n      // check if we are ready to pick a target\n      if (distance(traceState.startPx, event.pixel) < this.snapTolerance_) {\n        return;\n      }\n    }\n\n    const updatedTraceTarget = getTraceTargetUpdate(\n      event.coordinate,\n      traceState,\n      this.getMap(),\n      this.snapTolerance_,\n    );\n\n    if (traceState.targetIndex !== updatedTraceTarget.index) {\n      // target changed\n      if (traceState.targetIndex !== -1) {\n        // remove points added during previous trace\n        const oldTarget = traceState.targets[traceState.targetIndex];\n        this.removeTracedCoordinates_(oldTarget.startIndex, oldTarget.endIndex);\n      }\n      // add points for the new target\n      const newTarget = traceState.targets[updatedTraceTarget.index];\n      this.addTracedCoordinates_(\n        newTarget,\n        newTarget.startIndex,\n        updatedTraceTarget.endIndex,\n      );\n    } else {\n      // target stayed the same\n      const target = traceState.targets[traceState.targetIndex];\n      this.addOrRemoveTracedCoordinates_(target, updatedTraceTarget.endIndex);\n    }\n\n    // modify the state with updated info\n    traceState.targetIndex = updatedTraceTarget.index;\n    const target = traceState.targets[traceState.targetIndex];\n    target.endIndex = updatedTraceTarget.endIndex;\n\n    // update event coordinate and pixel to match end point of final segment\n    const coordinate = interpolateCoordinate(\n      target.coordinates,\n      target.endIndex,\n    );\n    const pixel = this.getMap().getPixelFromCoordinate(coordinate);\n    event.coordinate = coordinate;\n    event.pixel = [Math.round(pixel[0]), Math.round(pixel[1])];\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleUpEvent(event) {\n    let pass = true;\n\n    if (this.getPointerCount() === 0) {\n      if (this.downTimeout_) {\n        clearTimeout(this.downTimeout_);\n        this.downTimeout_ = undefined;\n      }\n\n      this.handlePointerMove_(event);\n      const tracing = this.traceState_.active;\n      this.toggleTraceState_(event);\n\n      if (this.shouldHandle_) {\n        const startingToDraw = !this.finishCoordinate_;\n        if (startingToDraw) {\n          this.startDrawing_(event.coordinate);\n        }\n        if (!startingToDraw && this.freehand_) {\n          this.finishDrawing();\n        } else if (\n          !this.freehand_ &&\n          (!startingToDraw || this.mode_ === 'Point')\n        ) {\n          if (this.atFinish_(event.pixel, tracing)) {\n            if (this.finishCondition_(event)) {\n              this.finishDrawing();\n            }\n          } else {\n            this.addToDrawing_(event.coordinate);\n          }\n        }\n        pass = false;\n      } else if (this.freehand_) {\n        this.abortDrawing();\n      }\n    }\n\n    if (!pass && this.stopClick_) {\n      event.preventDefault();\n    }\n    return pass;\n  }\n\n  /**\n   * Handle move events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event A move event.\n   * @private\n   */\n  handlePointerMove_(event) {\n    this.pointerType_ = event.originalEvent.pointerType;\n    if (\n      this.downPx_ &&\n      ((!this.freehand_ && this.shouldHandle_) ||\n        (this.freehand_ && !this.shouldHandle_))\n    ) {\n      const downPx = this.downPx_;\n      const clickPx = event.pixel;\n      const dx = downPx[0] - clickPx[0];\n      const dy = downPx[1] - clickPx[1];\n      const squaredDistance = dx * dx + dy * dy;\n      this.shouldHandle_ = this.freehand_\n        ? squaredDistance > this.squaredClickTolerance_\n        : squaredDistance <= this.squaredClickTolerance_;\n      if (!this.shouldHandle_) {\n        return;\n      }\n    }\n\n    if (!this.finishCoordinate_) {\n      this.createOrUpdateSketchPoint_(event.coordinate.slice());\n      return;\n    }\n\n    this.updateTrace_(event);\n    this.modifyDrawing_(event.coordinate);\n  }\n\n  /**\n   * Determine if an event is within the snapping tolerance of the start coord.\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @param {boolean} [tracing] Drawing in trace mode (only stop if at the starting point).\n   * @return {boolean} The event is within the snapping tolerance of the start.\n   * @private\n   */\n  atFinish_(pixel, tracing) {\n    let at = false;\n    if (this.sketchFeature_) {\n      let potentiallyDone = false;\n      let potentiallyFinishCoordinates = [this.finishCoordinate_];\n      const mode = this.mode_;\n      if (mode === 'Point') {\n        at = true;\n      } else if (mode === 'Circle') {\n        at = this.sketchCoords_.length === 2;\n      } else if (mode === 'LineString') {\n        potentiallyDone =\n          !tracing && this.sketchCoords_.length > this.minPoints_;\n      } else if (mode === 'Polygon') {\n        const sketchCoords = /** @type {PolyCoordType} */ (this.sketchCoords_);\n        potentiallyDone = sketchCoords[0].length > this.minPoints_;\n        potentiallyFinishCoordinates = [\n          sketchCoords[0][0],\n          sketchCoords[0][sketchCoords[0].length - 2],\n        ];\n        if (tracing) {\n          potentiallyFinishCoordinates = [sketchCoords[0][0]];\n        } else {\n          potentiallyFinishCoordinates = [\n            sketchCoords[0][0],\n            sketchCoords[0][sketchCoords[0].length - 2],\n          ];\n        }\n      }\n      if (potentiallyDone) {\n        const map = this.getMap();\n        for (let i = 0, ii = potentiallyFinishCoordinates.length; i < ii; i++) {\n          const finishCoordinate = potentiallyFinishCoordinates[i];\n          const finishPixel = map.getPixelFromCoordinate(finishCoordinate);\n          const dx = pixel[0] - finishPixel[0];\n          const dy = pixel[1] - finishPixel[1];\n          const snapTolerance = this.freehand_ ? 1 : this.snapTolerance_;\n          at = Math.sqrt(dx * dx + dy * dy) <= snapTolerance;\n          if (at) {\n            this.finishCoordinate_ = finishCoordinate;\n            break;\n          }\n        }\n      }\n    }\n    return at;\n  }\n\n  /**\n   * @param {import(\"../coordinate\").Coordinate} coordinates Coordinate.\n   * @private\n   */\n  createOrUpdateSketchPoint_(coordinates) {\n    if (!this.sketchPoint_) {\n      this.sketchPoint_ = new Feature(new Point(coordinates));\n      this.updateSketchFeatures_();\n    } else {\n      const sketchPointGeom = this.sketchPoint_.getGeometry();\n      sketchPointGeom.setCoordinates(coordinates);\n    }\n  }\n\n  /**\n   * @param {import(\"../geom/Polygon.js\").default} geometry Polygon geometry.\n   * @private\n   */\n  createOrUpdateCustomSketchLine_(geometry) {\n    if (!this.sketchLine_) {\n      this.sketchLine_ = new Feature();\n    }\n    const ring = geometry.getLinearRing(0);\n    let sketchLineGeom = this.sketchLine_.getGeometry();\n    if (!sketchLineGeom) {\n      sketchLineGeom = new LineString(\n        ring.getFlatCoordinates(),\n        ring.getLayout(),\n      );\n      this.sketchLine_.setGeometry(sketchLineGeom);\n    } else {\n      sketchLineGeom.setFlatCoordinates(\n        ring.getLayout(),\n        ring.getFlatCoordinates(),\n      );\n      sketchLineGeom.changed();\n    }\n  }\n\n  /**\n   * Start the drawing.\n   * @param {import(\"../coordinate.js\").Coordinate} start Start coordinate.\n   * @private\n   */\n  startDrawing_(start) {\n    const projection = this.getMap().getView().getProjection();\n    const stride = getStrideForLayout(this.geometryLayout_);\n    while (start.length < stride) {\n      start.push(0);\n    }\n    this.finishCoordinate_ = start;\n    if (this.mode_ === 'Point') {\n      this.sketchCoords_ = start.slice();\n    } else if (this.mode_ === 'Polygon') {\n      this.sketchCoords_ = [[start.slice(), start.slice()]];\n      this.sketchLineCoords_ = this.sketchCoords_[0];\n    } else {\n      this.sketchCoords_ = [start.slice(), start.slice()];\n    }\n    if (this.sketchLineCoords_) {\n      this.sketchLine_ = new Feature(new LineString(this.sketchLineCoords_));\n    }\n    const geometry = this.geometryFunction_(\n      this.sketchCoords_,\n      undefined,\n      projection,\n    );\n    this.sketchFeature_ = new Feature();\n    if (this.geometryName_) {\n      this.sketchFeature_.setGeometryName(this.geometryName_);\n    }\n    this.sketchFeature_.setGeometry(geometry);\n    this.updateSketchFeatures_();\n    this.dispatchEvent(\n      new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_),\n    );\n  }\n\n  /**\n   * Modify the drawing.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @private\n   */\n  modifyDrawing_(coordinate) {\n    const map = this.getMap();\n    const geometry = this.sketchFeature_.getGeometry();\n    const projection = map.getView().getProjection();\n    const stride = getStrideForLayout(this.geometryLayout_);\n    let coordinates, last;\n    while (coordinate.length < stride) {\n      coordinate.push(0);\n    }\n    if (this.mode_ === 'Point') {\n      last = this.sketchCoords_;\n    } else if (this.mode_ === 'Polygon') {\n      coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];\n      last = coordinates[coordinates.length - 1];\n      if (this.atFinish_(map.getPixelFromCoordinate(coordinate))) {\n        // snap to finish\n        coordinate = this.finishCoordinate_.slice();\n      }\n    } else {\n      coordinates = this.sketchCoords_;\n      last = coordinates[coordinates.length - 1];\n    }\n    last[0] = coordinate[0];\n    last[1] = coordinate[1];\n    this.geometryFunction_(\n      /** @type {!LineCoordType} */ (this.sketchCoords_),\n      geometry,\n      projection,\n    );\n    if (this.sketchPoint_) {\n      const sketchPointGeom = this.sketchPoint_.getGeometry();\n      sketchPointGeom.setCoordinates(coordinate);\n    }\n    if (geometry.getType() === 'Polygon' && this.mode_ !== 'Polygon') {\n      this.createOrUpdateCustomSketchLine_(/** @type {Polygon} */ (geometry));\n    } else if (this.sketchLineCoords_) {\n      const sketchLineGeom = this.sketchLine_.getGeometry();\n      sketchLineGeom.setCoordinates(this.sketchLineCoords_);\n    }\n    this.updateSketchFeatures_();\n  }\n\n  /**\n   * Add a new coordinate to the drawing.\n   * @param {!PointCoordType} coordinate Coordinate\n   * @return {Feature<import(\"../geom/SimpleGeometry.js\").default>} The sketch feature.\n   * @private\n   */\n  addToDrawing_(coordinate) {\n    const geometry = this.sketchFeature_.getGeometry();\n    const projection = this.getMap().getView().getProjection();\n    let done;\n    let coordinates;\n    const mode = this.mode_;\n    if (mode === 'LineString' || mode === 'Circle') {\n      this.finishCoordinate_ = coordinate.slice();\n      coordinates = /** @type {LineCoordType} */ (this.sketchCoords_);\n      if (coordinates.length >= this.maxPoints_) {\n        if (this.freehand_) {\n          coordinates.pop();\n        } else {\n          done = true;\n        }\n      }\n      coordinates.push(coordinate.slice());\n      this.geometryFunction_(coordinates, geometry, projection);\n    } else if (mode === 'Polygon') {\n      coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];\n      if (coordinates.length >= this.maxPoints_) {\n        if (this.freehand_) {\n          coordinates.pop();\n        } else {\n          done = true;\n        }\n      }\n      coordinates.push(coordinate.slice());\n      if (done) {\n        this.finishCoordinate_ = coordinates[0];\n      }\n      this.geometryFunction_(this.sketchCoords_, geometry, projection);\n    }\n    this.createOrUpdateSketchPoint_(coordinate.slice());\n    this.updateSketchFeatures_();\n    if (done) {\n      return this.finishDrawing();\n    }\n    return this.sketchFeature_;\n  }\n\n  /**\n   * @param {number} n The number of points to remove.\n   */\n  removeLastPoints_(n) {\n    if (!this.sketchFeature_) {\n      return;\n    }\n    const geometry = this.sketchFeature_.getGeometry();\n    const projection = this.getMap().getView().getProjection();\n    const mode = this.mode_;\n    for (let i = 0; i < n; ++i) {\n      let coordinates;\n      if (mode === 'LineString' || mode === 'Circle') {\n        coordinates = /** @type {LineCoordType} */ (this.sketchCoords_);\n        coordinates.splice(-2, 1);\n        if (coordinates.length >= 2) {\n          this.finishCoordinate_ = coordinates[coordinates.length - 2].slice();\n          const finishCoordinate = this.finishCoordinate_.slice();\n          coordinates[coordinates.length - 1] = finishCoordinate;\n          this.createOrUpdateSketchPoint_(finishCoordinate);\n        }\n        this.geometryFunction_(coordinates, geometry, projection);\n        if (geometry.getType() === 'Polygon' && this.sketchLine_) {\n          this.createOrUpdateCustomSketchLine_(\n            /** @type {Polygon} */ (geometry),\n          );\n        }\n      } else if (mode === 'Polygon') {\n        coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];\n        coordinates.splice(-2, 1);\n        const sketchLineGeom = this.sketchLine_.getGeometry();\n        if (coordinates.length >= 2) {\n          const finishCoordinate = coordinates[coordinates.length - 2].slice();\n          coordinates[coordinates.length - 1] = finishCoordinate;\n          this.createOrUpdateSketchPoint_(finishCoordinate);\n        }\n        sketchLineGeom.setCoordinates(coordinates);\n        this.geometryFunction_(this.sketchCoords_, geometry, projection);\n      }\n\n      if (coordinates.length === 1) {\n        this.abortDrawing();\n        break;\n      }\n    }\n\n    this.updateSketchFeatures_();\n  }\n\n  /**\n   * Remove last point of the feature currently being drawn. Does not do anything when\n   * drawing POINT or MULTI_POINT geometries.\n   * @api\n   */\n  removeLastPoint() {\n    this.removeLastPoints_(1);\n  }\n\n  /**\n   * Stop drawing and add the sketch feature to the target layer.\n   * The {@link module:ol/interaction/Draw~DrawEventType.DRAWEND} event is\n   * dispatched before inserting the feature.\n   * @return {Feature<import(\"../geom/SimpleGeometry.js\").default>|null} The drawn feature.\n   * @api\n   */\n  finishDrawing() {\n    const sketchFeature = this.abortDrawing_();\n    if (!sketchFeature) {\n      return null;\n    }\n    let coordinates = this.sketchCoords_;\n    const geometry = sketchFeature.getGeometry();\n    const projection = this.getMap().getView().getProjection();\n    if (this.mode_ === 'LineString') {\n      // remove the redundant last point\n      coordinates.pop();\n      this.geometryFunction_(coordinates, geometry, projection);\n    } else if (this.mode_ === 'Polygon') {\n      // remove the redundant last point in ring\n      /** @type {PolyCoordType} */ (coordinates)[0].pop();\n      this.geometryFunction_(coordinates, geometry, projection);\n      coordinates = geometry.getCoordinates();\n    }\n\n    // cast multi-part geometries\n    if (this.type_ === 'MultiPoint') {\n      sketchFeature.setGeometry(\n        new MultiPoint([/** @type {PointCoordType} */ (coordinates)]),\n      );\n    } else if (this.type_ === 'MultiLineString') {\n      sketchFeature.setGeometry(\n        new MultiLineString([/** @type {LineCoordType} */ (coordinates)]),\n      );\n    } else if (this.type_ === 'MultiPolygon') {\n      sketchFeature.setGeometry(\n        new MultiPolygon([/** @type {PolyCoordType} */ (coordinates)]),\n      );\n    }\n\n    // First dispatch event to allow full set up of feature\n    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWEND, sketchFeature));\n\n    // Then insert feature\n    if (this.features_) {\n      this.features_.push(sketchFeature);\n    }\n    if (this.source_) {\n      this.source_.addFeature(sketchFeature);\n    }\n    return sketchFeature;\n  }\n\n  /**\n   * Stop drawing without adding the sketch feature to the target layer.\n   * @return {Feature<import(\"../geom/SimpleGeometry.js\").default>|null} The sketch feature (or null if none).\n   * @private\n   */\n  abortDrawing_() {\n    this.finishCoordinate_ = null;\n    const sketchFeature = this.sketchFeature_;\n    this.sketchFeature_ = null;\n    this.sketchPoint_ = null;\n    this.sketchLine_ = null;\n    this.overlay_.getSource().clear(true);\n    this.deactivateTrace_();\n    return sketchFeature;\n  }\n\n  /**\n   * Stop drawing without adding the sketch feature to the target layer.\n   * @api\n   */\n  abortDrawing() {\n    const sketchFeature = this.abortDrawing_();\n    if (sketchFeature) {\n      this.dispatchEvent(new DrawEvent(DrawEventType.DRAWABORT, sketchFeature));\n    }\n  }\n\n  /**\n   * Append coordinates to the end of the geometry that is currently being drawn.\n   * This can be used when drawing LineStrings or Polygons. Coordinates will\n   * either be appended to the current LineString or the outer ring of the current\n   * Polygon. If no geometry is being drawn, a new one will be created.\n   * @param {!LineCoordType} coordinates Linear coordinates to be appended to\n   * the coordinate array.\n   * @api\n   */\n  appendCoordinates(coordinates) {\n    const mode = this.mode_;\n    const newDrawing = !this.sketchFeature_;\n    if (newDrawing) {\n      this.startDrawing_(coordinates[0]);\n    }\n    /** @type {LineCoordType} */\n    let sketchCoords;\n    if (mode === 'LineString' || mode === 'Circle') {\n      sketchCoords = /** @type {LineCoordType} */ (this.sketchCoords_);\n    } else if (mode === 'Polygon') {\n      sketchCoords =\n        this.sketchCoords_ && this.sketchCoords_.length\n          ? /** @type {PolyCoordType} */ (this.sketchCoords_)[0]\n          : [];\n    } else {\n      return;\n    }\n\n    if (newDrawing) {\n      sketchCoords.shift();\n    }\n\n    // Remove last coordinate from sketch drawing (this coordinate follows cursor position)\n    sketchCoords.pop();\n\n    // Append coordinate list\n    for (let i = 0; i < coordinates.length; i++) {\n      this.addToDrawing_(coordinates[i]);\n    }\n\n    const ending = coordinates[coordinates.length - 1];\n    // Duplicate last coordinate for sketch drawing (cursor position)\n    this.sketchFeature_ = this.addToDrawing_(ending);\n    this.modifyDrawing_(ending);\n  }\n\n  /**\n   * Initiate draw mode by starting from an existing geometry which will\n   * receive new additional points. This only works on features with\n   * `LineString` geometries, where the interaction will extend lines by adding\n   * points to the end of the coordinates array.\n   * This will change the original feature, instead of drawing a copy.\n   *\n   * The function will dispatch a `drawstart` event.\n   *\n   * @param {!Feature<LineString>} feature Feature to be extended.\n   * @api\n   */\n  extend(feature) {\n    const geometry = feature.getGeometry();\n    const lineString = geometry;\n    this.sketchFeature_ = feature;\n    this.sketchCoords_ = lineString.getCoordinates();\n    const last = this.sketchCoords_[this.sketchCoords_.length - 1];\n    this.finishCoordinate_ = last.slice();\n    this.sketchCoords_.push(last.slice());\n    this.sketchPoint_ = new Feature(new Point(last));\n    this.updateSketchFeatures_();\n    this.dispatchEvent(\n      new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_),\n    );\n  }\n\n  /**\n   * Redraw the sketch features.\n   * @private\n   */\n  updateSketchFeatures_() {\n    const sketchFeatures = [];\n    if (this.sketchFeature_) {\n      sketchFeatures.push(this.sketchFeature_);\n    }\n    if (this.sketchLine_) {\n      sketchFeatures.push(this.sketchLine_);\n    }\n    if (this.sketchPoint_) {\n      sketchFeatures.push(this.sketchPoint_);\n    }\n    const overlaySource = this.overlay_.getSource();\n    overlaySource.clear(true);\n    overlaySource.addFeatures(sketchFeatures);\n  }\n\n  /**\n   * @private\n   */\n  updateState_() {\n    const map = this.getMap();\n    const active = this.getActive();\n    if (!map || !active) {\n      this.abortDrawing();\n    }\n    this.overlay_.setMap(active ? map : null);\n  }\n}\n\n/**\n * @return {import(\"../style/Style.js\").StyleFunction} Styles.\n */\nfunction getDefaultStyleFunction() {\n  const styles = createEditingStyle();\n  return function (feature, resolution) {\n    return styles[feature.getGeometry().getType()];\n  };\n}\n\n/**\n * Create a `geometryFunction` for `type: 'Circle'` that will create a regular\n * polygon with a user specified number of sides and start angle instead of a\n * {@link import(\"../geom/Circle.js\").Circle} geometry.\n * @param {number} [sides] Number of sides of the regular polygon.\n *     Default is 32.\n * @param {number} [angle] Angle of the first point in counter-clockwise\n *     radians. 0 means East.\n *     Default is the angle defined by the heading from the center of the\n *     regular polygon to the current pointer position.\n * @return {GeometryFunction} Function that draws a polygon.\n * @api\n */\nexport function createRegularPolygon(sides, angle) {\n  return function (coordinates, geometry, projection) {\n    const center = fromUserCoordinate(\n      /** @type {LineCoordType} */ (coordinates)[0],\n      projection,\n    );\n    const end = fromUserCoordinate(\n      /** @type {LineCoordType} */ (coordinates)[coordinates.length - 1],\n      projection,\n    );\n    const radius = Math.sqrt(squaredCoordinateDistance(center, end));\n    geometry = geometry || fromCircle(new Circle(center), sides);\n\n    let internalAngle = angle;\n    if (!angle && angle !== 0) {\n      const x = end[0] - center[0];\n      const y = end[1] - center[1];\n      internalAngle = Math.atan2(y, x);\n    }\n    makeRegular(\n      /** @type {Polygon} */ (geometry),\n      center,\n      radius,\n      internalAngle,\n    );\n\n    const userProjection = getUserProjection();\n    if (userProjection) {\n      geometry.transform(projection, userProjection);\n    }\n    return geometry;\n  };\n}\n\n/**\n * Create a `geometryFunction` that will create a box-shaped polygon (aligned\n * with the coordinate system axes).  Use this with the draw interaction and\n * `type: 'Circle'` to return a box instead of a circle geometry.\n * @return {GeometryFunction} Function that draws a box-shaped polygon.\n * @api\n */\nexport function createBox() {\n  return function (coordinates, geometry, projection) {\n    const extent = boundingExtent(\n      /** @type {LineCoordType} */ ([\n        coordinates[0],\n        coordinates[coordinates.length - 1],\n      ]).map(function (coordinate) {\n        return fromUserCoordinate(coordinate, projection);\n      }),\n    );\n    const boxCoordinates = [\n      [\n        getBottomLeft(extent),\n        getBottomRight(extent),\n        getTopRight(extent),\n        getTopLeft(extent),\n        getBottomLeft(extent),\n      ],\n    ];\n    if (geometry) {\n      geometry.setCoordinates(boxCoordinates);\n    } else {\n      geometry = new Polygon(boxCoordinates);\n    }\n    const userProjection = getUserProjection();\n    if (userProjection) {\n      geometry.transform(projection, userProjection);\n    }\n    return geometry;\n  };\n}\n\n/**\n * Get the drawing mode.  The mode for multi-part geometries is the same as for\n * their single-part cousins.\n * @param {import(\"../geom/Geometry.js\").Type} type Geometry type.\n * @return {Mode} Drawing mode.\n */\nfunction getMode(type) {\n  switch (type) {\n    case 'Point':\n    case 'MultiPoint':\n      return 'Point';\n    case 'LineString':\n    case 'MultiLineString':\n      return 'LineString';\n    case 'Polygon':\n    case 'MultiPolygon':\n      return 'Polygon';\n    case 'Circle':\n      return 'Circle';\n    default:\n      throw new Error('Invalid type: ' + type);\n  }\n}\n\nexport default Draw;\n","import ol_style_Style from 'ol/style/Style.js'\r\nimport ol_style_Stroke from 'ol/style/Stroke.js'\r\nimport ol_source_Vector from 'ol/source/Vector.js'\r\nimport ol_style_Fill from 'ol/style/Fill.js'\r\nimport ol_layer_Vector from 'ol/layer/Vector.js'\r\nimport ol_geom_Point from 'ol/geom/Point.js'\r\nimport ol_Feature from 'ol/Feature.js'\r\nimport ol_Collection from 'ol/Collection.js'\r\nimport ol_interaction_Pointer from 'ol/interaction/Pointer.js'\r\nimport ol_style_RegularShape from 'ol/style/RegularShape.js'\r\nimport {fromExtent as ol_geom_Polygon_fromExtent} from 'ol/geom/Polygon.js'\r\nimport {boundingExtent as ol_extent_boundingExtent, buffer as ol_extent_buffer, createEmpty as ol_extent_createEmpty, extend as ol_extent_extend, getCenter as ol_extent_getCenter} from 'ol/extent.js'\r\nimport {unByKey as ol_Observable_unByKey} from 'ol/Observable.js'\r\nimport ol_geom_Polygon from 'ol/geom/Polygon.js'\r\nimport ol_ext_element from '../util/element.js'\r\n\r\n/** Interaction rotate\r\n * @constructor\r\n * @extends {ol_interaction_Pointer}\r\n * @fires select | rotatestart | rotating | rotateend | translatestart | translating | translateend | scalestart | scaling | scaleend\r\n * @param {any} options\r\n *  @param {function} options.filter A function that takes a Feature and a Layer and returns true if the feature may be transformed or false otherwise.\r\n *  @param {Array<ol.Layer>} options.layers array of layers to transform,\r\n *  @param {ol.Collection<ol.Feature>} options.features collection of feature to transform,\r\n *\t@param {ol.EventsConditionType|undefined} options.condition A function that takes an ol.MapBrowserEvent and a feature collection and returns a boolean to indicate whether that event should be handled. default: ol.events.condition.always.\r\n *\t@param {ol.EventsConditionType|undefined} options.addCondition A function that takes an ol.MapBrowserEvent and returns a boolean to indicate whether that event should be handled ie. the feature will be added to the transforms features. default: ol.events.condition.never.\r\n *\t@param {number | undefined} options.hitTolerance Tolerance to select feature in pixel, default 0\r\n *\t@param {bool} options.translateFeature Translate when click on feature\r\n *\t@param {bool} options.translate Can translate the feature\r\n *  @param {bool} options.translateBBox Enable translate when the user drags inside the bounding box\r\n *\t@param {bool} options.stretch can stretch the feature\r\n *\t@param {bool} options.scale can scale the feature\r\n *\t@param {bool} options.rotate can rotate the feature\r\n *\t@param {bool} options.noFlip prevent the feature geometry to flip, default false\r\n *\t@param {bool} options.selection the intraction handle selection/deselection, if not use the select prototype to add features to transform, default true\r\n *\t@param {ol.events.ConditionType | undefined} options.keepAspectRatio A function that takes an ol.MapBrowserEvent and returns a boolean to keep aspect ratio, default ol.events.condition.shiftKeyOnly.\r\n *\t@param {ol.events.ConditionType | undefined} options.modifyCenter A function that takes an ol.MapBrowserEvent and returns a boolean to apply scale & strech from the center, default ol.events.condition.metaKey or ol.events.condition.ctrlKey.\r\n *\t@param {boolean} options.enableRotatedTransform Enable transform when map is rotated\r\n *\t@param {boolean} [options.keepRectangle=false] keep rectangle when possible\r\n *  @param {number} [options.buffer] Increase the extent used as bounding box, default 0\r\n *\t@param {*} options.style list of ol.style for handles\r\n *  @param {number|Array<number>|function} [options.pointRadius=0] radius for points or a function that takes a feature and returns the radius (or [radiusX, radiusY]). If not null show handles to transform the points\r\n */\r\nvar ol_interaction_Transform = class olinteractionTransform extends ol_interaction_Pointer {\r\n  constructor(options) {\r\n    options = options || {}\r\n    // Extend pointer\r\n    super({\r\n      handleDownEvent: function(e) { return self.handleDownEvent_(e) },\r\n      handleDragEvent: function(e) { return this.handleDragEvent_(e) },\r\n      handleMoveEvent: function(e) { return this.handleMoveEvent_(e) },\r\n      handleUpEvent: function(e) { return this.handleUpEvent_(e) },\r\n    })\r\n    \r\n    var self = this\r\n    this.selection_ = new ol_Collection()\r\n\r\n    // Create a new overlay layer for the sketch\r\n    this.handles_ = new ol_Collection()\r\n    this.overlayLayer_ = new ol_layer_Vector({\r\n      source: new ol_source_Vector({\r\n        features: this.handles_,\r\n        useSpatialIndex: false,\r\n        wrapX: false // For vector editing across the -180 and 180 meridians to work properly, this should be set to false\r\n      }),\r\n      name: 'Transform overlay',\r\n      displayInLayerSwitcher: false,\r\n      // Return the style according to the handle type\r\n      style: function (feature) {\r\n        return (self.style[(feature.get('handle') || 'default') + (feature.get('constraint') || '') + (feature.get('option') || '')])\r\n      },\r\n      updateWhileAnimating: true,\r\n      updateWhileInteracting: true,\r\n    })\r\n\r\n    // Collection of feature to transform\r\n    this.features_ = options.features\r\n    // Filter or list of layers to transform\r\n    if (typeof (options.filter) === 'function')\r\n      this._filter = options.filter\r\n    this.layers_ = options.layers ? (options.layers instanceof Array) ? options.layers : [options.layers] : null\r\n\r\n    this._handleEvent = options.condition || function () { return true }\r\n    this.addFn_ = options.addCondition || function () { return false }\r\n    this.setPointRadius(options.pointRadius)\r\n    /* Translate when click on feature */\r\n    this.set('translateFeature', (options.translateFeature !== false))\r\n    /* Can translate the feature */\r\n    this.set('translate', (options.translate !== false))\r\n    /* Translate when click on the bounding box */\r\n    this.set('translateBBox', (options.translateBBox === true))\r\n    /* Can stretch the feature */\r\n    this.set('stretch', (options.stretch !== false))\r\n    /* Can scale the feature */\r\n    this.set('scale', (options.scale !== false))\r\n    /* Can rotate the feature */\r\n    this.set('rotate', (options.rotate !== false))\r\n    /* Keep aspect ratio */\r\n    this.set('keepAspectRatio', (options.keepAspectRatio || function (e) { return e.originalEvent.shiftKey }))\r\n    /* Modify center */\r\n    this.set('modifyCenter', (options.modifyCenter || function (e) { return e.originalEvent.metaKey || e.originalEvent.ctrlKey }))\r\n    /* Prevent flip */\r\n    this.set('noFlip', (options.noFlip || false))\r\n    /* Handle selection */\r\n    this.set('selection', (options.selection !== false))\r\n    /*  */\r\n    this.set('hitTolerance', (options.hitTolerance || 0))\r\n    /* Enable view rotated transforms */\r\n    this.set('enableRotatedTransform', (options.enableRotatedTransform || false))\r\n    /* Keep rectangle angles 90 degrees */\r\n    this.set('keepRectangle', (options.keepRectangle || false))\r\n    /* Add buffer to the feature's extent */\r\n    this.set('buffer', (options.buffer || 0))\r\n\r\n    // Force redraw when changed\r\n    this.on('propertychange', function () {\r\n      this.drawSketch_()\r\n    })\r\n\r\n    // setstyle\r\n    this.setDefaultStyle()\r\n  }\r\n  /**\r\n   * Remove the interaction from its current map, if any,  and attach it to a new\r\n   * map, if any. Pass `null` to just remove the interaction from the current map.\r\n   * @param {ol.Map} map Map.\r\n   * @api stable\r\n   */\r\n  setMap(map) {\r\n    var oldMap = this.getMap()\r\n    if (oldMap) {\r\n      oldMap.removeLayer(this.overlayLayer_)\r\n      if (this.previousCursor_) {\r\n        ol_ext_element.setCursor(oldMap, this.previousCursor_)\r\n      }\r\n      this.previousCursor_ = undefined\r\n    }\r\n    super.setMap(map)\r\n    this.overlayLayer_.setMap(map)\r\n    if (map === null) {\r\n      this.select(null)\r\n    }\r\n    if (map !== null) {\r\n      this.isTouch = /touch/.test(map.getViewport().className)\r\n      this.setDefaultStyle()\r\n    }\r\n  }\r\n  /**\r\n   * Activate/deactivate interaction\r\n   * @param {bool}\r\n   * @api stable\r\n   */\r\n  setActive(b) {\r\n    this.select(null)\r\n    if (this.overlayLayer_) this.overlayLayer_.setVisible(b)\r\n    super.setActive(b)\r\n  }\r\n  /** Set default sketch style\r\n   * @param {Object} [options]\r\n   *  @param {ol_style_Stroke} [stroke] stroke style for selection rectangle, default red dash\r\n   *  @param {ol_style_Fill} [fill] fill style for selection rectangle, default red\r\n   *  @param {ol_style_Stroke} [pointStroke] stroke style for handles, default red\r\n   *  @param {ol_style_Fill} [pointFill] fill style for handles, default white\r\n   */\r\n  setDefaultStyle(options) {\r\n    options = options || {}\r\n    // Style\r\n    var stroke = options.pointStroke || new ol_style_Stroke({ color: [255, 0, 0, 1], width: 1 })\r\n    var strokedash = options.stroke || new ol_style_Stroke({ color: [255, 0, 0, 1], width: 1, lineDash: [4, 4] })\r\n    var fill0 = options.fill || new ol_style_Fill({ color: [255, 0, 0, 0.01] })\r\n    var fill = options.pointFill || new ol_style_Fill({ color: [255, 255, 255, 0.8] })\r\n    var circle = new ol_style_RegularShape({\r\n      fill: fill,\r\n      stroke: stroke,\r\n      radius: this.isTouch ? 12 : 6,\r\n      displacement: this.isTouch ? [24, -24] : [12, -12],\r\n      points: 15\r\n    })\r\n    // Old version with no displacement\r\n    if (!circle.setDisplacement)\r\n      circle.getAnchor()[0] = this.isTouch ? -10 : -5\r\n    var bigpt = new ol_style_RegularShape({\r\n      fill: fill,\r\n      stroke: stroke,\r\n      radius: this.isTouch ? 16 : 8,\r\n      points: 4,\r\n      angle: Math.PI / 4\r\n    })\r\n    var smallpt = new ol_style_RegularShape({\r\n      fill: fill,\r\n      stroke: stroke,\r\n      radius: this.isTouch ? 12 : 6,\r\n      points: 4,\r\n      angle: Math.PI / 4\r\n    })\r\n    function createStyle(img, stroke, fill) {\r\n      return [new ol_style_Style({ image: img, stroke: stroke, fill: fill })]\r\n    }\r\n    /** Style for handles */\r\n    this.style = {\r\n      'default': createStyle(bigpt, strokedash, fill0),\r\n      'translate': createStyle(bigpt, stroke, fill),\r\n      'rotate': createStyle(circle, stroke, fill),\r\n      'rotate0': createStyle(bigpt, stroke, fill),\r\n      'scale': createStyle(bigpt, stroke, fill),\r\n      'scale1': createStyle(bigpt, stroke, fill),\r\n      'scale2': createStyle(bigpt, stroke, fill),\r\n      'scale3': createStyle(bigpt, stroke, fill),\r\n      'scalev': createStyle(smallpt, stroke, fill),\r\n      'scaleh1': createStyle(smallpt, stroke, fill),\r\n      'scalev2': createStyle(smallpt, stroke, fill),\r\n      'scaleh3': createStyle(smallpt, stroke, fill),\r\n    }\r\n    this.drawSketch_()\r\n  }\r\n  /**\r\n   * Set sketch style.\r\n   * @param {style} style Style name: 'default','translate','rotate','rotate0','scale','scale1','scale2','scale3','scalev','scaleh1','scalev2','scaleh3'\r\n   * @param {ol.style.Style|Array<ol.style.Style>} olstyle\r\n   * @api stable\r\n   */\r\n  setStyle(style, olstyle) {\r\n    if (!olstyle)\r\n      return\r\n    if (olstyle instanceof Array)\r\n      this.style[style] = olstyle\r\n    else\r\n      this.style[style] = [olstyle]\r\n    for (var i = 0; i < this.style[style].length; i++) {\r\n      var im = this.style[style][i].getImage()\r\n      if (im) {\r\n        if (style == 'rotate') {\r\n          im.getAnchor()[0] = -5\r\n        }\r\n        if (this.isTouch)\r\n          im.setScale(1.8)\r\n      }\r\n      var tx = this.style[style][i].getText()\r\n      if (tx) {\r\n        if (style == 'rotate')\r\n          tx.setOffsetX(this.isTouch ? 14 : 7)\r\n        if (this.isTouch)\r\n          tx.setScale(1.8)\r\n      }\r\n    }\r\n    this.drawSketch_()\r\n  }\r\n  /** Get Feature at pixel\r\n   * @param {ol.Pixel}\r\n   * @return {ol.feature}\r\n   * @private\r\n   */\r\n  getFeatureAtPixel_(pixel) {\r\n    var self = this\r\n    return this.getMap().forEachFeatureAtPixel(pixel,\r\n      function (feature, layer) {\r\n        var found = false\r\n        // Overlay ?\r\n        if (!layer) {\r\n          if (feature === self.bbox_) {\r\n            if (self.get('translateBBox')) {\r\n              return { feature: feature, handle: 'translate', constraint: '', option: '' }\r\n            } else {\r\n              return false\r\n            }\r\n          }\r\n          self.handles_.forEach(function (f) {\r\n            if (f === feature)\r\n              found = true\r\n          })\r\n          if (found)\r\n            return { feature: feature, handle: feature.get('handle'), constraint: feature.get('constraint'), option: feature.get('option') }\r\n        }\r\n        // No seletion\r\n        if (!self.get('selection')) {\r\n          // Return the currently selected feature the user is interacting with.\r\n          if (self.selection_.getArray().some(function (f) { return feature === f })) {\r\n            return { feature: feature }\r\n          }\r\n          return null\r\n        }\r\n        // filter condition\r\n        if (self._filter) {\r\n          if (self._filter(feature, layer))\r\n            return { feature: feature }\r\n          else\r\n            return null\r\n        }\r\n\r\n        // feature belong to a layer\r\n        else if (self.layers_) {\r\n          for (var i = 0; i < self.layers_.length; i++) {\r\n            if (self.layers_[i] === layer)\r\n              return { feature: feature }\r\n          }\r\n          return null\r\n        }\r\n\r\n        // feature in the collection\r\n        else if (self.features_) {\r\n          self.features_.forEach(function (f) {\r\n            if (f === feature)\r\n              found = true\r\n          })\r\n          if (found)\r\n            return { feature: feature }\r\n          else\r\n            return null\r\n        }\r\n\r\n        // Others\r\n        else\r\n          return { feature: feature }\r\n      },\r\n      { hitTolerance: this.get('hitTolerance') }\r\n    ) || {}\r\n  }\r\n  /** Rotate feature from map view rotation\r\n   * @param {ol.Feature} f the feature\r\n   * @param {boolean} clone clone resulting geom\r\n   * @param {ol.geom.Geometry} rotated geometry\r\n   */\r\n  getGeometryRotateToZero_(f, clone) {\r\n    var origGeom = f.getGeometry()\r\n    var viewRotation = this.getMap().getView().getRotation()\r\n    if (viewRotation === 0 || !this.get('enableRotatedTransform')) {\r\n      return (clone) ? origGeom.clone() : origGeom\r\n    }\r\n    var rotGeom = origGeom.clone()\r\n    rotGeom.rotate(viewRotation * -1, this.getMap().getView().getCenter())\r\n    return rotGeom\r\n  }\r\n  /** Test if rectangle\r\n   * @param {ol.Geometry} geom\r\n   * @returns {boolean}\r\n   * @private\r\n   */\r\n  _isRectangle(geom) {\r\n    if (this.get('keepRectangle') && geom.getType() === 'Polygon') {\r\n      var coords = geom.getCoordinates()[0]\r\n      return coords.length === 5\r\n    }\r\n    return false\r\n  }\r\n  /** Draw transform sketch\r\n  * @param {boolean} draw only the center\r\n  */\r\n  drawSketch_(center) {\r\n    var i, f, geom\r\n    var keepRectangle = this.selection_.item(0) && this._isRectangle(this.selection_.item(0).getGeometry())\r\n    this.overlayLayer_.getSource().clear()\r\n    if (!this.selection_.getLength())\r\n      return\r\n    var viewRotation = this.getMap().getView().getRotation()\r\n    var ext = this.getGeometryRotateToZero_(this.selection_.item(0)).getExtent()\r\n    var coords\r\n    if (keepRectangle) {\r\n      coords = this.getGeometryRotateToZero_(this.selection_.item(0)).getCoordinates()[0].slice(0, 4)\r\n      coords.unshift(coords[3])\r\n    }\r\n    // Clone and extend\r\n    ext = ol_extent_buffer(ext, this.get('buffer'))\r\n    this.selection_.forEach(function (f) {\r\n      var extendExt = this.getGeometryRotateToZero_(f).getExtent()\r\n      ol_extent_extend(ext, extendExt)\r\n    }.bind(this))\r\n\r\n    var ptRadius = (this.selection_.getLength() === 1 ? this._pointRadius(this.selection_.item(0)) : 0)\r\n    if (ptRadius && !(ptRadius instanceof Array))\r\n      ptRadius = [ptRadius, ptRadius]\r\n\r\n    if (center === true) {\r\n      if (!this.ispt_) {\r\n        this.overlayLayer_.getSource().addFeature(new ol_Feature({ geometry: new ol_geom_Point(this.center_), handle: 'rotate0' }))\r\n        geom = ol_geom_Polygon_fromExtent(ext)\r\n        if (this.get('enableRotatedTransform') && viewRotation !== 0) {\r\n          geom.rotate(viewRotation, this.getMap().getView().getCenter())\r\n        }\r\n        f = this.bbox_ = new ol_Feature(geom)\r\n        this.overlayLayer_.getSource().addFeature(f)\r\n      }\r\n    } else {\r\n      if (this.ispt_) {\r\n        // Calculate extent arround the point\r\n        var p = this.getMap().getPixelFromCoordinate(ol_extent_getCenter(ext))\r\n        if (p) {\r\n          var dx = ptRadius ? ptRadius[0] || 10 : 10\r\n          var dy = ptRadius ? ptRadius[1] || 10 : 10\r\n          ext = ol_extent_boundingExtent([\r\n            this.getMap().getCoordinateFromPixel([p[0] - dx, p[1] - dy]),\r\n            this.getMap().getCoordinateFromPixel([p[0] + dx, p[1] + dy])\r\n          ])\r\n        }\r\n      }\r\n      geom = keepRectangle ? new ol_geom_Polygon([coords]) : ol_geom_Polygon_fromExtent(ext)\r\n      if (this.get('enableRotatedTransform') && viewRotation !== 0) {\r\n        geom.rotate(viewRotation, this.getMap().getView().getCenter())\r\n      }\r\n      f = this.bbox_ = new ol_Feature(geom)\r\n      var features = []\r\n      var g = geom.getCoordinates()[0]\r\n      if (!this.ispt_ || ptRadius) {\r\n        features.push(f)\r\n        // Middle\r\n        if (!this.iscircle_ && !this.ispt_ && this.get('stretch') && this.get('scale'))\r\n          for (i = 0; i < g.length - 1; i++) {\r\n            f = new ol_Feature({ geometry: new ol_geom_Point([(g[i][0] + g[i + 1][0]) / 2, (g[i][1] + g[i + 1][1]) / 2]), handle: 'scale', constraint: i % 2 ? \"h\" : \"v\", option: i })\r\n            features.push(f)\r\n          }\r\n        // Handles\r\n        if (this.get('scale'))\r\n          for (i = 0; i < g.length - 1; i++) {\r\n            f = new ol_Feature({ geometry: new ol_geom_Point(g[i]), handle: 'scale', option: i })\r\n            features.push(f)\r\n          }\r\n        // Center\r\n        if (this.get('translate') && !this.get('translateFeature')) {\r\n          f = new ol_Feature({ geometry: new ol_geom_Point([(g[0][0] + g[2][0]) / 2, (g[0][1] + g[2][1]) / 2]), handle: 'translate' })\r\n          features.push(f)\r\n        }\r\n      }\r\n      // Rotate\r\n      if (!this.iscircle_ && this.get('rotate')) {\r\n        f = new ol_Feature({ geometry: new ol_geom_Point(g[3]), handle: 'rotate' })\r\n        features.push(f)\r\n      }\r\n      // Add sketch\r\n      this.overlayLayer_.getSource().addFeatures(features)\r\n    }\r\n\r\n  }\r\n  /** Select a feature to transform\r\n  * @param {ol.Feature} feature the feature to transform\r\n  * @param {boolean} add true to add the feature to the selection, default false\r\n  */\r\n  select(feature, add) {\r\n    if (!feature) {\r\n      if (this.selection_) {\r\n        this.selection_.clear()\r\n        this.drawSketch_()\r\n      }\r\n      return\r\n    }\r\n    if (!feature.getGeometry || !feature.getGeometry()) return\r\n    // Add to selection\r\n    if (add) {\r\n      this.selection_.push(feature)\r\n    } else {\r\n      var index = this.selection_.getArray().indexOf(feature)\r\n      this.selection_.removeAt(index)\r\n    }\r\n    this.ispt_ = (this.selection_.getLength() === 1 ? (this.selection_.item(0).getGeometry().getType() == \"Point\") : false)\r\n    this.iscircle_ = (this.selection_.getLength() === 1 ? (this.selection_.item(0).getGeometry().getType() == \"Circle\") : false)\r\n    this.drawSketch_()\r\n    this.watchFeatures_()\r\n    // select event\r\n    this.dispatchEvent({ type: 'select', feature: feature, features: this.selection_ })\r\n  }\r\n  /** Update the selection collection.\r\n  * @param {ol.Collection<ol.Feature>} features the features to transform\r\n  */\r\n  setSelection(features) {\r\n    this.selection_.clear()\r\n    features.forEach(function (feature) {\r\n      this.selection_.push(feature)\r\n    }.bind(this))\r\n\r\n    this.ispt_ = (this.selection_.getLength() === 1 ? (this.selection_.item(0).getGeometry().getType() == \"Point\") : false)\r\n    this.iscircle_ = (this.selection_.getLength() === 1 ? (this.selection_.item(0).getGeometry().getType() == \"Circle\") : false)\r\n    this.drawSketch_()\r\n    this.watchFeatures_()\r\n    // select event\r\n    this.dispatchEvent({ type: 'select', features: this.selection_ })\r\n  }\r\n  /** Watch selected features\r\n   * @private\r\n   */\r\n  watchFeatures_() {\r\n    // Listen to feature modification\r\n    if (this._featureListeners) {\r\n      this._featureListeners.forEach(function (l) {\r\n        ol_Observable_unByKey(l)\r\n      })\r\n    }\r\n    this._featureListeners = []\r\n    this.selection_.forEach(function (f) {\r\n      this._featureListeners.push(\r\n        f.on('change', function () {\r\n          if (!this.isUpdating_) {\r\n            this.drawSketch_()\r\n          }\r\n        }.bind(this))\r\n      )\r\n    }.bind(this))\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} evt Map browser event.\r\n   * @return {boolean} `true` to start the drag sequence.\r\n   * @private\r\n   */\r\n  handleDownEvent_(evt) {\r\n    if (!this._handleEvent(evt, this.selection_))\r\n      return\r\n    var sel = this.getFeatureAtPixel_(evt.pixel)\r\n    var feature = sel.feature\r\n    if (this.selection_.getLength()\r\n      && this.selection_.getArray().indexOf(feature) >= 0\r\n      && ((this.ispt_ && this.get('translate')) || this.get('translateFeature'))) {\r\n      sel.handle = 'translate'\r\n    }\r\n    if (sel.handle) {\r\n      this.mode_ = sel.handle\r\n      this.opt_ = sel.option\r\n      this.constraint_ = sel.constraint\r\n      // Save info\r\n      var viewRotation = this.getMap().getView().getRotation()\r\n      // Get coordinate of the handle (for snapping)\r\n      this.coordinate_ = feature.get('handle') ? feature.getGeometry().getCoordinates() : evt.coordinate;\r\n      this.pixel_ = this.getMap().getCoordinateFromPixel(this.coordinate_) // evt.pixel;\r\n      this.geoms_ = []\r\n      this.rotatedGeoms_ = []\r\n      var extent = ol_extent_createEmpty()\r\n      var rotExtent = ol_extent_createEmpty()\r\n      for (var i = 0, f; f = this.selection_.item(i); i++) {\r\n        this.geoms_.push(f.getGeometry().clone())\r\n        extent = ol_extent_extend(extent, f.getGeometry().getExtent())\r\n        if (this.get('enableRotatedTransform') && viewRotation !== 0) {\r\n          var rotGeom = this.getGeometryRotateToZero_(f, true)\r\n          this.rotatedGeoms_.push(rotGeom)\r\n          rotExtent = ol_extent_extend(rotExtent, rotGeom.getExtent())\r\n        }\r\n      }\r\n      this.extent_ = (ol_geom_Polygon_fromExtent(extent)).getCoordinates()[0]\r\n      if (this.get('enableRotatedTransform') && viewRotation !== 0) {\r\n        this.rotatedExtent_ = (ol_geom_Polygon_fromExtent(rotExtent)).getCoordinates()[0]\r\n      }\r\n      if (this.mode_ === 'rotate') {\r\n        this.center_ = this.getCenter() || ol_extent_getCenter(extent)\r\n        // we are now rotating (cursor down on rotate mode), so apply the grabbing cursor\r\n        var element = evt.map.getTargetElement()\r\n        ol_ext_element.setCursor(element, this.Cursors.rotate0)\r\n        this.previousCursor_ = element.style.cursor\r\n      } else {\r\n        this.center_ = ol_extent_getCenter(extent)\r\n      }\r\n      this.angle_ = Math.atan2(this.center_[1] - evt.coordinate[1], this.center_[0] - evt.coordinate[0])\r\n\r\n      this.dispatchEvent({\r\n        type: this.mode_ + 'start',\r\n        feature: this.selection_.item(0),\r\n        features: this.selection_,\r\n        pixel: evt.pixel,\r\n        coordinate: evt.coordinate\r\n      })\r\n      return true\r\n    }\r\n    else if (this.get('selection')) {\r\n      if (feature) {\r\n        if (!this.addFn_(evt))\r\n          this.selection_.clear()\r\n        var index = this.selection_.getArray().indexOf(feature)\r\n        if (index < 0)\r\n          this.selection_.push(feature)\r\n        else\r\n          this.selection_.removeAt(index)\r\n      } else {\r\n        this.selection_.clear()\r\n      }\r\n      this.ispt_ = this.selection_.getLength() === 1 ? (this.selection_.item(0).getGeometry().getType() == \"Point\") : false\r\n      this.iscircle_ = (this.selection_.getLength() === 1 ? (this.selection_.item(0).getGeometry().getType() == \"Circle\") : false)\r\n      this.drawSketch_()\r\n      this.watchFeatures_()\r\n      this.dispatchEvent({ type: 'select', feature: feature, features: this.selection_, pixel: evt.pixel, coordinate: evt.coordinate })\r\n      return false\r\n    }\r\n  }\r\n  /**\r\n   * Get the rotation center\r\n   * @return {ol.coordinate|undefined}\r\n   */\r\n  getCenter() {\r\n    return this.get('center')\r\n  }\r\n  /**\r\n   * Set the rotation center\r\n   * @param {ol.coordinate|undefined} c the center point, default center on the objet\r\n   */\r\n  setCenter(c) {\r\n    return this.set('center', c)\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} evt Map browser event.\r\n   * @private\r\n   */\r\n  handleDragEvent_(evt) {\r\n    if (!this._handleEvent(evt, this.features_))\r\n      return\r\n    var viewRotation = this.getMap().getView().getRotation()\r\n    var i, j, f, geometry\r\n    var pt0 = [this.coordinate_[0], this.coordinate_[1]]\r\n    var pt = [evt.coordinate[0], evt.coordinate[1]]\r\n    this.isUpdating_ = true\r\n    switch (this.mode_) {\r\n      case 'rotate': {\r\n        var a = Math.atan2(this.center_[1] - pt[1], this.center_[0] - pt[0])\r\n        if (!this.ispt) {\r\n          // var geometry = this.geom_.clone();\r\n          // geometry.rotate(a-this.angle_, this.center_);\r\n          // this.feature_.setGeometry(geometry);\r\n          for (i = 0, f; f = this.selection_.item(i); i++) {\r\n            geometry = this.geoms_[i].clone()\r\n            geometry.rotate(a - this.angle_, this.center_)\r\n            // bug: ol, bad calculation circle geom extent\r\n            if (geometry.getType() == 'Circle')\r\n              geometry.setCenterAndRadius(geometry.getCenter(), geometry.getRadius())\r\n            f.setGeometry(geometry)\r\n          }\r\n        }\r\n        this.drawSketch_(true)\r\n        this.dispatchEvent({\r\n          type: 'rotating',\r\n          feature: this.selection_.item(0),\r\n          features: this.selection_,\r\n          angle: a - this.angle_,\r\n          pixel: evt.pixel,\r\n          coordinate: evt.coordinate\r\n        })\r\n        break\r\n      }\r\n      case 'translate': {\r\n        var deltaX = pt[0] - pt0[0]\r\n        var deltaY = pt[1] - pt0[1]\r\n\r\n        //this.feature_.getGeometry().translate(deltaX, deltaY);\r\n        for (i = 0, f; f = this.selection_.item(i); i++) {\r\n          f.getGeometry().translate(deltaX, deltaY)\r\n        }\r\n        this.handles_.forEach(function (f) {\r\n          f.getGeometry().translate(deltaX, deltaY)\r\n        })\r\n\r\n        this.coordinate_ = evt.coordinate\r\n        this.dispatchEvent({\r\n          type: 'translating',\r\n          feature: this.selection_.item(0),\r\n          features: this.selection_,\r\n          delta: [deltaX, deltaY],\r\n          pixel: evt.pixel,\r\n          coordinate: evt.coordinate\r\n        })\r\n        break\r\n      }\r\n      case 'scale': {\r\n        var center = this.center_\r\n        if (this.get('modifyCenter')(evt)) {\r\n          var extentCoordinates = this.extent_\r\n          if (this.get('enableRotatedTransform') && viewRotation !== 0) {\r\n            extentCoordinates = this.rotatedExtent_\r\n          }\r\n          center = extentCoordinates[(Number(this.opt_) + 2) % 4]\r\n        }\r\n        var keepRectangle = (this.geoms_.length == 1 && this._isRectangle(this.geoms_[0]))\r\n        var stretch = this.constraint_\r\n        var opt = this.opt_\r\n\r\n        var downCoordinate = this.coordinate_\r\n        var dragCoordinate = evt.coordinate\r\n        if (this.get('enableRotatedTransform') && viewRotation !== 0) {\r\n          var downPoint = new ol_geom_Point(this.coordinate_)\r\n          downPoint.rotate(viewRotation * -1, center)\r\n          downCoordinate = downPoint.getCoordinates()\r\n\r\n          var dragPoint = new ol_geom_Point(evt.coordinate)\r\n          dragPoint.rotate(viewRotation * -1, center)\r\n          dragCoordinate = dragPoint.getCoordinates()\r\n        }\r\n\r\n        var scx = ((dragCoordinate)[0] - (center)[0]) / (downCoordinate[0] - (center)[0])\r\n        var scy = ((dragCoordinate)[1] - (center)[1]) / (downCoordinate[1] - (center)[1])\r\n        var displacementVector = [dragCoordinate[0] - downCoordinate[0], (dragCoordinate)[1] - downCoordinate[1]]\r\n\r\n        if (this.get('enableRotatedTransform') && viewRotation !== 0) {\r\n          var centerPoint = new ol_geom_Point(center)\r\n          centerPoint.rotate(viewRotation * -1, this.getMap().getView().getCenter())\r\n          center = centerPoint.getCoordinates()\r\n        }\r\n\r\n        if (this.get('noFlip')) {\r\n          if (scx < 0)\r\n            scx = -scx\r\n          if (scy < 0)\r\n            scy = -scy\r\n        }\r\n\r\n        if (this.constraint_) {\r\n          if (this.constraint_ == \"h\")\r\n            scx = 1\r\n          else\r\n            scy = 1\r\n        } else {\r\n          if (this.get('keepAspectRatio')(evt)) {\r\n            scx = scy = Math.min(scx, scy)\r\n          }\r\n        }\r\n\r\n        for (i = 0, f; f = this.selection_.item(i); i++) {\r\n          geometry = (viewRotation === 0 || !this.get('enableRotatedTransform')) ? this.geoms_[i].clone() : this.rotatedGeoms_[i].clone()\r\n          geometry.applyTransform(function (g1, g2, dim) {\r\n            if (dim < 2) return g2\r\n\r\n            if (!keepRectangle) {\r\n              for (j = 0; j < g1.length; j += dim) {\r\n                if (scx != 1)\r\n                  g2[j] = center[0] + (g1[j] - center[0]) * scx\r\n                if (scy != 1)\r\n                  g2[j + 1] = center[1] + (g1[j + 1] - center[1]) * scy\r\n              }\r\n            } else {\r\n              var pointArray = [[6], [0, 8], [2], [4]]\r\n              var pointA = [g1[0], g1[1]]\r\n              var pointB = [g1[2], g1[3]]\r\n              var pointC = [g1[4], g1[5]]\r\n              var pointD = [g1[6], g1[7]]\r\n              var pointA1 = [g1[8], g1[9]]\r\n\r\n              if (stretch) {\r\n                var base = (opt % 2 === 0) ? this._countVector(pointA, pointB) : this._countVector(pointD, pointA)\r\n                var projectedVector = this._projectVectorOnVector(displacementVector, base)\r\n                var nextIndex = opt + 1 < pointArray.length ? opt + 1 : 0\r\n                var coordsToChange = [...pointArray[opt], ...pointArray[nextIndex]]\r\n\r\n                for (j = 0; j < g1.length; j += dim) {\r\n                  g2[j] = coordsToChange.includes(j) ? g1[j] + projectedVector[0] : g1[j]\r\n                  g2[j + 1] = coordsToChange.includes(j) ? g1[j + 1] + projectedVector[1] : g1[j + 1]\r\n                }\r\n              } else {\r\n                var projectedLeft, projectedRight\r\n                switch (opt) {\r\n                  case 0:\r\n                    displacementVector = this._countVector(pointD, dragCoordinate)\r\n                    projectedLeft = this._projectVectorOnVector(displacementVector, this._countVector(pointC, pointD))\r\n                    projectedRight = this._projectVectorOnVector(displacementVector, this._countVector(pointA, pointD));\r\n                    [g2[0], g2[1]] = this._movePoint(pointA, projectedLeft);\r\n                    [g2[4], g2[5]] = this._movePoint(pointC, projectedRight);\r\n                    [g2[6], g2[7]] = this._movePoint(pointD, displacementVector);\r\n                    [g2[8], g2[9]] = this._movePoint(pointA1, projectedLeft)\r\n                    break\r\n                  case 1:\r\n                    displacementVector = this._countVector(pointA, dragCoordinate)\r\n                    projectedLeft = this._projectVectorOnVector(displacementVector, this._countVector(pointD, pointA))\r\n                    projectedRight = this._projectVectorOnVector(displacementVector, this._countVector(pointB, pointA));\r\n                    [g2[0], g2[1]] = this._movePoint(pointA, displacementVector);\r\n                    [g2[2], g2[3]] = this._movePoint(pointB, projectedLeft);\r\n                    [g2[6], g2[7]] = this._movePoint(pointD, projectedRight);\r\n                    [g2[8], g2[9]] = this._movePoint(pointA1, displacementVector)\r\n                    break\r\n                  case 2:\r\n                    displacementVector = this._countVector(pointB, dragCoordinate)\r\n                    projectedLeft = this._projectVectorOnVector(displacementVector, this._countVector(pointA, pointB))\r\n                    projectedRight = this._projectVectorOnVector(displacementVector, this._countVector(pointC, pointB));\r\n                    [g2[0], g2[1]] = this._movePoint(pointA, projectedRight);\r\n                    [g2[2], g2[3]] = this._movePoint(pointB, displacementVector);\r\n                    [g2[4], g2[5]] = this._movePoint(pointC, projectedLeft);\r\n                    [g2[8], g2[9]] = this._movePoint(pointA1, projectedRight)\r\n                    break\r\n                  case 3:\r\n                    displacementVector = this._countVector(pointC, dragCoordinate)\r\n                    projectedLeft = this._projectVectorOnVector(displacementVector, this._countVector(pointB, pointC))\r\n                    projectedRight = this._projectVectorOnVector(displacementVector, this._countVector(pointD, pointC));\r\n                    [g2[2], g2[3]] = this._movePoint(pointB, projectedRight);\r\n                    [g2[4], g2[5]] = this._movePoint(pointC, displacementVector);\r\n                    [g2[6], g2[7]] = this._movePoint(pointD, projectedLeft)\r\n                    break\r\n                }\r\n              }\r\n            }\r\n\r\n            // bug: ol, bad calculation circle geom extent\r\n            if (geometry.getType() == 'Circle') geometry.setCenterAndRadius(geometry.getCenter(), geometry.getRadius())\r\n            return g2\r\n          }.bind(this))\r\n          if (this.get('enableRotatedTransform') && viewRotation !== 0) {\r\n            //geometry.rotate(viewRotation, rotationCenter);\r\n            geometry.rotate(viewRotation, this.getMap().getView().getCenter())\r\n          }\r\n          f.setGeometry(geometry)\r\n        }\r\n        this.drawSketch_()\r\n        this.dispatchEvent({\r\n          type: 'scaling',\r\n          feature: this.selection_.item(0),\r\n          features: this.selection_,\r\n          scale: [scx, scy],\r\n          pixel: evt.pixel,\r\n          coordinate: evt.coordinate\r\n        })\r\n        break\r\n      }\r\n      default: break\r\n    }\r\n    this.isUpdating_ = false\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} evt Event.\r\n   * @private\r\n   */\r\n  handleMoveEvent_(evt) {\r\n    if (!this._handleEvent(evt, this.features_))\r\n      return\r\n    // console.log(\"handleMoveEvent\");\r\n    if (!this.mode_) {\r\n      var sel = this.getFeatureAtPixel_(evt.pixel)\r\n      var element = evt.map.getTargetElement()\r\n      if (sel.feature) {\r\n        var c = sel.handle ? this.Cursors[(sel.handle || 'default') + (sel.constraint || '') + (sel.option || '')] : this.Cursors.select\r\n\r\n        if (this.previousCursor_ === undefined) {\r\n          this.previousCursor_ = element.style.cursor\r\n        }\r\n        ol_ext_element.setCursor(element, c);\r\n      } else {\r\n        if (this.previousCursor_ !== undefined) {\r\n          ol_ext_element.setCursor(element, this.previousCursor_)\r\n        }\r\n        this.previousCursor_ = undefined\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} evt Map browser event.\r\n   * @return {boolean} `false` to stop the drag sequence.\r\n   */\r\n  handleUpEvent_(evt) {\r\n    // remove rotate0 cursor on Up event, otherwise it's stuck on grab/grabbing\r\n    if (this.mode_ === 'rotate') {\r\n      var element = evt.map.getTargetElement()\r\n      ol_ext_element.setCursor(element, this.Cursors.default)\r\n      this.previousCursor_ = undefined\r\n    }\r\n\r\n    //dispatchEvent\r\n    this.dispatchEvent({\r\n      type: this.mode_ + 'end',\r\n      feature: this.selection_.item(0),\r\n      features: this.selection_,\r\n      oldgeom: this.geoms_[0],\r\n      oldgeoms: this.geoms_\r\n    })\r\n\r\n    this.drawSketch_()\r\n    this.mode_ = null\r\n    return false\r\n  }\r\n  /** Set the point radius to calculate handles on points\r\n   *  @param {number|Array<number>|function} [pointRadius=0] radius for points or a function that takes a feature and returns the radius (or [radiusX, radiusY]). If not null show handles to transform the points\r\n   */\r\n  setPointRadius(pointRadius) {\r\n    if (typeof (pointRadius) === 'function') {\r\n      this._pointRadius = pointRadius\r\n    } else {\r\n      this._pointRadius = function () { return pointRadius }\r\n    }\r\n  }\r\n  /** Get the features that are selected for transform\r\n   * @return ol.Collection\r\n   */\r\n  getFeatures() {\r\n    return this.selection_;\r\n  }\r\n  /**\r\n   * @private\r\n   */\r\n  _projectVectorOnVector(displacement_vector, base) {\r\n    var k = (displacement_vector[0] * base[0] + displacement_vector[1] * base[1]) / (base[0] * base[0] + base[1] * base[1]);\r\n    return [base[0] * k, base[1] * k];\r\n  }\r\n  /**\r\n   * @private\r\n   */\r\n  _countVector(start, end) {\r\n    return [end[0] - start[0], end[1] - start[1]];\r\n  }\r\n  /**\r\n   * @private\r\n   */\r\n  _movePoint(point, displacementVector) {\r\n    return [point[0]+displacementVector[0], point[1]+displacementVector[1]];\r\n  }\r\n  \r\n  \r\n}\r\n\r\n/** Cursors for transform\r\n*/\r\nol_interaction_Transform.prototype.Cursors = {\r\n  'default': 'auto',\r\n  'select': 'pointer',\r\n  'translate': 'move',\r\n  'rotate': 'move',\r\n  'rotate0': 'move',\r\n  'scale': 'nesw-resize',\r\n  'scale1': 'nwse-resize',\r\n  'scale2': 'nesw-resize',\r\n  'scale3': 'nwse-resize',\r\n  'scalev': 'ew-resize',\r\n  'scaleh1': 'ns-resize',\r\n  'scalev2': 'ew-resize',\r\n  'scaleh3': 'ns-resize'\r\n};\r\n\r\nexport default ol_interaction_Transform\r\n","/*\tCopyright (c) 2016 Jean-Marc VIGLINO, \r\n\treleased under the CeCILL-B license (French BSD license)\r\n\t(http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).\r\n*/\r\nimport ol_interaction_Pointer from 'ol/interaction/Pointer.js'\r\nimport ol_geom_LineString from 'ol/geom/LineString.js'\r\nimport ol_geom_Polygon from 'ol/geom/Polygon.js'\r\nimport {ol_coordinate_dist2d, ol_coordinate_findSegment, ol_coordinate_offsetCoords} from \"../geom/GeomUtils.js\";\r\n\r\nimport ol_style_Style_defaultStyle from '../style/defaultStyle.js'\r\nimport ol_ext_element from '../util/element.js';\r\n\r\n/** Offset interaction for offseting feature geometry\r\n * @constructor\r\n * @extends {ol_interaction_Pointer}\r\n * @fires offsetstart\r\n * @fires offsetting\r\n * @fires offsetend\r\n * @param {any} options\r\n *\t@param {function} [options.filter] a function that takes a feature and a layer and return true if the feature can be modified\r\n *\t@param {ol.layer.Vector | Array<ol.layer.Vector>} options.layers list of feature to transform \r\n *\t@param {ol.Collection.<ol.Feature>} options.features collection of feature to transform\r\n *\t@param {ol.source.Vector | undefined} options.source source to duplicate feature when ctrl key is down\r\n *\t@param {boolean} options.duplicate force feature to duplicate (source must be set)\r\n *  @param {ol.style.Style | Array.<ol.style.Style> | ol.style.StyleFunction | undefined} style style for the sketch\r\n */\r\nvar ol_interaction_Offset = class olinteractionOffset extends ol_interaction_Pointer {\r\n  constructor(options) {\r\n    options = options || {};\r\n\r\n    // Extend pointer\r\n    super({\r\n      handleDownEvent: function(e) { return self.handleDownEvent_(e) },\r\n      handleDragEvent: function(e) { return self.handleDragEvent_(e) },\r\n      handleMoveEvent: function(e) { return self.handleMoveEvent_(e) },\r\n      handleUpEvent: function(e) { return self.handleUpEvent_(e) },\r\n    });\r\n    var self = this;\r\n\r\n    this._filter = options.filter;\r\n    // Collection of feature to transform\r\n    this.features_ = options.features;\r\n    // List of layers to transform\r\n    this.layers_ = options.layers ? (options.layers instanceof Array) ? options.layers : [options.layers] : null;\r\n    // duplicate\r\n    this.set('duplicate', options.duplicate);\r\n    this.source_ = options.source;\r\n    // Style\r\n    this._style = (typeof (options.style) === 'function') ? options.style : function () {\r\n      if (options.style)\r\n        return options.style;\r\n      else\r\n        return ol_style_Style_defaultStyle(true);\r\n    };\r\n\r\n    // init\r\n    this.previousCursor_ = false;\r\n  }\r\n  /** Get Feature at pixel\r\n   * @param {ol.MapBrowserEvent} evt Map browser event.\r\n   * @return {any} a feature and the hit point\r\n   * @private\r\n   */\r\n  getFeatureAtPixel_(e) {\r\n    var self = this;\r\n    return this.getMap().forEachFeatureAtPixel(e.pixel,\r\n      function (feature, layer) {\r\n        var current;\r\n        if (self._filter && !self._filter(feature, layer))\r\n          return false;\r\n        // feature belong to a layer\r\n        if (self.layers_) {\r\n          for (var i = 0; i < self.layers_.length; i++) {\r\n            if (self.layers_[i] === layer) {\r\n              current = feature;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n\r\n        // feature in the collection\r\n        else if (self.features_) {\r\n          self.features_.forEach(function (f) {\r\n            if (f === feature) {\r\n              current = feature;\r\n            }\r\n          });\r\n        }\r\n\r\n        // Others\r\n        else {\r\n          current = feature;\r\n        }\r\n\r\n        // Only poygon or linestring\r\n        var typeGeom = current.getGeometry().getType();\r\n        if (current && /Polygon|LineString/.test(typeGeom)) {\r\n          if (typeGeom === 'Polygon' && current.getGeometry().getCoordinates().length > 1)\r\n            return false;\r\n          // test distance\r\n          var p = current.getGeometry().getClosestPoint(e.coordinate);\r\n          var dx = p[0] - e.coordinate[0];\r\n          var dy = p[1] - e.coordinate[1];\r\n          var d = Math.sqrt(dx * dx + dy * dy) / e.frameState.viewState.resolution;\r\n\r\n          if (d < 5) {\r\n            return {\r\n              feature: current,\r\n              hit: p,\r\n              coordinates: current.getGeometry().getCoordinates(),\r\n              geom: current.getGeometry().clone(),\r\n              geomType: typeGeom\r\n            };\r\n          } else {\r\n            return false;\r\n          }\r\n        } else {\r\n          return false;\r\n        }\r\n      }, { hitTolerance: 5 });\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} e Map browser event.\r\n   * @return {boolean} `true` to start the drag sequence.\r\n   * @private\r\n   */\r\n  handleDownEvent_(e) {\r\n    this.current_ = this.getFeatureAtPixel_(e);\r\n    if (this.current_) {\r\n      this.currentStyle_ = this.current_.feature.getStyle();\r\n      if (this.source_ && (this.get('duplicate') || e.originalEvent.ctrlKey)) {\r\n        this.current_.feature = this.current_.feature.clone();\r\n        this.current_.feature.setStyle(this._style(this.current_.feature));\r\n        this.source_.addFeature(this.current_.feature);\r\n      } else {\r\n        // Modify the current feature\r\n        this.current_.feature.setStyle(this._style(this.current_.feature));\r\n        this._modifystart = true;\r\n      }\r\n      this.dispatchEvent({ type: 'offsetstart', feature: this.current_.feature, offset: 0 });\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} e Map browser event.\r\n   * @private\r\n   */\r\n  handleDragEvent_(e) {\r\n    if (this._modifystart) {\r\n      this.dispatchEvent({ type: 'modifystart', features: [this.current_.feature] });\r\n      this._modifystart = false;\r\n    }\r\n    var p = this.current_.geom.getClosestPoint(e.coordinate);\r\n    var d = ol_coordinate_dist2d(p, e.coordinate);\r\n    var seg, v1, v2, offset;\r\n    switch (this.current_.geomType) {\r\n      case 'Polygon': {\r\n        seg = ol_coordinate_findSegment(p, this.current_.coordinates[0]).segment;\r\n        if (seg) {\r\n          v1 = [seg[1][0] - seg[0][0], seg[1][1] - seg[0][1]];\r\n          v2 = [e.coordinate[0] - p[0], e.coordinate[1] - p[1]];\r\n          if (v1[0] * v2[1] - v1[1] * v2[0] > 0) {\r\n            d = -d;\r\n          }\r\n\r\n          offset = [];\r\n          for (var i = 0; i < this.current_.coordinates.length; i++) {\r\n            offset.push(ol_coordinate_offsetCoords(this.current_.coordinates[i], i == 0 ? d : -d));\r\n          }\r\n          this.current_.feature.setGeometry(new ol_geom_Polygon(offset));\r\n        }\r\n        break;\r\n      }\r\n      case 'LineString': {\r\n        seg = ol_coordinate_findSegment(p, this.current_.coordinates).segment;\r\n        if (seg) {\r\n          v1 = [seg[1][0] - seg[0][0], seg[1][1] - seg[0][1]];\r\n          v2 = [e.coordinate[0] - p[0], e.coordinate[1] - p[1]];\r\n          if (v1[0] * v2[1] - v1[1] * v2[0] > 0) {\r\n            d = -d;\r\n          }\r\n          offset = ol_coordinate_offsetCoords(this.current_.coordinates, d);\r\n          this.current_.feature.setGeometry(new ol_geom_LineString(offset));\r\n        }\r\n        break;\r\n      }\r\n      default: {\r\n        break;\r\n      }\r\n    }\r\n    this.dispatchEvent({ type: 'offsetting', feature: this.current_.feature, offset: d, segment: [p, e.coordinate], coordinate: e.coordinate });\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} e Map browser event.\r\n   * @private\r\n   */\r\n  handleUpEvent_(e) {\r\n    if (!this._modifystart) {\r\n      this.dispatchEvent({ type: 'offsetend', feature: this.current_.feature, coordinate: e.coordinate });\r\n    }\r\n    this.current_.feature.setStyle(this.currentStyle_);\r\n    this.current_ = false;\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} e Event.\r\n   * @private\r\n   */\r\n  handleMoveEvent_(e) {\r\n    var f = this.getFeatureAtPixel_(e);\r\n    if (f) {\r\n      if (this.previousCursor_ === false) {\r\n        this.previousCursor_ = e.map.getTargetElement().style.cursor;\r\n      }\r\n      ol_ext_element.setCursor(e.map, 'pointer');\r\n    } else {\r\n      ol_ext_element.setCursor(e.map, this.previousCursor_);\r\n      this.previousCursor_ = false;\r\n    }\r\n  }\r\n}\r\n\r\nexport default ol_interaction_Offset\r\n","/**\n * @module ol/interaction/Extent\n */\nimport Event from '../events/Event.js';\nimport Feature from '../Feature.js';\nimport MapBrowserEventType from '../MapBrowserEventType.js';\nimport Point from '../geom/Point.js';\nimport PointerInteraction from './Pointer.js';\nimport VectorLayer from '../layer/Vector.js';\nimport VectorSource from '../source/Vector.js';\nimport {always} from '../events/condition.js';\nimport {boundingExtent, getArea} from '../extent.js';\nimport {\n  closestOnSegment,\n  distance as coordinateDistance,\n  squaredDistance as squaredCoordinateDistance,\n  squaredDistanceToSegment,\n} from '../coordinate.js';\nimport {createEditingStyle} from '../style/Style.js';\nimport {fromExtent as polygonFromExtent} from '../geom/Polygon.js';\nimport {toUserExtent} from '../proj.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * Default is {@link module:ol/events/condition.always}.\n * @property {import(\"../extent.js\").Extent} [extent] Initial extent. Defaults to no\n * initial extent.\n * @property {import(\"../style/Style.js\").StyleLike} [boxStyle]\n * Style for the drawn extent box. Defaults to the `Polygon` editing style\n * documented in {@link module:ol/style/Style~Style}\n * @property {number} [pixelTolerance=10] Pixel tolerance for considering the\n * pointer close enough to a segment or vertex for editing.\n * @property {import(\"../style/Style.js\").StyleLike} [pointerStyle]\n * Style for the cursor used to draw the extent. Defaults to the `Point` editing style\n * documented in {@link module:ol/style/Style~Style}\n * @property {boolean} [wrapX=false] Wrap the drawn extent across multiple maps\n * in the X direction? Only affects visuals, not functionality.\n */\n\n/**\n * @enum {string}\n */\nconst ExtentEventType = {\n  /**\n   * Triggered after the extent is changed\n   * @event ExtentEvent#extentchanged\n   * @api\n   */\n  EXTENTCHANGED: 'extentchanged',\n};\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/Extent~Extent} instances are\n * instances of this type.\n */\nexport class ExtentEvent extends Event {\n  /**\n   * @param {import(\"../extent.js\").Extent} extent the new extent\n   */\n  constructor(extent) {\n    super(ExtentEventType.EXTENTCHANGED);\n\n    /**\n     * The current extent.\n     * @type {import(\"../extent.js\").Extent}\n     * @api\n     */\n    this.extent = extent;\n  }\n}\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'extentchanged', ExtentEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'extentchanged', Return>} ExtentOnSignature\n */\n\n/**\n * @classdesc\n * Allows the user to draw a vector box by clicking and dragging on the map.\n * Once drawn, the vector box can be modified by dragging its vertices or edges.\n * This interaction is only supported for mouse devices.\n *\n * @fires ExtentEvent\n * @api\n */\nclass Extent extends PointerInteraction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options || {};\n\n    super(/** @type {import(\"./Pointer.js\").Options} */ (options));\n\n    /***\n     * @type {ExtentOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {ExtentOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {ExtentOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * Condition\n     * @type {import(\"../events/condition.js\").Condition}\n     * @private\n     */\n    this.condition_ = options.condition ? options.condition : always;\n\n    /**\n     * Extent of the drawn box\n     * @type {import(\"../extent.js\").Extent}\n     * @private\n     */\n    this.extent_ = null;\n\n    /**\n     * Handler for pointer move events\n     * @type {function (import(\"../coordinate.js\").Coordinate): import(\"../extent.js\").Extent|null}\n     * @private\n     */\n    this.pointerHandler_ = null;\n\n    /**\n     * Pixel threshold to snap to extent\n     * @type {number}\n     * @private\n     */\n    this.pixelTolerance_ =\n      options.pixelTolerance !== undefined ? options.pixelTolerance : 10;\n\n    /**\n     * Is the pointer snapped to an extent vertex\n     * @type {boolean}\n     * @private\n     */\n    this.snappedToVertex_ = false;\n\n    /**\n     * Feature for displaying the visible extent\n     * @type {Feature}\n     * @private\n     */\n    this.extentFeature_ = null;\n\n    /**\n     * Feature for displaying the visible pointer\n     * @type {Feature<Point>}\n     * @private\n     */\n    this.vertexFeature_ = null;\n\n    if (!options) {\n      options = {};\n    }\n\n    /**\n     * Layer for the extentFeature\n     * @type {VectorLayer}\n     * @private\n     */\n    this.extentOverlay_ = new VectorLayer({\n      source: new VectorSource({\n        useSpatialIndex: false,\n        wrapX: !!options.wrapX,\n      }),\n      style: options.boxStyle\n        ? options.boxStyle\n        : getDefaultExtentStyleFunction(),\n      updateWhileAnimating: true,\n      updateWhileInteracting: true,\n    });\n\n    /**\n     * Layer for the vertexFeature\n     * @type {VectorLayer}\n     * @private\n     */\n    this.vertexOverlay_ = new VectorLayer({\n      source: new VectorSource({\n        useSpatialIndex: false,\n        wrapX: !!options.wrapX,\n      }),\n      style: options.pointerStyle\n        ? options.pointerStyle\n        : getDefaultPointerStyleFunction(),\n      updateWhileAnimating: true,\n      updateWhileInteracting: true,\n    });\n\n    if (options.extent) {\n      this.setExtent(options.extent);\n    }\n  }\n\n  /**\n   * @param {import(\"../pixel.js\").Pixel} pixel cursor location\n   * @param {import(\"../Map.js\").default} map map\n   * @return {import(\"../coordinate.js\").Coordinate|null} snapped vertex on extent\n   * @private\n   */\n  snapToVertex_(pixel, map) {\n    const pixelCoordinate = map.getCoordinateFromPixelInternal(pixel);\n    const sortByDistance = function (a, b) {\n      return (\n        squaredDistanceToSegment(pixelCoordinate, a) -\n        squaredDistanceToSegment(pixelCoordinate, b)\n      );\n    };\n    const extent = this.getExtentInternal();\n    if (extent) {\n      //convert extents to line segments and find the segment closest to pixelCoordinate\n      const segments = getSegments(extent);\n      segments.sort(sortByDistance);\n      const closestSegment = segments[0];\n\n      let vertex = closestOnSegment(pixelCoordinate, closestSegment);\n      const vertexPixel = map.getPixelFromCoordinateInternal(vertex);\n\n      //if the distance is within tolerance, snap to the segment\n      if (coordinateDistance(pixel, vertexPixel) <= this.pixelTolerance_) {\n        //test if we should further snap to a vertex\n        const pixel1 = map.getPixelFromCoordinateInternal(closestSegment[0]);\n        const pixel2 = map.getPixelFromCoordinateInternal(closestSegment[1]);\n        const squaredDist1 = squaredCoordinateDistance(vertexPixel, pixel1);\n        const squaredDist2 = squaredCoordinateDistance(vertexPixel, pixel2);\n        const dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));\n        this.snappedToVertex_ = dist <= this.pixelTolerance_;\n        if (this.snappedToVertex_) {\n          vertex =\n            squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];\n        }\n        return vertex;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent pointer move event\n   * @private\n   */\n  handlePointerMove_(mapBrowserEvent) {\n    const pixel = mapBrowserEvent.pixel;\n    const map = mapBrowserEvent.map;\n\n    let vertex = this.snapToVertex_(pixel, map);\n    if (!vertex) {\n      vertex = map.getCoordinateFromPixelInternal(pixel);\n    }\n    this.createOrUpdatePointerFeature_(vertex);\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent extent\n   * @return {Feature} extent as featrue\n   * @private\n   */\n  createOrUpdateExtentFeature_(extent) {\n    let extentFeature = this.extentFeature_;\n\n    if (!extentFeature) {\n      if (!extent) {\n        extentFeature = new Feature({});\n      } else {\n        extentFeature = new Feature(polygonFromExtent(extent));\n      }\n      this.extentFeature_ = extentFeature;\n      this.extentOverlay_.getSource().addFeature(extentFeature);\n    } else {\n      if (!extent) {\n        extentFeature.setGeometry(undefined);\n      } else {\n        extentFeature.setGeometry(polygonFromExtent(extent));\n      }\n    }\n    return extentFeature;\n  }\n\n  /**\n   * @param {import(\"../coordinate.js\").Coordinate} vertex location of feature\n   * @return {Feature} vertex as feature\n   * @private\n   */\n  createOrUpdatePointerFeature_(vertex) {\n    let vertexFeature = this.vertexFeature_;\n    if (!vertexFeature) {\n      vertexFeature = new Feature(new Point(vertex));\n      this.vertexFeature_ = vertexFeature;\n      this.vertexOverlay_.getSource().addFeature(vertexFeature);\n    } else {\n      const geometry = vertexFeature.getGeometry();\n      geometry.setCoordinates(vertex);\n    }\n    return vertexFeature;\n  }\n\n  /**\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   */\n  handleEvent(mapBrowserEvent) {\n    if (!mapBrowserEvent.originalEvent || !this.condition_(mapBrowserEvent)) {\n      return true;\n    }\n    //display pointer (if not dragging)\n    if (\n      mapBrowserEvent.type == MapBrowserEventType.POINTERMOVE &&\n      !this.handlingDownUpSequence\n    ) {\n      this.handlePointerMove_(mapBrowserEvent);\n    }\n    //call pointer to determine up/down/drag\n    super.handleEvent(mapBrowserEvent);\n    //return false to stop propagation\n    return false;\n  }\n\n  /**\n   * Handle pointer down events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleDownEvent(mapBrowserEvent) {\n    const pixel = mapBrowserEvent.pixel;\n    const map = mapBrowserEvent.map;\n\n    const extent = this.getExtentInternal();\n    let vertex = this.snapToVertex_(pixel, map);\n\n    //find the extent corner opposite the passed corner\n    const getOpposingPoint = function (point) {\n      let x_ = null;\n      let y_ = null;\n      if (point[0] == extent[0]) {\n        x_ = extent[2];\n      } else if (point[0] == extent[2]) {\n        x_ = extent[0];\n      }\n      if (point[1] == extent[1]) {\n        y_ = extent[3];\n      } else if (point[1] == extent[3]) {\n        y_ = extent[1];\n      }\n      if (x_ !== null && y_ !== null) {\n        return [x_, y_];\n      }\n      return null;\n    };\n    if (vertex && extent) {\n      const x =\n        vertex[0] == extent[0] || vertex[0] == extent[2] ? vertex[0] : null;\n      const y =\n        vertex[1] == extent[1] || vertex[1] == extent[3] ? vertex[1] : null;\n\n      //snap to point\n      if (x !== null && y !== null) {\n        this.pointerHandler_ = getPointHandler(getOpposingPoint(vertex));\n        //snap to edge\n      } else if (x !== null) {\n        this.pointerHandler_ = getEdgeHandler(\n          getOpposingPoint([x, extent[1]]),\n          getOpposingPoint([x, extent[3]]),\n        );\n      } else if (y !== null) {\n        this.pointerHandler_ = getEdgeHandler(\n          getOpposingPoint([extent[0], y]),\n          getOpposingPoint([extent[2], y]),\n        );\n      }\n      //no snap - new bbox\n    } else {\n      vertex = map.getCoordinateFromPixelInternal(pixel);\n      this.setExtent([vertex[0], vertex[1], vertex[0], vertex[1]]);\n      this.pointerHandler_ = getPointHandler(vertex);\n    }\n    return true; //event handled; start downup sequence\n  }\n\n  /**\n   * Handle pointer drag events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   */\n  handleDragEvent(mapBrowserEvent) {\n    if (this.pointerHandler_) {\n      const pixelCoordinate = mapBrowserEvent.coordinate;\n      this.setExtent(this.pointerHandler_(pixelCoordinate));\n      this.createOrUpdatePointerFeature_(pixelCoordinate);\n    }\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleUpEvent(mapBrowserEvent) {\n    this.pointerHandler_ = null;\n    //If bbox is zero area, set to null;\n    const extent = this.getExtentInternal();\n    if (!extent || getArea(extent) === 0) {\n      this.setExtent(null);\n    }\n    return false; //Stop handling downup sequence\n  }\n\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../Map.js\").default} map Map.\n   */\n  setMap(map) {\n    this.extentOverlay_.setMap(map);\n    this.vertexOverlay_.setMap(map);\n    super.setMap(map);\n  }\n\n  /**\n   * Returns the current drawn extent in the view projection (or user projection if set)\n   *\n   * @return {import(\"../extent.js\").Extent} Drawn extent in the view projection.\n   * @api\n   */\n  getExtent() {\n    return toUserExtent(\n      this.getExtentInternal(),\n      this.getMap().getView().getProjection(),\n    );\n  }\n\n  /**\n   * Returns the current drawn extent in the view projection\n   *\n   * @return {import(\"../extent.js\").Extent} Drawn extent in the view projection.\n   * @api\n   */\n  getExtentInternal() {\n    return this.extent_;\n  }\n\n  /**\n   * Manually sets the drawn extent, using the view projection.\n   *\n   * @param {import(\"../extent.js\").Extent} extent Extent\n   * @api\n   */\n  setExtent(extent) {\n    //Null extent means no bbox\n    this.extent_ = extent ? extent : null;\n    this.createOrUpdateExtentFeature_(extent);\n    this.dispatchEvent(new ExtentEvent(this.extent_));\n  }\n}\n\n/**\n * Returns the default style for the drawn bbox\n *\n * @return {import(\"../style/Style.js\").StyleFunction} Default Extent style\n */\nfunction getDefaultExtentStyleFunction() {\n  const style = createEditingStyle();\n  return function (feature, resolution) {\n    return style['Polygon'];\n  };\n}\n\n/**\n * Returns the default style for the pointer\n *\n * @return {import(\"../style/Style.js\").StyleFunction} Default pointer style\n */\nfunction getDefaultPointerStyleFunction() {\n  const style = createEditingStyle();\n  return function (feature, resolution) {\n    return style['Point'];\n  };\n}\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} fixedPoint corner that will be unchanged in the new extent\n * @return {function (import(\"../coordinate.js\").Coordinate): import(\"../extent.js\").Extent} event handler\n */\nfunction getPointHandler(fixedPoint) {\n  return function (point) {\n    return boundingExtent([fixedPoint, point]);\n  };\n}\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} fixedP1 first corner that will be unchanged in the new extent\n * @param {import(\"../coordinate.js\").Coordinate} fixedP2 second corner that will be unchanged in the new extent\n * @return {function (import(\"../coordinate.js\").Coordinate): import(\"../extent.js\").Extent|null} event handler\n */\nfunction getEdgeHandler(fixedP1, fixedP2) {\n  if (fixedP1[0] == fixedP2[0]) {\n    return function (point) {\n      return boundingExtent([fixedP1, [point[0], fixedP2[1]]]);\n    };\n  }\n  if (fixedP1[1] == fixedP2[1]) {\n    return function (point) {\n      return boundingExtent([fixedP1, [fixedP2[0], point[1]]]);\n    };\n  }\n  return null;\n}\n\n/**\n * @param {import(\"../extent.js\").Extent} extent extent\n * @return {Array<Array<import(\"../coordinate.js\").Coordinate>>} extent line segments\n */\nfunction getSegments(extent) {\n  return [\n    [\n      [extent[0], extent[1]],\n      [extent[0], extent[3]],\n    ],\n    [\n      [extent[0], extent[3]],\n      [extent[2], extent[3]],\n    ],\n    [\n      [extent[2], extent[3]],\n      [extent[2], extent[1]],\n    ],\n    [\n      [extent[2], extent[1]],\n      [extent[0], extent[1]],\n    ],\n  ];\n}\n\nexport default Extent;\n","/**\n * @module ol/events/SnapEvent\n */\nimport Event from './Event.js';\n\n/**\n * @enum {string}\n */\nexport const SnapEventType = {\n  /**\n   * Triggered upon snapping to vertex or edge\n   * @event SnapEvent#snap\n   * @api\n   */\n  SNAP: 'snap',\n};\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/Snap~Snap} instances are instances of this\n */\nexport class SnapEvent extends Event {\n  /**\n   * @param {SnapEventType} type Type.\n   * @param {Object} options Options.\n   * @param {import(\"../coordinate.js\").Coordinate} options.vertex The snapped vertex.\n   * @param {import(\"../coordinate.js\").Coordinate} options.vertexPixel The pixel of the snapped vertex.\n   * @param {import(\"../Feature.js\").default} options.feature The feature being snapped.\n   * @param {Array<import(\"../coordinate.js\").Coordinate>|null} options.segment Segment, or `null` if snapped to a vertex.\n   */\n  constructor(type, options) {\n    super(type);\n    /**\n     * The Map coordinate of the snapped point.\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @api\n     */\n    this.vertex = options.vertex;\n    /**\n     * The Map pixel of the snapped point.\n     * @type {Array<number>&Array<number>}\n     * @api\n     */\n    this.vertexPixel = options.vertexPixel;\n    /**\n     * The feature closest to the snapped point.\n     * @type {import(\"../Feature.js\").default<import(\"../geom/Geometry.js\").default>}\n     * @api\n     */\n    this.feature = options.feature;\n    /**\n     * The segment closest to the snapped point, if snapped to a segment.\n     * @type {Array<import(\"../coordinate.js\").Coordinate>|null}\n     * @api\n     */\n    this.segment = options.segment;\n  }\n}\n","/**\n * @module ol/interaction/Snap\n */\nimport CollectionEventType from '../CollectionEventType.js';\nimport EventType from '../events/EventType.js';\nimport PointerInteraction from './Pointer.js';\nimport RBush from '../structs/RBush.js';\nimport VectorEventType from '../source/VectorEventType.js';\nimport {FALSE, TRUE} from '../functions.js';\nimport {SnapEvent, SnapEventType} from '../events/SnapEvent.js';\nimport {boundingExtent, buffer, createEmpty} from '../extent.js';\nimport {\n  closestOnCircle,\n  closestOnSegment,\n  squaredDistance,\n} from '../coordinate.js';\nimport {fromCircle} from '../geom/Polygon.js';\nimport {\n  fromUserCoordinate,\n  getUserProjection,\n  toUserCoordinate,\n  toUserExtent,\n} from '../proj.js';\nimport {getUid} from '../util.js';\nimport {listen, unlistenByKey} from '../events.js';\n\n/**\n * @typedef {Object} Result\n * @property {import(\"../coordinate.js\").Coordinate|null} vertex Vertex.\n * @property {import(\"../pixel.js\").Pixel|null} vertexPixel VertexPixel.\n * @property {import(\"../Feature.js\").default|null} feature Feature.\n * @property {Array<import(\"../coordinate.js\").Coordinate>|null} segment Segment, or `null` if snapped to a vertex.\n */\n\n/**\n * @typedef {Object} SegmentData\n * @property {import(\"../Feature.js\").default} feature Feature.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} segment Segment.\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../Collection.js\").default<import(\"../Feature.js\").default>} [features] Snap to these features. Either this option or source should be provided.\n * @property {boolean} [edge=true] Snap to edges.\n * @property {boolean} [vertex=true] Snap to vertices.\n * @property {number} [pixelTolerance=10] Pixel tolerance for considering the pointer close enough to a segment or\n * vertex for snapping.\n * @property {import(\"../source/Vector.js\").default} [source] Snap to features from this source. Either this option or features should be provided\n */\n\n/**\n * @param  {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} evt Event.\n * @return {import(\"../Feature.js\").default|null} Feature.\n */\nfunction getFeatureFromEvent(evt) {\n  if (\n    /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */ (evt).feature\n  ) {\n    return /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */ (evt)\n      .feature;\n  }\n  if (\n    /** @type {import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} */ (\n      evt\n    ).element\n  ) {\n    return /** @type {import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} */ (\n      evt\n    ).element;\n  }\n  return null;\n}\n\nconst tempSegment = [];\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'snap', SnapEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'snap', Return>} SnapOnSignature\n */\n\n/**\n * @classdesc\n * Handles snapping of vector features while modifying or drawing them.  The\n * features can come from a {@link module:ol/source/Vector~VectorSource} or {@link module:ol/Collection~Collection}\n * Any interaction object that allows the user to interact\n * with the features using the mouse can benefit from the snapping, as long\n * as it is added before.\n *\n * The snap interaction modifies map browser event `coordinate` and `pixel`\n * properties to force the snap to occur to any interaction that them.\n *\n * Example:\n *\n *     import Snap from 'ol/interaction/Snap.js';\n *\n *     const snap = new Snap({\n *       source: source\n *     });\n *\n *     map.addInteraction(snap);\n *\n * @fires SnapEvent\n * @api\n */\nclass Snap extends PointerInteraction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const pointerOptions = /** @type {import(\"./Pointer.js\").Options} */ (\n      options\n    );\n\n    if (!pointerOptions.handleDownEvent) {\n      pointerOptions.handleDownEvent = TRUE;\n    }\n\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n\n    super(pointerOptions);\n\n    /***\n     * @type {SnapOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {SnapOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {SnapOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @type {import(\"../source/Vector.js\").default|null}\n     * @private\n     */\n    this.source_ = options.source ? options.source : null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.vertex_ = options.vertex !== undefined ? options.vertex : true;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.edge_ = options.edge !== undefined ? options.edge : true;\n\n    /**\n     * @type {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|null}\n     * @private\n     */\n    this.features_ = options.features ? options.features : null;\n\n    /**\n     * @type {Array<import(\"../events.js\").EventsKey>}\n     * @private\n     */\n    this.featuresListenerKeys_ = [];\n\n    /**\n     * @type {Object<string, import(\"../events.js\").EventsKey>}\n     * @private\n     */\n    this.featureChangeListenerKeys_ = {};\n\n    /**\n     * Extents are preserved so indexed segment can be quickly removed\n     * when its feature geometry changes\n     * @type {Object<string, import(\"../extent.js\").Extent>}\n     * @private\n     */\n    this.indexedFeaturesExtents_ = {};\n\n    /**\n     * If a feature geometry changes while a pointer drag|move event occurs, the\n     * feature doesn't get updated right away.  It will be at the next 'pointerup'\n     * event fired.\n     * @type {!Object<string, import(\"../Feature.js\").default>}\n     * @private\n     */\n    this.pendingFeatures_ = {};\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.pixelTolerance_ =\n      options.pixelTolerance !== undefined ? options.pixelTolerance : 10;\n\n    /**\n     * Segment RTree for each layer\n     * @type {import(\"../structs/RBush.js\").default<SegmentData>}\n     * @private\n     */\n    this.rBush_ = new RBush();\n\n    /**\n     * @const\n     * @private\n     * @type {Object<string, function(Array<Array<import('../coordinate.js').Coordinate>>, import(\"../geom/Geometry.js\").default): void>}\n     */\n    this.GEOMETRY_SEGMENTERS_ = {\n      'Point': this.segmentPointGeometry_.bind(this),\n      'LineString': this.segmentLineStringGeometry_.bind(this),\n      'LinearRing': this.segmentLineStringGeometry_.bind(this),\n      'Polygon': this.segmentPolygonGeometry_.bind(this),\n      'MultiPoint': this.segmentMultiPointGeometry_.bind(this),\n      'MultiLineString': this.segmentMultiLineStringGeometry_.bind(this),\n      'MultiPolygon': this.segmentMultiPolygonGeometry_.bind(this),\n      'GeometryCollection': this.segmentGeometryCollectionGeometry_.bind(this),\n      'Circle': this.segmentCircleGeometry_.bind(this),\n    };\n  }\n\n  /**\n   * Add a feature to the collection of features that we may snap to.\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {boolean} [register] Whether to listen to the feature change or not\n   *     Defaults to `true`.\n   * @api\n   */\n  addFeature(feature, register) {\n    register = register !== undefined ? register : true;\n    const feature_uid = getUid(feature);\n    const geometry = feature.getGeometry();\n    if (geometry) {\n      const segmenter = this.GEOMETRY_SEGMENTERS_[geometry.getType()];\n      if (segmenter) {\n        this.indexedFeaturesExtents_[feature_uid] =\n          geometry.getExtent(createEmpty());\n        const segments =\n          /** @type {Array<Array<import('../coordinate.js').Coordinate>>} */ ([]);\n        segmenter(segments, geometry);\n        if (segments.length === 1) {\n          this.rBush_.insert(boundingExtent(segments[0]), {\n            feature: feature,\n            segment: segments[0],\n          });\n        } else if (segments.length > 1) {\n          const extents = segments.map((s) => boundingExtent(s));\n          const segmentsData = segments.map((segment) => ({\n            feature: feature,\n            segment: segment,\n          }));\n          this.rBush_.load(extents, segmentsData);\n        }\n      }\n    }\n\n    if (register) {\n      this.featureChangeListenerKeys_[feature_uid] = listen(\n        feature,\n        EventType.CHANGE,\n        this.handleFeatureChange_,\n        this,\n      );\n    }\n  }\n\n  /**\n   * @return {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|Array<import(\"../Feature.js\").default>} Features.\n   * @private\n   */\n  getFeatures_() {\n    /** @type {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|Array<import(\"../Feature.js\").default>} */\n    let features;\n    if (this.features_) {\n      features = this.features_;\n    } else if (this.source_) {\n      features = this.source_.getFeatures();\n    }\n    return features;\n  }\n\n  /**\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   * @api\n   */\n  handleEvent(evt) {\n    const result = this.snapTo(evt.pixel, evt.coordinate, evt.map);\n    if (result) {\n      evt.coordinate = result.vertex.slice(0, 2);\n      evt.pixel = result.vertexPixel;\n      this.dispatchEvent(\n        new SnapEvent(SnapEventType.SNAP, {\n          vertex: evt.coordinate,\n          vertexPixel: evt.pixel,\n          feature: result.feature,\n          segment: result.segment,\n        }),\n      );\n    }\n    return super.handleEvent(evt);\n  }\n\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} evt Event.\n   * @private\n   */\n  handleFeatureAdd_(evt) {\n    const feature = getFeatureFromEvent(evt);\n    if (feature) {\n      this.addFeature(feature);\n    }\n  }\n\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} evt Event.\n   * @private\n   */\n  handleFeatureRemove_(evt) {\n    const feature = getFeatureFromEvent(evt);\n    if (feature) {\n      this.removeFeature(feature);\n    }\n  }\n\n  /**\n   * @param {import(\"../events/Event.js\").default} evt Event.\n   * @private\n   */\n  handleFeatureChange_(evt) {\n    const feature = /** @type {import(\"../Feature.js\").default} */ (evt.target);\n    if (this.handlingDownUpSequence) {\n      const uid = getUid(feature);\n      if (!(uid in this.pendingFeatures_)) {\n        this.pendingFeatures_[uid] = feature;\n      }\n    } else {\n      this.updateFeature_(feature);\n    }\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleUpEvent(evt) {\n    const featuresToUpdate = Object.values(this.pendingFeatures_);\n    if (featuresToUpdate.length) {\n      featuresToUpdate.forEach(this.updateFeature_.bind(this));\n      this.pendingFeatures_ = {};\n    }\n    return false;\n  }\n\n  /**\n   * Remove a feature from the collection of features that we may snap to.\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {boolean} [unlisten] Whether to unlisten to the feature change\n   *     or not. Defaults to `true`.\n   * @api\n   */\n  removeFeature(feature, unlisten) {\n    const unregister = unlisten !== undefined ? unlisten : true;\n    const feature_uid = getUid(feature);\n    const extent = this.indexedFeaturesExtents_[feature_uid];\n    if (extent) {\n      const rBush = this.rBush_;\n      const nodesToRemove = [];\n      rBush.forEachInExtent(extent, function (node) {\n        if (feature === node.feature) {\n          nodesToRemove.push(node);\n        }\n      });\n      for (let i = nodesToRemove.length - 1; i >= 0; --i) {\n        rBush.remove(nodesToRemove[i]);\n      }\n    }\n\n    if (unregister) {\n      unlistenByKey(this.featureChangeListenerKeys_[feature_uid]);\n      delete this.featureChangeListenerKeys_[feature_uid];\n    }\n  }\n\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../Map.js\").default} map Map.\n   */\n  setMap(map) {\n    const currentMap = this.getMap();\n    const keys = this.featuresListenerKeys_;\n    const features = /** @type {Array<import(\"../Feature.js\").default>} */ (\n      this.getFeatures_()\n    );\n\n    if (currentMap) {\n      keys.forEach(unlistenByKey);\n      keys.length = 0;\n      this.rBush_.clear();\n      Object.values(this.featureChangeListenerKeys_).forEach(unlistenByKey);\n      this.featureChangeListenerKeys_ = {};\n    }\n    super.setMap(map);\n\n    if (map) {\n      if (this.features_) {\n        keys.push(\n          listen(\n            this.features_,\n            CollectionEventType.ADD,\n            this.handleFeatureAdd_,\n            this,\n          ),\n          listen(\n            this.features_,\n            CollectionEventType.REMOVE,\n            this.handleFeatureRemove_,\n            this,\n          ),\n        );\n      } else if (this.source_) {\n        keys.push(\n          listen(\n            this.source_,\n            VectorEventType.ADDFEATURE,\n            this.handleFeatureAdd_,\n            this,\n          ),\n          listen(\n            this.source_,\n            VectorEventType.REMOVEFEATURE,\n            this.handleFeatureRemove_,\n            this,\n          ),\n        );\n      }\n      features.forEach((feature) => this.addFeature(feature));\n    }\n  }\n\n  /**\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel\n   * @param {import(\"../coordinate.js\").Coordinate} pixelCoordinate Coordinate\n   * @param {import(\"../Map.js\").default} map Map.\n   * @return {Result|null} Snap result\n   */\n  snapTo(pixel, pixelCoordinate, map) {\n    const projection = map.getView().getProjection();\n    const projectedCoordinate = fromUserCoordinate(pixelCoordinate, projection);\n\n    const box = toUserExtent(\n      buffer(\n        boundingExtent([projectedCoordinate]),\n        map.getView().getResolution() * this.pixelTolerance_,\n      ),\n      projection,\n    );\n\n    const segments = this.rBush_.getInExtent(box);\n    const segmentsLength = segments.length;\n    if (segmentsLength === 0) {\n      return null;\n    }\n\n    let closestVertex;\n    let minSquaredDistance = Infinity;\n    let closestFeature;\n    let closestSegment = null;\n\n    const squaredPixelTolerance = this.pixelTolerance_ * this.pixelTolerance_;\n    const getResult = () => {\n      if (closestVertex) {\n        const vertexPixel = map.getPixelFromCoordinate(closestVertex);\n        const squaredPixelDistance = squaredDistance(pixel, vertexPixel);\n        if (squaredPixelDistance <= squaredPixelTolerance) {\n          return {\n            vertex: closestVertex,\n            vertexPixel: [\n              Math.round(vertexPixel[0]),\n              Math.round(vertexPixel[1]),\n            ],\n            feature: closestFeature,\n            segment: closestSegment,\n          };\n        }\n      }\n      return null;\n    };\n\n    if (this.vertex_) {\n      for (let i = 0; i < segmentsLength; ++i) {\n        const segmentData = segments[i];\n        if (segmentData.feature.getGeometry().getType() !== 'Circle') {\n          segmentData.segment.forEach((vertex) => {\n            const tempVertexCoord = fromUserCoordinate(vertex, projection);\n            const delta = squaredDistance(projectedCoordinate, tempVertexCoord);\n            if (delta < minSquaredDistance) {\n              closestVertex = vertex;\n              minSquaredDistance = delta;\n              closestFeature = segmentData.feature;\n            }\n          });\n        }\n      }\n      const result = getResult();\n      if (result) {\n        return result;\n      }\n    }\n\n    if (this.edge_) {\n      for (let i = 0; i < segmentsLength; ++i) {\n        let vertex = null;\n        const segmentData = segments[i];\n        if (segmentData.feature.getGeometry().getType() === 'Circle') {\n          let circleGeometry = segmentData.feature.getGeometry();\n          const userProjection = getUserProjection();\n          if (userProjection) {\n            circleGeometry = circleGeometry\n              .clone()\n              .transform(userProjection, projection);\n          }\n          vertex = closestOnCircle(\n            projectedCoordinate,\n            /** @type {import(\"../geom/Circle.js\").default} */ (circleGeometry),\n          );\n        } else {\n          const [segmentStart, segmentEnd] = segmentData.segment;\n          // points have only one coordinate\n          if (segmentEnd) {\n            tempSegment[0] = fromUserCoordinate(segmentStart, projection);\n            tempSegment[1] = fromUserCoordinate(segmentEnd, projection);\n            vertex = closestOnSegment(projectedCoordinate, tempSegment);\n          }\n        }\n        if (vertex) {\n          const delta = squaredDistance(projectedCoordinate, vertex);\n          if (delta < minSquaredDistance) {\n            closestVertex = toUserCoordinate(vertex, projection);\n            closestSegment =\n              segmentData.feature.getGeometry().getType() === 'Circle'\n                ? null\n                : segmentData.segment;\n            minSquaredDistance = delta;\n            closestFeature = segmentData.feature;\n          }\n        }\n      }\n\n      const result = getResult();\n      if (result) {\n        return result;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @private\n   */\n  updateFeature_(feature) {\n    this.removeFeature(feature, false);\n    this.addFeature(feature, false);\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/Circle.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentCircleGeometry_(segments, geometry) {\n    const projection = this.getMap().getView().getProjection();\n    let circleGeometry = geometry;\n    const userProjection = getUserProjection();\n    if (userProjection) {\n      circleGeometry = circleGeometry\n        .clone()\n        .transform(userProjection, projection);\n    }\n    const polygon = fromCircle(circleGeometry);\n    if (userProjection) {\n      polygon.transform(projection, userProjection);\n    }\n    const coordinates = polygon.getCoordinates()[0];\n    for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      segments.push(coordinates.slice(i, i + 2));\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentGeometryCollectionGeometry_(segments, geometry) {\n    const geometries = geometry.getGeometriesArray();\n    for (let i = 0; i < geometries.length; ++i) {\n      const segmenter = this.GEOMETRY_SEGMENTERS_[geometries[i].getType()];\n      if (segmenter) {\n        segmenter(segments, geometries[i]);\n      }\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/LineString.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentLineStringGeometry_(segments, geometry) {\n    const coordinates = geometry.getCoordinates();\n    for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      segments.push(coordinates.slice(i, i + 2));\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/MultiLineString.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentMultiLineStringGeometry_(segments, geometry) {\n    const lines = geometry.getCoordinates();\n    for (let j = 0, jj = lines.length; j < jj; ++j) {\n      const coordinates = lines[j];\n      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        segments.push(coordinates.slice(i, i + 2));\n      }\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/MultiPoint.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentMultiPointGeometry_(segments, geometry) {\n    geometry.getCoordinates().forEach((point) => {\n      segments.push([point]);\n    });\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentMultiPolygonGeometry_(segments, geometry) {\n    const polygons = geometry.getCoordinates();\n    for (let k = 0, kk = polygons.length; k < kk; ++k) {\n      const rings = polygons[k];\n      for (let j = 0, jj = rings.length; j < jj; ++j) {\n        const coordinates = rings[j];\n        for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n          segments.push(coordinates.slice(i, i + 2));\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/Point.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentPointGeometry_(segments, geometry) {\n    segments.push([geometry.getCoordinates()]);\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/Polygon.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentPolygonGeometry_(segments, geometry) {\n    const rings = geometry.getCoordinates();\n    for (let j = 0, jj = rings.length; j < jj; ++j) {\n      const coordinates = rings[j];\n      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        segments.push(coordinates.slice(i, i + 2));\n      }\n    }\n  }\n}\n\nexport default Snap;\n","import {ol_coordinate_equal} from \"./GeomUtils.js\";\r\nimport ol_geom_LineString from \"ol/geom/LineString.js\";\r\n\r\n/** Split a lineString by a point or a list of points\r\n *\tNB: points must be on the line, use getClosestPoint() to get one\r\n * @param {ol.Coordinate | Array<ol.Coordinate>} pt points to split the line\r\n * @param {Number} tol distance tolerance for 2 points to be equal\r\n */\r\nol_geom_LineString.prototype.splitAt = function(pt, tol) {\r\n  var i;\r\n  if (!pt) return [this];\r\n    if (!tol) tol = 1e-10;\r\n    // Test if list of points\r\n    if (pt.length && pt[0].length) {\r\n      var result = [this];\r\n      for (i=0; i<pt.length; i++) {\r\n        var r = [];\r\n        for (var k=0; k<result.length; k++) {\r\n          var ri = result[k].splitAt(pt[i], tol);\r\n          r = r.concat(ri);\r\n        }\r\n        result = r;\r\n      }\r\n      return result;\r\n    }\r\n    // Nothing to do\r\n    if (ol_coordinate_equal(pt,this.getFirstCoordinate())\r\n    || ol_coordinate_equal(pt,this.getLastCoordinate())) {\r\n      return [this];\r\n    }\r\n    // Get\r\n    var c0 = this.getCoordinates();\r\n    var ci=[c0[0]];\r\n    var c = [];\r\n    for (i=0; i<c0.length-1; i++) {\r\n      // Filter equal points\r\n      if (ol_coordinate_equal(c0[i],c0[i+1])) continue;\r\n      // Extremity found\r\n      if (ol_coordinate_equal(pt,c0[i+1])) {\r\n        ci.push(c0[i+1]);\r\n        c.push(new ol_geom_LineString(ci));\r\n        ci = [];\r\n      }\r\n      // Test alignement\r\n      else if (!ol_coordinate_equal(pt,c0[i])) {\r\n        var d1, d2, split=false;\r\n        if (c0[i][0] == c0[i+1][0]) {\r\n          d1 = (c0[i][1]-pt[1]) / (c0[i][1]-c0[i+1][1]);\r\n          split = (c0[i][0] == pt[0]) && (0 < d1 && d1 <= 1)\r\n        } else if (c0[i][1] == c0[i+1][1]) {\r\n          d1 = (c0[i][0]-pt[0]) / (c0[i][0]-c0[i+1][0]);\r\n          split = (c0[i][1] == pt[1]) && (0 < d1 && d1 <= 1)\r\n        } else {\r\n          d1 = (c0[i][0]-pt[0]) / (c0[i][0]-c0[i+1][0]);\r\n          d2 = (c0[i][1]-pt[1]) / (c0[i][1]-c0[i+1][1]);\r\n          split = (Math.abs(d1-d2) <= tol && 0 < d1 && d1 <= 1)\r\n        }\r\n        // pt is inside the segment > split\r\n        if (split) {\r\n          ci.push(pt);\r\n          c.push (new ol_geom_LineString(ci));\r\n          ci = [pt];\r\n        }\r\n      }\r\n      ci.push(c0[i+1]);\r\n    }\r\n    if (ci.length>1) c.push (new ol_geom_LineString(ci));\r\n    if (c.length) return c;\r\n    else return [this];\r\n}\r\n\r\n// import('ol-ext/geom/LineStringSplitAt')","/**\n * @module ol/geom/Circle\n */\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {createOrUpdate, forEachCorner, intersects} from '../extent.js';\nimport {deflateCoordinate} from './flat/deflate.js';\nimport {rotate} from './flat/transform.js';\n\n/**\n * @classdesc\n * Circle geometry.\n *\n * @api\n */\nclass Circle extends SimpleGeometry {\n  /**\n   * @param {!import(\"../coordinate.js\").Coordinate} center Center.\n   *     For internal use, flat coordinates in combination with `layout` and no\n   *     `radius` are also accepted.\n   * @param {number} [radius] Radius in units of the projection.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   */\n  constructor(center, radius, layout) {\n    super();\n    if (layout !== undefined && radius === undefined) {\n      this.setFlatCoordinates(layout, center);\n    } else {\n      radius = radius ? radius : 0;\n      this.setCenterAndRadius(center, radius, layout);\n    }\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!Circle} Clone.\n   * @api\n   */\n  clone() {\n    const circle = new Circle(\n      this.flatCoordinates.slice(),\n      undefined,\n      this.layout,\n    );\n    circle.applyProperties(this);\n    return circle;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    const flatCoordinates = this.flatCoordinates;\n    const dx = x - flatCoordinates[0];\n    const dy = y - flatCoordinates[1];\n    const squaredDistance = dx * dx + dy * dy;\n    if (squaredDistance < minSquaredDistance) {\n      if (squaredDistance === 0) {\n        for (let i = 0; i < this.stride; ++i) {\n          closestPoint[i] = flatCoordinates[i];\n        }\n      } else {\n        const delta = this.getRadius() / Math.sqrt(squaredDistance);\n        closestPoint[0] = flatCoordinates[0] + delta * dx;\n        closestPoint[1] = flatCoordinates[1] + delta * dy;\n        for (let i = 2; i < this.stride; ++i) {\n          closestPoint[i] = flatCoordinates[i];\n        }\n      }\n      closestPoint.length = this.stride;\n      return squaredDistance;\n    }\n    return minSquaredDistance;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @return {boolean} Contains (x, y).\n   */\n  containsXY(x, y) {\n    const flatCoordinates = this.flatCoordinates;\n    const dx = x - flatCoordinates[0];\n    const dy = y - flatCoordinates[1];\n    return dx * dx + dy * dy <= this.getRadiusSquared_();\n  }\n\n  /**\n   * Return the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.\n   * @return {import(\"../coordinate.js\").Coordinate} Center.\n   * @api\n   */\n  getCenter() {\n    return this.flatCoordinates.slice(0, this.stride);\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @protected\n   * @return {import(\"../extent.js\").Extent} extent Extent.\n   */\n  computeExtent(extent) {\n    const flatCoordinates = this.flatCoordinates;\n    const radius = flatCoordinates[this.stride] - flatCoordinates[0];\n    return createOrUpdate(\n      flatCoordinates[0] - radius,\n      flatCoordinates[1] - radius,\n      flatCoordinates[0] + radius,\n      flatCoordinates[1] + radius,\n      extent,\n    );\n  }\n\n  /**\n   * Return the radius of the circle.\n   * @return {number} Radius.\n   * @api\n   */\n  getRadius() {\n    return Math.sqrt(this.getRadiusSquared_());\n  }\n\n  /**\n   * @private\n   * @return {number} Radius squared.\n   */\n  getRadiusSquared_() {\n    const dx = this.flatCoordinates[this.stride] - this.flatCoordinates[0];\n    const dy = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];\n    return dx * dx + dy * dy;\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   */\n  getType() {\n    return 'Circle';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   */\n  intersectsExtent(extent) {\n    const circleExtent = this.getExtent();\n    if (intersects(extent, circleExtent)) {\n      const center = this.getCenter();\n\n      if (extent[0] <= center[0] && extent[2] >= center[0]) {\n        return true;\n      }\n      if (extent[1] <= center[1] && extent[3] >= center[1]) {\n        return true;\n      }\n\n      return forEachCorner(extent, this.intersectsCoordinate.bind(this));\n    }\n    return false;\n  }\n\n  /**\n   * Set the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.\n   * @param {import(\"../coordinate.js\").Coordinate} center Center.\n   * @api\n   */\n  setCenter(center) {\n    const stride = this.stride;\n    const radius = this.flatCoordinates[stride] - this.flatCoordinates[0];\n    const flatCoordinates = center.slice();\n    flatCoordinates[stride] = flatCoordinates[0] + radius;\n    for (let i = 1; i < stride; ++i) {\n      flatCoordinates[stride + i] = center[i];\n    }\n    this.setFlatCoordinates(this.layout, flatCoordinates);\n    this.changed();\n  }\n\n  /**\n   * Set the center (as {@link module:ol/coordinate~Coordinate coordinate}) and the radius (as\n   * number) of the circle.\n   * @param {!import(\"../coordinate.js\").Coordinate} center Center.\n   * @param {number} radius Radius.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @api\n   */\n  setCenterAndRadius(center, radius, layout) {\n    this.setLayout(layout, center, 0);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    /** @type {Array<number>} */\n    const flatCoordinates = this.flatCoordinates;\n    let offset = deflateCoordinate(flatCoordinates, 0, center, this.stride);\n    flatCoordinates[offset++] = flatCoordinates[0] + radius;\n    for (let i = 1, ii = this.stride; i < ii; ++i) {\n      flatCoordinates[offset++] = flatCoordinates[i];\n    }\n    flatCoordinates.length = offset;\n    this.changed();\n  }\n\n  getCoordinates() {\n    return null;\n  }\n\n  setCoordinates(coordinates, layout) {}\n\n  /**\n   * Set the radius of the circle. The radius is in the units of the projection.\n   * @param {number} radius Radius.\n   * @api\n   */\n  setRadius(radius) {\n    this.flatCoordinates[this.stride] = this.flatCoordinates[0] + radius;\n    this.changed();\n  }\n\n  /**\n   * Rotate the geometry around a given coordinate. This modifies the geometry\n   * coordinates in place.\n   * @param {number} angle Rotation angle in counter-clockwise radians.\n   * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\n   * @api\n   */\n  rotate(angle, anchor) {\n    const center = this.getCenter();\n    const stride = this.getStride();\n    this.setCenter(\n      rotate(center, 0, center.length, stride, angle, anchor, center),\n    );\n    this.changed();\n  }\n}\n\n/**\n * Transform each coordinate of the circle from one coordinate reference system\n * to another. The geometry is modified in place.\n * If you do not want the geometry modified in place, first clone() it and\n * then use this function on the clone.\n *\n * Internally a circle is currently represented by two points: the center of\n * the circle `[cx, cy]`, and the point to the right of the circle\n * `[cx + r, cy]`. This `transform` function just transforms these two points.\n * So the resulting geometry is also a circle, and that circle does not\n * correspond to the shape that would be obtained by transforming every point\n * of the original circle.\n *\n * @param {import(\"../proj.js\").ProjectionLike} source The current projection.  Can be a\n *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n * @param {import(\"../proj.js\").ProjectionLike} destination The desired projection.  Can be a\n *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n * @return {Circle} This geometry.  Note that original geometry is\n *     modified in place.\n * @function\n * @api\n */\nCircle.prototype.transform;\nexport default Circle;\n"],"names":["ol_interaction_ModifyFeature","constructor","options","dragging","modifying","super","handleEvent","e","type","this","handleDownEvent","_deleteCondition","handleUpEvent","handleDragEvent","handleMoveEvent","snapDistance_","pixelTolerance","tolerance_","cursor_","cursor","sources_","sources","Array","source","push","features","filterSplit_","filter","_condition","condition","deleteCondition","_insertVertexCondition","insertVertexCondition","sketchStyle","image","radius","fill","color","stroke","width","style","overlayLayer_","useSpatialIndex","name","displayInLayerSwitcher","wrapX","setMap","map","getMap","removeLayer","setActive","active","getSource","clear","setFilter","undefined","getClosestFeature","f","c","d","i","length","getClosestFeatureToCoordinate","coordinate","ci","getGeometry","getClosestPoint","di","frameState","viewState","resolution","currentFeature","dispatchEvent","selected","deselected","coord","getNearestCoord","p","getPixelFromCoordinate","pixel","feature","pt","geom","l","p0","dm","getType","getCoordinates","dist","Number","MAX_VALUE","coords","lstring","getLineStrings","ring","lring","getLinearRings","poly","getPolygons","g","getGeometries","getArcs","s","arcs","coord1","coord2","node","index","split","splitAt","shift","concat","c0","c1","nbpt","pop","closed","start","end","typeg","console","error","evt","getActive","current","forEach","extent","getFeaturesInExtent","bind","_modifiedFeatures","a","_removePoint","originalEvent","getModifiedFeatures","removePoint","_getModification","geoms","found","setGeometries","setCoordinates","setArcCoordinates","addFeature","element","getTargetElement","previousCursor_","setCursor","getCurrentFeature","ol_interaction_DrawHole","_geometryFn","coordinates","geometry","getPolygon","intersectsCoordinate","lastOKCoord","geomFn","geometryFunction","_select","layers","layers_","indexOf","_features","featureFilter","item","getArray","on","_startDrawing","_finishDrawing","removeInteraction","addInteraction","call","b","getFeatures","removeLastPoint","_feature","_polygon","_current","forEachFeatureAtPixel","layer","_polygonIndex","layerFilter","hole","pi","newGeom","appendLinearRing","appendPolygon","setGeometry","ol_extent_intersection","ol_coordinate_dist2d","p1","p2","dx","dy","Math","sqrt","ol_coordinate_equal","ol_coordinate_offsetCoords","offset","mi","mi1","li","li1","ri","ri1","si","si1","Xi1","Yi1","path","N","max","isClosed","abs","ol_coordinate_findSegment","segment","d0","v0","d1","v1","splitX","pts","x","splice","splitY","y","polygon","ol_coordinate_sampleAt","dl","nb","round","prototype","sampleAt","line","result","lines","res","mpoly","intersection","ext","getCenter","getRadius","simplify","r","hasout","warn","ol_style_Style_defaultStyle","white","blue","defaultEditStyle","edit","fillColor","ol_interaction_Delete","delete","_getSources","getLayers","getLength","delFeatures","removeFeature","ol_control_TextButton","className","ol_interaction_DrawRegular","self","handleEvent_","squaredClickTolerance_","clickTolerance","maxCircleCoordinates_","maxCircleCoordinates","features_","source_","conditionFn_","squareFn_","squareCondition","centeredFn_","centerCondition","canRotate_","canRotate","geometryName_","geometryName","setSides","sides","defaultStyle","sketch_","reset","started_","parseInt","sides_","getSides","getGeom_","center_","coord_","dmax","circle","centerPx","center","square_","centered_","coordPx_","min","hasrotation","atan2","startAngle","getExtent","scx","scy","sc","sign","t","applyTransform","g1","g2","dim","drawSketch_","shiftKey","metaKey","ctrlKey","feature_","drawPoint_","noclear","_eventTime","Date","downPx_","start_","dt","_longTouch","setTimeout","handleMoveEvent_","lastEvent","end_","upPx_","finishDrawing","startCoordinate","square","centered","setGeometryName","PI","opt_fast","ol_interaction_UndoRedo","_layers","_undoStack","_redoStack","_undo","_redo","level","_level","view","getView","zoom","getZoom","action","_reduce","_doShift","_doClear","_block","_record","_defs","define","undoFn","redoFn","undo","redo","setMaxLength","set","size","setMaxSize","get","getStack","prop","custom","removeAt","_mapListener","blockStart","blockEnd","_watchSources","_watchInteractions","_sourceListener","getVectorLayers","init","vectors","_onAddRemove","_interactionListener","getInteractions","_onInteraction","target","fn","_handleDo","oldGeom","newp","newProperties","oldp","oldProperties","unset","hasUndo","hasRedo","setattributestart","Object","assign","properties","rotatestart","translatestart","scalestart","modifystart","replace","m","clone","beforesplit","deletestart","aftersplit","deleteend","ol_control_Toggle","toggleFn","onToggle","handleClick","toggle","interaction_","interaction","title","autoActivate","bar","setSubBar","setDisable","disable","subbar_","removeControl","addControl","getSubBar","setTarget","classList","add","getDisable","button","querySelector","disabled","key","oldValue","contains","remove","setInteraction","getInteraction","ol_interaction_Split","snapDistance","tolerance","setSources","featureStyle","_sketch_","getSources","getVisible","unshift","fi","gi","link","tosplit","original","linkGeometry","DrawEventType","DRAWSTART","DRAWEND","DRAWABORT","DrawEvent","getTraceTargets","targets","appendGeometryTraceTargets","getSquaredDistance","getCoordinate","count","getCumulativeSquaredDistance","startIndex","endIndex","lowIndex","highIndex","lowWholeIndex","ceil","highWholeIndex","floor","interpolateCoordinate","sd","appendTraceTarget","ii","polys","j","jj","geometries","sharedUpdateInfo","NaN","getTraceTargetUpdate","traceState","snapTolerance","closestTargetDistance","Infinity","newTargetIndex","newEndIndex","targetIndex","minSegmentDistance","coordinateIndex","rel","getPointSegmentRelationship","squaredDistance","along","newTarget","considerBothDirections","newCoordinate","startPx","forwardDistance","reverseDistance","sharedRel","x1","y1","x2","y2","px","py","x0","y0","Draw","pointerOptions","stopDown","once","un","shouldHandle_","downTimeout_","lastDragTime_","pointerType_","freehand_","snapTolerance_","type_","mode_","getMode","stopClick_","stopClick","minPoints_","minPoints","maxPoints_","maxPoints","finishCondition_","finishCondition","geometryLayout_","geometryLayout","mode","projection","fromUserCoordinate","squaredLength","setCenterAndRadius","userProjection","getUserProjection","transform","Constructor","geometryFunction_","dragVertexDelay_","dragVertexDelay","finishCoordinate_","sketchFeature_","sketchPoint_","sketchCoords_","sketchLine_","sketchLineCoords_","overlay_","getDefaultStyleFunction","updateWhileInteracting","condition_","freehandCondition_","freehand","freehandCondition","traceCondition_","setTrace","trace","traceState_","traceSource_","traceSource","addChangeListener","ACTIVE","updateState_","getOverlay","event","CONTEXTMENU","preventDefault","move","POINTERMOVE","pass","POINTERDRAG","now","clearTimeout","addToDrawing_","POINTERDOWN","getPointerCount","handlePointerMove_","pointerType","DBLCLICK","startDrawing_","deactivateTrace_","toggleTraceState_","lowerLeft","getCoordinateFromPixel","upperRight","slice","addOrRemoveTracedCoordinates_","previouslyForward","currentlyForward","addTracedCoordinates_","removeTracedCoordinates_","fromIndex","toIndex","removeLastPoints_","appendCoordinates","updateTrace_","updatedTraceTarget","oldTarget","tracing","startingToDraw","atFinish_","abortDrawing","downPx","clickPx","modifyDrawing_","createOrUpdateSketchPoint_","at","potentiallyDone","potentiallyFinishCoordinates","sketchCoords","finishCoordinate","finishPixel","sketchPointGeom","updateSketchFeatures_","createOrUpdateCustomSketchLine_","getLinearRing","sketchLineGeom","setFlatCoordinates","getLayout","getFlatCoordinates","changed","getProjection","stride","last","done","n","sketchFeature","abortDrawing_","newDrawing","ending","extend","lineString","sketchFeatures","overlaySource","addFeatures","styles","createEditingStyle","Error","ol_interaction_Transform","handleDownEvent_","handleDragEvent_","handleUpEvent_","selection_","handles_","updateWhileAnimating","_filter","_handleEvent","addFn_","addCondition","setPointRadius","pointRadius","translateFeature","translate","translateBBox","stretch","scale","rotate","keepAspectRatio","modifyCenter","noFlip","selection","hitTolerance","enableRotatedTransform","keepRectangle","buffer","setDefaultStyle","oldMap","select","isTouch","test","getViewport","setVisible","pointStroke","strokedash","lineDash","fill0","pointFill","displacement","points","setDisplacement","getAnchor","bigpt","angle","smallpt","createStyle","img","setStyle","olstyle","im","getImage","setScale","tx","getText","setOffsetX","getFeatureAtPixel_","bbox_","handle","constraint","option","some","getGeometryRotateToZero_","origGeom","viewRotation","getRotation","rotGeom","_isRectangle","extendExt","ptRadius","_pointRadius","ispt_","iscircle_","watchFeatures_","setSelection","_featureListeners","isUpdating_","sel","opt_","constraint_","coordinate_","pixel_","geoms_","rotatedGeoms_","rotExtent","extent_","rotatedExtent_","Cursors","rotate0","angle_","setCenter","pt0","ispt","deltaX","deltaY","delta","extentCoordinates","opt","downCoordinate","dragCoordinate","downPoint","dragPoint","displacementVector","centerPoint","pointArray","pointA","pointB","pointC","pointD","pointA1","base","_countVector","projectedVector","_projectVectorOnVector","nextIndex","coordsToChange","includes","projectedLeft","projectedRight","_movePoint","default","oldgeom","oldgeoms","displacement_vector","k","point","ol_interaction_Offset","duplicate","_style","typeGeom","hit","geomType","current_","currentStyle_","getStyle","_modifystart","seg","v2","ExtentEventType","EXTENTCHANGED","ExtentEvent","Extent","pointerHandler_","pixelTolerance_","snappedToVertex_","extentFeature_","vertexFeature_","extentOverlay_","boxStyle","getDefaultExtentStyleFunction","vertexOverlay_","pointerStyle","getDefaultPointerStyleFunction","setExtent","snapToVertex_","pixelCoordinate","getCoordinateFromPixelInternal","sortByDistance","getExtentInternal","segments","getSegments","sort","closestSegment","vertex","vertexPixel","getPixelFromCoordinateInternal","pixel1","pixel2","squaredDist1","squaredDist2","mapBrowserEvent","createOrUpdatePointerFeature_","createOrUpdateExtentFeature_","extentFeature","vertexFeature","handlingDownUpSequence","getOpposingPoint","x_","y_","getPointHandler","getEdgeHandler","toUserExtent","fixedPoint","fixedP1","fixedP2","SnapEventType","SNAP","SnapEvent","Event","getFeatureFromEvent","tempSegment","Snap","Pointer","vertex_","edge_","edge","featuresListenerKeys_","featureChangeListenerKeys_","indexedFeaturesExtents_","pendingFeatures_","rBush_","RBush","GEOMETRY_SEGMENTERS_","segmentPointGeometry_","segmentLineStringGeometry_","segmentPolygonGeometry_","segmentMultiPointGeometry_","segmentMultiLineStringGeometry_","segmentMultiPolygonGeometry_","segmentGeometryCollectionGeometry_","segmentCircleGeometry_","register","feature_uid","segmenter","insert","extents","segmentsData","load","EventType","CHANGE","handleFeatureChange_","getFeatures_","snapTo","handleFeatureAdd_","handleFeatureRemove_","uid","updateFeature_","featuresToUpdate","values","unlisten","unregister","rBush","nodesToRemove","forEachInExtent","currentMap","keys","CollectionEventType","ADD","REMOVE","VectorEventType","ADDFEATURE","REMOVEFEATURE","projectedCoordinate","box","getResolution","getInExtent","segmentsLength","closestVertex","closestFeature","minSquaredDistance","squaredPixelTolerance","getResult","squaredPixelDistance","segmentData","tempVertexCoord","circleGeometry","segmentStart","segmentEnd","toUserCoordinate","getGeometriesArray","polygons","kk","rings","tol","getFirstCoordinate","getLastCoordinate","d2","Circle","layout","flatCoordinates","applyProperties","closestPointXY","closestPoint","containsXY","getRadiusSquared_","computeExtent","intersectsExtent","circleExtent","setLayout","setRadius","anchor","getStride"],"sourceRoot":""}
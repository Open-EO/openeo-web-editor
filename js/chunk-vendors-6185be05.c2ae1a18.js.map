{"version":3,"file":"js/chunk-vendors-6185be05.c2ae1a18.js","mappings":"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","sources":["webpack://@openeo/web-editor/./node_modules/gopd/gOPD.js","webpack://@openeo/web-editor/./node_modules/hasown/index.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/rgb.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/compression/index.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/resample.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/geotiffimage.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/dataview64.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/dataslice.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/source/httputils.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/source/basesource.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/utils.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/source/blockedsource.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/source/client/base.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/source/client/fetch.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/source/client/xhr.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/source/client/http.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/source/remote.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/source/filereader.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/geotiff.js","webpack://@openeo/web-editor/./node_modules/has-symbols/shams.js","webpack://@openeo/web-editor/./node_modules/get-proto/Reflect.getPrototypeOf.js","webpack://@openeo/web-editor/./node_modules/has-symbols/index.js","webpack://@openeo/web-editor/./node_modules/get-intrinsic/index.js","webpack://@openeo/web-editor/./node_modules/get-proto/Object.getPrototypeOf.js","webpack://@openeo/web-editor/./node_modules/gopd/index.js","webpack://@openeo/web-editor/./node_modules/get-proto/index.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/globals.js"],"sourcesContent":["'use strict';\n\n/** @type {import('./gOPD')} */\nmodule.exports = Object.getOwnPropertyDescriptor;\n","'use strict';\n\nvar call = Function.prototype.call;\nvar $hasOwn = Object.prototype.hasOwnProperty;\nvar bind = require('function-bind');\n\n/** @type {import('.')} */\nmodule.exports = bind.call(call, $hasOwn);\n","export function fromWhiteIsZero(raster, max) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  let value;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    value = 256 - (raster[i] / max * 256);\n    rgbRaster[j] = value;\n    rgbRaster[j + 1] = value;\n    rgbRaster[j + 2] = value;\n  }\n  return rgbRaster;\n}\n\nexport function fromBlackIsZero(raster, max) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  let value;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    value = raster[i] / max * 256;\n    rgbRaster[j] = value;\n    rgbRaster[j + 1] = value;\n    rgbRaster[j + 2] = value;\n  }\n  return rgbRaster;\n}\n\nexport function fromPalette(raster, colorMap) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  const greenOffset = colorMap.length / 3;\n  const blueOffset = colorMap.length / 3 * 2;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    const mapIndex = raster[i];\n    rgbRaster[j] = colorMap[mapIndex] / 65536 * 256;\n    rgbRaster[j + 1] = colorMap[mapIndex + greenOffset] / 65536 * 256;\n    rgbRaster[j + 2] = colorMap[mapIndex + blueOffset] / 65536 * 256;\n  }\n  return rgbRaster;\n}\n\nexport function fromCMYK(cmykRaster) {\n  const { width, height } = cmykRaster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  for (let i = 0, j = 0; i < cmykRaster.length; i += 4, j += 3) {\n    const c = cmykRaster[i];\n    const m = cmykRaster[i + 1];\n    const y = cmykRaster[i + 2];\n    const k = cmykRaster[i + 3];\n\n    rgbRaster[j] = 255 * ((255 - c) / 256) * ((255 - k) / 256);\n    rgbRaster[j + 1] = 255 * ((255 - m) / 256) * ((255 - k) / 256);\n    rgbRaster[j + 2] = 255 * ((255 - y) / 256) * ((255 - k) / 256);\n  }\n  return rgbRaster;\n}\n\nexport function fromYCbCr(yCbCrRaster) {\n  const { width, height } = yCbCrRaster;\n  const rgbRaster = new Uint8ClampedArray(width * height * 3);\n  for (let i = 0, j = 0; i < yCbCrRaster.length; i += 3, j += 3) {\n    const y = yCbCrRaster[i];\n    const cb = yCbCrRaster[i + 1];\n    const cr = yCbCrRaster[i + 2];\n\n    rgbRaster[j] = (y + (1.40200 * (cr - 0x80)));\n    rgbRaster[j + 1] = (y - (0.34414 * (cb - 0x80)) - (0.71414 * (cr - 0x80)));\n    rgbRaster[j + 2] = (y + (1.77200 * (cb - 0x80)));\n  }\n  return rgbRaster;\n}\n\nconst Xn = 0.95047;\nconst Yn = 1.00000;\nconst Zn = 1.08883;\n\n// from https://github.com/antimatter15/rgb-lab/blob/master/color.js\n\nexport function fromCIELab(cieLabRaster) {\n  const { width, height } = cieLabRaster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n\n  for (let i = 0, j = 0; i < cieLabRaster.length; i += 3, j += 3) {\n    const L = cieLabRaster[i + 0];\n    const a_ = cieLabRaster[i + 1] << 24 >> 24; // conversion from uint8 to int8\n    const b_ = cieLabRaster[i + 2] << 24 >> 24; // same\n\n    let y = (L + 16) / 116;\n    let x = (a_ / 500) + y;\n    let z = y - (b_ / 200);\n    let r;\n    let g;\n    let b;\n\n    x = Xn * ((x * x * x > 0.008856) ? x * x * x : (x - (16 / 116)) / 7.787);\n    y = Yn * ((y * y * y > 0.008856) ? y * y * y : (y - (16 / 116)) / 7.787);\n    z = Zn * ((z * z * z > 0.008856) ? z * z * z : (z - (16 / 116)) / 7.787);\n\n    r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n    g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n    b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\n    r = (r > 0.0031308) ? ((1.055 * (r ** (1 / 2.4))) - 0.055) : 12.92 * r;\n    g = (g > 0.0031308) ? ((1.055 * (g ** (1 / 2.4))) - 0.055) : 12.92 * g;\n    b = (b > 0.0031308) ? ((1.055 * (b ** (1 / 2.4))) - 0.055) : 12.92 * b;\n\n    rgbRaster[j] = Math.max(0, Math.min(1, r)) * 255;\n    rgbRaster[j + 1] = Math.max(0, Math.min(1, g)) * 255;\n    rgbRaster[j + 2] = Math.max(0, Math.min(1, b)) * 255;\n  }\n  return rgbRaster;\n}\n","const registry = new Map();\nconst preferWorkerMap = new Map();\n\n/**\n * Either a number or undefined.\n * @typedef {(number|undefined)} NumberOrUndefined\n */\n\n/**\n * Register a decoder for a specific compression method or a range of compressions\n * @param {(NumberOrUndefined|(NumberOrUndefined[]))} cases ids of the compression methods to register for\n * @param {function():Promise} importFn the function to import the decoder\n * @param {boolean} preferWorker_ Whether to prefer running the decoder in a worker\n */\nexport function addDecoder(cases, importFn, preferWorker_ = true) {\n  if (!Array.isArray(cases)) {\n    cases = [cases]; // eslint-disable-line no-param-reassign\n  }\n  cases.forEach((c) => {\n    registry.set(c, importFn);\n    preferWorkerMap.set(c, preferWorker_);\n  });\n}\n\n/**\n * Get a decoder for a specific file directory\n * @param {object} fileDirectory the file directory of the image\n * @returns {Promise<Decoder>}\n */\nexport async function getDecoder(fileDirectory) {\n  const importFn = registry.get(fileDirectory.Compression);\n  if (!importFn) {\n    throw new Error(`Unknown compression method identifier: ${fileDirectory.Compression}`);\n  }\n  const Decoder = await importFn();\n  return new Decoder(fileDirectory);\n}\n\n/**\n * Whether to prefer running the decoder in a worker\n * @param {object} fileDirectory the file directory of the image\n * @returns {boolean}\n */\nexport function preferWorker(fileDirectory) {\n  return preferWorkerMap.get(fileDirectory.Compression);\n}\n\n// Add default decoders to registry (end-user may override with other implementations)\naddDecoder([undefined, 1], () => import('./raw.js').then((m) => m.default), false);\naddDecoder(5, () => import('./lzw.js').then((m) => m.default));\naddDecoder(6, () => {\n  throw new Error('old style JPEG compression is not supported.');\n});\naddDecoder(7, () => import('./jpeg.js').then((m) => m.default));\naddDecoder([8, 32946], () => import('./deflate.js').then((m) => m.default));\naddDecoder(32773, () => import('./packbits.js').then((m) => m.default));\naddDecoder(34887, () => import('./lerc.js')\n  .then(async (m) => {\n    await m.zstd.init();\n    return m;\n  })\n  .then((m) => m.default),\n);\naddDecoder(50000, () => import('./zstd.js')\n  .then(async (m) => {\n    await m.zstd.init();\n    return m;\n  })\n  .then((m) => m.default),\n);\naddDecoder(50001, () => import('./webimage.js').then((m) => m.default), false);\n","/**\n * @module resample\n */\n\nfunction copyNewSize(array, width, height, samplesPerPixel = 1) {\n  return new (Object.getPrototypeOf(array).constructor)(width * height * samplesPerPixel);\n}\n\n/**\n * Resample the input arrays using nearest neighbor value selection.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  return valueArrays.map((array) => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n    for (let y = 0; y < outHeight; ++y) {\n      const cy = Math.min(Math.round(relY * y), inHeight - 1);\n      for (let x = 0; x < outWidth; ++x) {\n        const cx = Math.min(Math.round(relX * x), inWidth - 1);\n        const value = array[(cy * inWidth) + cx];\n        newArray[(y * outWidth) + x] = value;\n      }\n    }\n    return newArray;\n  });\n}\n\n// simple linear interpolation, code from:\n// https://en.wikipedia.org/wiki/Linear_interpolation#Programming_language_support\nfunction lerp(v0, v1, t) {\n  return ((1 - t) * v0) + (t * v1);\n}\n\n/**\n * Resample the input arrays using bilinear interpolation.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n\n  return valueArrays.map((array) => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n    for (let y = 0; y < outHeight; ++y) {\n      const rawY = relY * y;\n\n      const yl = Math.floor(rawY);\n      const yh = Math.min(Math.ceil(rawY), (inHeight - 1));\n\n      for (let x = 0; x < outWidth; ++x) {\n        const rawX = relX * x;\n        const tx = rawX % 1;\n\n        const xl = Math.floor(rawX);\n        const xh = Math.min(Math.ceil(rawX), (inWidth - 1));\n\n        const ll = array[(yl * inWidth) + xl];\n        const hl = array[(yl * inWidth) + xh];\n        const lh = array[(yh * inWidth) + xl];\n        const hh = array[(yh * inWidth) + xh];\n\n        const value = lerp(\n          lerp(ll, hl, tx),\n          lerp(lh, hh, tx),\n          rawY % 1,\n        );\n        newArray[(y * outWidth) + x] = value;\n      }\n    }\n    return newArray;\n  });\n}\n\n/**\n * Resample the input arrays using the selected resampling method.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resample(valueArrays, inWidth, inHeight, outWidth, outHeight, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight);\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight);\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n\n/**\n * Resample the pixel interleaved input array using nearest neighbor value selection.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\nexport function resampleNearestInterleaved(\n  valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n  for (let y = 0; y < outHeight; ++y) {\n    const cy = Math.min(Math.round(relY * y), inHeight - 1);\n    for (let x = 0; x < outWidth; ++x) {\n      const cx = Math.min(Math.round(relX * x), inWidth - 1);\n      for (let i = 0; i < samples; ++i) {\n        const value = valueArray[(cy * inWidth * samples) + (cx * samples) + i];\n        newArray[(y * outWidth * samples) + (x * samples) + i] = value;\n      }\n    }\n  }\n  return newArray;\n}\n\n/**\n * Resample the pixel interleaved input array using bilinear interpolation.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\nexport function resampleBilinearInterleaved(\n  valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n  for (let y = 0; y < outHeight; ++y) {\n    const rawY = relY * y;\n\n    const yl = Math.floor(rawY);\n    const yh = Math.min(Math.ceil(rawY), (inHeight - 1));\n\n    for (let x = 0; x < outWidth; ++x) {\n      const rawX = relX * x;\n      const tx = rawX % 1;\n\n      const xl = Math.floor(rawX);\n      const xh = Math.min(Math.ceil(rawX), (inWidth - 1));\n\n      for (let i = 0; i < samples; ++i) {\n        const ll = valueArray[(yl * inWidth * samples) + (xl * samples) + i];\n        const hl = valueArray[(yl * inWidth * samples) + (xh * samples) + i];\n        const lh = valueArray[(yh * inWidth * samples) + (xl * samples) + i];\n        const hh = valueArray[(yh * inWidth * samples) + (xh * samples) + i];\n\n        const value = lerp(\n          lerp(ll, hl, tx),\n          lerp(lh, hh, tx),\n          rawY % 1,\n        );\n        newArray[(y * outWidth * samples) + (x * samples) + i] = value;\n      }\n    }\n  }\n  return newArray;\n}\n\n/**\n * Resample the pixel interleaved input array using the selected resampling method.\n * @param {TypedArray} valueArray The input array to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                                 interleaved data\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray} The resampled rasters\n */\nexport function resampleInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearestInterleaved(\n        valueArray, inWidth, inHeight, outWidth, outHeight, samples,\n      );\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinearInterleaved(\n        valueArray, inWidth, inHeight, outWidth, outHeight, samples,\n      );\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n","/** @module geotiffimage */\nimport { getFloat16 } from '@petamoriken/float16';\nimport getAttribute from 'xml-utils/get-attribute'; // eslint-disable-line import/extensions\nimport findTagsByName from 'xml-utils/find-tags-by-name'; // eslint-disable-line import/extensions\n\nimport { photometricInterpretations, ExtraSamplesValues } from './globals.js';\nimport { fromWhiteIsZero, fromBlackIsZero, fromPalette, fromCMYK, fromYCbCr, fromCIELab } from './rgb.js';\nimport { getDecoder } from './compression/index.js';\nimport { resample, resampleInterleaved } from './resample.js';\n\n/**\n * @typedef {Object} ReadRasterOptions\n * @property {Array<number>} [window=whole window] the subset to read data from in pixels.\n * @property {Array<number>} [bbox=whole image] the subset to read data from in\n *                                           geographical coordinates.\n * @property {Array<number>} [samples=all samples] the selection of samples to read from. Default is all samples.\n * @property {boolean} [interleave=false] whether the data shall be read\n *                                             in one single array or separate\n *                                             arrays.\n * @property {Pool} [pool=null] The optional decoder pool to use.\n * @property {number} [width] The desired width of the output. When the width is not the\n *                                 same as the images, resampling will be performed.\n * @property {number} [height] The desired height of the output. When the width is not the\n *                                  same as the images, resampling will be performed.\n * @property {string} [resampleMethod='nearest'] The desired resampling method.\n * @property {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                                       to be aborted\n * @property {number|number[]} [fillValue] The value to use for parts of the image\n *                                              outside of the images extent. When multiple\n *                                              samples are requested, an array of fill values\n *                                              can be passed.\n */\n\n/** @typedef {import(\"./geotiff.js\").TypedArray} TypedArray */\n/** @typedef {import(\"./geotiff.js\").ReadRasterResult} ReadRasterResult */\n\nfunction sum(array, start, end) {\n  let s = 0;\n  for (let i = start; i < end; ++i) {\n    s += array[i];\n  }\n  return s;\n}\n\nfunction arrayForType(format, bitsPerSample, size) {\n  switch (format) {\n    case 1: // unsigned integer data\n      if (bitsPerSample <= 8) {\n        return new Uint8Array(size);\n      } else if (bitsPerSample <= 16) {\n        return new Uint16Array(size);\n      } else if (bitsPerSample <= 32) {\n        return new Uint32Array(size);\n      }\n      break;\n    case 2: // twos complement signed integer data\n      if (bitsPerSample === 8) {\n        return new Int8Array(size);\n      } else if (bitsPerSample === 16) {\n        return new Int16Array(size);\n      } else if (bitsPerSample === 32) {\n        return new Int32Array(size);\n      }\n      break;\n    case 3: // floating point data\n      switch (bitsPerSample) {\n        case 16:\n        case 32:\n          return new Float32Array(size);\n        case 64:\n          return new Float64Array(size);\n        default:\n          break;\n      }\n      break;\n    default:\n      break;\n  }\n  throw Error('Unsupported data format/bitsPerSample');\n}\n\nfunction needsNormalization(format, bitsPerSample) {\n  if ((format === 1 || format === 2) && bitsPerSample <= 32 && bitsPerSample % 8 === 0) {\n    return false;\n  } else if (format === 3 && (bitsPerSample === 16 || bitsPerSample === 32 || bitsPerSample === 64)) {\n    return false;\n  }\n  return true;\n}\n\nfunction normalizeArray(inBuffer, format, planarConfiguration, samplesPerPixel, bitsPerSample, tileWidth, tileHeight) {\n  // const inByteArray = new Uint8Array(inBuffer);\n  const view = new DataView(inBuffer);\n  const outSize = planarConfiguration === 2\n    ? tileHeight * tileWidth\n    : tileHeight * tileWidth * samplesPerPixel;\n  const samplesToTransfer = planarConfiguration === 2\n    ? 1 : samplesPerPixel;\n  const outArray = arrayForType(format, bitsPerSample, outSize);\n  // let pixel = 0;\n\n  const bitMask = parseInt('1'.repeat(bitsPerSample), 2);\n\n  if (format === 1) { // unsigned integer\n    // translation of https://github.com/OSGeo/gdal/blob/master/gdal/frmts/gtiff/geotiff.cpp#L7337\n    let pixelBitSkip;\n    // let sampleBitOffset = 0;\n    if (planarConfiguration === 1) {\n      pixelBitSkip = samplesPerPixel * bitsPerSample;\n      // sampleBitOffset = (samplesPerPixel - 1) * bitsPerSample;\n    } else {\n      pixelBitSkip = bitsPerSample;\n    }\n\n    // Bits per line rounds up to next byte boundary.\n    let bitsPerLine = tileWidth * pixelBitSkip;\n    if ((bitsPerLine & 7) !== 0) {\n      bitsPerLine = (bitsPerLine + 7) & (~7);\n    }\n\n    for (let y = 0; y < tileHeight; ++y) {\n      const lineBitOffset = y * bitsPerLine;\n      for (let x = 0; x < tileWidth; ++x) {\n        const pixelBitOffset = lineBitOffset + (x * samplesToTransfer * bitsPerSample);\n        for (let i = 0; i < samplesToTransfer; ++i) {\n          const bitOffset = pixelBitOffset + (i * bitsPerSample);\n          const outIndex = (((y * tileWidth) + x) * samplesToTransfer) + i;\n\n          const byteOffset = Math.floor(bitOffset / 8);\n          const innerBitOffset = bitOffset % 8;\n          if (innerBitOffset + bitsPerSample <= 8) {\n            outArray[outIndex] = (view.getUint8(byteOffset) >> (8 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 16) {\n            outArray[outIndex] = (view.getUint16(byteOffset) >> (16 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 24) {\n            const raw = (view.getUint16(byteOffset) << 8) | (view.getUint8(byteOffset + 2));\n            outArray[outIndex] = (raw >> (24 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else {\n            outArray[outIndex] = (view.getUint32(byteOffset) >> (32 - bitsPerSample) - innerBitOffset) & bitMask;\n          }\n\n          // let outWord = 0;\n          // for (let bit = 0; bit < bitsPerSample; ++bit) {\n          //   if (inByteArray[bitOffset >> 3]\n          //     & (0x80 >> (bitOffset & 7))) {\n          //     outWord |= (1 << (bitsPerSample - 1 - bit));\n          //   }\n          //   ++bitOffset;\n          // }\n\n          // outArray[outIndex] = outWord;\n          // outArray[pixel] = outWord;\n          // pixel += 1;\n        }\n        // bitOffset = bitOffset + pixelBitSkip - bitsPerSample;\n      }\n    }\n  } else if (format === 3) { // floating point\n    // Float16 is handled elsewhere\n    // normalize 16/24 bit floats to 32 bit floats in the array\n    // console.time();\n    // if (bitsPerSample === 16) {\n    //   for (let byte = 0, outIndex = 0; byte < inBuffer.byteLength; byte += 2, ++outIndex) {\n    //     outArray[outIndex] = getFloat16(view, byte);\n    //   }\n    // }\n    // console.timeEnd()\n  }\n\n  return outArray.buffer;\n}\n\n/**\n * GeoTIFF sub-file image.\n */\nclass GeoTIFFImage {\n  /**\n   * @constructor\n   * @param {Object} fileDirectory The parsed file directory\n   * @param {Object} geoKeys The parsed geo-keys\n   * @param {DataView} dataView The DataView for the underlying file.\n   * @param {Boolean} littleEndian Whether the file is encoded in little or big endian\n   * @param {Boolean} cache Whether or not decoded tiles shall be cached\n   * @param {import('./source/basesource').BaseSource} source The datasource to read from\n   */\n  constructor(fileDirectory, geoKeys, dataView, littleEndian, cache, source) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeys = geoKeys;\n    this.dataView = dataView;\n    this.littleEndian = littleEndian;\n    this.tiles = cache ? {} : null;\n    this.isTiled = !fileDirectory.StripOffsets;\n    const planarConfiguration = fileDirectory.PlanarConfiguration;\n    this.planarConfiguration = (typeof planarConfiguration === 'undefined') ? 1 : planarConfiguration;\n    if (this.planarConfiguration !== 1 && this.planarConfiguration !== 2) {\n      throw new Error('Invalid planar configuration.');\n    }\n\n    this.source = source;\n  }\n\n  /**\n   * Returns the associated parsed file directory.\n   * @returns {Object} the parsed file directory\n   */\n  getFileDirectory() {\n    return this.fileDirectory;\n  }\n\n  /**\n   * Returns the associated parsed geo keys.\n   * @returns {Object} the parsed geo keys\n   */\n  getGeoKeys() {\n    return this.geoKeys;\n  }\n\n  /**\n   * Returns the width of the image.\n   * @returns {Number} the width of the image\n   */\n  getWidth() {\n    return this.fileDirectory.ImageWidth;\n  }\n\n  /**\n   * Returns the height of the image.\n   * @returns {Number} the height of the image\n   */\n  getHeight() {\n    return this.fileDirectory.ImageLength;\n  }\n\n  /**\n   * Returns the number of samples per pixel.\n   * @returns {Number} the number of samples per pixel\n   */\n  getSamplesPerPixel() {\n    return typeof this.fileDirectory.SamplesPerPixel !== 'undefined'\n      ? this.fileDirectory.SamplesPerPixel : 1;\n  }\n\n  /**\n   * Returns the width of each tile.\n   * @returns {Number} the width of each tile\n   */\n  getTileWidth() {\n    return this.isTiled ? this.fileDirectory.TileWidth : this.getWidth();\n  }\n\n  /**\n   * Returns the height of each tile.\n   * @returns {Number} the height of each tile\n   */\n  getTileHeight() {\n    if (this.isTiled) {\n      return this.fileDirectory.TileLength;\n    }\n    if (typeof this.fileDirectory.RowsPerStrip !== 'undefined') {\n      return Math.min(this.fileDirectory.RowsPerStrip, this.getHeight());\n    }\n    return this.getHeight();\n  }\n\n  getBlockWidth() {\n    return this.getTileWidth();\n  }\n\n  getBlockHeight(y) {\n    if (this.isTiled || (y + 1) * this.getTileHeight() <= this.getHeight()) {\n      return this.getTileHeight();\n    } else {\n      return this.getHeight() - (y * this.getTileHeight());\n    }\n  }\n\n  /**\n   * Calculates the number of bytes for each pixel across all samples. Only full\n   * bytes are supported, an exception is thrown when this is not the case.\n   * @returns {Number} the bytes per pixel\n   */\n  getBytesPerPixel() {\n    let bytes = 0;\n    for (let i = 0; i < this.fileDirectory.BitsPerSample.length; ++i) {\n      bytes += this.getSampleByteSize(i);\n    }\n    return bytes;\n  }\n\n  getSampleByteSize(i) {\n    if (i >= this.fileDirectory.BitsPerSample.length) {\n      throw new RangeError(`Sample index ${i} is out of range.`);\n    }\n    return Math.ceil(this.fileDirectory.BitsPerSample[i] / 8);\n  }\n\n  getReaderForSample(sampleIndex) {\n    const format = this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n    const bitsPerSample = this.fileDirectory.BitsPerSample[sampleIndex];\n    switch (format) {\n      case 1: // unsigned integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getUint8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getUint16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getUint32;\n        }\n        break;\n      case 2: // twos complement signed integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getInt8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getInt16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getInt32;\n        }\n        break;\n      case 3:\n        switch (bitsPerSample) {\n          case 16:\n            return function (offset, littleEndian) {\n              return getFloat16(this, offset, littleEndian);\n            };\n          case 32:\n            return DataView.prototype.getFloat32;\n          case 64:\n            return DataView.prototype.getFloat64;\n          default:\n            break;\n        }\n        break;\n      default:\n        break;\n    }\n    throw Error('Unsupported data format/bitsPerSample');\n  }\n\n  getSampleFormat(sampleIndex = 0) {\n    return this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n  }\n\n  getBitsPerSample(sampleIndex = 0) {\n    return this.fileDirectory.BitsPerSample[sampleIndex];\n  }\n\n  getArrayForSample(sampleIndex, size) {\n    const format = this.getSampleFormat(sampleIndex);\n    const bitsPerSample = this.getBitsPerSample(sampleIndex);\n    return arrayForType(format, bitsPerSample, size);\n  }\n\n  /**\n   * Returns the decoded strip or tile.\n   * @param {Number} x the strip or tile x-offset\n   * @param {Number} y the tile y-offset (0 for stripped images)\n   * @param {Number} sample the sample to get for separated samples\n   * @param {import(\"./geotiff\").Pool|import(\"./geotiff\").BaseDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise.<{x: number, y: number, sample: number, data: ArrayBuffer}>} the decoded strip or tile\n   */\n  async getTileOrStrip(x, y, sample, poolOrDecoder, signal) {\n    const numTilesPerRow = Math.ceil(this.getWidth() / this.getTileWidth());\n    const numTilesPerCol = Math.ceil(this.getHeight() / this.getTileHeight());\n    let index;\n    const { tiles } = this;\n    if (this.planarConfiguration === 1) {\n      index = (y * numTilesPerRow) + x;\n    } else if (this.planarConfiguration === 2) {\n      index = (sample * numTilesPerRow * numTilesPerCol) + (y * numTilesPerRow) + x;\n    }\n\n    let offset;\n    let byteCount;\n    if (this.isTiled) {\n      offset = this.fileDirectory.TileOffsets[index];\n      byteCount = this.fileDirectory.TileByteCounts[index];\n    } else {\n      offset = this.fileDirectory.StripOffsets[index];\n      byteCount = this.fileDirectory.StripByteCounts[index];\n    }\n\n    if (byteCount === 0) {\n      const nPixels = this.getBlockHeight(y) * this.getTileWidth();\n      const bytesPerPixel = (this.planarConfiguration === 2) ? this.getSampleByteSize(sample) : this.getBytesPerPixel();\n      const data = new ArrayBuffer(nPixels * bytesPerPixel);\n      const view = this.getArrayForSample(sample, data);\n      view.fill(this.getGDALNoData() || 0);\n      return { x, y, sample, data };\n    }\n\n    const slice = (await this.source.fetch([{ offset, length: byteCount }], signal))[0];\n\n    let request;\n    if (tiles === null || !tiles[index]) {\n    // resolve each request by potentially applying array normalization\n      request = (async () => {\n        let data = await poolOrDecoder.decode(this.fileDirectory, slice);\n        const sampleFormat = this.getSampleFormat();\n        const bitsPerSample = this.getBitsPerSample();\n        if (needsNormalization(sampleFormat, bitsPerSample)) {\n          data = normalizeArray(\n            data,\n            sampleFormat,\n            this.planarConfiguration,\n            this.getSamplesPerPixel(),\n            bitsPerSample,\n            this.getTileWidth(),\n            this.getBlockHeight(y),\n          );\n        }\n        return data;\n      })();\n\n      // set the cache\n      if (tiles !== null) {\n        tiles[index] = request;\n      }\n    } else {\n      // get from the cache\n      request = tiles[index];\n    }\n\n    // cache the tile request\n    return { x, y, sample, data: await request };\n  }\n\n  /**\n   * Internal read function.\n   * @private\n   * @param {Array} imageWindow The image window in pixel coordinates\n   * @param {Array} samples The selected samples (0-based indices)\n   * @param {TypedArray|TypedArray[]} valueArrays The array(s) to write into\n   * @param {Boolean} interleave Whether or not to write in an interleaved manner\n   * @param {import(\"./geotiff\").Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {number} width the width of window to be read into\n   * @param {number} height the height of window to be read into\n   * @param {number} resampleMethod the resampling method to be used when interpolating\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise<ReadRasterResult>}\n   */\n  async _readRaster(imageWindow, samples, valueArrays, interleave, poolOrDecoder, width,\n    height, resampleMethod, signal) {\n    const tileWidth = this.getTileWidth();\n    const tileHeight = this.getTileHeight();\n    const imageWidth = this.getWidth();\n    const imageHeight = this.getHeight();\n\n    const minXTile = Math.max(Math.floor(imageWindow[0] / tileWidth), 0);\n    const maxXTile = Math.min(\n      Math.ceil(imageWindow[2] / tileWidth),\n      Math.ceil(imageWidth / tileWidth),\n    );\n    const minYTile = Math.max(Math.floor(imageWindow[1] / tileHeight), 0);\n    const maxYTile = Math.min(\n      Math.ceil(imageWindow[3] / tileHeight),\n      Math.ceil(imageHeight / tileHeight),\n    );\n    const windowWidth = imageWindow[2] - imageWindow[0];\n\n    let bytesPerPixel = this.getBytesPerPixel();\n\n    const srcSampleOffsets = [];\n    const sampleReaders = [];\n    for (let i = 0; i < samples.length; ++i) {\n      if (this.planarConfiguration === 1) {\n        srcSampleOffsets.push(sum(this.fileDirectory.BitsPerSample, 0, samples[i]) / 8);\n      } else {\n        srcSampleOffsets.push(0);\n      }\n      sampleReaders.push(this.getReaderForSample(samples[i]));\n    }\n\n    const promises = [];\n    const { littleEndian } = this;\n\n    for (let yTile = minYTile; yTile < maxYTile; ++yTile) {\n      for (let xTile = minXTile; xTile < maxXTile; ++xTile) {\n        let getPromise;\n        if (this.planarConfiguration === 1) {\n          getPromise = this.getTileOrStrip(xTile, yTile, 0, poolOrDecoder, signal);\n        }\n        for (let sampleIndex = 0; sampleIndex < samples.length; ++sampleIndex) {\n          const si = sampleIndex;\n          const sample = samples[sampleIndex];\n          if (this.planarConfiguration === 2) {\n            bytesPerPixel = this.getSampleByteSize(sample);\n            getPromise = this.getTileOrStrip(xTile, yTile, sample, poolOrDecoder, signal);\n          }\n          const promise = getPromise.then((tile) => {\n            const buffer = tile.data;\n            const dataView = new DataView(buffer);\n            const blockHeight = this.getBlockHeight(tile.y);\n            const firstLine = tile.y * tileHeight;\n            const firstCol = tile.x * tileWidth;\n            const lastLine = firstLine + blockHeight;\n            const lastCol = (tile.x + 1) * tileWidth;\n            const reader = sampleReaders[si];\n\n            const ymax = Math.min(blockHeight, blockHeight - (lastLine - imageWindow[3]), imageHeight - firstLine);\n            const xmax = Math.min(tileWidth, tileWidth - (lastCol - imageWindow[2]), imageWidth - firstCol);\n\n            for (let y = Math.max(0, imageWindow[1] - firstLine); y < ymax; ++y) {\n              for (let x = Math.max(0, imageWindow[0] - firstCol); x < xmax; ++x) {\n                const pixelOffset = ((y * tileWidth) + x) * bytesPerPixel;\n                const value = reader.call(\n                  dataView, pixelOffset + srcSampleOffsets[si], littleEndian,\n                );\n                let windowCoordinate;\n                if (interleave) {\n                  windowCoordinate = ((y + firstLine - imageWindow[1]) * windowWidth * samples.length)\n                    + ((x + firstCol - imageWindow[0]) * samples.length)\n                    + si;\n                  valueArrays[windowCoordinate] = value;\n                } else {\n                  windowCoordinate = (\n                    (y + firstLine - imageWindow[1]) * windowWidth\n                  ) + x + firstCol - imageWindow[0];\n                  valueArrays[si][windowCoordinate] = value;\n                }\n              }\n            }\n          });\n          promises.push(promise);\n        }\n      }\n    }\n    await Promise.all(promises);\n\n    if ((width && (imageWindow[2] - imageWindow[0]) !== width)\n        || (height && (imageWindow[3] - imageWindow[1]) !== height)) {\n      let resampled;\n      if (interleave) {\n        resampled = resampleInterleaved(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          samples.length,\n          resampleMethod,\n        );\n      } else {\n        resampled = resample(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          resampleMethod,\n        );\n      }\n      resampled.width = width;\n      resampled.height = height;\n      return resampled;\n    }\n\n    valueArrays.width = width || imageWindow[2] - imageWindow[0];\n    valueArrays.height = height || imageWindow[3] - imageWindow[1];\n\n    return valueArrays;\n  }\n\n  /**\n   * Reads raster data from the image. This function reads all selected samples\n   * into separate arrays of the correct type for that sample or into a single\n   * combined array when `interleave` is set. When provided, only a subset\n   * of the raster is read for each sample.\n   *\n   * @param {ReadRasterOptions} [options={}] optional parameters\n   * @returns {Promise<ReadRasterResult>} the decoded arrays as a promise\n   */\n  async readRasters({\n    window: wnd, samples = [], interleave, pool = null,\n    width, height, resampleMethod, fillValue, signal,\n  } = {}) {\n    const imageWindow = wnd || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const imageWindowWidth = imageWindow[2] - imageWindow[0];\n    const imageWindowHeight = imageWindow[3] - imageWindow[1];\n    const numPixels = imageWindowWidth * imageWindowHeight;\n    const samplesPerPixel = this.getSamplesPerPixel();\n\n    if (!samples || !samples.length) {\n      for (let i = 0; i < samplesPerPixel; ++i) {\n        samples.push(i);\n      }\n    } else {\n      for (let i = 0; i < samples.length; ++i) {\n        if (samples[i] >= samplesPerPixel) {\n          return Promise.reject(new RangeError(`Invalid sample index '${samples[i]}'.`));\n        }\n      }\n    }\n    let valueArrays;\n    if (interleave) {\n      const format = this.fileDirectory.SampleFormat\n        ? Math.max.apply(null, this.fileDirectory.SampleFormat) : 1;\n      const bitsPerSample = Math.max.apply(null, this.fileDirectory.BitsPerSample);\n      valueArrays = arrayForType(format, bitsPerSample, numPixels * samples.length);\n      if (fillValue) {\n        valueArrays.fill(fillValue);\n      }\n    } else {\n      valueArrays = [];\n      for (let i = 0; i < samples.length; ++i) {\n        const valueArray = this.getArrayForSample(samples[i], numPixels);\n        if (Array.isArray(fillValue) && i < fillValue.length) {\n          valueArray.fill(fillValue[i]);\n        } else if (fillValue && !Array.isArray(fillValue)) {\n          valueArray.fill(fillValue);\n        }\n        valueArrays.push(valueArray);\n      }\n    }\n\n    const poolOrDecoder = pool || await getDecoder(this.fileDirectory);\n\n    const result = await this._readRaster(\n      imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod, signal,\n    );\n    return result;\n  }\n\n  /**\n   * Reads raster data from the image as RGB.\n   * Colorspaces other than RGB will be transformed to RGB, color maps expanded.\n   * When no other method is applicable, the first sample is used to produce a\n   * grayscale image.\n   * When provided, only a subset of the raster is read for each sample.\n   *\n   * @param {Object} [options] optional parameters\n   * @param {Array<number>} [options.window] the subset to read data from in pixels.\n   * @param {boolean} [options.interleave=true] whether the data shall be read\n   *                                             in one single array or separate\n   *                                             arrays.\n   * @param {import(\"./geotiff\").Pool} [options.pool=null] The optional decoder pool to use.\n   * @param {number} [options.width] The desired width of the output. When the width is no the\n   *                                 same as the images, resampling will be performed.\n   * @param {number} [options.height] The desired height of the output. When the width is no the\n   *                                  same as the images, resampling will be performed.\n   * @param {string} [options.resampleMethod='nearest'] The desired resampling method.\n   * @param {boolean} [options.enableAlpha=false] Enable reading alpha channel if present.\n   * @param {AbortSignal} [options.signal] An AbortSignal that may be signalled if the request is\n   *                                       to be aborted\n   * @returns {Promise<ReadRasterResult>} the RGB array as a Promise\n   */\n  async readRGB({ window, interleave = true, pool = null, width, height,\n    resampleMethod, enableAlpha = false, signal } = {}) {\n    const imageWindow = window || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const pi = this.fileDirectory.PhotometricInterpretation;\n\n    if (pi === photometricInterpretations.RGB) {\n      let s = [0, 1, 2];\n      if ((!(this.fileDirectory.ExtraSamples === ExtraSamplesValues.Unspecified)) && enableAlpha) {\n        s = [];\n        for (let i = 0; i < this.fileDirectory.BitsPerSample.length; i += 1) {\n          s.push(i);\n        }\n      }\n      return this.readRasters({\n        window,\n        interleave,\n        samples: s,\n        pool,\n        width,\n        height,\n        resampleMethod,\n        signal,\n      });\n    }\n\n    let samples;\n    switch (pi) {\n      case photometricInterpretations.WhiteIsZero:\n      case photometricInterpretations.BlackIsZero:\n      case photometricInterpretations.Palette:\n        samples = [0];\n        break;\n      case photometricInterpretations.CMYK:\n        samples = [0, 1, 2, 3];\n        break;\n      case photometricInterpretations.YCbCr:\n      case photometricInterpretations.CIELab:\n        samples = [0, 1, 2];\n        break;\n      default:\n        throw new Error('Invalid or unsupported photometric interpretation.');\n    }\n\n    const subOptions = {\n      window: imageWindow,\n      interleave: true,\n      samples,\n      pool,\n      width,\n      height,\n      resampleMethod,\n      signal,\n    };\n    const { fileDirectory } = this;\n    const raster = await this.readRasters(subOptions);\n\n    const max = 2 ** this.fileDirectory.BitsPerSample[0];\n    let data;\n    switch (pi) {\n      case photometricInterpretations.WhiteIsZero:\n        data = fromWhiteIsZero(raster, max);\n        break;\n      case photometricInterpretations.BlackIsZero:\n        data = fromBlackIsZero(raster, max);\n        break;\n      case photometricInterpretations.Palette:\n        data = fromPalette(raster, fileDirectory.ColorMap);\n        break;\n      case photometricInterpretations.CMYK:\n        data = fromCMYK(raster);\n        break;\n      case photometricInterpretations.YCbCr:\n        data = fromYCbCr(raster);\n        break;\n      case photometricInterpretations.CIELab:\n        data = fromCIELab(raster);\n        break;\n      default:\n        throw new Error('Unsupported photometric interpretation.');\n    }\n\n    // if non-interleaved data is requested, we must split the channels\n    // into their respective arrays\n    if (!interleave) {\n      const red = new Uint8Array(data.length / 3);\n      const green = new Uint8Array(data.length / 3);\n      const blue = new Uint8Array(data.length / 3);\n      for (let i = 0, j = 0; i < data.length; i += 3, ++j) {\n        red[j] = data[i];\n        green[j] = data[i + 1];\n        blue[j] = data[i + 2];\n      }\n      data = [red, green, blue];\n    }\n\n    data.width = raster.width;\n    data.height = raster.height;\n    return data;\n  }\n\n  /**\n   * Returns an array of tiepoints.\n   * @returns {Object[]}\n   */\n  getTiePoints() {\n    if (!this.fileDirectory.ModelTiepoint) {\n      return [];\n    }\n\n    const tiePoints = [];\n    for (let i = 0; i < this.fileDirectory.ModelTiepoint.length; i += 6) {\n      tiePoints.push({\n        i: this.fileDirectory.ModelTiepoint[i],\n        j: this.fileDirectory.ModelTiepoint[i + 1],\n        k: this.fileDirectory.ModelTiepoint[i + 2],\n        x: this.fileDirectory.ModelTiepoint[i + 3],\n        y: this.fileDirectory.ModelTiepoint[i + 4],\n        z: this.fileDirectory.ModelTiepoint[i + 5],\n      });\n    }\n    return tiePoints;\n  }\n\n  /**\n   * Returns the parsed GDAL metadata items.\n   *\n   * If sample is passed to null, dataset-level metadata will be returned.\n   * Otherwise only metadata specific to the provided sample will be returned.\n   *\n   * @param {number} [sample=null] The sample index.\n   * @returns {Object}\n   */\n  getGDALMetadata(sample = null) {\n    const metadata = {};\n    if (!this.fileDirectory.GDAL_METADATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_METADATA;\n\n    let items = findTagsByName(string, 'Item');\n\n    if (sample === null) {\n      items = items.filter((item) => getAttribute(item, 'sample') === undefined);\n    } else {\n      items = items.filter((item) => Number(getAttribute(item, 'sample')) === sample);\n    }\n\n    for (let i = 0; i < items.length; ++i) {\n      const item = items[i];\n      metadata[getAttribute(item, 'name')] = item.inner;\n    }\n    return metadata;\n  }\n\n  /**\n   * Returns the GDAL nodata value\n   * @returns {number|null}\n   */\n  getGDALNoData() {\n    if (!this.fileDirectory.GDAL_NODATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_NODATA;\n    return Number(string.substring(0, string.length - 1));\n  }\n\n  /**\n   * Returns the image origin as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @returns {Array<number>} The origin as a vector\n   */\n  getOrigin() {\n    const tiePoints = this.fileDirectory.ModelTiepoint;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n    if (tiePoints && tiePoints.length === 6) {\n      return [\n        tiePoints[3],\n        tiePoints[4],\n        tiePoints[5],\n      ];\n    }\n    if (modelTransformation) {\n      return [\n        modelTransformation[3],\n        modelTransformation[7],\n        modelTransformation[11],\n      ];\n    }\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns the image resolution as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @param {GeoTIFFImage} [referenceImage=null] A reference image to calculate the resolution from\n   *                                             in cases when the current image does not have the\n   *                                             required tags on its own.\n   * @returns {Array<number>} The resolution as a vector\n   */\n  getResolution(referenceImage = null) {\n    const modelPixelScale = this.fileDirectory.ModelPixelScale;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n\n    if (modelPixelScale) {\n      return [\n        modelPixelScale[0],\n        -modelPixelScale[1],\n        modelPixelScale[2],\n      ];\n    }\n    if (modelTransformation) {\n      if (modelTransformation[1] === 0 && modelTransformation[4] === 0) {\n        return [\n          modelTransformation[0],\n          -modelTransformation[5],\n          modelTransformation[10],\n        ];\n      }\n      return [\n        Math.sqrt((modelTransformation[0] * modelTransformation[0])\n          + (modelTransformation[4] * modelTransformation[4])),\n        -Math.sqrt((modelTransformation[1] * modelTransformation[1])\n          + (modelTransformation[5] * modelTransformation[5])),\n        modelTransformation[10]];\n    }\n\n    if (referenceImage) {\n      const [refResX, refResY, refResZ] = referenceImage.getResolution();\n      return [\n        refResX * referenceImage.getWidth() / this.getWidth(),\n        refResY * referenceImage.getHeight() / this.getHeight(),\n        refResZ * referenceImage.getWidth() / this.getWidth(),\n      ];\n    }\n\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns whether or not the pixels of the image depict an area (or point).\n   * @returns {Boolean} Whether the pixels are a point\n   */\n  pixelIsArea() {\n    return this.geoKeys.GTRasterTypeGeoKey === 1;\n  }\n\n  /**\n   * Returns the image bounding box as an array of 4 values: min-x, min-y,\n   * max-x and max-y. When the image has no affine transformation, then an\n   * exception is thrown.\n   * @param {boolean} [tilegrid=false] If true return extent for a tilegrid\n   *                                   without adjustment for ModelTransformation.\n   * @returns {Array<number>} The bounding box\n   */\n  getBoundingBox(tilegrid = false) {\n    const height = this.getHeight();\n    const width = this.getWidth();\n\n    if (this.fileDirectory.ModelTransformation && !tilegrid) {\n      // eslint-disable-next-line no-unused-vars\n      const [a, b, c, d, e, f, g, h] = this.fileDirectory.ModelTransformation;\n\n      const corners = [\n        [0, 0],\n        [0, height],\n        [width, 0],\n        [width, height],\n      ];\n\n      const projected = corners.map(([I, J]) => [\n        d + (a * I) + (b * J),\n        h + (e * I) + (f * J),\n      ]);\n\n      const xs = projected.map((pt) => pt[0]);\n      const ys = projected.map((pt) => pt[1]);\n\n      return [\n        Math.min(...xs),\n        Math.min(...ys),\n        Math.max(...xs),\n        Math.max(...ys),\n      ];\n    } else {\n      const origin = this.getOrigin();\n      const resolution = this.getResolution();\n\n      const x1 = origin[0];\n      const y1 = origin[1];\n\n      const x2 = x1 + (resolution[0] * width);\n      const y2 = y1 + (resolution[1] * height);\n\n      return [\n        Math.min(x1, x2),\n        Math.min(y1, y2),\n        Math.max(x1, x2),\n        Math.max(y1, y2),\n      ];\n    }\n  }\n}\n\nexport default GeoTIFFImage;\n","import { getFloat16 } from '@petamoriken/float16';\n\nexport default class DataView64 {\n  constructor(arrayBuffer) {\n    this._dataView = new DataView(arrayBuffer);\n  }\n\n  get buffer() {\n    return this._dataView.buffer;\n  }\n\n  getUint64(offset, littleEndian) {\n    const left = this.getUint32(offset, littleEndian);\n    const right = this.getUint32(offset + 4, littleEndian);\n    let combined;\n    if (littleEndian) {\n      combined = left + ((2 ** 32) * right);\n      if (!Number.isSafeInteger(combined)) {\n        throw new Error(\n          `${combined} exceeds MAX_SAFE_INTEGER. `\n          + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n        );\n      }\n      return combined;\n    }\n    combined = ((2 ** 32) * left) + right;\n    if (!Number.isSafeInteger(combined)) {\n      throw new Error(\n        `${combined} exceeds MAX_SAFE_INTEGER. `\n        + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n      );\n    }\n\n    return combined;\n  }\n\n  // adapted from https://stackoverflow.com/a/55338384/8060591\n  getInt64(offset, littleEndian) {\n    let value = 0;\n    const isNegative = (this._dataView.getUint8(offset + (littleEndian ? 7 : 0)) & 0x80) > 0;\n    let carrying = true;\n    for (let i = 0; i < 8; i++) {\n      let byte = this._dataView.getUint8(offset + (littleEndian ? i : 7 - i));\n      if (isNegative) {\n        if (carrying) {\n          if (byte !== 0x00) {\n            byte = ~(byte - 1) & 0xff;\n            carrying = false;\n          }\n        } else {\n          byte = ~byte & 0xff;\n        }\n      }\n      value += byte * (256 ** i);\n    }\n    if (isNegative) {\n      value = -value;\n    }\n    return value;\n  }\n\n  getUint8(offset, littleEndian) {\n    return this._dataView.getUint8(offset, littleEndian);\n  }\n\n  getInt8(offset, littleEndian) {\n    return this._dataView.getInt8(offset, littleEndian);\n  }\n\n  getUint16(offset, littleEndian) {\n    return this._dataView.getUint16(offset, littleEndian);\n  }\n\n  getInt16(offset, littleEndian) {\n    return this._dataView.getInt16(offset, littleEndian);\n  }\n\n  getUint32(offset, littleEndian) {\n    return this._dataView.getUint32(offset, littleEndian);\n  }\n\n  getInt32(offset, littleEndian) {\n    return this._dataView.getInt32(offset, littleEndian);\n  }\n\n  getFloat16(offset, littleEndian) {\n    return getFloat16(this._dataView, offset, littleEndian);\n  }\n\n  getFloat32(offset, littleEndian) {\n    return this._dataView.getFloat32(offset, littleEndian);\n  }\n\n  getFloat64(offset, littleEndian) {\n    return this._dataView.getFloat64(offset, littleEndian);\n  }\n}\n","export default class DataSlice {\n  constructor(arrayBuffer, sliceOffset, littleEndian, bigTiff) {\n    this._dataView = new DataView(arrayBuffer);\n    this._sliceOffset = sliceOffset;\n    this._littleEndian = littleEndian;\n    this._bigTiff = bigTiff;\n  }\n\n  get sliceOffset() {\n    return this._sliceOffset;\n  }\n\n  get sliceTop() {\n    return this._sliceOffset + this.buffer.byteLength;\n  }\n\n  get littleEndian() {\n    return this._littleEndian;\n  }\n\n  get bigTiff() {\n    return this._bigTiff;\n  }\n\n  get buffer() {\n    return this._dataView.buffer;\n  }\n\n  covers(offset, length) {\n    return this.sliceOffset <= offset && this.sliceTop >= offset + length;\n  }\n\n  readUint8(offset) {\n    return this._dataView.getUint8(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt8(offset) {\n    return this._dataView.getInt8(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint16(offset) {\n    return this._dataView.getUint16(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt16(offset) {\n    return this._dataView.getInt16(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint32(offset) {\n    return this._dataView.getUint32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt32(offset) {\n    return this._dataView.getInt32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readFloat32(offset) {\n    return this._dataView.getFloat32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readFloat64(offset) {\n    return this._dataView.getFloat64(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint64(offset) {\n    const left = this.readUint32(offset);\n    const right = this.readUint32(offset + 4);\n    let combined;\n    if (this._littleEndian) {\n      combined = left + ((2 ** 32) * right);\n      if (!Number.isSafeInteger(combined)) {\n        throw new Error(\n          `${combined} exceeds MAX_SAFE_INTEGER. `\n          + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n        );\n      }\n      return combined;\n    }\n    combined = ((2 ** 32) * left) + right;\n    if (!Number.isSafeInteger(combined)) {\n      throw new Error(\n        `${combined} exceeds MAX_SAFE_INTEGER. `\n        + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n      );\n    }\n\n    return combined;\n  }\n\n  // adapted from https://stackoverflow.com/a/55338384/8060591\n  readInt64(offset) {\n    let value = 0;\n    const isNegative = (this._dataView.getUint8(offset + (this._littleEndian ? 7 : 0)) & 0x80)\n      > 0;\n    let carrying = true;\n    for (let i = 0; i < 8; i++) {\n      let byte = this._dataView.getUint8(\n        offset + (this._littleEndian ? i : 7 - i),\n      );\n      if (isNegative) {\n        if (carrying) {\n          if (byte !== 0x00) {\n            byte = ~(byte - 1) & 0xff;\n            carrying = false;\n          }\n        } else {\n          byte = ~byte & 0xff;\n        }\n      }\n      value += byte * (256 ** i);\n    }\n    if (isNegative) {\n      value = -value;\n    }\n    return value;\n  }\n\n  readOffset(offset) {\n    if (this._bigTiff) {\n      return this.readUint64(offset);\n    }\n    return this.readUint32(offset);\n  }\n}\n","const CRLFCRLF = '\\r\\n\\r\\n';\n\n/*\n * Shim for 'Object.fromEntries'\n */\nfunction itemsToObject(items) {\n  if (typeof Object.fromEntries !== 'undefined') {\n    return Object.fromEntries(items);\n  }\n  const obj = {};\n  for (const [key, value] of items) {\n    obj[key.toLowerCase()] = value;\n  }\n  return obj;\n}\n\n/**\n * Parse HTTP headers from a given string.\n * @param {String} text the text to parse the headers from\n * @returns {Object} the parsed headers with lowercase keys\n */\nfunction parseHeaders(text) {\n  const items = text\n    .split('\\r\\n')\n    .map((line) => {\n      const kv = line.split(':').map((str) => str.trim());\n      kv[0] = kv[0].toLowerCase();\n      return kv;\n    });\n\n  return itemsToObject(items);\n}\n\n/**\n * Parse a 'Content-Type' header value to the content-type and parameters\n * @param {String} rawContentType the raw string to parse from\n * @returns {Object} the parsed content type with the fields: type and params\n */\nexport function parseContentType(rawContentType) {\n  const [type, ...rawParams] = rawContentType.split(';').map((s) => s.trim());\n  const paramsItems = rawParams.map((param) => param.split('='));\n  return { type, params: itemsToObject(paramsItems) };\n}\n\n/**\n * Parse a 'Content-Range' header value to its start, end, and total parts\n * @param {String} rawContentRange the raw string to parse from\n * @returns {Object} the parsed parts\n */\nexport function parseContentRange(rawContentRange) {\n  let start;\n  let end;\n  let total;\n\n  if (rawContentRange) {\n    [, start, end, total] = rawContentRange.match(/bytes (\\d+)-(\\d+)\\/(\\d+)/);\n    start = parseInt(start, 10);\n    end = parseInt(end, 10);\n    total = parseInt(total, 10);\n  }\n\n  return { start, end, total };\n}\n\n/**\n * Parses a list of byteranges from the given 'multipart/byteranges' HTTP response.\n * Each item in the list has the following properties:\n * - headers: the HTTP headers\n * - data: the sliced ArrayBuffer for that specific part\n * - offset: the offset of the byterange within its originating file\n * - length: the length of the byterange\n * @param {ArrayBuffer} responseArrayBuffer the response to be parsed and split\n * @param {String} boundary the boundary string used to split the sections\n * @returns {Object[]} the parsed byteranges\n */\nexport function parseByteRanges(responseArrayBuffer, boundary) {\n  let offset = null;\n  const decoder = new TextDecoder('ascii');\n  const out = [];\n\n  const startBoundary = `--${boundary}`;\n  const endBoundary = `${startBoundary}--`;\n\n  // search for the initial boundary, may be offset by some bytes\n  // TODO: more efficient to check for `--` in bytes directly\n  for (let i = 0; i < 10; ++i) {\n    const text = decoder.decode(\n      new Uint8Array(responseArrayBuffer, i, startBoundary.length),\n    );\n    if (text === startBoundary) {\n      offset = i;\n    }\n  }\n\n  if (offset === null) {\n    throw new Error('Could not find initial boundary');\n  }\n\n  while (offset < responseArrayBuffer.byteLength) {\n    const text = decoder.decode(\n      new Uint8Array(responseArrayBuffer, offset,\n        Math.min(startBoundary.length + 1024, responseArrayBuffer.byteLength - offset),\n      ),\n    );\n\n    // break if we arrived at the end\n    if (text.length === 0 || text.startsWith(endBoundary)) {\n      break;\n    }\n\n    // assert that we are actually dealing with a byterange and are at the correct offset\n    if (!text.startsWith(startBoundary)) {\n      throw new Error('Part does not start with boundary');\n    }\n\n    // get a substring from where we read the headers\n    const innerText = text.substr(startBoundary.length + 2);\n\n    if (innerText.length === 0) {\n      break;\n    }\n\n    // find the double linebreak that denotes the end of the headers\n    const endOfHeaders = innerText.indexOf(CRLFCRLF);\n\n    // parse the headers to get the content range size\n    const headers = parseHeaders(innerText.substr(0, endOfHeaders));\n    const { start, end, total } = parseContentRange(headers['content-range']);\n\n    // calculate the length of the slice and the next offset\n    const startOfData = offset + startBoundary.length + endOfHeaders + CRLFCRLF.length;\n    const length = parseInt(end, 10) + 1 - parseInt(start, 10);\n    out.push({\n      headers,\n      data: responseArrayBuffer.slice(startOfData, startOfData + length),\n      offset: start,\n      length,\n      fileSize: total,\n    });\n\n    offset = startOfData + length + 4;\n  }\n\n  return out;\n}\n","/**\n * @typedef Slice\n * @property {number} offset\n * @property {number} length\n */\n\nexport class BaseSource {\n  /**\n   *\n   * @param {Slice[]} slices\n   * @returns {ArrayBuffer[]}\n   */\n  async fetch(slices, signal = undefined) {\n    return Promise.all(\n      slices.map((slice) => this.fetchSlice(slice, signal)),\n    );\n  }\n\n  /**\n   *\n   * @param {Slice} slice\n   * @returns {ArrayBuffer}\n   */\n  async fetchSlice(slice) {\n    throw new Error(`fetching of slice ${slice} not possible, not implemented`);\n  }\n\n  /**\n   * Returns the filesize if already determined and null otherwise\n   */\n  get fileSize() {\n    return null;\n  }\n\n  async close() {\n    // no-op by default\n  }\n}\n","export function assign(target, source) {\n  for (const key in source) {\n    if (source.hasOwnProperty(key)) {\n      target[key] = source[key];\n    }\n  }\n}\n\nexport function chunk(iterable, length) {\n  const results = [];\n  const lengthOfIterable = iterable.length;\n  for (let i = 0; i < lengthOfIterable; i += length) {\n    const chunked = [];\n    for (let ci = i; ci < i + length; ci++) {\n      chunked.push(iterable[ci]);\n    }\n    results.push(chunked);\n  }\n  return results;\n}\n\nexport function endsWith(string, expectedEnding) {\n  if (string.length < expectedEnding.length) {\n    return false;\n  }\n  const actualEnding = string.substr(string.length - expectedEnding.length);\n  return actualEnding === expectedEnding;\n}\n\nexport function forEach(iterable, func) {\n  const { length } = iterable;\n  for (let i = 0; i < length; i++) {\n    func(iterable[i], i);\n  }\n}\n\nexport function invert(oldObj) {\n  const newObj = {};\n  for (const key in oldObj) {\n    if (oldObj.hasOwnProperty(key)) {\n      const value = oldObj[key];\n      newObj[value] = key;\n    }\n  }\n  return newObj;\n}\n\nexport function range(n) {\n  const results = [];\n  for (let i = 0; i < n; i++) {\n    results.push(i);\n  }\n  return results;\n}\n\nexport function times(numTimes, func) {\n  const results = [];\n  for (let i = 0; i < numTimes; i++) {\n    results.push(func(i));\n  }\n  return results;\n}\n\nexport function toArray(iterable) {\n  const results = [];\n  const { length } = iterable;\n  for (let i = 0; i < length; i++) {\n    results.push(iterable[i]);\n  }\n  return results;\n}\n\nexport function toArrayRecursively(input) {\n  if (input.length) {\n    return toArray(input).map(toArrayRecursively);\n  }\n  return input;\n}\n\n// copied from https://github.com/academia-de-codigo/parse-content-range-header/blob/master/index.js\nexport function parseContentRange(headerValue) {\n  if (!headerValue) {\n    return null;\n  }\n\n  if (typeof headerValue !== 'string') {\n    throw new Error('invalid argument');\n  }\n\n  const parseInt = (number) => Number.parseInt(number, 10);\n\n  // Check for presence of unit\n  let matches = headerValue.match(/^(\\w*) /);\n  const unit = matches && matches[1];\n\n  // check for start-end/size header format\n  matches = headerValue.match(/(\\d+)-(\\d+)\\/(\\d+|\\*)/);\n  if (matches) {\n    return {\n      unit,\n      first: parseInt(matches[1]),\n      last: parseInt(matches[2]),\n      length: matches[3] === '*' ? null : parseInt(matches[3]),\n    };\n  }\n\n  // check for size header format\n  matches = headerValue.match(/(\\d+|\\*)/);\n  if (matches) {\n    return {\n      unit,\n      first: null,\n      last: null,\n      length: matches[1] === '*' ? null : parseInt(matches[1]),\n    };\n  }\n\n  return null;\n}\n\n/*\n * Promisified wrapper around 'setTimeout' to allow 'await'\n */\nexport async function wait(milliseconds) {\n  return new Promise((resolve) => setTimeout(resolve, milliseconds));\n}\n\nexport function zip(a, b) {\n  const A = Array.isArray(a) ? a : Array.from(a);\n  const B = Array.isArray(b) ? b : Array.from(b);\n  return A.map((k, i) => [k, B[i]]);\n}\n\n// Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error\nexport class AbortError extends Error {\n  constructor(params) {\n    // Pass remaining arguments (including vendor specific ones) to parent constructor\n    super(params);\n\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AbortError);\n    }\n\n    this.name = 'AbortError';\n  }\n}\n\nexport class CustomAggregateError extends Error {\n  constructor(errors, message) {\n    super(message);\n    this.errors = errors;\n    this.message = message;\n    this.name = 'AggregateError';\n  }\n}\n\nexport const AggregateError = CustomAggregateError;\n\nexport function isTypedFloatArray(input) {\n  if (ArrayBuffer.isView(input)) {\n    const ctr = input.constructor;\n    if (ctr === Float32Array || ctr === Float64Array) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function isTypedIntArray(input) {\n  if (ArrayBuffer.isView(input)) {\n    const ctr = input.constructor;\n    if (ctr === Int8Array || ctr === Int16Array || ctr === Int32Array) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function isTypedUintArray(input) {\n  if (ArrayBuffer.isView(input)) {\n    const ctr = input.constructor;\n    if (ctr === Uint8Array || ctr === Uint16Array || ctr === Uint32Array || ctr === Uint8ClampedArray) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport const typeMap = {\n  Float64Array,\n  Float32Array,\n  Uint32Array,\n  Uint16Array,\n  Uint8Array,\n};\n","import QuickLRU from 'quick-lru';\nimport { BaseSource } from './basesource.js';\nimport { AbortError, AggregateError, wait, zip } from '../utils.js';\n\nclass Block {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {ArrayBuffer} [data]\n   */\n  constructor(offset, length, data = null) {\n    this.offset = offset;\n    this.length = length;\n    this.data = data;\n  }\n\n  /**\n   * @returns {number} the top byte border\n   */\n  get top() {\n    return this.offset + this.length;\n  }\n}\n\nclass BlockGroup {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {number[]} blockIds\n   */\n  constructor(offset, length, blockIds) {\n    this.offset = offset;\n    this.length = length;\n    this.blockIds = blockIds;\n  }\n}\n\nexport class BlockedSource extends BaseSource {\n  /**\n   *\n   * @param {BaseSource} source The underlying source that shall be blocked and cached\n   * @param {object} options\n   * @param {number} [options.blockSize]\n   * @param {number} [options.cacheSize]\n   */\n  constructor(source, { blockSize = 65536, cacheSize = 100 } = {}) {\n    super();\n    this.source = source;\n    this.blockSize = blockSize;\n\n    this.blockCache = new QuickLRU({\n      maxSize: cacheSize,\n      onEviction: (blockId, block) => {\n        this.evictedBlocks.set(blockId, block);\n      },\n    });\n\n    /** @type {Map<number, Block>} */\n    this.evictedBlocks = new Map();\n\n    // mapping blockId -> Block instance\n    this.blockRequests = new Map();\n\n    // set of blockIds missing for the current requests\n    this.blockIdsToFetch = new Set();\n\n    this.abortedBlockIds = new Set();\n  }\n\n  get fileSize() {\n    return this.source.fileSize;\n  }\n\n  /**\n   *\n   * @param {import(\"./basesource\").Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    const blockRequests = [];\n    const missingBlockIds = [];\n    const allBlockIds = [];\n    this.evictedBlocks.clear();\n\n    for (const { offset, length } of slices) {\n      let top = offset + length;\n\n      const { fileSize } = this;\n      if (fileSize !== null) {\n        top = Math.min(top, fileSize);\n      }\n\n      const firstBlockOffset = Math.floor(offset / this.blockSize) * this.blockSize;\n\n      for (let current = firstBlockOffset; current < top; current += this.blockSize) {\n        const blockId = Math.floor(current / this.blockSize);\n        if (!this.blockCache.has(blockId) && !this.blockRequests.has(blockId)) {\n          this.blockIdsToFetch.add(blockId);\n          missingBlockIds.push(blockId);\n        }\n        if (this.blockRequests.has(blockId)) {\n          blockRequests.push(this.blockRequests.get(blockId));\n        }\n        allBlockIds.push(blockId);\n      }\n    }\n\n    // allow additional block requests to accumulate\n    await wait();\n    this.fetchBlocks(signal);\n\n    // Gather all of the new requests that this fetch call is contributing to `fetch`.\n    const missingRequests = [];\n    for (const blockId of missingBlockIds) {\n      // The requested missing block could already be in the cache\n      // instead of having its request still be outstanding.\n      if (this.blockRequests.has(blockId)) {\n        missingRequests.push(this.blockRequests.get(blockId));\n      }\n    }\n\n    // Actually await all pending requests that are needed for this `fetch`.\n    await Promise.allSettled(blockRequests);\n    await Promise.allSettled(missingRequests);\n\n    // Perform retries if a block was interrupted by a previous signal\n    const abortedBlockRequests = [];\n    const abortedBlockIds = allBlockIds\n      .filter((id) => this.abortedBlockIds.has(id) || !this.blockCache.has(id));\n    abortedBlockIds.forEach((id) => this.blockIdsToFetch.add(id));\n    // start the retry of some blocks if required\n    if (abortedBlockIds.length > 0 && signal && !signal.aborted) {\n      this.fetchBlocks(null);\n      for (const blockId of abortedBlockIds) {\n        const block = this.blockRequests.get(blockId);\n        if (!block) {\n          throw new Error(`Block ${blockId} is not in the block requests`);\n        }\n        abortedBlockRequests.push(block);\n      }\n      await Promise.allSettled(abortedBlockRequests);\n    }\n\n    // throw an  abort error\n    if (signal && signal.aborted) {\n      throw new AbortError('Request was aborted');\n    }\n\n    const blocks = allBlockIds.map((id) => this.blockCache.get(id) || this.evictedBlocks.get(id));\n    const failedBlocks = blocks.filter((i) => !i);\n    if (failedBlocks.length) {\n      throw new AggregateError(failedBlocks, 'Request failed');\n    }\n\n    // create a final Map, with all required blocks for this request to satisfy\n    const requiredBlocks = new Map(zip(allBlockIds, blocks));\n\n    // TODO: satisfy each slice\n    return this.readSliceData(slices, requiredBlocks);\n  }\n\n  /**\n   *\n   * @param {AbortSignal} signal\n   */\n  fetchBlocks(signal) {\n    // check if we still need to\n    if (this.blockIdsToFetch.size > 0) {\n      const groups = this.groupBlocks(this.blockIdsToFetch);\n\n      // start requesting slices of data\n      const groupRequests = this.source.fetch(groups, signal);\n\n      for (let groupIndex = 0; groupIndex < groups.length; ++groupIndex) {\n        const group = groups[groupIndex];\n\n        for (const blockId of group.blockIds) {\n          // make an async IIFE for each block\n          this.blockRequests.set(blockId, (async () => {\n            try {\n              const response = (await groupRequests)[groupIndex];\n              const blockOffset = blockId * this.blockSize;\n              const o = blockOffset - response.offset;\n              const t = Math.min(o + this.blockSize, response.data.byteLength);\n              const data = response.data.slice(o, t);\n              const block = new Block(\n                blockOffset,\n                data.byteLength,\n                data,\n                blockId,\n              );\n              this.blockCache.set(blockId, block);\n              this.abortedBlockIds.delete(blockId);\n            } catch (err) {\n              if (err.name === 'AbortError') {\n                // store the signal here, we need it to determine later if an\n                // error was caused by this signal\n                err.signal = signal;\n                this.blockCache.delete(blockId);\n                this.abortedBlockIds.add(blockId);\n              } else {\n                throw err;\n              }\n            } finally {\n              this.blockRequests.delete(blockId);\n            }\n          })());\n        }\n      }\n      this.blockIdsToFetch.clear();\n    }\n  }\n\n  /**\n   *\n   * @param {Set} blockIds\n   * @returns {BlockGroup[]}\n   */\n  groupBlocks(blockIds) {\n    const sortedBlockIds = Array.from(blockIds).sort((a, b) => a - b);\n    if (sortedBlockIds.length === 0) {\n      return [];\n    }\n    let current = [];\n    let lastBlockId = null;\n    const groups = [];\n\n    for (const blockId of sortedBlockIds) {\n      if (lastBlockId === null || lastBlockId + 1 === blockId) {\n        current.push(blockId);\n        lastBlockId = blockId;\n      } else {\n        groups.push(new BlockGroup(\n          current[0] * this.blockSize,\n          current.length * this.blockSize,\n          current,\n        ));\n        current = [blockId];\n        lastBlockId = blockId;\n      }\n    }\n\n    groups.push(new BlockGroup(\n      current[0] * this.blockSize,\n      current.length * this.blockSize,\n      current,\n    ));\n\n    return groups;\n  }\n\n  /**\n   *\n   * @param {import(\"./basesource\").Slice[]} slices\n   * @param {Map} blocks\n   */\n  readSliceData(slices, blocks) {\n    return slices.map((slice) => {\n      let top = slice.offset + slice.length;\n      if (this.fileSize !== null) {\n        top = Math.min(this.fileSize, top);\n      }\n      const blockIdLow = Math.floor(slice.offset / this.blockSize);\n      const blockIdHigh = Math.floor(top / this.blockSize);\n      const sliceData = new ArrayBuffer(slice.length);\n      const sliceView = new Uint8Array(sliceData);\n\n      for (let blockId = blockIdLow; blockId <= blockIdHigh; ++blockId) {\n        const block = blocks.get(blockId);\n        const delta = block.offset - slice.offset;\n        const topDelta = block.top - top;\n        let blockInnerOffset = 0;\n        let rangeInnerOffset = 0;\n        let usedBlockLength;\n\n        if (delta < 0) {\n          blockInnerOffset = -delta;\n        } else if (delta > 0) {\n          rangeInnerOffset = delta;\n        }\n\n        if (topDelta < 0) {\n          usedBlockLength = block.length - blockInnerOffset;\n        } else {\n          usedBlockLength = top - block.offset - blockInnerOffset;\n        }\n\n        const blockView = new Uint8Array(block.data, blockInnerOffset, usedBlockLength);\n        sliceView.set(blockView, rangeInnerOffset);\n      }\n\n      return sliceData;\n    });\n  }\n}\n","export class BaseResponse {\n  /**\n   * Returns whether the response has an ok'ish status code\n   */\n  get ok() {\n    return this.status >= 200 && this.status <= 299;\n  }\n\n  /**\n   * Returns the status code of the response\n   */\n  get status() {\n    throw new Error('not implemented');\n  }\n\n  /**\n   * Returns the value of the specified header\n   * @param {string} headerName the header name\n   * @returns {string} the header value\n   */\n  getHeader(headerName) { // eslint-disable-line no-unused-vars\n    throw new Error('not implemented');\n  }\n\n  /**\n   * @returns {ArrayBuffer} the response data of the request\n   */\n  async getData() {\n    throw new Error('not implemented');\n  }\n}\n\nexport class BaseClient {\n  constructor(url) {\n    this.url = url;\n  }\n\n  /**\n   * Send a request with the options\n   * @param {{headers: HeadersInit, signal: AbortSignal}} [options={}]\n   * @returns {Promise<BaseResponse>}\n   */\n  async request({ headers, signal } = {}) { // eslint-disable-line no-unused-vars\n    throw new Error('request is not implemented');\n  }\n}\n","import { BaseClient, BaseResponse } from './base.js';\n\nclass FetchResponse extends BaseResponse {\n  /**\n   * BaseResponse facade for fetch API Response\n   * @param {Response} response\n   */\n  constructor(response) {\n    super();\n    this.response = response;\n  }\n\n  get status() {\n    return this.response.status;\n  }\n\n  getHeader(name) {\n    return this.response.headers.get(name);\n  }\n\n  async getData() {\n    const data = this.response.arrayBuffer\n      ? await this.response.arrayBuffer()\n      : (await this.response.buffer()).buffer;\n    return data;\n  }\n}\n\nexport class FetchClient extends BaseClient {\n  constructor(url, credentials) {\n    super(url);\n    this.credentials = credentials;\n  }\n\n  /**\n   * @param {{headers: HeadersInit, signal: AbortSignal}} [options={}]\n   * @returns {Promise<FetchResponse>}\n   */\n  async request({ headers, signal } = {}) {\n    const response = await fetch(this.url, {\n      headers, credentials: this.credentials, signal,\n    });\n    return new FetchResponse(response);\n  }\n}\n","import { BaseClient, BaseResponse } from './base.js';\nimport { AbortError } from '../../utils.js';\n\nclass XHRResponse extends BaseResponse {\n  /**\n   * BaseResponse facade for XMLHttpRequest\n   * @param {XMLHttpRequest} xhr\n   * @param {ArrayBuffer} data\n   */\n  constructor(xhr, data) {\n    super();\n    this.xhr = xhr;\n    this.data = data;\n  }\n\n  get status() {\n    return this.xhr.status;\n  }\n\n  getHeader(name) {\n    return this.xhr.getResponseHeader(name);\n  }\n\n  async getData() {\n    return this.data;\n  }\n}\n\nexport class XHRClient extends BaseClient {\n  constructRequest(headers, signal) {\n    return new Promise((resolve, reject) => {\n      const xhr = new XMLHttpRequest();\n      xhr.open('GET', this.url);\n      xhr.responseType = 'arraybuffer';\n      for (const [key, value] of Object.entries(headers)) {\n        xhr.setRequestHeader(key, value);\n      }\n\n      // hook signals\n      xhr.onload = () => {\n        const data = xhr.response;\n        resolve(new XHRResponse(xhr, data));\n      };\n      xhr.onerror = reject;\n      xhr.onabort = () => reject(new AbortError('Request aborted'));\n      xhr.send();\n\n      if (signal) {\n        if (signal.aborted) {\n          xhr.abort();\n        }\n        signal.addEventListener('abort', () => xhr.abort());\n      }\n    });\n  }\n\n  async request({ headers, signal } = {}) {\n    const response = await this.constructRequest(headers, signal);\n    return response;\n  }\n}\n","import http from 'http';\nimport https from 'https';\nimport urlMod from 'url';\n\nimport { BaseClient, BaseResponse } from './base.js';\nimport { AbortError } from '../../utils.js';\n\nclass HttpResponse extends BaseResponse {\n  /**\n   * BaseResponse facade for node HTTP/HTTPS API Response\n   * @param {http.ServerResponse} response\n   */\n  constructor(response, dataPromise) {\n    super();\n    this.response = response;\n    this.dataPromise = dataPromise;\n  }\n\n  get status() {\n    return this.response.statusCode;\n  }\n\n  getHeader(name) {\n    return this.response.headers[name];\n  }\n\n  async getData() {\n    const data = await this.dataPromise;\n    return data;\n  }\n}\n\nexport class HttpClient extends BaseClient {\n  constructor(url) {\n    super(url);\n    this.parsedUrl = urlMod.parse(this.url);\n    this.httpApi = (this.parsedUrl.protocol === 'http:' ? http : https);\n  }\n\n  constructRequest(headers, signal) {\n    return new Promise((resolve, reject) => {\n      const request = this.httpApi.get(\n        {\n          ...this.parsedUrl,\n          headers,\n        },\n        (response) => {\n          const dataPromise = new Promise((resolveData) => {\n            const chunks = [];\n\n            // collect chunks\n            response.on('data', (chunk) => {\n              chunks.push(chunk);\n            });\n\n            // concatenate all chunks and resolve the promise with the resulting buffer\n            response.on('end', () => {\n              const data = Buffer.concat(chunks).buffer;\n              resolveData(data);\n            });\n            response.on('error', reject);\n          });\n          resolve(new HttpResponse(response, dataPromise));\n        },\n      );\n      request.on('error', reject);\n\n      if (signal) {\n        if (signal.aborted) {\n          request.destroy(new AbortError('Request aborted'));\n        }\n        signal.addEventListener('abort', () => request.destroy(new AbortError('Request aborted')));\n      }\n    });\n  }\n\n  async request({ headers, signal } = {}) {\n    const response = await this.constructRequest(headers, signal);\n    return response;\n  }\n}\n","import { parseByteRanges, parseContentRange, parseContentType } from './httputils.js';\nimport { BaseSource } from './basesource.js';\nimport { BlockedSource } from './blockedsource.js';\n\nimport { FetchClient } from './client/fetch.js';\nimport { XHRClient } from './client/xhr.js';\nimport { HttpClient } from './client/http.js';\n\nclass RemoteSource extends BaseSource {\n  /**\n   *\n   * @param {BaseClient} client\n   * @param {object} headers\n   * @param {numbers} maxRanges\n   * @param {boolean} allowFullFile\n   */\n  constructor(client, headers, maxRanges, allowFullFile) {\n    super();\n    this.client = client;\n    this.headers = headers;\n    this.maxRanges = maxRanges;\n    this.allowFullFile = allowFullFile;\n    this._fileSize = null;\n  }\n\n  /**\n   *\n   * @param {Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    // if we allow multi-ranges, split the incoming request into that many sub-requests\n    // and join them afterwards\n    if (this.maxRanges >= slices.length) {\n      return this.fetchSlices(slices, signal);\n    } else if (this.maxRanges > 0 && slices.length > 1) {\n      // TODO: split into multiple multi-range requests\n\n      // const subSlicesRequests = [];\n      // for (let i = 0; i < slices.length; i += this.maxRanges) {\n      //   subSlicesRequests.push(\n      //     this.fetchSlices(slices.slice(i, i + this.maxRanges), signal),\n      //   );\n      // }\n      // return (await Promise.all(subSlicesRequests)).flat();\n    }\n\n    // otherwise make a single request for each slice\n    return Promise.all(\n      slices.map((slice) => this.fetchSlice(slice, signal)),\n    );\n  }\n\n  async fetchSlices(slices, signal) {\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${slices\n          .map(({ offset, length }) => `${offset}-${offset + length}`)\n          .join(',')\n        }`,\n      },\n      signal,\n    });\n\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const { type, params } = parseContentType(response.getHeader('content-type'));\n      if (type === 'multipart/byteranges') {\n        const byteRanges = parseByteRanges(await response.getData(), params.boundary);\n        this._fileSize = byteRanges[0].fileSize || null;\n        return byteRanges;\n      }\n\n      const data = await response.getData();\n\n      const { start, end, total } = parseContentRange(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      const first = [{\n        data,\n        offset: start,\n        length: end - start,\n      }];\n\n      if (slices.length > 1) {\n        // we requested more than one slice, but got only the first\n        // unfortunately, some HTTP Servers don't support multi-ranges\n        // and return only the first\n\n        // get the rest of the slices and fetch them iteratively\n        const others = await Promise.all(slices.slice(1).map((slice) => this.fetchSlice(slice, signal)));\n        return first.concat(others);\n      }\n      return first;\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n      const data = await response.getData();\n      this._fileSize = data.byteLength;\n      return [{\n        data,\n        offset: 0,\n        length: data.byteLength,\n      }];\n    }\n  }\n\n  async fetchSlice(slice, signal) {\n    const { offset, length } = slice;\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${offset}-${offset + length}`,\n      },\n      signal,\n    });\n\n    // check the response was okay and if the server actually understands range requests\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const data = await response.getData();\n\n      const { total } = parseContentRange(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      return {\n        data,\n        offset,\n        length,\n      };\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n\n      const data = await response.getData();\n\n      this._fileSize = data.byteLength;\n      return {\n        data,\n        offset: 0,\n        length: data.byteLength,\n      };\n    }\n  }\n\n  get fileSize() {\n    return this._fileSize;\n  }\n}\n\nfunction maybeWrapInBlockedSource(source, { blockSize, cacheSize }) {\n  if (blockSize === null) {\n    return source;\n  }\n  return new BlockedSource(source, { blockSize, cacheSize });\n}\n\nexport function makeFetchSource(url, { headers = {}, credentials, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new FetchClient(url, credentials);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nexport function makeXHRSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new XHRClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nexport function makeHttpSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new HttpClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nexport function makeCustomSource(client, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\n/**\n *\n * @param {string} url\n * @param {object} options\n */\nexport function makeRemoteSource(url, { forceXHR = false, ...clientOptions } = {}) {\n  if (typeof fetch === 'function' && !forceXHR) {\n    return makeFetchSource(url, clientOptions);\n  }\n  if (typeof XMLHttpRequest !== 'undefined') {\n    return makeXHRSource(url, clientOptions);\n  }\n  return makeHttpSource(url, clientOptions);\n}\n","import { BaseSource } from './basesource.js';\n\nclass FileReaderSource extends BaseSource {\n  constructor(file) {\n    super();\n    this.file = file;\n  }\n\n  async fetchSlice(slice, signal) {\n    return new Promise((resolve, reject) => {\n      const blob = this.file.slice(slice.offset, slice.offset + slice.length);\n      const reader = new FileReader();\n      reader.onload = (event) => resolve(event.target.result);\n      reader.onerror = reject;\n      reader.onabort = reject;\n      reader.readAsArrayBuffer(blob);\n\n      if (signal) {\n        signal.addEventListener('abort', () => reader.abort());\n      }\n    });\n  }\n}\n\n/**\n * Create a new source from a given file/blob.\n * @param {Blob} file The file or blob to read from.\n * @returns The constructed source\n */\nexport function makeFileReaderSource(file) {\n  return new FileReaderSource(file);\n}\n","/** @module geotiff */\nimport GeoTIFFImage from './geotiffimage.js';\nimport DataView64 from './dataview64.js';\nimport DataSlice from './dataslice.js';\nimport Pool from './pool.js';\n\nimport { makeRemoteSource, makeCustomSource } from './source/remote.js';\nimport { makeBufferSource } from './source/arraybuffer.js';\nimport { makeFileReaderSource } from './source/filereader.js';\nimport { makeFileSource } from './source/file.js';\nimport { BaseClient, BaseResponse } from './source/client/base.js';\n\nimport { fieldTypes, fieldTagNames, arrayFields, geoKeyNames } from './globals.js';\nimport { writeGeotiff } from './geotiffwriter.js';\nimport * as globals from './globals.js';\nimport * as rgb from './rgb.js';\nimport { getDecoder, addDecoder } from './compression/index.js';\nimport { setLogger } from './logging.js';\n\nexport { globals };\nexport { rgb };\nexport { default as BaseDecoder } from './compression/basedecoder.js';\nexport { getDecoder, addDecoder };\nexport { setLogger };\n\n/**\n * @typedef {Uint8Array | Int8Array | Uint16Array | Int16Array | Uint32Array | Int32Array | Float32Array | Float64Array}\n * TypedArray\n */\n\n/**\n * @typedef {{ height:number, width: number }} Dimensions\n */\n\n/**\n * The autogenerated docs are a little confusing here. The effective type is:\n *\n * `TypedArray & { height: number; width: number}`\n * @typedef {TypedArray & Dimensions} TypedArrayWithDimensions\n */\n\n/**\n * The autogenerated docs are a little confusing here. The effective type is:\n *\n * `TypedArray[] & { height: number; width: number}`\n * @typedef {TypedArray[] & Dimensions} TypedArrayArrayWithDimensions\n */\n\n/**\n *  The autogenerated docs are a little confusing here. The effective type is:\n *\n * `(TypedArray | TypedArray[]) & { height: number; width: number}`\n * @typedef {TypedArrayWithDimensions | TypedArrayArrayWithDimensions} ReadRasterResult\n */\n\nfunction getFieldTypeLength(fieldType) {\n  switch (fieldType) {\n    case fieldTypes.BYTE: case fieldTypes.ASCII: case fieldTypes.SBYTE: case fieldTypes.UNDEFINED:\n      return 1;\n    case fieldTypes.SHORT: case fieldTypes.SSHORT:\n      return 2;\n    case fieldTypes.LONG: case fieldTypes.SLONG: case fieldTypes.FLOAT: case fieldTypes.IFD:\n      return 4;\n    case fieldTypes.RATIONAL: case fieldTypes.SRATIONAL: case fieldTypes.DOUBLE:\n    case fieldTypes.LONG8: case fieldTypes.SLONG8: case fieldTypes.IFD8:\n      return 8;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n}\n\nfunction parseGeoKeyDirectory(fileDirectory) {\n  const rawGeoKeyDirectory = fileDirectory.GeoKeyDirectory;\n  if (!rawGeoKeyDirectory) {\n    return null;\n  }\n\n  const geoKeyDirectory = {};\n  for (let i = 4; i <= rawGeoKeyDirectory[3] * 4; i += 4) {\n    const key = geoKeyNames[rawGeoKeyDirectory[i]];\n    const location = (rawGeoKeyDirectory[i + 1])\n      ? (fieldTagNames[rawGeoKeyDirectory[i + 1]]) : null;\n    const count = rawGeoKeyDirectory[i + 2];\n    const offset = rawGeoKeyDirectory[i + 3];\n\n    let value = null;\n    if (!location) {\n      value = offset;\n    } else {\n      value = fileDirectory[location];\n      if (typeof value === 'undefined' || value === null) {\n        throw new Error(`Could not get value of geoKey '${key}'.`);\n      } else if (typeof value === 'string') {\n        value = value.substring(offset, offset + count - 1);\n      } else if (value.subarray) {\n        value = value.subarray(offset, offset + count);\n        if (count === 1) {\n          value = value[0];\n        }\n      }\n    }\n    geoKeyDirectory[key] = value;\n  }\n  return geoKeyDirectory;\n}\n\nfunction getValues(dataSlice, fieldType, count, offset) {\n  let values = null;\n  let readMethod = null;\n  const fieldTypeLength = getFieldTypeLength(fieldType);\n\n  switch (fieldType) {\n    case fieldTypes.BYTE: case fieldTypes.ASCII: case fieldTypes.UNDEFINED:\n      values = new Uint8Array(count); readMethod = dataSlice.readUint8;\n      break;\n    case fieldTypes.SBYTE:\n      values = new Int8Array(count); readMethod = dataSlice.readInt8;\n      break;\n    case fieldTypes.SHORT:\n      values = new Uint16Array(count); readMethod = dataSlice.readUint16;\n      break;\n    case fieldTypes.SSHORT:\n      values = new Int16Array(count); readMethod = dataSlice.readInt16;\n      break;\n    case fieldTypes.LONG: case fieldTypes.IFD:\n      values = new Uint32Array(count); readMethod = dataSlice.readUint32;\n      break;\n    case fieldTypes.SLONG:\n      values = new Int32Array(count); readMethod = dataSlice.readInt32;\n      break;\n    case fieldTypes.LONG8: case fieldTypes.IFD8:\n      values = new Array(count); readMethod = dataSlice.readUint64;\n      break;\n    case fieldTypes.SLONG8:\n      values = new Array(count); readMethod = dataSlice.readInt64;\n      break;\n    case fieldTypes.RATIONAL:\n      values = new Uint32Array(count * 2); readMethod = dataSlice.readUint32;\n      break;\n    case fieldTypes.SRATIONAL:\n      values = new Int32Array(count * 2); readMethod = dataSlice.readInt32;\n      break;\n    case fieldTypes.FLOAT:\n      values = new Float32Array(count); readMethod = dataSlice.readFloat32;\n      break;\n    case fieldTypes.DOUBLE:\n      values = new Float64Array(count); readMethod = dataSlice.readFloat64;\n      break;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n\n  // normal fields\n  if (!(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {\n    for (let i = 0; i < count; ++i) {\n      values[i] = readMethod.call(\n        dataSlice, offset + (i * fieldTypeLength),\n      );\n    }\n  } else { // RATIONAL or SRATIONAL\n    for (let i = 0; i < count; i += 2) {\n      values[i] = readMethod.call(\n        dataSlice, offset + (i * fieldTypeLength),\n      );\n      values[i + 1] = readMethod.call(\n        dataSlice, offset + ((i * fieldTypeLength) + 4),\n      );\n    }\n  }\n\n  if (fieldType === fieldTypes.ASCII) {\n    return new TextDecoder('utf-8').decode(values);\n  }\n  return values;\n}\n\n/**\n * Data class to store the parsed file directory (+ its raw form), geo key directory and\n * offset to the next IFD\n */\nclass ImageFileDirectory {\n  /**\n   * Create an ImageFileDirectory.\n   * @param {object} fileDirectory the file directory, mapping tag names to values\n   * @param {Map} rawFileDirectory the raw file directory, mapping tag IDs to values\n   * @param {object} geoKeyDirectory the geo key directory, mapping geo key names to values\n   * @param {number} nextIFDByteOffset the byte offset to the next IFD\n   */\n  constructor(fileDirectory, rawFileDirectory, geoKeyDirectory, nextIFDByteOffset) {\n    this.fileDirectory = fileDirectory;\n    this.rawFileDirectory = rawFileDirectory;\n    this.geoKeyDirectory = geoKeyDirectory;\n    this.nextIFDByteOffset = nextIFDByteOffset;\n  }\n}\n\n/**\n * Error class for cases when an IFD index was requested, that does not exist\n * in the file.\n */\nclass GeoTIFFImageIndexError extends Error {\n  constructor(index) {\n    super(`No image at index ${index}`);\n    this.index = index;\n  }\n}\n\nclass GeoTIFFBase {\n  /**\n   * (experimental) Reads raster data from the best fitting image. This function uses\n   * the image with the lowest resolution that is still a higher resolution than the\n   * requested resolution.\n   * When specified, the `bbox` option is translated to the `window` option and the\n   * `resX` and `resY` to `width` and `height` respectively.\n   * Then, the [readRasters]{@link GeoTIFFImage#readRasters} method of the selected\n   * image is called and the result returned.\n   * @see GeoTIFFImage.readRasters\n   * @param {import('./geotiffimage').ReadRasterOptions} [options={}] optional parameters\n   * @returns {Promise<ReadRasterResult>} the decoded array(s), with `height` and `width`, as a promise\n   */\n  async readRasters(options = {}) {\n    const { window: imageWindow, width, height } = options;\n    let { resX, resY, bbox } = options;\n\n    const firstImage = await this.getImage();\n    let usedImage = firstImage;\n    const imageCount = await this.getImageCount();\n    const imgBBox = firstImage.getBoundingBox();\n\n    if (imageWindow && bbox) {\n      throw new Error('Both \"bbox\" and \"window\" passed.');\n    }\n\n    // if width/height is passed, transform it to resolution\n    if (width || height) {\n      // if we have an image window (pixel coordinates), transform it to a BBox\n      // using the origin/resolution of the first image.\n      if (imageWindow) {\n        const [oX, oY] = firstImage.getOrigin();\n        const [rX, rY] = firstImage.getResolution();\n\n        bbox = [\n          oX + (imageWindow[0] * rX),\n          oY + (imageWindow[1] * rY),\n          oX + (imageWindow[2] * rX),\n          oY + (imageWindow[3] * rY),\n        ];\n      }\n\n      // if we have a bbox (or calculated one)\n\n      const usedBBox = bbox || imgBBox;\n\n      if (width) {\n        if (resX) {\n          throw new Error('Both width and resX passed');\n        }\n        resX = (usedBBox[2] - usedBBox[0]) / width;\n      }\n      if (height) {\n        if (resY) {\n          throw new Error('Both width and resY passed');\n        }\n        resY = (usedBBox[3] - usedBBox[1]) / height;\n      }\n    }\n\n    // if resolution is set or calculated, try to get the image with the worst acceptable resolution\n    if (resX || resY) {\n      const allImages = [];\n      for (let i = 0; i < imageCount; ++i) {\n        const image = await this.getImage(i);\n        const { SubfileType: subfileType, NewSubfileType: newSubfileType } = image.fileDirectory;\n        if (i === 0 || subfileType === 2 || newSubfileType & 1) {\n          allImages.push(image);\n        }\n      }\n\n      allImages.sort((a, b) => a.getWidth() - b.getWidth());\n      for (let i = 0; i < allImages.length; ++i) {\n        const image = allImages[i];\n        const imgResX = (imgBBox[2] - imgBBox[0]) / image.getWidth();\n        const imgResY = (imgBBox[3] - imgBBox[1]) / image.getHeight();\n\n        usedImage = image;\n        if ((resX && resX > imgResX) || (resY && resY > imgResY)) {\n          break;\n        }\n      }\n    }\n\n    let wnd = imageWindow;\n    if (bbox) {\n      const [oX, oY] = firstImage.getOrigin();\n      const [imageResX, imageResY] = usedImage.getResolution(firstImage);\n\n      wnd = [\n        Math.round((bbox[0] - oX) / imageResX),\n        Math.round((bbox[1] - oY) / imageResY),\n        Math.round((bbox[2] - oX) / imageResX),\n        Math.round((bbox[3] - oY) / imageResY),\n      ];\n      wnd = [\n        Math.min(wnd[0], wnd[2]),\n        Math.min(wnd[1], wnd[3]),\n        Math.max(wnd[0], wnd[2]),\n        Math.max(wnd[1], wnd[3]),\n      ];\n    }\n\n    return usedImage.readRasters({ ...options, window: wnd });\n  }\n}\n\n/**\n * @typedef {Object} GeoTIFFOptions\n * @property {boolean} [cache=false] whether or not decoded tiles shall be cached.\n */\n\n/**\n * The abstraction for a whole GeoTIFF file.\n * @augments GeoTIFFBase\n */\nclass GeoTIFF extends GeoTIFFBase {\n  /**\n   * @constructor\n   * @param {*} source The datasource to read from.\n   * @param {boolean} littleEndian Whether the image uses little endian.\n   * @param {boolean} bigTiff Whether the image uses bigTIFF conventions.\n   * @param {number} firstIFDOffset The numeric byte-offset from the start of the image\n   *                                to the first IFD.\n   * @param {GeoTIFFOptions} [options] further options.\n   */\n  constructor(source, littleEndian, bigTiff, firstIFDOffset, options = {}) {\n    super();\n    this.source = source;\n    this.littleEndian = littleEndian;\n    this.bigTiff = bigTiff;\n    this.firstIFDOffset = firstIFDOffset;\n    this.cache = options.cache || false;\n    this.ifdRequests = [];\n    this.ghostValues = null;\n  }\n\n  async getSlice(offset, size) {\n    const fallbackSize = this.bigTiff ? 4048 : 1024;\n    return new DataSlice(\n      (await this.source.fetch([{\n        offset,\n        length: typeof size !== 'undefined' ? size : fallbackSize,\n      }]))[0],\n      offset,\n      this.littleEndian,\n      this.bigTiff,\n    );\n  }\n\n  /**\n   * Instructs to parse an image file directory at the given file offset.\n   * As there is no way to ensure that a location is indeed the start of an IFD,\n   * this function must be called with caution (e.g only using the IFD offsets from\n   * the headers or other IFDs).\n   * @param {number} offset the offset to parse the IFD at\n   * @returns {Promise<ImageFileDirectory>} the parsed IFD\n   */\n  async parseFileDirectoryAt(offset) {\n    const entrySize = this.bigTiff ? 20 : 12;\n    const offsetSize = this.bigTiff ? 8 : 2;\n\n    let dataSlice = await this.getSlice(offset);\n    const numDirEntries = this.bigTiff\n      ? dataSlice.readUint64(offset)\n      : dataSlice.readUint16(offset);\n\n    // if the slice does not cover the whole IFD, request a bigger slice, where the\n    // whole IFD fits: num of entries + n x tag length + offset to next IFD\n    const byteSize = (numDirEntries * entrySize) + (this.bigTiff ? 16 : 6);\n    if (!dataSlice.covers(offset, byteSize)) {\n      dataSlice = await this.getSlice(offset, byteSize);\n    }\n\n    const fileDirectory = {};\n    const rawFileDirectory = new Map();\n\n    // loop over the IFD and create a file directory object\n    let i = offset + (this.bigTiff ? 8 : 2);\n    for (let entryCount = 0; entryCount < numDirEntries; i += entrySize, ++entryCount) {\n      const fieldTag = dataSlice.readUint16(i);\n      const fieldType = dataSlice.readUint16(i + 2);\n      const typeCount = this.bigTiff\n        ? dataSlice.readUint64(i + 4)\n        : dataSlice.readUint32(i + 4);\n\n      let fieldValues;\n      let value;\n      const fieldTypeLength = getFieldTypeLength(fieldType);\n      const valueOffset = i + (this.bigTiff ? 12 : 8);\n\n      // check whether the value is directly encoded in the tag or refers to a\n      // different external byte range\n      if (fieldTypeLength * typeCount <= (this.bigTiff ? 8 : 4)) {\n        fieldValues = getValues(dataSlice, fieldType, typeCount, valueOffset);\n      } else {\n        // resolve the reference to the actual byte range\n        const actualOffset = dataSlice.readOffset(valueOffset);\n        const length = getFieldTypeLength(fieldType) * typeCount;\n\n        // check, whether we actually cover the referenced byte range; if not,\n        // request a new slice of bytes to read from it\n        if (dataSlice.covers(actualOffset, length)) {\n          fieldValues = getValues(dataSlice, fieldType, typeCount, actualOffset);\n        } else {\n          const fieldDataSlice = await this.getSlice(actualOffset, length);\n          fieldValues = getValues(fieldDataSlice, fieldType, typeCount, actualOffset);\n        }\n      }\n\n      // unpack single values from the array\n      if (typeCount === 1 && arrayFields.indexOf(fieldTag) === -1\n        && !(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {\n        value = fieldValues[0];\n      } else {\n        value = fieldValues;\n      }\n\n      // write the tags value to the file directory\n      const tagName = fieldTagNames[fieldTag];\n      if (tagName) {\n        fileDirectory[tagName] = value;\n      }\n      rawFileDirectory.set(fieldTag, value);\n    }\n    const geoKeyDirectory = parseGeoKeyDirectory(fileDirectory);\n    const nextIFDByteOffset = dataSlice.readOffset(\n      offset + offsetSize + (entrySize * numDirEntries),\n    );\n\n    return new ImageFileDirectory(\n      fileDirectory,\n      rawFileDirectory,\n      geoKeyDirectory,\n      nextIFDByteOffset,\n    );\n  }\n\n  async requestIFD(index) {\n    // see if we already have that IFD index requested.\n    if (this.ifdRequests[index]) {\n      // attach to an already requested IFD\n      return this.ifdRequests[index];\n    } else if (index === 0) {\n      // special case for index 0\n      this.ifdRequests[index] = this.parseFileDirectoryAt(this.firstIFDOffset);\n      return this.ifdRequests[index];\n    } else if (!this.ifdRequests[index - 1]) {\n      // if the previous IFD was not yet loaded, load that one first\n      // this is the recursive call.\n      try {\n        this.ifdRequests[index - 1] = this.requestIFD(index - 1);\n      } catch (e) {\n        // if the previous one already was an index error, rethrow\n        // with the current index\n        if (e instanceof GeoTIFFImageIndexError) {\n          throw new GeoTIFFImageIndexError(index);\n        }\n        // rethrow anything else\n        throw e;\n      }\n    }\n    // if the previous IFD was loaded, we can finally fetch the one we are interested in.\n    // we need to wrap this in an IIFE, otherwise this.ifdRequests[index] would be delayed\n    this.ifdRequests[index] = (async () => {\n      const previousIfd = await this.ifdRequests[index - 1];\n      if (previousIfd.nextIFDByteOffset === 0) {\n        throw new GeoTIFFImageIndexError(index);\n      }\n      return this.parseFileDirectoryAt(previousIfd.nextIFDByteOffset);\n    })();\n    return this.ifdRequests[index];\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {number} [index=0] the index of the image to return.\n   * @returns {Promise<GeoTIFFImage>} the image at the given index\n   */\n  async getImage(index = 0) {\n    const ifd = await this.requestIFD(index);\n    return new GeoTIFFImage(\n      ifd.fileDirectory, ifd.geoKeyDirectory,\n      this.dataView, this.littleEndian, this.cache, this.source,\n    );\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Promise<number>} the number of internal subfile images\n   */\n  async getImageCount() {\n    let index = 0;\n    // loop until we run out of IFDs\n    let hasNext = true;\n    while (hasNext) {\n      try {\n        await this.requestIFD(index);\n        ++index;\n      } catch (e) {\n        if (e instanceof GeoTIFFImageIndexError) {\n          hasNext = false;\n        } else {\n          throw e;\n        }\n      }\n    }\n    return index;\n  }\n\n  /**\n   * Get the values of the COG ghost area as a parsed map.\n   * See https://gdal.org/drivers/raster/cog.html#header-ghost-area for reference\n   * @returns {Promise<Object>} the parsed ghost area or null, if no such area was found\n   */\n  async getGhostValues() {\n    const offset = this.bigTiff ? 16 : 8;\n    if (this.ghostValues) {\n      return this.ghostValues;\n    }\n    const detectionString = 'GDAL_STRUCTURAL_METADATA_SIZE=';\n    const heuristicAreaSize = detectionString.length + 100;\n    let slice = await this.getSlice(offset, heuristicAreaSize);\n    if (detectionString === getValues(slice, fieldTypes.ASCII, detectionString.length, offset)) {\n      const valuesString = getValues(slice, fieldTypes.ASCII, heuristicAreaSize, offset);\n      const firstLine = valuesString.split('\\n')[0];\n      const metadataSize = Number(firstLine.split('=')[1].split(' ')[0]) + firstLine.length;\n      if (metadataSize > heuristicAreaSize) {\n        slice = await this.getSlice(offset, metadataSize);\n      }\n      const fullString = getValues(slice, fieldTypes.ASCII, metadataSize, offset);\n      this.ghostValues = {};\n      fullString\n        .split('\\n')\n        .filter((line) => line.length > 0)\n        .map((line) => line.split('='))\n        .forEach(([key, value]) => {\n          this.ghostValues[key] = value;\n        });\n    }\n    return this.ghostValues;\n  }\n\n  /**\n   * Parse a (Geo)TIFF file from the given source.\n   *\n   * @param {*} source The source of data to parse from.\n   * @param {GeoTIFFOptions} [options] Additional options.\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   */\n  static async fromSource(source, options, signal) {\n    const headerData = (await source.fetch([{ offset: 0, length: 1024 }], signal))[0];\n    const dataView = new DataView64(headerData);\n\n    const BOM = dataView.getUint16(0, 0);\n    let littleEndian;\n    if (BOM === 0x4949) {\n      littleEndian = true;\n    } else if (BOM === 0x4D4D) {\n      littleEndian = false;\n    } else {\n      throw new TypeError('Invalid byte order value.');\n    }\n\n    const magicNumber = dataView.getUint16(2, littleEndian);\n    let bigTiff;\n    if (magicNumber === 42) {\n      bigTiff = false;\n    } else if (magicNumber === 43) {\n      bigTiff = true;\n      const offsetByteSize = dataView.getUint16(4, littleEndian);\n      if (offsetByteSize !== 8) {\n        throw new Error('Unsupported offset byte-size.');\n      }\n    } else {\n      throw new TypeError('Invalid magic number.');\n    }\n\n    const firstIFDOffset = bigTiff\n      ? dataView.getUint64(8, littleEndian)\n      : dataView.getUint32(4, littleEndian);\n    return new GeoTIFF(source, littleEndian, bigTiff, firstIFDOffset, options);\n  }\n\n  /**\n   * Closes the underlying file buffer\n   * N.B. After the GeoTIFF has been completely processed it needs\n   * to be closed but only if it has been constructed from a file.\n   */\n  close() {\n    if (typeof this.source.close === 'function') {\n      return this.source.close();\n    }\n    return false;\n  }\n}\n\nexport { GeoTIFF };\nexport default GeoTIFF;\n\n/**\n * Wrapper for GeoTIFF files that have external overviews.\n * @augments GeoTIFFBase\n */\nclass MultiGeoTIFF extends GeoTIFFBase {\n  /**\n   * Construct a new MultiGeoTIFF from a main and several overview files.\n   * @param {GeoTIFF} mainFile The main GeoTIFF file.\n   * @param {GeoTIFF[]} overviewFiles An array of overview files.\n   */\n  constructor(mainFile, overviewFiles) {\n    super();\n    this.mainFile = mainFile;\n    this.overviewFiles = overviewFiles;\n    this.imageFiles = [mainFile].concat(overviewFiles);\n\n    this.fileDirectoriesPerFile = null;\n    this.fileDirectoriesPerFileParsing = null;\n    this.imageCount = null;\n  }\n\n  async parseFileDirectoriesPerFile() {\n    const requests = [this.mainFile.parseFileDirectoryAt(this.mainFile.firstIFDOffset)]\n      .concat(this.overviewFiles.map((file) => file.parseFileDirectoryAt(file.firstIFDOffset)));\n\n    this.fileDirectoriesPerFile = await Promise.all(requests);\n    return this.fileDirectoriesPerFile;\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {number} [index=0] the index of the image to return.\n   * @returns {Promise<GeoTIFFImage>} the image at the given index\n   */\n  async getImage(index = 0) {\n    await this.getImageCount();\n    await this.parseFileDirectoriesPerFile();\n    let visited = 0;\n    let relativeIndex = 0;\n    for (let i = 0; i < this.imageFiles.length; i++) {\n      const imageFile = this.imageFiles[i];\n      for (let ii = 0; ii < this.imageCounts[i]; ii++) {\n        if (index === visited) {\n          const ifd = await imageFile.requestIFD(relativeIndex);\n          return new GeoTIFFImage(\n            ifd.fileDirectory, ifd.geoKeyDirectory,\n            imageFile.dataView, imageFile.littleEndian, imageFile.cache, imageFile.source,\n          );\n        }\n        visited++;\n        relativeIndex++;\n      }\n      relativeIndex = 0;\n    }\n\n    throw new RangeError('Invalid image index');\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Promise<number>} the number of internal subfile images\n   */\n  async getImageCount() {\n    if (this.imageCount !== null) {\n      return this.imageCount;\n    }\n    const requests = [this.mainFile.getImageCount()]\n      .concat(this.overviewFiles.map((file) => file.getImageCount()));\n    this.imageCounts = await Promise.all(requests);\n    this.imageCount = this.imageCounts.reduce((count, ifds) => count + ifds, 0);\n    return this.imageCount;\n  }\n}\n\nexport { MultiGeoTIFF };\n\n/**\n * Creates a new GeoTIFF from a remote URL.\n * @param {string} url The URL to access the image from\n * @param {object} [options] Additional options to pass to the source.\n *                           See {@link makeRemoteSource} for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromUrl(url, options = {}, signal) {\n  return GeoTIFF.fromSource(makeRemoteSource(url, options), signal);\n}\n\n/**\n * Creates a new GeoTIFF from a custom {@link BaseClient}.\n * @param {BaseClient} client The client.\n * @param {object} [options] Additional options to pass to the source.\n *                           See {@link makeRemoteSource} for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromCustomClient(client, options = {}, signal) {\n  return GeoTIFF.fromSource(makeCustomSource(client, options), signal);\n}\n\n/**\n * Construct a new GeoTIFF from an\n * [ArrayBuffer]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer}.\n * @param {ArrayBuffer} arrayBuffer The data to read the file from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromArrayBuffer(arrayBuffer, signal) {\n  return GeoTIFF.fromSource(makeBufferSource(arrayBuffer), signal);\n}\n\n/**\n * Construct a GeoTIFF from a local file path. This uses the node\n * [filesystem API]{@link https://nodejs.org/api/fs.html} and is\n * not available on browsers.\n *\n * N.B. After the GeoTIFF has been completely processed it needs\n * to be closed but only if it has been constructed from a file.\n * @param {string} path The file path to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromFile(path, signal) {\n  return GeoTIFF.fromSource(makeFileSource(path), signal);\n}\n\n/**\n * Construct a GeoTIFF from an HTML\n * [Blob]{@link https://developer.mozilla.org/en-US/docs/Web/API/Blob} or\n * [File]{@link https://developer.mozilla.org/en-US/docs/Web/API/File}\n * object.\n * @param {Blob|File} blob The Blob or File object to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromBlob(blob, signal) {\n  return GeoTIFF.fromSource(makeFileReaderSource(blob), signal);\n}\n\n/**\n * Construct a MultiGeoTIFF from the given URLs.\n * @param {string} mainUrl The URL for the main file.\n * @param {string[]} overviewUrls An array of URLs for the overview images.\n * @param {Object} [options] Additional options to pass to the source.\n *                           See [makeRemoteSource]{@link module:source.makeRemoteSource}\n *                           for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<MultiGeoTIFF>} The resulting MultiGeoTIFF file.\n */\nexport async function fromUrls(mainUrl, overviewUrls = [], options = {}, signal) {\n  const mainFile = await GeoTIFF.fromSource(makeRemoteSource(mainUrl, options), signal);\n  const overviewFiles = await Promise.all(\n    overviewUrls.map((url) => GeoTIFF.fromSource(makeRemoteSource(url, options))),\n  );\n\n  return new MultiGeoTIFF(mainFile, overviewFiles);\n}\n\n/**\n * Main creating function for GeoTIFF files.\n * @param {(Array)} array of pixel values\n * @returns {metadata} metadata\n */\nexport function writeArrayBuffer(values, metadata) {\n  return writeGeotiff(values, metadata);\n}\n\nexport { Pool };\nexport { GeoTIFFImage };\nexport { BaseClient, BaseResponse };\n","'use strict';\n\n/** @type {import('./shams')} */\n/* eslint complexity: [2, 18], max-statements: [2, 33] */\nmodule.exports = function hasSymbols() {\n\tif (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }\n\tif (typeof Symbol.iterator === 'symbol') { return true; }\n\n\t/** @type {{ [k in symbol]?: unknown }} */\n\tvar obj = {};\n\tvar sym = Symbol('test');\n\tvar symObj = Object(sym);\n\tif (typeof sym === 'string') { return false; }\n\n\tif (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }\n\tif (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }\n\n\t// temp disabled per https://github.com/ljharb/object.assign/issues/17\n\t// if (sym instanceof Symbol) { return false; }\n\t// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4\n\t// if (!(symObj instanceof Symbol)) { return false; }\n\n\t// if (typeof Symbol.prototype.toString !== 'function') { return false; }\n\t// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }\n\n\tvar symVal = 42;\n\tobj[sym] = symVal;\n\tfor (var _ in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop\n\tif (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }\n\n\tif (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }\n\n\tvar syms = Object.getOwnPropertySymbols(obj);\n\tif (syms.length !== 1 || syms[0] !== sym) { return false; }\n\n\tif (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }\n\n\tif (typeof Object.getOwnPropertyDescriptor === 'function') {\n\t\t// eslint-disable-next-line no-extra-parens\n\t\tvar descriptor = /** @type {PropertyDescriptor} */ (Object.getOwnPropertyDescriptor(obj, sym));\n\t\tif (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }\n\t}\n\n\treturn true;\n};\n","'use strict';\n\n/** @type {import('./Reflect.getPrototypeOf')} */\nmodule.exports = (typeof Reflect !== 'undefined' && Reflect.getPrototypeOf) || null;\n","'use strict';\n\nvar origSymbol = typeof Symbol !== 'undefined' && Symbol;\nvar hasSymbolSham = require('./shams');\n\n/** @type {import('.')} */\nmodule.exports = function hasNativeSymbols() {\n\tif (typeof origSymbol !== 'function') { return false; }\n\tif (typeof Symbol !== 'function') { return false; }\n\tif (typeof origSymbol('foo') !== 'symbol') { return false; }\n\tif (typeof Symbol('bar') !== 'symbol') { return false; }\n\n\treturn hasSymbolSham();\n};\n","'use strict';\n\nvar undefined;\n\nvar $Object = require('es-object-atoms');\n\nvar $Error = require('es-errors');\nvar $EvalError = require('es-errors/eval');\nvar $RangeError = require('es-errors/range');\nvar $ReferenceError = require('es-errors/ref');\nvar $SyntaxError = require('es-errors/syntax');\nvar $TypeError = require('es-errors/type');\nvar $URIError = require('es-errors/uri');\n\nvar abs = require('math-intrinsics/abs');\nvar floor = require('math-intrinsics/floor');\nvar max = require('math-intrinsics/max');\nvar min = require('math-intrinsics/min');\nvar pow = require('math-intrinsics/pow');\nvar round = require('math-intrinsics/round');\nvar sign = require('math-intrinsics/sign');\n\nvar $Function = Function;\n\n// eslint-disable-next-line consistent-return\nvar getEvalledConstructor = function (expressionSyntax) {\n\ttry {\n\t\treturn $Function('\"use strict\"; return (' + expressionSyntax + ').constructor;')();\n\t} catch (e) {}\n};\n\nvar $gOPD = require('gopd');\nvar $defineProperty = require('es-define-property');\n\nvar throwTypeError = function () {\n\tthrow new $TypeError();\n};\nvar ThrowTypeError = $gOPD\n\t? (function () {\n\t\ttry {\n\t\t\t// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties\n\t\t\targuments.callee; // IE 8 does not throw here\n\t\t\treturn throwTypeError;\n\t\t} catch (calleeThrows) {\n\t\t\ttry {\n\t\t\t\t// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')\n\t\t\t\treturn $gOPD(arguments, 'callee').get;\n\t\t\t} catch (gOPDthrows) {\n\t\t\t\treturn throwTypeError;\n\t\t\t}\n\t\t}\n\t}())\n\t: throwTypeError;\n\nvar hasSymbols = require('has-symbols')();\n\nvar getProto = require('get-proto');\nvar $ObjectGPO = require('get-proto/Object.getPrototypeOf');\nvar $ReflectGPO = require('get-proto/Reflect.getPrototypeOf');\n\nvar $apply = require('call-bind-apply-helpers/functionApply');\nvar $call = require('call-bind-apply-helpers/functionCall');\n\nvar needsEval = {};\n\nvar TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);\n\nvar INTRINSICS = {\n\t__proto__: null,\n\t'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,\n\t'%Array%': Array,\n\t'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,\n\t'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,\n\t'%AsyncFromSyncIteratorPrototype%': undefined,\n\t'%AsyncFunction%': needsEval,\n\t'%AsyncGenerator%': needsEval,\n\t'%AsyncGeneratorFunction%': needsEval,\n\t'%AsyncIteratorPrototype%': needsEval,\n\t'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,\n\t'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,\n\t'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,\n\t'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,\n\t'%Boolean%': Boolean,\n\t'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,\n\t'%Date%': Date,\n\t'%decodeURI%': decodeURI,\n\t'%decodeURIComponent%': decodeURIComponent,\n\t'%encodeURI%': encodeURI,\n\t'%encodeURIComponent%': encodeURIComponent,\n\t'%Error%': $Error,\n\t'%eval%': eval, // eslint-disable-line no-eval\n\t'%EvalError%': $EvalError,\n\t'%Float16Array%': typeof Float16Array === 'undefined' ? undefined : Float16Array,\n\t'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,\n\t'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,\n\t'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,\n\t'%Function%': $Function,\n\t'%GeneratorFunction%': needsEval,\n\t'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,\n\t'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,\n\t'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,\n\t'%isFinite%': isFinite,\n\t'%isNaN%': isNaN,\n\t'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,\n\t'%JSON%': typeof JSON === 'object' ? JSON : undefined,\n\t'%Map%': typeof Map === 'undefined' ? undefined : Map,\n\t'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),\n\t'%Math%': Math,\n\t'%Number%': Number,\n\t'%Object%': $Object,\n\t'%Object.getOwnPropertyDescriptor%': $gOPD,\n\t'%parseFloat%': parseFloat,\n\t'%parseInt%': parseInt,\n\t'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,\n\t'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,\n\t'%RangeError%': $RangeError,\n\t'%ReferenceError%': $ReferenceError,\n\t'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,\n\t'%RegExp%': RegExp,\n\t'%Set%': typeof Set === 'undefined' ? undefined : Set,\n\t'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),\n\t'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,\n\t'%String%': String,\n\t'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,\n\t'%Symbol%': hasSymbols ? Symbol : undefined,\n\t'%SyntaxError%': $SyntaxError,\n\t'%ThrowTypeError%': ThrowTypeError,\n\t'%TypedArray%': TypedArray,\n\t'%TypeError%': $TypeError,\n\t'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,\n\t'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,\n\t'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,\n\t'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,\n\t'%URIError%': $URIError,\n\t'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,\n\t'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,\n\t'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet,\n\n\t'%Function.prototype.call%': $call,\n\t'%Function.prototype.apply%': $apply,\n\t'%Object.defineProperty%': $defineProperty,\n\t'%Object.getPrototypeOf%': $ObjectGPO,\n\t'%Math.abs%': abs,\n\t'%Math.floor%': floor,\n\t'%Math.max%': max,\n\t'%Math.min%': min,\n\t'%Math.pow%': pow,\n\t'%Math.round%': round,\n\t'%Math.sign%': sign,\n\t'%Reflect.getPrototypeOf%': $ReflectGPO\n};\n\nif (getProto) {\n\ttry {\n\t\tnull.error; // eslint-disable-line no-unused-expressions\n\t} catch (e) {\n\t\t// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229\n\t\tvar errorProto = getProto(getProto(e));\n\t\tINTRINSICS['%Error.prototype%'] = errorProto;\n\t}\n}\n\nvar doEval = function doEval(name) {\n\tvar value;\n\tif (name === '%AsyncFunction%') {\n\t\tvalue = getEvalledConstructor('async function () {}');\n\t} else if (name === '%GeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('function* () {}');\n\t} else if (name === '%AsyncGeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('async function* () {}');\n\t} else if (name === '%AsyncGenerator%') {\n\t\tvar fn = doEval('%AsyncGeneratorFunction%');\n\t\tif (fn) {\n\t\t\tvalue = fn.prototype;\n\t\t}\n\t} else if (name === '%AsyncIteratorPrototype%') {\n\t\tvar gen = doEval('%AsyncGenerator%');\n\t\tif (gen && getProto) {\n\t\t\tvalue = getProto(gen.prototype);\n\t\t}\n\t}\n\n\tINTRINSICS[name] = value;\n\n\treturn value;\n};\n\nvar LEGACY_ALIASES = {\n\t__proto__: null,\n\t'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],\n\t'%ArrayPrototype%': ['Array', 'prototype'],\n\t'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],\n\t'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],\n\t'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],\n\t'%ArrayProto_values%': ['Array', 'prototype', 'values'],\n\t'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],\n\t'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],\n\t'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],\n\t'%BooleanPrototype%': ['Boolean', 'prototype'],\n\t'%DataViewPrototype%': ['DataView', 'prototype'],\n\t'%DatePrototype%': ['Date', 'prototype'],\n\t'%ErrorPrototype%': ['Error', 'prototype'],\n\t'%EvalErrorPrototype%': ['EvalError', 'prototype'],\n\t'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],\n\t'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],\n\t'%FunctionPrototype%': ['Function', 'prototype'],\n\t'%Generator%': ['GeneratorFunction', 'prototype'],\n\t'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],\n\t'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],\n\t'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],\n\t'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],\n\t'%JSONParse%': ['JSON', 'parse'],\n\t'%JSONStringify%': ['JSON', 'stringify'],\n\t'%MapPrototype%': ['Map', 'prototype'],\n\t'%NumberPrototype%': ['Number', 'prototype'],\n\t'%ObjectPrototype%': ['Object', 'prototype'],\n\t'%ObjProto_toString%': ['Object', 'prototype', 'toString'],\n\t'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],\n\t'%PromisePrototype%': ['Promise', 'prototype'],\n\t'%PromiseProto_then%': ['Promise', 'prototype', 'then'],\n\t'%Promise_all%': ['Promise', 'all'],\n\t'%Promise_reject%': ['Promise', 'reject'],\n\t'%Promise_resolve%': ['Promise', 'resolve'],\n\t'%RangeErrorPrototype%': ['RangeError', 'prototype'],\n\t'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],\n\t'%RegExpPrototype%': ['RegExp', 'prototype'],\n\t'%SetPrototype%': ['Set', 'prototype'],\n\t'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],\n\t'%StringPrototype%': ['String', 'prototype'],\n\t'%SymbolPrototype%': ['Symbol', 'prototype'],\n\t'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],\n\t'%TypedArrayPrototype%': ['TypedArray', 'prototype'],\n\t'%TypeErrorPrototype%': ['TypeError', 'prototype'],\n\t'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],\n\t'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],\n\t'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],\n\t'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],\n\t'%URIErrorPrototype%': ['URIError', 'prototype'],\n\t'%WeakMapPrototype%': ['WeakMap', 'prototype'],\n\t'%WeakSetPrototype%': ['WeakSet', 'prototype']\n};\n\nvar bind = require('function-bind');\nvar hasOwn = require('hasown');\nvar $concat = bind.call($call, Array.prototype.concat);\nvar $spliceApply = bind.call($apply, Array.prototype.splice);\nvar $replace = bind.call($call, String.prototype.replace);\nvar $strSlice = bind.call($call, String.prototype.slice);\nvar $exec = bind.call($call, RegExp.prototype.exec);\n\n/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */\nvar rePropName = /[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g;\nvar reEscapeChar = /\\\\(\\\\)?/g; /** Used to match backslashes in property paths. */\nvar stringToPath = function stringToPath(string) {\n\tvar first = $strSlice(string, 0, 1);\n\tvar last = $strSlice(string, -1);\n\tif (first === '%' && last !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected closing `%`');\n\t} else if (last === '%' && first !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected opening `%`');\n\t}\n\tvar result = [];\n\t$replace(string, rePropName, function (match, number, quote, subString) {\n\t\tresult[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;\n\t});\n\treturn result;\n};\n/* end adaptation */\n\nvar getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {\n\tvar intrinsicName = name;\n\tvar alias;\n\tif (hasOwn(LEGACY_ALIASES, intrinsicName)) {\n\t\talias = LEGACY_ALIASES[intrinsicName];\n\t\tintrinsicName = '%' + alias[0] + '%';\n\t}\n\n\tif (hasOwn(INTRINSICS, intrinsicName)) {\n\t\tvar value = INTRINSICS[intrinsicName];\n\t\tif (value === needsEval) {\n\t\t\tvalue = doEval(intrinsicName);\n\t\t}\n\t\tif (typeof value === 'undefined' && !allowMissing) {\n\t\t\tthrow new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');\n\t\t}\n\n\t\treturn {\n\t\t\talias: alias,\n\t\t\tname: intrinsicName,\n\t\t\tvalue: value\n\t\t};\n\t}\n\n\tthrow new $SyntaxError('intrinsic ' + name + ' does not exist!');\n};\n\nmodule.exports = function GetIntrinsic(name, allowMissing) {\n\tif (typeof name !== 'string' || name.length === 0) {\n\t\tthrow new $TypeError('intrinsic name must be a non-empty string');\n\t}\n\tif (arguments.length > 1 && typeof allowMissing !== 'boolean') {\n\t\tthrow new $TypeError('\"allowMissing\" argument must be a boolean');\n\t}\n\n\tif ($exec(/^%?[^%]*%?$/, name) === null) {\n\t\tthrow new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');\n\t}\n\tvar parts = stringToPath(name);\n\tvar intrinsicBaseName = parts.length > 0 ? parts[0] : '';\n\n\tvar intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);\n\tvar intrinsicRealName = intrinsic.name;\n\tvar value = intrinsic.value;\n\tvar skipFurtherCaching = false;\n\n\tvar alias = intrinsic.alias;\n\tif (alias) {\n\t\tintrinsicBaseName = alias[0];\n\t\t$spliceApply(parts, $concat([0, 1], alias));\n\t}\n\n\tfor (var i = 1, isOwn = true; i < parts.length; i += 1) {\n\t\tvar part = parts[i];\n\t\tvar first = $strSlice(part, 0, 1);\n\t\tvar last = $strSlice(part, -1);\n\t\tif (\n\t\t\t(\n\t\t\t\t(first === '\"' || first === \"'\" || first === '`')\n\t\t\t\t|| (last === '\"' || last === \"'\" || last === '`')\n\t\t\t)\n\t\t\t&& first !== last\n\t\t) {\n\t\t\tthrow new $SyntaxError('property names with quotes must have matching quotes');\n\t\t}\n\t\tif (part === 'constructor' || !isOwn) {\n\t\t\tskipFurtherCaching = true;\n\t\t}\n\n\t\tintrinsicBaseName += '.' + part;\n\t\tintrinsicRealName = '%' + intrinsicBaseName + '%';\n\n\t\tif (hasOwn(INTRINSICS, intrinsicRealName)) {\n\t\t\tvalue = INTRINSICS[intrinsicRealName];\n\t\t} else if (value != null) {\n\t\t\tif (!(part in value)) {\n\t\t\t\tif (!allowMissing) {\n\t\t\t\t\tthrow new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');\n\t\t\t\t}\n\t\t\t\treturn void undefined;\n\t\t\t}\n\t\t\tif ($gOPD && (i + 1) >= parts.length) {\n\t\t\t\tvar desc = $gOPD(value, part);\n\t\t\t\tisOwn = !!desc;\n\n\t\t\t\t// By convention, when a data property is converted to an accessor\n\t\t\t\t// property to emulate a data property that does not suffer from\n\t\t\t\t// the override mistake, that accessor's getter is marked with\n\t\t\t\t// an `originalValue` property. Here, when we detect this, we\n\t\t\t\t// uphold the illusion by pretending to see that original data\n\t\t\t\t// property, i.e., returning the value rather than the getter\n\t\t\t\t// itself.\n\t\t\t\tif (isOwn && 'get' in desc && !('originalValue' in desc.get)) {\n\t\t\t\t\tvalue = desc.get;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = value[part];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tisOwn = hasOwn(value, part);\n\t\t\t\tvalue = value[part];\n\t\t\t}\n\n\t\t\tif (isOwn && !skipFurtherCaching) {\n\t\t\t\tINTRINSICS[intrinsicRealName] = value;\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n};\n","'use strict';\n\nvar $Object = require('es-object-atoms');\n\n/** @type {import('./Object.getPrototypeOf')} */\nmodule.exports = $Object.getPrototypeOf || null;\n","'use strict';\n\n/** @type {import('.')} */\nvar $gOPD = require('./gOPD');\n\nif ($gOPD) {\n\ttry {\n\t\t$gOPD([], 'length');\n\t} catch (e) {\n\t\t// IE 8 has a broken gOPD\n\t\t$gOPD = null;\n\t}\n}\n\nmodule.exports = $gOPD;\n","'use strict';\n\nvar reflectGetProto = require('./Reflect.getPrototypeOf');\nvar originalGetProto = require('./Object.getPrototypeOf');\n\nvar getDunderProto = require('dunder-proto/get');\n\n/** @type {import('.')} */\nmodule.exports = reflectGetProto\n\t? function getProto(O) {\n\t\t// @ts-expect-error TS can't narrow inside a closure, for some reason\n\t\treturn reflectGetProto(O);\n\t}\n\t: originalGetProto\n\t\t? function getProto(O) {\n\t\t\tif (!O || (typeof O !== 'object' && typeof O !== 'function')) {\n\t\t\t\tthrow new TypeError('getProto: not an object');\n\t\t\t}\n\t\t\t// @ts-expect-error TS can't narrow inside a closure, for some reason\n\t\t\treturn originalGetProto(O);\n\t\t}\n\t\t: getDunderProto\n\t\t\t? function getProto(O) {\n\t\t\t\t// @ts-expect-error TS can't narrow inside a closure, for some reason\n\t\t\t\treturn getDunderProto(O);\n\t\t\t}\n\t\t\t: null;\n","export const fieldTagNames = {\n  // TIFF Baseline\n  0x013B: 'Artist',\n  0x0102: 'BitsPerSample',\n  0x0109: 'CellLength',\n  0x0108: 'CellWidth',\n  0x0140: 'ColorMap',\n  0x0103: 'Compression',\n  0x8298: 'Copyright',\n  0x0132: 'DateTime',\n  0x0152: 'ExtraSamples',\n  0x010A: 'FillOrder',\n  0x0121: 'FreeByteCounts',\n  0x0120: 'FreeOffsets',\n  0x0123: 'GrayResponseCurve',\n  0x0122: 'GrayResponseUnit',\n  0x013C: 'HostComputer',\n  0x010E: 'ImageDescription',\n  0x0101: 'ImageLength',\n  0x0100: 'ImageWidth',\n  0x010F: 'Make',\n  0x0119: 'MaxSampleValue',\n  0x0118: 'MinSampleValue',\n  0x0110: 'Model',\n  0x00FE: 'NewSubfileType',\n  0x0112: 'Orientation',\n  0x0106: 'PhotometricInterpretation',\n  0x011C: 'PlanarConfiguration',\n  0x0128: 'ResolutionUnit',\n  0x0116: 'RowsPerStrip',\n  0x0115: 'SamplesPerPixel',\n  0x0131: 'Software',\n  0x0117: 'StripByteCounts',\n  0x0111: 'StripOffsets',\n  0x00FF: 'SubfileType',\n  0x0107: 'Threshholding',\n  0x011A: 'XResolution',\n  0x011B: 'YResolution',\n\n  // TIFF Extended\n  0x0146: 'BadFaxLines',\n  0x0147: 'CleanFaxData',\n  0x0157: 'ClipPath',\n  0x0148: 'ConsecutiveBadFaxLines',\n  0x01B1: 'Decode',\n  0x01B2: 'DefaultImageColor',\n  0x010D: 'DocumentName',\n  0x0150: 'DotRange',\n  0x0141: 'HalftoneHints',\n  0x015A: 'Indexed',\n  0x015B: 'JPEGTables',\n  0x011D: 'PageName',\n  0x0129: 'PageNumber',\n  0x013D: 'Predictor',\n  0x013F: 'PrimaryChromaticities',\n  0x0214: 'ReferenceBlackWhite',\n  0x0153: 'SampleFormat',\n  0x0154: 'SMinSampleValue',\n  0x0155: 'SMaxSampleValue',\n  0x022F: 'StripRowCounts',\n  0x014A: 'SubIFDs',\n  0x0124: 'T4Options',\n  0x0125: 'T6Options',\n  0x0145: 'TileByteCounts',\n  0x0143: 'TileLength',\n  0x0144: 'TileOffsets',\n  0x0142: 'TileWidth',\n  0x012D: 'TransferFunction',\n  0x013E: 'WhitePoint',\n  0x0158: 'XClipPathUnits',\n  0x011E: 'XPosition',\n  0x0211: 'YCbCrCoefficients',\n  0x0213: 'YCbCrPositioning',\n  0x0212: 'YCbCrSubSampling',\n  0x0159: 'YClipPathUnits',\n  0x011F: 'YPosition',\n\n  // EXIF\n  0x9202: 'ApertureValue',\n  0xA001: 'ColorSpace',\n  0x9004: 'DateTimeDigitized',\n  0x9003: 'DateTimeOriginal',\n  0x8769: 'Exif IFD',\n  0x9000: 'ExifVersion',\n  0x829A: 'ExposureTime',\n  0xA300: 'FileSource',\n  0x9209: 'Flash',\n  0xA000: 'FlashpixVersion',\n  0x829D: 'FNumber',\n  0xA420: 'ImageUniqueID',\n  0x9208: 'LightSource',\n  0x927C: 'MakerNote',\n  0x9201: 'ShutterSpeedValue',\n  0x9286: 'UserComment',\n\n  // IPTC\n  0x83BB: 'IPTC',\n\n  // Laser Scanning Microscopy\n  0x866c: 'CZ_LSMINFO',\n\n  // ICC\n  0x8773: 'ICC Profile',\n\n  // XMP\n  0x02BC: 'XMP',\n\n  // GDAL\n  0xA480: 'GDAL_METADATA',\n  0xA481: 'GDAL_NODATA',\n\n  // Photoshop\n  0x8649: 'Photoshop',\n\n  // GeoTiff\n  0x830E: 'ModelPixelScale',\n  0x8482: 'ModelTiepoint',\n  0x85D8: 'ModelTransformation',\n  0x87AF: 'GeoKeyDirectory',\n  0x87B0: 'GeoDoubleParams',\n  0x87B1: 'GeoAsciiParams',\n\n  // LERC\n  0xC5F2: 'LercParameters',\n};\n\nexport const fieldTags = {};\nfor (const key in fieldTagNames) {\n  if (fieldTagNames.hasOwnProperty(key)) {\n    fieldTags[fieldTagNames[key]] = parseInt(key, 10);\n  }\n}\n\nexport const fieldTagTypes = {\n  256: 'SHORT',\n  257: 'SHORT',\n  258: 'SHORT',\n  259: 'SHORT',\n  262: 'SHORT',\n  270: 'ASCII',\n  271: 'ASCII',\n  272: 'ASCII',\n  273: 'LONG',\n  274: 'SHORT',\n  277: 'SHORT',\n  278: 'LONG',\n  279: 'LONG',\n  282: 'RATIONAL',\n  283: 'RATIONAL',\n  284: 'SHORT',\n  286: 'SHORT',\n  287: 'RATIONAL',\n  296: 'SHORT',\n  297: 'SHORT',\n  305: 'ASCII',\n  306: 'ASCII',\n  315: 'ASCII',\n  338: 'SHORT',\n  339: 'SHORT',\n  513: 'LONG',\n  514: 'LONG',\n  1024: 'SHORT',\n  1025: 'SHORT',\n  1026: 'ASCII',\n  2048: 'SHORT',\n  2049: 'ASCII',\n  2052: 'SHORT',\n  2054: 'SHORT',\n  2060: 'SHORT',\n  3072: 'SHORT',\n  3073: 'ASCII',\n  3076: 'SHORT',\n  4096: 'SHORT',\n  4097: 'ASCII',\n  4099: 'SHORT',\n  33432: 'ASCII',\n  33550: 'DOUBLE',\n  33922: 'DOUBLE',\n  34264: 'DOUBLE',\n  34665: 'LONG',\n  34735: 'SHORT',\n  34736: 'DOUBLE',\n  34737: 'ASCII',\n  42113: 'ASCII',\n};\n\nexport const arrayFields = [\n  fieldTags.BitsPerSample,\n  fieldTags.ExtraSamples,\n  fieldTags.SampleFormat,\n  fieldTags.StripByteCounts,\n  fieldTags.StripOffsets,\n  fieldTags.StripRowCounts,\n  fieldTags.TileByteCounts,\n  fieldTags.TileOffsets,\n  fieldTags.SubIFDs,\n];\n\nexport const fieldTypeNames = {\n  0x0001: 'BYTE',\n  0x0002: 'ASCII',\n  0x0003: 'SHORT',\n  0x0004: 'LONG',\n  0x0005: 'RATIONAL',\n  0x0006: 'SBYTE',\n  0x0007: 'UNDEFINED',\n  0x0008: 'SSHORT',\n  0x0009: 'SLONG',\n  0x000A: 'SRATIONAL',\n  0x000B: 'FLOAT',\n  0x000C: 'DOUBLE',\n  // IFD offset, suggested by https://owl.phy.queensu.ca/~phil/exiftool/standards.html\n  0x000D: 'IFD',\n  // introduced by BigTIFF\n  0x0010: 'LONG8',\n  0x0011: 'SLONG8',\n  0x0012: 'IFD8',\n};\n\nexport const fieldTypes = {};\nfor (const key in fieldTypeNames) {\n  if (fieldTypeNames.hasOwnProperty(key)) {\n    fieldTypes[fieldTypeNames[key]] = parseInt(key, 10);\n  }\n}\n\n/**\n * Registers a new field tag\n * @param {number} tag the numeric tiff tag\n * @param {string} name the name of the tag that will be reported in the IFD\n * @param {number} type the tags data type\n * @param {Boolean} isArray whether the tag is an array\n */\nexport function registerTag(tag, name, type = undefined, isArray = false) {\n  fieldTags[name] = tag;\n  fieldTagNames[tag] = name;\n\n  if (type) {\n    fieldTypes[name] = type;\n  }\n  if (isArray) {\n    arrayFields.push(tag);\n  }\n}\n\nexport const photometricInterpretations = {\n  WhiteIsZero: 0,\n  BlackIsZero: 1,\n  RGB: 2,\n  Palette: 3,\n  TransparencyMask: 4,\n  CMYK: 5,\n  YCbCr: 6,\n\n  CIELab: 8,\n  ICCLab: 9,\n};\n\nexport const ExtraSamplesValues = {\n  Unspecified: 0,\n  Assocalpha: 1,\n  Unassalpha: 2,\n};\n\nexport const LercParameters = {\n  Version: 0,\n  AddCompression: 1,\n};\n\nexport const LercAddCompression = {\n  None: 0,\n  Deflate: 1,\n  Zstandard: 2,\n};\n\nexport const geoKeyNames = {\n  1024: 'GTModelTypeGeoKey',\n  1025: 'GTRasterTypeGeoKey',\n  1026: 'GTCitationGeoKey',\n  2048: 'GeographicTypeGeoKey',\n  2049: 'GeogCitationGeoKey',\n  2050: 'GeogGeodeticDatumGeoKey',\n  2051: 'GeogPrimeMeridianGeoKey',\n  2052: 'GeogLinearUnitsGeoKey',\n  2053: 'GeogLinearUnitSizeGeoKey',\n  2054: 'GeogAngularUnitsGeoKey',\n  2055: 'GeogAngularUnitSizeGeoKey',\n  2056: 'GeogEllipsoidGeoKey',\n  2057: 'GeogSemiMajorAxisGeoKey',\n  2058: 'GeogSemiMinorAxisGeoKey',\n  2059: 'GeogInvFlatteningGeoKey',\n  2060: 'GeogAzimuthUnitsGeoKey',\n  2061: 'GeogPrimeMeridianLongGeoKey',\n  2062: 'GeogTOWGS84GeoKey',\n  3072: 'ProjectedCSTypeGeoKey',\n  3073: 'PCSCitationGeoKey',\n  3074: 'ProjectionGeoKey',\n  3075: 'ProjCoordTransGeoKey',\n  3076: 'ProjLinearUnitsGeoKey',\n  3077: 'ProjLinearUnitSizeGeoKey',\n  3078: 'ProjStdParallel1GeoKey',\n  3079: 'ProjStdParallel2GeoKey',\n  3080: 'ProjNatOriginLongGeoKey',\n  3081: 'ProjNatOriginLatGeoKey',\n  3082: 'ProjFalseEastingGeoKey',\n  3083: 'ProjFalseNorthingGeoKey',\n  3084: 'ProjFalseOriginLongGeoKey',\n  3085: 'ProjFalseOriginLatGeoKey',\n  3086: 'ProjFalseOriginEastingGeoKey',\n  3087: 'ProjFalseOriginNorthingGeoKey',\n  3088: 'ProjCenterLongGeoKey',\n  3089: 'ProjCenterLatGeoKey',\n  3090: 'ProjCenterEastingGeoKey',\n  3091: 'ProjCenterNorthingGeoKey',\n  3092: 'ProjScaleAtNatOriginGeoKey',\n  3093: 'ProjScaleAtCenterGeoKey',\n  3094: 'ProjAzimuthAngleGeoKey',\n  3095: 'ProjStraightVertPoleLongGeoKey',\n  3096: 'ProjRectifiedGridAngleGeoKey',\n  4096: 'VerticalCSTypeGeoKey',\n  4097: 'VerticalCitationGeoKey',\n  4098: 'VerticalDatumGeoKey',\n  4099: 'VerticalUnitsGeoKey',\n};\n\nexport const geoKeys = {};\nfor (const key in geoKeyNames) {\n  if (geoKeyNames.hasOwnProperty(key)) {\n    geoKeys[geoKeyNames[key]] = parseInt(key, 10);\n  }\n}\n"],"names":["module","exports","Object","getOwnPropertyDescriptor","call","Function","prototype","$hasOwn","hasOwnProperty","bind","fromWhiteIsZero","raster","max","width","height","rgbRaster","Uint8Array","value","i","j","length","fromBlackIsZero","fromPalette","colorMap","greenOffset","blueOffset","mapIndex","fromCMYK","cmykRaster","c","m","y","k","fromYCbCr","yCbCrRaster","Uint8ClampedArray","cb","cr","Xn","Yn","Zn","fromCIELab","cieLabRaster","L","a_","b_","r","g","b","x","z","Math","min","registry","Map","preferWorkerMap","addDecoder","cases","importFn","preferWorker_","Array","isArray","forEach","set","async","getDecoder","fileDirectory","get","Compression","Error","Decoder","copyNewSize","array","samplesPerPixel","getPrototypeOf","resampleNearest","valueArrays","inWidth","inHeight","outWidth","outHeight","relX","relY","map","newArray","cy","round","cx","lerp","v0","v1","t","resampleBilinear","rawY","yl","floor","yh","ceil","rawX","tx","xl","xh","ll","hl","lh","hh","resample","method","toLowerCase","resampleNearestInterleaved","valueArray","samples","resampleBilinearInterleaved","resampleInterleaved","sum","start","end","s","arrayForType","format","bitsPerSample","size","Uint16Array","Uint32Array","Int8Array","Int16Array","Int32Array","Float32Array","Float64Array","needsNormalization","normalizeArray","inBuffer","planarConfiguration","tileWidth","tileHeight","view","DataView","outSize","samplesToTransfer","outArray","bitMask","parseInt","repeat","pixelBitSkip","bitsPerLine","lineBitOffset","pixelBitOffset","bitOffset","outIndex","byteOffset","innerBitOffset","getUint8","getUint16","raw","getUint32","buffer","undefined","then","default","zstd","init","GeoTIFFImage","constructor","geoKeys","dataView","littleEndian","cache","source","this","tiles","isTiled","StripOffsets","PlanarConfiguration","getFileDirectory","getGeoKeys","getWidth","ImageWidth","getHeight","ImageLength","getSamplesPerPixel","SamplesPerPixel","getTileWidth","TileWidth","getTileHeight","TileLength","RowsPerStrip","getBlockWidth","getBlockHeight","getBytesPerPixel","bytes","BitsPerSample","getSampleByteSize","RangeError","getReaderForSample","sampleIndex","SampleFormat","getInt8","getInt16","getInt32","offset","getFloat32","getFloat64","getSampleFormat","getBitsPerSample","getArrayForSample","getTileOrStrip","sample","poolOrDecoder","signal","numTilesPerRow","numTilesPerCol","index","byteCount","TileOffsets","TileByteCounts","StripByteCounts","nPixels","bytesPerPixel","data","ArrayBuffer","fill","getGDALNoData","slice","fetch","request","decode","sampleFormat","_readRaster","imageWindow","interleave","resampleMethod","imageWidth","imageHeight","minXTile","maxXTile","minYTile","maxYTile","windowWidth","srcSampleOffsets","sampleReaders","push","promises","yTile","xTile","getPromise","si","promise","tile","blockHeight","firstLine","firstCol","lastLine","lastCol","reader","ymax","xmax","pixelOffset","windowCoordinate","Promise","all","resampled","readRasters","window","wnd","pool","fillValue","imageWindowWidth","imageWindowHeight","numPixels","reject","apply","result","readRGB","enableAlpha","pi","PhotometricInterpretation","RGB","ExtraSamples","Unspecified","WhiteIsZero","BlackIsZero","Palette","CMYK","YCbCr","CIELab","subOptions","ColorMap","red","green","blue","getTiePoints","ModelTiepoint","tiePoints","getGDALMetadata","metadata","GDAL_METADATA","string","items","filter","item","Number","inner","GDAL_NODATA","substring","getOrigin","modelTransformation","ModelTransformation","getResolution","referenceImage","modelPixelScale","ModelPixelScale","sqrt","refResX","refResY","refResZ","pixelIsArea","GTRasterTypeGeoKey","getBoundingBox","tilegrid","a","d","e","f","h","corners","projected","I","J","xs","pt","ys","origin","resolution","x1","y1","x2","y2","DataView64","arrayBuffer","_dataView","getUint64","left","right","combined","isSafeInteger","getInt64","isNegative","carrying","byte","getFloat16","DataSlice","sliceOffset","bigTiff","_sliceOffset","_littleEndian","_bigTiff","sliceTop","byteLength","covers","readUint8","readInt8","readUint16","readInt16","readUint32","readInt32","readFloat32","readFloat64","readUint64","readInt64","readOffset","CRLFCRLF","itemsToObject","fromEntries","obj","key","parseHeaders","text","split","line","kv","str","trim","parseContentType","rawContentType","type","rawParams","paramsItems","param","params","parseContentRange","rawContentRange","total","match","parseByteRanges","responseArrayBuffer","boundary","decoder","TextDecoder","out","startBoundary","endBoundary","startsWith","innerText","substr","endOfHeaders","indexOf","headers","startOfData","fileSize","BaseSource","slices","fetchSlice","close","wait","milliseconds","resolve","setTimeout","zip","A","from","B","AbortError","super","captureStackTrace","name","CustomAggregateError","errors","message","AggregateError","Block","top","BlockGroup","blockIds","BlockedSource","blockSize","cacheSize","blockCache","maxSize","onEviction","blockId","block","evictedBlocks","blockRequests","blockIdsToFetch","Set","abortedBlockIds","missingBlockIds","allBlockIds","clear","firstBlockOffset","current","has","add","fetchBlocks","missingRequests","allSettled","abortedBlockRequests","id","aborted","blocks","failedBlocks","requiredBlocks","readSliceData","groups","groupBlocks","groupRequests","groupIndex","group","response","blockOffset","o","delete","err","sortedBlockIds","sort","lastBlockId","blockIdLow","blockIdHigh","sliceData","sliceView","delta","topDelta","usedBlockLength","blockInnerOffset","rangeInnerOffset","blockView","BaseResponse","ok","status","getHeader","headerName","getData","BaseClient","url","FetchResponse","FetchClient","credentials","XHRResponse","xhr","getResponseHeader","XHRClient","constructRequest","XMLHttpRequest","open","responseType","entries","setRequestHeader","onload","onerror","onabort","send","abort","addEventListener","HttpResponse","dataPromise","statusCode","HttpClient","parsedUrl","httpApi","protocol","resolveData","chunks","on","chunk","Buffer","concat","destroy","RemoteSource","client","maxRanges","allowFullFile","_fileSize","fetchSlices","Range","join","byteRanges","first","others","maybeWrapInBlockedSource","makeFetchSource","blockOptions","makeXHRSource","makeHttpSource","forceXHR","clientOptions","FileReaderSource","file","blob","FileReader","event","target","readAsArrayBuffer","makeFileReaderSource","getFieldTypeLength","fieldType","BYTE","ASCII","SBYTE","UNDEFINED","SHORT","SSHORT","LONG","SLONG","FLOAT","IFD","RATIONAL","SRATIONAL","DOUBLE","LONG8","SLONG8","IFD8","parseGeoKeyDirectory","rawGeoKeyDirectory","GeoKeyDirectory","geoKeyDirectory","location","count","subarray","getValues","dataSlice","values","readMethod","fieldTypeLength","ImageFileDirectory","rawFileDirectory","nextIFDByteOffset","GeoTIFFImageIndexError","GeoTIFFBase","options","resX","resY","bbox","firstImage","getImage","usedImage","imageCount","getImageCount","imgBBox","oX","oY","rX","rY","usedBBox","allImages","image","SubfileType","subfileType","NewSubfileType","newSubfileType","imgResX","imgResY","imageResX","imageResY","GeoTIFF","firstIFDOffset","ifdRequests","ghostValues","getSlice","fallbackSize","parseFileDirectoryAt","entrySize","offsetSize","numDirEntries","byteSize","entryCount","fieldTag","typeCount","fieldValues","valueOffset","actualOffset","fieldDataSlice","tagName","requestIFD","previousIfd","ifd","hasNext","getGhostValues","detectionString","heuristicAreaSize","valuesString","metadataSize","fullString","fromSource","headerData","BOM","TypeError","magicNumber","offsetByteSize","fromUrl","fromBlob","Symbol","getOwnPropertySymbols","iterator","sym","symObj","toString","symVal","_","keys","getOwnPropertyNames","syms","propertyIsEnumerable","descriptor","enumerable","Reflect","origSymbol","hasSymbolSham","$Object","$Error","$EvalError","$RangeError","$ReferenceError","$SyntaxError","$TypeError","$URIError","abs","pow","sign","$Function","getEvalledConstructor","expressionSyntax","$gOPD","$defineProperty","throwTypeError","ThrowTypeError","calleeThrows","arguments","gOPDthrows","hasSymbols","getProto","$ObjectGPO","$ReflectGPO","$apply","$call","needsEval","TypedArray","INTRINSICS","__proto__","Atomics","BigInt","BigInt64Array","BigUint64Array","Boolean","Date","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","eval","Float16Array","FinalizationRegistry","isFinite","isNaN","JSON","parseFloat","Proxy","RegExp","SharedArrayBuffer","String","WeakMap","WeakRef","WeakSet","error","errorProto","doEval","fn","gen","LEGACY_ALIASES","hasOwn","$concat","$spliceApply","splice","$replace","replace","$strSlice","$exec","exec","rePropName","reEscapeChar","stringToPath","last","number","quote","subString","getBaseIntrinsic","allowMissing","alias","intrinsicName","parts","intrinsicBaseName","intrinsic","intrinsicRealName","skipFurtherCaching","isOwn","part","desc","reflectGetProto","originalGetProto","getDunderProto","O","fieldTagNames","fieldTags","arrayFields","StripRowCounts","SubIFDs","fieldTypeNames","fieldTypes","photometricInterpretations","TransparencyMask","ICCLab","ExtraSamplesValues","Assocalpha","Unassalpha","LercParameters","Version","AddCompression","LercAddCompression","None","Deflate","Zstandard","geoKeyNames"],"sourceRoot":""}
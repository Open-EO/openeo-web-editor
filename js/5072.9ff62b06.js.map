{"version":3,"file":"js/5072.9ff62b06.js","mappings":"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","sources":["webpack://@openeo/web-editor/./node_modules/ol/reproj/Triangulation.js","webpack://@openeo/web-editor/./node_modules/ol/reproj.js","webpack://@openeo/web-editor/./node_modules/ol/reproj/Tile.js","webpack://@openeo/web-editor/./node_modules/ol/reproj/common.js","webpack://@openeo/web-editor/./node_modules/ol/resolutionconstraint.js","webpack://@openeo/web-editor/./node_modules/ol/rotationconstraint.js","webpack://@openeo/web-editor/./node_modules/ol/size.js"],"sourcesContent":["/**\n * @module ol/reproj/Triangulation\n */\nimport { boundingExtent, createEmpty, extendCoordinate, getArea, getBottomLeft, getBottomRight, getTopLeft, getTopRight, getWidth, intersects, } from '../extent.js';\nimport { getTransform } from '../proj.js';\nimport { log2, modulo } from '../math.js';\n/**\n * Single triangle; consists of 3 source points and 3 target points.\n * @typedef {Object} Triangle\n * @property {Array<import(\"../coordinate.js\").Coordinate>} source Source.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} target Target.\n */\n/**\n * Maximum number of subdivision steps during raster reprojection triangulation.\n * Prevents high memory usage and large number of proj4 calls (for certain\n * transformations and areas). At most `2*(2^this)` triangles are created for\n * each triangulated extent (tile/image).\n * @type {number}\n */\nvar MAX_SUBDIVISION = 10;\n/**\n * Maximum allowed size of triangle relative to world width. When transforming\n * corners of world extent between certain projections, the resulting\n * triangulation seems to have zero error and no subdivision is performed. If\n * the triangle width is more than this (relative to world width; 0-1),\n * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.\n * @type {number}\n */\nvar MAX_TRIANGLE_WIDTH = 0.25;\n/**\n * @classdesc\n * Class containing triangulation of the given target extent.\n * Used for determining source data and the reprojection itself.\n */\nvar Triangulation = /** @class */ (function () {\n    /**\n     * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n     * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n     * @param {import(\"../extent.js\").Extent} targetExtent Target extent to triangulate.\n     * @param {import(\"../extent.js\").Extent} maxSourceExtent Maximal source extent that can be used.\n     * @param {number} errorThreshold Acceptable error (in source units).\n     * @param {?number} opt_destinationResolution The (optional) resolution of the destination.\n     */\n    function Triangulation(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold, opt_destinationResolution) {\n        /**\n         * @type {import(\"../proj/Projection.js\").default}\n         * @private\n         */\n        this.sourceProj_ = sourceProj;\n        /**\n         * @type {import(\"../proj/Projection.js\").default}\n         * @private\n         */\n        this.targetProj_ = targetProj;\n        /** @type {!Object<string, import(\"../coordinate.js\").Coordinate>} */\n        var transformInvCache = {};\n        var transformInv = getTransform(this.targetProj_, this.sourceProj_);\n        /**\n         * @param {import(\"../coordinate.js\").Coordinate} c A coordinate.\n         * @return {import(\"../coordinate.js\").Coordinate} Transformed coordinate.\n         * @private\n         */\n        this.transformInv_ = function (c) {\n            var key = c[0] + '/' + c[1];\n            if (!transformInvCache[key]) {\n                transformInvCache[key] = transformInv(c);\n            }\n            return transformInvCache[key];\n        };\n        /**\n         * @type {import(\"../extent.js\").Extent}\n         * @private\n         */\n        this.maxSourceExtent_ = maxSourceExtent;\n        /**\n         * @type {number}\n         * @private\n         */\n        this.errorThresholdSquared_ = errorThreshold * errorThreshold;\n        /**\n         * @type {Array<Triangle>}\n         * @private\n         */\n        this.triangles_ = [];\n        /**\n         * Indicates that the triangulation crosses edge of the source projection.\n         * @type {boolean}\n         * @private\n         */\n        this.wrapsXInSource_ = false;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this.canWrapXInSource_ =\n            this.sourceProj_.canWrapX() &&\n                !!maxSourceExtent &&\n                !!this.sourceProj_.getExtent() &&\n                getWidth(maxSourceExtent) == getWidth(this.sourceProj_.getExtent());\n        /**\n         * @type {?number}\n         * @private\n         */\n        this.sourceWorldWidth_ = this.sourceProj_.getExtent()\n            ? getWidth(this.sourceProj_.getExtent())\n            : null;\n        /**\n         * @type {?number}\n         * @private\n         */\n        this.targetWorldWidth_ = this.targetProj_.getExtent()\n            ? getWidth(this.targetProj_.getExtent())\n            : null;\n        var destinationTopLeft = getTopLeft(targetExtent);\n        var destinationTopRight = getTopRight(targetExtent);\n        var destinationBottomRight = getBottomRight(targetExtent);\n        var destinationBottomLeft = getBottomLeft(targetExtent);\n        var sourceTopLeft = this.transformInv_(destinationTopLeft);\n        var sourceTopRight = this.transformInv_(destinationTopRight);\n        var sourceBottomRight = this.transformInv_(destinationBottomRight);\n        var sourceBottomLeft = this.transformInv_(destinationBottomLeft);\n        /*\n         * The maxSubdivision controls how many splittings of the target area can\n         * be done. The idea here is to do a linear mapping of the target areas\n         * but the actual overal reprojection (can be) extremely non-linear. The\n         * default value of MAX_SUBDIVISION was chosen based on mapping a 256x256\n         * tile size. However this function is also called to remap canvas rendered\n         * layers which can be much larger. This calculation increases the maxSubdivision\n         * value by the right factor so that each 256x256 pixel area has\n         * MAX_SUBDIVISION divisions.\n         */\n        var maxSubdivision = MAX_SUBDIVISION +\n            (opt_destinationResolution\n                ? Math.max(0, Math.ceil(log2(getArea(targetExtent) /\n                    (opt_destinationResolution *\n                        opt_destinationResolution *\n                        256 *\n                        256))))\n                : 0);\n        this.addQuad_(destinationTopLeft, destinationTopRight, destinationBottomRight, destinationBottomLeft, sourceTopLeft, sourceTopRight, sourceBottomRight, sourceBottomLeft, maxSubdivision);\n        if (this.wrapsXInSource_) {\n            var leftBound_1 = Infinity;\n            this.triangles_.forEach(function (triangle, i, arr) {\n                leftBound_1 = Math.min(leftBound_1, triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]);\n            });\n            // Shift triangles to be as close to `leftBound` as possible\n            // (if the distance is more than `worldWidth / 2` it can be closer.\n            this.triangles_.forEach(function (triangle) {\n                if (Math.max(triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]) -\n                    leftBound_1 >\n                    this.sourceWorldWidth_ / 2) {\n                    var newTriangle = [\n                        [triangle.source[0][0], triangle.source[0][1]],\n                        [triangle.source[1][0], triangle.source[1][1]],\n                        [triangle.source[2][0], triangle.source[2][1]],\n                    ];\n                    if (newTriangle[0][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {\n                        newTriangle[0][0] -= this.sourceWorldWidth_;\n                    }\n                    if (newTriangle[1][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {\n                        newTriangle[1][0] -= this.sourceWorldWidth_;\n                    }\n                    if (newTriangle[2][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {\n                        newTriangle[2][0] -= this.sourceWorldWidth_;\n                    }\n                    // Rarely (if the extent contains both the dateline and prime meridian)\n                    // the shift can in turn break some triangles.\n                    // Detect this here and don't shift in such cases.\n                    var minX = Math.min(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);\n                    var maxX = Math.max(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);\n                    if (maxX - minX < this.sourceWorldWidth_ / 2) {\n                        triangle.source = newTriangle;\n                    }\n                }\n            }.bind(this));\n        }\n        transformInvCache = {};\n    }\n    /**\n     * Adds triangle to the triangulation.\n     * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n     * @private\n     */\n    Triangulation.prototype.addTriangle_ = function (a, b, c, aSrc, bSrc, cSrc) {\n        this.triangles_.push({\n            source: [aSrc, bSrc, cSrc],\n            target: [a, b, c],\n        });\n    };\n    /**\n     * Adds quad (points in clock-wise order) to the triangulation\n     * (and reprojects the vertices) if valid.\n     * Performs quad subdivision if needed to increase precision.\n     *\n     * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} d The target d coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} dSrc The source d coordinate.\n     * @param {number} maxSubdivision Maximal allowed subdivision of the quad.\n     * @private\n     */\n    Triangulation.prototype.addQuad_ = function (a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {\n        var sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);\n        var sourceCoverageX = this.sourceWorldWidth_\n            ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_\n            : null;\n        var sourceWorldWidth = /** @type {number} */ (this.sourceWorldWidth_);\n        // when the quad is wrapped in the source projection\n        // it covers most of the projection extent, but not fully\n        var wrapsX = this.sourceProj_.canWrapX() &&\n            sourceCoverageX > 0.5 &&\n            sourceCoverageX < 1;\n        var needsSubdivision = false;\n        if (maxSubdivision > 0) {\n            if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {\n                var targetQuadExtent = boundingExtent([a, b, c, d]);\n                var targetCoverageX = getWidth(targetQuadExtent) / this.targetWorldWidth_;\n                needsSubdivision =\n                    targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n            }\n            if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {\n                needsSubdivision =\n                    sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n            }\n        }\n        if (!needsSubdivision && this.maxSourceExtent_) {\n            if (isFinite(sourceQuadExtent[0]) &&\n                isFinite(sourceQuadExtent[1]) &&\n                isFinite(sourceQuadExtent[2]) &&\n                isFinite(sourceQuadExtent[3])) {\n                if (!intersects(sourceQuadExtent, this.maxSourceExtent_)) {\n                    // whole quad outside source projection extent -> ignore\n                    return;\n                }\n            }\n        }\n        var isNotFinite = 0;\n        if (!needsSubdivision) {\n            if (!isFinite(aSrc[0]) ||\n                !isFinite(aSrc[1]) ||\n                !isFinite(bSrc[0]) ||\n                !isFinite(bSrc[1]) ||\n                !isFinite(cSrc[0]) ||\n                !isFinite(cSrc[1]) ||\n                !isFinite(dSrc[0]) ||\n                !isFinite(dSrc[1])) {\n                if (maxSubdivision > 0) {\n                    needsSubdivision = true;\n                }\n                else {\n                    // It might be the case that only 1 of the points is infinite. In this case\n                    // we can draw a single triangle with the other three points\n                    isNotFinite =\n                        (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) +\n                            (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) +\n                            (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) +\n                            (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);\n                    if (isNotFinite != 1 &&\n                        isNotFinite != 2 &&\n                        isNotFinite != 4 &&\n                        isNotFinite != 8) {\n                        return;\n                    }\n                }\n            }\n        }\n        if (maxSubdivision > 0) {\n            if (!needsSubdivision) {\n                var center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];\n                var centerSrc = this.transformInv_(center);\n                var dx = void 0;\n                if (wrapsX) {\n                    var centerSrcEstimX = (modulo(aSrc[0], sourceWorldWidth) +\n                        modulo(cSrc[0], sourceWorldWidth)) /\n                        2;\n                    dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);\n                }\n                else {\n                    dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];\n                }\n                var dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];\n                var centerSrcErrorSquared = dx * dx + dy * dy;\n                needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;\n            }\n            if (needsSubdivision) {\n                if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {\n                    // split horizontally (top & bottom)\n                    var bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];\n                    var bcSrc = this.transformInv_(bc);\n                    var da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];\n                    var daSrc = this.transformInv_(da);\n                    this.addQuad_(a, b, bc, da, aSrc, bSrc, bcSrc, daSrc, maxSubdivision - 1);\n                    this.addQuad_(da, bc, c, d, daSrc, bcSrc, cSrc, dSrc, maxSubdivision - 1);\n                }\n                else {\n                    // split vertically (left & right)\n                    var ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\n                    var abSrc = this.transformInv_(ab);\n                    var cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];\n                    var cdSrc = this.transformInv_(cd);\n                    this.addQuad_(a, ab, cd, d, aSrc, abSrc, cdSrc, dSrc, maxSubdivision - 1);\n                    this.addQuad_(ab, b, c, cd, abSrc, bSrc, cSrc, cdSrc, maxSubdivision - 1);\n                }\n                return;\n            }\n        }\n        if (wrapsX) {\n            if (!this.canWrapXInSource_) {\n                return;\n            }\n            this.wrapsXInSource_ = true;\n        }\n        // Exactly zero or one of *Src is not finite\n        // The triangles must have the diagonal line as the first side\n        // This is to allow easy code in reproj.s to make it straight for broken\n        // browsers that can't handle diagonal clipping\n        if ((isNotFinite & 0xb) == 0) {\n            this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);\n        }\n        if ((isNotFinite & 0xe) == 0) {\n            this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);\n        }\n        if (isNotFinite) {\n            // Try the other two triangles\n            if ((isNotFinite & 0xd) == 0) {\n                this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);\n            }\n            if ((isNotFinite & 0x7) == 0) {\n                this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);\n            }\n        }\n    };\n    /**\n     * Calculates extent of the `source` coordinates from all the triangles.\n     *\n     * @return {import(\"../extent.js\").Extent} Calculated extent.\n     */\n    Triangulation.prototype.calculateSourceExtent = function () {\n        var extent = createEmpty();\n        this.triangles_.forEach(function (triangle, i, arr) {\n            var src = triangle.source;\n            extendCoordinate(extent, src[0]);\n            extendCoordinate(extent, src[1]);\n            extendCoordinate(extent, src[2]);\n        });\n        return extent;\n    };\n    /**\n     * @return {Array<Triangle>} Array of the calculated triangles.\n     */\n    Triangulation.prototype.getTriangles = function () {\n        return this.triangles_;\n    };\n    return Triangulation;\n}());\nexport default Triangulation;\n//# sourceMappingURL=Triangulation.js.map","/**\n * @module ol/reproj\n */\nimport { IMAGE_SMOOTHING_DISABLED } from './renderer/canvas/common.js';\nimport { assign } from './obj.js';\nimport { containsCoordinate, createEmpty, extend, forEachCorner, getCenter, getHeight, getTopLeft, getWidth, } from './extent.js';\nimport { createCanvasContext2D } from './dom.js';\nimport { getPointResolution, transform } from './proj.js';\nimport { solveLinearSystem } from './math.js';\nvar brokenDiagonalRendering_;\n/**\n * @type {Array<HTMLCanvasElement>}\n */\nexport var canvasPool = [];\n/**\n * This draws a small triangle into a canvas by setting the triangle as the clip region\n * and then drawing a (too large) rectangle\n *\n * @param {CanvasRenderingContext2D} ctx The context in which to draw the triangle\n * @param {number} u1 The x-coordinate of the second point. The first point is 0,0.\n * @param {number} v1 The y-coordinate of the second point.\n * @param {number} u2 The x-coordinate of the third point.\n * @param {number} v2 The y-coordinate of the third point.\n */\nfunction drawTestTriangle(ctx, u1, v1, u2, v2) {\n    ctx.beginPath();\n    ctx.moveTo(0, 0);\n    ctx.lineTo(u1, v1);\n    ctx.lineTo(u2, v2);\n    ctx.closePath();\n    ctx.save();\n    ctx.clip();\n    ctx.fillRect(0, 0, Math.max(u1, u2) + 1, Math.max(v1, v2));\n    ctx.restore();\n}\n/**\n * Given the data from getImageData, see if the right values appear at the provided offset.\n * Returns true if either the color or transparency is off\n *\n * @param {Uint8ClampedArray} data The data returned from getImageData\n * @param {number} offset The pixel offset from the start of data.\n * @return {boolean} true if the diagonal rendering is broken\n */\nfunction verifyBrokenDiagonalRendering(data, offset) {\n    // the values ought to be close to the rgba(210, 0, 0, 0.75)\n    return (Math.abs(data[offset * 4] - 210) > 2 ||\n        Math.abs(data[offset * 4 + 3] - 0.75 * 255) > 2);\n}\n/**\n * Determines if the current browser configuration can render triangular clip regions correctly.\n * This value is cached so the function is only expensive the first time called.\n * Firefox on Windows (as of now) does not if HWA is enabled. See https://bugzilla.mozilla.org/show_bug.cgi?id=1606976\n * IE also doesn't. Chrome works, and everything seems to work on OSX and Android. This function caches the\n * result. I suppose that it is conceivably possible that a browser might flip modes while the app is\n * running, but lets hope not.\n *\n * @return {boolean} true if the Diagonal Rendering is broken.\n */\nfunction isBrokenDiagonalRendering() {\n    if (brokenDiagonalRendering_ === undefined) {\n        var ctx = document.createElement('canvas').getContext('2d');\n        ctx.globalCompositeOperation = 'lighter';\n        ctx.fillStyle = 'rgba(210, 0, 0, 0.75)';\n        drawTestTriangle(ctx, 4, 5, 4, 0);\n        drawTestTriangle(ctx, 4, 5, 0, 5);\n        var data = ctx.getImageData(0, 0, 3, 3).data;\n        brokenDiagonalRendering_ =\n            verifyBrokenDiagonalRendering(data, 0) ||\n                verifyBrokenDiagonalRendering(data, 4) ||\n                verifyBrokenDiagonalRendering(data, 8);\n    }\n    return brokenDiagonalRendering_;\n}\n/**\n * Calculates ideal resolution to use from the source in order to achieve\n * pixel mapping as close as possible to 1:1 during reprojection.\n * The resolution is calculated regardless of what resolutions\n * are actually available in the dataset (TileGrid, Image, ...).\n *\n * @param {import(\"./proj/Projection.js\").default} sourceProj Source projection.\n * @param {import(\"./proj/Projection.js\").default} targetProj Target projection.\n * @param {import(\"./coordinate.js\").Coordinate} targetCenter Target center.\n * @param {number} targetResolution Target resolution.\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\n */\nexport function calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution) {\n    var sourceCenter = transform(targetCenter, targetProj, sourceProj);\n    // calculate the ideal resolution of the source data\n    var sourceResolution = getPointResolution(targetProj, targetResolution, targetCenter);\n    var targetMetersPerUnit = targetProj.getMetersPerUnit();\n    if (targetMetersPerUnit !== undefined) {\n        sourceResolution *= targetMetersPerUnit;\n    }\n    var sourceMetersPerUnit = sourceProj.getMetersPerUnit();\n    if (sourceMetersPerUnit !== undefined) {\n        sourceResolution /= sourceMetersPerUnit;\n    }\n    // Based on the projection properties, the point resolution at the specified\n    // coordinates may be slightly different. We need to reverse-compensate this\n    // in order to achieve optimal results.\n    var sourceExtent = sourceProj.getExtent();\n    if (!sourceExtent || containsCoordinate(sourceExtent, sourceCenter)) {\n        var compensationFactor = getPointResolution(sourceProj, sourceResolution, sourceCenter) /\n            sourceResolution;\n        if (isFinite(compensationFactor) && compensationFactor > 0) {\n            sourceResolution /= compensationFactor;\n        }\n    }\n    return sourceResolution;\n}\n/**\n * Calculates ideal resolution to use from the source in order to achieve\n * pixel mapping as close as possible to 1:1 during reprojection.\n * The resolution is calculated regardless of what resolutions\n * are actually available in the dataset (TileGrid, Image, ...).\n *\n * @param {import(\"./proj/Projection.js\").default} sourceProj Source projection.\n * @param {import(\"./proj/Projection.js\").default} targetProj Target projection.\n * @param {import(\"./extent.js\").Extent} targetExtent Target extent\n * @param {number} targetResolution Target resolution.\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\n */\nexport function calculateSourceExtentResolution(sourceProj, targetProj, targetExtent, targetResolution) {\n    var targetCenter = getCenter(targetExtent);\n    var sourceResolution = calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution);\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n        forEachCorner(targetExtent, function (corner) {\n            sourceResolution = calculateSourceResolution(sourceProj, targetProj, corner, targetResolution);\n            return isFinite(sourceResolution) && sourceResolution > 0;\n        });\n    }\n    return sourceResolution;\n}\n/**\n * @typedef {Object} ImageExtent\n * @property {import(\"./extent.js\").Extent} extent Extent.\n * @property {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.\n */\n/**\n * Renders the source data into new canvas based on the triangulation.\n *\n * @param {number} width Width of the canvas.\n * @param {number} height Height of the canvas.\n * @param {number} pixelRatio Pixel ratio.\n * @param {number} sourceResolution Source resolution.\n * @param {import(\"./extent.js\").Extent} sourceExtent Extent of the data source.\n * @param {number} targetResolution Target resolution.\n * @param {import(\"./extent.js\").Extent} targetExtent Target extent.\n * @param {import(\"./reproj/Triangulation.js\").default} triangulation Calculated triangulation.\n * @param {Array<ImageExtent>} sources Array of sources.\n * @param {number} gutter Gutter of the sources.\n * @param {boolean} [opt_renderEdges] Render reprojection edges.\n * @param {boolean} [opt_interpolate] Use linear interpolation when resampling.\n * @return {HTMLCanvasElement} Canvas with reprojected data.\n */\nexport function render(width, height, pixelRatio, sourceResolution, sourceExtent, targetResolution, targetExtent, triangulation, sources, gutter, opt_renderEdges, opt_interpolate) {\n    var context = createCanvasContext2D(Math.round(pixelRatio * width), Math.round(pixelRatio * height), canvasPool);\n    if (!opt_interpolate) {\n        assign(context, IMAGE_SMOOTHING_DISABLED);\n    }\n    if (sources.length === 0) {\n        return context.canvas;\n    }\n    context.scale(pixelRatio, pixelRatio);\n    function pixelRound(value) {\n        return Math.round(value * pixelRatio) / pixelRatio;\n    }\n    context.globalCompositeOperation = 'lighter';\n    var sourceDataExtent = createEmpty();\n    sources.forEach(function (src, i, arr) {\n        extend(sourceDataExtent, src.extent);\n    });\n    var canvasWidthInUnits = getWidth(sourceDataExtent);\n    var canvasHeightInUnits = getHeight(sourceDataExtent);\n    var stitchContext = createCanvasContext2D(Math.round((pixelRatio * canvasWidthInUnits) / sourceResolution), Math.round((pixelRatio * canvasHeightInUnits) / sourceResolution));\n    if (!opt_interpolate) {\n        assign(stitchContext, IMAGE_SMOOTHING_DISABLED);\n    }\n    var stitchScale = pixelRatio / sourceResolution;\n    sources.forEach(function (src, i, arr) {\n        var xPos = src.extent[0] - sourceDataExtent[0];\n        var yPos = -(src.extent[3] - sourceDataExtent[3]);\n        var srcWidth = getWidth(src.extent);\n        var srcHeight = getHeight(src.extent);\n        // This test should never fail -- but it does. Need to find a fix the upstream condition\n        if (src.image.width > 0 && src.image.height > 0) {\n            stitchContext.drawImage(src.image, gutter, gutter, src.image.width - 2 * gutter, src.image.height - 2 * gutter, xPos * stitchScale, yPos * stitchScale, srcWidth * stitchScale, srcHeight * stitchScale);\n        }\n    });\n    var targetTopLeft = getTopLeft(targetExtent);\n    triangulation.getTriangles().forEach(function (triangle, i, arr) {\n        /* Calculate affine transform (src -> dst)\n         * Resulting matrix can be used to transform coordinate\n         * from `sourceProjection` to destination pixels.\n         *\n         * To optimize number of context calls and increase numerical stability,\n         * we also do the following operations:\n         * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)\n         * here before solving the linear system so [ui, vi] are pixel coordinates.\n         *\n         * Src points: xi, yi\n         * Dst points: ui, vi\n         * Affine coefficients: aij\n         *\n         * | x0 y0 1  0  0 0 |   |a00|   |u0|\n         * | x1 y1 1  0  0 0 |   |a01|   |u1|\n         * | x2 y2 1  0  0 0 | x |a02| = |u2|\n         * |  0  0 0 x0 y0 1 |   |a10|   |v0|\n         * |  0  0 0 x1 y1 1 |   |a11|   |v1|\n         * |  0  0 0 x2 y2 1 |   |a12|   |v2|\n         */\n        var source = triangle.source;\n        var target = triangle.target;\n        var x0 = source[0][0], y0 = source[0][1];\n        var x1 = source[1][0], y1 = source[1][1];\n        var x2 = source[2][0], y2 = source[2][1];\n        // Make sure that everything is on pixel boundaries\n        var u0 = pixelRound((target[0][0] - targetTopLeft[0]) / targetResolution);\n        var v0 = pixelRound(-(target[0][1] - targetTopLeft[1]) / targetResolution);\n        var u1 = pixelRound((target[1][0] - targetTopLeft[0]) / targetResolution);\n        var v1 = pixelRound(-(target[1][1] - targetTopLeft[1]) / targetResolution);\n        var u2 = pixelRound((target[2][0] - targetTopLeft[0]) / targetResolution);\n        var v2 = pixelRound(-(target[2][1] - targetTopLeft[1]) / targetResolution);\n        // Shift all the source points to improve numerical stability\n        // of all the subsequent calculations. The [x0, y0] is used here.\n        // This is also used to simplify the linear system.\n        var sourceNumericalShiftX = x0;\n        var sourceNumericalShiftY = y0;\n        x0 = 0;\n        y0 = 0;\n        x1 -= sourceNumericalShiftX;\n        y1 -= sourceNumericalShiftY;\n        x2 -= sourceNumericalShiftX;\n        y2 -= sourceNumericalShiftY;\n        var augmentedMatrix = [\n            [x1, y1, 0, 0, u1 - u0],\n            [x2, y2, 0, 0, u2 - u0],\n            [0, 0, x1, y1, v1 - v0],\n            [0, 0, x2, y2, v2 - v0],\n        ];\n        var affineCoefs = solveLinearSystem(augmentedMatrix);\n        if (!affineCoefs) {\n            return;\n        }\n        context.save();\n        context.beginPath();\n        if (isBrokenDiagonalRendering() || !opt_interpolate) {\n            // Make sure that all lines are horizontal or vertical\n            context.moveTo(u1, v1);\n            // This is the diagonal line. Do it in 4 steps\n            var steps = 4;\n            var ud = u0 - u1;\n            var vd = v0 - v1;\n            for (var step = 0; step < steps; step++) {\n                // Go horizontally\n                context.lineTo(u1 + pixelRound(((step + 1) * ud) / steps), v1 + pixelRound((step * vd) / (steps - 1)));\n                // Go vertically\n                if (step != steps - 1) {\n                    context.lineTo(u1 + pixelRound(((step + 1) * ud) / steps), v1 + pixelRound(((step + 1) * vd) / (steps - 1)));\n                }\n            }\n            // We are almost at u0r, v0r\n            context.lineTo(u2, v2);\n        }\n        else {\n            context.moveTo(u1, v1);\n            context.lineTo(u0, v0);\n            context.lineTo(u2, v2);\n        }\n        context.clip();\n        context.transform(affineCoefs[0], affineCoefs[2], affineCoefs[1], affineCoefs[3], u0, v0);\n        context.translate(sourceDataExtent[0] - sourceNumericalShiftX, sourceDataExtent[3] - sourceNumericalShiftY);\n        context.scale(sourceResolution / pixelRatio, -sourceResolution / pixelRatio);\n        context.drawImage(stitchContext.canvas, 0, 0);\n        context.restore();\n    });\n    if (opt_renderEdges) {\n        context.save();\n        context.globalCompositeOperation = 'source-over';\n        context.strokeStyle = 'black';\n        context.lineWidth = 1;\n        triangulation.getTriangles().forEach(function (triangle, i, arr) {\n            var target = triangle.target;\n            var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;\n            var v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;\n            var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;\n            var v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;\n            var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;\n            var v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;\n            context.beginPath();\n            context.moveTo(u1, v1);\n            context.lineTo(u0, v0);\n            context.lineTo(u2, v2);\n            context.closePath();\n            context.stroke();\n        });\n        context.restore();\n    }\n    return context.canvas;\n}\n//# sourceMappingURL=reproj.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/reproj/Tile\n */\nimport { ERROR_THRESHOLD } from './common.js';\nimport EventType from '../events/EventType.js';\nimport Tile from '../Tile.js';\nimport TileState from '../TileState.js';\nimport Triangulation from './Triangulation.js';\nimport { calculateSourceExtentResolution, canvasPool, render as renderReprojected, } from '../reproj.js';\nimport { clamp } from '../math.js';\nimport { getArea, getIntersection } from '../extent.js';\nimport { listen, unlistenByKey } from '../events.js';\nimport { releaseCanvas } from '../dom.js';\n/**\n * @typedef {function(number, number, number, number) : import(\"../Tile.js\").default} FunctionType\n */\n/**\n * @classdesc\n * Class encapsulating single reprojected tile.\n * See {@link module:ol/source/TileImage~TileImage}.\n *\n */\nvar ReprojTile = /** @class */ (function (_super) {\n    __extends(ReprojTile, _super);\n    /**\n     * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n     * @param {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n     * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n     * @param {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n     * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n     * @param {import(\"../tilecoord.js\").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {number} gutter Gutter of the source tiles.\n     * @param {FunctionType} getTileFunction\n     *     Function returning source tiles (z, x, y, pixelRatio).\n     * @param {number} [opt_errorThreshold] Acceptable reprojection error (in px).\n     * @param {boolean} [opt_renderEdges] Render reprojection edges.\n     * @param {boolean} [opt_interpolate] Use linear interpolation when resampling.\n     */\n    function ReprojTile(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, opt_errorThreshold, opt_renderEdges, opt_interpolate) {\n        var _this = _super.call(this, tileCoord, TileState.IDLE, { interpolate: !!opt_interpolate }) || this;\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _this.renderEdges_ = opt_renderEdges !== undefined ? opt_renderEdges : false;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.pixelRatio_ = pixelRatio;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.gutter_ = gutter;\n        /**\n         * @private\n         * @type {HTMLCanvasElement}\n         */\n        _this.canvas_ = null;\n        /**\n         * @private\n         * @type {import(\"../tilegrid/TileGrid.js\").default}\n         */\n        _this.sourceTileGrid_ = sourceTileGrid;\n        /**\n         * @private\n         * @type {import(\"../tilegrid/TileGrid.js\").default}\n         */\n        _this.targetTileGrid_ = targetTileGrid;\n        /**\n         * @private\n         * @type {import(\"../tilecoord.js\").TileCoord}\n         */\n        _this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\n        /**\n         * @private\n         * @type {!Array<import(\"../Tile.js\").default>}\n         */\n        _this.sourceTiles_ = [];\n        /**\n         * @private\n         * @type {?Array<import(\"../events.js\").EventsKey>}\n         */\n        _this.sourcesListenerKeys_ = null;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.sourceZ_ = 0;\n        var targetExtent = targetTileGrid.getTileCoordExtent(_this.wrappedTileCoord_);\n        var maxTargetExtent = _this.targetTileGrid_.getExtent();\n        var maxSourceExtent = _this.sourceTileGrid_.getExtent();\n        var limitedTargetExtent = maxTargetExtent\n            ? getIntersection(targetExtent, maxTargetExtent)\n            : targetExtent;\n        if (getArea(limitedTargetExtent) === 0) {\n            // Tile is completely outside range -> EMPTY\n            // TODO: is it actually correct that the source even creates the tile ?\n            _this.state = TileState.EMPTY;\n            return _this;\n        }\n        var sourceProjExtent = sourceProj.getExtent();\n        if (sourceProjExtent) {\n            if (!maxSourceExtent) {\n                maxSourceExtent = sourceProjExtent;\n            }\n            else {\n                maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n            }\n        }\n        var targetResolution = targetTileGrid.getResolution(_this.wrappedTileCoord_[0]);\n        var sourceResolution = calculateSourceExtentResolution(sourceProj, targetProj, limitedTargetExtent, targetResolution);\n        if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n            // invalid sourceResolution -> EMPTY\n            // probably edges of the projections when no extent is defined\n            _this.state = TileState.EMPTY;\n            return _this;\n        }\n        var errorThresholdInPixels = opt_errorThreshold !== undefined ? opt_errorThreshold : ERROR_THRESHOLD;\n        /**\n         * @private\n         * @type {!import(\"./Triangulation.js\").default}\n         */\n        _this.triangulation_ = new Triangulation(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution);\n        if (_this.triangulation_.getTriangles().length === 0) {\n            // no valid triangles -> EMPTY\n            _this.state = TileState.EMPTY;\n            return _this;\n        }\n        _this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\n        var sourceExtent = _this.triangulation_.calculateSourceExtent();\n        if (maxSourceExtent) {\n            if (sourceProj.canWrapX()) {\n                sourceExtent[1] = clamp(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);\n                sourceExtent[3] = clamp(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);\n            }\n            else {\n                sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n            }\n        }\n        if (!getArea(sourceExtent)) {\n            _this.state = TileState.EMPTY;\n        }\n        else {\n            var sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(sourceExtent, _this.sourceZ_);\n            for (var srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n                for (var srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n                    var tile = getTileFunction(_this.sourceZ_, srcX, srcY, pixelRatio);\n                    if (tile) {\n                        _this.sourceTiles_.push(tile);\n                    }\n                }\n            }\n            if (_this.sourceTiles_.length === 0) {\n                _this.state = TileState.EMPTY;\n            }\n        }\n        return _this;\n    }\n    /**\n     * Get the HTML Canvas element for this tile.\n     * @return {HTMLCanvasElement} Canvas.\n     */\n    ReprojTile.prototype.getImage = function () {\n        return this.canvas_;\n    };\n    /**\n     * @private\n     */\n    ReprojTile.prototype.reproject_ = function () {\n        var sources = [];\n        this.sourceTiles_.forEach(function (tile, i, arr) {\n            if (tile && tile.getState() == TileState.LOADED) {\n                sources.push({\n                    extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),\n                    image: tile.getImage(),\n                });\n            }\n        }.bind(this));\n        this.sourceTiles_.length = 0;\n        if (sources.length === 0) {\n            this.state = TileState.ERROR;\n        }\n        else {\n            var z = this.wrappedTileCoord_[0];\n            var size = this.targetTileGrid_.getTileSize(z);\n            var width = typeof size === 'number' ? size : size[0];\n            var height = typeof size === 'number' ? size : size[1];\n            var targetResolution = this.targetTileGrid_.getResolution(z);\n            var sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);\n            var targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);\n            this.canvas_ = renderReprojected(width, height, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, this.renderEdges_, this.interpolate);\n            this.state = TileState.LOADED;\n        }\n        this.changed();\n    };\n    /**\n     * Load not yet loaded URI.\n     */\n    ReprojTile.prototype.load = function () {\n        if (this.state == TileState.IDLE) {\n            this.state = TileState.LOADING;\n            this.changed();\n            var leftToLoad_1 = 0;\n            this.sourcesListenerKeys_ = [];\n            this.sourceTiles_.forEach(function (tile, i, arr) {\n                var state = tile.getState();\n                if (state == TileState.IDLE || state == TileState.LOADING) {\n                    leftToLoad_1++;\n                    var sourceListenKey_1 = listen(tile, EventType.CHANGE, function (e) {\n                        var state = tile.getState();\n                        if (state == TileState.LOADED ||\n                            state == TileState.ERROR ||\n                            state == TileState.EMPTY) {\n                            unlistenByKey(sourceListenKey_1);\n                            leftToLoad_1--;\n                            if (leftToLoad_1 === 0) {\n                                this.unlistenSources_();\n                                this.reproject_();\n                            }\n                        }\n                    }, this);\n                    this.sourcesListenerKeys_.push(sourceListenKey_1);\n                }\n            }.bind(this));\n            if (leftToLoad_1 === 0) {\n                setTimeout(this.reproject_.bind(this), 0);\n            }\n            else {\n                this.sourceTiles_.forEach(function (tile, i, arr) {\n                    var state = tile.getState();\n                    if (state == TileState.IDLE) {\n                        tile.load();\n                    }\n                });\n            }\n        }\n    };\n    /**\n     * @private\n     */\n    ReprojTile.prototype.unlistenSources_ = function () {\n        this.sourcesListenerKeys_.forEach(unlistenByKey);\n        this.sourcesListenerKeys_ = null;\n    };\n    /**\n     * Remove from the cache due to expiry\n     */\n    ReprojTile.prototype.release = function () {\n        if (this.canvas_) {\n            releaseCanvas(this.canvas_.getContext('2d'));\n            canvasPool.push(this.canvas_);\n            this.canvas_ = null;\n        }\n        _super.prototype.release.call(this);\n    };\n    return ReprojTile;\n}(Tile));\nexport default ReprojTile;\n//# sourceMappingURL=Tile.js.map","/**\n * @module ol/reproj/common\n */\n/**\n * Default maximum allowed threshold  (in pixels) for reprojection\n * triangulation.\n * @type {number}\n */\nexport var ERROR_THRESHOLD = 0.5;\n/**\n * Enable automatic reprojection of raster sources. Default is `true`.\n * TODO: decide if we want to expose this as a build flag or remove it\n * @type {boolean}\n */\nexport var ENABLE_RASTER_REPROJECTION = true;\n//# sourceMappingURL=common.js.map","/**\n * @module ol/resolutionconstraint\n */\nimport { clamp } from './math.js';\nimport { getHeight, getWidth } from './extent.js';\nimport { linearFindNearest } from './array.js';\n/**\n * @typedef {function((number|undefined), number, import(\"./size.js\").Size, boolean=): (number|undefined)} Type\n */\n/**\n * Returns a modified resolution taking into account the viewport size and maximum\n * allowed extent.\n * @param {number} resolution Resolution\n * @param {import(\"./extent.js\").Extent} maxExtent Maximum allowed extent.\n * @param {import(\"./size.js\").Size} viewportSize Viewport size.\n * @param {boolean} showFullExtent Whether to show the full extent.\n * @return {number} Capped resolution.\n */\nfunction getViewportClampedResolution(resolution, maxExtent, viewportSize, showFullExtent) {\n    var xResolution = getWidth(maxExtent) / viewportSize[0];\n    var yResolution = getHeight(maxExtent) / viewportSize[1];\n    if (showFullExtent) {\n        return Math.min(resolution, Math.max(xResolution, yResolution));\n    }\n    return Math.min(resolution, Math.min(xResolution, yResolution));\n}\n/**\n * Returns a modified resolution to be between maxResolution and minResolution while\n * still allowing the value to be slightly out of bounds.\n * Note: the computation is based on the logarithm function (ln):\n *  - at 1, ln(x) is 0\n *  - above 1, ln(x) keeps increasing but at a much slower pace than x\n * The final result is clamped to prevent getting too far away from bounds.\n * @param {number} resolution Resolution.\n * @param {number} maxResolution Max resolution.\n * @param {number} minResolution Min resolution.\n * @return {number} Smoothed resolution.\n */\nfunction getSmoothClampedResolution(resolution, maxResolution, minResolution) {\n    var result = Math.min(resolution, maxResolution);\n    var ratio = 50;\n    result *=\n        Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio +\n            1;\n    if (minResolution) {\n        result = Math.max(result, minResolution);\n        result /=\n            Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) /\n                ratio +\n                1;\n    }\n    return clamp(result, minResolution / 2, maxResolution * 2);\n}\n/**\n * @param {Array<number>} resolutions Resolutions.\n * @param {boolean} [opt_smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\n * @param {import(\"./extent.js\").Extent} [opt_maxExtent] Maximum allowed extent.\n * @param {boolean} [opt_showFullExtent] If true, allows us to show the full extent. Default: false.\n * @return {Type} Zoom function.\n */\nexport function createSnapToResolutions(resolutions, opt_smooth, opt_maxExtent, opt_showFullExtent) {\n    return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} direction Direction.\n     * @param {import(\"./size.js\").Size} size Viewport size.\n     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, direction, size, opt_isMoving) {\n        if (resolution !== undefined) {\n            var maxResolution = resolutions[0];\n            var minResolution = resolutions[resolutions.length - 1];\n            var cappedMaxRes = opt_maxExtent\n                ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent)\n                : maxResolution;\n            // during interacting or animating, allow intermediary values\n            if (opt_isMoving) {\n                var smooth = opt_smooth !== undefined ? opt_smooth : true;\n                if (!smooth) {\n                    return clamp(resolution, minResolution, cappedMaxRes);\n                }\n                return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);\n            }\n            var capped = Math.min(cappedMaxRes, resolution);\n            var z = Math.floor(linearFindNearest(resolutions, capped, direction));\n            if (resolutions[z] > cappedMaxRes && z < resolutions.length - 1) {\n                return resolutions[z + 1];\n            }\n            return resolutions[z];\n        }\n        else {\n            return undefined;\n        }\n    });\n}\n/**\n * @param {number} power Power.\n * @param {number} maxResolution Maximum resolution.\n * @param {number} [opt_minResolution] Minimum resolution.\n * @param {boolean} [opt_smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\n * @param {import(\"./extent.js\").Extent} [opt_maxExtent] Maximum allowed extent.\n * @param {boolean} [opt_showFullExtent] If true, allows us to show the full extent. Default: false.\n * @return {Type} Zoom function.\n */\nexport function createSnapToPower(power, maxResolution, opt_minResolution, opt_smooth, opt_maxExtent, opt_showFullExtent) {\n    return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} direction Direction.\n     * @param {import(\"./size.js\").Size} size Viewport size.\n     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, direction, size, opt_isMoving) {\n        if (resolution !== undefined) {\n            var cappedMaxRes = opt_maxExtent\n                ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent)\n                : maxResolution;\n            var minResolution = opt_minResolution !== undefined ? opt_minResolution : 0;\n            // during interacting or animating, allow intermediary values\n            if (opt_isMoving) {\n                var smooth = opt_smooth !== undefined ? opt_smooth : true;\n                if (!smooth) {\n                    return clamp(resolution, minResolution, cappedMaxRes);\n                }\n                return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);\n            }\n            var tolerance = 1e-9;\n            var minZoomLevel = Math.ceil(Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance);\n            var offset = -direction * (0.5 - tolerance) + 0.5;\n            var capped = Math.min(cappedMaxRes, resolution);\n            var cappedZoomLevel = Math.floor(Math.log(maxResolution / capped) / Math.log(power) + offset);\n            var zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);\n            var newResolution = maxResolution / Math.pow(power, zoomLevel);\n            return clamp(newResolution, minResolution, cappedMaxRes);\n        }\n        else {\n            return undefined;\n        }\n    });\n}\n/**\n * @param {number} maxResolution Max resolution.\n * @param {number} minResolution Min resolution.\n * @param {boolean} [opt_smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\n * @param {import(\"./extent.js\").Extent} [opt_maxExtent] Maximum allowed extent.\n * @param {boolean} [opt_showFullExtent] If true, allows us to show the full extent. Default: false.\n * @return {Type} Zoom function.\n */\nexport function createMinMaxResolution(maxResolution, minResolution, opt_smooth, opt_maxExtent, opt_showFullExtent) {\n    return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} direction Direction.\n     * @param {import(\"./size.js\").Size} size Viewport size.\n     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, direction, size, opt_isMoving) {\n        if (resolution !== undefined) {\n            var cappedMaxRes = opt_maxExtent\n                ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent)\n                : maxResolution;\n            var smooth = opt_smooth !== undefined ? opt_smooth : true;\n            if (!smooth || !opt_isMoving) {\n                return clamp(resolution, minResolution, cappedMaxRes);\n            }\n            return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);\n        }\n        else {\n            return undefined;\n        }\n    });\n}\n//# sourceMappingURL=resolutionconstraint.js.map","/**\n * @module ol/rotationconstraint\n */\nimport { toRadians } from './math.js';\n/**\n * @typedef {function((number|undefined), boolean=): (number|undefined)} Type\n */\n/**\n * @param {number|undefined} rotation Rotation.\n * @return {number|undefined} Rotation.\n */\nexport function disable(rotation) {\n    if (rotation !== undefined) {\n        return 0;\n    }\n    else {\n        return undefined;\n    }\n}\n/**\n * @param {number|undefined} rotation Rotation.\n * @return {number|undefined} Rotation.\n */\nexport function none(rotation) {\n    if (rotation !== undefined) {\n        return rotation;\n    }\n    else {\n        return undefined;\n    }\n}\n/**\n * @param {number} n N.\n * @return {Type} Rotation constraint.\n */\nexport function createSnapToN(n) {\n    var theta = (2 * Math.PI) / n;\n    return (\n    /**\n     * @param {number|undefined} rotation Rotation.\n     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Rotation.\n     */\n    function (rotation, opt_isMoving) {\n        if (opt_isMoving) {\n            return rotation;\n        }\n        if (rotation !== undefined) {\n            rotation = Math.floor(rotation / theta + 0.5) * theta;\n            return rotation;\n        }\n        else {\n            return undefined;\n        }\n    });\n}\n/**\n * @param {number} [opt_tolerance] Tolerance.\n * @return {Type} Rotation constraint.\n */\nexport function createSnapToZero(opt_tolerance) {\n    var tolerance = opt_tolerance || toRadians(5);\n    return (\n    /**\n     * @param {number|undefined} rotation Rotation.\n     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Rotation.\n     */\n    function (rotation, opt_isMoving) {\n        if (opt_isMoving) {\n            return rotation;\n        }\n        if (rotation !== undefined) {\n            if (Math.abs(rotation) <= tolerance) {\n                return 0;\n            }\n            else {\n                return rotation;\n            }\n        }\n        else {\n            return undefined;\n        }\n    });\n}\n//# sourceMappingURL=rotationconstraint.js.map","/**\n * @module ol/size\n */\n/**\n * An array of numbers representing a size: `[width, height]`.\n * @typedef {Array<number>} Size\n * @api\n */\n/**\n * Returns a buffered size.\n * @param {Size} size Size.\n * @param {number} num The amount by which to buffer.\n * @param {Size} [opt_size] Optional reusable size array.\n * @return {Size} The buffered size.\n */\nexport function buffer(size, num, opt_size) {\n    if (opt_size === undefined) {\n        opt_size = [0, 0];\n    }\n    opt_size[0] = size[0] + 2 * num;\n    opt_size[1] = size[1] + 2 * num;\n    return opt_size;\n}\n/**\n * Determines if a size has a positive area.\n * @param {Size} size The size to test.\n * @return {boolean} The size has a positive area.\n */\nexport function hasArea(size) {\n    return size[0] > 0 && size[1] > 0;\n}\n/**\n * Returns a size scaled by a ratio. The result will be an array of integers.\n * @param {Size} size Size.\n * @param {number} ratio Ratio.\n * @param {Size} [opt_size] Optional reusable size array.\n * @return {Size} The scaled size.\n */\nexport function scale(size, ratio, opt_size) {\n    if (opt_size === undefined) {\n        opt_size = [0, 0];\n    }\n    opt_size[0] = (size[0] * ratio + 0.5) | 0;\n    opt_size[1] = (size[1] * ratio + 0.5) | 0;\n    return opt_size;\n}\n/**\n * Returns an `Size` array for the passed in number (meaning: square) or\n * `Size` array.\n * (meaning: non-square),\n * @param {number|Size} size Width and height.\n * @param {Size} [opt_size] Optional reusable size array.\n * @return {Size} Size.\n * @api\n */\nexport function toSize(size, opt_size) {\n    if (Array.isArray(size)) {\n        return size;\n    }\n    else {\n        if (opt_size === undefined) {\n            opt_size = [size, size];\n        }\n        else {\n            opt_size[0] = size;\n            opt_size[1] = size;\n        }\n        return opt_size;\n    }\n}\n//# sourceMappingURL=size.js.map"],"names":["MAX_SUBDIVISION","MAX_TRIANGLE_WIDTH","Triangulation","sourceProj","targetProj","targetExtent","maxSourceExtent","errorThreshold","opt_destinationResolution","this","sourceProj_","targetProj_","transformInvCache","transformInv","transformInv_","c","key","maxSourceExtent_","errorThresholdSquared_","triangles_","wrapsXInSource_","canWrapXInSource_","canWrapX","getExtent","sourceWorldWidth_","targetWorldWidth_","destinationTopLeft","destinationTopRight","destinationBottomRight","destinationBottomLeft","sourceTopLeft","sourceTopRight","sourceBottomRight","sourceBottomLeft","maxSubdivision","Math","max","ceil","addQuad_","leftBound_1","Infinity","forEach","triangle","i","arr","min","source","newTriangle","minX","maxX","bind","prototype","addTriangle_","a","b","aSrc","bSrc","cSrc","push","target","d","dSrc","sourceQuadExtent","sourceCoverageX","sourceWorldWidth","wrapsX","needsSubdivision","isGlobal","targetQuadExtent","targetCoverageX","isFinite","isNotFinite","center","centerSrc","dx","centerSrcEstimX","dy","centerSrcErrorSquared","abs","bc","bcSrc","da","daSrc","ab","abSrc","cd","cdSrc","calculateSourceExtent","extent","src","getTriangles","brokenDiagonalRendering_","canvasPool","drawTestTriangle","ctx","u1","v1","u2","v2","beginPath","moveTo","lineTo","closePath","save","clip","fillRect","restore","verifyBrokenDiagonalRendering","data","offset","isBrokenDiagonalRendering","undefined","document","createElement","getContext","globalCompositeOperation","fillStyle","getImageData","calculateSourceResolution","targetCenter","targetResolution","sourceCenter","sourceResolution","targetMetersPerUnit","getMetersPerUnit","sourceMetersPerUnit","sourceExtent","compensationFactor","calculateSourceExtentResolution","corner","render","width","height","pixelRatio","triangulation","sources","gutter","opt_renderEdges","opt_interpolate","context","round","length","canvas","pixelRound","value","scale","sourceDataExtent","canvasWidthInUnits","canvasHeightInUnits","stitchContext","stitchScale","xPos","yPos","srcWidth","srcHeight","image","drawImage","targetTopLeft","x0","y0","x1","y1","x2","y2","u0","v0","sourceNumericalShiftX","sourceNumericalShiftY","augmentedMatrix","affineCoefs","steps","ud","vd","step","transform","translate","strokeStyle","lineWidth","stroke","__extends","extendStatics","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","call","TypeError","String","__","constructor","create","ReprojTile","_super","sourceTileGrid","targetTileGrid","tileCoord","wrappedTileCoord","getTileFunction","opt_errorThreshold","_this","TileState","interpolate","renderEdges_","pixelRatio_","gutter_","canvas_","sourceTileGrid_","targetTileGrid_","wrappedTileCoord_","sourceTiles_","sourcesListenerKeys_","sourceZ_","getTileCoordExtent","maxTargetExtent","limitedTargetExtent","state","sourceProjExtent","getResolution","errorThresholdInPixels","triangulation_","getZForResolution","sourceRange","getTileRangeForExtentAndZ","srcX","srcY","minY","maxY","tile","getImage","reproject_","getState","z","size","getTileSize","changed","load","leftToLoad_1","sourceListenKey_1","EventType","e","unlistenSources_","setTimeout","release","Tile","ERROR_THRESHOLD","ENABLE_RASTER_REPROJECTION","getViewportClampedResolution","resolution","maxExtent","viewportSize","showFullExtent","xResolution","yResolution","getSmoothClampedResolution","maxResolution","minResolution","result","ratio","log","createSnapToResolutions","resolutions","opt_smooth","opt_maxExtent","opt_showFullExtent","direction","opt_isMoving","cappedMaxRes","smooth","capped","floor","createSnapToPower","power","opt_minResolution","tolerance","minZoomLevel","cappedZoomLevel","zoomLevel","newResolution","pow","createMinMaxResolution","disable","rotation","none","createSnapToN","n","theta","PI","createSnapToZero","opt_tolerance","hasArea","opt_size","toSize","isArray"],"sourceRoot":""}
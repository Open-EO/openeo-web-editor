{"version":3,"file":"js/9421.8fa987ad.js","mappings":"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B,EAAI,EAAGA,EAAI2iB,IAAU3iB,EACxBghB,EAAahhB,GAAKqoB,EAASroB,GAE7BghB,EAAazhB,OAASojB,CACxB,CAEF,OAAO1B,CACT,CAgBO,SAASqH,EACd/E,EACAgC,EACApB,EACAxB,EACAwF,EACAC,EACA7lB,EACAC,EACAwe,EACAC,EACAoH,GAEAA,EAAWA,GAAsB,CAAC/G,IAAKA,KACvC,IAAK,IAAIthB,EAAI,EAAGwG,EAAK2d,EAAK5kB,OAAQS,EAAIwG,IAAMxG,EAAG,CAC7C,MAAMG,EAAMgkB,EAAKnkB,GACjBihB,EAAqBiH,EACnB3E,EACAgC,EACAplB,EACAwiB,EACAwF,EACAC,EACA7lB,EACAC,EACAwe,EACAC,EACAoH,GAEF9C,EAASplB,CACX,CACA,OAAO8gB,CACT,CAgBO,SAASsH,EACdhF,EACAgC,EACAiC,EACA7E,EACAwF,EACAC,EACA7lB,EACAC,EACAwe,EACAC,EACAoH,GAEAA,EAAWA,GAAsB,CAAC/G,IAAKA,KACvC,IAAK,IAAIthB,EAAI,EAAGwG,EAAKghB,EAAMjoB,OAAQS,EAAIwG,IAAMxG,EAAG,CAC9C,MAAMmkB,EAAOqD,EAAMxnB,GACnBihB,EAAqBqH,EACnB/E,EACAgC,EACApB,EACAxB,EACAwF,EACAC,EACA7lB,EACAC,EACAwe,EACAC,EACAoH,GAEF9C,EAASpB,EAAKA,EAAK5kB,OAAS,EAC9B,CACA,OAAO0hB,CACT,C,8EClUO,SAASuH,EACdjF,EACAgC,EACAplB,EACAwiB,EACAphB,GAEA,MAAMknB,GAAU,QACdlnB,GAKA,SAAUkgB,GACR,OAAQiH,EACNnF,EACAgC,EACAplB,EACAwiB,EACAlB,EAAW,GACXA,EAAW,GAEf,IAEF,OAAQgH,CACV,CAWO,SAASC,EACdnF,EACAgC,EACAplB,EACAwiB,EACApgB,EACAC,GASA,IAAImmB,EAAK,EACLzB,EAAK3D,EAAgBpjB,EAAMwiB,GAC3BwE,EAAK5D,EAAgBpjB,EAAMwiB,EAAS,GACxC,KAAO4C,EAASplB,EAAKolB,GAAU5C,EAAQ,CACrC,M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","sources":["webpack://@openeo/web-editor/./node_modules/ol/array.js","webpack://@openeo/web-editor/./node_modules/ol/centerconstraint.js","webpack://@openeo/web-editor/./node_modules/ol/color.js","webpack://@openeo/web-editor/./node_modules/ol/colorlike.js","webpack://@openeo/web-editor/./node_modules/ol/control/Control.js","webpack://@openeo/web-editor/./node_modules/ol/control/FullScreen.js","webpack://@openeo/web-editor/./node_modules/ol/control/ScaleLine.js","webpack://@openeo/web-editor/./node_modules/ol/control/Attribution.js","webpack://@openeo/web-editor/./node_modules/ol/control/Rotate.js","webpack://@openeo/web-editor/./node_modules/ol/control/Zoom.js","webpack://@openeo/web-editor/./node_modules/ol/control/defaults.js","webpack://@openeo/web-editor/./node_modules/ol/css.js","webpack://@openeo/web-editor/./node_modules/ol/dom.js","webpack://@openeo/web-editor/./node_modules/ol/easing.js","webpack://@openeo/web-editor/./node_modules/ol/events.js","webpack://@openeo/web-editor/./node_modules/ol/events/Event.js","webpack://@openeo/web-editor/./node_modules/ol/events/EventType.js","webpack://@openeo/web-editor/./node_modules/ol/events/KeyCode.js","webpack://@openeo/web-editor/./node_modules/ol/events/Target.js","webpack://@openeo/web-editor/./node_modules/ol/events/condition.js","webpack://@openeo/web-editor/./node_modules/ol/featureloader.js","webpack://@openeo/web-editor/./node_modules/ol/functions.js","webpack://@openeo/web-editor/./node_modules/ol/geom/Geometry.js","webpack://@openeo/web-editor/./node_modules/ol/geom/LinearRing.js","webpack://@openeo/web-editor/./node_modules/ol/geom/Point.js","webpack://@openeo/web-editor/./node_modules/ol/geom/Polygon.js","webpack://@openeo/web-editor/./node_modules/ol/geom/SimpleGeometry.js","webpack://@openeo/web-editor/./node_modules/ol/geom/flat/area.js","webpack://@openeo/web-editor/./node_modules/ol/geom/flat/closest.js","webpack://@openeo/web-editor/./node_modules/ol/geom/flat/contains.js","webpack://@openeo/web-editor/./node_modules/ol/geom/flat/deflate.js","webpack://@openeo/web-editor/./node_modules/ol/geom/flat/inflate.js","webpack://@openeo/web-editor/./node_modules/ol/geom/flat/interiorpoint.js","webpack://@openeo/web-editor/./node_modules/ol/geom/flat/intersectsextent.js","webpack://@openeo/web-editor/./node_modules/ol/geom/flat/length.js","webpack://@openeo/web-editor/./node_modules/ol/geom/flat/reverse.js","webpack://@openeo/web-editor/./node_modules/ol/geom/flat/orient.js","webpack://@openeo/web-editor/./node_modules/ol/geom/flat/segments.js","webpack://@openeo/web-editor/./node_modules/ol/geom/flat/simplify.js","webpack://@openeo/web-editor/./node_modules/ol/geom/flat/straightchunk.js","webpack://@openeo/web-editor/./node_modules/ol/geom/flat/textpath.js","webpack://@openeo/web-editor/./node_modules/ol/geom/flat/transform.js"],"sourcesContent":["/**\n * @module ol/array\n */\n\n/**\n * Performs a binary search on the provided sorted list and returns the index of the item if found. If it can't be found it'll return -1.\n * https://github.com/darkskyapp/binary-search\n *\n * @param {Array<*>} haystack Items to search through.\n * @param {*} needle The item to look for.\n * @param {Function} [comparator] Comparator function.\n * @return {number} The index of the item if found, -1 if not.\n */\nexport function binarySearch(haystack, needle, comparator) {\n  let mid, cmp;\n  comparator = comparator || ascending;\n  let low = 0;\n  let high = haystack.length;\n  let found = false;\n\n  while (low < high) {\n    /* Note that \"(low + high) >>> 1\" may overflow, and results in a typecast\n     * to double (which gives the wrong results). */\n    mid = low + ((high - low) >> 1);\n    cmp = +comparator(haystack[mid], needle);\n\n    if (cmp < 0.0) {\n      /* Too low. */\n      low = mid + 1;\n    } else {\n      /* Key found or too high */\n      high = mid;\n      found = !cmp;\n    }\n  }\n\n  /* Key not found. */\n  return found ? low : ~low;\n}\n\n/**\n * Compare function sorting arrays in ascending order.  Safe to use for numeric values.\n * @param {*} a The first object to be compared.\n * @param {*} b The second object to be compared.\n * @return {number} A negative number, zero, or a positive number as the first\n *     argument is less than, equal to, or greater than the second.\n */\nexport function ascending(a, b) {\n  return a > b ? 1 : a < b ? -1 : 0;\n}\n\n/**\n * {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution} can use a function\n * of this type to determine which nearest resolution to use.\n *\n * This function takes a `{number}` representing a value between two array entries,\n * a `{number}` representing the value of the nearest higher entry and\n * a `{number}` representing the value of the nearest lower entry\n * as arguments and returns a `{number}`. If a negative number or zero is returned\n * the lower value will be used, if a positive number is returned the higher value\n * will be used.\n * @typedef {function(number, number, number): number} NearestDirectionFunction\n * @api\n */\n\n/**\n * @param {Array<number>} arr Array in descending order.\n * @param {number} target Target.\n * @param {number|NearestDirectionFunction} direction\n *    0 means return the nearest,\n *    > 0 means return the largest nearest,\n *    < 0 means return the smallest nearest.\n * @return {number} Index.\n */\nexport function linearFindNearest(arr, target, direction) {\n  const n = arr.length;\n  if (arr[0] <= target) {\n    return 0;\n  } else if (target <= arr[n - 1]) {\n    return n - 1;\n  }\n  let i;\n  if (direction > 0) {\n    for (i = 1; i < n; ++i) {\n      if (arr[i] < target) {\n        return i - 1;\n      }\n    }\n  } else if (direction < 0) {\n    for (i = 1; i < n; ++i) {\n      if (arr[i] <= target) {\n        return i;\n      }\n    }\n  } else {\n    for (i = 1; i < n; ++i) {\n      if (arr[i] == target) {\n        return i;\n      } else if (arr[i] < target) {\n        if (typeof direction === 'function') {\n          if (direction(target, arr[i - 1], arr[i]) > 0) {\n            return i - 1;\n          }\n          return i;\n        } else if (arr[i - 1] - target < target - arr[i]) {\n          return i - 1;\n        }\n        return i;\n      }\n    }\n  }\n  return n - 1;\n}\n\n/**\n * @param {Array<*>} arr Array.\n * @param {number} begin Begin index.\n * @param {number} end End index.\n */\nexport function reverseSubArray(arr, begin, end) {\n  while (begin < end) {\n    const tmp = arr[begin];\n    arr[begin] = arr[end];\n    arr[end] = tmp;\n    ++begin;\n    --end;\n  }\n}\n\n/**\n * @param {Array<VALUE>} arr The array to modify.\n * @param {!Array<VALUE>|VALUE} data The elements or arrays of elements to add to arr.\n * @template VALUE\n */\nexport function extend(arr, data) {\n  const extension = Array.isArray(data) ? data : [data];\n  const length = extension.length;\n  for (let i = 0; i < length; i++) {\n    arr[arr.length] = extension[i];\n  }\n}\n\n/**\n * @param {Array<VALUE>} arr The array to modify.\n * @param {VALUE} obj The element to remove.\n * @template VALUE\n * @return {boolean} If the element was removed.\n */\nexport function remove(arr, obj) {\n  const i = arr.indexOf(obj);\n  const found = i > -1;\n  if (found) {\n    arr.splice(i, 1);\n  }\n  return found;\n}\n\n/**\n * @param {Array|Uint8ClampedArray} arr1 The first array to compare.\n * @param {Array|Uint8ClampedArray} arr2 The second array to compare.\n * @return {boolean} Whether the two arrays are equal.\n */\nexport function equals(arr1, arr2) {\n  const len1 = arr1.length;\n  if (len1 !== arr2.length) {\n    return false;\n  }\n  for (let i = 0; i < len1; i++) {\n    if (arr1[i] !== arr2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Sort the passed array such that the relative order of equal elements is preserved.\n * See https://en.wikipedia.org/wiki/Sorting_algorithm#Stability for details.\n * @param {Array<*>} arr The array to sort (modifies original).\n * @param {!function(*, *): number} compareFnc Comparison function.\n * @api\n */\nexport function stableSort(arr, compareFnc) {\n  const length = arr.length;\n  const tmp = Array(arr.length);\n  let i;\n  for (i = 0; i < length; i++) {\n    tmp[i] = {index: i, value: arr[i]};\n  }\n  tmp.sort(function (a, b) {\n    return compareFnc(a.value, b.value) || a.index - b.index;\n  });\n  for (i = 0; i < arr.length; i++) {\n    arr[i] = tmp[i].value;\n  }\n}\n\n/**\n * @param {Array<*>} arr The array to test.\n * @param {Function} [func] Comparison function.\n * @param {boolean} [strict] Strictly sorted (default false).\n * @return {boolean} Return index.\n */\nexport function isSorted(arr, func, strict) {\n  const compare = func || ascending;\n  return arr.every(function (currentVal, index) {\n    if (index === 0) {\n      return true;\n    }\n    const res = compare(arr[index - 1], currentVal);\n    return !(res > 0 || (strict && res === 0));\n  });\n}\n","/**\n * @module ol/centerconstraint\n */\nimport {clamp} from './math.js';\n\n/**\n * @typedef {function((import(\"./coordinate.js\").Coordinate|undefined), number, import(\"./size.js\").Size, boolean=, Array<number>=): (import(\"./coordinate.js\").Coordinate|undefined)} Type\n */\n\n/**\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {boolean} onlyCenter If true, the constraint will only apply to the view center.\n * @param {boolean} smooth If true, the view will be able to go slightly out of the given extent\n * (only during interaction and animation).\n * @return {Type} The constraint.\n */\nexport function createExtent(extent, onlyCenter, smooth) {\n  return (\n    /**\n     * @param {import(\"./coordinate.js\").Coordinate|undefined} center Center.\n     * @param {number|undefined} resolution Resolution.\n     * @param {import(\"./size.js\").Size} size Viewport size; unused if `onlyCenter` was specified.\n     * @param {boolean} [isMoving] True if an interaction or animation is in progress.\n     * @param {Array<number>} [centerShift] Shift between map center and viewport center.\n     * @return {import(\"./coordinate.js\").Coordinate|undefined} Center.\n     */\n    function (center, resolution, size, isMoving, centerShift) {\n      if (!center) {\n        return undefined;\n      }\n      if (!resolution && !onlyCenter) {\n        return center;\n      }\n      const viewWidth = onlyCenter ? 0 : size[0] * resolution;\n      const viewHeight = onlyCenter ? 0 : size[1] * resolution;\n      const shiftX = centerShift ? centerShift[0] : 0;\n      const shiftY = centerShift ? centerShift[1] : 0;\n      let minX = extent[0] + viewWidth / 2 + shiftX;\n      let maxX = extent[2] - viewWidth / 2 + shiftX;\n      let minY = extent[1] + viewHeight / 2 + shiftY;\n      let maxY = extent[3] - viewHeight / 2 + shiftY;\n\n      // note: when zooming out of bounds, min and max values for x and y may\n      // end up inverted (min > max); this has to be accounted for\n      if (minX > maxX) {\n        minX = (maxX + minX) / 2;\n        maxX = minX;\n      }\n      if (minY > maxY) {\n        minY = (maxY + minY) / 2;\n        maxY = minY;\n      }\n\n      let x = clamp(center[0], minX, maxX);\n      let y = clamp(center[1], minY, maxY);\n\n      // during an interaction, allow some overscroll\n      if (isMoving && smooth && resolution) {\n        const ratio = 30 * resolution;\n        x +=\n          -ratio * Math.log(1 + Math.max(0, minX - center[0]) / ratio) +\n          ratio * Math.log(1 + Math.max(0, center[0] - maxX) / ratio);\n        y +=\n          -ratio * Math.log(1 + Math.max(0, minY - center[1]) / ratio) +\n          ratio * Math.log(1 + Math.max(0, center[1] - maxY) / ratio);\n      }\n\n      return [x, y];\n    }\n  );\n}\n\n/**\n * @param {import(\"./coordinate.js\").Coordinate} [center] Center.\n * @return {import(\"./coordinate.js\").Coordinate|undefined} Center.\n */\nexport function none(center) {\n  return center;\n}\n","/**\n * @module ol/color\n */\nimport {assert} from './asserts.js';\nimport {clamp} from './math.js';\n\n/**\n * A color represented as a short array [red, green, blue, alpha].\n * red, green, and blue should be integers in the range 0..255 inclusive.\n * alpha should be a float in the range 0..1 inclusive. If no alpha value is\n * given then `1` will be used.\n * @typedef {Array<number>} Color\n * @api\n */\n\n/**\n * This RegExp matches # followed by 3, 4, 6, or 8 hex digits.\n * @const\n * @type {RegExp}\n * @private\n */\nconst HEX_COLOR_RE_ = /^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i;\n\n/**\n * Regular expression for matching potential named color style strings.\n * @const\n * @type {RegExp}\n * @private\n */\nconst NAMED_COLOR_RE_ = /^([a-z]*)$|^hsla?\\(.*\\)$/i;\n\n/**\n * Return the color as an rgba string.\n * @param {Color|string} color Color.\n * @return {string} Rgba string.\n * @api\n */\nexport function asString(color) {\n  if (typeof color === 'string') {\n    return color;\n  }\n  return toString(color);\n}\n\n/**\n * Return named color as an rgba string.\n * @param {string} color Named color.\n * @return {string} Rgb string.\n */\nfunction fromNamed(color) {\n  const el = document.createElement('div');\n  el.style.color = color;\n  if (el.style.color !== '') {\n    document.body.appendChild(el);\n    const rgb = getComputedStyle(el).color;\n    document.body.removeChild(el);\n    return rgb;\n  }\n  return '';\n}\n\n/**\n * @param {string} s String.\n * @return {Color} Color.\n */\nexport const fromString = (function () {\n  // We maintain a small cache of parsed strings.  To provide cheap LRU-like\n  // semantics, whenever the cache grows too large we simply delete an\n  // arbitrary 25% of the entries.\n\n  /**\n   * @const\n   * @type {number}\n   */\n  const MAX_CACHE_SIZE = 1024;\n\n  /**\n   * @type {Object<string, Color>}\n   */\n  const cache = {};\n\n  /**\n   * @type {number}\n   */\n  let cacheSize = 0;\n\n  return (\n    /**\n     * @param {string} s String.\n     * @return {Color} Color.\n     */\n    function (s) {\n      let color;\n      if (cache.hasOwnProperty(s)) {\n        color = cache[s];\n      } else {\n        if (cacheSize >= MAX_CACHE_SIZE) {\n          let i = 0;\n          for (const key in cache) {\n            if ((i++ & 3) === 0) {\n              delete cache[key];\n              --cacheSize;\n            }\n          }\n        }\n        color = fromStringInternal_(s);\n        cache[s] = color;\n        ++cacheSize;\n      }\n      return color;\n    }\n  );\n})();\n\n/**\n * Return the color as an array. This function maintains a cache of calculated\n * arrays which means the result should not be modified.\n * @param {Color|string} color Color.\n * @return {Color} Color.\n * @api\n */\nexport function asArray(color) {\n  if (Array.isArray(color)) {\n    return color;\n  }\n  return fromString(color);\n}\n\n/**\n * @param {string} s String.\n * @private\n * @return {Color} Color.\n */\nfunction fromStringInternal_(s) {\n  let r, g, b, a, color;\n\n  if (NAMED_COLOR_RE_.exec(s)) {\n    s = fromNamed(s);\n  }\n\n  if (HEX_COLOR_RE_.exec(s)) {\n    // hex\n    const n = s.length - 1; // number of hex digits\n    let d; // number of digits per channel\n    if (n <= 4) {\n      d = 1;\n    } else {\n      d = 2;\n    }\n    const hasAlpha = n === 4 || n === 8;\n    r = parseInt(s.substr(1 + 0 * d, d), 16);\n    g = parseInt(s.substr(1 + 1 * d, d), 16);\n    b = parseInt(s.substr(1 + 2 * d, d), 16);\n    if (hasAlpha) {\n      a = parseInt(s.substr(1 + 3 * d, d), 16);\n    } else {\n      a = 255;\n    }\n    if (d == 1) {\n      r = (r << 4) + r;\n      g = (g << 4) + g;\n      b = (b << 4) + b;\n      if (hasAlpha) {\n        a = (a << 4) + a;\n      }\n    }\n    color = [r, g, b, a / 255];\n  } else if (s.startsWith('rgba(')) {\n    // rgba()\n    color = s.slice(5, -1).split(',').map(Number);\n    normalize(color);\n  } else if (s.startsWith('rgb(')) {\n    // rgb()\n    color = s.slice(4, -1).split(',').map(Number);\n    color.push(1);\n    normalize(color);\n  } else {\n    assert(false, 14); // Invalid color\n  }\n  return color;\n}\n\n/**\n * TODO this function is only used in the test, we probably shouldn't export it\n * @param {Color} color Color.\n * @return {Color} Clamped color.\n */\nexport function normalize(color) {\n  color[0] = clamp((color[0] + 0.5) | 0, 0, 255);\n  color[1] = clamp((color[1] + 0.5) | 0, 0, 255);\n  color[2] = clamp((color[2] + 0.5) | 0, 0, 255);\n  color[3] = clamp(color[3], 0, 1);\n  return color;\n}\n\n/**\n * @param {Color} color Color.\n * @return {string} String.\n */\nexport function toString(color) {\n  let r = color[0];\n  if (r != (r | 0)) {\n    r = (r + 0.5) | 0;\n  }\n  let g = color[1];\n  if (g != (g | 0)) {\n    g = (g + 0.5) | 0;\n  }\n  let b = color[2];\n  if (b != (b | 0)) {\n    b = (b + 0.5) | 0;\n  }\n  const a = color[3] === undefined ? 1 : Math.round(color[3] * 100) / 100;\n  return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n}\n\n/**\n * @param {string} s String.\n * @return {boolean} Whether the string is actually a valid color\n */\nexport function isStringColor(s) {\n  if (NAMED_COLOR_RE_.test(s)) {\n    s = fromNamed(s);\n  }\n  return HEX_COLOR_RE_.test(s) || s.startsWith('rgba(') || s.startsWith('rgb(');\n}\n","/**\n * @module ol/colorlike\n */\nimport {toString} from './color.js';\n\n/**\n * A type accepted by CanvasRenderingContext2D.fillStyle\n * or CanvasRenderingContext2D.strokeStyle.\n * Represents a color, pattern, or gradient. The origin for patterns and\n * gradients as fill style is an increment of 512 css pixels from map coordinate\n * `[0, 0]`. For seamless repeat patterns, width and height of the pattern image\n * must be a factor of two (2, 4, 8, ..., 512).\n *\n * @typedef {string|CanvasPattern|CanvasGradient} ColorLike\n * @api\n */\n\n/**\n * @param {import(\"./color.js\").Color|ColorLike} color Color.\n * @return {ColorLike} The color as an {@link ol/colorlike~ColorLike}.\n * @api\n */\nexport function asColorLike(color) {\n  if (Array.isArray(color)) {\n    return toString(color);\n  }\n  return color;\n}\n","/**\n * @module ol/control/Control\n */\nimport BaseObject from '../Object.js';\nimport MapEventType from '../MapEventType.js';\nimport {VOID} from '../functions.js';\nimport {listen, unlistenByKey} from '../events.js';\nimport {removeNode} from '../dom.js';\n\n/**\n * @typedef {Object} Options\n * @property {HTMLElement} [element] The element is the control's\n * container element. This only needs to be specified if you're developing\n * a custom control.\n * @property {function(import(\"../MapEvent.js\").default):void} [render] Function called when\n * the control should be re-rendered. This is called in a `requestAnimationFrame`\n * callback.\n * @property {HTMLElement|string} [target] Specify a target if you want\n * the control to be rendered outside of the map's viewport.\n */\n\n/**\n * @classdesc\n * A control is a visible widget with a DOM element in a fixed position on the\n * screen. They can involve user input (buttons), or be informational only;\n * the position is determined using CSS. By default these are placed in the\n * container with CSS class name `ol-overlaycontainer-stopevent`, but can use\n * any outside DOM element.\n *\n * This is the base class for controls. You can use it for simple custom\n * controls by creating the element with listeners, creating an instance:\n * ```js\n * const myControl = new Control({element: myElement});\n * ```\n * and then adding this to the map.\n *\n * The main advantage of having this as a control rather than a simple separate\n * DOM element is that preventing propagation is handled for you. Controls\n * will also be objects in a {@link module:ol/Collection~Collection}, so you can use their methods.\n *\n * You can also extend this base for your own control class. See\n * examples/custom-controls for an example of how to do this.\n *\n * @api\n */\nclass Control extends BaseObject {\n  /**\n   * @param {Options} options Control options.\n   */\n  constructor(options) {\n    super();\n\n    const element = options.element;\n    if (element && !options.target && !element.style.pointerEvents) {\n      element.style.pointerEvents = 'auto';\n    }\n\n    /**\n     * @protected\n     * @type {HTMLElement}\n     */\n    this.element = element ? element : null;\n\n    /**\n     * @private\n     * @type {HTMLElement}\n     */\n    this.target_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../Map.js\").default|null}\n     */\n    this.map_ = null;\n\n    /**\n     * @protected\n     * @type {!Array<import(\"../events.js\").EventsKey>}\n     */\n    this.listenerKeys = [];\n\n    if (options.render) {\n      this.render = options.render;\n    }\n\n    if (options.target) {\n      this.setTarget(options.target);\n    }\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    removeNode(this.element);\n    super.disposeInternal();\n  }\n\n  /**\n   * Get the map associated with this control.\n   * @return {import(\"../Map.js\").default|null} Map.\n   * @api\n   */\n  getMap() {\n    return this.map_;\n  }\n\n  /**\n   * Remove the control from its current map and attach it to the new map.\n   * Pass `null` to just remove the control from the current map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../Map.js\").default|null} map Map.\n   * @api\n   */\n  setMap(map) {\n    if (this.map_) {\n      removeNode(this.element);\n    }\n    for (let i = 0, ii = this.listenerKeys.length; i < ii; ++i) {\n      unlistenByKey(this.listenerKeys[i]);\n    }\n    this.listenerKeys.length = 0;\n    this.map_ = map;\n    if (map) {\n      const target = this.target_\n        ? this.target_\n        : map.getOverlayContainerStopEvent();\n      target.appendChild(this.element);\n      if (this.render !== VOID) {\n        this.listenerKeys.push(\n          listen(map, MapEventType.POSTRENDER, this.render, this)\n        );\n      }\n      map.render();\n    }\n  }\n\n  /**\n   * Renders the control.\n   * @param {import(\"../MapEvent.js\").default} mapEvent Map event.\n   * @api\n   */\n  render(mapEvent) {}\n\n  /**\n   * This function is used to set a target element for the control. It has no\n   * effect if it is called after the control has been added to the map (i.e.\n   * after `setMap` is called on the control). If no `target` is set in the\n   * options passed to the control constructor and if `setTarget` is not called\n   * then the control is added to the map's overlay container.\n   * @param {HTMLElement|string} target Target.\n   * @api\n   */\n  setTarget(target) {\n    this.target_ =\n      typeof target === 'string' ? document.getElementById(target) : target;\n  }\n}\n\nexport default Control;\n","/**\n * @module ol/control/FullScreen\n */\nimport Control from './Control.js';\nimport EventType from '../events/EventType.js';\nimport MapProperty from '../MapProperty.js';\nimport {CLASS_CONTROL, CLASS_UNSELECTABLE, CLASS_UNSUPPORTED} from '../css.js';\nimport {listen, unlistenByKey} from '../events.js';\nimport {replaceNode} from '../dom.js';\n\nconst events = [\n  'fullscreenchange',\n  'webkitfullscreenchange',\n  'MSFullscreenChange',\n];\n\n/**\n * @enum {string}\n */\nconst FullScreenEventType = {\n  /**\n   * Triggered after the map entered fullscreen.\n   * @event FullScreenEventType#enterfullscreen\n   * @api\n   */\n  ENTERFULLSCREEN: 'enterfullscreen',\n\n  /**\n   * Triggered after the map leave fullscreen.\n   * @event FullScreenEventType#leavefullscreen\n   * @api\n   */\n  LEAVEFULLSCREEN: 'leavefullscreen',\n};\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes|\n *     'enterfullscreen'|'leavefullscreen', import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types, import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|\n *     'enterfullscreen'|'leavefullscreen'|import(\"../ObjectEventType\").Types, Return>} FullScreenOnSignature\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-full-screen'] CSS class name.\n * @property {string|Text|HTMLElement} [label='\\u2922'] Text label to use for the button.\n * Instead of text, also an element (e.g. a `span` element) can be used.\n * @property {string|Text|HTMLElement} [labelActive='\\u00d7'] Text label to use for the\n * button when full-screen is active.\n * Instead of text, also an element (e.g. a `span` element) can be used.\n * @property {string} [activeClassName=className + '-true'] CSS class name for the button\n * when full-screen is active.\n * @property {string} [inactiveClassName=className + '-false'] CSS class name for the button\n * when full-screen is inactive.\n * @property {string} [tipLabel='Toggle full-screen'] Text label to use for the button tip.\n * @property {boolean} [keys=false] Full keyboard access.\n * @property {HTMLElement|string} [target] Specify a target if you want the\n * control to be rendered outside of the map's viewport.\n * @property {HTMLElement|string} [source] The element to be displayed\n * fullscreen. When not provided, the element containing the map viewport will\n * be displayed fullscreen.\n */\n\n/**\n * @classdesc\n * Provides a button that when clicked fills up the full screen with the map.\n * The full screen source element is by default the element containing the map viewport unless\n * overridden by providing the `source` option. In which case, the dom\n * element introduced using this parameter will be displayed in full screen.\n *\n * When in full screen mode, a close button is shown to exit full screen mode.\n * The [Fullscreen API](https://www.w3.org/TR/fullscreen/) is used to\n * toggle the map in full screen mode.\n *\n * @fires FullScreenEventType#enterfullscreen\n * @fires FullScreenEventType#leavefullscreen\n * @api\n */\nclass FullScreen extends Control {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    super({\n      element: document.createElement('div'),\n      target: options.target,\n    });\n\n    /***\n     * @type {FullScreenOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {FullScreenOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {FullScreenOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.keys_ = options.keys !== undefined ? options.keys : false;\n\n    /**\n     * @private\n     * @type {HTMLElement|string|undefined}\n     */\n    this.source_ = options.source;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.isInFullscreen_ = false;\n\n    /**\n     * @private\n     */\n    this.boundHandleMapTargetChange_ = this.handleMapTargetChange_.bind(this);\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.cssClassName_ =\n      options.className !== undefined ? options.className : 'ol-full-screen';\n\n    /**\n     * @private\n     * @type {Array<import(\"../events.js\").EventsKey>}\n     */\n    this.documentListeners_ = [];\n\n    /**\n     * @private\n     * @type {Array<string>}\n     */\n    this.activeClassName_ =\n      options.activeClassName !== undefined\n        ? options.activeClassName.split(' ')\n        : [this.cssClassName_ + '-true'];\n\n    /**\n     * @private\n     * @type {Array<string>}\n     */\n    this.inactiveClassName_ =\n      options.inactiveClassName !== undefined\n        ? options.inactiveClassName.split(' ')\n        : [this.cssClassName_ + '-false'];\n\n    const label = options.label !== undefined ? options.label : '\\u2922';\n\n    /**\n     * @private\n     * @type {Text|HTMLElement}\n     */\n    this.labelNode_ =\n      typeof label === 'string' ? document.createTextNode(label) : label;\n\n    const labelActive =\n      options.labelActive !== undefined ? options.labelActive : '\\u00d7';\n\n    /**\n     * @private\n     * @type {Text|HTMLElement}\n     */\n    this.labelActiveNode_ =\n      typeof labelActive === 'string'\n        ? document.createTextNode(labelActive)\n        : labelActive;\n\n    const tipLabel = options.tipLabel ? options.tipLabel : 'Toggle full-screen';\n\n    /**\n     * @private\n     * @type {HTMLElement}\n     */\n    this.button_ = document.createElement('button');\n    this.button_.title = tipLabel;\n    this.button_.setAttribute('type', 'button');\n    this.button_.appendChild(this.labelNode_);\n    this.button_.addEventListener(\n      EventType.CLICK,\n      this.handleClick_.bind(this),\n      false\n    );\n    this.setClassName_(this.button_, this.isInFullscreen_);\n\n    this.element.className = `${this.cssClassName_} ${CLASS_UNSELECTABLE} ${CLASS_CONTROL}`;\n    this.element.appendChild(this.button_);\n  }\n\n  /**\n   * @param {MouseEvent} event The event to handle\n   * @private\n   */\n  handleClick_(event) {\n    event.preventDefault();\n    this.handleFullScreen_();\n  }\n\n  /**\n   * @private\n   */\n  handleFullScreen_() {\n    const map = this.getMap();\n    if (!map) {\n      return;\n    }\n    const doc = map.getOwnerDocument();\n    if (!isFullScreenSupported(doc)) {\n      return;\n    }\n    if (isFullScreen(doc)) {\n      exitFullScreen(doc);\n    } else {\n      let element;\n      if (this.source_) {\n        element =\n          typeof this.source_ === 'string'\n            ? doc.getElementById(this.source_)\n            : this.source_;\n      } else {\n        element = map.getTargetElement();\n      }\n      if (this.keys_) {\n        requestFullScreenWithKeys(element);\n      } else {\n        requestFullScreen(element);\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  handleFullScreenChange_() {\n    const map = this.getMap();\n    if (!map) {\n      return;\n    }\n    const wasInFullscreen = this.isInFullscreen_;\n    this.isInFullscreen_ = isFullScreen(map.getOwnerDocument());\n    if (wasInFullscreen !== this.isInFullscreen_) {\n      this.setClassName_(this.button_, this.isInFullscreen_);\n      if (this.isInFullscreen_) {\n        replaceNode(this.labelActiveNode_, this.labelNode_);\n        this.dispatchEvent(FullScreenEventType.ENTERFULLSCREEN);\n      } else {\n        replaceNode(this.labelNode_, this.labelActiveNode_);\n        this.dispatchEvent(FullScreenEventType.LEAVEFULLSCREEN);\n      }\n      map.updateSize();\n    }\n  }\n\n  /**\n   * @param {HTMLElement} element Target element\n   * @param {boolean} fullscreen True if fullscreen class name should be active\n   * @private\n   */\n  setClassName_(element, fullscreen) {\n    if (fullscreen) {\n      element.classList.remove(...this.inactiveClassName_);\n      element.classList.add(...this.activeClassName_);\n    } else {\n      element.classList.remove(...this.activeClassName_);\n      element.classList.add(...this.inactiveClassName_);\n    }\n  }\n\n  /**\n   * Remove the control from its current map and attach it to the new map.\n   * Pass `null` to just remove the control from the current map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../Map.js\").default|null} map Map.\n   * @api\n   */\n  setMap(map) {\n    const oldMap = this.getMap();\n    if (oldMap) {\n      oldMap.removeChangeListener(\n        MapProperty.TARGET,\n        this.boundHandleMapTargetChange_\n      );\n    }\n\n    super.setMap(map);\n\n    this.handleMapTargetChange_();\n    if (map) {\n      map.addChangeListener(\n        MapProperty.TARGET,\n        this.boundHandleMapTargetChange_\n      );\n    }\n  }\n\n  /**\n   * @private\n   */\n  handleMapTargetChange_() {\n    const listeners = this.documentListeners_;\n    for (let i = 0, ii = listeners.length; i < ii; ++i) {\n      unlistenByKey(listeners[i]);\n    }\n    listeners.length = 0;\n\n    const map = this.getMap();\n    if (map) {\n      const doc = map.getOwnerDocument();\n      if (isFullScreenSupported(doc)) {\n        this.element.classList.remove(CLASS_UNSUPPORTED);\n      } else {\n        this.element.classList.add(CLASS_UNSUPPORTED);\n      }\n\n      for (let i = 0, ii = events.length; i < ii; ++i) {\n        listeners.push(\n          listen(doc, events[i], this.handleFullScreenChange_, this)\n        );\n      }\n      this.handleFullScreenChange_();\n    }\n  }\n}\n\n/**\n * @param {Document} doc The root document to check.\n * @return {boolean} Fullscreen is supported by the current platform.\n */\nfunction isFullScreenSupported(doc) {\n  const body = doc.body;\n  return !!(\n    body['webkitRequestFullscreen'] ||\n    (body.requestFullscreen && doc.fullscreenEnabled)\n  );\n}\n\n/**\n * @param {Document} doc The root document to check.\n * @return {boolean} Element is currently in fullscreen.\n */\nfunction isFullScreen(doc) {\n  return !!(doc['webkitIsFullScreen'] || doc.fullscreenElement);\n}\n\n/**\n * Request to fullscreen an element.\n * @param {HTMLElement} element Element to request fullscreen\n */\nfunction requestFullScreen(element) {\n  if (element.requestFullscreen) {\n    element.requestFullscreen();\n  } else if (element['webkitRequestFullscreen']) {\n    element['webkitRequestFullscreen']();\n  }\n}\n\n/**\n * Request to fullscreen an element with keyboard input.\n * @param {HTMLElement} element Element to request fullscreen\n */\nfunction requestFullScreenWithKeys(element) {\n  if (element['webkitRequestFullscreen']) {\n    element['webkitRequestFullscreen']();\n  } else {\n    requestFullScreen(element);\n  }\n}\n\n/**\n * Exit fullscreen.\n * @param {Document} doc The document to exit fullscren from\n */\nfunction exitFullScreen(doc) {\n  if (doc.exitFullscreen) {\n    doc.exitFullscreen();\n  } else if (doc['webkitExitFullscreen']) {\n    doc['webkitExitFullscreen']();\n  }\n}\n\nexport default FullScreen;\n","/**\n * @module ol/control/ScaleLine\n */\nimport Control from './Control.js';\nimport {CLASS_UNSELECTABLE} from '../css.js';\nimport {METERS_PER_UNIT, getPointResolution} from '../proj.js';\nimport {assert} from '../asserts.js';\n\n/**\n * @type {string}\n */\nconst UNITS_PROP = 'units';\n\n/**\n * @typedef {'degrees' | 'imperial' | 'nautical' | 'metric' | 'us'} Units\n * Units for the scale line.\n */\n\n/**\n * @const\n * @type {Array<number>}\n */\nconst LEADING_DIGITS = [1, 2, 5];\n\n/**\n * @const\n * @type {number}\n */\nconst DEFAULT_DPI = 25.4 / 0.28;\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:units', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types\n *     |'change:units', Return>} ScaleLineOnSignature\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} [className] CSS class name. The default is `ol-scale-bar` when configured with\n * `bar: true`. Otherwise the default is `ol-scale-line`.\n * @property {number} [minWidth=64] Minimum width in pixels at the OGC default dpi. The width will be\n * adjusted to match the dpi used.\n * @property {number} [maxWidth] Maximum width in pixels at the OGC default dpi. The width will be\n * adjusted to match the dpi used.\n * @property {function(import(\"../MapEvent.js\").default):void} [render] Function called when the control\n * should be re-rendered. This is called in a `requestAnimationFrame` callback.\n * @property {HTMLElement|string} [target] Specify a target if you want the control\n * to be rendered outside of the map's viewport.\n * @property {Units} [units='metric'] Units.\n * @property {boolean} [bar=false] Render scalebars instead of a line.\n * @property {number} [steps=4] Number of steps the scalebar should use. Use even numbers\n * for best results. Only applies when `bar` is `true`.\n * @property {boolean} [text=false] Render the text scale above of the scalebar. Only applies\n * when `bar` is `true`.\n * @property {number|undefined} [dpi=undefined] dpi of output device such as printer. Only applies\n * when `bar` is `true`. If undefined the OGC default screen pixel size of 0.28mm will be assumed.\n */\n\n/**\n * @classdesc\n * A control displaying rough y-axis distances, calculated for the center of the\n * viewport. For conformal projections (e.g. EPSG:3857, the default view\n * projection in OpenLayers), the scale is valid for all directions.\n * No scale line will be shown when the y-axis distance of a pixel at the\n * viewport center cannot be calculated in the view projection.\n * By default the scale line will show in the bottom left portion of the map,\n * but this can be changed by using the css selector `.ol-scale-line`.\n * When specifying `bar` as `true`, a scalebar will be rendered instead\n * of a scaleline.\n *\n * @api\n */\nclass ScaleLine extends Control {\n  /**\n   * @param {Options} [options] Scale line options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const element = document.createElement('div');\n    element.style.pointerEvents = 'none';\n\n    super({\n      element: element,\n      render: options.render,\n      target: options.target,\n    });\n\n    /***\n     * @type {ScaleLineOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {ScaleLineOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {ScaleLineOnSignature<void>}\n     */\n    this.un;\n\n    const className =\n      options.className !== undefined\n        ? options.className\n        : options.bar\n        ? 'ol-scale-bar'\n        : 'ol-scale-line';\n\n    /**\n     * @private\n     * @type {HTMLElement}\n     */\n    this.innerElement_ = document.createElement('div');\n    this.innerElement_.className = className + '-inner';\n\n    this.element.className = className + ' ' + CLASS_UNSELECTABLE;\n    this.element.appendChild(this.innerElement_);\n\n    /**\n     * @private\n     * @type {?import(\"../View.js\").State}\n     */\n    this.viewState_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.minWidth_ = options.minWidth !== undefined ? options.minWidth : 64;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.maxWidth_ = options.maxWidth;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.renderedVisible_ = false;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.renderedWidth_ = undefined;\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.renderedHTML_ = '';\n\n    this.addChangeListener(UNITS_PROP, this.handleUnitsChanged_);\n\n    this.setUnits(options.units || 'metric');\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.scaleBar_ = options.bar || false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.scaleBarSteps_ = options.steps || 4;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.scaleBarText_ = options.text || false;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.dpi_ = options.dpi || undefined;\n  }\n\n  /**\n   * Return the units to use in the scale line.\n   * @return {Units} The units\n   * to use in the scale line.\n   * @observable\n   * @api\n   */\n  getUnits() {\n    return this.get(UNITS_PROP);\n  }\n\n  /**\n   * @private\n   */\n  handleUnitsChanged_() {\n    this.updateElement_();\n  }\n\n  /**\n   * Set the units to use in the scale line.\n   * @param {Units} units The units to use in the scale line.\n   * @observable\n   * @api\n   */\n  setUnits(units) {\n    this.set(UNITS_PROP, units);\n  }\n\n  /**\n   * Specify the dpi of output device such as printer.\n   * @param {number|undefined} dpi The dpi of output device.\n   * @api\n   */\n  setDpi(dpi) {\n    this.dpi_ = dpi;\n  }\n\n  /**\n   * @private\n   */\n  updateElement_() {\n    const viewState = this.viewState_;\n\n    if (!viewState) {\n      if (this.renderedVisible_) {\n        this.element.style.display = 'none';\n        this.renderedVisible_ = false;\n      }\n      return;\n    }\n\n    const center = viewState.center;\n    const projection = viewState.projection;\n    const units = this.getUnits();\n    const pointResolutionUnits = units == 'degrees' ? 'degrees' : 'm';\n    let pointResolution = getPointResolution(\n      projection,\n      viewState.resolution,\n      center,\n      pointResolutionUnits\n    );\n\n    const minWidth =\n      (this.minWidth_ * (this.dpi_ || DEFAULT_DPI)) / DEFAULT_DPI;\n\n    const maxWidth =\n      this.maxWidth_ !== undefined\n        ? (this.maxWidth_ * (this.dpi_ || DEFAULT_DPI)) / DEFAULT_DPI\n        : undefined;\n\n    let nominalCount = minWidth * pointResolution;\n    let suffix = '';\n    if (units == 'degrees') {\n      const metersPerDegree = METERS_PER_UNIT.degrees;\n      nominalCount *= metersPerDegree;\n      if (nominalCount < metersPerDegree / 60) {\n        suffix = '\\u2033'; // seconds\n        pointResolution *= 3600;\n      } else if (nominalCount < metersPerDegree) {\n        suffix = '\\u2032'; // minutes\n        pointResolution *= 60;\n      } else {\n        suffix = '\\u00b0'; // degrees\n      }\n    } else if (units == 'imperial') {\n      if (nominalCount < 0.9144) {\n        suffix = 'in';\n        pointResolution /= 0.0254;\n      } else if (nominalCount < 1609.344) {\n        suffix = 'ft';\n        pointResolution /= 0.3048;\n      } else {\n        suffix = 'mi';\n        pointResolution /= 1609.344;\n      }\n    } else if (units == 'nautical') {\n      pointResolution /= 1852;\n      suffix = 'NM';\n    } else if (units == 'metric') {\n      if (nominalCount < 0.001) {\n        suffix = 'm';\n        pointResolution *= 1000000;\n      } else if (nominalCount < 1) {\n        suffix = 'mm';\n        pointResolution *= 1000;\n      } else if (nominalCount < 1000) {\n        suffix = 'm';\n      } else {\n        suffix = 'km';\n        pointResolution /= 1000;\n      }\n    } else if (units == 'us') {\n      if (nominalCount < 0.9144) {\n        suffix = 'in';\n        pointResolution *= 39.37;\n      } else if (nominalCount < 1609.344) {\n        suffix = 'ft';\n        pointResolution /= 0.30480061;\n      } else {\n        suffix = 'mi';\n        pointResolution /= 1609.3472;\n      }\n    } else {\n      assert(false, 33); // Invalid units\n    }\n\n    let i = 3 * Math.floor(Math.log(minWidth * pointResolution) / Math.log(10));\n    let count, width, decimalCount;\n    let previousCount, previousWidth, previousDecimalCount;\n    while (true) {\n      decimalCount = Math.floor(i / 3);\n      const decimal = Math.pow(10, decimalCount);\n      count = LEADING_DIGITS[((i % 3) + 3) % 3] * decimal;\n      width = Math.round(count / pointResolution);\n      if (isNaN(width)) {\n        this.element.style.display = 'none';\n        this.renderedVisible_ = false;\n        return;\n      }\n      if (maxWidth !== undefined && width >= maxWidth) {\n        count = previousCount;\n        width = previousWidth;\n        decimalCount = previousDecimalCount;\n        break;\n      } else if (width >= minWidth) {\n        break;\n      }\n      previousCount = count;\n      previousWidth = width;\n      previousDecimalCount = decimalCount;\n      ++i;\n    }\n    const html = this.scaleBar_\n      ? this.createScaleBar(width, count, suffix)\n      : count.toFixed(decimalCount < 0 ? -decimalCount : 0) + ' ' + suffix;\n\n    if (this.renderedHTML_ != html) {\n      this.innerElement_.innerHTML = html;\n      this.renderedHTML_ = html;\n    }\n\n    if (this.renderedWidth_ != width) {\n      this.innerElement_.style.width = width + 'px';\n      this.renderedWidth_ = width;\n    }\n\n    if (!this.renderedVisible_) {\n      this.element.style.display = '';\n      this.renderedVisible_ = true;\n    }\n  }\n\n  /**\n   * @private\n   * @param {number} width The current width of the scalebar.\n   * @param {number} scale The current scale.\n   * @param {string} suffix The suffix to append to the scale text.\n   * @return {string} The stringified HTML of the scalebar.\n   */\n  createScaleBar(width, scale, suffix) {\n    const resolutionScale = this.getScaleForResolution();\n    const mapScale =\n      resolutionScale < 1\n        ? Math.round(1 / resolutionScale).toLocaleString() + ' : 1'\n        : '1 : ' + Math.round(resolutionScale).toLocaleString();\n    const steps = this.scaleBarSteps_;\n    const stepWidth = width / steps;\n    const scaleSteps = [this.createMarker('absolute')];\n    for (let i = 0; i < steps; ++i) {\n      const cls =\n        i % 2 === 0 ? 'ol-scale-singlebar-odd' : 'ol-scale-singlebar-even';\n      scaleSteps.push(\n        '<div>' +\n          '<div ' +\n          `class=\"ol-scale-singlebar ${cls}\" ` +\n          `style=\"width: ${stepWidth}px;\"` +\n          '>' +\n          '</div>' +\n          this.createMarker('relative') +\n          // render text every second step, except when only 2 steps\n          (i % 2 === 0 || steps === 2\n            ? this.createStepText(i, width, false, scale, suffix)\n            : '') +\n          '</div>'\n      );\n    }\n    // render text at the end\n    scaleSteps.push(this.createStepText(steps, width, true, scale, suffix));\n\n    const scaleBarText = this.scaleBarText_\n      ? `<div class=\"ol-scale-text\" style=\"width: ${width}px;\">` +\n        mapScale +\n        '</div>'\n      : '';\n    return scaleBarText + scaleSteps.join('');\n  }\n\n  /**\n   * Creates a marker at given position\n   * @param {'absolute'|'relative'} position The position, absolute or relative\n   * @return {string} The stringified div containing the marker\n   */\n  createMarker(position) {\n    const top = position === 'absolute' ? 3 : -10;\n    return (\n      '<div ' +\n      'class=\"ol-scale-step-marker\" ' +\n      `style=\"position: ${position}; top: ${top}px;\"` +\n      '></div>'\n    );\n  }\n\n  /**\n   * Creates the label for a marker marker at given position\n   * @param {number} i The iterator\n   * @param {number} width The width the scalebar will currently use\n   * @param {boolean} isLast Flag indicating if we add the last step text\n   * @param {number} scale The current scale for the whole scalebar\n   * @param {string} suffix The suffix for the scale\n   * @return {string} The stringified div containing the step text\n   */\n  createStepText(i, width, isLast, scale, suffix) {\n    const length =\n      i === 0 ? 0 : Math.round((scale / this.scaleBarSteps_) * i * 100) / 100;\n    const lengthString = length + (i === 0 ? '' : ' ' + suffix);\n    const margin = i === 0 ? -3 : (width / this.scaleBarSteps_) * -1;\n    const minWidth = i === 0 ? 0 : (width / this.scaleBarSteps_) * 2;\n    return (\n      '<div ' +\n      'class=\"ol-scale-step-text\" ' +\n      'style=\"' +\n      `margin-left: ${margin}px;` +\n      `text-align: ${i === 0 ? 'left' : 'center'};` +\n      `min-width: ${minWidth}px;` +\n      `left: ${isLast ? width + 'px' : 'unset'};` +\n      '\">' +\n      lengthString +\n      '</div>'\n    );\n  }\n\n  /**\n   * Returns the appropriate scale for the given resolution and units.\n   * @return {number} The appropriate scale.\n   */\n  getScaleForResolution() {\n    const resolution = getPointResolution(\n      this.viewState_.projection,\n      this.viewState_.resolution,\n      this.viewState_.center,\n      'm'\n    );\n    const dpi = this.dpi_ || DEFAULT_DPI;\n    const inchesPerMeter = 1000 / 25.4;\n    return resolution * inchesPerMeter * dpi;\n  }\n\n  /**\n   * Update the scale line element.\n   * @param {import(\"../MapEvent.js\").default} mapEvent Map event.\n   * @override\n   */\n  render(mapEvent) {\n    const frameState = mapEvent.frameState;\n    if (!frameState) {\n      this.viewState_ = null;\n    } else {\n      this.viewState_ = frameState.viewState;\n    }\n    this.updateElement_();\n  }\n}\n\nexport default ScaleLine;\n","/**\n * @module ol/control/Attribution\n */\nimport Control from './Control.js';\nimport EventType from '../events/EventType.js';\nimport {CLASS_COLLAPSED, CLASS_CONTROL, CLASS_UNSELECTABLE} from '../css.js';\nimport {equals} from '../array.js';\nimport {inView} from '../layer/Layer.js';\nimport {removeChildren, replaceNode} from '../dom.js';\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-attribution'] CSS class name.\n * @property {HTMLElement|string} [target] Specify a target if you\n * want the control to be rendered outside of the map's\n * viewport.\n * @property {boolean} [collapsible] Specify if attributions can\n * be collapsed. If not specified, sources control this behavior with their\n * `attributionsCollapsible` setting.\n * @property {boolean} [collapsed=true] Specify if attributions should\n * be collapsed at startup.\n * @property {string} [tipLabel='Attributions'] Text label to use for the button tip.\n * @property {string|HTMLElement} [label='i'] Text label to use for the\n * collapsed attributions button.\n * Instead of text, also an element (e.g. a `span` element) can be used.\n * @property {string} [expandClassName=className + '-expand'] CSS class name for the\n * collapsed attributions button.\n * @property {string|HTMLElement} [collapseLabel=''] Text label to use\n * for the expanded attributions button.\n * Instead of text, also an element (e.g. a `span` element) can be used.\n * @property {string} [collapseClassName=className + '-collapse'] CSS class name for the\n * expanded attributions button.\n * @property {function(import(\"../MapEvent.js\").default):void} [render] Function called when\n * the control should be re-rendered. This is called in a `requestAnimationFrame`\n * callback.\n */\n\n/**\n * @classdesc\n * Control to show all the attributions associated with the layer sources\n * in the map. This control is one of the default controls included in maps.\n * By default it will show in the bottom right portion of the map, but this can\n * be changed by using a css selector for `.ol-attribution`.\n *\n * @api\n */\nclass Attribution extends Control {\n  /**\n   * @param {Options} [options] Attribution options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    super({\n      element: document.createElement('div'),\n      render: options.render,\n      target: options.target,\n    });\n\n    /**\n     * @private\n     * @type {HTMLElement}\n     */\n    this.ulElement_ = document.createElement('ul');\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.collapsed_ =\n      options.collapsed !== undefined ? options.collapsed : true;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.userCollapsed_ = this.collapsed_;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.overrideCollapsible_ = options.collapsible !== undefined;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.collapsible_ =\n      options.collapsible !== undefined ? options.collapsible : true;\n\n    if (!this.collapsible_) {\n      this.collapsed_ = false;\n    }\n\n    const className =\n      options.className !== undefined ? options.className : 'ol-attribution';\n\n    const tipLabel =\n      options.tipLabel !== undefined ? options.tipLabel : 'Attributions';\n\n    const expandClassName =\n      options.expandClassName !== undefined\n        ? options.expandClassName\n        : className + '-expand';\n\n    const collapseLabel =\n      options.collapseLabel !== undefined ? options.collapseLabel : '\\u203A';\n\n    const collapseClassName =\n      options.collapseClassName !== undefined\n        ? options.collapseClassName\n        : className + '-collapse';\n\n    if (typeof collapseLabel === 'string') {\n      /**\n       * @private\n       * @type {HTMLElement}\n       */\n      this.collapseLabel_ = document.createElement('span');\n      this.collapseLabel_.textContent = collapseLabel;\n      this.collapseLabel_.className = collapseClassName;\n    } else {\n      this.collapseLabel_ = collapseLabel;\n    }\n\n    const label = options.label !== undefined ? options.label : 'i';\n\n    if (typeof label === 'string') {\n      /**\n       * @private\n       * @type {HTMLElement}\n       */\n      this.label_ = document.createElement('span');\n      this.label_.textContent = label;\n      this.label_.className = expandClassName;\n    } else {\n      this.label_ = label;\n    }\n\n    const activeLabel =\n      this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_;\n\n    /**\n     * @private\n     * @type {HTMLElement}\n     */\n    this.toggleButton_ = document.createElement('button');\n    this.toggleButton_.setAttribute('type', 'button');\n    this.toggleButton_.setAttribute('aria-expanded', String(!this.collapsed_));\n    this.toggleButton_.title = tipLabel;\n    this.toggleButton_.appendChild(activeLabel);\n\n    this.toggleButton_.addEventListener(\n      EventType.CLICK,\n      this.handleClick_.bind(this),\n      false\n    );\n\n    const cssClasses =\n      className +\n      ' ' +\n      CLASS_UNSELECTABLE +\n      ' ' +\n      CLASS_CONTROL +\n      (this.collapsed_ && this.collapsible_ ? ' ' + CLASS_COLLAPSED : '') +\n      (this.collapsible_ ? '' : ' ol-uncollapsible');\n    const element = this.element;\n    element.className = cssClasses;\n    element.appendChild(this.toggleButton_);\n    element.appendChild(this.ulElement_);\n\n    /**\n     * A list of currently rendered resolutions.\n     * @type {Array<string>}\n     * @private\n     */\n    this.renderedAttributions_ = [];\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.renderedVisible_ = true;\n  }\n\n  /**\n   * Collect a list of visible attributions and set the collapsible state.\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @return {Array<string>} Attributions.\n   * @private\n   */\n  collectSourceAttributions_(frameState) {\n    /**\n     * Used to determine if an attribution already exists.\n     * @type {!Object<string, boolean>}\n     */\n    const lookup = {};\n\n    /**\n     * A list of visible attributions.\n     * @type {Array<string>}\n     */\n    const visibleAttributions = [];\n\n    let collapsible = true;\n    const layerStatesArray = frameState.layerStatesArray;\n    for (let i = 0, ii = layerStatesArray.length; i < ii; ++i) {\n      const layerState = layerStatesArray[i];\n      if (!inView(layerState, frameState.viewState)) {\n        continue;\n      }\n\n      const source = /** @type {import(\"../layer/Layer.js\").default} */ (\n        layerState.layer\n      ).getSource();\n      if (!source) {\n        continue;\n      }\n\n      const attributionGetter = source.getAttributions();\n      if (!attributionGetter) {\n        continue;\n      }\n\n      const attributions = attributionGetter(frameState);\n      if (!attributions) {\n        continue;\n      }\n\n      collapsible =\n        collapsible && source.getAttributionsCollapsible() !== false;\n\n      if (Array.isArray(attributions)) {\n        for (let j = 0, jj = attributions.length; j < jj; ++j) {\n          if (!(attributions[j] in lookup)) {\n            visibleAttributions.push(attributions[j]);\n            lookup[attributions[j]] = true;\n          }\n        }\n      } else {\n        if (!(attributions in lookup)) {\n          visibleAttributions.push(attributions);\n          lookup[attributions] = true;\n        }\n      }\n    }\n    if (!this.overrideCollapsible_) {\n      this.setCollapsible(collapsible);\n    }\n    return visibleAttributions;\n  }\n\n  /**\n   * @private\n   * @param {?import(\"../Map.js\").FrameState} frameState Frame state.\n   */\n  updateElement_(frameState) {\n    if (!frameState) {\n      if (this.renderedVisible_) {\n        this.element.style.display = 'none';\n        this.renderedVisible_ = false;\n      }\n      return;\n    }\n\n    const attributions = this.collectSourceAttributions_(frameState);\n\n    const visible = attributions.length > 0;\n    if (this.renderedVisible_ != visible) {\n      this.element.style.display = visible ? '' : 'none';\n      this.renderedVisible_ = visible;\n    }\n\n    if (equals(attributions, this.renderedAttributions_)) {\n      return;\n    }\n\n    removeChildren(this.ulElement_);\n\n    // append the attributions\n    for (let i = 0, ii = attributions.length; i < ii; ++i) {\n      const element = document.createElement('li');\n      element.innerHTML = attributions[i];\n      this.ulElement_.appendChild(element);\n    }\n\n    this.renderedAttributions_ = attributions;\n  }\n\n  /**\n   * @param {MouseEvent} event The event to handle\n   * @private\n   */\n  handleClick_(event) {\n    event.preventDefault();\n    this.handleToggle_();\n    this.userCollapsed_ = this.collapsed_;\n  }\n\n  /**\n   * @private\n   */\n  handleToggle_() {\n    this.element.classList.toggle(CLASS_COLLAPSED);\n    if (this.collapsed_) {\n      replaceNode(this.collapseLabel_, this.label_);\n    } else {\n      replaceNode(this.label_, this.collapseLabel_);\n    }\n    this.collapsed_ = !this.collapsed_;\n    this.toggleButton_.setAttribute('aria-expanded', String(!this.collapsed_));\n  }\n\n  /**\n   * Return `true` if the attribution is collapsible, `false` otherwise.\n   * @return {boolean} True if the widget is collapsible.\n   * @api\n   */\n  getCollapsible() {\n    return this.collapsible_;\n  }\n\n  /**\n   * Set whether the attribution should be collapsible.\n   * @param {boolean} collapsible True if the widget is collapsible.\n   * @api\n   */\n  setCollapsible(collapsible) {\n    if (this.collapsible_ === collapsible) {\n      return;\n    }\n    this.collapsible_ = collapsible;\n    this.element.classList.toggle('ol-uncollapsible');\n    if (this.userCollapsed_) {\n      this.handleToggle_();\n    }\n  }\n\n  /**\n   * Collapse or expand the attribution according to the passed parameter. Will\n   * not do anything if the attribution isn't collapsible or if the current\n   * collapsed state is already the one requested.\n   * @param {boolean} collapsed True if the widget is collapsed.\n   * @api\n   */\n  setCollapsed(collapsed) {\n    this.userCollapsed_ = collapsed;\n    if (!this.collapsible_ || this.collapsed_ === collapsed) {\n      return;\n    }\n    this.handleToggle_();\n  }\n\n  /**\n   * Return `true` when the attribution is currently collapsed or `false`\n   * otherwise.\n   * @return {boolean} True if the widget is collapsed.\n   * @api\n   */\n  getCollapsed() {\n    return this.collapsed_;\n  }\n\n  /**\n   * Update the attribution element.\n   * @param {import(\"../MapEvent.js\").default} mapEvent Map event.\n   * @override\n   */\n  render(mapEvent) {\n    this.updateElement_(mapEvent.frameState);\n  }\n}\n\nexport default Attribution;\n","/**\n * @module ol/control/Rotate\n */\nimport Control from './Control.js';\nimport EventType from '../events/EventType.js';\nimport {CLASS_CONTROL, CLASS_HIDDEN, CLASS_UNSELECTABLE} from '../css.js';\nimport {easeOut} from '../easing.js';\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-rotate'] CSS class name.\n * @property {string|HTMLElement} [label=''] Text label to use for the rotate button.\n * Instead of text, also an element (e.g. a `span` element) can be used.\n * @property {string} [tipLabel='Reset rotation'] Text label to use for the rotate tip.\n * @property {string} [compassClassName='ol-compass'] CSS class name for the compass.\n * @property {number} [duration=250] Animation duration in milliseconds.\n * @property {boolean} [autoHide=true] Hide the control when rotation is 0.\n * @property {function(import(\"../MapEvent.js\").default):void} [render] Function called when the control should\n * be re-rendered. This is called in a `requestAnimationFrame` callback.\n * @property {function():void} [resetNorth] Function called when the control is clicked.\n * This will override the default `resetNorth`.\n * @property {HTMLElement|string} [target] Specify a target if you want the control to be\n * rendered outside of the map's viewport.\n */\n\n/**\n * @classdesc\n * A button control to reset rotation to 0.\n * To style this control use css selector `.ol-rotate`. A `.ol-hidden` css\n * selector is added to the button when the rotation is 0.\n *\n * @api\n */\nclass Rotate extends Control {\n  /**\n   * @param {Options} [options] Rotate options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    super({\n      element: document.createElement('div'),\n      render: options.render,\n      target: options.target,\n    });\n\n    const className =\n      options.className !== undefined ? options.className : 'ol-rotate';\n\n    const label = options.label !== undefined ? options.label : '\\u21E7';\n\n    const compassClassName =\n      options.compassClassName !== undefined\n        ? options.compassClassName\n        : 'ol-compass';\n\n    /**\n     * @type {HTMLElement}\n     * @private\n     */\n    this.label_ = null;\n\n    if (typeof label === 'string') {\n      this.label_ = document.createElement('span');\n      this.label_.className = compassClassName;\n      this.label_.textContent = label;\n    } else {\n      this.label_ = label;\n      this.label_.classList.add(compassClassName);\n    }\n\n    const tipLabel = options.tipLabel ? options.tipLabel : 'Reset rotation';\n\n    const button = document.createElement('button');\n    button.className = className + '-reset';\n    button.setAttribute('type', 'button');\n    button.title = tipLabel;\n    button.appendChild(this.label_);\n\n    button.addEventListener(\n      EventType.CLICK,\n      this.handleClick_.bind(this),\n      false\n    );\n\n    const cssClasses =\n      className + ' ' + CLASS_UNSELECTABLE + ' ' + CLASS_CONTROL;\n    const element = this.element;\n    element.className = cssClasses;\n    element.appendChild(button);\n\n    this.callResetNorth_ = options.resetNorth ? options.resetNorth : undefined;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 250;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.autoHide_ = options.autoHide !== undefined ? options.autoHide : true;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.rotation_ = undefined;\n\n    if (this.autoHide_) {\n      this.element.classList.add(CLASS_HIDDEN);\n    }\n  }\n\n  /**\n   * @param {MouseEvent} event The event to handle\n   * @private\n   */\n  handleClick_(event) {\n    event.preventDefault();\n    if (this.callResetNorth_ !== undefined) {\n      this.callResetNorth_();\n    } else {\n      this.resetNorth_();\n    }\n  }\n\n  /**\n   * @private\n   */\n  resetNorth_() {\n    const map = this.getMap();\n    const view = map.getView();\n    if (!view) {\n      // the map does not have a view, so we can't act\n      // upon it\n      return;\n    }\n    const rotation = view.getRotation();\n    if (rotation !== undefined) {\n      if (this.duration_ > 0 && rotation % (2 * Math.PI) !== 0) {\n        view.animate({\n          rotation: 0,\n          duration: this.duration_,\n          easing: easeOut,\n        });\n      } else {\n        view.setRotation(0);\n      }\n    }\n  }\n\n  /**\n   * Update the rotate control element.\n   * @param {import(\"../MapEvent.js\").default} mapEvent Map event.\n   * @override\n   */\n  render(mapEvent) {\n    const frameState = mapEvent.frameState;\n    if (!frameState) {\n      return;\n    }\n    const rotation = frameState.viewState.rotation;\n    if (rotation != this.rotation_) {\n      const transform = 'rotate(' + rotation + 'rad)';\n      if (this.autoHide_) {\n        const contains = this.element.classList.contains(CLASS_HIDDEN);\n        if (!contains && rotation === 0) {\n          this.element.classList.add(CLASS_HIDDEN);\n        } else if (contains && rotation !== 0) {\n          this.element.classList.remove(CLASS_HIDDEN);\n        }\n      }\n      this.label_.style.transform = transform;\n    }\n    this.rotation_ = rotation;\n  }\n}\n\nexport default Rotate;\n","/**\n * @module ol/control/Zoom\n */\nimport Control from './Control.js';\nimport EventType from '../events/EventType.js';\nimport {CLASS_CONTROL, CLASS_UNSELECTABLE} from '../css.js';\nimport {easeOut} from '../easing.js';\n\n/**\n * @typedef {Object} Options\n * @property {number} [duration=250] Animation duration in milliseconds.\n * @property {string} [className='ol-zoom'] CSS class name.\n * @property {string} [zoomInClassName=className + '-in'] CSS class name for the zoom-in button.\n * @property {string} [zoomOutClassName=className + '-out'] CSS class name for the zoom-out button.\n * @property {string|HTMLElement} [zoomInLabel='+'] Text label to use for the zoom-in\n * button. Instead of text, also an element (e.g. a `span` element) can be used.\n * @property {string|HTMLElement} [zoomOutLabel=''] Text label to use for the zoom-out button.\n * Instead of text, also an element (e.g. a `span` element) can be used.\n * @property {string} [zoomInTipLabel='Zoom in'] Text label to use for the button tip.\n * @property {string} [zoomOutTipLabel='Zoom out'] Text label to use for the button tip.\n * @property {number} [delta=1] The zoom delta applied on each click.\n * @property {HTMLElement|string} [target] Specify a target if you want the control to be\n * rendered outside of the map's viewport.\n */\n\n/**\n * @classdesc\n * A control with 2 buttons, one for zoom in and one for zoom out.\n * This control is one of the default controls of a map. To style this control\n * use css selectors `.ol-zoom-in` and `.ol-zoom-out`.\n *\n * @api\n */\nclass Zoom extends Control {\n  /**\n   * @param {Options} [options] Zoom options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    super({\n      element: document.createElement('div'),\n      target: options.target,\n    });\n\n    const className =\n      options.className !== undefined ? options.className : 'ol-zoom';\n\n    const delta = options.delta !== undefined ? options.delta : 1;\n\n    const zoomInClassName =\n      options.zoomInClassName !== undefined\n        ? options.zoomInClassName\n        : className + '-in';\n\n    const zoomOutClassName =\n      options.zoomOutClassName !== undefined\n        ? options.zoomOutClassName\n        : className + '-out';\n\n    const zoomInLabel =\n      options.zoomInLabel !== undefined ? options.zoomInLabel : '+';\n    const zoomOutLabel =\n      options.zoomOutLabel !== undefined ? options.zoomOutLabel : '\\u2013';\n\n    const zoomInTipLabel =\n      options.zoomInTipLabel !== undefined ? options.zoomInTipLabel : 'Zoom in';\n    const zoomOutTipLabel =\n      options.zoomOutTipLabel !== undefined\n        ? options.zoomOutTipLabel\n        : 'Zoom out';\n\n    const inElement = document.createElement('button');\n    inElement.className = zoomInClassName;\n    inElement.setAttribute('type', 'button');\n    inElement.title = zoomInTipLabel;\n    inElement.appendChild(\n      typeof zoomInLabel === 'string'\n        ? document.createTextNode(zoomInLabel)\n        : zoomInLabel\n    );\n\n    inElement.addEventListener(\n      EventType.CLICK,\n      this.handleClick_.bind(this, delta),\n      false\n    );\n\n    const outElement = document.createElement('button');\n    outElement.className = zoomOutClassName;\n    outElement.setAttribute('type', 'button');\n    outElement.title = zoomOutTipLabel;\n    outElement.appendChild(\n      typeof zoomOutLabel === 'string'\n        ? document.createTextNode(zoomOutLabel)\n        : zoomOutLabel\n    );\n\n    outElement.addEventListener(\n      EventType.CLICK,\n      this.handleClick_.bind(this, -delta),\n      false\n    );\n\n    const cssClasses =\n      className + ' ' + CLASS_UNSELECTABLE + ' ' + CLASS_CONTROL;\n    const element = this.element;\n    element.className = cssClasses;\n    element.appendChild(inElement);\n    element.appendChild(outElement);\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 250;\n  }\n\n  /**\n   * @param {number} delta Zoom delta.\n   * @param {MouseEvent} event The event to handle\n   * @private\n   */\n  handleClick_(delta, event) {\n    event.preventDefault();\n    this.zoomByDelta_(delta);\n  }\n\n  /**\n   * @param {number} delta Zoom delta.\n   * @private\n   */\n  zoomByDelta_(delta) {\n    const map = this.getMap();\n    const view = map.getView();\n    if (!view) {\n      // the map does not have a view, so we can't act\n      // upon it\n      return;\n    }\n    const currentZoom = view.getZoom();\n    if (currentZoom !== undefined) {\n      const newZoom = view.getConstrainedZoom(currentZoom + delta);\n      if (this.duration_ > 0) {\n        if (view.getAnimating()) {\n          view.cancelAnimations();\n        }\n        view.animate({\n          zoom: newZoom,\n          duration: this.duration_,\n          easing: easeOut,\n        });\n      } else {\n        view.setZoom(newZoom);\n      }\n    }\n  }\n}\n\nexport default Zoom;\n","/**\n * @module ol/control/defaults\n */\nimport Attribution from './Attribution.js';\nimport Collection from '../Collection.js';\nimport Rotate from './Rotate.js';\nimport Zoom from './Zoom.js';\n\n/**\n * @typedef {Object} DefaultsOptions\n * @property {boolean} [attribution=true] Include\n * {@link module:ol/control/Attribution~Attribution}.\n * @property {import(\"./Attribution.js\").Options} [attributionOptions]\n * Options for {@link module:ol/control/Attribution~Attribution}.\n * @property {boolean} [rotate=true] Include\n * {@link module:ol/control/Rotate~Rotate}.\n * @property {import(\"./Rotate.js\").Options} [rotateOptions] Options\n * for {@link module:ol/control/Rotate~Rotate}.\n * @property {boolean} [zoom] Include {@link module:ol/control/Zoom~Zoom}.\n * @property {import(\"./Zoom.js\").Options} [zoomOptions] Options for\n * {@link module:ol/control/Zoom~Zoom}.\n */\n\n/**\n * Set of controls included in maps by default. Unless configured otherwise,\n * this returns a collection containing an instance of each of the following\n * controls:\n * * {@link module:ol/control/Zoom~Zoom}\n * * {@link module:ol/control/Rotate~Rotate}\n * * {@link module:ol/control/Attribution~Attribution}\n *\n * @param {DefaultsOptions} [options] Options for the default controls.\n * @return {Collection<import(\"./Control.js\").default>} A collection of controls\n * to be used with the {@link module:ol/Map~Map} constructor's `controls` option.\n * @api\n */\nexport function defaults(options) {\n  options = options ? options : {};\n\n  /** @type {Collection<import(\"./Control.js\").default>} */\n  const controls = new Collection();\n\n  const zoomControl = options.zoom !== undefined ? options.zoom : true;\n  if (zoomControl) {\n    controls.push(new Zoom(options.zoomOptions));\n  }\n\n  const rotateControl = options.rotate !== undefined ? options.rotate : true;\n  if (rotateControl) {\n    controls.push(new Rotate(options.rotateOptions));\n  }\n\n  const attributionControl =\n    options.attribution !== undefined ? options.attribution : true;\n  if (attributionControl) {\n    controls.push(new Attribution(options.attributionOptions));\n  }\n\n  return controls;\n}\n","/**\n * @module ol/css\n */\n\n/**\n * @typedef {Object} FontParameters\n * @property {string} style Style.\n * @property {string} variant Variant.\n * @property {string} weight Weight.\n * @property {string} size Size.\n * @property {string} lineHeight LineHeight.\n * @property {string} family Family.\n * @property {Array<string>} families Families.\n */\n\n/**\n * The CSS class for hidden feature.\n *\n * @const\n * @type {string}\n */\nexport const CLASS_HIDDEN = 'ol-hidden';\n\n/**\n * The CSS class that we'll give the DOM elements to have them selectable.\n *\n * @const\n * @type {string}\n */\nexport const CLASS_SELECTABLE = 'ol-selectable';\n\n/**\n * The CSS class that we'll give the DOM elements to have them unselectable.\n *\n * @const\n * @type {string}\n */\nexport const CLASS_UNSELECTABLE = 'ol-unselectable';\n\n/**\n * The CSS class for unsupported feature.\n *\n * @const\n * @type {string}\n */\nexport const CLASS_UNSUPPORTED = 'ol-unsupported';\n\n/**\n * The CSS class for controls.\n *\n * @const\n * @type {string}\n */\nexport const CLASS_CONTROL = 'ol-control';\n\n/**\n * The CSS class that we'll give the DOM elements that are collapsed, i.e.\n * to those elements which usually can be expanded.\n *\n * @const\n * @type {string}\n */\nexport const CLASS_COLLAPSED = 'ol-collapsed';\n\n/**\n * From https://stackoverflow.com/questions/10135697/regex-to-parse-any-css-font\n * @type {RegExp}\n */\nconst fontRegEx = new RegExp(\n  [\n    '^\\\\s*(?=(?:(?:[-a-z]+\\\\s*){0,2}(italic|oblique))?)',\n    '(?=(?:(?:[-a-z]+\\\\s*){0,2}(small-caps))?)',\n    '(?=(?:(?:[-a-z]+\\\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)',\n    '(?:(?:normal|\\\\1|\\\\2|\\\\3)\\\\s*){0,3}((?:xx?-)?',\n    '(?:small|large)|medium|smaller|larger|[\\\\.\\\\d]+(?:\\\\%|in|[cem]m|ex|p[ctx]))',\n    '(?:\\\\s*\\\\/\\\\s*(normal|[\\\\.\\\\d]+(?:\\\\%|in|[cem]m|ex|p[ctx])?))',\n    '?\\\\s*([-,\\\\\"\\\\\\'\\\\sa-z]+?)\\\\s*$',\n  ].join(''),\n  'i'\n);\nconst fontRegExMatchIndex = [\n  'style',\n  'variant',\n  'weight',\n  'size',\n  'lineHeight',\n  'family',\n];\n\n/**\n * Get the list of font families from a font spec.  Note that this doesn't work\n * for font families that have commas in them.\n * @param {string} fontSpec The CSS font property.\n * @return {FontParameters|null} The font parameters (or null if the input spec is invalid).\n */\nexport const getFontParameters = function (fontSpec) {\n  const match = fontSpec.match(fontRegEx);\n  if (!match) {\n    return null;\n  }\n  const style = /** @type {FontParameters} */ ({\n    lineHeight: 'normal',\n    size: '1.2em',\n    style: 'normal',\n    weight: 'normal',\n    variant: 'normal',\n  });\n  for (let i = 0, ii = fontRegExMatchIndex.length; i < ii; ++i) {\n    const value = match[i + 1];\n    if (value !== undefined) {\n      style[fontRegExMatchIndex[i]] = value;\n    }\n  }\n  style.families = style.family.split(/,\\s?/);\n  return style;\n};\n","import {WORKER_OFFSCREEN_CANVAS} from './has.js';\n\n/**\n * @module ol/dom\n */\n\n//FIXME Move this function to the canvas module\n/**\n * Create an html canvas element and returns its 2d context.\n * @param {number} [width] Canvas width.\n * @param {number} [height] Canvas height.\n * @param {Array<HTMLCanvasElement>} [canvasPool] Canvas pool to take existing canvas from.\n * @param {CanvasRenderingContext2DSettings} [settings] CanvasRenderingContext2DSettings\n * @return {CanvasRenderingContext2D} The context.\n */\nexport function createCanvasContext2D(width, height, canvasPool, settings) {\n  /** @type {HTMLCanvasElement|OffscreenCanvas} */\n  let canvas;\n  if (canvasPool && canvasPool.length) {\n    canvas = canvasPool.shift();\n  } else if (WORKER_OFFSCREEN_CANVAS) {\n    canvas = new OffscreenCanvas(width || 300, height || 300);\n  } else {\n    canvas = document.createElement('canvas');\n  }\n  if (width) {\n    canvas.width = width;\n  }\n  if (height) {\n    canvas.height = height;\n  }\n  //FIXME Allow OffscreenCanvasRenderingContext2D as return type\n  return /** @type {CanvasRenderingContext2D} */ (\n    canvas.getContext('2d', settings)\n  );\n}\n\n/**\n * Releases canvas memory to avoid exceeding memory limits in Safari.\n * See https://pqina.nl/blog/total-canvas-memory-use-exceeds-the-maximum-limit/\n * @param {CanvasRenderingContext2D} context Context.\n */\nexport function releaseCanvas(context) {\n  const canvas = context.canvas;\n  canvas.width = 1;\n  canvas.height = 1;\n  context.clearRect(0, 0, 1, 1);\n}\n\n/**\n * Get the current computed width for the given element including margin,\n * padding and border.\n * Equivalent to jQuery's `$(el).outerWidth(true)`.\n * @param {!HTMLElement} element Element.\n * @return {number} The width.\n */\nexport function outerWidth(element) {\n  let width = element.offsetWidth;\n  const style = getComputedStyle(element);\n  width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);\n\n  return width;\n}\n\n/**\n * Get the current computed height for the given element including margin,\n * padding and border.\n * Equivalent to jQuery's `$(el).outerHeight(true)`.\n * @param {!HTMLElement} element Element.\n * @return {number} The height.\n */\nexport function outerHeight(element) {\n  let height = element.offsetHeight;\n  const style = getComputedStyle(element);\n  height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);\n\n  return height;\n}\n\n/**\n * @param {Node} newNode Node to replace old node\n * @param {Node} oldNode The node to be replaced\n */\nexport function replaceNode(newNode, oldNode) {\n  const parent = oldNode.parentNode;\n  if (parent) {\n    parent.replaceChild(newNode, oldNode);\n  }\n}\n\n/**\n * @param {Node} node The node to remove.\n * @return {Node|null} The node that was removed or null.\n */\nexport function removeNode(node) {\n  return node && node.parentNode ? node.parentNode.removeChild(node) : null;\n}\n\n/**\n * @param {Node} node The node to remove the children from.\n */\nexport function removeChildren(node) {\n  while (node.lastChild) {\n    node.removeChild(node.lastChild);\n  }\n}\n\n/**\n * Transform the children of a parent node so they match the\n * provided list of children.  This function aims to efficiently\n * remove, add, and reorder child nodes while maintaining a simple\n * implementation (it is not guaranteed to minimize DOM operations).\n * @param {Node} node The parent node whose children need reworking.\n * @param {Array<Node>} children The desired children.\n */\nexport function replaceChildren(node, children) {\n  const oldChildren = node.childNodes;\n\n  for (let i = 0; true; ++i) {\n    const oldChild = oldChildren[i];\n    const newChild = children[i];\n\n    // check if our work is done\n    if (!oldChild && !newChild) {\n      break;\n    }\n\n    // check if children match\n    if (oldChild === newChild) {\n      continue;\n    }\n\n    // check if a new child needs to be added\n    if (!oldChild) {\n      node.appendChild(newChild);\n      continue;\n    }\n\n    // check if an old child needs to be removed\n    if (!newChild) {\n      node.removeChild(oldChild);\n      --i;\n      continue;\n    }\n\n    // reorder\n    node.insertBefore(newChild, oldChild);\n  }\n}\n","/**\n * @module ol/easing\n */\n\n/**\n * Start slow and speed up.\n * @param {number} t Input between 0 and 1.\n * @return {number} Output between 0 and 1.\n * @api\n */\nexport function easeIn(t) {\n  return Math.pow(t, 3);\n}\n\n/**\n * Start fast and slow down.\n * @param {number} t Input between 0 and 1.\n * @return {number} Output between 0 and 1.\n * @api\n */\nexport function easeOut(t) {\n  return 1 - easeIn(1 - t);\n}\n\n/**\n * Start slow, speed up, and then slow down again.\n * @param {number} t Input between 0 and 1.\n * @return {number} Output between 0 and 1.\n * @api\n */\nexport function inAndOut(t) {\n  return 3 * t * t - 2 * t * t * t;\n}\n\n/**\n * Maintain a constant speed over time.\n * @param {number} t Input between 0 and 1.\n * @return {number} Output between 0 and 1.\n * @api\n */\nexport function linear(t) {\n  return t;\n}\n\n/**\n * Start slow, speed up, and at the very end slow down again.  This has the\n * same general behavior as {@link module:ol/easing.inAndOut}, but the final\n * slowdown is delayed.\n * @param {number} t Input between 0 and 1.\n * @return {number} Output between 0 and 1.\n * @api\n */\nexport function upAndDown(t) {\n  if (t < 0.5) {\n    return inAndOut(2 * t);\n  }\n  return 1 - inAndOut(2 * (t - 0.5));\n}\n","/**\n * @module ol/events\n */\nimport {clear} from './obj.js';\n\n/**\n * Key to use with {@link module:ol/Observable.unByKey}.\n * @typedef {Object} EventsKey\n * @property {ListenerFunction} listener Listener.\n * @property {import(\"./events/Target.js\").EventTargetLike} target Target.\n * @property {string} type Type.\n * @api\n */\n\n/**\n * Listener function. This function is called with an event object as argument.\n * When the function returns `false`, event propagation will stop.\n *\n * @typedef {function((Event|import(\"./events/Event.js\").default)): (void|boolean)} ListenerFunction\n * @api\n */\n\n/**\n * @typedef {Object} ListenerObject\n * @property {ListenerFunction} handleEvent HandleEvent listener function.\n */\n\n/**\n * @typedef {ListenerFunction|ListenerObject} Listener\n */\n\n/**\n * Registers an event listener on an event target. Inspired by\n * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html\n *\n * This function efficiently binds a `listener` to a `this` object, and returns\n * a key for use with {@link module:ol/events.unlistenByKey}.\n *\n * @param {import(\"./events/Target.js\").EventTargetLike} target Event target.\n * @param {string} type Event type.\n * @param {ListenerFunction} listener Listener.\n * @param {Object} [thisArg] Object referenced by the `this` keyword in the\n *     listener. Default is the `target`.\n * @param {boolean} [once] If true, add the listener as one-off listener.\n * @return {EventsKey} Unique key for the listener.\n */\nexport function listen(target, type, listener, thisArg, once) {\n  if (thisArg && thisArg !== target) {\n    listener = listener.bind(thisArg);\n  }\n  if (once) {\n    const originalListener = listener;\n    listener = function () {\n      target.removeEventListener(type, listener);\n      originalListener.apply(this, arguments);\n    };\n  }\n  const eventsKey = {\n    target: target,\n    type: type,\n    listener: listener,\n  };\n  target.addEventListener(type, listener);\n  return eventsKey;\n}\n\n/**\n * Registers a one-off event listener on an event target. Inspired by\n * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html\n *\n * This function efficiently binds a `listener` as self-unregistering listener\n * to a `this` object, and returns a key for use with\n * {@link module:ol/events.unlistenByKey} in case the listener needs to be\n * unregistered before it is called.\n *\n * When {@link module:ol/events.listen} is called with the same arguments after this\n * function, the self-unregistering listener will be turned into a permanent\n * listener.\n *\n * @param {import(\"./events/Target.js\").EventTargetLike} target Event target.\n * @param {string} type Event type.\n * @param {ListenerFunction} listener Listener.\n * @param {Object} [thisArg] Object referenced by the `this` keyword in the\n *     listener. Default is the `target`.\n * @return {EventsKey} Key for unlistenByKey.\n */\nexport function listenOnce(target, type, listener, thisArg) {\n  return listen(target, type, listener, thisArg, true);\n}\n\n/**\n * Unregisters event listeners on an event target. Inspired by\n * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html\n *\n * The argument passed to this function is the key returned from\n * {@link module:ol/events.listen} or {@link module:ol/events.listenOnce}.\n *\n * @param {EventsKey} key The key.\n */\nexport function unlistenByKey(key) {\n  if (key && key.target) {\n    key.target.removeEventListener(key.type, key.listener);\n    clear(key);\n  }\n}\n","/**\n * @module ol/events/Event\n */\n\n/**\n * @classdesc\n * Stripped down implementation of the W3C DOM Level 2 Event interface.\n * See https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-interface.\n *\n * This implementation only provides `type` and `target` properties, and\n * `stopPropagation` and `preventDefault` methods. It is meant as base class\n * for higher level events defined in the library, and works with\n * {@link module:ol/events/Target~Target}.\n */\nclass BaseEvent {\n  /**\n   * @param {string} type Type.\n   */\n  constructor(type) {\n    /**\n     * @type {boolean}\n     */\n    this.propagationStopped;\n\n    /**\n     * @type {boolean}\n     */\n    this.defaultPrevented;\n\n    /**\n     * The event type.\n     * @type {string}\n     * @api\n     */\n    this.type = type;\n\n    /**\n     * The event target.\n     * @type {Object}\n     * @api\n     */\n    this.target = null;\n  }\n\n  /**\n   * Prevent default. This means that no emulated `click`, `singleclick` or `doubleclick` events\n   * will be fired.\n   * @api\n   */\n  preventDefault() {\n    this.defaultPrevented = true;\n  }\n\n  /**\n   * Stop event propagation.\n   * @api\n   */\n  stopPropagation() {\n    this.propagationStopped = true;\n  }\n}\n\n/**\n * @param {Event|import(\"./Event.js\").default} evt Event\n */\nexport function stopPropagation(evt) {\n  evt.stopPropagation();\n}\n\n/**\n * @param {Event|import(\"./Event.js\").default} evt Event\n */\nexport function preventDefault(evt) {\n  evt.preventDefault();\n}\n\nexport default BaseEvent;\n","/**\n * @module ol/events/EventType\n */\n\n/**\n * @enum {string}\n * @const\n */\nexport default {\n  /**\n   * Generic change event. Triggered when the revision counter is increased.\n   * @event module:ol/events/Event~BaseEvent#change\n   * @api\n   */\n  CHANGE: 'change',\n\n  /**\n   * Generic error event. Triggered when an error occurs.\n   * @event module:ol/events/Event~BaseEvent#error\n   * @api\n   */\n  ERROR: 'error',\n\n  BLUR: 'blur',\n  CLEAR: 'clear',\n  CONTEXTMENU: 'contextmenu',\n  CLICK: 'click',\n  DBLCLICK: 'dblclick',\n  DRAGENTER: 'dragenter',\n  DRAGOVER: 'dragover',\n  DROP: 'drop',\n  FOCUS: 'focus',\n  KEYDOWN: 'keydown',\n  KEYPRESS: 'keypress',\n  LOAD: 'load',\n  RESIZE: 'resize',\n  TOUCHMOVE: 'touchmove',\n  WHEEL: 'wheel',\n};\n","/**\n * @module ol/events/KeyCode\n */\n\n/**\n * @enum {number}\n * @const\n */\nexport default {\n  LEFT: 37,\n  UP: 38,\n  RIGHT: 39,\n  DOWN: 40,\n};\n","/**\n * @module ol/events/Target\n */\nimport Disposable from '../Disposable.js';\nimport Event from './Event.js';\nimport {VOID} from '../functions.js';\nimport {clear} from '../obj.js';\n\n/**\n * @typedef {EventTarget|Target} EventTargetLike\n */\n\n/**\n * @classdesc\n * A simplified implementation of the W3C DOM Level 2 EventTarget interface.\n * See https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget.\n *\n * There are two important simplifications compared to the specification:\n *\n * 1. The handling of `useCapture` in `addEventListener` and\n *    `removeEventListener`. There is no real capture model.\n * 2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.\n *    There is no event target hierarchy. When a listener calls\n *    `stopPropagation` or `preventDefault` on an event object, it means that no\n *    more listeners after this one will be called. Same as when the listener\n *    returns false.\n */\nclass Target extends Disposable {\n  /**\n   * @param {*} [target] Default event target for dispatched events.\n   */\n  constructor(target) {\n    super();\n\n    /**\n     * @private\n     * @type {*}\n     */\n    this.eventTarget_ = target;\n\n    /**\n     * @private\n     * @type {Object<string, number>}\n     */\n    this.pendingRemovals_ = null;\n\n    /**\n     * @private\n     * @type {Object<string, number>}\n     */\n    this.dispatching_ = null;\n\n    /**\n     * @private\n     * @type {Object<string, Array<import(\"../events.js\").Listener>>}\n     */\n    this.listeners_ = null;\n  }\n\n  /**\n   * @param {string} type Type.\n   * @param {import(\"../events.js\").Listener} listener Listener.\n   */\n  addEventListener(type, listener) {\n    if (!type || !listener) {\n      return;\n    }\n    const listeners = this.listeners_ || (this.listeners_ = {});\n    const listenersForType = listeners[type] || (listeners[type] = []);\n    if (!listenersForType.includes(listener)) {\n      listenersForType.push(listener);\n    }\n  }\n\n  /**\n   * Dispatches an event and calls all listeners listening for events\n   * of this type. The event parameter can either be a string or an\n   * Object with a `type` property.\n   *\n   * @param {import(\"./Event.js\").default|string} event Event object.\n   * @return {boolean|undefined} `false` if anyone called preventDefault on the\n   *     event object or if any of the listeners returned false.\n   * @api\n   */\n  dispatchEvent(event) {\n    const isString = typeof event === 'string';\n    const type = isString ? event : event.type;\n    const listeners = this.listeners_ && this.listeners_[type];\n    if (!listeners) {\n      return;\n    }\n\n    const evt = isString ? new Event(event) : /** @type {Event} */ (event);\n    if (!evt.target) {\n      evt.target = this.eventTarget_ || this;\n    }\n    const dispatching = this.dispatching_ || (this.dispatching_ = {});\n    const pendingRemovals =\n      this.pendingRemovals_ || (this.pendingRemovals_ = {});\n    if (!(type in dispatching)) {\n      dispatching[type] = 0;\n      pendingRemovals[type] = 0;\n    }\n    ++dispatching[type];\n    let propagate;\n    for (let i = 0, ii = listeners.length; i < ii; ++i) {\n      if ('handleEvent' in listeners[i]) {\n        propagate = /** @type {import(\"../events.js\").ListenerObject} */ (\n          listeners[i]\n        ).handleEvent(evt);\n      } else {\n        propagate = /** @type {import(\"../events.js\").ListenerFunction} */ (\n          listeners[i]\n        ).call(this, evt);\n      }\n      if (propagate === false || evt.propagationStopped) {\n        propagate = false;\n        break;\n      }\n    }\n    if (--dispatching[type] === 0) {\n      let pr = pendingRemovals[type];\n      delete pendingRemovals[type];\n      while (pr--) {\n        this.removeEventListener(type, VOID);\n      }\n      delete dispatching[type];\n    }\n    return propagate;\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    this.listeners_ && clear(this.listeners_);\n  }\n\n  /**\n   * Get the listeners for a specified event type. Listeners are returned in the\n   * order that they will be called in.\n   *\n   * @param {string} type Type.\n   * @return {Array<import(\"../events.js\").Listener>|undefined} Listeners.\n   */\n  getListeners(type) {\n    return (this.listeners_ && this.listeners_[type]) || undefined;\n  }\n\n  /**\n   * @param {string} [type] Type. If not provided,\n   *     `true` will be returned if this event target has any listeners.\n   * @return {boolean} Has listeners.\n   */\n  hasListener(type) {\n    if (!this.listeners_) {\n      return false;\n    }\n    return type\n      ? type in this.listeners_\n      : Object.keys(this.listeners_).length > 0;\n  }\n\n  /**\n   * @param {string} type Type.\n   * @param {import(\"../events.js\").Listener} listener Listener.\n   */\n  removeEventListener(type, listener) {\n    const listeners = this.listeners_ && this.listeners_[type];\n    if (listeners) {\n      const index = listeners.indexOf(listener);\n      if (index !== -1) {\n        if (this.pendingRemovals_ && type in this.pendingRemovals_) {\n          // make listener a no-op, and remove later in #dispatchEvent()\n          listeners[index] = VOID;\n          ++this.pendingRemovals_[type];\n        } else {\n          listeners.splice(index, 1);\n          if (listeners.length === 0) {\n            delete this.listeners_[type];\n          }\n        }\n      }\n    }\n  }\n}\n\nexport default Target;\n","/**\n * @module ol/events/condition\n */\nimport MapBrowserEventType from '../MapBrowserEventType.js';\nimport {FALSE, TRUE} from '../functions.js';\nimport {MAC, WEBKIT} from '../has.js';\nimport {assert} from '../asserts.js';\n\n/**\n * A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * `{boolean}`. If the condition is met, true should be returned.\n *\n * @typedef {function(this: ?, import(\"../MapBrowserEvent.js\").default): boolean} Condition\n */\n\n/**\n * Creates a condition function that passes when all provided conditions pass.\n * @param {...Condition} var_args Conditions to check.\n * @return {Condition} Condition function.\n */\nexport function all(var_args) {\n  const conditions = arguments;\n  /**\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @return {boolean} All conditions passed.\n   */\n  return function (event) {\n    let pass = true;\n    for (let i = 0, ii = conditions.length; i < ii; ++i) {\n      pass = pass && conditions[i](event);\n      if (!pass) {\n        break;\n      }\n    }\n    return pass;\n  };\n}\n\n/**\n * Return `true` if only the alt-key is pressed, `false` otherwise (e.g. when\n * additionally the shift-key is pressed).\n *\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n * @return {boolean} True if only the alt key is pressed.\n * @api\n */\nexport const altKeyOnly = function (mapBrowserEvent) {\n  const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (\n    mapBrowserEvent.originalEvent\n  );\n  return (\n    originalEvent.altKey &&\n    !(originalEvent.metaKey || originalEvent.ctrlKey) &&\n    !originalEvent.shiftKey\n  );\n};\n\n/**\n * Return `true` if only the alt-key and shift-key is pressed, `false` otherwise\n * (e.g. when additionally the platform-modifier-key is pressed).\n *\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n * @return {boolean} True if only the alt and shift keys are pressed.\n * @api\n */\nexport const altShiftKeysOnly = function (mapBrowserEvent) {\n  const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (\n    mapBrowserEvent.originalEvent\n  );\n  return (\n    originalEvent.altKey &&\n    !(originalEvent.metaKey || originalEvent.ctrlKey) &&\n    originalEvent.shiftKey\n  );\n};\n\n/**\n * Return `true` if the map has the focus. This condition requires a map target\n * element with a `tabindex` attribute, e.g. `<div id=\"map\" tabindex=\"1\">`.\n *\n * @param {import(\"../MapBrowserEvent.js\").default} event Map browser event.\n * @return {boolean} The map has the focus.\n * @api\n */\nexport const focus = function (event) {\n  const targetElement = event.map.getTargetElement();\n  const activeElement = event.map.getOwnerDocument().activeElement;\n  return targetElement.contains(activeElement);\n};\n\n/**\n * Return `true` if the map has the focus or no 'tabindex' attribute set.\n *\n * @param {import(\"../MapBrowserEvent.js\").default} event Map browser event.\n * @return {boolean} The map container has the focus or no 'tabindex' attribute.\n */\nexport const focusWithTabindex = function (event) {\n  return event.map.getTargetElement().hasAttribute('tabindex')\n    ? focus(event)\n    : true;\n};\n\n/**\n * Return always true.\n *\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n * @return {boolean} True.\n * @api\n */\nexport const always = TRUE;\n\n/**\n * Return `true` if the event is a `click` event, `false` otherwise.\n *\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n * @return {boolean} True if the event is a map `click` event.\n * @api\n */\nexport const click = function (mapBrowserEvent) {\n  return mapBrowserEvent.type == MapBrowserEventType.CLICK;\n};\n\n/**\n * Return `true` if the event has an \"action\"-producing mouse button.\n *\n * By definition, this includes left-click on windows/linux, and left-click\n * without the ctrl key on Macs.\n *\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n * @return {boolean} The result.\n */\nexport const mouseActionButton = function (mapBrowserEvent) {\n  const originalEvent = /** @type {MouseEvent} */ (\n    mapBrowserEvent.originalEvent\n  );\n  return originalEvent.button == 0 && !(WEBKIT && MAC && originalEvent.ctrlKey);\n};\n\n/**\n * Return always false.\n *\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n * @return {boolean} False.\n * @api\n */\nexport const never = FALSE;\n\n/**\n * Return `true` if the browser event is a `pointermove` event, `false`\n * otherwise.\n *\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n * @return {boolean} True if the browser event is a `pointermove` event.\n * @api\n */\nexport const pointerMove = function (mapBrowserEvent) {\n  return mapBrowserEvent.type == 'pointermove';\n};\n\n/**\n * Return `true` if the event is a map `singleclick` event, `false` otherwise.\n *\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n * @return {boolean} True if the event is a map `singleclick` event.\n * @api\n */\nexport const singleClick = function (mapBrowserEvent) {\n  return mapBrowserEvent.type == MapBrowserEventType.SINGLECLICK;\n};\n\n/**\n * Return `true` if the event is a map `dblclick` event, `false` otherwise.\n *\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n * @return {boolean} True if the event is a map `dblclick` event.\n * @api\n */\nexport const doubleClick = function (mapBrowserEvent) {\n  return mapBrowserEvent.type == MapBrowserEventType.DBLCLICK;\n};\n\n/**\n * Return `true` if no modifier key (alt-, shift- or platform-modifier-key) is\n * pressed.\n *\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n * @return {boolean} True only if there no modifier keys are pressed.\n * @api\n */\nexport const noModifierKeys = function (mapBrowserEvent) {\n  const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (\n    mapBrowserEvent.originalEvent\n  );\n  return (\n    !originalEvent.altKey &&\n    !(originalEvent.metaKey || originalEvent.ctrlKey) &&\n    !originalEvent.shiftKey\n  );\n};\n\n/**\n * Return `true` if only the platform-modifier-key (the meta-key on Mac,\n * ctrl-key otherwise) is pressed, `false` otherwise (e.g. when additionally\n * the shift-key is pressed).\n *\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n * @return {boolean} True if only the platform modifier key is pressed.\n * @api\n */\nexport const platformModifierKeyOnly = function (mapBrowserEvent) {\n  const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (\n    mapBrowserEvent.originalEvent\n  );\n  return (\n    !originalEvent.altKey &&\n    (MAC ? originalEvent.metaKey : originalEvent.ctrlKey) &&\n    !originalEvent.shiftKey\n  );\n};\n\n/**\n * Return `true` if only the shift-key is pressed, `false` otherwise (e.g. when\n * additionally the alt-key is pressed).\n *\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n * @return {boolean} True if only the shift key is pressed.\n * @api\n */\nexport const shiftKeyOnly = function (mapBrowserEvent) {\n  const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (\n    mapBrowserEvent.originalEvent\n  );\n  return (\n    !originalEvent.altKey &&\n    !(originalEvent.metaKey || originalEvent.ctrlKey) &&\n    originalEvent.shiftKey\n  );\n};\n\n/**\n * Return `true` if the target element is not editable, i.e. not an `input`,\n * `select`, or `textarea` element and no `contenteditable` attribute is\n * set or inherited, `false` otherwise.\n *\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n * @return {boolean} True only if the target element is not editable.\n * @api\n */\nexport const targetNotEditable = function (mapBrowserEvent) {\n  const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (\n    mapBrowserEvent.originalEvent\n  );\n  const tagName = /** @type {Element} */ (originalEvent.target).tagName;\n  return (\n    tagName !== 'INPUT' &&\n    tagName !== 'SELECT' &&\n    tagName !== 'TEXTAREA' &&\n    // `isContentEditable` is only available on `HTMLElement`, but it may also be a\n    // different type like `SVGElement`.\n    // @ts-ignore\n    !originalEvent.target.isContentEditable\n  );\n};\n\n/**\n * Return `true` if the event originates from a mouse device.\n *\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n * @return {boolean} True if the event originates from a mouse device.\n * @api\n */\nexport const mouseOnly = function (mapBrowserEvent) {\n  const pointerEvent = /** @type {import(\"../MapBrowserEvent\").default} */ (\n    mapBrowserEvent\n  ).originalEvent;\n  assert(pointerEvent !== undefined, 56); // mapBrowserEvent must originate from a pointer event\n  // see https://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType\n  return pointerEvent.pointerType == 'mouse';\n};\n\n/**\n * Return `true` if the event originates from a touchable device.\n *\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n * @return {boolean} True if the event originates from a touchable device.\n * @api\n */\nexport const touchOnly = function (mapBrowserEvent) {\n  const pointerEvt = /** @type {import(\"../MapBrowserEvent\").default} */ (\n    mapBrowserEvent\n  ).originalEvent;\n  assert(pointerEvt !== undefined, 56); // mapBrowserEvent must originate from a pointer event\n  // see https://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType\n  return pointerEvt.pointerType === 'touch';\n};\n\n/**\n * Return `true` if the event originates from a digital pen.\n *\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n * @return {boolean} True if the event originates from a digital pen.\n * @api\n */\nexport const penOnly = function (mapBrowserEvent) {\n  const pointerEvt = /** @type {import(\"../MapBrowserEvent\").default} */ (\n    mapBrowserEvent\n  ).originalEvent;\n  assert(pointerEvt !== undefined, 56); // mapBrowserEvent must originate from a pointer event\n  // see https://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType\n  return pointerEvt.pointerType === 'pen';\n};\n\n/**\n * Return `true` if the event originates from a primary pointer in\n * contact with the surface or if the left mouse button is pressed.\n * See https://www.w3.org/TR/pointerevents/#button-states.\n *\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n * @return {boolean} True if the event originates from a primary pointer.\n * @api\n */\nexport const primaryAction = function (mapBrowserEvent) {\n  const pointerEvent = /** @type {import(\"../MapBrowserEvent\").default} */ (\n    mapBrowserEvent\n  ).originalEvent;\n  assert(pointerEvent !== undefined, 56); // mapBrowserEvent must originate from a pointer event\n  return pointerEvent.isPrimary && pointerEvent.button === 0;\n};\n","/**\n * @module ol/featureloader\n */\nimport {VOID} from './functions.js';\n\n/**\n *\n * @type {boolean}\n * @private\n */\nlet withCredentials = false;\n\n/**\n * {@link module:ol/source/Vector~VectorSource} sources use a function of this type to\n * load features.\n *\n * This function takes up to 5 arguments. These are an {@link module:ol/extent~Extent} representing\n * the area to be loaded, a `{number}` representing the resolution (map units per pixel), an\n * {@link module:ol/proj/Projection~Projection} for the projection, an optional success callback that should get\n * the loaded features passed as an argument and an optional failure callback with no arguments. If\n * the callbacks are not used, the corresponding vector source will not fire `'featuresloadend'` and\n * `'featuresloaderror'` events. `this` within the function is bound to the\n * {@link module:ol/source/Vector~VectorSource} it's called from.\n *\n * The function is responsible for loading the features and adding them to the\n * source.\n * @typedef {function(this:(import(\"./source/Vector\").default|import(\"./VectorTile.js\").default),\n *           import(\"./extent.js\").Extent,\n *           number,\n *           import(\"./proj/Projection.js\").default,\n *           function(Array<import(\"./Feature.js\").default>): void=,\n *           function(): void=): void} FeatureLoader\n * @api\n */\n\n/**\n * {@link module:ol/source/Vector~VectorSource} sources use a function of this type to\n * get the url to load features from.\n *\n * This function takes an {@link module:ol/extent~Extent} representing the area\n * to be loaded, a `{number}` representing the resolution (map units per pixel)\n * and an {@link module:ol/proj/Projection~Projection} for the projection  as\n * arguments and returns a `{string}` representing the URL.\n * @typedef {function(import(\"./extent.js\").Extent, number, import(\"./proj/Projection.js\").default): string} FeatureUrlFunction\n * @api\n */\n\n/**\n * @param {string|FeatureUrlFunction} url Feature URL service.\n * @param {import(\"./format/Feature.js\").default} format Feature format.\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number} resolution Resolution.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @param {function(Array<import(\"./Feature.js\").default>, import(\"./proj/Projection.js\").default): void} success Success\n *      Function called with the loaded features and optionally with the data projection.\n * @param {function(): void} failure Failure\n *      Function called when loading failed.\n */\nexport function loadFeaturesXhr(\n  url,\n  format,\n  extent,\n  resolution,\n  projection,\n  success,\n  failure\n) {\n  const xhr = new XMLHttpRequest();\n  xhr.open(\n    'GET',\n    typeof url === 'function' ? url(extent, resolution, projection) : url,\n    true\n  );\n  if (format.getType() == 'arraybuffer') {\n    xhr.responseType = 'arraybuffer';\n  }\n  xhr.withCredentials = withCredentials;\n  /**\n   * @param {Event} event Event.\n   * @private\n   */\n  xhr.onload = function (event) {\n    // status will be 0 for file:// urls\n    if (!xhr.status || (xhr.status >= 200 && xhr.status < 300)) {\n      const type = format.getType();\n      /** @type {Document|Node|Object|string|undefined} */\n      let source;\n      if (type == 'json' || type == 'text') {\n        source = xhr.responseText;\n      } else if (type == 'xml') {\n        source = xhr.responseXML;\n        if (!source) {\n          source = new DOMParser().parseFromString(\n            xhr.responseText,\n            'application/xml'\n          );\n        }\n      } else if (type == 'arraybuffer') {\n        source = /** @type {ArrayBuffer} */ (xhr.response);\n      }\n      if (source) {\n        success(\n          /** @type {Array<import(\"./Feature.js\").default>} */\n          (\n            format.readFeatures(source, {\n              extent: extent,\n              featureProjection: projection,\n            })\n          ),\n          format.readProjection(source)\n        );\n      } else {\n        failure();\n      }\n    } else {\n      failure();\n    }\n  };\n  /**\n   * @private\n   */\n  xhr.onerror = failure;\n  xhr.send();\n}\n\n/**\n * Create an XHR feature loader for a `url` and `format`. The feature loader\n * loads features (with XHR), parses the features, and adds them to the\n * vector source.\n * @param {string|FeatureUrlFunction} url Feature URL service.\n * @param {import(\"./format/Feature.js\").default} format Feature format.\n * @return {FeatureLoader} The feature loader.\n * @api\n */\nexport function xhr(url, format) {\n  /**\n   * @param {import(\"./extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {import(\"./proj/Projection.js\").default} projection Projection.\n   * @param {function(Array<import(\"./Feature.js\").default>): void} [success] Success\n   *      Function called when loading succeeded.\n   * @param {function(): void} [failure] Failure\n   *      Function called when loading failed.\n   */\n  return function (extent, resolution, projection, success, failure) {\n    const source = /** @type {import(\"./source/Vector\").default} */ (this);\n    loadFeaturesXhr(\n      url,\n      format,\n      extent,\n      resolution,\n      projection,\n      /**\n       * @param {Array<import(\"./Feature.js\").default>} features The loaded features.\n       * @param {import(\"./proj/Projection.js\").default} dataProjection Data\n       * projection.\n       */\n      function (features, dataProjection) {\n        source.addFeatures(features);\n        if (success !== undefined) {\n          success(features);\n        }\n      },\n      /* FIXME handle error */ failure ? failure : VOID\n    );\n  };\n}\n\n/**\n * Setter for the withCredentials configuration for the XHR.\n *\n * @param {boolean} xhrWithCredentials The value of withCredentials to set.\n * Compare https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/\n * @api\n */\nexport function setWithCredentials(xhrWithCredentials) {\n  withCredentials = xhrWithCredentials;\n}\n","/**\n * @module ol/functions\n */\n\nimport {equals as arrayEquals} from './array.js';\n\n/**\n * Always returns true.\n * @return {boolean} true.\n */\nexport function TRUE() {\n  return true;\n}\n\n/**\n * Always returns false.\n * @return {boolean} false.\n */\nexport function FALSE() {\n  return false;\n}\n\n/**\n * A reusable function, used e.g. as a default for callbacks.\n *\n * @return {void} Nothing.\n */\nexport function VOID() {}\n\n/**\n * Wrap a function in another function that remembers the last return.  If the\n * returned function is called twice in a row with the same arguments and the same\n * this object, it will return the value from the first call in the second call.\n *\n * @param {function(...any): ReturnType} fn The function to memoize.\n * @return {function(...any): ReturnType} The memoized function.\n * @template ReturnType\n */\nexport function memoizeOne(fn) {\n  let called = false;\n\n  /** @type {ReturnType} */\n  let lastResult;\n\n  /** @type {Array<any>} */\n  let lastArgs;\n\n  let lastThis;\n\n  return function () {\n    const nextArgs = Array.prototype.slice.call(arguments);\n    if (!called || this !== lastThis || !arrayEquals(nextArgs, lastArgs)) {\n      called = true;\n      lastThis = this;\n      lastArgs = nextArgs;\n      lastResult = fn.apply(this, arguments);\n    }\n    return lastResult;\n  };\n}\n\n/**\n * @template T\n * @param {function(): (T | Promise<T>)} getter A function that returns a value or a promise for a value.\n * @return {Promise<T>} A promise for the value.\n */\nexport function toPromise(getter) {\n  function promiseGetter() {\n    let value;\n    try {\n      value = getter();\n    } catch (err) {\n      return Promise.reject(err);\n    }\n    if (value instanceof Promise) {\n      return value;\n    }\n    return Promise.resolve(value);\n  }\n  return promiseGetter();\n}\n","/**\n * @module ol/geom/Geometry\n */\nimport BaseObject from '../Object.js';\nimport {abstract} from '../util.js';\nimport {\n  compose as composeTransform,\n  create as createTransform,\n} from '../transform.js';\nimport {\n  createEmpty,\n  createOrUpdateEmpty,\n  getHeight,\n  returnOrUpdate,\n} from '../extent.js';\nimport {get as getProjection, getTransform} from '../proj.js';\nimport {memoizeOne} from '../functions.js';\nimport {transform2D} from './flat/transform.js';\n\n/**\n * @typedef {'XY' | 'XYZ' | 'XYM' | 'XYZM'} GeometryLayout\n * The coordinate layout for geometries, indicating whether a 3rd or 4th z ('Z')\n * or measure ('M') coordinate is available.\n */\n\n/**\n * @typedef {'Point' | 'LineString' | 'LinearRing' | 'Polygon' | 'MultiPoint' | 'MultiLineString' | 'MultiPolygon' | 'GeometryCollection' | 'Circle'} Type\n * The geometry type.  One of `'Point'`, `'LineString'`, `'LinearRing'`,\n * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,\n * `'GeometryCollection'`, or `'Circle'`.\n */\n\n/**\n * @type {import(\"../transform.js\").Transform}\n */\nconst tmpTransform = createTransform();\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for vector geometries.\n *\n * To get notified of changes to the geometry, register a listener for the\n * generic `change` event on your geometry instance.\n *\n * @abstract\n * @api\n */\nclass Geometry extends BaseObject {\n  constructor() {\n    super();\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.extent_ = createEmpty();\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.extentRevision_ = -1;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.simplifiedGeometryRevision = 0;\n\n    /**\n     * Get a transformed and simplified version of the geometry.\n     * @abstract\n     * @param {number} revision The geometry revision.\n     * @param {number} squaredTolerance Squared tolerance.\n     * @param {import(\"../proj.js\").TransformFunction} [transform] Optional transform function.\n     * @return {Geometry} Simplified geometry.\n     */\n    this.simplifyTransformedInternal = memoizeOne(function (\n      revision,\n      squaredTolerance,\n      transform\n    ) {\n      if (!transform) {\n        return this.getSimplifiedGeometry(squaredTolerance);\n      }\n      const clone = this.clone();\n      clone.applyTransform(transform);\n      return clone.getSimplifiedGeometry(squaredTolerance);\n    });\n  }\n\n  /**\n   * Get a transformed and simplified version of the geometry.\n   * @abstract\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../proj.js\").TransformFunction} [transform] Optional transform function.\n   * @return {Geometry} Simplified geometry.\n   */\n  simplifyTransformed(squaredTolerance, transform) {\n    return this.simplifyTransformedInternal(\n      this.getRevision(),\n      squaredTolerance,\n      transform\n    );\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @abstract\n   * @return {!Geometry} Clone.\n   */\n  clone() {\n    return abstract();\n  }\n\n  /**\n   * @abstract\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    return abstract();\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @return {boolean} Contains (x, y).\n   */\n  containsXY(x, y) {\n    const coord = this.getClosestPoint([x, y]);\n    return coord[0] === x && coord[1] === y;\n  }\n\n  /**\n   * Return the closest point of the geometry to the passed point as\n   * {@link module:ol/coordinate~Coordinate coordinate}.\n   * @param {import(\"../coordinate.js\").Coordinate} point Point.\n   * @param {import(\"../coordinate.js\").Coordinate} [closestPoint] Closest point.\n   * @return {import(\"../coordinate.js\").Coordinate} Closest point.\n   * @api\n   */\n  getClosestPoint(point, closestPoint) {\n    closestPoint = closestPoint ? closestPoint : [NaN, NaN];\n    this.closestPointXY(point[0], point[1], closestPoint, Infinity);\n    return closestPoint;\n  }\n\n  /**\n   * Returns true if this geometry includes the specified coordinate. If the\n   * coordinate is on the boundary of the geometry, returns false.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @return {boolean} Contains coordinate.\n   * @api\n   */\n  intersectsCoordinate(coordinate) {\n    return this.containsXY(coordinate[0], coordinate[1]);\n  }\n\n  /**\n   * @abstract\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @protected\n   * @return {import(\"../extent.js\").Extent} extent Extent.\n   */\n  computeExtent(extent) {\n    return abstract();\n  }\n\n  /**\n   * Get the extent of the geometry.\n   * @param {import(\"../extent.js\").Extent} [extent] Extent.\n   * @return {import(\"../extent.js\").Extent} extent Extent.\n   * @api\n   */\n  getExtent(extent) {\n    if (this.extentRevision_ != this.getRevision()) {\n      const extent = this.computeExtent(this.extent_);\n      if (isNaN(extent[0]) || isNaN(extent[1])) {\n        createOrUpdateEmpty(extent);\n      }\n      this.extentRevision_ = this.getRevision();\n    }\n    return returnOrUpdate(this.extent_, extent);\n  }\n\n  /**\n   * Rotate the geometry around a given coordinate. This modifies the geometry\n   * coordinates in place.\n   * @abstract\n   * @param {number} angle Rotation angle in radians.\n   * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\n   * @api\n   */\n  rotate(angle, anchor) {\n    abstract();\n  }\n\n  /**\n   * Scale the geometry (with an optional origin).  This modifies the geometry\n   * coordinates in place.\n   * @abstract\n   * @param {number} sx The scaling factor in the x-direction.\n   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).\n   * @param {import(\"../coordinate.js\").Coordinate} [anchor] The scale origin (defaults to the center\n   *     of the geometry extent).\n   * @api\n   */\n  scale(sx, sy, anchor) {\n    abstract();\n  }\n\n  /**\n   * Create a simplified version of this geometry.  For linestrings, this uses\n   * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)\n   * algorithm.  For polygons, a quantization-based\n   * simplification is used to preserve topology.\n   * @param {number} tolerance The tolerance distance for simplification.\n   * @return {Geometry} A new, simplified version of the original geometry.\n   * @api\n   */\n  simplify(tolerance) {\n    return this.getSimplifiedGeometry(tolerance * tolerance);\n  }\n\n  /**\n   * Create a simplified version of this geometry using the Douglas Peucker\n   * algorithm.\n   * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.\n   * @abstract\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {Geometry} Simplified geometry.\n   */\n  getSimplifiedGeometry(squaredTolerance) {\n    return abstract();\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @abstract\n   * @return {Type} Geometry type.\n   */\n  getType() {\n    return abstract();\n  }\n\n  /**\n   * Apply a transform function to the coordinates of the geometry.\n   * The geometry is modified in place.\n   * If you do not want the geometry modified in place, first `clone()` it and\n   * then use this function on the clone.\n   * @abstract\n   * @param {import(\"../proj.js\").TransformFunction} transformFn Transform function.\n   * Called with a flat array of geometry coordinates.\n   */\n  applyTransform(transformFn) {\n    abstract();\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @abstract\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   */\n  intersectsExtent(extent) {\n    return abstract();\n  }\n\n  /**\n   * Translate the geometry.  This modifies the geometry coordinates in place.  If\n   * instead you want a new geometry, first `clone()` this geometry.\n   * @abstract\n   * @param {number} deltaX Delta X.\n   * @param {number} deltaY Delta Y.\n   * @api\n   */\n  translate(deltaX, deltaY) {\n    abstract();\n  }\n\n  /**\n   * Transform each coordinate of the geometry from one coordinate reference\n   * system to another. The geometry is modified in place.\n   * For example, a line will be transformed to a line and a circle to a circle.\n   * If you do not want the geometry modified in place, first `clone()` it and\n   * then use this function on the clone.\n   *\n   * @param {import(\"../proj.js\").ProjectionLike} source The current projection.  Can be a\n   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n   * @param {import(\"../proj.js\").ProjectionLike} destination The desired projection.  Can be a\n   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n   * @return {Geometry} This geometry.  Note that original geometry is\n   *     modified in place.\n   * @api\n   */\n  transform(source, destination) {\n    /** @type {import(\"../proj/Projection.js\").default} */\n    const sourceProj = getProjection(source);\n    const transformFn =\n      sourceProj.getUnits() == 'tile-pixels'\n        ? function (inCoordinates, outCoordinates, stride) {\n            const pixelExtent = sourceProj.getExtent();\n            const projectedExtent = sourceProj.getWorldExtent();\n            const scale = getHeight(projectedExtent) / getHeight(pixelExtent);\n            composeTransform(\n              tmpTransform,\n              projectedExtent[0],\n              projectedExtent[3],\n              scale,\n              -scale,\n              0,\n              0,\n              0\n            );\n            transform2D(\n              inCoordinates,\n              0,\n              inCoordinates.length,\n              stride,\n              tmpTransform,\n              outCoordinates\n            );\n            return getTransform(sourceProj, destination)(\n              inCoordinates,\n              outCoordinates,\n              stride\n            );\n          }\n        : getTransform(sourceProj, destination);\n    this.applyTransform(transformFn);\n    return this;\n  }\n}\n\nexport default Geometry;\n","/**\n * @module ol/geom/LinearRing\n */\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {assignClosestPoint, maxSquaredDelta} from './flat/closest.js';\nimport {closestSquaredDistanceXY} from '../extent.js';\nimport {deflateCoordinates} from './flat/deflate.js';\nimport {douglasPeucker} from './flat/simplify.js';\nimport {inflateCoordinates} from './flat/inflate.js';\nimport {linearRing as linearRingArea} from './flat/area.js';\n\n/**\n * @classdesc\n * Linear ring geometry. Only used as part of polygon; cannot be rendered\n * on its own.\n *\n * @api\n */\nclass LinearRing extends SimpleGeometry {\n  /**\n   * @param {Array<import(\"../coordinate.js\").Coordinate>|Array<number>} coordinates Coordinates.\n   *     For internal use, flat coordinates in combination with `layout` are also accepted.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   */\n  constructor(coordinates, layout) {\n    super();\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n\n    if (layout !== undefined && !Array.isArray(coordinates[0])) {\n      this.setFlatCoordinates(\n        layout,\n        /** @type {Array<number>} */ (coordinates)\n      );\n    } else {\n      this.setCoordinates(\n        /** @type {Array<import(\"../coordinate.js\").Coordinate>} */ (\n          coordinates\n        ),\n        layout\n      );\n    }\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!LinearRing} Clone.\n   * @api\n   */\n  clone() {\n    return new LinearRing(this.flatCoordinates.slice(), this.layout);\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(\n        maxSquaredDelta(\n          this.flatCoordinates,\n          0,\n          this.flatCoordinates.length,\n          this.stride,\n          0\n        )\n      );\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestPoint(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      this.maxDelta_,\n      true,\n      x,\n      y,\n      closestPoint,\n      minSquaredDistance\n    );\n  }\n\n  /**\n   * Return the area of the linear ring on projected plane.\n   * @return {number} Area (on projected plane).\n   * @api\n   */\n  getArea() {\n    return linearRingArea(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride\n    );\n  }\n\n  /**\n   * Return the coordinates of the linear ring.\n   * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates.\n   * @api\n   */\n  getCoordinates() {\n    return inflateCoordinates(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride\n    );\n  }\n\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {LinearRing} Simplified LinearRing.\n   * @protected\n   */\n  getSimplifiedGeometryInternal(squaredTolerance) {\n    const simplifiedFlatCoordinates = [];\n    simplifiedFlatCoordinates.length = douglasPeucker(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      squaredTolerance,\n      simplifiedFlatCoordinates,\n      0\n    );\n    return new LinearRing(simplifiedFlatCoordinates, 'XY');\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   */\n  getType() {\n    return 'LinearRing';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   */\n  intersectsExtent(extent) {\n    return false;\n  }\n\n  /**\n   * Set the coordinates of the linear ring.\n   * @param {!Array<import(\"../coordinate.js\").Coordinate>} coordinates Coordinates.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @api\n   */\n  setCoordinates(coordinates, layout) {\n    this.setLayout(layout, coordinates, 1);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    this.flatCoordinates.length = deflateCoordinates(\n      this.flatCoordinates,\n      0,\n      coordinates,\n      this.stride\n    );\n    this.changed();\n  }\n}\n\nexport default LinearRing;\n","/**\n * @module ol/geom/Point\n */\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {containsXY, createOrUpdateFromCoordinate} from '../extent.js';\nimport {deflateCoordinate} from './flat/deflate.js';\nimport {squaredDistance as squaredDx} from '../math.js';\n\n/**\n * @classdesc\n * Point geometry.\n *\n * @api\n */\nclass Point extends SimpleGeometry {\n  /**\n   * @param {import(\"../coordinate.js\").Coordinate} coordinates Coordinates.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   */\n  constructor(coordinates, layout) {\n    super();\n    this.setCoordinates(coordinates, layout);\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!Point} Clone.\n   * @api\n   */\n  clone() {\n    const point = new Point(this.flatCoordinates.slice(), this.layout);\n    point.applyProperties(this);\n    return point;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    const flatCoordinates = this.flatCoordinates;\n    const squaredDistance = squaredDx(\n      x,\n      y,\n      flatCoordinates[0],\n      flatCoordinates[1]\n    );\n    if (squaredDistance < minSquaredDistance) {\n      const stride = this.stride;\n      for (let i = 0; i < stride; ++i) {\n        closestPoint[i] = flatCoordinates[i];\n      }\n      closestPoint.length = stride;\n      return squaredDistance;\n    }\n    return minSquaredDistance;\n  }\n\n  /**\n   * Return the coordinate of the point.\n   * @return {import(\"../coordinate.js\").Coordinate} Coordinates.\n   * @api\n   */\n  getCoordinates() {\n    return !this.flatCoordinates ? [] : this.flatCoordinates.slice();\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @protected\n   * @return {import(\"../extent.js\").Extent} extent Extent.\n   */\n  computeExtent(extent) {\n    return createOrUpdateFromCoordinate(this.flatCoordinates, extent);\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   */\n  getType() {\n    return 'Point';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   */\n  intersectsExtent(extent) {\n    return containsXY(extent, this.flatCoordinates[0], this.flatCoordinates[1]);\n  }\n\n  /**\n   * @param {!Array<*>} coordinates Coordinates.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @api\n   */\n  setCoordinates(coordinates, layout) {\n    this.setLayout(layout, coordinates, 0);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    this.flatCoordinates.length = deflateCoordinate(\n      this.flatCoordinates,\n      0,\n      coordinates,\n      this.stride\n    );\n    this.changed();\n  }\n}\n\nexport default Point;\n","/**\n * @module ol/geom/Polygon\n */\nimport LinearRing from './LinearRing.js';\nimport Point from './Point.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {arrayMaxSquaredDelta, assignClosestArrayPoint} from './flat/closest.js';\nimport {closestSquaredDistanceXY, getCenter} from '../extent.js';\nimport {deflateCoordinatesArray} from './flat/deflate.js';\nimport {extend} from '../array.js';\nimport {getInteriorPointOfArray} from './flat/interiorpoint.js';\nimport {inflateCoordinatesArray} from './flat/inflate.js';\nimport {intersectsLinearRingArray} from './flat/intersectsextent.js';\nimport {linearRingsAreOriented, orientLinearRings} from './flat/orient.js';\nimport {linearRings as linearRingsArea} from './flat/area.js';\nimport {linearRingsContainsXY} from './flat/contains.js';\nimport {modulo} from '../math.js';\nimport {quantizeArray} from './flat/simplify.js';\nimport {offset as sphereOffset} from '../sphere.js';\n\n/**\n * @classdesc\n * Polygon geometry.\n *\n * @api\n */\nclass Polygon extends SimpleGeometry {\n  /**\n   * @param {!Array<Array<import(\"../coordinate.js\").Coordinate>>|!Array<number>} coordinates\n   *     Array of linear rings that define the polygon. The first linear ring of the\n   *     array defines the outer-boundary or surface of the polygon. Each subsequent\n   *     linear ring defines a hole in the surface of the polygon. A linear ring is\n   *     an array of vertices' coordinates where the first coordinate and the last are\n   *     equivalent. (For internal use, flat coordinates in combination with\n   *     `layout` and `ends` are also accepted.)\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @param {Array<number>} [ends] Ends (for internal use with flat coordinates).\n   */\n  constructor(coordinates, layout, ends) {\n    super();\n\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    this.ends_ = [];\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.flatInteriorPointRevision_ = -1;\n\n    /**\n     * @private\n     * @type {import(\"../coordinate.js\").Coordinate}\n     */\n    this.flatInteriorPoint_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.orientedRevision_ = -1;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.orientedFlatCoordinates_ = null;\n\n    if (layout !== undefined && ends) {\n      this.setFlatCoordinates(\n        layout,\n        /** @type {Array<number>} */ (coordinates)\n      );\n      this.ends_ = ends;\n    } else {\n      this.setCoordinates(\n        /** @type {Array<Array<import(\"../coordinate.js\").Coordinate>>} */ (\n          coordinates\n        ),\n        layout\n      );\n    }\n  }\n\n  /**\n   * Append the passed linear ring to this polygon.\n   * @param {LinearRing} linearRing Linear ring.\n   * @api\n   */\n  appendLinearRing(linearRing) {\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = linearRing.getFlatCoordinates().slice();\n    } else {\n      extend(this.flatCoordinates, linearRing.getFlatCoordinates());\n    }\n    this.ends_.push(this.flatCoordinates.length);\n    this.changed();\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!Polygon} Clone.\n   * @api\n   */\n  clone() {\n    const polygon = new Polygon(\n      this.flatCoordinates.slice(),\n      this.layout,\n      this.ends_.slice()\n    );\n    polygon.applyProperties(this);\n    return polygon;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(\n        arrayMaxSquaredDelta(\n          this.flatCoordinates,\n          0,\n          this.ends_,\n          this.stride,\n          0\n        )\n      );\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestArrayPoint(\n      this.flatCoordinates,\n      0,\n      this.ends_,\n      this.stride,\n      this.maxDelta_,\n      true,\n      x,\n      y,\n      closestPoint,\n      minSquaredDistance\n    );\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @return {boolean} Contains (x, y).\n   */\n  containsXY(x, y) {\n    return linearRingsContainsXY(\n      this.getOrientedFlatCoordinates(),\n      0,\n      this.ends_,\n      this.stride,\n      x,\n      y\n    );\n  }\n\n  /**\n   * Return the area of the polygon on projected plane.\n   * @return {number} Area (on projected plane).\n   * @api\n   */\n  getArea() {\n    return linearRingsArea(\n      this.getOrientedFlatCoordinates(),\n      0,\n      this.ends_,\n      this.stride\n    );\n  }\n\n  /**\n   * Get the coordinate array for this geometry.  This array has the structure\n   * of a GeoJSON coordinate array for polygons.\n   *\n   * @param {boolean} [right] Orient coordinates according to the right-hand\n   *     rule (counter-clockwise for exterior and clockwise for interior rings).\n   *     If `false`, coordinates will be oriented according to the left-hand rule\n   *     (clockwise for exterior and counter-clockwise for interior rings).\n   *     By default, coordinate orientation will depend on how the geometry was\n   *     constructed.\n   * @return {Array<Array<import(\"../coordinate.js\").Coordinate>>} Coordinates.\n   * @api\n   */\n  getCoordinates(right) {\n    let flatCoordinates;\n    if (right !== undefined) {\n      flatCoordinates = this.getOrientedFlatCoordinates().slice();\n      orientLinearRings(flatCoordinates, 0, this.ends_, this.stride, right);\n    } else {\n      flatCoordinates = this.flatCoordinates;\n    }\n\n    return inflateCoordinatesArray(flatCoordinates, 0, this.ends_, this.stride);\n  }\n\n  /**\n   * @return {Array<number>} Ends.\n   */\n  getEnds() {\n    return this.ends_;\n  }\n\n  /**\n   * @return {Array<number>} Interior point.\n   */\n  getFlatInteriorPoint() {\n    if (this.flatInteriorPointRevision_ != this.getRevision()) {\n      const flatCenter = getCenter(this.getExtent());\n      this.flatInteriorPoint_ = getInteriorPointOfArray(\n        this.getOrientedFlatCoordinates(),\n        0,\n        this.ends_,\n        this.stride,\n        flatCenter,\n        0\n      );\n      this.flatInteriorPointRevision_ = this.getRevision();\n    }\n    return this.flatInteriorPoint_;\n  }\n\n  /**\n   * Return an interior point of the polygon.\n   * @return {Point} Interior point as XYM coordinate, where M is the\n   * length of the horizontal intersection that the point belongs to.\n   * @api\n   */\n  getInteriorPoint() {\n    return new Point(this.getFlatInteriorPoint(), 'XYM');\n  }\n\n  /**\n   * Return the number of rings of the polygon,  this includes the exterior\n   * ring and any interior rings.\n   *\n   * @return {number} Number of rings.\n   * @api\n   */\n  getLinearRingCount() {\n    return this.ends_.length;\n  }\n\n  /**\n   * Return the Nth linear ring of the polygon geometry. Return `null` if the\n   * given index is out of range.\n   * The exterior linear ring is available at index `0` and the interior rings\n   * at index `1` and beyond.\n   *\n   * @param {number} index Index.\n   * @return {LinearRing|null} Linear ring.\n   * @api\n   */\n  getLinearRing(index) {\n    if (index < 0 || this.ends_.length <= index) {\n      return null;\n    }\n    return new LinearRing(\n      this.flatCoordinates.slice(\n        index === 0 ? 0 : this.ends_[index - 1],\n        this.ends_[index]\n      ),\n      this.layout\n    );\n  }\n\n  /**\n   * Return the linear rings of the polygon.\n   * @return {Array<LinearRing>} Linear rings.\n   * @api\n   */\n  getLinearRings() {\n    const layout = this.layout;\n    const flatCoordinates = this.flatCoordinates;\n    const ends = this.ends_;\n    const linearRings = [];\n    let offset = 0;\n    for (let i = 0, ii = ends.length; i < ii; ++i) {\n      const end = ends[i];\n      const linearRing = new LinearRing(\n        flatCoordinates.slice(offset, end),\n        layout\n      );\n      linearRings.push(linearRing);\n      offset = end;\n    }\n    return linearRings;\n  }\n\n  /**\n   * @return {Array<number>} Oriented flat coordinates.\n   */\n  getOrientedFlatCoordinates() {\n    if (this.orientedRevision_ != this.getRevision()) {\n      const flatCoordinates = this.flatCoordinates;\n      if (linearRingsAreOriented(flatCoordinates, 0, this.ends_, this.stride)) {\n        this.orientedFlatCoordinates_ = flatCoordinates;\n      } else {\n        this.orientedFlatCoordinates_ = flatCoordinates.slice();\n        this.orientedFlatCoordinates_.length = orientLinearRings(\n          this.orientedFlatCoordinates_,\n          0,\n          this.ends_,\n          this.stride\n        );\n      }\n      this.orientedRevision_ = this.getRevision();\n    }\n    return this.orientedFlatCoordinates_;\n  }\n\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {Polygon} Simplified Polygon.\n   * @protected\n   */\n  getSimplifiedGeometryInternal(squaredTolerance) {\n    const simplifiedFlatCoordinates = [];\n    const simplifiedEnds = [];\n    simplifiedFlatCoordinates.length = quantizeArray(\n      this.flatCoordinates,\n      0,\n      this.ends_,\n      this.stride,\n      Math.sqrt(squaredTolerance),\n      simplifiedFlatCoordinates,\n      0,\n      simplifiedEnds\n    );\n    return new Polygon(simplifiedFlatCoordinates, 'XY', simplifiedEnds);\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   */\n  getType() {\n    return 'Polygon';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   */\n  intersectsExtent(extent) {\n    return intersectsLinearRingArray(\n      this.getOrientedFlatCoordinates(),\n      0,\n      this.ends_,\n      this.stride,\n      extent\n    );\n  }\n\n  /**\n   * Set the coordinates of the polygon.\n   * @param {!Array<Array<import(\"../coordinate.js\").Coordinate>>} coordinates Coordinates.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @api\n   */\n  setCoordinates(coordinates, layout) {\n    this.setLayout(layout, coordinates, 2);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    const ends = deflateCoordinatesArray(\n      this.flatCoordinates,\n      0,\n      coordinates,\n      this.stride,\n      this.ends_\n    );\n    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];\n    this.changed();\n  }\n}\n\nexport default Polygon;\n\n/**\n * Create an approximation of a circle on the surface of a sphere.\n * @param {import(\"../coordinate.js\").Coordinate} center Center (`[lon, lat]` in degrees).\n * @param {number} radius The great-circle distance from the center to\n *     the polygon vertices in meters.\n * @param {number} [n] Optional number of vertices for the resulting\n *     polygon. Default is `32`.\n * @param {number} [sphereRadius] Optional radius for the sphere (defaults to\n *     the Earth's mean radius using the WGS84 ellipsoid).\n * @return {Polygon} The \"circular\" polygon.\n * @api\n */\nexport function circular(center, radius, n, sphereRadius) {\n  n = n ? n : 32;\n  /** @type {Array<number>} */\n  const flatCoordinates = [];\n  for (let i = 0; i < n; ++i) {\n    extend(\n      flatCoordinates,\n      sphereOffset(center, radius, (2 * Math.PI * i) / n, sphereRadius)\n    );\n  }\n  flatCoordinates.push(flatCoordinates[0], flatCoordinates[1]);\n  return new Polygon(flatCoordinates, 'XY', [flatCoordinates.length]);\n}\n\n/**\n * Create a polygon from an extent. The layout used is `XY`.\n * @param {import(\"../extent.js\").Extent} extent The extent.\n * @return {Polygon} The polygon.\n * @api\n */\nexport function fromExtent(extent) {\n  const minX = extent[0];\n  const minY = extent[1];\n  const maxX = extent[2];\n  const maxY = extent[3];\n  const flatCoordinates = [\n    minX,\n    minY,\n    minX,\n    maxY,\n    maxX,\n    maxY,\n    maxX,\n    minY,\n    minX,\n    minY,\n  ];\n  return new Polygon(flatCoordinates, 'XY', [flatCoordinates.length]);\n}\n\n/**\n * Create a regular polygon from a circle.\n * @param {import(\"./Circle.js\").default} circle Circle geometry.\n * @param {number} [sides] Number of sides of the polygon. Default is 32.\n * @param {number} [angle] Start angle for the first vertex of the polygon in\n *     counter-clockwise radians. 0 means East. Default is 0.\n * @return {Polygon} Polygon geometry.\n * @api\n */\nexport function fromCircle(circle, sides, angle) {\n  sides = sides ? sides : 32;\n  const stride = circle.getStride();\n  const layout = circle.getLayout();\n  const center = circle.getCenter();\n  const arrayLength = stride * (sides + 1);\n  const flatCoordinates = new Array(arrayLength);\n  for (let i = 0; i < arrayLength; i += stride) {\n    flatCoordinates[i] = 0;\n    flatCoordinates[i + 1] = 0;\n    for (let j = 2; j < stride; j++) {\n      flatCoordinates[i + j] = center[j];\n    }\n  }\n  const ends = [flatCoordinates.length];\n  const polygon = new Polygon(flatCoordinates, layout, ends);\n  makeRegular(polygon, center, circle.getRadius(), angle);\n  return polygon;\n}\n\n/**\n * Modify the coordinates of a polygon to make it a regular polygon.\n * @param {Polygon} polygon Polygon geometry.\n * @param {import(\"../coordinate.js\").Coordinate} center Center of the regular polygon.\n * @param {number} radius Radius of the regular polygon.\n * @param {number} [angle] Start angle for the first vertex of the polygon in\n *     counter-clockwise radians. 0 means East. Default is 0.\n */\nexport function makeRegular(polygon, center, radius, angle) {\n  const flatCoordinates = polygon.getFlatCoordinates();\n  const stride = polygon.getStride();\n  const sides = flatCoordinates.length / stride - 1;\n  const startAngle = angle ? angle : 0;\n  for (let i = 0; i <= sides; ++i) {\n    const offset = i * stride;\n    const angle = startAngle + (modulo(i, sides) * 2 * Math.PI) / sides;\n    flatCoordinates[offset] = center[0] + radius * Math.cos(angle);\n    flatCoordinates[offset + 1] = center[1] + radius * Math.sin(angle);\n  }\n  polygon.changed();\n}\n","/**\n * @module ol/geom/SimpleGeometry\n */\nimport Geometry from './Geometry.js';\nimport {abstract} from '../util.js';\nimport {createOrUpdateFromFlatCoordinates, getCenter} from '../extent.js';\nimport {rotate, scale, transform2D, translate} from './flat/transform.js';\n\n/**\n * @classdesc\n * Abstract base class; only used for creating subclasses; do not instantiate\n * in apps, as cannot be rendered.\n *\n * @abstract\n * @api\n */\nclass SimpleGeometry extends Geometry {\n  constructor() {\n    super();\n\n    /**\n     * @protected\n     * @type {import(\"./Geometry.js\").GeometryLayout}\n     */\n    this.layout = 'XY';\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.stride = 2;\n\n    /**\n     * @protected\n     * @type {Array<number>}\n     */\n    this.flatCoordinates = null;\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @protected\n   * @return {import(\"../extent.js\").Extent} extent Extent.\n   */\n  computeExtent(extent) {\n    return createOrUpdateFromFlatCoordinates(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      extent\n    );\n  }\n\n  /**\n   * @abstract\n   * @return {Array<*> | null} Coordinates.\n   */\n  getCoordinates() {\n    return abstract();\n  }\n\n  /**\n   * Return the first coordinate of the geometry.\n   * @return {import(\"../coordinate.js\").Coordinate} First coordinate.\n   * @api\n   */\n  getFirstCoordinate() {\n    return this.flatCoordinates.slice(0, this.stride);\n  }\n\n  /**\n   * @return {Array<number>} Flat coordinates.\n   */\n  getFlatCoordinates() {\n    return this.flatCoordinates;\n  }\n\n  /**\n   * Return the last coordinate of the geometry.\n   * @return {import(\"../coordinate.js\").Coordinate} Last point.\n   * @api\n   */\n  getLastCoordinate() {\n    return this.flatCoordinates.slice(\n      this.flatCoordinates.length - this.stride\n    );\n  }\n\n  /**\n   * Return the {@link import(\"./Geometry.js\").GeometryLayout layout} of the geometry.\n   * @return {import(\"./Geometry.js\").GeometryLayout} Layout.\n   * @api\n   */\n  getLayout() {\n    return this.layout;\n  }\n\n  /**\n   * Create a simplified version of this geometry using the Douglas Peucker algorithm.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {SimpleGeometry} Simplified geometry.\n   */\n  getSimplifiedGeometry(squaredTolerance) {\n    if (this.simplifiedGeometryRevision !== this.getRevision()) {\n      this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n      this.simplifiedGeometryRevision = this.getRevision();\n    }\n    // If squaredTolerance is negative or if we know that simplification will not\n    // have any effect then just return this.\n    if (\n      squaredTolerance < 0 ||\n      (this.simplifiedGeometryMaxMinSquaredTolerance !== 0 &&\n        squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance)\n    ) {\n      return this;\n    }\n\n    const simplifiedGeometry =\n      this.getSimplifiedGeometryInternal(squaredTolerance);\n    const simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();\n    if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {\n      return simplifiedGeometry;\n    }\n    // Simplification did not actually remove any coordinates.  We now know\n    // that any calls to getSimplifiedGeometry with a squaredTolerance less\n    // than or equal to the current squaredTolerance will also not have any\n    // effect.  This allows us to short circuit simplification (saving CPU\n    // cycles) and prevents the cache of simplified geometries from filling\n    // up with useless identical copies of this geometry (saving memory).\n    this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;\n    return this;\n  }\n\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {SimpleGeometry} Simplified geometry.\n   * @protected\n   */\n  getSimplifiedGeometryInternal(squaredTolerance) {\n    return this;\n  }\n\n  /**\n   * @return {number} Stride.\n   */\n  getStride() {\n    return this.stride;\n  }\n\n  /**\n   * @param {import(\"./Geometry.js\").GeometryLayout} layout Layout.\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   */\n  setFlatCoordinates(layout, flatCoordinates) {\n    this.stride = getStrideForLayout(layout);\n    this.layout = layout;\n    this.flatCoordinates = flatCoordinates;\n  }\n\n  /**\n   * @abstract\n   * @param {!Array<*>} coordinates Coordinates.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   */\n  setCoordinates(coordinates, layout) {\n    abstract();\n  }\n\n  /**\n   * @param {import(\"./Geometry.js\").GeometryLayout|undefined} layout Layout.\n   * @param {Array<*>} coordinates Coordinates.\n   * @param {number} nesting Nesting.\n   * @protected\n   */\n  setLayout(layout, coordinates, nesting) {\n    /** @type {number} */\n    let stride;\n    if (layout) {\n      stride = getStrideForLayout(layout);\n    } else {\n      for (let i = 0; i < nesting; ++i) {\n        if (coordinates.length === 0) {\n          this.layout = 'XY';\n          this.stride = 2;\n          return;\n        }\n        coordinates = /** @type {Array} */ (coordinates[0]);\n      }\n      stride = coordinates.length;\n      layout = getLayoutForStride(stride);\n    }\n    this.layout = layout;\n    this.stride = stride;\n  }\n\n  /**\n   * Apply a transform function to the coordinates of the geometry.\n   * The geometry is modified in place.\n   * If you do not want the geometry modified in place, first `clone()` it and\n   * then use this function on the clone.\n   * @param {import(\"../proj.js\").TransformFunction} transformFn Transform function.\n   * Called with a flat array of geometry coordinates.\n   * @api\n   */\n  applyTransform(transformFn) {\n    if (this.flatCoordinates) {\n      transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);\n      this.changed();\n    }\n  }\n\n  /**\n   * Rotate the geometry around a given coordinate. This modifies the geometry\n   * coordinates in place.\n   * @param {number} angle Rotation angle in counter-clockwise radians.\n   * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\n   * @api\n   */\n  rotate(angle, anchor) {\n    const flatCoordinates = this.getFlatCoordinates();\n    if (flatCoordinates) {\n      const stride = this.getStride();\n      rotate(\n        flatCoordinates,\n        0,\n        flatCoordinates.length,\n        stride,\n        angle,\n        anchor,\n        flatCoordinates\n      );\n      this.changed();\n    }\n  }\n\n  /**\n   * Scale the geometry (with an optional origin).  This modifies the geometry\n   * coordinates in place.\n   * @param {number} sx The scaling factor in the x-direction.\n   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).\n   * @param {import(\"../coordinate.js\").Coordinate} [anchor] The scale origin (defaults to the center\n   *     of the geometry extent).\n   * @api\n   */\n  scale(sx, sy, anchor) {\n    if (sy === undefined) {\n      sy = sx;\n    }\n    if (!anchor) {\n      anchor = getCenter(this.getExtent());\n    }\n    const flatCoordinates = this.getFlatCoordinates();\n    if (flatCoordinates) {\n      const stride = this.getStride();\n      scale(\n        flatCoordinates,\n        0,\n        flatCoordinates.length,\n        stride,\n        sx,\n        sy,\n        anchor,\n        flatCoordinates\n      );\n      this.changed();\n    }\n  }\n\n  /**\n   * Translate the geometry.  This modifies the geometry coordinates in place.  If\n   * instead you want a new geometry, first `clone()` this geometry.\n   * @param {number} deltaX Delta X.\n   * @param {number} deltaY Delta Y.\n   * @api\n   */\n  translate(deltaX, deltaY) {\n    const flatCoordinates = this.getFlatCoordinates();\n    if (flatCoordinates) {\n      const stride = this.getStride();\n      translate(\n        flatCoordinates,\n        0,\n        flatCoordinates.length,\n        stride,\n        deltaX,\n        deltaY,\n        flatCoordinates\n      );\n      this.changed();\n    }\n  }\n}\n\n/**\n * @param {number} stride Stride.\n * @return {import(\"./Geometry.js\").GeometryLayout} layout Layout.\n */\nfunction getLayoutForStride(stride) {\n  let layout;\n  if (stride == 2) {\n    layout = 'XY';\n  } else if (stride == 3) {\n    layout = 'XYZ';\n  } else if (stride == 4) {\n    layout = 'XYZM';\n  }\n  return /** @type {import(\"./Geometry.js\").GeometryLayout} */ (layout);\n}\n\n/**\n * @param {import(\"./Geometry.js\").GeometryLayout} layout Layout.\n * @return {number} Stride.\n */\nexport function getStrideForLayout(layout) {\n  let stride;\n  if (layout == 'XY') {\n    stride = 2;\n  } else if (layout == 'XYZ' || layout == 'XYM') {\n    stride = 3;\n  } else if (layout == 'XYZM') {\n    stride = 4;\n  }\n  return /** @type {number} */ (stride);\n}\n\n/**\n * @param {SimpleGeometry} simpleGeometry Simple geometry.\n * @param {import(\"../transform.js\").Transform} transform Transform.\n * @param {Array<number>} [dest] Destination.\n * @return {Array<number>} Transformed flat coordinates.\n */\nexport function transformGeom2D(simpleGeometry, transform, dest) {\n  const flatCoordinates = simpleGeometry.getFlatCoordinates();\n  if (!flatCoordinates) {\n    return null;\n  }\n  const stride = simpleGeometry.getStride();\n  return transform2D(\n    flatCoordinates,\n    0,\n    flatCoordinates.length,\n    stride,\n    transform,\n    dest\n  );\n}\n\nexport default SimpleGeometry;\n","/**\n * @module ol/geom/flat/area\n */\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {number} Area.\n */\nexport function linearRing(flatCoordinates, offset, end, stride) {\n  let twiceArea = 0;\n  let x1 = flatCoordinates[end - stride];\n  let y1 = flatCoordinates[end - stride + 1];\n  for (; offset < end; offset += stride) {\n    const x2 = flatCoordinates[offset];\n    const y2 = flatCoordinates[offset + 1];\n    twiceArea += y1 * x2 - x1 * y2;\n    x1 = x2;\n    y1 = y2;\n  }\n  return twiceArea / 2;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @return {number} Area.\n */\nexport function linearRings(flatCoordinates, offset, ends, stride) {\n  let area = 0;\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    area += linearRing(flatCoordinates, offset, end, stride);\n    offset = end;\n  }\n  return area;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @return {number} Area.\n */\nexport function linearRingss(flatCoordinates, offset, endss, stride) {\n  let area = 0;\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    area += linearRings(flatCoordinates, offset, ends, stride);\n    offset = ends[ends.length - 1];\n  }\n  return area;\n}\n","/**\n * @module ol/geom/flat/closest\n */\nimport {lerp, squaredDistance as squaredDx} from '../../math.js';\n\n/**\n * Returns the point on the 2D line segment flatCoordinates[offset1] to\n * flatCoordinates[offset2] that is closest to the point (x, y).  Extra\n * dimensions are linearly interpolated.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset1 Offset 1.\n * @param {number} offset2 Offset 2.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n */\nfunction assignClosest(\n  flatCoordinates,\n  offset1,\n  offset2,\n  stride,\n  x,\n  y,\n  closestPoint\n) {\n  const x1 = flatCoordinates[offset1];\n  const y1 = flatCoordinates[offset1 + 1];\n  const dx = flatCoordinates[offset2] - x1;\n  const dy = flatCoordinates[offset2 + 1] - y1;\n  let offset;\n  if (dx === 0 && dy === 0) {\n    offset = offset1;\n  } else {\n    const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\n    if (t > 1) {\n      offset = offset2;\n    } else if (t > 0) {\n      for (let i = 0; i < stride; ++i) {\n        closestPoint[i] = lerp(\n          flatCoordinates[offset1 + i],\n          flatCoordinates[offset2 + i],\n          t\n        );\n      }\n      closestPoint.length = stride;\n      return;\n    } else {\n      offset = offset1;\n    }\n  }\n  for (let i = 0; i < stride; ++i) {\n    closestPoint[i] = flatCoordinates[offset + i];\n  }\n  closestPoint.length = stride;\n}\n\n/**\n * Return the squared of the largest distance between any pair of consecutive\n * coordinates.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\nexport function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {\n  let x1 = flatCoordinates[offset];\n  let y1 = flatCoordinates[offset + 1];\n  for (offset += stride; offset < end; offset += stride) {\n    const x2 = flatCoordinates[offset];\n    const y2 = flatCoordinates[offset + 1];\n    const squaredDelta = squaredDx(x1, y1, x2, y2);\n    if (squaredDelta > max) {\n      max = squaredDelta;\n    }\n    x1 = x2;\n    y1 = y2;\n  }\n  return max;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\nexport function arrayMaxSquaredDelta(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  max\n) {\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    max = maxSquaredDelta(flatCoordinates, offset, end, stride, max);\n    offset = end;\n  }\n  return max;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\nexport function multiArrayMaxSquaredDelta(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  max\n) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    max = arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max);\n    offset = ends[ends.length - 1];\n  }\n  return max;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>} [tmpPoint] Temporary point object.\n * @return {number} Minimum squared distance.\n */\nexport function assignClosestPoint(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  maxDelta,\n  isRing,\n  x,\n  y,\n  closestPoint,\n  minSquaredDistance,\n  tmpPoint\n) {\n  if (offset == end) {\n    return minSquaredDistance;\n  }\n  let i, squaredDistance;\n  if (maxDelta === 0) {\n    // All points are identical, so just test the first point.\n    squaredDistance = squaredDx(\n      x,\n      y,\n      flatCoordinates[offset],\n      flatCoordinates[offset + 1]\n    );\n    if (squaredDistance < minSquaredDistance) {\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = flatCoordinates[offset + i];\n      }\n      closestPoint.length = stride;\n      return squaredDistance;\n    }\n    return minSquaredDistance;\n  }\n  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];\n  let index = offset + stride;\n  while (index < end) {\n    assignClosest(\n      flatCoordinates,\n      index - stride,\n      index,\n      stride,\n      x,\n      y,\n      tmpPoint\n    );\n    squaredDistance = squaredDx(x, y, tmpPoint[0], tmpPoint[1]);\n    if (squaredDistance < minSquaredDistance) {\n      minSquaredDistance = squaredDistance;\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = tmpPoint[i];\n      }\n      closestPoint.length = stride;\n      index += stride;\n    } else {\n      // Skip ahead multiple points, because we know that all the skipped\n      // points cannot be any closer than the closest point we have found so\n      // far.  We know this because we know how close the current point is, how\n      // close the closest point we have found so far is, and the maximum\n      // distance between consecutive points.  For example, if we're currently\n      // at distance 10, the best we've found so far is 3, and that the maximum\n      // distance between consecutive points is 2, then we'll need to skip at\n      // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of\n      // finding a closer point.  We use Math.max(..., 1) to ensure that we\n      // always advance at least one point, to avoid an infinite loop.\n      index +=\n        stride *\n        Math.max(\n          ((Math.sqrt(squaredDistance) - Math.sqrt(minSquaredDistance)) /\n            maxDelta) |\n            0,\n          1\n        );\n    }\n  }\n  if (isRing) {\n    // Check the closing segment.\n    assignClosest(\n      flatCoordinates,\n      end - stride,\n      offset,\n      stride,\n      x,\n      y,\n      tmpPoint\n    );\n    squaredDistance = squaredDx(x, y, tmpPoint[0], tmpPoint[1]);\n    if (squaredDistance < minSquaredDistance) {\n      minSquaredDistance = squaredDistance;\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = tmpPoint[i];\n      }\n      closestPoint.length = stride;\n    }\n  }\n  return minSquaredDistance;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>} [tmpPoint] Temporary point object.\n * @return {number} Minimum squared distance.\n */\nexport function assignClosestArrayPoint(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  maxDelta,\n  isRing,\n  x,\n  y,\n  closestPoint,\n  minSquaredDistance,\n  tmpPoint\n) {\n  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    minSquaredDistance = assignClosestPoint(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      maxDelta,\n      isRing,\n      x,\n      y,\n      closestPoint,\n      minSquaredDistance,\n      tmpPoint\n    );\n    offset = end;\n  }\n  return minSquaredDistance;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>} [tmpPoint] Temporary point object.\n * @return {number} Minimum squared distance.\n */\nexport function assignClosestMultiArrayPoint(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  maxDelta,\n  isRing,\n  x,\n  y,\n  closestPoint,\n  minSquaredDistance,\n  tmpPoint\n) {\n  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    minSquaredDistance = assignClosestArrayPoint(\n      flatCoordinates,\n      offset,\n      ends,\n      stride,\n      maxDelta,\n      isRing,\n      x,\n      y,\n      closestPoint,\n      minSquaredDistance,\n      tmpPoint\n    );\n    offset = ends[ends.length - 1];\n  }\n  return minSquaredDistance;\n}\n","/**\n * @module ol/geom/flat/contains\n */\nimport {forEachCorner} from '../../extent.js';\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} Contains extent.\n */\nexport function linearRingContainsExtent(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  extent\n) {\n  const outside = forEachCorner(\n    extent,\n    /**\n     * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @return {boolean} Contains (x, y).\n     */\n    function (coordinate) {\n      return !linearRingContainsXY(\n        flatCoordinates,\n        offset,\n        end,\n        stride,\n        coordinate[0],\n        coordinate[1]\n      );\n    }\n  );\n  return !outside;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\nexport function linearRingContainsXY(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  x,\n  y\n) {\n  // https://geomalgorithms.com/a03-_inclusion.html\n  // Copyright 2000 softSurfer, 2012 Dan Sunday\n  // This code may be freely used and modified for any purpose\n  // providing that this copyright notice is included with it.\n  // SoftSurfer makes no warranty for this code, and cannot be held\n  // liable for any real or imagined damage resulting from its use.\n  // Users of this code must verify correctness for their application.\n  let wn = 0;\n  let x1 = flatCoordinates[end - stride];\n  let y1 = flatCoordinates[end - stride + 1];\n  for (; offset < end; offset += stride) {\n    const x2 = flatCoordinates[offset];\n    const y2 = flatCoordinates[offset + 1];\n    if (y1 <= y) {\n      if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) {\n        wn++;\n      }\n    } else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) {\n      wn--;\n    }\n    x1 = x2;\n    y1 = y2;\n  }\n  return wn !== 0;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\nexport function linearRingsContainsXY(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  x,\n  y\n) {\n  if (ends.length === 0) {\n    return false;\n  }\n  if (!linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) {\n    return false;\n  }\n  for (let i = 1, ii = ends.length; i < ii; ++i) {\n    if (\n      linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\nexport function linearRingssContainsXY(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  x,\n  y\n) {\n  if (endss.length === 0) {\n    return false;\n  }\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {\n      return true;\n    }\n    offset = ends[ends.length - 1];\n  }\n  return false;\n}\n","/**\n * @module ol/geom/flat/deflate\n */\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n * @param {number} stride Stride.\n * @return {number} offset Offset.\n */\nexport function deflateCoordinate(flatCoordinates, offset, coordinate, stride) {\n  for (let i = 0, ii = coordinate.length; i < ii; ++i) {\n    flatCoordinates[offset++] = coordinate[i];\n  }\n  return offset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<import(\"../../coordinate.js\").Coordinate>} coordinates Coordinates.\n * @param {number} stride Stride.\n * @return {number} offset Offset.\n */\nexport function deflateCoordinates(\n  flatCoordinates,\n  offset,\n  coordinates,\n  stride\n) {\n  for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n    const coordinate = coordinates[i];\n    for (let j = 0; j < stride; ++j) {\n      flatCoordinates[offset++] = coordinate[j];\n    }\n  }\n  return offset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<import(\"../../coordinate.js\").Coordinate>>} coordinatess Coordinatess.\n * @param {number} stride Stride.\n * @param {Array<number>} [ends] Ends.\n * @return {Array<number>} Ends.\n */\nexport function deflateCoordinatesArray(\n  flatCoordinates,\n  offset,\n  coordinatess,\n  stride,\n  ends\n) {\n  ends = ends ? ends : [];\n  let i = 0;\n  for (let j = 0, jj = coordinatess.length; j < jj; ++j) {\n    const end = deflateCoordinates(\n      flatCoordinates,\n      offset,\n      coordinatess[j],\n      stride\n    );\n    ends[i++] = end;\n    offset = end;\n  }\n  ends.length = i;\n  return ends;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<Array<import(\"../../coordinate.js\").Coordinate>>>} coordinatesss Coordinatesss.\n * @param {number} stride Stride.\n * @param {Array<Array<number>>} [endss] Endss.\n * @return {Array<Array<number>>} Endss.\n */\nexport function deflateMultiCoordinatesArray(\n  flatCoordinates,\n  offset,\n  coordinatesss,\n  stride,\n  endss\n) {\n  endss = endss ? endss : [];\n  let i = 0;\n  for (let j = 0, jj = coordinatesss.length; j < jj; ++j) {\n    const ends = deflateCoordinatesArray(\n      flatCoordinates,\n      offset,\n      coordinatesss[j],\n      stride,\n      endss[i]\n    );\n    if (ends.length === 0) {\n      ends[0] = offset;\n    }\n    endss[i++] = ends;\n    offset = ends[ends.length - 1];\n  }\n  endss.length = i;\n  return endss;\n}\n","/**\n * @module ol/geom/flat/inflate\n */\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {Array<import(\"../../coordinate.js\").Coordinate>} [coordinates] Coordinates.\n * @return {Array<import(\"../../coordinate.js\").Coordinate>} Coordinates.\n */\nexport function inflateCoordinates(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  coordinates\n) {\n  coordinates = coordinates !== undefined ? coordinates : [];\n  let i = 0;\n  for (let j = offset; j < end; j += stride) {\n    coordinates[i++] = flatCoordinates.slice(j, j + stride);\n  }\n  coordinates.length = i;\n  return coordinates;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {Array<Array<import(\"../../coordinate.js\").Coordinate>>} [coordinatess] Coordinatess.\n * @return {Array<Array<import(\"../../coordinate.js\").Coordinate>>} Coordinatess.\n */\nexport function inflateCoordinatesArray(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  coordinatess\n) {\n  coordinatess = coordinatess !== undefined ? coordinatess : [];\n  let i = 0;\n  for (let j = 0, jj = ends.length; j < jj; ++j) {\n    const end = ends[j];\n    coordinatess[i++] = inflateCoordinates(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      coordinatess[i]\n    );\n    offset = end;\n  }\n  coordinatess.length = i;\n  return coordinatess;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {Array<Array<Array<import(\"../../coordinate.js\").Coordinate>>>} [coordinatesss]\n *     Coordinatesss.\n * @return {Array<Array<Array<import(\"../../coordinate.js\").Coordinate>>>} Coordinatesss.\n */\nexport function inflateMultiCoordinatesArray(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  coordinatesss\n) {\n  coordinatesss = coordinatesss !== undefined ? coordinatesss : [];\n  let i = 0;\n  for (let j = 0, jj = endss.length; j < jj; ++j) {\n    const ends = endss[j];\n    coordinatesss[i++] =\n      ends.length === 1 && ends[0] === offset\n        ? []\n        : inflateCoordinatesArray(\n            flatCoordinates,\n            offset,\n            ends,\n            stride,\n            coordinatesss[i]\n          );\n    offset = ends[ends.length - 1];\n  }\n  coordinatesss.length = i;\n  return coordinatesss;\n}\n","/**\n * @module ol/geom/flat/interiorpoint\n */\nimport {ascending} from '../../array.js';\nimport {linearRingsContainsXY} from './contains.js';\n\n/**\n * Calculates a point that is likely to lie in the interior of the linear rings.\n * Inspired by JTS's com.vividsolutions.jts.geom.Geometry#getInteriorPoint.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {Array<number>} flatCenters Flat centers.\n * @param {number} flatCentersOffset Flat center offset.\n * @param {Array<number>} [dest] Destination.\n * @return {Array<number>} Destination point as XYM coordinate, where M is the\n * length of the horizontal intersection that the point belongs to.\n */\nexport function getInteriorPointOfArray(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  flatCenters,\n  flatCentersOffset,\n  dest\n) {\n  let i, ii, x, x1, x2, y1, y2;\n  const y = flatCenters[flatCentersOffset + 1];\n  /** @type {Array<number>} */\n  const intersections = [];\n  // Calculate intersections with the horizontal line\n  for (let r = 0, rr = ends.length; r < rr; ++r) {\n    const end = ends[r];\n    x1 = flatCoordinates[end - stride];\n    y1 = flatCoordinates[end - stride + 1];\n    for (i = offset; i < end; i += stride) {\n      x2 = flatCoordinates[i];\n      y2 = flatCoordinates[i + 1];\n      if ((y <= y1 && y2 <= y) || (y1 <= y && y <= y2)) {\n        x = ((y - y1) / (y2 - y1)) * (x2 - x1) + x1;\n        intersections.push(x);\n      }\n      x1 = x2;\n      y1 = y2;\n    }\n  }\n  // Find the longest segment of the horizontal line that has its center point\n  // inside the linear ring.\n  let pointX = NaN;\n  let maxSegmentLength = -Infinity;\n  intersections.sort(ascending);\n  x1 = intersections[0];\n  for (i = 1, ii = intersections.length; i < ii; ++i) {\n    x2 = intersections[i];\n    const segmentLength = Math.abs(x2 - x1);\n    if (segmentLength > maxSegmentLength) {\n      x = (x1 + x2) / 2;\n      if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {\n        pointX = x;\n        maxSegmentLength = segmentLength;\n      }\n    }\n    x1 = x2;\n  }\n  if (isNaN(pointX)) {\n    // There is no horizontal line that has its center point inside the linear\n    // ring.  Use the center of the the linear ring's extent.\n    pointX = flatCenters[flatCentersOffset];\n  }\n  if (dest) {\n    dest.push(pointX, y, maxSegmentLength);\n    return dest;\n  }\n  return [pointX, y, maxSegmentLength];\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {Array<number>} flatCenters Flat centers.\n * @return {Array<number>} Interior points as XYM coordinates, where M is the\n * length of the horizontal intersection that the point belongs to.\n */\nexport function getInteriorPointsOfMultiArray(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  flatCenters\n) {\n  let interiorPoints = [];\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    interiorPoints = getInteriorPointOfArray(\n      flatCoordinates,\n      offset,\n      ends,\n      stride,\n      flatCenters,\n      2 * i,\n      interiorPoints\n    );\n    offset = ends[ends.length - 1];\n  }\n  return interiorPoints;\n}\n","/**\n * @module ol/geom/flat/intersectsextent\n */\nimport {\n  containsExtent,\n  createEmpty,\n  extendFlatCoordinates,\n  intersects,\n  intersectsSegment,\n} from '../../extent.js';\nimport {forEach as forEachSegment} from './segments.js';\nimport {linearRingContainsExtent, linearRingContainsXY} from './contains.js';\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLineString(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  extent\n) {\n  const coordinatesExtent = extendFlatCoordinates(\n    createEmpty(),\n    flatCoordinates,\n    offset,\n    end,\n    stride\n  );\n  if (!intersects(extent, coordinatesExtent)) {\n    return false;\n  }\n  if (containsExtent(extent, coordinatesExtent)) {\n    return true;\n  }\n  if (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2]) {\n    return true;\n  }\n  if (coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3]) {\n    return true;\n  }\n  return forEachSegment(\n    flatCoordinates,\n    offset,\n    end,\n    stride,\n    /**\n     * @param {import(\"../../coordinate.js\").Coordinate} point1 Start point.\n     * @param {import(\"../../coordinate.js\").Coordinate} point2 End point.\n     * @return {boolean} `true` if the segment and the extent intersect,\n     *     `false` otherwise.\n     */\n    function (point1, point2) {\n      return intersectsSegment(extent, point1, point2);\n    }\n  );\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLineStringArray(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  extent\n) {\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    if (\n      intersectsLineString(flatCoordinates, offset, ends[i], stride, extent)\n    ) {\n      return true;\n    }\n    offset = ends[i];\n  }\n  return false;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLinearRing(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  extent\n) {\n  if (intersectsLineString(flatCoordinates, offset, end, stride, extent)) {\n    return true;\n  }\n  if (\n    linearRingContainsXY(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      extent[0],\n      extent[1]\n    )\n  ) {\n    return true;\n  }\n  if (\n    linearRingContainsXY(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      extent[0],\n      extent[3]\n    )\n  ) {\n    return true;\n  }\n  if (\n    linearRingContainsXY(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      extent[2],\n      extent[1]\n    )\n  ) {\n    return true;\n  }\n  if (\n    linearRingContainsXY(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      extent[2],\n      extent[3]\n    )\n  ) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLinearRingArray(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  extent\n) {\n  if (!intersectsLinearRing(flatCoordinates, offset, ends[0], stride, extent)) {\n    return false;\n  }\n  if (ends.length === 1) {\n    return true;\n  }\n  for (let i = 1, ii = ends.length; i < ii; ++i) {\n    if (\n      linearRingContainsExtent(\n        flatCoordinates,\n        ends[i - 1],\n        ends[i],\n        stride,\n        extent\n      )\n    ) {\n      if (\n        !intersectsLineString(\n          flatCoordinates,\n          ends[i - 1],\n          ends[i],\n          stride,\n          extent\n        )\n      ) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLinearRingMultiArray(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  extent\n) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    if (\n      intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent)\n    ) {\n      return true;\n    }\n    offset = ends[ends.length - 1];\n  }\n  return false;\n}\n","/**\n * @module ol/geom/flat/length\n */\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {number} Length.\n */\nexport function lineStringLength(flatCoordinates, offset, end, stride) {\n  let x1 = flatCoordinates[offset];\n  let y1 = flatCoordinates[offset + 1];\n  let length = 0;\n  for (let i = offset + stride; i < end; i += stride) {\n    const x2 = flatCoordinates[i];\n    const y2 = flatCoordinates[i + 1];\n    length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n    x1 = x2;\n    y1 = y2;\n  }\n  return length;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {number} Perimeter.\n */\nexport function linearRingLength(flatCoordinates, offset, end, stride) {\n  let perimeter = lineStringLength(flatCoordinates, offset, end, stride);\n  const dx = flatCoordinates[end - stride] - flatCoordinates[offset];\n  const dy = flatCoordinates[end - stride + 1] - flatCoordinates[offset + 1];\n  perimeter += Math.sqrt(dx * dx + dy * dy);\n  return perimeter;\n}\n","/**\n * @module ol/geom/flat/reverse\n */\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n */\nexport function coordinates(flatCoordinates, offset, end, stride) {\n  while (offset < end - stride) {\n    for (let i = 0; i < stride; ++i) {\n      const tmp = flatCoordinates[offset + i];\n      flatCoordinates[offset + i] = flatCoordinates[end - stride + i];\n      flatCoordinates[end - stride + i] = tmp;\n    }\n    offset += stride;\n    end -= stride;\n  }\n}\n","/**\n * @module ol/geom/flat/orient\n */\nimport {coordinates as reverseCoordinates} from './reverse.js';\n\n/**\n * Is the linear ring oriented clockwise in a coordinate system with a bottom-left\n * coordinate origin? For a coordinate system with a top-left coordinate origin,\n * the ring's orientation is clockwise when this function returns false.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {boolean} Is clockwise.\n */\nexport function linearRingIsClockwise(flatCoordinates, offset, end, stride) {\n  // https://stackoverflow.com/q/1165647/clockwise-method#1165943\n  // https://github.com/OSGeo/gdal/blob/master/gdal/ogr/ogrlinearring.cpp\n  let edge = 0;\n  let x1 = flatCoordinates[end - stride];\n  let y1 = flatCoordinates[end - stride + 1];\n  for (; offset < end; offset += stride) {\n    const x2 = flatCoordinates[offset];\n    const y2 = flatCoordinates[offset + 1];\n    edge += (x2 - x1) * (y2 + y1);\n    x1 = x2;\n    y1 = y2;\n  }\n  return edge === 0 ? undefined : edge > 0;\n}\n\n/**\n * Determines if linear rings are oriented.  By default, left-hand orientation\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n * To test for right-hand orientation, use the `right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean} [right] Test for right-hand orientation\n *     (counter-clockwise exterior ring and clockwise interior rings).\n * @return {boolean} Rings are correctly oriented.\n */\nexport function linearRingsAreOriented(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  right\n) {\n  right = right !== undefined ? right : false;\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    const isClockwise = linearRingIsClockwise(\n      flatCoordinates,\n      offset,\n      end,\n      stride\n    );\n    if (i === 0) {\n      if ((right && isClockwise) || (!right && !isClockwise)) {\n        return false;\n      }\n    } else {\n      if ((right && !isClockwise) || (!right && isClockwise)) {\n        return false;\n      }\n    }\n    offset = end;\n  }\n  return true;\n}\n\n/**\n * Determines if linear rings are oriented.  By default, left-hand orientation\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n * To test for right-hand orientation, use the `right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Array of array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean} [right] Test for right-hand orientation\n *     (counter-clockwise exterior ring and clockwise interior rings).\n * @return {boolean} Rings are correctly oriented.\n */\nexport function linearRingssAreOriented(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  right\n) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    if (!linearRingsAreOriented(flatCoordinates, offset, ends, stride, right)) {\n      return false;\n    }\n    if (ends.length) {\n      offset = ends[ends.length - 1];\n    }\n  }\n  return true;\n}\n\n/**\n * Orient coordinates in a flat array of linear rings.  By default, rings\n * are oriented following the left-hand rule (clockwise for exterior and\n * counter-clockwise for interior rings).  To orient according to the\n * right-hand rule, use the `right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {boolean} [right] Follow the right-hand rule for orientation.\n * @return {number} End.\n */\nexport function orientLinearRings(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  right\n) {\n  right = right !== undefined ? right : false;\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    const isClockwise = linearRingIsClockwise(\n      flatCoordinates,\n      offset,\n      end,\n      stride\n    );\n    const reverse =\n      i === 0\n        ? (right && isClockwise) || (!right && !isClockwise)\n        : (right && !isClockwise) || (!right && isClockwise);\n    if (reverse) {\n      reverseCoordinates(flatCoordinates, offset, end, stride);\n    }\n    offset = end;\n  }\n  return offset;\n}\n\n/**\n * Orient coordinates in a flat array of linear rings.  By default, rings\n * are oriented following the left-hand rule (clockwise for exterior and\n * counter-clockwise for interior rings).  To orient according to the\n * right-hand rule, use the `right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Array of array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean} [right] Follow the right-hand rule for orientation.\n * @return {number} End.\n */\nexport function orientLinearRingsArray(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  right\n) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    offset = orientLinearRings(\n      flatCoordinates,\n      offset,\n      endss[i],\n      stride,\n      right\n    );\n  }\n  return offset;\n}\n\n/**\n * Return a two-dimensional endss\n * @param {Array<number>} flatCoordinates Flat coordinates\n * @param {Array<number>} ends Linear ring end indexes\n * @return {Array<Array<number>>} Two dimensional endss array that can\n * be used to contruct a MultiPolygon\n */\nexport function inflateEnds(flatCoordinates, ends) {\n  const endss = [];\n  let offset = 0;\n  let prevEndIndex = 0;\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    // classifies an array of rings into polygons with outer rings and holes\n    if (!linearRingIsClockwise(flatCoordinates, offset, end, 2)) {\n      endss.push(ends.slice(prevEndIndex, i + 1));\n    } else {\n      if (endss.length === 0) {\n        continue;\n      }\n      endss[endss.length - 1].push(ends[prevEndIndex]);\n    }\n    prevEndIndex = i + 1;\n    offset = end;\n  }\n  return endss;\n}\n","/**\n * @module ol/geom/flat/segments\n */\n\n/**\n * This function calls `callback` for each segment of the flat coordinates\n * array. If the callback returns a truthy value the function returns that\n * value immediately. Otherwise the function returns `false`.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {function(import(\"../../coordinate.js\").Coordinate, import(\"../../coordinate.js\").Coordinate): T} callback Function\n *     called for each segment.\n * @return {T|boolean} Value.\n * @template T\n */\nexport function forEach(flatCoordinates, offset, end, stride, callback) {\n  let ret;\n  offset += stride;\n  for (; offset < end; offset += stride) {\n    ret = callback(\n      flatCoordinates.slice(offset - stride, offset),\n      flatCoordinates.slice(offset, offset + stride)\n    );\n    if (ret) {\n      return ret;\n    }\n  }\n  return false;\n}\n","/**\n * @module ol/geom/flat/simplify\n */\n// Based on simplify-js https://github.com/mourner/simplify-js\n// Copyright (c) 2012, Vladimir Agafonkin\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n//    1. Redistributions of source code must retain the above copyright notice,\n//       this list of conditions and the following disclaimer.\n//\n//    2. Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n\nimport {squaredDistance, squaredSegmentDistance} from '../../math.js';\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {boolean} highQuality Highest quality.\n * @param {Array<number>} [simplifiedFlatCoordinates] Simplified flat\n *     coordinates.\n * @return {Array<number>} Simplified line string.\n */\nexport function simplifyLineString(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  squaredTolerance,\n  highQuality,\n  simplifiedFlatCoordinates\n) {\n  simplifiedFlatCoordinates =\n    simplifiedFlatCoordinates !== undefined ? simplifiedFlatCoordinates : [];\n  if (!highQuality) {\n    end = radialDistance(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      squaredTolerance,\n      simplifiedFlatCoordinates,\n      0\n    );\n    flatCoordinates = simplifiedFlatCoordinates;\n    offset = 0;\n    stride = 2;\n  }\n  simplifiedFlatCoordinates.length = douglasPeucker(\n    flatCoordinates,\n    offset,\n    end,\n    stride,\n    squaredTolerance,\n    simplifiedFlatCoordinates,\n    0\n  );\n  return simplifiedFlatCoordinates;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\nexport function douglasPeucker(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  squaredTolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset\n) {\n  const n = (end - offset) / stride;\n  if (n < 3) {\n    for (; offset < end; offset += stride) {\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n        flatCoordinates[offset + 1];\n    }\n    return simplifiedOffset;\n  }\n  /** @type {Array<number>} */\n  const markers = new Array(n);\n  markers[0] = 1;\n  markers[n - 1] = 1;\n  /** @type {Array<number>} */\n  const stack = [offset, end - stride];\n  let index = 0;\n  while (stack.length > 0) {\n    const last = stack.pop();\n    const first = stack.pop();\n    let maxSquaredDistance = 0;\n    const x1 = flatCoordinates[first];\n    const y1 = flatCoordinates[first + 1];\n    const x2 = flatCoordinates[last];\n    const y2 = flatCoordinates[last + 1];\n    for (let i = first + stride; i < last; i += stride) {\n      const x = flatCoordinates[i];\n      const y = flatCoordinates[i + 1];\n      const squaredDistance = squaredSegmentDistance(x, y, x1, y1, x2, y2);\n      if (squaredDistance > maxSquaredDistance) {\n        index = i;\n        maxSquaredDistance = squaredDistance;\n      }\n    }\n    if (maxSquaredDistance > squaredTolerance) {\n      markers[(index - offset) / stride] = 1;\n      if (first + stride < index) {\n        stack.push(first, index);\n      }\n      if (index + stride < last) {\n        stack.push(index, last);\n      }\n    }\n  }\n  for (let i = 0; i < n; ++i) {\n    if (markers[i]) {\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n        flatCoordinates[offset + i * stride];\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n        flatCoordinates[offset + i * stride + 1];\n    }\n  }\n  return simplifiedOffset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<number>} simplifiedEnds Simplified ends.\n * @return {number} Simplified offset.\n */\nexport function douglasPeuckerArray(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  squaredTolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset,\n  simplifiedEnds\n) {\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    simplifiedOffset = douglasPeucker(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      squaredTolerance,\n      simplifiedFlatCoordinates,\n      simplifiedOffset\n    );\n    simplifiedEnds.push(simplifiedOffset);\n    offset = end;\n  }\n  return simplifiedOffset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<Array<number>>} simplifiedEndss Simplified endss.\n * @return {number} Simplified offset.\n */\nexport function douglasPeuckerMultiArray(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  squaredTolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset,\n  simplifiedEndss\n) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    const simplifiedEnds = [];\n    simplifiedOffset = douglasPeuckerArray(\n      flatCoordinates,\n      offset,\n      ends,\n      stride,\n      squaredTolerance,\n      simplifiedFlatCoordinates,\n      simplifiedOffset,\n      simplifiedEnds\n    );\n    simplifiedEndss.push(simplifiedEnds);\n    offset = ends[ends.length - 1];\n  }\n  return simplifiedOffset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\nexport function radialDistance(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  squaredTolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset\n) {\n  if (end <= offset + stride) {\n    // zero or one point, no simplification possible, so copy and return\n    for (; offset < end; offset += stride) {\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n        flatCoordinates[offset + 1];\n    }\n    return simplifiedOffset;\n  }\n  let x1 = flatCoordinates[offset];\n  let y1 = flatCoordinates[offset + 1];\n  // copy first point\n  simplifiedFlatCoordinates[simplifiedOffset++] = x1;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y1;\n  let x2 = x1;\n  let y2 = y1;\n  for (offset += stride; offset < end; offset += stride) {\n    x2 = flatCoordinates[offset];\n    y2 = flatCoordinates[offset + 1];\n    if (squaredDistance(x1, y1, x2, y2) > squaredTolerance) {\n      // copy point at offset\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n      x1 = x2;\n      y1 = y2;\n    }\n  }\n  if (x2 != x1 || y2 != y1) {\n    // copy last point\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n  }\n  return simplifiedOffset;\n}\n\n/**\n * @param {number} value Value.\n * @param {number} tolerance Tolerance.\n * @return {number} Rounded value.\n */\nexport function snap(value, tolerance) {\n  return tolerance * Math.round(value / tolerance);\n}\n\n/**\n * Simplifies a line string using an algorithm designed by Tim Schaub.\n * Coordinates are snapped to the nearest value in a virtual grid and\n * consecutive duplicate coordinates are discarded.  This effectively preserves\n * topology as the simplification of any subsection of a line string is\n * independent of the rest of the line string.  This means that, for examples,\n * the common edge between two polygons will be simplified to the same line\n * string independently in both polygons.  This implementation uses a single\n * pass over the coordinates and eliminates intermediate collinear points.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\nexport function quantize(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  tolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset\n) {\n  // do nothing if the line is empty\n  if (offset == end) {\n    return simplifiedOffset;\n  }\n  // snap the first coordinate (P1)\n  let x1 = snap(flatCoordinates[offset], tolerance);\n  let y1 = snap(flatCoordinates[offset + 1], tolerance);\n  offset += stride;\n  // add the first coordinate to the output\n  simplifiedFlatCoordinates[simplifiedOffset++] = x1;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y1;\n  // find the next coordinate that does not snap to the same value as the first\n  // coordinate (P2)\n  let x2, y2;\n  do {\n    x2 = snap(flatCoordinates[offset], tolerance);\n    y2 = snap(flatCoordinates[offset + 1], tolerance);\n    offset += stride;\n    if (offset == end) {\n      // all coordinates snap to the same value, the line collapses to a point\n      // push the last snapped value anyway to ensure that the output contains\n      // at least two points\n      // FIXME should we really return at least two points anyway?\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n      return simplifiedOffset;\n    }\n  } while (x2 == x1 && y2 == y1);\n  while (offset < end) {\n    // snap the next coordinate (P3)\n    const x3 = snap(flatCoordinates[offset], tolerance);\n    const y3 = snap(flatCoordinates[offset + 1], tolerance);\n    offset += stride;\n    // skip P3 if it is equal to P2\n    if (x3 == x2 && y3 == y2) {\n      continue;\n    }\n    // calculate the delta between P1 and P2\n    const dx1 = x2 - x1;\n    const dy1 = y2 - y1;\n    // calculate the delta between P3 and P1\n    const dx2 = x3 - x1;\n    const dy2 = y3 - y1;\n    // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from\n    // P1 in the same direction then P2 is on the straight line between P1 and\n    // P3\n    if (\n      dx1 * dy2 == dy1 * dx2 &&\n      ((dx1 < 0 && dx2 < dx1) || dx1 == dx2 || (dx1 > 0 && dx2 > dx1)) &&\n      ((dy1 < 0 && dy2 < dy1) || dy1 == dy2 || (dy1 > 0 && dy2 > dy1))\n    ) {\n      // discard P2 and set P2 = P3\n      x2 = x3;\n      y2 = y3;\n      continue;\n    }\n    // either P1, P2, and P3 are not colinear, or they are colinear but P3 is\n    // between P3 and P1 or on the opposite half of the line to P2.  add P2,\n    // and continue with P1 = P2 and P2 = P3\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n    x1 = x2;\n    y1 = y2;\n    x2 = x3;\n    y2 = y3;\n  }\n  // add the last point (P2)\n  simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n  return simplifiedOffset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<number>} simplifiedEnds Simplified ends.\n * @return {number} Simplified offset.\n */\nexport function quantizeArray(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  tolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset,\n  simplifiedEnds\n) {\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    simplifiedOffset = quantize(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      tolerance,\n      simplifiedFlatCoordinates,\n      simplifiedOffset\n    );\n    simplifiedEnds.push(simplifiedOffset);\n    offset = end;\n  }\n  return simplifiedOffset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<Array<number>>} simplifiedEndss Simplified endss.\n * @return {number} Simplified offset.\n */\nexport function quantizeMultiArray(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  tolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset,\n  simplifiedEndss\n) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    const simplifiedEnds = [];\n    simplifiedOffset = quantizeArray(\n      flatCoordinates,\n      offset,\n      ends,\n      stride,\n      tolerance,\n      simplifiedFlatCoordinates,\n      simplifiedOffset,\n      simplifiedEnds\n    );\n    simplifiedEndss.push(simplifiedEnds);\n    offset = ends[ends.length - 1];\n  }\n  return simplifiedOffset;\n}\n","/**\n * @module ol/geom/flat/straightchunk\n */\n\n/**\n * @param {number} maxAngle Maximum acceptable angle delta between segments.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {Array<number>} Start and end of the first suitable chunk of the\n * given `flatCoordinates`.\n */\nexport function matchingChunk(maxAngle, flatCoordinates, offset, end, stride) {\n  let chunkStart = offset;\n  let chunkEnd = offset;\n  let chunkM = 0;\n  let m = 0;\n  let start = offset;\n  let acos, i, m12, m23, x1, y1, x12, y12, x23, y23;\n  for (i = offset; i < end; i += stride) {\n    const x2 = flatCoordinates[i];\n    const y2 = flatCoordinates[i + 1];\n    if (x1 !== undefined) {\n      x23 = x2 - x1;\n      y23 = y2 - y1;\n      m23 = Math.sqrt(x23 * x23 + y23 * y23);\n      if (x12 !== undefined) {\n        m += m12;\n        acos = Math.acos((x12 * x23 + y12 * y23) / (m12 * m23));\n        if (acos > maxAngle) {\n          if (m > chunkM) {\n            chunkM = m;\n            chunkStart = start;\n            chunkEnd = i;\n          }\n          m = 0;\n          start = i - stride;\n        }\n      }\n      m12 = m23;\n      x12 = x23;\n      y12 = y23;\n    }\n    x1 = x2;\n    y1 = y2;\n  }\n  m += m23;\n  return m > chunkM ? [start, i] : [chunkStart, chunkEnd];\n}\n","/**\n * @module ol/geom/flat/textpath\n */\nimport {lerp} from '../../math.js';\nimport {rotate} from './transform.js';\n\n/**\n * @param {Array<number>} flatCoordinates Path to put text on.\n * @param {number} offset Start offset of the `flatCoordinates`.\n * @param {number} end End offset of the `flatCoordinates`.\n * @param {number} stride Stride.\n * @param {string} text Text to place on the path.\n * @param {number} startM m along the path where the text starts.\n * @param {number} maxAngle Max angle between adjacent chars in radians.\n * @param {number} scale The product of the text scale and the device pixel ratio.\n * @param {function(string, string, Object<string, number>):number} measureAndCacheTextWidth Measure and cache text width.\n * @param {string} font The font.\n * @param {Object<string, number>} cache A cache of measured widths.\n * @param {number} rotation Rotation to apply to the flatCoordinates to determine whether text needs to be reversed.\n * @return {Array<Array<*>>|null} The result array (or null if `maxAngle` was\n * exceeded). Entries of the array are x, y, anchorX, angle, chunk.\n */\nexport function drawTextOnPath(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  text,\n  startM,\n  maxAngle,\n  scale,\n  measureAndCacheTextWidth,\n  font,\n  cache,\n  rotation\n) {\n  let x2 = flatCoordinates[offset];\n  let y2 = flatCoordinates[offset + 1];\n  let x1 = 0;\n  let y1 = 0;\n  let segmentLength = 0;\n  let segmentM = 0;\n\n  function advance() {\n    x1 = x2;\n    y1 = y2;\n    offset += stride;\n    x2 = flatCoordinates[offset];\n    y2 = flatCoordinates[offset + 1];\n    segmentM += segmentLength;\n    segmentLength = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n  }\n  do {\n    advance();\n  } while (offset < end - stride && segmentM + segmentLength < startM);\n\n  let interpolate =\n    segmentLength === 0 ? 0 : (startM - segmentM) / segmentLength;\n  const beginX = lerp(x1, x2, interpolate);\n  const beginY = lerp(y1, y2, interpolate);\n\n  const startOffset = offset - stride;\n  const startLength = segmentM;\n  const endM = startM + scale * measureAndCacheTextWidth(font, text, cache);\n  while (offset < end - stride && segmentM + segmentLength < endM) {\n    advance();\n  }\n  interpolate = segmentLength === 0 ? 0 : (endM - segmentM) / segmentLength;\n  const endX = lerp(x1, x2, interpolate);\n  const endY = lerp(y1, y2, interpolate);\n\n  // Keep text upright\n  let reverse;\n  if (rotation) {\n    const flat = [beginX, beginY, endX, endY];\n    rotate(flat, 0, 4, 2, rotation, flat, flat);\n    reverse = flat[0] > flat[2];\n  } else {\n    reverse = beginX > endX;\n  }\n\n  const PI = Math.PI;\n  const result = [];\n  const singleSegment = startOffset + stride === offset;\n\n  offset = startOffset;\n  segmentLength = 0;\n  segmentM = startLength;\n  x2 = flatCoordinates[offset];\n  y2 = flatCoordinates[offset + 1];\n\n  let previousAngle;\n  // All on the same segment\n  if (singleSegment) {\n    advance();\n\n    previousAngle = Math.atan2(y2 - y1, x2 - x1);\n    if (reverse) {\n      previousAngle += previousAngle > 0 ? -PI : PI;\n    }\n    const x = (endX + beginX) / 2;\n    const y = (endY + beginY) / 2;\n    result[0] = [x, y, (endM - startM) / 2, previousAngle, text];\n    return result;\n  }\n\n  // rendering across line segments\n  text = text.replace(/\\n/g, ' '); // ensure rendering in single-line as all calculations below don't handle multi-lines\n\n  for (let i = 0, ii = text.length; i < ii; ) {\n    advance();\n    let angle = Math.atan2(y2 - y1, x2 - x1);\n    if (reverse) {\n      angle += angle > 0 ? -PI : PI;\n    }\n    if (previousAngle !== undefined) {\n      let delta = angle - previousAngle;\n      delta += delta > PI ? -2 * PI : delta < -PI ? 2 * PI : 0;\n      if (Math.abs(delta) > maxAngle) {\n        return null;\n      }\n    }\n    previousAngle = angle;\n\n    const iStart = i;\n    let charLength = 0;\n    for (; i < ii; ++i) {\n      const index = reverse ? ii - i - 1 : i;\n      const len = scale * measureAndCacheTextWidth(font, text[index], cache);\n      if (\n        offset + stride < end &&\n        segmentM + segmentLength < startM + charLength + len / 2\n      ) {\n        break;\n      }\n      charLength += len;\n    }\n    if (i === iStart) {\n      continue;\n    }\n    const chars = reverse\n      ? text.substring(ii - iStart, ii - i)\n      : text.substring(iStart, i);\n    interpolate =\n      segmentLength === 0\n        ? 0\n        : (startM + charLength / 2 - segmentM) / segmentLength;\n    const x = lerp(x1, x2, interpolate);\n    const y = lerp(y1, y2, interpolate);\n    result.push([x, y, charLength / 2, angle, chars]);\n    startM += charLength;\n  }\n  return result;\n}\n","/**\n * @module ol/geom/flat/transform\n */\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../transform.js\").Transform} transform Transform.\n * @param {Array<number>} [dest] Destination.\n * @return {Array<number>} Transformed coordinates.\n */\nexport function transform2D(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  transform,\n  dest\n) {\n  dest = dest ? dest : [];\n  let i = 0;\n  for (let j = offset; j < end; j += stride) {\n    const x = flatCoordinates[j];\n    const y = flatCoordinates[j + 1];\n    dest[i++] = transform[0] * x + transform[2] * y + transform[4];\n    dest[i++] = transform[1] * x + transform[3] * y + transform[5];\n  }\n  if (dest && dest.length != i) {\n    dest.length = i;\n  }\n  return dest;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} angle Angle.\n * @param {Array<number>} anchor Rotation anchor point.\n * @param {Array<number>} [dest] Destination.\n * @return {Array<number>} Transformed coordinates.\n */\nexport function rotate(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  angle,\n  anchor,\n  dest\n) {\n  dest = dest ? dest : [];\n  const cos = Math.cos(angle);\n  const sin = Math.sin(angle);\n  const anchorX = anchor[0];\n  const anchorY = anchor[1];\n  let i = 0;\n  for (let j = offset; j < end; j += stride) {\n    const deltaX = flatCoordinates[j] - anchorX;\n    const deltaY = flatCoordinates[j + 1] - anchorY;\n    dest[i++] = anchorX + deltaX * cos - deltaY * sin;\n    dest[i++] = anchorY + deltaX * sin + deltaY * cos;\n    for (let k = j + 2; k < j + stride; ++k) {\n      dest[i++] = flatCoordinates[k];\n    }\n  }\n  if (dest && dest.length != i) {\n    dest.length = i;\n  }\n  return dest;\n}\n\n/**\n * Scale the coordinates.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} sx Scale factor in the x-direction.\n * @param {number} sy Scale factor in the y-direction.\n * @param {Array<number>} anchor Scale anchor point.\n * @param {Array<number>} [dest] Destination.\n * @return {Array<number>} Transformed coordinates.\n */\nexport function scale(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  sx,\n  sy,\n  anchor,\n  dest\n) {\n  dest = dest ? dest : [];\n  const anchorX = anchor[0];\n  const anchorY = anchor[1];\n  let i = 0;\n  for (let j = offset; j < end; j += stride) {\n    const deltaX = flatCoordinates[j] - anchorX;\n    const deltaY = flatCoordinates[j + 1] - anchorY;\n    dest[i++] = anchorX + sx * deltaX;\n    dest[i++] = anchorY + sy * deltaY;\n    for (let k = j + 2; k < j + stride; ++k) {\n      dest[i++] = flatCoordinates[k];\n    }\n  }\n  if (dest && dest.length != i) {\n    dest.length = i;\n  }\n  return dest;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} deltaX Delta X.\n * @param {number} deltaY Delta Y.\n * @param {Array<number>} [dest] Destination.\n * @return {Array<number>} Transformed coordinates.\n */\nexport function translate(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  deltaX,\n  deltaY,\n  dest\n) {\n  dest = dest ? dest : [];\n  let i = 0;\n  for (let j = offset; j < end; j += stride) {\n    dest[i++] = flatCoordinates[j] + deltaX;\n    dest[i++] = flatCoordinates[j + 1] + deltaY;\n    for (let k = j + 2; k < j + stride; ++k) {\n      dest[i++] = flatCoordinates[k];\n    }\n  }\n  if (dest && dest.length != i) {\n    dest.length = i;\n  }\n  return dest;\n}\n"],"names":["binarySearch","haystack","needle","comparator","mid","cmp","ascending","low","high","length","found","a","b","linearFindNearest","arr","target","direction","n","i","reverseSubArray","begin","end","tmp","extend","data","extension","Array","isArray","equals","arr1","arr2","len1","isSorted","func","strict","compare","every","currentVal","index","res","createExtent","extent","onlyCenter","smooth","center","resolution","size","isMoving","centerShift","viewWidth","viewHeight","shiftX","shiftY","minX","maxX","minY","maxY","x","y","ratio","Math","log","max","none","HEX_COLOR_RE_","NAMED_COLOR_RE_","asString","color","toString","fromNamed","el","document","createElement","style","body","appendChild","rgb","getComputedStyle","removeChild","fromString","MAX_CACHE_SIZE","cache","cacheSize","s","hasOwnProperty","key","fromStringInternal_","asArray","r","g","exec","d","hasAlpha","parseInt","substr","startsWith","slice","split","map","Number","normalize","push","undefined","round","isStringColor","test","asColorLike","Control","constructor","options","super","element","pointerEvents","this","target_","map_","listenerKeys","render","setTarget","disposeInternal","getMap","setMap","ii","getOverlayContainerStopEvent","mapEvent","getElementById","events","FullScreenEventType","ENTERFULLSCREEN","LEAVEFULLSCREEN","FullScreen","on","once","un","keys_","keys","source_","source","isInFullscreen_","boundHandleMapTargetChange_","handleMapTargetChange_","bind","cssClassName_","className","documentListeners_","activeClassName_","activeClassName","inactiveClassName_","inactiveClassName","label","labelNode_","createTextNode","labelActive","labelActiveNode_","tipLabel","button_","title","setAttribute","addEventListener","handleClick_","setClassName_","event","preventDefault","handleFullScreen_","doc","getOwnerDocument","isFullScreenSupported","isFullScreen","exitFullScreen","getTargetElement","requestFullScreenWithKeys","requestFullScreen","handleFullScreenChange_","wasInFullscreen","dispatchEvent","updateSize","fullscreen","classList","remove","add","oldMap","removeChangeListener","addChangeListener","listeners","requestFullscreen","fullscreenEnabled","fullscreenElement","exitFullscreen","UNITS_PROP","LEADING_DIGITS","DEFAULT_DPI","ScaleLine","bar","innerElement_","viewState_","minWidth_","minWidth","maxWidth_","maxWidth","renderedVisible_","renderedWidth_","renderedHTML_","handleUnitsChanged_","setUnits","units","scaleBar_","scaleBarSteps_","steps","scaleBarText_","text","dpi_","dpi","getUnits","get","updateElement_","set","setDpi","viewState","display","projection","pointResolutionUnits","pointResolution","getPointResolution","nominalCount","suffix","metersPerDegree","METERS_PER_UNIT","count","width","decimalCount","previousCount","previousWidth","previousDecimalCount","floor","decimal","pow","isNaN","html","createScaleBar","toFixed","innerHTML","scale","resolutionScale","getScaleForResolution","mapScale","toLocaleString","stepWidth","scaleSteps","createMarker","cls","createStepText","scaleBarText","join","position","top","isLast","lengthString","margin","inchesPerMeter","frameState","Attribution","ulElement_","collapsed_","collapsed","userCollapsed_","overrideCollapsible_","collapsible","collapsible_","expandClassName","collapseLabel","collapseClassName","collapseLabel_","textContent","label_","activeLabel","toggleButton_","String","EventType","cssClasses","renderedAttributions_","collectSourceAttributions_","lookup","visibleAttributions","layerStatesArray","layerState","getSource","attributionGetter","getAttributions","attributions","getAttributionsCollapsible","j","jj","setCollapsible","visible","handleToggle_","toggle","getCollapsible","setCollapsed","getCollapsed","Rotate","compassClassName","button","callResetNorth_","resetNorth","duration_","duration","autoHide_","autoHide","rotation_","resetNorth_","view","getView","rotation","getRotation","PI","animate","easing","setRotation","transform","contains","Zoom","delta","zoomInClassName","zoomOutClassName","zoomInLabel","zoomOutLabel","zoomInTipLabel","zoomOutTipLabel","inElement","outElement","zoomByDelta_","currentZoom","getZoom","newZoom","getConstrainedZoom","getAnimating","cancelAnimations","zoom","setZoom","defaults","controls","Collection","zoomControl","zoomOptions","rotateControl","rotate","rotateOptions","attributionControl","attribution","attributionOptions","CLASS_HIDDEN","CLASS_UNSELECTABLE","CLASS_UNSUPPORTED","CLASS_CONTROL","CLASS_COLLAPSED","fontRegEx","RegExp","fontRegExMatchIndex","getFontParameters","fontSpec","match","lineHeight","weight","variant","value","families","family","createCanvasContext2D","height","canvasPool","settings","canvas","shift","OffscreenCanvas","getContext","releaseCanvas","context","clearRect","replaceNode","newNode","oldNode","parent","parentNode","replaceChild","removeNode","node","removeChildren","lastChild","replaceChildren","children","oldChildren","childNodes","oldChild","newChild","insertBefore","easeIn","t","easeOut","inAndOut","linear","listen","type","listener","thisArg","originalListener","removeEventListener","apply","arguments","eventsKey","listenOnce","unlistenByKey","BaseEvent","propagationStopped","defaultPrevented","stopPropagation","CHANGE","ERROR","BLUR","CLEAR","CONTEXTMENU","CLICK","DBLCLICK","DRAGENTER","DRAGOVER","DROP","FOCUS","KEYDOWN","KEYPRESS","LOAD","RESIZE","TOUCHMOVE","WHEEL","LEFT","UP","RIGHT","DOWN","Target","eventTarget_","pendingRemovals_","dispatching_","listeners_","listenersForType","includes","isString","evt","dispatching","pendingRemovals","propagate","handleEvent","call","pr","getListeners","hasListener","Object","indexOf","splice","all","var_args","conditions","pass","altKeyOnly","mapBrowserEvent","originalEvent","altKey","metaKey","ctrlKey","shiftKey","altShiftKeysOnly","focus","targetElement","activeElement","focusWithTabindex","hasAttribute","always","click","mouseActionButton","never","singleClick","noModifierKeys","shiftKeyOnly","targetNotEditable","tagName","isContentEditable","mouseOnly","pointerEvent","pointerType","primaryAction","isPrimary","withCredentials","loadFeaturesXhr","url","format","success","failure","xhr","XMLHttpRequest","open","getType","responseType","onload","status","responseText","responseXML","DOMParser","parseFromString","readFeatures","featureProjection","readProjection","onerror","send","features","dataProjection","addFeatures","TRUE","FALSE","VOID","memoizeOne","fn","lastResult","lastArgs","lastThis","called","nextArgs","prototype","toPromise","getter","promiseGetter","err","Promise","reject","resolve","tmpTransform","Geometry","extent_","extentRevision_","simplifiedGeometryMaxMinSquaredTolerance","simplifiedGeometryRevision","simplifyTransformedInternal","revision","squaredTolerance","getSimplifiedGeometry","clone","applyTransform","simplifyTransformed","getRevision","closestPointXY","closestPoint","minSquaredDistance","containsXY","coord","getClosestPoint","point","NaN","Infinity","intersectsCoordinate","coordinate","computeExtent","getExtent","angle","anchor","sx","sy","simplify","tolerance","transformFn","intersectsExtent","translate","deltaX","deltaY","destination","sourceProj","inCoordinates","outCoordinates","stride","pixelExtent","projectedExtent","getWorldExtent","getTransform","LinearRing","coordinates","layout","maxDelta_","maxDeltaRevision_","setCoordinates","setFlatCoordinates","flatCoordinates","sqrt","getArea","getCoordinates","getSimplifiedGeometryInternal","simplifiedFlatCoordinates","setLayout","changed","Point","applyProperties","squaredDistance","Polygon","ends","ends_","flatInteriorPointRevision_","flatInteriorPoint_","orientedRevision_","orientedFlatCoordinates_","appendLinearRing","linearRing","getFlatCoordinates","polygon","getOrientedFlatCoordinates","right","getEnds","getFlatInteriorPoint","flatCenter","getInteriorPoint","getLinearRingCount","getLinearRing","getLinearRings","linearRings","offset","simplifiedEnds","fromExtent","fromCircle","circle","sides","getStride","getLayout","getCenter","arrayLength","makeRegular","getRadius","radius","startAngle","cos","sin","SimpleGeometry","getFirstCoordinate","getLastCoordinate","simplifiedGeometry","getStrideForLayout","nesting","getLayoutForStride","transformGeom2D","simpleGeometry","dest","twiceArea","x1","y1","x2","y2","area","linearRingss","endss","assignClosest","offset1","offset2","dx","dy","maxSquaredDelta","squaredDelta","arrayMaxSquaredDelta","multiArrayMaxSquaredDelta","assignClosestPoint","maxDelta","isRing","tmpPoint","assignClosestArrayPoint","assignClosestMultiArrayPoint","linearRingContainsExtent","outside","linearRingContainsXY","wn","linearRingsContainsXY","linearRingssContainsXY","deflateCoordinate","deflateCoordinates","deflateCoordinatesArray","coordinatess","deflateMultiCoordinatesArray","coordinatesss","inflateCoordinates","inflateCoordinatesArray","inflateMultiCoordinatesArray","getInteriorPointOfArray","flatCenters","flatCentersOffset","intersections","rr","pointX","maxSegmentLength","sort","segmentLength","abs","getInteriorPointsOfMultiArray","interiorPoints","intersectsLineString","coordinatesExtent","point1","point2","intersectsLineStringArray","intersectsLinearRing","intersectsLinearRingArray","intersectsLinearRingMultiArray","lineStringLength","linearRingIsClockwise","edge","linearRingsAreOriented","isClockwise","linearRingssAreOriented","orientLinearRings","reverse","orientLinearRingsArray","forEach","callback","ret","douglasPeucker","simplifiedOffset","markers","stack","last","pop","first","maxSquaredDistance","douglasPeuckerArray","snap","quantize","x3","y3","dx1","dy1","dx2","dy2","quantizeArray","quantizeMultiArray","simplifiedEndss","matchingChunk","maxAngle","acos","m12","m23","x12","y12","x23","y23","chunkStart","chunkEnd","chunkM","m","start","drawTextOnPath","startM","measureAndCacheTextWidth","font","segmentM","advance","interpolate","beginX","beginY","startOffset","startLength","endM","endX","endY","flat","result","singleSegment","previousAngle","atan2","replace","iStart","charLength","len","chars","substring","transform2D","anchorX","anchorY","k"],"sourceRoot":""}
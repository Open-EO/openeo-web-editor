{"version":3,"file":"js/3564.cde648cd.js","mappings":"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","sources":["webpack://@openeo/web-editor/./node_modules/ol/functions.js","webpack://@openeo/web-editor/./node_modules/ol/geom/Geometry.js","webpack://@openeo/web-editor/./node_modules/ol/geom/GeometryCollection.js","webpack://@openeo/web-editor/./node_modules/ol/geom/GeometryLayout.js","webpack://@openeo/web-editor/./node_modules/ol/geom/LineString.js","webpack://@openeo/web-editor/./node_modules/ol/geom/LinearRing.js","webpack://@openeo/web-editor/./node_modules/ol/geom/MultiLineString.js","webpack://@openeo/web-editor/./node_modules/ol/geom/MultiPoint.js","webpack://@openeo/web-editor/./node_modules/ol/geom/flat/center.js","webpack://@openeo/web-editor/./node_modules/ol/geom/MultiPolygon.js","webpack://@openeo/web-editor/./node_modules/ol/geom/Point.js","webpack://@openeo/web-editor/./node_modules/ol/geom/Polygon.js","webpack://@openeo/web-editor/./node_modules/ol/geom/SimpleGeometry.js","webpack://@openeo/web-editor/./node_modules/ol/geom/flat/area.js","webpack://@openeo/web-editor/./node_modules/ol/geom/flat/closest.js","webpack://@openeo/web-editor/./node_modules/ol/geom/flat/contains.js","webpack://@openeo/web-editor/./node_modules/ol/geom/flat/deflate.js","webpack://@openeo/web-editor/./node_modules/ol/geom/flat/inflate.js","webpack://@openeo/web-editor/./node_modules/ol/geom/flat/interiorpoint.js","webpack://@openeo/web-editor/./node_modules/ol/geom/flat/interpolate.js","webpack://@openeo/web-editor/./node_modules/ol/geom/flat/intersectsextent.js","webpack://@openeo/web-editor/./node_modules/ol/geom/flat/length.js","webpack://@openeo/web-editor/./node_modules/ol/geom/flat/reverse.js","webpack://@openeo/web-editor/./node_modules/ol/geom/flat/orient.js","webpack://@openeo/web-editor/./node_modules/ol/geom/flat/segments.js","webpack://@openeo/web-editor/./node_modules/ol/geom/flat/simplify.js","webpack://@openeo/web-editor/./node_modules/ol/geom/flat/straightchunk.js","webpack://@openeo/web-editor/./node_modules/ol/geom/flat/textpath.js","webpack://@openeo/web-editor/./node_modules/ol/geom/flat/transform.js"],"sourcesContent":["/**\n * @module ol/functions\n */\nimport { equals as arrayEquals } from './array.js';\n/**\n * Always returns true.\n * @return {boolean} true.\n */\nexport function TRUE() {\n    return true;\n}\n/**\n * Always returns false.\n * @return {boolean} false.\n */\nexport function FALSE() {\n    return false;\n}\n/**\n * A reusable function, used e.g. as a default for callbacks.\n *\n * @return {void} Nothing.\n */\nexport function VOID() { }\n/**\n * Wrap a function in another function that remembers the last return.  If the\n * returned function is called twice in a row with the same arguments and the same\n * this object, it will return the value from the first call in the second call.\n *\n * @param {function(...any): ReturnType} fn The function to memoize.\n * @return {function(...any): ReturnType} The memoized function.\n * @template ReturnType\n */\nexport function memoizeOne(fn) {\n    var called = false;\n    /** @type {ReturnType} */\n    var lastResult;\n    /** @type {Array<any>} */\n    var lastArgs;\n    var lastThis;\n    return function () {\n        var nextArgs = Array.prototype.slice.call(arguments);\n        if (!called || this !== lastThis || !arrayEquals(nextArgs, lastArgs)) {\n            called = true;\n            lastThis = this;\n            lastArgs = nextArgs;\n            lastResult = fn.apply(this, arguments);\n        }\n        return lastResult;\n    };\n}\n/**\n * @template T\n * @param {function(): (T | Promise<T>)} getter A function that returns a value or a promise for a value.\n * @return {Promise<T>} A promise for the value.\n */\nexport function toPromise(getter) {\n    function promiseGetter() {\n        var value;\n        try {\n            value = getter();\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n        if (value instanceof Promise) {\n            return value;\n        }\n        return Promise.resolve(value);\n    }\n    return promiseGetter();\n}\n//# sourceMappingURL=functions.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/geom/Geometry\n */\nimport BaseObject from '../Object.js';\nimport Units from '../proj/Units.js';\nimport { abstract } from '../util.js';\nimport { compose as composeTransform, create as createTransform, } from '../transform.js';\nimport { createEmpty, createOrUpdateEmpty, getHeight, returnOrUpdate, } from '../extent.js';\nimport { get as getProjection, getTransform } from '../proj.js';\nimport { memoizeOne } from '../functions.js';\nimport { transform2D } from './flat/transform.js';\n/**\n * @typedef {'Point' | 'LineString' | 'LinearRing' | 'Polygon' | 'MultiPoint' | 'MultiLineString' | 'MultiPolygon' | 'GeometryCollection' | 'Circle'} Type\n * The geometry type.  One of `'Point'`, `'LineString'`, `'LinearRing'`,\n * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,\n * `'GeometryCollection'`, or `'Circle'`.\n */\n/**\n * @type {import(\"../transform.js\").Transform}\n */\nvar tmpTransform = createTransform();\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for vector geometries.\n *\n * To get notified of changes to the geometry, register a listener for the\n * generic `change` event on your geometry instance.\n *\n * @abstract\n * @api\n */\nvar Geometry = /** @class */ (function (_super) {\n    __extends(Geometry, _super);\n    function Geometry() {\n        var _this = _super.call(this) || this;\n        /**\n         * @private\n         * @type {import(\"../extent.js\").Extent}\n         */\n        _this.extent_ = createEmpty();\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.extentRevision_ = -1;\n        /**\n         * @protected\n         * @type {number}\n         */\n        _this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n        /**\n         * @protected\n         * @type {number}\n         */\n        _this.simplifiedGeometryRevision = 0;\n        /**\n         * Get a transformed and simplified version of the geometry.\n         * @abstract\n         * @param {number} revision The geometry revision.\n         * @param {number} squaredTolerance Squared tolerance.\n         * @param {import(\"../proj.js\").TransformFunction} [opt_transform] Optional transform function.\n         * @return {Geometry} Simplified geometry.\n         */\n        _this.simplifyTransformedInternal = memoizeOne(function (revision, squaredTolerance, opt_transform) {\n            if (!opt_transform) {\n                return this.getSimplifiedGeometry(squaredTolerance);\n            }\n            var clone = this.clone();\n            clone.applyTransform(opt_transform);\n            return clone.getSimplifiedGeometry(squaredTolerance);\n        });\n        return _this;\n    }\n    /**\n     * Get a transformed and simplified version of the geometry.\n     * @abstract\n     * @param {number} squaredTolerance Squared tolerance.\n     * @param {import(\"../proj.js\").TransformFunction} [opt_transform] Optional transform function.\n     * @return {Geometry} Simplified geometry.\n     */\n    Geometry.prototype.simplifyTransformed = function (squaredTolerance, opt_transform) {\n        return this.simplifyTransformedInternal(this.getRevision(), squaredTolerance, opt_transform);\n    };\n    /**\n     * Make a complete copy of the geometry.\n     * @abstract\n     * @return {!Geometry} Clone.\n     */\n    Geometry.prototype.clone = function () {\n        return abstract();\n    };\n    /**\n     * @abstract\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n     * @param {number} minSquaredDistance Minimum squared distance.\n     * @return {number} Minimum squared distance.\n     */\n    Geometry.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {\n        return abstract();\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @return {boolean} Contains (x, y).\n     */\n    Geometry.prototype.containsXY = function (x, y) {\n        var coord = this.getClosestPoint([x, y]);\n        return coord[0] === x && coord[1] === y;\n    };\n    /**\n     * Return the closest point of the geometry to the passed point as\n     * {@link module:ol/coordinate~Coordinate coordinate}.\n     * @param {import(\"../coordinate.js\").Coordinate} point Point.\n     * @param {import(\"../coordinate.js\").Coordinate} [opt_closestPoint] Closest point.\n     * @return {import(\"../coordinate.js\").Coordinate} Closest point.\n     * @api\n     */\n    Geometry.prototype.getClosestPoint = function (point, opt_closestPoint) {\n        var closestPoint = opt_closestPoint ? opt_closestPoint : [NaN, NaN];\n        this.closestPointXY(point[0], point[1], closestPoint, Infinity);\n        return closestPoint;\n    };\n    /**\n     * Returns true if this geometry includes the specified coordinate. If the\n     * coordinate is on the boundary of the geometry, returns false.\n     * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @return {boolean} Contains coordinate.\n     * @api\n     */\n    Geometry.prototype.intersectsCoordinate = function (coordinate) {\n        return this.containsXY(coordinate[0], coordinate[1]);\n    };\n    /**\n     * @abstract\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @protected\n     * @return {import(\"../extent.js\").Extent} extent Extent.\n     */\n    Geometry.prototype.computeExtent = function (extent) {\n        return abstract();\n    };\n    /**\n     * Get the extent of the geometry.\n     * @param {import(\"../extent.js\").Extent} [opt_extent] Extent.\n     * @return {import(\"../extent.js\").Extent} extent Extent.\n     * @api\n     */\n    Geometry.prototype.getExtent = function (opt_extent) {\n        if (this.extentRevision_ != this.getRevision()) {\n            var extent = this.computeExtent(this.extent_);\n            if (isNaN(extent[0]) || isNaN(extent[1])) {\n                createOrUpdateEmpty(extent);\n            }\n            this.extentRevision_ = this.getRevision();\n        }\n        return returnOrUpdate(this.extent_, opt_extent);\n    };\n    /**\n     * Rotate the geometry around a given coordinate. This modifies the geometry\n     * coordinates in place.\n     * @abstract\n     * @param {number} angle Rotation angle in radians.\n     * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\n     * @api\n     */\n    Geometry.prototype.rotate = function (angle, anchor) {\n        abstract();\n    };\n    /**\n     * Scale the geometry (with an optional origin).  This modifies the geometry\n     * coordinates in place.\n     * @abstract\n     * @param {number} sx The scaling factor in the x-direction.\n     * @param {number} [opt_sy] The scaling factor in the y-direction (defaults to sx).\n     * @param {import(\"../coordinate.js\").Coordinate} [opt_anchor] The scale origin (defaults to the center\n     *     of the geometry extent).\n     * @api\n     */\n    Geometry.prototype.scale = function (sx, opt_sy, opt_anchor) {\n        abstract();\n    };\n    /**\n     * Create a simplified version of this geometry.  For linestrings, this uses\n     * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)\n     * algorithm.  For polygons, a quantization-based\n     * simplification is used to preserve topology.\n     * @param {number} tolerance The tolerance distance for simplification.\n     * @return {Geometry} A new, simplified version of the original geometry.\n     * @api\n     */\n    Geometry.prototype.simplify = function (tolerance) {\n        return this.getSimplifiedGeometry(tolerance * tolerance);\n    };\n    /**\n     * Create a simplified version of this geometry using the Douglas Peucker\n     * algorithm.\n     * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.\n     * @abstract\n     * @param {number} squaredTolerance Squared tolerance.\n     * @return {Geometry} Simplified geometry.\n     */\n    Geometry.prototype.getSimplifiedGeometry = function (squaredTolerance) {\n        return abstract();\n    };\n    /**\n     * Get the type of this geometry.\n     * @abstract\n     * @return {Type} Geometry type.\n     */\n    Geometry.prototype.getType = function () {\n        return abstract();\n    };\n    /**\n     * Apply a transform function to the coordinates of the geometry.\n     * The geometry is modified in place.\n     * If you do not want the geometry modified in place, first `clone()` it and\n     * then use this function on the clone.\n     * @abstract\n     * @param {import(\"../proj.js\").TransformFunction} transformFn Transform function.\n     * Called with a flat array of geometry coordinates.\n     */\n    Geometry.prototype.applyTransform = function (transformFn) {\n        abstract();\n    };\n    /**\n     * Test if the geometry and the passed extent intersect.\n     * @abstract\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @return {boolean} `true` if the geometry and the extent intersect.\n     */\n    Geometry.prototype.intersectsExtent = function (extent) {\n        return abstract();\n    };\n    /**\n     * Translate the geometry.  This modifies the geometry coordinates in place.  If\n     * instead you want a new geometry, first `clone()` this geometry.\n     * @abstract\n     * @param {number} deltaX Delta X.\n     * @param {number} deltaY Delta Y.\n     * @api\n     */\n    Geometry.prototype.translate = function (deltaX, deltaY) {\n        abstract();\n    };\n    /**\n     * Transform each coordinate of the geometry from one coordinate reference\n     * system to another. The geometry is modified in place.\n     * For example, a line will be transformed to a line and a circle to a circle.\n     * If you do not want the geometry modified in place, first `clone()` it and\n     * then use this function on the clone.\n     *\n     * @param {import(\"../proj.js\").ProjectionLike} source The current projection.  Can be a\n     *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n     * @param {import(\"../proj.js\").ProjectionLike} destination The desired projection.  Can be a\n     *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n     * @return {Geometry} This geometry.  Note that original geometry is\n     *     modified in place.\n     * @api\n     */\n    Geometry.prototype.transform = function (source, destination) {\n        /** @type {import(\"../proj/Projection.js\").default} */\n        var sourceProj = getProjection(source);\n        var transformFn = sourceProj.getUnits() == Units.TILE_PIXELS\n            ? function (inCoordinates, outCoordinates, stride) {\n                var pixelExtent = sourceProj.getExtent();\n                var projectedExtent = sourceProj.getWorldExtent();\n                var scale = getHeight(projectedExtent) / getHeight(pixelExtent);\n                composeTransform(tmpTransform, projectedExtent[0], projectedExtent[3], scale, -scale, 0, 0, 0);\n                transform2D(inCoordinates, 0, inCoordinates.length, stride, tmpTransform, outCoordinates);\n                return getTransform(sourceProj, destination)(inCoordinates, outCoordinates, stride);\n            }\n            : getTransform(sourceProj, destination);\n        this.applyTransform(transformFn);\n        return this;\n    };\n    return Geometry;\n}(BaseObject));\nexport default Geometry;\n//# sourceMappingURL=Geometry.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/geom/GeometryCollection\n */\nimport EventType from '../events/EventType.js';\nimport Geometry from './Geometry.js';\nimport { closestSquaredDistanceXY, createOrUpdateEmpty, extend, getCenter, } from '../extent.js';\nimport { listen, unlistenByKey } from '../events.js';\n/**\n * @classdesc\n * An array of {@link module:ol/geom/Geometry~Geometry} objects.\n *\n * @api\n */\nvar GeometryCollection = /** @class */ (function (_super) {\n    __extends(GeometryCollection, _super);\n    /**\n     * @param {Array<Geometry>} [opt_geometries] Geometries.\n     */\n    function GeometryCollection(opt_geometries) {\n        var _this = _super.call(this) || this;\n        /**\n         * @private\n         * @type {Array<Geometry>}\n         */\n        _this.geometries_ = opt_geometries ? opt_geometries : null;\n        /**\n         * @type {Array<import(\"../events.js\").EventsKey>}\n         */\n        _this.changeEventsKeys_ = [];\n        _this.listenGeometriesChange_();\n        return _this;\n    }\n    /**\n     * @private\n     */\n    GeometryCollection.prototype.unlistenGeometriesChange_ = function () {\n        this.changeEventsKeys_.forEach(unlistenByKey);\n        this.changeEventsKeys_.length = 0;\n    };\n    /**\n     * @private\n     */\n    GeometryCollection.prototype.listenGeometriesChange_ = function () {\n        if (!this.geometries_) {\n            return;\n        }\n        for (var i = 0, ii = this.geometries_.length; i < ii; ++i) {\n            this.changeEventsKeys_.push(listen(this.geometries_[i], EventType.CHANGE, this.changed, this));\n        }\n    };\n    /**\n     * Make a complete copy of the geometry.\n     * @return {!GeometryCollection} Clone.\n     * @api\n     */\n    GeometryCollection.prototype.clone = function () {\n        var geometryCollection = new GeometryCollection(null);\n        geometryCollection.setGeometries(this.geometries_);\n        geometryCollection.applyProperties(this);\n        return geometryCollection;\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n     * @param {number} minSquaredDistance Minimum squared distance.\n     * @return {number} Minimum squared distance.\n     */\n    GeometryCollection.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {\n        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n            return minSquaredDistance;\n        }\n        var geometries = this.geometries_;\n        for (var i = 0, ii = geometries.length; i < ii; ++i) {\n            minSquaredDistance = geometries[i].closestPointXY(x, y, closestPoint, minSquaredDistance);\n        }\n        return minSquaredDistance;\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @return {boolean} Contains (x, y).\n     */\n    GeometryCollection.prototype.containsXY = function (x, y) {\n        var geometries = this.geometries_;\n        for (var i = 0, ii = geometries.length; i < ii; ++i) {\n            if (geometries[i].containsXY(x, y)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @protected\n     * @return {import(\"../extent.js\").Extent} extent Extent.\n     */\n    GeometryCollection.prototype.computeExtent = function (extent) {\n        createOrUpdateEmpty(extent);\n        var geometries = this.geometries_;\n        for (var i = 0, ii = geometries.length; i < ii; ++i) {\n            extend(extent, geometries[i].getExtent());\n        }\n        return extent;\n    };\n    /**\n     * Return the geometries that make up this geometry collection.\n     * @return {Array<Geometry>} Geometries.\n     * @api\n     */\n    GeometryCollection.prototype.getGeometries = function () {\n        return cloneGeometries(this.geometries_);\n    };\n    /**\n     * @return {Array<Geometry>} Geometries.\n     */\n    GeometryCollection.prototype.getGeometriesArray = function () {\n        return this.geometries_;\n    };\n    /**\n     * @return {Array<Geometry>} Geometries.\n     */\n    GeometryCollection.prototype.getGeometriesArrayRecursive = function () {\n        /** @type {Array<Geometry>} */\n        var geometriesArray = [];\n        var geometries = this.geometries_;\n        for (var i = 0, ii = geometries.length; i < ii; ++i) {\n            if (geometries[i].getType() === this.getType()) {\n                geometriesArray = geometriesArray.concat(\n                /** @type {GeometryCollection} */ (geometries[i]).getGeometriesArrayRecursive());\n            }\n            else {\n                geometriesArray.push(geometries[i]);\n            }\n        }\n        return geometriesArray;\n    };\n    /**\n     * Create a simplified version of this geometry using the Douglas Peucker algorithm.\n     * @param {number} squaredTolerance Squared tolerance.\n     * @return {GeometryCollection} Simplified GeometryCollection.\n     */\n    GeometryCollection.prototype.getSimplifiedGeometry = function (squaredTolerance) {\n        if (this.simplifiedGeometryRevision !== this.getRevision()) {\n            this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n            this.simplifiedGeometryRevision = this.getRevision();\n        }\n        if (squaredTolerance < 0 ||\n            (this.simplifiedGeometryMaxMinSquaredTolerance !== 0 &&\n                squaredTolerance < this.simplifiedGeometryMaxMinSquaredTolerance)) {\n            return this;\n        }\n        var simplifiedGeometries = [];\n        var geometries = this.geometries_;\n        var simplified = false;\n        for (var i = 0, ii = geometries.length; i < ii; ++i) {\n            var geometry = geometries[i];\n            var simplifiedGeometry = geometry.getSimplifiedGeometry(squaredTolerance);\n            simplifiedGeometries.push(simplifiedGeometry);\n            if (simplifiedGeometry !== geometry) {\n                simplified = true;\n            }\n        }\n        if (simplified) {\n            var simplifiedGeometryCollection = new GeometryCollection(null);\n            simplifiedGeometryCollection.setGeometriesArray(simplifiedGeometries);\n            return simplifiedGeometryCollection;\n        }\n        else {\n            this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;\n            return this;\n        }\n    };\n    /**\n     * Get the type of this geometry.\n     * @return {import(\"./Geometry.js\").Type} Geometry type.\n     * @api\n     */\n    GeometryCollection.prototype.getType = function () {\n        return 'GeometryCollection';\n    };\n    /**\n     * Test if the geometry and the passed extent intersect.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @return {boolean} `true` if the geometry and the extent intersect.\n     * @api\n     */\n    GeometryCollection.prototype.intersectsExtent = function (extent) {\n        var geometries = this.geometries_;\n        for (var i = 0, ii = geometries.length; i < ii; ++i) {\n            if (geometries[i].intersectsExtent(extent)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * @return {boolean} Is empty.\n     */\n    GeometryCollection.prototype.isEmpty = function () {\n        return this.geometries_.length === 0;\n    };\n    /**\n     * Rotate the geometry around a given coordinate. This modifies the geometry\n     * coordinates in place.\n     * @param {number} angle Rotation angle in radians.\n     * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\n     * @api\n     */\n    GeometryCollection.prototype.rotate = function (angle, anchor) {\n        var geometries = this.geometries_;\n        for (var i = 0, ii = geometries.length; i < ii; ++i) {\n            geometries[i].rotate(angle, anchor);\n        }\n        this.changed();\n    };\n    /**\n     * Scale the geometry (with an optional origin).  This modifies the geometry\n     * coordinates in place.\n     * @abstract\n     * @param {number} sx The scaling factor in the x-direction.\n     * @param {number} [opt_sy] The scaling factor in the y-direction (defaults to sx).\n     * @param {import(\"../coordinate.js\").Coordinate} [opt_anchor] The scale origin (defaults to the center\n     *     of the geometry extent).\n     * @api\n     */\n    GeometryCollection.prototype.scale = function (sx, opt_sy, opt_anchor) {\n        var anchor = opt_anchor;\n        if (!anchor) {\n            anchor = getCenter(this.getExtent());\n        }\n        var geometries = this.geometries_;\n        for (var i = 0, ii = geometries.length; i < ii; ++i) {\n            geometries[i].scale(sx, opt_sy, anchor);\n        }\n        this.changed();\n    };\n    /**\n     * Set the geometries that make up this geometry collection.\n     * @param {Array<Geometry>} geometries Geometries.\n     * @api\n     */\n    GeometryCollection.prototype.setGeometries = function (geometries) {\n        this.setGeometriesArray(cloneGeometries(geometries));\n    };\n    /**\n     * @param {Array<Geometry>} geometries Geometries.\n     */\n    GeometryCollection.prototype.setGeometriesArray = function (geometries) {\n        this.unlistenGeometriesChange_();\n        this.geometries_ = geometries;\n        this.listenGeometriesChange_();\n        this.changed();\n    };\n    /**\n     * Apply a transform function to the coordinates of the geometry.\n     * The geometry is modified in place.\n     * If you do not want the geometry modified in place, first `clone()` it and\n     * then use this function on the clone.\n     * @param {import(\"../proj.js\").TransformFunction} transformFn Transform function.\n     * Called with a flat array of geometry coordinates.\n     * @api\n     */\n    GeometryCollection.prototype.applyTransform = function (transformFn) {\n        var geometries = this.geometries_;\n        for (var i = 0, ii = geometries.length; i < ii; ++i) {\n            geometries[i].applyTransform(transformFn);\n        }\n        this.changed();\n    };\n    /**\n     * Translate the geometry.  This modifies the geometry coordinates in place.  If\n     * instead you want a new geometry, first `clone()` this geometry.\n     * @param {number} deltaX Delta X.\n     * @param {number} deltaY Delta Y.\n     * @api\n     */\n    GeometryCollection.prototype.translate = function (deltaX, deltaY) {\n        var geometries = this.geometries_;\n        for (var i = 0, ii = geometries.length; i < ii; ++i) {\n            geometries[i].translate(deltaX, deltaY);\n        }\n        this.changed();\n    };\n    /**\n     * Clean up.\n     */\n    GeometryCollection.prototype.disposeInternal = function () {\n        this.unlistenGeometriesChange_();\n        _super.prototype.disposeInternal.call(this);\n    };\n    return GeometryCollection;\n}(Geometry));\n/**\n * @param {Array<Geometry>} geometries Geometries.\n * @return {Array<Geometry>} Cloned geometries.\n */\nfunction cloneGeometries(geometries) {\n    var clonedGeometries = [];\n    for (var i = 0, ii = geometries.length; i < ii; ++i) {\n        clonedGeometries.push(geometries[i].clone());\n    }\n    return clonedGeometries;\n}\nexport default GeometryCollection;\n//# sourceMappingURL=GeometryCollection.js.map","/**\n * @module ol/geom/GeometryLayout\n */\n/**\n * The coordinate layout for geometries, indicating whether a 3rd or 4th z ('Z')\n * or measure ('M') coordinate is available. Supported values are `'XY'`,\n * `'XYZ'`, `'XYM'`, `'XYZM'`.\n * @enum {string}\n */\nexport default {\n    XY: 'XY',\n    XYZ: 'XYZ',\n    XYM: 'XYM',\n    XYZM: 'XYZM',\n};\n//# sourceMappingURL=GeometryLayout.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/geom/LineString\n */\nimport GeometryLayout from './GeometryLayout.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport { assignClosestPoint, maxSquaredDelta } from './flat/closest.js';\nimport { closestSquaredDistanceXY } from '../extent.js';\nimport { deflateCoordinates } from './flat/deflate.js';\nimport { douglasPeucker } from './flat/simplify.js';\nimport { extend } from '../array.js';\nimport { forEach as forEachSegment } from './flat/segments.js';\nimport { inflateCoordinates } from './flat/inflate.js';\nimport { interpolatePoint, lineStringCoordinateAtM } from './flat/interpolate.js';\nimport { intersectsLineString } from './flat/intersectsextent.js';\nimport { lineStringLength } from './flat/length.js';\n/**\n * @classdesc\n * Linestring geometry.\n *\n * @api\n */\nvar LineString = /** @class */ (function (_super) {\n    __extends(LineString, _super);\n    /**\n     * @param {Array<import(\"../coordinate.js\").Coordinate>|Array<number>} coordinates Coordinates.\n     *     For internal use, flat coordinates in combination with `opt_layout` are also accepted.\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     */\n    function LineString(coordinates, opt_layout) {\n        var _this = _super.call(this) || this;\n        /**\n         * @private\n         * @type {import(\"../coordinate.js\").Coordinate}\n         */\n        _this.flatMidpoint_ = null;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.flatMidpointRevision_ = -1;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.maxDelta_ = -1;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.maxDeltaRevision_ = -1;\n        if (opt_layout !== undefined && !Array.isArray(coordinates[0])) {\n            _this.setFlatCoordinates(opt_layout, \n            /** @type {Array<number>} */ (coordinates));\n        }\n        else {\n            _this.setCoordinates(\n            /** @type {Array<import(\"../coordinate.js\").Coordinate>} */ (coordinates), opt_layout);\n        }\n        return _this;\n    }\n    /**\n     * Append the passed coordinate to the coordinates of the linestring.\n     * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @api\n     */\n    LineString.prototype.appendCoordinate = function (coordinate) {\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = coordinate.slice();\n        }\n        else {\n            extend(this.flatCoordinates, coordinate);\n        }\n        this.changed();\n    };\n    /**\n     * Make a complete copy of the geometry.\n     * @return {!LineString} Clone.\n     * @api\n     */\n    LineString.prototype.clone = function () {\n        var lineString = new LineString(this.flatCoordinates.slice(), this.layout);\n        lineString.applyProperties(this);\n        return lineString;\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n     * @param {number} minSquaredDistance Minimum squared distance.\n     * @return {number} Minimum squared distance.\n     */\n    LineString.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {\n        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n            return minSquaredDistance;\n        }\n        if (this.maxDeltaRevision_ != this.getRevision()) {\n            this.maxDelta_ = Math.sqrt(maxSquaredDelta(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));\n            this.maxDeltaRevision_ = this.getRevision();\n        }\n        return assignClosestPoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);\n    };\n    /**\n     * Iterate over each segment, calling the provided callback.\n     * If the callback returns a truthy value the function returns that\n     * value immediately. Otherwise the function returns `false`.\n     *\n     * @param {function(this: S, import(\"../coordinate.js\").Coordinate, import(\"../coordinate.js\").Coordinate): T} callback Function\n     *     called for each segment. The function will receive two arguments, the start and end coordinates of the segment.\n     * @return {T|boolean} Value.\n     * @template T,S\n     * @api\n     */\n    LineString.prototype.forEachSegment = function (callback) {\n        return forEachSegment(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, callback);\n    };\n    /**\n     * Returns the coordinate at `m` using linear interpolation, or `null` if no\n     * such coordinate exists.\n     *\n     * `opt_extrapolate` controls extrapolation beyond the range of Ms in the\n     * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first\n     * M will return the first coordinate and Ms greater than the last M will\n     * return the last coordinate.\n     *\n     * @param {number} m M.\n     * @param {boolean} [opt_extrapolate] Extrapolate. Default is `false`.\n     * @return {import(\"../coordinate.js\").Coordinate|null} Coordinate.\n     * @api\n     */\n    LineString.prototype.getCoordinateAtM = function (m, opt_extrapolate) {\n        if (this.layout != GeometryLayout.XYM &&\n            this.layout != GeometryLayout.XYZM) {\n            return null;\n        }\n        var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;\n        return lineStringCoordinateAtM(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, m, extrapolate);\n    };\n    /**\n     * Return the coordinates of the linestring.\n     * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates.\n     * @api\n     */\n    LineString.prototype.getCoordinates = function () {\n        return inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n    };\n    /**\n     * Return the coordinate at the provided fraction along the linestring.\n     * The `fraction` is a number between 0 and 1, where 0 is the start of the\n     * linestring and 1 is the end.\n     * @param {number} fraction Fraction.\n     * @param {import(\"../coordinate.js\").Coordinate} [opt_dest] Optional coordinate whose values will\n     *     be modified. If not provided, a new coordinate will be returned.\n     * @return {import(\"../coordinate.js\").Coordinate} Coordinate of the interpolated point.\n     * @api\n     */\n    LineString.prototype.getCoordinateAt = function (fraction, opt_dest) {\n        return interpolatePoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, fraction, opt_dest, this.stride);\n    };\n    /**\n     * Return the length of the linestring on projected plane.\n     * @return {number} Length (on projected plane).\n     * @api\n     */\n    LineString.prototype.getLength = function () {\n        return lineStringLength(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n    };\n    /**\n     * @return {Array<number>} Flat midpoint.\n     */\n    LineString.prototype.getFlatMidpoint = function () {\n        if (this.flatMidpointRevision_ != this.getRevision()) {\n            this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_);\n            this.flatMidpointRevision_ = this.getRevision();\n        }\n        return this.flatMidpoint_;\n    };\n    /**\n     * @param {number} squaredTolerance Squared tolerance.\n     * @return {LineString} Simplified LineString.\n     * @protected\n     */\n    LineString.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {\n        var simplifiedFlatCoordinates = [];\n        simplifiedFlatCoordinates.length = douglasPeucker(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);\n        return new LineString(simplifiedFlatCoordinates, GeometryLayout.XY);\n    };\n    /**\n     * Get the type of this geometry.\n     * @return {import(\"./Geometry.js\").Type} Geometry type.\n     * @api\n     */\n    LineString.prototype.getType = function () {\n        return 'LineString';\n    };\n    /**\n     * Test if the geometry and the passed extent intersect.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @return {boolean} `true` if the geometry and the extent intersect.\n     * @api\n     */\n    LineString.prototype.intersectsExtent = function (extent) {\n        return intersectsLineString(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);\n    };\n    /**\n     * Set the coordinates of the linestring.\n     * @param {!Array<import(\"../coordinate.js\").Coordinate>} coordinates Coordinates.\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     * @api\n     */\n    LineString.prototype.setCoordinates = function (coordinates, opt_layout) {\n        this.setLayout(opt_layout, coordinates, 1);\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = [];\n        }\n        this.flatCoordinates.length = deflateCoordinates(this.flatCoordinates, 0, coordinates, this.stride);\n        this.changed();\n    };\n    return LineString;\n}(SimpleGeometry));\nexport default LineString;\n//# sourceMappingURL=LineString.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/geom/LinearRing\n */\nimport GeometryLayout from './GeometryLayout.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport { assignClosestPoint, maxSquaredDelta } from './flat/closest.js';\nimport { closestSquaredDistanceXY } from '../extent.js';\nimport { deflateCoordinates } from './flat/deflate.js';\nimport { douglasPeucker } from './flat/simplify.js';\nimport { inflateCoordinates } from './flat/inflate.js';\nimport { linearRing as linearRingArea } from './flat/area.js';\n/**\n * @classdesc\n * Linear ring geometry. Only used as part of polygon; cannot be rendered\n * on its own.\n *\n * @api\n */\nvar LinearRing = /** @class */ (function (_super) {\n    __extends(LinearRing, _super);\n    /**\n     * @param {Array<import(\"../coordinate.js\").Coordinate>|Array<number>} coordinates Coordinates.\n     *     For internal use, flat coordinates in combination with `opt_layout` are also accepted.\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     */\n    function LinearRing(coordinates, opt_layout) {\n        var _this = _super.call(this) || this;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.maxDelta_ = -1;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.maxDeltaRevision_ = -1;\n        if (opt_layout !== undefined && !Array.isArray(coordinates[0])) {\n            _this.setFlatCoordinates(opt_layout, \n            /** @type {Array<number>} */ (coordinates));\n        }\n        else {\n            _this.setCoordinates(\n            /** @type {Array<import(\"../coordinate.js\").Coordinate>} */ (coordinates), opt_layout);\n        }\n        return _this;\n    }\n    /**\n     * Make a complete copy of the geometry.\n     * @return {!LinearRing} Clone.\n     * @api\n     */\n    LinearRing.prototype.clone = function () {\n        return new LinearRing(this.flatCoordinates.slice(), this.layout);\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n     * @param {number} minSquaredDistance Minimum squared distance.\n     * @return {number} Minimum squared distance.\n     */\n    LinearRing.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {\n        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n            return minSquaredDistance;\n        }\n        if (this.maxDeltaRevision_ != this.getRevision()) {\n            this.maxDelta_ = Math.sqrt(maxSquaredDelta(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));\n            this.maxDeltaRevision_ = this.getRevision();\n        }\n        return assignClosestPoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);\n    };\n    /**\n     * Return the area of the linear ring on projected plane.\n     * @return {number} Area (on projected plane).\n     * @api\n     */\n    LinearRing.prototype.getArea = function () {\n        return linearRingArea(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n    };\n    /**\n     * Return the coordinates of the linear ring.\n     * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates.\n     * @api\n     */\n    LinearRing.prototype.getCoordinates = function () {\n        return inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n    };\n    /**\n     * @param {number} squaredTolerance Squared tolerance.\n     * @return {LinearRing} Simplified LinearRing.\n     * @protected\n     */\n    LinearRing.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {\n        var simplifiedFlatCoordinates = [];\n        simplifiedFlatCoordinates.length = douglasPeucker(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);\n        return new LinearRing(simplifiedFlatCoordinates, GeometryLayout.XY);\n    };\n    /**\n     * Get the type of this geometry.\n     * @return {import(\"./Geometry.js\").Type} Geometry type.\n     * @api\n     */\n    LinearRing.prototype.getType = function () {\n        return 'LinearRing';\n    };\n    /**\n     * Test if the geometry and the passed extent intersect.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @return {boolean} `true` if the geometry and the extent intersect.\n     * @api\n     */\n    LinearRing.prototype.intersectsExtent = function (extent) {\n        return false;\n    };\n    /**\n     * Set the coordinates of the linear ring.\n     * @param {!Array<import(\"../coordinate.js\").Coordinate>} coordinates Coordinates.\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     * @api\n     */\n    LinearRing.prototype.setCoordinates = function (coordinates, opt_layout) {\n        this.setLayout(opt_layout, coordinates, 1);\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = [];\n        }\n        this.flatCoordinates.length = deflateCoordinates(this.flatCoordinates, 0, coordinates, this.stride);\n        this.changed();\n    };\n    return LinearRing;\n}(SimpleGeometry));\nexport default LinearRing;\n//# sourceMappingURL=LinearRing.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/geom/MultiLineString\n */\nimport GeometryLayout from './GeometryLayout.js';\nimport LineString from './LineString.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport { arrayMaxSquaredDelta, assignClosestArrayPoint } from './flat/closest.js';\nimport { closestSquaredDistanceXY } from '../extent.js';\nimport { deflateCoordinatesArray } from './flat/deflate.js';\nimport { douglasPeuckerArray } from './flat/simplify.js';\nimport { extend } from '../array.js';\nimport { inflateCoordinatesArray } from './flat/inflate.js';\nimport { interpolatePoint, lineStringsCoordinateAtM, } from './flat/interpolate.js';\nimport { intersectsLineStringArray } from './flat/intersectsextent.js';\n/**\n * @classdesc\n * Multi-linestring geometry.\n *\n * @api\n */\nvar MultiLineString = /** @class */ (function (_super) {\n    __extends(MultiLineString, _super);\n    /**\n     * @param {Array<Array<import(\"../coordinate.js\").Coordinate>|LineString>|Array<number>} coordinates\n     *     Coordinates or LineString geometries. (For internal use, flat coordinates in\n     *     combination with `opt_layout` and `opt_ends` are also accepted.)\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     * @param {Array<number>} [opt_ends] Flat coordinate ends for internal use.\n     */\n    function MultiLineString(coordinates, opt_layout, opt_ends) {\n        var _this = _super.call(this) || this;\n        /**\n         * @type {Array<number>}\n         * @private\n         */\n        _this.ends_ = [];\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.maxDelta_ = -1;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.maxDeltaRevision_ = -1;\n        if (Array.isArray(coordinates[0])) {\n            _this.setCoordinates(\n            /** @type {Array<Array<import(\"../coordinate.js\").Coordinate>>} */ (coordinates), opt_layout);\n        }\n        else if (opt_layout !== undefined && opt_ends) {\n            _this.setFlatCoordinates(opt_layout, \n            /** @type {Array<number>} */ (coordinates));\n            _this.ends_ = opt_ends;\n        }\n        else {\n            var layout = _this.getLayout();\n            var lineStrings = /** @type {Array<LineString>} */ (coordinates);\n            var flatCoordinates = [];\n            var ends = [];\n            for (var i = 0, ii = lineStrings.length; i < ii; ++i) {\n                var lineString = lineStrings[i];\n                if (i === 0) {\n                    layout = lineString.getLayout();\n                }\n                extend(flatCoordinates, lineString.getFlatCoordinates());\n                ends.push(flatCoordinates.length);\n            }\n            _this.setFlatCoordinates(layout, flatCoordinates);\n            _this.ends_ = ends;\n        }\n        return _this;\n    }\n    /**\n     * Append the passed linestring to the multilinestring.\n     * @param {LineString} lineString LineString.\n     * @api\n     */\n    MultiLineString.prototype.appendLineString = function (lineString) {\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = lineString.getFlatCoordinates().slice();\n        }\n        else {\n            extend(this.flatCoordinates, lineString.getFlatCoordinates().slice());\n        }\n        this.ends_.push(this.flatCoordinates.length);\n        this.changed();\n    };\n    /**\n     * Make a complete copy of the geometry.\n     * @return {!MultiLineString} Clone.\n     * @api\n     */\n    MultiLineString.prototype.clone = function () {\n        var multiLineString = new MultiLineString(this.flatCoordinates.slice(), this.layout, this.ends_.slice());\n        multiLineString.applyProperties(this);\n        return multiLineString;\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n     * @param {number} minSquaredDistance Minimum squared distance.\n     * @return {number} Minimum squared distance.\n     */\n    MultiLineString.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {\n        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n            return minSquaredDistance;\n        }\n        if (this.maxDeltaRevision_ != this.getRevision()) {\n            this.maxDelta_ = Math.sqrt(arrayMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0));\n            this.maxDeltaRevision_ = this.getRevision();\n        }\n        return assignClosestArrayPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);\n    };\n    /**\n     * Returns the coordinate at `m` using linear interpolation, or `null` if no\n     * such coordinate exists.\n     *\n     * `opt_extrapolate` controls extrapolation beyond the range of Ms in the\n     * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first\n     * M will return the first coordinate and Ms greater than the last M will\n     * return the last coordinate.\n     *\n     * `opt_interpolate` controls interpolation between consecutive LineStrings\n     * within the MultiLineString. If `opt_interpolate` is `true` the coordinates\n     * will be linearly interpolated between the last coordinate of one LineString\n     * and the first coordinate of the next LineString.  If `opt_interpolate` is\n     * `false` then the function will return `null` for Ms falling between\n     * LineStrings.\n     *\n     * @param {number} m M.\n     * @param {boolean} [opt_extrapolate] Extrapolate. Default is `false`.\n     * @param {boolean} [opt_interpolate] Interpolate. Default is `false`.\n     * @return {import(\"../coordinate.js\").Coordinate|null} Coordinate.\n     * @api\n     */\n    MultiLineString.prototype.getCoordinateAtM = function (m, opt_extrapolate, opt_interpolate) {\n        if ((this.layout != GeometryLayout.XYM &&\n            this.layout != GeometryLayout.XYZM) ||\n            this.flatCoordinates.length === 0) {\n            return null;\n        }\n        var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;\n        var interpolate = opt_interpolate !== undefined ? opt_interpolate : false;\n        return lineStringsCoordinateAtM(this.flatCoordinates, 0, this.ends_, this.stride, m, extrapolate, interpolate);\n    };\n    /**\n     * Return the coordinates of the multilinestring.\n     * @return {Array<Array<import(\"../coordinate.js\").Coordinate>>} Coordinates.\n     * @api\n     */\n    MultiLineString.prototype.getCoordinates = function () {\n        return inflateCoordinatesArray(this.flatCoordinates, 0, this.ends_, this.stride);\n    };\n    /**\n     * @return {Array<number>} Ends.\n     */\n    MultiLineString.prototype.getEnds = function () {\n        return this.ends_;\n    };\n    /**\n     * Return the linestring at the specified index.\n     * @param {number} index Index.\n     * @return {LineString} LineString.\n     * @api\n     */\n    MultiLineString.prototype.getLineString = function (index) {\n        if (index < 0 || this.ends_.length <= index) {\n            return null;\n        }\n        return new LineString(this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);\n    };\n    /**\n     * Return the linestrings of this multilinestring.\n     * @return {Array<LineString>} LineStrings.\n     * @api\n     */\n    MultiLineString.prototype.getLineStrings = function () {\n        var flatCoordinates = this.flatCoordinates;\n        var ends = this.ends_;\n        var layout = this.layout;\n        /** @type {Array<LineString>} */\n        var lineStrings = [];\n        var offset = 0;\n        for (var i = 0, ii = ends.length; i < ii; ++i) {\n            var end = ends[i];\n            var lineString = new LineString(flatCoordinates.slice(offset, end), layout);\n            lineStrings.push(lineString);\n            offset = end;\n        }\n        return lineStrings;\n    };\n    /**\n     * @return {Array<number>} Flat midpoints.\n     */\n    MultiLineString.prototype.getFlatMidpoints = function () {\n        var midpoints = [];\n        var flatCoordinates = this.flatCoordinates;\n        var offset = 0;\n        var ends = this.ends_;\n        var stride = this.stride;\n        for (var i = 0, ii = ends.length; i < ii; ++i) {\n            var end = ends[i];\n            var midpoint = interpolatePoint(flatCoordinates, offset, end, stride, 0.5);\n            extend(midpoints, midpoint);\n            offset = end;\n        }\n        return midpoints;\n    };\n    /**\n     * @param {number} squaredTolerance Squared tolerance.\n     * @return {MultiLineString} Simplified MultiLineString.\n     * @protected\n     */\n    MultiLineString.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {\n        var simplifiedFlatCoordinates = [];\n        var simplifiedEnds = [];\n        simplifiedFlatCoordinates.length = douglasPeuckerArray(this.flatCoordinates, 0, this.ends_, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0, simplifiedEnds);\n        return new MultiLineString(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEnds);\n    };\n    /**\n     * Get the type of this geometry.\n     * @return {import(\"./Geometry.js\").Type} Geometry type.\n     * @api\n     */\n    MultiLineString.prototype.getType = function () {\n        return 'MultiLineString';\n    };\n    /**\n     * Test if the geometry and the passed extent intersect.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @return {boolean} `true` if the geometry and the extent intersect.\n     * @api\n     */\n    MultiLineString.prototype.intersectsExtent = function (extent) {\n        return intersectsLineStringArray(this.flatCoordinates, 0, this.ends_, this.stride, extent);\n    };\n    /**\n     * Set the coordinates of the multilinestring.\n     * @param {!Array<Array<import(\"../coordinate.js\").Coordinate>>} coordinates Coordinates.\n     * @param {GeometryLayout} [opt_layout] Layout.\n     * @api\n     */\n    MultiLineString.prototype.setCoordinates = function (coordinates, opt_layout) {\n        this.setLayout(opt_layout, coordinates, 2);\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = [];\n        }\n        var ends = deflateCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);\n        this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];\n        this.changed();\n    };\n    return MultiLineString;\n}(SimpleGeometry));\nexport default MultiLineString;\n//# sourceMappingURL=MultiLineString.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/geom/MultiPoint\n */\nimport Point from './Point.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport { closestSquaredDistanceXY, containsXY } from '../extent.js';\nimport { deflateCoordinates } from './flat/deflate.js';\nimport { extend } from '../array.js';\nimport { inflateCoordinates } from './flat/inflate.js';\nimport { squaredDistance as squaredDx } from '../math.js';\n/**\n * @classdesc\n * Multi-point geometry.\n *\n * @api\n */\nvar MultiPoint = /** @class */ (function (_super) {\n    __extends(MultiPoint, _super);\n    /**\n     * @param {Array<import(\"../coordinate.js\").Coordinate>|Array<number>} coordinates Coordinates.\n     *     For internal use, flat coordinates in combination with `opt_layout` are also accepted.\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     */\n    function MultiPoint(coordinates, opt_layout) {\n        var _this = _super.call(this) || this;\n        if (opt_layout && !Array.isArray(coordinates[0])) {\n            _this.setFlatCoordinates(opt_layout, \n            /** @type {Array<number>} */ (coordinates));\n        }\n        else {\n            _this.setCoordinates(\n            /** @type {Array<import(\"../coordinate.js\").Coordinate>} */ (coordinates), opt_layout);\n        }\n        return _this;\n    }\n    /**\n     * Append the passed point to this multipoint.\n     * @param {Point} point Point.\n     * @api\n     */\n    MultiPoint.prototype.appendPoint = function (point) {\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = point.getFlatCoordinates().slice();\n        }\n        else {\n            extend(this.flatCoordinates, point.getFlatCoordinates());\n        }\n        this.changed();\n    };\n    /**\n     * Make a complete copy of the geometry.\n     * @return {!MultiPoint} Clone.\n     * @api\n     */\n    MultiPoint.prototype.clone = function () {\n        var multiPoint = new MultiPoint(this.flatCoordinates.slice(), this.layout);\n        multiPoint.applyProperties(this);\n        return multiPoint;\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n     * @param {number} minSquaredDistance Minimum squared distance.\n     * @return {number} Minimum squared distance.\n     */\n    MultiPoint.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {\n        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n            return minSquaredDistance;\n        }\n        var flatCoordinates = this.flatCoordinates;\n        var stride = this.stride;\n        for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n            var squaredDistance = squaredDx(x, y, flatCoordinates[i], flatCoordinates[i + 1]);\n            if (squaredDistance < minSquaredDistance) {\n                minSquaredDistance = squaredDistance;\n                for (var j = 0; j < stride; ++j) {\n                    closestPoint[j] = flatCoordinates[i + j];\n                }\n                closestPoint.length = stride;\n            }\n        }\n        return minSquaredDistance;\n    };\n    /**\n     * Return the coordinates of the multipoint.\n     * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates.\n     * @api\n     */\n    MultiPoint.prototype.getCoordinates = function () {\n        return inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n    };\n    /**\n     * Return the point at the specified index.\n     * @param {number} index Index.\n     * @return {Point} Point.\n     * @api\n     */\n    MultiPoint.prototype.getPoint = function (index) {\n        var n = !this.flatCoordinates\n            ? 0\n            : this.flatCoordinates.length / this.stride;\n        if (index < 0 || n <= index) {\n            return null;\n        }\n        return new Point(this.flatCoordinates.slice(index * this.stride, (index + 1) * this.stride), this.layout);\n    };\n    /**\n     * Return the points of this multipoint.\n     * @return {Array<Point>} Points.\n     * @api\n     */\n    MultiPoint.prototype.getPoints = function () {\n        var flatCoordinates = this.flatCoordinates;\n        var layout = this.layout;\n        var stride = this.stride;\n        /** @type {Array<Point>} */\n        var points = [];\n        for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n            var point = new Point(flatCoordinates.slice(i, i + stride), layout);\n            points.push(point);\n        }\n        return points;\n    };\n    /**\n     * Get the type of this geometry.\n     * @return {import(\"./Geometry.js\").Type} Geometry type.\n     * @api\n     */\n    MultiPoint.prototype.getType = function () {\n        return 'MultiPoint';\n    };\n    /**\n     * Test if the geometry and the passed extent intersect.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @return {boolean} `true` if the geometry and the extent intersect.\n     * @api\n     */\n    MultiPoint.prototype.intersectsExtent = function (extent) {\n        var flatCoordinates = this.flatCoordinates;\n        var stride = this.stride;\n        for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n            var x = flatCoordinates[i];\n            var y = flatCoordinates[i + 1];\n            if (containsXY(extent, x, y)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * Set the coordinates of the multipoint.\n     * @param {!Array<import(\"../coordinate.js\").Coordinate>} coordinates Coordinates.\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     * @api\n     */\n    MultiPoint.prototype.setCoordinates = function (coordinates, opt_layout) {\n        this.setLayout(opt_layout, coordinates, 1);\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = [];\n        }\n        this.flatCoordinates.length = deflateCoordinates(this.flatCoordinates, 0, coordinates, this.stride);\n        this.changed();\n    };\n    return MultiPoint;\n}(SimpleGeometry));\nexport default MultiPoint;\n//# sourceMappingURL=MultiPoint.js.map","/**\n * @module ol/geom/flat/center\n */\nimport { createEmpty, createOrUpdateFromFlatCoordinates } from '../../extent.js';\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @return {Array<number>} Flat centers.\n */\nexport function linearRingss(flatCoordinates, offset, endss, stride) {\n    var flatCenters = [];\n    var extent = createEmpty();\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n        var ends = endss[i];\n        extent = createOrUpdateFromFlatCoordinates(flatCoordinates, offset, ends[0], stride);\n        flatCenters.push((extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2);\n        offset = ends[ends.length - 1];\n    }\n    return flatCenters;\n}\n//# sourceMappingURL=center.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/geom/MultiPolygon\n */\nimport GeometryLayout from './GeometryLayout.js';\nimport MultiPoint from './MultiPoint.js';\nimport Polygon from './Polygon.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport { assignClosestMultiArrayPoint, multiArrayMaxSquaredDelta, } from './flat/closest.js';\nimport { closestSquaredDistanceXY } from '../extent.js';\nimport { deflateMultiCoordinatesArray } from './flat/deflate.js';\nimport { extend } from '../array.js';\nimport { getInteriorPointsOfMultiArray } from './flat/interiorpoint.js';\nimport { inflateMultiCoordinatesArray } from './flat/inflate.js';\nimport { intersectsLinearRingMultiArray } from './flat/intersectsextent.js';\nimport { linearRingssAreOriented, orientLinearRingsArray, } from './flat/orient.js';\nimport { linearRingss as linearRingssArea } from './flat/area.js';\nimport { linearRingss as linearRingssCenter } from './flat/center.js';\nimport { linearRingssContainsXY } from './flat/contains.js';\nimport { quantizeMultiArray } from './flat/simplify.js';\n/**\n * @classdesc\n * Multi-polygon geometry.\n *\n * @api\n */\nvar MultiPolygon = /** @class */ (function (_super) {\n    __extends(MultiPolygon, _super);\n    /**\n     * @param {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.\n     *     For internal use, flat coordinates in combination with `opt_layout` and `opt_endss` are also accepted.\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     * @param {Array<Array<number>>} [opt_endss] Array of ends for internal use with flat coordinates.\n     */\n    function MultiPolygon(coordinates, opt_layout, opt_endss) {\n        var _this = _super.call(this) || this;\n        /**\n         * @type {Array<Array<number>>}\n         * @private\n         */\n        _this.endss_ = [];\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.flatInteriorPointsRevision_ = -1;\n        /**\n         * @private\n         * @type {Array<number>}\n         */\n        _this.flatInteriorPoints_ = null;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.maxDelta_ = -1;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.maxDeltaRevision_ = -1;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.orientedRevision_ = -1;\n        /**\n         * @private\n         * @type {Array<number>}\n         */\n        _this.orientedFlatCoordinates_ = null;\n        if (!opt_endss && !Array.isArray(coordinates[0])) {\n            var layout = _this.getLayout();\n            var polygons = /** @type {Array<Polygon>} */ (coordinates);\n            var flatCoordinates = [];\n            var endss = [];\n            for (var i = 0, ii = polygons.length; i < ii; ++i) {\n                var polygon = polygons[i];\n                if (i === 0) {\n                    layout = polygon.getLayout();\n                }\n                var offset = flatCoordinates.length;\n                var ends = polygon.getEnds();\n                for (var j = 0, jj = ends.length; j < jj; ++j) {\n                    ends[j] += offset;\n                }\n                extend(flatCoordinates, polygon.getFlatCoordinates());\n                endss.push(ends);\n            }\n            opt_layout = layout;\n            coordinates = flatCoordinates;\n            opt_endss = endss;\n        }\n        if (opt_layout !== undefined && opt_endss) {\n            _this.setFlatCoordinates(opt_layout, \n            /** @type {Array<number>} */ (coordinates));\n            _this.endss_ = opt_endss;\n        }\n        else {\n            _this.setCoordinates(\n            /** @type {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} */ (coordinates), opt_layout);\n        }\n        return _this;\n    }\n    /**\n     * Append the passed polygon to this multipolygon.\n     * @param {Polygon} polygon Polygon.\n     * @api\n     */\n    MultiPolygon.prototype.appendPolygon = function (polygon) {\n        /** @type {Array<number>} */\n        var ends;\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = polygon.getFlatCoordinates().slice();\n            ends = polygon.getEnds().slice();\n            this.endss_.push();\n        }\n        else {\n            var offset = this.flatCoordinates.length;\n            extend(this.flatCoordinates, polygon.getFlatCoordinates());\n            ends = polygon.getEnds().slice();\n            for (var i = 0, ii = ends.length; i < ii; ++i) {\n                ends[i] += offset;\n            }\n        }\n        this.endss_.push(ends);\n        this.changed();\n    };\n    /**\n     * Make a complete copy of the geometry.\n     * @return {!MultiPolygon} Clone.\n     * @api\n     */\n    MultiPolygon.prototype.clone = function () {\n        var len = this.endss_.length;\n        var newEndss = new Array(len);\n        for (var i = 0; i < len; ++i) {\n            newEndss[i] = this.endss_[i].slice();\n        }\n        var multiPolygon = new MultiPolygon(this.flatCoordinates.slice(), this.layout, newEndss);\n        multiPolygon.applyProperties(this);\n        return multiPolygon;\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n     * @param {number} minSquaredDistance Minimum squared distance.\n     * @return {number} Minimum squared distance.\n     */\n    MultiPolygon.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {\n        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n            return minSquaredDistance;\n        }\n        if (this.maxDeltaRevision_ != this.getRevision()) {\n            this.maxDelta_ = Math.sqrt(multiArrayMaxSquaredDelta(this.flatCoordinates, 0, this.endss_, this.stride, 0));\n            this.maxDeltaRevision_ = this.getRevision();\n        }\n        return assignClosestMultiArrayPoint(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @return {boolean} Contains (x, y).\n     */\n    MultiPolygon.prototype.containsXY = function (x, y) {\n        return linearRingssContainsXY(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, x, y);\n    };\n    /**\n     * Return the area of the multipolygon on projected plane.\n     * @return {number} Area (on projected plane).\n     * @api\n     */\n    MultiPolygon.prototype.getArea = function () {\n        return linearRingssArea(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);\n    };\n    /**\n     * Get the coordinate array for this geometry.  This array has the structure\n     * of a GeoJSON coordinate array for multi-polygons.\n     *\n     * @param {boolean} [opt_right] Orient coordinates according to the right-hand\n     *     rule (counter-clockwise for exterior and clockwise for interior rings).\n     *     If `false`, coordinates will be oriented according to the left-hand rule\n     *     (clockwise for exterior and counter-clockwise for interior rings).\n     *     By default, coordinate orientation will depend on how the geometry was\n     *     constructed.\n     * @return {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} Coordinates.\n     * @api\n     */\n    MultiPolygon.prototype.getCoordinates = function (opt_right) {\n        var flatCoordinates;\n        if (opt_right !== undefined) {\n            flatCoordinates = this.getOrientedFlatCoordinates().slice();\n            orientLinearRingsArray(flatCoordinates, 0, this.endss_, this.stride, opt_right);\n        }\n        else {\n            flatCoordinates = this.flatCoordinates;\n        }\n        return inflateMultiCoordinatesArray(flatCoordinates, 0, this.endss_, this.stride);\n    };\n    /**\n     * @return {Array<Array<number>>} Endss.\n     */\n    MultiPolygon.prototype.getEndss = function () {\n        return this.endss_;\n    };\n    /**\n     * @return {Array<number>} Flat interior points.\n     */\n    MultiPolygon.prototype.getFlatInteriorPoints = function () {\n        if (this.flatInteriorPointsRevision_ != this.getRevision()) {\n            var flatCenters = linearRingssCenter(this.flatCoordinates, 0, this.endss_, this.stride);\n            this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, flatCenters);\n            this.flatInteriorPointsRevision_ = this.getRevision();\n        }\n        return this.flatInteriorPoints_;\n    };\n    /**\n     * Return the interior points as {@link module:ol/geom/MultiPoint~MultiPoint multipoint}.\n     * @return {MultiPoint} Interior points as XYM coordinates, where M is\n     * the length of the horizontal intersection that the point belongs to.\n     * @api\n     */\n    MultiPolygon.prototype.getInteriorPoints = function () {\n        return new MultiPoint(this.getFlatInteriorPoints().slice(), GeometryLayout.XYM);\n    };\n    /**\n     * @return {Array<number>} Oriented flat coordinates.\n     */\n    MultiPolygon.prototype.getOrientedFlatCoordinates = function () {\n        if (this.orientedRevision_ != this.getRevision()) {\n            var flatCoordinates = this.flatCoordinates;\n            if (linearRingssAreOriented(flatCoordinates, 0, this.endss_, this.stride)) {\n                this.orientedFlatCoordinates_ = flatCoordinates;\n            }\n            else {\n                this.orientedFlatCoordinates_ = flatCoordinates.slice();\n                this.orientedFlatCoordinates_.length = orientLinearRingsArray(this.orientedFlatCoordinates_, 0, this.endss_, this.stride);\n            }\n            this.orientedRevision_ = this.getRevision();\n        }\n        return this.orientedFlatCoordinates_;\n    };\n    /**\n     * @param {number} squaredTolerance Squared tolerance.\n     * @return {MultiPolygon} Simplified MultiPolygon.\n     * @protected\n     */\n    MultiPolygon.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {\n        var simplifiedFlatCoordinates = [];\n        var simplifiedEndss = [];\n        simplifiedFlatCoordinates.length = quantizeMultiArray(this.flatCoordinates, 0, this.endss_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEndss);\n        return new MultiPolygon(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEndss);\n    };\n    /**\n     * Return the polygon at the specified index.\n     * @param {number} index Index.\n     * @return {Polygon} Polygon.\n     * @api\n     */\n    MultiPolygon.prototype.getPolygon = function (index) {\n        if (index < 0 || this.endss_.length <= index) {\n            return null;\n        }\n        var offset;\n        if (index === 0) {\n            offset = 0;\n        }\n        else {\n            var prevEnds = this.endss_[index - 1];\n            offset = prevEnds[prevEnds.length - 1];\n        }\n        var ends = this.endss_[index].slice();\n        var end = ends[ends.length - 1];\n        if (offset !== 0) {\n            for (var i = 0, ii = ends.length; i < ii; ++i) {\n                ends[i] -= offset;\n            }\n        }\n        return new Polygon(this.flatCoordinates.slice(offset, end), this.layout, ends);\n    };\n    /**\n     * Return the polygons of this multipolygon.\n     * @return {Array<Polygon>} Polygons.\n     * @api\n     */\n    MultiPolygon.prototype.getPolygons = function () {\n        var layout = this.layout;\n        var flatCoordinates = this.flatCoordinates;\n        var endss = this.endss_;\n        var polygons = [];\n        var offset = 0;\n        for (var i = 0, ii = endss.length; i < ii; ++i) {\n            var ends = endss[i].slice();\n            var end = ends[ends.length - 1];\n            if (offset !== 0) {\n                for (var j = 0, jj = ends.length; j < jj; ++j) {\n                    ends[j] -= offset;\n                }\n            }\n            var polygon = new Polygon(flatCoordinates.slice(offset, end), layout, ends);\n            polygons.push(polygon);\n            offset = end;\n        }\n        return polygons;\n    };\n    /**\n     * Get the type of this geometry.\n     * @return {import(\"./Geometry.js\").Type} Geometry type.\n     * @api\n     */\n    MultiPolygon.prototype.getType = function () {\n        return 'MultiPolygon';\n    };\n    /**\n     * Test if the geometry and the passed extent intersect.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @return {boolean} `true` if the geometry and the extent intersect.\n     * @api\n     */\n    MultiPolygon.prototype.intersectsExtent = function (extent) {\n        return intersectsLinearRingMultiArray(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, extent);\n    };\n    /**\n     * Set the coordinates of the multipolygon.\n     * @param {!Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} coordinates Coordinates.\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     * @api\n     */\n    MultiPolygon.prototype.setCoordinates = function (coordinates, opt_layout) {\n        this.setLayout(opt_layout, coordinates, 3);\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = [];\n        }\n        var endss = deflateMultiCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.endss_);\n        if (endss.length === 0) {\n            this.flatCoordinates.length = 0;\n        }\n        else {\n            var lastEnds = endss[endss.length - 1];\n            this.flatCoordinates.length =\n                lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];\n        }\n        this.changed();\n    };\n    return MultiPolygon;\n}(SimpleGeometry));\nexport default MultiPolygon;\n//# sourceMappingURL=MultiPolygon.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/geom/Point\n */\nimport SimpleGeometry from './SimpleGeometry.js';\nimport { containsXY, createOrUpdateFromCoordinate } from '../extent.js';\nimport { deflateCoordinate } from './flat/deflate.js';\nimport { squaredDistance as squaredDx } from '../math.js';\n/**\n * @classdesc\n * Point geometry.\n *\n * @api\n */\nvar Point = /** @class */ (function (_super) {\n    __extends(Point, _super);\n    /**\n     * @param {import(\"../coordinate.js\").Coordinate} coordinates Coordinates.\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     */\n    function Point(coordinates, opt_layout) {\n        var _this = _super.call(this) || this;\n        _this.setCoordinates(coordinates, opt_layout);\n        return _this;\n    }\n    /**\n     * Make a complete copy of the geometry.\n     * @return {!Point} Clone.\n     * @api\n     */\n    Point.prototype.clone = function () {\n        var point = new Point(this.flatCoordinates.slice(), this.layout);\n        point.applyProperties(this);\n        return point;\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n     * @param {number} minSquaredDistance Minimum squared distance.\n     * @return {number} Minimum squared distance.\n     */\n    Point.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {\n        var flatCoordinates = this.flatCoordinates;\n        var squaredDistance = squaredDx(x, y, flatCoordinates[0], flatCoordinates[1]);\n        if (squaredDistance < minSquaredDistance) {\n            var stride = this.stride;\n            for (var i = 0; i < stride; ++i) {\n                closestPoint[i] = flatCoordinates[i];\n            }\n            closestPoint.length = stride;\n            return squaredDistance;\n        }\n        else {\n            return minSquaredDistance;\n        }\n    };\n    /**\n     * Return the coordinate of the point.\n     * @return {import(\"../coordinate.js\").Coordinate} Coordinates.\n     * @api\n     */\n    Point.prototype.getCoordinates = function () {\n        return !this.flatCoordinates ? [] : this.flatCoordinates.slice();\n    };\n    /**\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @protected\n     * @return {import(\"../extent.js\").Extent} extent Extent.\n     */\n    Point.prototype.computeExtent = function (extent) {\n        return createOrUpdateFromCoordinate(this.flatCoordinates, extent);\n    };\n    /**\n     * Get the type of this geometry.\n     * @return {import(\"./Geometry.js\").Type} Geometry type.\n     * @api\n     */\n    Point.prototype.getType = function () {\n        return 'Point';\n    };\n    /**\n     * Test if the geometry and the passed extent intersect.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @return {boolean} `true` if the geometry and the extent intersect.\n     * @api\n     */\n    Point.prototype.intersectsExtent = function (extent) {\n        return containsXY(extent, this.flatCoordinates[0], this.flatCoordinates[1]);\n    };\n    /**\n     * @param {!Array<*>} coordinates Coordinates.\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     * @api\n     */\n    Point.prototype.setCoordinates = function (coordinates, opt_layout) {\n        this.setLayout(opt_layout, coordinates, 0);\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = [];\n        }\n        this.flatCoordinates.length = deflateCoordinate(this.flatCoordinates, 0, coordinates, this.stride);\n        this.changed();\n    };\n    return Point;\n}(SimpleGeometry));\nexport default Point;\n//# sourceMappingURL=Point.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/geom/Polygon\n */\nimport GeometryLayout from './GeometryLayout.js';\nimport LinearRing from './LinearRing.js';\nimport Point from './Point.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport { arrayMaxSquaredDelta, assignClosestArrayPoint } from './flat/closest.js';\nimport { closestSquaredDistanceXY, getCenter } from '../extent.js';\nimport { deflateCoordinatesArray } from './flat/deflate.js';\nimport { extend } from '../array.js';\nimport { getInteriorPointOfArray } from './flat/interiorpoint.js';\nimport { inflateCoordinatesArray } from './flat/inflate.js';\nimport { intersectsLinearRingArray } from './flat/intersectsextent.js';\nimport { linearRingsAreOriented, orientLinearRings } from './flat/orient.js';\nimport { linearRings as linearRingsArea } from './flat/area.js';\nimport { linearRingsContainsXY } from './flat/contains.js';\nimport { modulo } from '../math.js';\nimport { quantizeArray } from './flat/simplify.js';\nimport { offset as sphereOffset } from '../sphere.js';\n/**\n * @classdesc\n * Polygon geometry.\n *\n * @api\n */\nvar Polygon = /** @class */ (function (_super) {\n    __extends(Polygon, _super);\n    /**\n     * @param {!Array<Array<import(\"../coordinate.js\").Coordinate>>|!Array<number>} coordinates\n     *     Array of linear rings that define the polygon. The first linear ring of the\n     *     array defines the outer-boundary or surface of the polygon. Each subsequent\n     *     linear ring defines a hole in the surface of the polygon. A linear ring is\n     *     an array of vertices' coordinates where the first coordinate and the last are\n     *     equivalent. (For internal use, flat coordinates in combination with\n     *     `opt_layout` and `opt_ends` are also accepted.)\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     * @param {Array<number>} [opt_ends] Ends (for internal use with flat coordinates).\n     */\n    function Polygon(coordinates, opt_layout, opt_ends) {\n        var _this = _super.call(this) || this;\n        /**\n         * @type {Array<number>}\n         * @private\n         */\n        _this.ends_ = [];\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.flatInteriorPointRevision_ = -1;\n        /**\n         * @private\n         * @type {import(\"../coordinate.js\").Coordinate}\n         */\n        _this.flatInteriorPoint_ = null;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.maxDelta_ = -1;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.maxDeltaRevision_ = -1;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.orientedRevision_ = -1;\n        /**\n         * @private\n         * @type {Array<number>}\n         */\n        _this.orientedFlatCoordinates_ = null;\n        if (opt_layout !== undefined && opt_ends) {\n            _this.setFlatCoordinates(opt_layout, \n            /** @type {Array<number>} */ (coordinates));\n            _this.ends_ = opt_ends;\n        }\n        else {\n            _this.setCoordinates(\n            /** @type {Array<Array<import(\"../coordinate.js\").Coordinate>>} */ (coordinates), opt_layout);\n        }\n        return _this;\n    }\n    /**\n     * Append the passed linear ring to this polygon.\n     * @param {LinearRing} linearRing Linear ring.\n     * @api\n     */\n    Polygon.prototype.appendLinearRing = function (linearRing) {\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = linearRing.getFlatCoordinates().slice();\n        }\n        else {\n            extend(this.flatCoordinates, linearRing.getFlatCoordinates());\n        }\n        this.ends_.push(this.flatCoordinates.length);\n        this.changed();\n    };\n    /**\n     * Make a complete copy of the geometry.\n     * @return {!Polygon} Clone.\n     * @api\n     */\n    Polygon.prototype.clone = function () {\n        var polygon = new Polygon(this.flatCoordinates.slice(), this.layout, this.ends_.slice());\n        polygon.applyProperties(this);\n        return polygon;\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n     * @param {number} minSquaredDistance Minimum squared distance.\n     * @return {number} Minimum squared distance.\n     */\n    Polygon.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {\n        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n            return minSquaredDistance;\n        }\n        if (this.maxDeltaRevision_ != this.getRevision()) {\n            this.maxDelta_ = Math.sqrt(arrayMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0));\n            this.maxDeltaRevision_ = this.getRevision();\n        }\n        return assignClosestArrayPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @return {boolean} Contains (x, y).\n     */\n    Polygon.prototype.containsXY = function (x, y) {\n        return linearRingsContainsXY(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, x, y);\n    };\n    /**\n     * Return the area of the polygon on projected plane.\n     * @return {number} Area (on projected plane).\n     * @api\n     */\n    Polygon.prototype.getArea = function () {\n        return linearRingsArea(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride);\n    };\n    /**\n     * Get the coordinate array for this geometry.  This array has the structure\n     * of a GeoJSON coordinate array for polygons.\n     *\n     * @param {boolean} [opt_right] Orient coordinates according to the right-hand\n     *     rule (counter-clockwise for exterior and clockwise for interior rings).\n     *     If `false`, coordinates will be oriented according to the left-hand rule\n     *     (clockwise for exterior and counter-clockwise for interior rings).\n     *     By default, coordinate orientation will depend on how the geometry was\n     *     constructed.\n     * @return {Array<Array<import(\"../coordinate.js\").Coordinate>>} Coordinates.\n     * @api\n     */\n    Polygon.prototype.getCoordinates = function (opt_right) {\n        var flatCoordinates;\n        if (opt_right !== undefined) {\n            flatCoordinates = this.getOrientedFlatCoordinates().slice();\n            orientLinearRings(flatCoordinates, 0, this.ends_, this.stride, opt_right);\n        }\n        else {\n            flatCoordinates = this.flatCoordinates;\n        }\n        return inflateCoordinatesArray(flatCoordinates, 0, this.ends_, this.stride);\n    };\n    /**\n     * @return {Array<number>} Ends.\n     */\n    Polygon.prototype.getEnds = function () {\n        return this.ends_;\n    };\n    /**\n     * @return {Array<number>} Interior point.\n     */\n    Polygon.prototype.getFlatInteriorPoint = function () {\n        if (this.flatInteriorPointRevision_ != this.getRevision()) {\n            var flatCenter = getCenter(this.getExtent());\n            this.flatInteriorPoint_ = getInteriorPointOfArray(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, flatCenter, 0);\n            this.flatInteriorPointRevision_ = this.getRevision();\n        }\n        return this.flatInteriorPoint_;\n    };\n    /**\n     * Return an interior point of the polygon.\n     * @return {Point} Interior point as XYM coordinate, where M is the\n     * length of the horizontal intersection that the point belongs to.\n     * @api\n     */\n    Polygon.prototype.getInteriorPoint = function () {\n        return new Point(this.getFlatInteriorPoint(), GeometryLayout.XYM);\n    };\n    /**\n     * Return the number of rings of the polygon,  this includes the exterior\n     * ring and any interior rings.\n     *\n     * @return {number} Number of rings.\n     * @api\n     */\n    Polygon.prototype.getLinearRingCount = function () {\n        return this.ends_.length;\n    };\n    /**\n     * Return the Nth linear ring of the polygon geometry. Return `null` if the\n     * given index is out of range.\n     * The exterior linear ring is available at index `0` and the interior rings\n     * at index `1` and beyond.\n     *\n     * @param {number} index Index.\n     * @return {LinearRing|null} Linear ring.\n     * @api\n     */\n    Polygon.prototype.getLinearRing = function (index) {\n        if (index < 0 || this.ends_.length <= index) {\n            return null;\n        }\n        return new LinearRing(this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);\n    };\n    /**\n     * Return the linear rings of the polygon.\n     * @return {Array<LinearRing>} Linear rings.\n     * @api\n     */\n    Polygon.prototype.getLinearRings = function () {\n        var layout = this.layout;\n        var flatCoordinates = this.flatCoordinates;\n        var ends = this.ends_;\n        var linearRings = [];\n        var offset = 0;\n        for (var i = 0, ii = ends.length; i < ii; ++i) {\n            var end = ends[i];\n            var linearRing = new LinearRing(flatCoordinates.slice(offset, end), layout);\n            linearRings.push(linearRing);\n            offset = end;\n        }\n        return linearRings;\n    };\n    /**\n     * @return {Array<number>} Oriented flat coordinates.\n     */\n    Polygon.prototype.getOrientedFlatCoordinates = function () {\n        if (this.orientedRevision_ != this.getRevision()) {\n            var flatCoordinates = this.flatCoordinates;\n            if (linearRingsAreOriented(flatCoordinates, 0, this.ends_, this.stride)) {\n                this.orientedFlatCoordinates_ = flatCoordinates;\n            }\n            else {\n                this.orientedFlatCoordinates_ = flatCoordinates.slice();\n                this.orientedFlatCoordinates_.length = orientLinearRings(this.orientedFlatCoordinates_, 0, this.ends_, this.stride);\n            }\n            this.orientedRevision_ = this.getRevision();\n        }\n        return this.orientedFlatCoordinates_;\n    };\n    /**\n     * @param {number} squaredTolerance Squared tolerance.\n     * @return {Polygon} Simplified Polygon.\n     * @protected\n     */\n    Polygon.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {\n        var simplifiedFlatCoordinates = [];\n        var simplifiedEnds = [];\n        simplifiedFlatCoordinates.length = quantizeArray(this.flatCoordinates, 0, this.ends_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEnds);\n        return new Polygon(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEnds);\n    };\n    /**\n     * Get the type of this geometry.\n     * @return {import(\"./Geometry.js\").Type} Geometry type.\n     * @api\n     */\n    Polygon.prototype.getType = function () {\n        return 'Polygon';\n    };\n    /**\n     * Test if the geometry and the passed extent intersect.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @return {boolean} `true` if the geometry and the extent intersect.\n     * @api\n     */\n    Polygon.prototype.intersectsExtent = function (extent) {\n        return intersectsLinearRingArray(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, extent);\n    };\n    /**\n     * Set the coordinates of the polygon.\n     * @param {!Array<Array<import(\"../coordinate.js\").Coordinate>>} coordinates Coordinates.\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     * @api\n     */\n    Polygon.prototype.setCoordinates = function (coordinates, opt_layout) {\n        this.setLayout(opt_layout, coordinates, 2);\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = [];\n        }\n        var ends = deflateCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);\n        this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];\n        this.changed();\n    };\n    return Polygon;\n}(SimpleGeometry));\nexport default Polygon;\n/**\n * Create an approximation of a circle on the surface of a sphere.\n * @param {import(\"../coordinate.js\").Coordinate} center Center (`[lon, lat]` in degrees).\n * @param {number} radius The great-circle distance from the center to\n *     the polygon vertices in meters.\n * @param {number} [opt_n] Optional number of vertices for the resulting\n *     polygon. Default is `32`.\n * @param {number} [opt_sphereRadius] Optional radius for the sphere (defaults to\n *     the Earth's mean radius using the WGS84 ellipsoid).\n * @return {Polygon} The \"circular\" polygon.\n * @api\n */\nexport function circular(center, radius, opt_n, opt_sphereRadius) {\n    var n = opt_n ? opt_n : 32;\n    /** @type {Array<number>} */\n    var flatCoordinates = [];\n    for (var i = 0; i < n; ++i) {\n        extend(flatCoordinates, sphereOffset(center, radius, (2 * Math.PI * i) / n, opt_sphereRadius));\n    }\n    flatCoordinates.push(flatCoordinates[0], flatCoordinates[1]);\n    return new Polygon(flatCoordinates, GeometryLayout.XY, [\n        flatCoordinates.length,\n    ]);\n}\n/**\n * Create a polygon from an extent. The layout used is `XY`.\n * @param {import(\"../extent.js\").Extent} extent The extent.\n * @return {Polygon} The polygon.\n * @api\n */\nexport function fromExtent(extent) {\n    var minX = extent[0];\n    var minY = extent[1];\n    var maxX = extent[2];\n    var maxY = extent[3];\n    var flatCoordinates = [\n        minX,\n        minY,\n        minX,\n        maxY,\n        maxX,\n        maxY,\n        maxX,\n        minY,\n        minX,\n        minY,\n    ];\n    return new Polygon(flatCoordinates, GeometryLayout.XY, [\n        flatCoordinates.length,\n    ]);\n}\n/**\n * Create a regular polygon from a circle.\n * @param {import(\"./Circle.js\").default} circle Circle geometry.\n * @param {number} [opt_sides] Number of sides of the polygon. Default is 32.\n * @param {number} [opt_angle] Start angle for the first vertex of the polygon in\n *     counter-clockwise radians. 0 means East. Default is 0.\n * @return {Polygon} Polygon geometry.\n * @api\n */\nexport function fromCircle(circle, opt_sides, opt_angle) {\n    var sides = opt_sides ? opt_sides : 32;\n    var stride = circle.getStride();\n    var layout = circle.getLayout();\n    var center = circle.getCenter();\n    var arrayLength = stride * (sides + 1);\n    var flatCoordinates = new Array(arrayLength);\n    for (var i = 0; i < arrayLength; i += stride) {\n        flatCoordinates[i] = 0;\n        flatCoordinates[i + 1] = 0;\n        for (var j = 2; j < stride; j++) {\n            flatCoordinates[i + j] = center[j];\n        }\n    }\n    var ends = [flatCoordinates.length];\n    var polygon = new Polygon(flatCoordinates, layout, ends);\n    makeRegular(polygon, center, circle.getRadius(), opt_angle);\n    return polygon;\n}\n/**\n * Modify the coordinates of a polygon to make it a regular polygon.\n * @param {Polygon} polygon Polygon geometry.\n * @param {import(\"../coordinate.js\").Coordinate} center Center of the regular polygon.\n * @param {number} radius Radius of the regular polygon.\n * @param {number} [opt_angle] Start angle for the first vertex of the polygon in\n *     counter-clockwise radians. 0 means East. Default is 0.\n */\nexport function makeRegular(polygon, center, radius, opt_angle) {\n    var flatCoordinates = polygon.getFlatCoordinates();\n    var stride = polygon.getStride();\n    var sides = flatCoordinates.length / stride - 1;\n    var startAngle = opt_angle ? opt_angle : 0;\n    for (var i = 0; i <= sides; ++i) {\n        var offset = i * stride;\n        var angle = startAngle + (modulo(i, sides) * 2 * Math.PI) / sides;\n        flatCoordinates[offset] = center[0] + radius * Math.cos(angle);\n        flatCoordinates[offset + 1] = center[1] + radius * Math.sin(angle);\n    }\n    polygon.changed();\n}\n//# sourceMappingURL=Polygon.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/geom/SimpleGeometry\n */\nimport Geometry from './Geometry.js';\nimport GeometryLayout from './GeometryLayout.js';\nimport { abstract } from '../util.js';\nimport { createOrUpdateFromFlatCoordinates, getCenter } from '../extent.js';\nimport { rotate, scale, transform2D, translate } from './flat/transform.js';\n/**\n * @classdesc\n * Abstract base class; only used for creating subclasses; do not instantiate\n * in apps, as cannot be rendered.\n *\n * @abstract\n * @api\n */\nvar SimpleGeometry = /** @class */ (function (_super) {\n    __extends(SimpleGeometry, _super);\n    function SimpleGeometry() {\n        var _this = _super.call(this) || this;\n        /**\n         * @protected\n         * @type {import(\"./GeometryLayout.js\").default}\n         */\n        _this.layout = GeometryLayout.XY;\n        /**\n         * @protected\n         * @type {number}\n         */\n        _this.stride = 2;\n        /**\n         * @protected\n         * @type {Array<number>}\n         */\n        _this.flatCoordinates = null;\n        return _this;\n    }\n    /**\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @protected\n     * @return {import(\"../extent.js\").Extent} extent Extent.\n     */\n    SimpleGeometry.prototype.computeExtent = function (extent) {\n        return createOrUpdateFromFlatCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);\n    };\n    /**\n     * @abstract\n     * @return {Array<*> | null} Coordinates.\n     */\n    SimpleGeometry.prototype.getCoordinates = function () {\n        return abstract();\n    };\n    /**\n     * Return the first coordinate of the geometry.\n     * @return {import(\"../coordinate.js\").Coordinate} First coordinate.\n     * @api\n     */\n    SimpleGeometry.prototype.getFirstCoordinate = function () {\n        return this.flatCoordinates.slice(0, this.stride);\n    };\n    /**\n     * @return {Array<number>} Flat coordinates.\n     */\n    SimpleGeometry.prototype.getFlatCoordinates = function () {\n        return this.flatCoordinates;\n    };\n    /**\n     * Return the last coordinate of the geometry.\n     * @return {import(\"../coordinate.js\").Coordinate} Last point.\n     * @api\n     */\n    SimpleGeometry.prototype.getLastCoordinate = function () {\n        return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride);\n    };\n    /**\n     * Return the {@link module:ol/geom/GeometryLayout layout} of the geometry.\n     * @return {import(\"./GeometryLayout.js\").default} Layout.\n     * @api\n     */\n    SimpleGeometry.prototype.getLayout = function () {\n        return this.layout;\n    };\n    /**\n     * Create a simplified version of this geometry using the Douglas Peucker algorithm.\n     * @param {number} squaredTolerance Squared tolerance.\n     * @return {SimpleGeometry} Simplified geometry.\n     */\n    SimpleGeometry.prototype.getSimplifiedGeometry = function (squaredTolerance) {\n        if (this.simplifiedGeometryRevision !== this.getRevision()) {\n            this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n            this.simplifiedGeometryRevision = this.getRevision();\n        }\n        // If squaredTolerance is negative or if we know that simplification will not\n        // have any effect then just return this.\n        if (squaredTolerance < 0 ||\n            (this.simplifiedGeometryMaxMinSquaredTolerance !== 0 &&\n                squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance)) {\n            return this;\n        }\n        var simplifiedGeometry = this.getSimplifiedGeometryInternal(squaredTolerance);\n        var simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();\n        if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {\n            return simplifiedGeometry;\n        }\n        else {\n            // Simplification did not actually remove any coordinates.  We now know\n            // that any calls to getSimplifiedGeometry with a squaredTolerance less\n            // than or equal to the current squaredTolerance will also not have any\n            // effect.  This allows us to short circuit simplification (saving CPU\n            // cycles) and prevents the cache of simplified geometries from filling\n            // up with useless identical copies of this geometry (saving memory).\n            this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;\n            return this;\n        }\n    };\n    /**\n     * @param {number} squaredTolerance Squared tolerance.\n     * @return {SimpleGeometry} Simplified geometry.\n     * @protected\n     */\n    SimpleGeometry.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {\n        return this;\n    };\n    /**\n     * @return {number} Stride.\n     */\n    SimpleGeometry.prototype.getStride = function () {\n        return this.stride;\n    };\n    /**\n     * @param {import(\"./GeometryLayout.js\").default} layout Layout.\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     */\n    SimpleGeometry.prototype.setFlatCoordinates = function (layout, flatCoordinates) {\n        this.stride = getStrideForLayout(layout);\n        this.layout = layout;\n        this.flatCoordinates = flatCoordinates;\n    };\n    /**\n     * @abstract\n     * @param {!Array<*>} coordinates Coordinates.\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     */\n    SimpleGeometry.prototype.setCoordinates = function (coordinates, opt_layout) {\n        abstract();\n    };\n    /**\n     * @param {import(\"./GeometryLayout.js\").default|undefined} layout Layout.\n     * @param {Array<*>} coordinates Coordinates.\n     * @param {number} nesting Nesting.\n     * @protected\n     */\n    SimpleGeometry.prototype.setLayout = function (layout, coordinates, nesting) {\n        /** @type {number} */\n        var stride;\n        if (layout) {\n            stride = getStrideForLayout(layout);\n        }\n        else {\n            for (var i = 0; i < nesting; ++i) {\n                if (coordinates.length === 0) {\n                    this.layout = GeometryLayout.XY;\n                    this.stride = 2;\n                    return;\n                }\n                else {\n                    coordinates = /** @type {Array} */ (coordinates[0]);\n                }\n            }\n            stride = coordinates.length;\n            layout = getLayoutForStride(stride);\n        }\n        this.layout = layout;\n        this.stride = stride;\n    };\n    /**\n     * Apply a transform function to the coordinates of the geometry.\n     * The geometry is modified in place.\n     * If you do not want the geometry modified in place, first `clone()` it and\n     * then use this function on the clone.\n     * @param {import(\"../proj.js\").TransformFunction} transformFn Transform function.\n     * Called with a flat array of geometry coordinates.\n     * @api\n     */\n    SimpleGeometry.prototype.applyTransform = function (transformFn) {\n        if (this.flatCoordinates) {\n            transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);\n            this.changed();\n        }\n    };\n    /**\n     * Rotate the geometry around a given coordinate. This modifies the geometry\n     * coordinates in place.\n     * @param {number} angle Rotation angle in counter-clockwise radians.\n     * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\n     * @api\n     */\n    SimpleGeometry.prototype.rotate = function (angle, anchor) {\n        var flatCoordinates = this.getFlatCoordinates();\n        if (flatCoordinates) {\n            var stride = this.getStride();\n            rotate(flatCoordinates, 0, flatCoordinates.length, stride, angle, anchor, flatCoordinates);\n            this.changed();\n        }\n    };\n    /**\n     * Scale the geometry (with an optional origin).  This modifies the geometry\n     * coordinates in place.\n     * @param {number} sx The scaling factor in the x-direction.\n     * @param {number} [opt_sy] The scaling factor in the y-direction (defaults to sx).\n     * @param {import(\"../coordinate.js\").Coordinate} [opt_anchor] The scale origin (defaults to the center\n     *     of the geometry extent).\n     * @api\n     */\n    SimpleGeometry.prototype.scale = function (sx, opt_sy, opt_anchor) {\n        var sy = opt_sy;\n        if (sy === undefined) {\n            sy = sx;\n        }\n        var anchor = opt_anchor;\n        if (!anchor) {\n            anchor = getCenter(this.getExtent());\n        }\n        var flatCoordinates = this.getFlatCoordinates();\n        if (flatCoordinates) {\n            var stride = this.getStride();\n            scale(flatCoordinates, 0, flatCoordinates.length, stride, sx, sy, anchor, flatCoordinates);\n            this.changed();\n        }\n    };\n    /**\n     * Translate the geometry.  This modifies the geometry coordinates in place.  If\n     * instead you want a new geometry, first `clone()` this geometry.\n     * @param {number} deltaX Delta X.\n     * @param {number} deltaY Delta Y.\n     * @api\n     */\n    SimpleGeometry.prototype.translate = function (deltaX, deltaY) {\n        var flatCoordinates = this.getFlatCoordinates();\n        if (flatCoordinates) {\n            var stride = this.getStride();\n            translate(flatCoordinates, 0, flatCoordinates.length, stride, deltaX, deltaY, flatCoordinates);\n            this.changed();\n        }\n    };\n    return SimpleGeometry;\n}(Geometry));\n/**\n * @param {number} stride Stride.\n * @return {import(\"./GeometryLayout.js\").default} layout Layout.\n */\nfunction getLayoutForStride(stride) {\n    var layout;\n    if (stride == 2) {\n        layout = GeometryLayout.XY;\n    }\n    else if (stride == 3) {\n        layout = GeometryLayout.XYZ;\n    }\n    else if (stride == 4) {\n        layout = GeometryLayout.XYZM;\n    }\n    return /** @type {import(\"./GeometryLayout.js\").default} */ (layout);\n}\n/**\n * @param {import(\"./GeometryLayout.js\").default} layout Layout.\n * @return {number} Stride.\n */\nexport function getStrideForLayout(layout) {\n    var stride;\n    if (layout == GeometryLayout.XY) {\n        stride = 2;\n    }\n    else if (layout == GeometryLayout.XYZ || layout == GeometryLayout.XYM) {\n        stride = 3;\n    }\n    else if (layout == GeometryLayout.XYZM) {\n        stride = 4;\n    }\n    return /** @type {number} */ (stride);\n}\n/**\n * @param {SimpleGeometry} simpleGeometry Simple geometry.\n * @param {import(\"../transform.js\").Transform} transform Transform.\n * @param {Array<number>} [opt_dest] Destination.\n * @return {Array<number>} Transformed flat coordinates.\n */\nexport function transformGeom2D(simpleGeometry, transform, opt_dest) {\n    var flatCoordinates = simpleGeometry.getFlatCoordinates();\n    if (!flatCoordinates) {\n        return null;\n    }\n    else {\n        var stride = simpleGeometry.getStride();\n        return transform2D(flatCoordinates, 0, flatCoordinates.length, stride, transform, opt_dest);\n    }\n}\nexport default SimpleGeometry;\n//# sourceMappingURL=SimpleGeometry.js.map","/**\n * @module ol/geom/flat/area\n */\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {number} Area.\n */\nexport function linearRing(flatCoordinates, offset, end, stride) {\n    var twiceArea = 0;\n    var x1 = flatCoordinates[end - stride];\n    var y1 = flatCoordinates[end - stride + 1];\n    for (; offset < end; offset += stride) {\n        var x2 = flatCoordinates[offset];\n        var y2 = flatCoordinates[offset + 1];\n        twiceArea += y1 * x2 - x1 * y2;\n        x1 = x2;\n        y1 = y2;\n    }\n    return twiceArea / 2;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @return {number} Area.\n */\nexport function linearRings(flatCoordinates, offset, ends, stride) {\n    var area = 0;\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n        var end = ends[i];\n        area += linearRing(flatCoordinates, offset, end, stride);\n        offset = end;\n    }\n    return area;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @return {number} Area.\n */\nexport function linearRingss(flatCoordinates, offset, endss, stride) {\n    var area = 0;\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n        var ends = endss[i];\n        area += linearRings(flatCoordinates, offset, ends, stride);\n        offset = ends[ends.length - 1];\n    }\n    return area;\n}\n//# sourceMappingURL=area.js.map","/**\n * @module ol/geom/flat/closest\n */\nimport { lerp, squaredDistance as squaredDx } from '../../math.js';\n/**\n * Returns the point on the 2D line segment flatCoordinates[offset1] to\n * flatCoordinates[offset2] that is closest to the point (x, y).  Extra\n * dimensions are linearly interpolated.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset1 Offset 1.\n * @param {number} offset2 Offset 2.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n */\nfunction assignClosest(flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {\n    var x1 = flatCoordinates[offset1];\n    var y1 = flatCoordinates[offset1 + 1];\n    var dx = flatCoordinates[offset2] - x1;\n    var dy = flatCoordinates[offset2 + 1] - y1;\n    var offset;\n    if (dx === 0 && dy === 0) {\n        offset = offset1;\n    }\n    else {\n        var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\n        if (t > 1) {\n            offset = offset2;\n        }\n        else if (t > 0) {\n            for (var i = 0; i < stride; ++i) {\n                closestPoint[i] = lerp(flatCoordinates[offset1 + i], flatCoordinates[offset2 + i], t);\n            }\n            closestPoint.length = stride;\n            return;\n        }\n        else {\n            offset = offset1;\n        }\n    }\n    for (var i = 0; i < stride; ++i) {\n        closestPoint[i] = flatCoordinates[offset + i];\n    }\n    closestPoint.length = stride;\n}\n/**\n * Return the squared of the largest distance between any pair of consecutive\n * coordinates.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\nexport function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {\n    var x1 = flatCoordinates[offset];\n    var y1 = flatCoordinates[offset + 1];\n    for (offset += stride; offset < end; offset += stride) {\n        var x2 = flatCoordinates[offset];\n        var y2 = flatCoordinates[offset + 1];\n        var squaredDelta = squaredDx(x1, y1, x2, y2);\n        if (squaredDelta > max) {\n            max = squaredDelta;\n        }\n        x1 = x2;\n        y1 = y2;\n    }\n    return max;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\nexport function arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max) {\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n        var end = ends[i];\n        max = maxSquaredDelta(flatCoordinates, offset, end, stride, max);\n        offset = end;\n    }\n    return max;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\nexport function multiArrayMaxSquaredDelta(flatCoordinates, offset, endss, stride, max) {\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n        var ends = endss[i];\n        max = arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max);\n        offset = ends[ends.length - 1];\n    }\n    return max;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>} [opt_tmpPoint] Temporary point object.\n * @return {number} Minimum squared distance.\n */\nexport function assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {\n    if (offset == end) {\n        return minSquaredDistance;\n    }\n    var i, squaredDistance;\n    if (maxDelta === 0) {\n        // All points are identical, so just test the first point.\n        squaredDistance = squaredDx(x, y, flatCoordinates[offset], flatCoordinates[offset + 1]);\n        if (squaredDistance < minSquaredDistance) {\n            for (i = 0; i < stride; ++i) {\n                closestPoint[i] = flatCoordinates[offset + i];\n            }\n            closestPoint.length = stride;\n            return squaredDistance;\n        }\n        else {\n            return minSquaredDistance;\n        }\n    }\n    var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n    var index = offset + stride;\n    while (index < end) {\n        assignClosest(flatCoordinates, index - stride, index, stride, x, y, tmpPoint);\n        squaredDistance = squaredDx(x, y, tmpPoint[0], tmpPoint[1]);\n        if (squaredDistance < minSquaredDistance) {\n            minSquaredDistance = squaredDistance;\n            for (i = 0; i < stride; ++i) {\n                closestPoint[i] = tmpPoint[i];\n            }\n            closestPoint.length = stride;\n            index += stride;\n        }\n        else {\n            // Skip ahead multiple points, because we know that all the skipped\n            // points cannot be any closer than the closest point we have found so\n            // far.  We know this because we know how close the current point is, how\n            // close the closest point we have found so far is, and the maximum\n            // distance between consecutive points.  For example, if we're currently\n            // at distance 10, the best we've found so far is 3, and that the maximum\n            // distance between consecutive points is 2, then we'll need to skip at\n            // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of\n            // finding a closer point.  We use Math.max(..., 1) to ensure that we\n            // always advance at least one point, to avoid an infinite loop.\n            index +=\n                stride *\n                    Math.max(((Math.sqrt(squaredDistance) - Math.sqrt(minSquaredDistance)) /\n                        maxDelta) |\n                        0, 1);\n        }\n    }\n    if (isRing) {\n        // Check the closing segment.\n        assignClosest(flatCoordinates, end - stride, offset, stride, x, y, tmpPoint);\n        squaredDistance = squaredDx(x, y, tmpPoint[0], tmpPoint[1]);\n        if (squaredDistance < minSquaredDistance) {\n            minSquaredDistance = squaredDistance;\n            for (i = 0; i < stride; ++i) {\n                closestPoint[i] = tmpPoint[i];\n            }\n            closestPoint.length = stride;\n        }\n    }\n    return minSquaredDistance;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>} [opt_tmpPoint] Temporary point object.\n * @return {number} Minimum squared distance.\n */\nexport function assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {\n    var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n        var end = ends[i];\n        minSquaredDistance = assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);\n        offset = end;\n    }\n    return minSquaredDistance;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>} [opt_tmpPoint] Temporary point object.\n * @return {number} Minimum squared distance.\n */\nexport function assignClosestMultiArrayPoint(flatCoordinates, offset, endss, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {\n    var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n        var ends = endss[i];\n        minSquaredDistance = assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);\n        offset = ends[ends.length - 1];\n    }\n    return minSquaredDistance;\n}\n//# sourceMappingURL=closest.js.map","/**\n * @module ol/geom/flat/contains\n */\nimport { forEachCorner } from '../../extent.js';\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} Contains extent.\n */\nexport function linearRingContainsExtent(flatCoordinates, offset, end, stride, extent) {\n    var outside = forEachCorner(extent, \n    /**\n     * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @return {boolean} Contains (x, y).\n     */\n    function (coordinate) {\n        return !linearRingContainsXY(flatCoordinates, offset, end, stride, coordinate[0], coordinate[1]);\n    });\n    return !outside;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\nexport function linearRingContainsXY(flatCoordinates, offset, end, stride, x, y) {\n    // https://geomalgorithms.com/a03-_inclusion.html\n    // Copyright 2000 softSurfer, 2012 Dan Sunday\n    // This code may be freely used and modified for any purpose\n    // providing that this copyright notice is included with it.\n    // SoftSurfer makes no warranty for this code, and cannot be held\n    // liable for any real or imagined damage resulting from its use.\n    // Users of this code must verify correctness for their application.\n    var wn = 0;\n    var x1 = flatCoordinates[end - stride];\n    var y1 = flatCoordinates[end - stride + 1];\n    for (; offset < end; offset += stride) {\n        var x2 = flatCoordinates[offset];\n        var y2 = flatCoordinates[offset + 1];\n        if (y1 <= y) {\n            if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) {\n                wn++;\n            }\n        }\n        else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) {\n            wn--;\n        }\n        x1 = x2;\n        y1 = y2;\n    }\n    return wn !== 0;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\nexport function linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y) {\n    if (ends.length === 0) {\n        return false;\n    }\n    if (!linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) {\n        return false;\n    }\n    for (var i = 1, ii = ends.length; i < ii; ++i) {\n        if (linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\nexport function linearRingssContainsXY(flatCoordinates, offset, endss, stride, x, y) {\n    if (endss.length === 0) {\n        return false;\n    }\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n        var ends = endss[i];\n        if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {\n            return true;\n        }\n        offset = ends[ends.length - 1];\n    }\n    return false;\n}\n//# sourceMappingURL=contains.js.map","/**\n * @module ol/geom/flat/deflate\n */\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n * @param {number} stride Stride.\n * @return {number} offset Offset.\n */\nexport function deflateCoordinate(flatCoordinates, offset, coordinate, stride) {\n    for (var i = 0, ii = coordinate.length; i < ii; ++i) {\n        flatCoordinates[offset++] = coordinate[i];\n    }\n    return offset;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<import(\"../../coordinate.js\").Coordinate>} coordinates Coordinates.\n * @param {number} stride Stride.\n * @return {number} offset Offset.\n */\nexport function deflateCoordinates(flatCoordinates, offset, coordinates, stride) {\n    for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n        var coordinate = coordinates[i];\n        for (var j = 0; j < stride; ++j) {\n            flatCoordinates[offset++] = coordinate[j];\n        }\n    }\n    return offset;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<import(\"../../coordinate.js\").Coordinate>>} coordinatess Coordinatess.\n * @param {number} stride Stride.\n * @param {Array<number>} [opt_ends] Ends.\n * @return {Array<number>} Ends.\n */\nexport function deflateCoordinatesArray(flatCoordinates, offset, coordinatess, stride, opt_ends) {\n    var ends = opt_ends ? opt_ends : [];\n    var i = 0;\n    for (var j = 0, jj = coordinatess.length; j < jj; ++j) {\n        var end = deflateCoordinates(flatCoordinates, offset, coordinatess[j], stride);\n        ends[i++] = end;\n        offset = end;\n    }\n    ends.length = i;\n    return ends;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<Array<import(\"../../coordinate.js\").Coordinate>>>} coordinatesss Coordinatesss.\n * @param {number} stride Stride.\n * @param {Array<Array<number>>} [opt_endss] Endss.\n * @return {Array<Array<number>>} Endss.\n */\nexport function deflateMultiCoordinatesArray(flatCoordinates, offset, coordinatesss, stride, opt_endss) {\n    var endss = opt_endss ? opt_endss : [];\n    var i = 0;\n    for (var j = 0, jj = coordinatesss.length; j < jj; ++j) {\n        var ends = deflateCoordinatesArray(flatCoordinates, offset, coordinatesss[j], stride, endss[i]);\n        endss[i++] = ends;\n        offset = ends[ends.length - 1];\n    }\n    endss.length = i;\n    return endss;\n}\n//# sourceMappingURL=deflate.js.map","/**\n * @module ol/geom/flat/inflate\n */\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {Array<import(\"../../coordinate.js\").Coordinate>} [opt_coordinates] Coordinates.\n * @return {Array<import(\"../../coordinate.js\").Coordinate>} Coordinates.\n */\nexport function inflateCoordinates(flatCoordinates, offset, end, stride, opt_coordinates) {\n    var coordinates = opt_coordinates !== undefined ? opt_coordinates : [];\n    var i = 0;\n    for (var j = offset; j < end; j += stride) {\n        coordinates[i++] = flatCoordinates.slice(j, j + stride);\n    }\n    coordinates.length = i;\n    return coordinates;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {Array<Array<import(\"../../coordinate.js\").Coordinate>>} [opt_coordinatess] Coordinatess.\n * @return {Array<Array<import(\"../../coordinate.js\").Coordinate>>} Coordinatess.\n */\nexport function inflateCoordinatesArray(flatCoordinates, offset, ends, stride, opt_coordinatess) {\n    var coordinatess = opt_coordinatess !== undefined ? opt_coordinatess : [];\n    var i = 0;\n    for (var j = 0, jj = ends.length; j < jj; ++j) {\n        var end = ends[j];\n        coordinatess[i++] = inflateCoordinates(flatCoordinates, offset, end, stride, coordinatess[i]);\n        offset = end;\n    }\n    coordinatess.length = i;\n    return coordinatess;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {Array<Array<Array<import(\"../../coordinate.js\").Coordinate>>>} [opt_coordinatesss]\n *     Coordinatesss.\n * @return {Array<Array<Array<import(\"../../coordinate.js\").Coordinate>>>} Coordinatesss.\n */\nexport function inflateMultiCoordinatesArray(flatCoordinates, offset, endss, stride, opt_coordinatesss) {\n    var coordinatesss = opt_coordinatesss !== undefined ? opt_coordinatesss : [];\n    var i = 0;\n    for (var j = 0, jj = endss.length; j < jj; ++j) {\n        var ends = endss[j];\n        coordinatesss[i++] = inflateCoordinatesArray(flatCoordinates, offset, ends, stride, coordinatesss[i]);\n        offset = ends[ends.length - 1];\n    }\n    coordinatesss.length = i;\n    return coordinatesss;\n}\n//# sourceMappingURL=inflate.js.map","/**\n * @module ol/geom/flat/interiorpoint\n */\nimport { linearRingsContainsXY } from './contains.js';\nimport { numberSafeCompareFunction } from '../../array.js';\n/**\n * Calculates a point that is likely to lie in the interior of the linear rings.\n * Inspired by JTS's com.vividsolutions.jts.geom.Geometry#getInteriorPoint.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {Array<number>} flatCenters Flat centers.\n * @param {number} flatCentersOffset Flat center offset.\n * @param {Array<number>} [opt_dest] Destination.\n * @return {Array<number>} Destination point as XYM coordinate, where M is the\n * length of the horizontal intersection that the point belongs to.\n */\nexport function getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, flatCentersOffset, opt_dest) {\n    var i, ii, x, x1, x2, y1, y2;\n    var y = flatCenters[flatCentersOffset + 1];\n    /** @type {Array<number>} */\n    var intersections = [];\n    // Calculate intersections with the horizontal line\n    for (var r = 0, rr = ends.length; r < rr; ++r) {\n        var end = ends[r];\n        x1 = flatCoordinates[end - stride];\n        y1 = flatCoordinates[end - stride + 1];\n        for (i = offset; i < end; i += stride) {\n            x2 = flatCoordinates[i];\n            y2 = flatCoordinates[i + 1];\n            if ((y <= y1 && y2 <= y) || (y1 <= y && y <= y2)) {\n                x = ((y - y1) / (y2 - y1)) * (x2 - x1) + x1;\n                intersections.push(x);\n            }\n            x1 = x2;\n            y1 = y2;\n        }\n    }\n    // Find the longest segment of the horizontal line that has its center point\n    // inside the linear ring.\n    var pointX = NaN;\n    var maxSegmentLength = -Infinity;\n    intersections.sort(numberSafeCompareFunction);\n    x1 = intersections[0];\n    for (i = 1, ii = intersections.length; i < ii; ++i) {\n        x2 = intersections[i];\n        var segmentLength = Math.abs(x2 - x1);\n        if (segmentLength > maxSegmentLength) {\n            x = (x1 + x2) / 2;\n            if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {\n                pointX = x;\n                maxSegmentLength = segmentLength;\n            }\n        }\n        x1 = x2;\n    }\n    if (isNaN(pointX)) {\n        // There is no horizontal line that has its center point inside the linear\n        // ring.  Use the center of the the linear ring's extent.\n        pointX = flatCenters[flatCentersOffset];\n    }\n    if (opt_dest) {\n        opt_dest.push(pointX, y, maxSegmentLength);\n        return opt_dest;\n    }\n    else {\n        return [pointX, y, maxSegmentLength];\n    }\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {Array<number>} flatCenters Flat centers.\n * @return {Array<number>} Interior points as XYM coordinates, where M is the\n * length of the horizontal intersection that the point belongs to.\n */\nexport function getInteriorPointsOfMultiArray(flatCoordinates, offset, endss, stride, flatCenters) {\n    var interiorPoints = [];\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n        var ends = endss[i];\n        interiorPoints = getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, 2 * i, interiorPoints);\n        offset = ends[ends.length - 1];\n    }\n    return interiorPoints;\n}\n//# sourceMappingURL=interiorpoint.js.map","/**\n * @module ol/geom/flat/interpolate\n */\nimport { binarySearch } from '../../array.js';\nimport { lerp } from '../../math.js';\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} fraction Fraction.\n * @param {Array<number>} [opt_dest] Destination.\n * @param {number} [opt_dimension] Destination dimension (default is `2`)\n * @return {Array<number>} Destination.\n */\nexport function interpolatePoint(flatCoordinates, offset, end, stride, fraction, opt_dest, opt_dimension) {\n    var o, t;\n    var n = (end - offset) / stride;\n    if (n === 1) {\n        o = offset;\n    }\n    else if (n === 2) {\n        o = offset;\n        t = fraction;\n    }\n    else if (n !== 0) {\n        var x1 = flatCoordinates[offset];\n        var y1 = flatCoordinates[offset + 1];\n        var length_1 = 0;\n        var cumulativeLengths = [0];\n        for (var i = offset + stride; i < end; i += stride) {\n            var x2 = flatCoordinates[i];\n            var y2 = flatCoordinates[i + 1];\n            length_1 += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n            cumulativeLengths.push(length_1);\n            x1 = x2;\n            y1 = y2;\n        }\n        var target = fraction * length_1;\n        var index = binarySearch(cumulativeLengths, target);\n        if (index < 0) {\n            t =\n                (target - cumulativeLengths[-index - 2]) /\n                    (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);\n            o = offset + (-index - 2) * stride;\n        }\n        else {\n            o = offset + index * stride;\n        }\n    }\n    var dimension = opt_dimension > 1 ? opt_dimension : 2;\n    var dest = opt_dest ? opt_dest : new Array(dimension);\n    for (var i = 0; i < dimension; ++i) {\n        dest[i] =\n            o === undefined\n                ? NaN\n                : t === undefined\n                    ? flatCoordinates[o + i]\n                    : lerp(flatCoordinates[o + i], flatCoordinates[o + stride + i], t);\n    }\n    return dest;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @return {import(\"../../coordinate.js\").Coordinate|null} Coordinate.\n */\nexport function lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, extrapolate) {\n    if (end == offset) {\n        return null;\n    }\n    var coordinate;\n    if (m < flatCoordinates[offset + stride - 1]) {\n        if (extrapolate) {\n            coordinate = flatCoordinates.slice(offset, offset + stride);\n            coordinate[stride - 1] = m;\n            return coordinate;\n        }\n        else {\n            return null;\n        }\n    }\n    else if (flatCoordinates[end - 1] < m) {\n        if (extrapolate) {\n            coordinate = flatCoordinates.slice(end - stride, end);\n            coordinate[stride - 1] = m;\n            return coordinate;\n        }\n        else {\n            return null;\n        }\n    }\n    // FIXME use O(1) search\n    if (m == flatCoordinates[offset + stride - 1]) {\n        return flatCoordinates.slice(offset, offset + stride);\n    }\n    var lo = offset / stride;\n    var hi = end / stride;\n    while (lo < hi) {\n        var mid = (lo + hi) >> 1;\n        if (m < flatCoordinates[(mid + 1) * stride - 1]) {\n            hi = mid;\n        }\n        else {\n            lo = mid + 1;\n        }\n    }\n    var m0 = flatCoordinates[lo * stride - 1];\n    if (m == m0) {\n        return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);\n    }\n    var m1 = flatCoordinates[(lo + 1) * stride - 1];\n    var t = (m - m0) / (m1 - m0);\n    coordinate = [];\n    for (var i = 0; i < stride - 1; ++i) {\n        coordinate.push(lerp(flatCoordinates[(lo - 1) * stride + i], flatCoordinates[lo * stride + i], t));\n    }\n    coordinate.push(m);\n    return coordinate;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @param {boolean} interpolate Interpolate.\n * @return {import(\"../../coordinate.js\").Coordinate|null} Coordinate.\n */\nexport function lineStringsCoordinateAtM(flatCoordinates, offset, ends, stride, m, extrapolate, interpolate) {\n    if (interpolate) {\n        return lineStringCoordinateAtM(flatCoordinates, offset, ends[ends.length - 1], stride, m, extrapolate);\n    }\n    var coordinate;\n    if (m < flatCoordinates[stride - 1]) {\n        if (extrapolate) {\n            coordinate = flatCoordinates.slice(0, stride);\n            coordinate[stride - 1] = m;\n            return coordinate;\n        }\n        else {\n            return null;\n        }\n    }\n    if (flatCoordinates[flatCoordinates.length - 1] < m) {\n        if (extrapolate) {\n            coordinate = flatCoordinates.slice(flatCoordinates.length - stride);\n            coordinate[stride - 1] = m;\n            return coordinate;\n        }\n        else {\n            return null;\n        }\n    }\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n        var end = ends[i];\n        if (offset == end) {\n            continue;\n        }\n        if (m < flatCoordinates[offset + stride - 1]) {\n            return null;\n        }\n        else if (m <= flatCoordinates[end - 1]) {\n            return lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, false);\n        }\n        offset = end;\n    }\n    return null;\n}\n//# sourceMappingURL=interpolate.js.map","/**\n * @module ol/geom/flat/intersectsextent\n */\nimport { containsExtent, createEmpty, extendFlatCoordinates, intersects, intersectsSegment, } from '../../extent.js';\nimport { forEach as forEachSegment } from './segments.js';\nimport { linearRingContainsExtent, linearRingContainsXY } from './contains.js';\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLineString(flatCoordinates, offset, end, stride, extent) {\n    var coordinatesExtent = extendFlatCoordinates(createEmpty(), flatCoordinates, offset, end, stride);\n    if (!intersects(extent, coordinatesExtent)) {\n        return false;\n    }\n    if (containsExtent(extent, coordinatesExtent)) {\n        return true;\n    }\n    if (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2]) {\n        return true;\n    }\n    if (coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3]) {\n        return true;\n    }\n    return forEachSegment(flatCoordinates, offset, end, stride, \n    /**\n     * @param {import(\"../../coordinate.js\").Coordinate} point1 Start point.\n     * @param {import(\"../../coordinate.js\").Coordinate} point2 End point.\n     * @return {boolean} `true` if the segment and the extent intersect,\n     *     `false` otherwise.\n     */\n    function (point1, point2) {\n        return intersectsSegment(extent, point1, point2);\n    });\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLineStringArray(flatCoordinates, offset, ends, stride, extent) {\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n        if (intersectsLineString(flatCoordinates, offset, ends[i], stride, extent)) {\n            return true;\n        }\n        offset = ends[i];\n    }\n    return false;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLinearRing(flatCoordinates, offset, end, stride, extent) {\n    if (intersectsLineString(flatCoordinates, offset, end, stride, extent)) {\n        return true;\n    }\n    if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[0], extent[1])) {\n        return true;\n    }\n    if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[0], extent[3])) {\n        return true;\n    }\n    if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[2], extent[1])) {\n        return true;\n    }\n    if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[2], extent[3])) {\n        return true;\n    }\n    return false;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent) {\n    if (!intersectsLinearRing(flatCoordinates, offset, ends[0], stride, extent)) {\n        return false;\n    }\n    if (ends.length === 1) {\n        return true;\n    }\n    for (var i = 1, ii = ends.length; i < ii; ++i) {\n        if (linearRingContainsExtent(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {\n            if (!intersectsLineString(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLinearRingMultiArray(flatCoordinates, offset, endss, stride, extent) {\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n        var ends = endss[i];\n        if (intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent)) {\n            return true;\n        }\n        offset = ends[ends.length - 1];\n    }\n    return false;\n}\n//# sourceMappingURL=intersectsextent.js.map","/**\n * @module ol/geom/flat/length\n */\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {number} Length.\n */\nexport function lineStringLength(flatCoordinates, offset, end, stride) {\n    var x1 = flatCoordinates[offset];\n    var y1 = flatCoordinates[offset + 1];\n    var length = 0;\n    for (var i = offset + stride; i < end; i += stride) {\n        var x2 = flatCoordinates[i];\n        var y2 = flatCoordinates[i + 1];\n        length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n        x1 = x2;\n        y1 = y2;\n    }\n    return length;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {number} Perimeter.\n */\nexport function linearRingLength(flatCoordinates, offset, end, stride) {\n    var perimeter = lineStringLength(flatCoordinates, offset, end, stride);\n    var dx = flatCoordinates[end - stride] - flatCoordinates[offset];\n    var dy = flatCoordinates[end - stride + 1] - flatCoordinates[offset + 1];\n    perimeter += Math.sqrt(dx * dx + dy * dy);\n    return perimeter;\n}\n//# sourceMappingURL=length.js.map","/**\n * @module ol/geom/flat/reverse\n */\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n */\nexport function coordinates(flatCoordinates, offset, end, stride) {\n    while (offset < end - stride) {\n        for (var i = 0; i < stride; ++i) {\n            var tmp = flatCoordinates[offset + i];\n            flatCoordinates[offset + i] = flatCoordinates[end - stride + i];\n            flatCoordinates[end - stride + i] = tmp;\n        }\n        offset += stride;\n        end -= stride;\n    }\n}\n//# sourceMappingURL=reverse.js.map","/**\n * @module ol/geom/flat/orient\n */\nimport { coordinates as reverseCoordinates } from './reverse.js';\n/**\n * Is the linear ring oriented clockwise in a coordinate system with a bottom-left\n * coordinate origin? For a coordinate system with a top-left coordinate origin,\n * the ring's orientation is clockwise when this function returns false.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {boolean} Is clockwise.\n */\nexport function linearRingIsClockwise(flatCoordinates, offset, end, stride) {\n    // https://stackoverflow.com/q/1165647/clockwise-method#1165943\n    // https://github.com/OSGeo/gdal/blob/master/gdal/ogr/ogrlinearring.cpp\n    var edge = 0;\n    var x1 = flatCoordinates[end - stride];\n    var y1 = flatCoordinates[end - stride + 1];\n    for (; offset < end; offset += stride) {\n        var x2 = flatCoordinates[offset];\n        var y2 = flatCoordinates[offset + 1];\n        edge += (x2 - x1) * (y2 + y1);\n        x1 = x2;\n        y1 = y2;\n    }\n    return edge === 0 ? undefined : edge > 0;\n}\n/**\n * Determines if linear rings are oriented.  By default, left-hand orientation\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n * To test for right-hand orientation, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean} [opt_right] Test for right-hand orientation\n *     (counter-clockwise exterior ring and clockwise interior rings).\n * @return {boolean} Rings are correctly oriented.\n */\nexport function linearRingsAreOriented(flatCoordinates, offset, ends, stride, opt_right) {\n    var right = opt_right !== undefined ? opt_right : false;\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n        var end = ends[i];\n        var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);\n        if (i === 0) {\n            if ((right && isClockwise) || (!right && !isClockwise)) {\n                return false;\n            }\n        }\n        else {\n            if ((right && !isClockwise) || (!right && isClockwise)) {\n                return false;\n            }\n        }\n        offset = end;\n    }\n    return true;\n}\n/**\n * Determines if linear rings are oriented.  By default, left-hand orientation\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n * To test for right-hand orientation, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Array of array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean} [opt_right] Test for right-hand orientation\n *     (counter-clockwise exterior ring and clockwise interior rings).\n * @return {boolean} Rings are correctly oriented.\n */\nexport function linearRingssAreOriented(flatCoordinates, offset, endss, stride, opt_right) {\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n        var ends = endss[i];\n        if (!linearRingsAreOriented(flatCoordinates, offset, ends, stride, opt_right)) {\n            return false;\n        }\n        if (ends.length) {\n            offset = ends[ends.length - 1];\n        }\n    }\n    return true;\n}\n/**\n * Orient coordinates in a flat array of linear rings.  By default, rings\n * are oriented following the left-hand rule (clockwise for exterior and\n * counter-clockwise for interior rings).  To orient according to the\n * right-hand rule, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {boolean} [opt_right] Follow the right-hand rule for orientation.\n * @return {number} End.\n */\nexport function orientLinearRings(flatCoordinates, offset, ends, stride, opt_right) {\n    var right = opt_right !== undefined ? opt_right : false;\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n        var end = ends[i];\n        var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);\n        var reverse = i === 0\n            ? (right && isClockwise) || (!right && !isClockwise)\n            : (right && !isClockwise) || (!right && isClockwise);\n        if (reverse) {\n            reverseCoordinates(flatCoordinates, offset, end, stride);\n        }\n        offset = end;\n    }\n    return offset;\n}\n/**\n * Orient coordinates in a flat array of linear rings.  By default, rings\n * are oriented following the left-hand rule (clockwise for exterior and\n * counter-clockwise for interior rings).  To orient according to the\n * right-hand rule, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Array of array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean} [opt_right] Follow the right-hand rule for orientation.\n * @return {number} End.\n */\nexport function orientLinearRingsArray(flatCoordinates, offset, endss, stride, opt_right) {\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n        offset = orientLinearRings(flatCoordinates, offset, endss[i], stride, opt_right);\n    }\n    return offset;\n}\n/**\n * Return a two-dimensional endss\n * @param {Array<number>} flatCoordinates Flat coordinates\n * @param {Array<number>} ends Linear ring end indexes\n * @return {Array<Array<number>>} Two dimensional endss array that can\n * be used to contruct a MultiPolygon\n */\nexport function inflateEnds(flatCoordinates, ends) {\n    var endss = [];\n    var offset = 0;\n    var prevEndIndex = 0;\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n        var end = ends[i];\n        // classifies an array of rings into polygons with outer rings and holes\n        if (!linearRingIsClockwise(flatCoordinates, offset, end, 2)) {\n            endss.push(ends.slice(prevEndIndex, i + 1));\n        }\n        else {\n            if (endss.length === 0) {\n                continue;\n            }\n            endss[endss.length - 1].push(ends[prevEndIndex]);\n        }\n        prevEndIndex = i + 1;\n        offset = end;\n    }\n    return endss;\n}\n//# sourceMappingURL=orient.js.map","/**\n * @module ol/geom/flat/segments\n */\n/**\n * This function calls `callback` for each segment of the flat coordinates\n * array. If the callback returns a truthy value the function returns that\n * value immediately. Otherwise the function returns `false`.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {function(import(\"../../coordinate.js\").Coordinate, import(\"../../coordinate.js\").Coordinate): T} callback Function\n *     called for each segment.\n * @return {T|boolean} Value.\n * @template T\n */\nexport function forEach(flatCoordinates, offset, end, stride, callback) {\n    var ret;\n    offset += stride;\n    for (; offset < end; offset += stride) {\n        ret = callback(flatCoordinates.slice(offset - stride, offset), flatCoordinates.slice(offset, offset + stride));\n        if (ret) {\n            return ret;\n        }\n    }\n    return false;\n}\n//# sourceMappingURL=segments.js.map","/**\n * @module ol/geom/flat/simplify\n */\n// Based on simplify-js https://github.com/mourner/simplify-js\n// Copyright (c) 2012, Vladimir Agafonkin\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n//    1. Redistributions of source code must retain the above copyright notice,\n//       this list of conditions and the following disclaimer.\n//\n//    2. Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\nimport { squaredDistance, squaredSegmentDistance } from '../../math.js';\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {boolean} highQuality Highest quality.\n * @param {Array<number>} [opt_simplifiedFlatCoordinates] Simplified flat\n *     coordinates.\n * @return {Array<number>} Simplified line string.\n */\nexport function simplifyLineString(flatCoordinates, offset, end, stride, squaredTolerance, highQuality, opt_simplifiedFlatCoordinates) {\n    var simplifiedFlatCoordinates = opt_simplifiedFlatCoordinates !== undefined\n        ? opt_simplifiedFlatCoordinates\n        : [];\n    if (!highQuality) {\n        end = radialDistance(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);\n        flatCoordinates = simplifiedFlatCoordinates;\n        offset = 0;\n        stride = 2;\n    }\n    simplifiedFlatCoordinates.length = douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);\n    return simplifiedFlatCoordinates;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\nexport function douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {\n    var n = (end - offset) / stride;\n    if (n < 3) {\n        for (; offset < end; offset += stride) {\n            simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];\n            simplifiedFlatCoordinates[simplifiedOffset++] =\n                flatCoordinates[offset + 1];\n        }\n        return simplifiedOffset;\n    }\n    /** @type {Array<number>} */\n    var markers = new Array(n);\n    markers[0] = 1;\n    markers[n - 1] = 1;\n    /** @type {Array<number>} */\n    var stack = [offset, end - stride];\n    var index = 0;\n    while (stack.length > 0) {\n        var last = stack.pop();\n        var first = stack.pop();\n        var maxSquaredDistance = 0;\n        var x1 = flatCoordinates[first];\n        var y1 = flatCoordinates[first + 1];\n        var x2 = flatCoordinates[last];\n        var y2 = flatCoordinates[last + 1];\n        for (var i = first + stride; i < last; i += stride) {\n            var x = flatCoordinates[i];\n            var y = flatCoordinates[i + 1];\n            var squaredDistance_1 = squaredSegmentDistance(x, y, x1, y1, x2, y2);\n            if (squaredDistance_1 > maxSquaredDistance) {\n                index = i;\n                maxSquaredDistance = squaredDistance_1;\n            }\n        }\n        if (maxSquaredDistance > squaredTolerance) {\n            markers[(index - offset) / stride] = 1;\n            if (first + stride < index) {\n                stack.push(first, index);\n            }\n            if (index + stride < last) {\n                stack.push(index, last);\n            }\n        }\n    }\n    for (var i = 0; i < n; ++i) {\n        if (markers[i]) {\n            simplifiedFlatCoordinates[simplifiedOffset++] =\n                flatCoordinates[offset + i * stride];\n            simplifiedFlatCoordinates[simplifiedOffset++] =\n                flatCoordinates[offset + i * stride + 1];\n        }\n    }\n    return simplifiedOffset;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<number>} simplifiedEnds Simplified ends.\n * @return {number} Simplified offset.\n */\nexport function douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n        var end = ends[i];\n        simplifiedOffset = douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset);\n        simplifiedEnds.push(simplifiedOffset);\n        offset = end;\n    }\n    return simplifiedOffset;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<Array<number>>} simplifiedEndss Simplified endss.\n * @return {number} Simplified offset.\n */\nexport function douglasPeuckerMultiArray(flatCoordinates, offset, endss, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n        var ends = endss[i];\n        var simplifiedEnds = [];\n        simplifiedOffset = douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);\n        simplifiedEndss.push(simplifiedEnds);\n        offset = ends[ends.length - 1];\n    }\n    return simplifiedOffset;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\nexport function radialDistance(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {\n    if (end <= offset + stride) {\n        // zero or one point, no simplification possible, so copy and return\n        for (; offset < end; offset += stride) {\n            simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];\n            simplifiedFlatCoordinates[simplifiedOffset++] =\n                flatCoordinates[offset + 1];\n        }\n        return simplifiedOffset;\n    }\n    var x1 = flatCoordinates[offset];\n    var y1 = flatCoordinates[offset + 1];\n    // copy first point\n    simplifiedFlatCoordinates[simplifiedOffset++] = x1;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y1;\n    var x2 = x1;\n    var y2 = y1;\n    for (offset += stride; offset < end; offset += stride) {\n        x2 = flatCoordinates[offset];\n        y2 = flatCoordinates[offset + 1];\n        if (squaredDistance(x1, y1, x2, y2) > squaredTolerance) {\n            // copy point at offset\n            simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n            simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n            x1 = x2;\n            y1 = y2;\n        }\n    }\n    if (x2 != x1 || y2 != y1) {\n        // copy last point\n        simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n        simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n    }\n    return simplifiedOffset;\n}\n/**\n * @param {number} value Value.\n * @param {number} tolerance Tolerance.\n * @return {number} Rounded value.\n */\nexport function snap(value, tolerance) {\n    return tolerance * Math.round(value / tolerance);\n}\n/**\n * Simplifies a line string using an algorithm designed by Tim Schaub.\n * Coordinates are snapped to the nearest value in a virtual grid and\n * consecutive duplicate coordinates are discarded.  This effectively preserves\n * topology as the simplification of any subsection of a line string is\n * independent of the rest of the line string.  This means that, for examples,\n * the common edge between two polygons will be simplified to the same line\n * string independently in both polygons.  This implementation uses a single\n * pass over the coordinates and eliminates intermediate collinear points.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\nexport function quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset) {\n    // do nothing if the line is empty\n    if (offset == end) {\n        return simplifiedOffset;\n    }\n    // snap the first coordinate (P1)\n    var x1 = snap(flatCoordinates[offset], tolerance);\n    var y1 = snap(flatCoordinates[offset + 1], tolerance);\n    offset += stride;\n    // add the first coordinate to the output\n    simplifiedFlatCoordinates[simplifiedOffset++] = x1;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y1;\n    // find the next coordinate that does not snap to the same value as the first\n    // coordinate (P2)\n    var x2, y2;\n    do {\n        x2 = snap(flatCoordinates[offset], tolerance);\n        y2 = snap(flatCoordinates[offset + 1], tolerance);\n        offset += stride;\n        if (offset == end) {\n            // all coordinates snap to the same value, the line collapses to a point\n            // push the last snapped value anyway to ensure that the output contains\n            // at least two points\n            // FIXME should we really return at least two points anyway?\n            simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n            simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n            return simplifiedOffset;\n        }\n    } while (x2 == x1 && y2 == y1);\n    while (offset < end) {\n        // snap the next coordinate (P3)\n        var x3 = snap(flatCoordinates[offset], tolerance);\n        var y3 = snap(flatCoordinates[offset + 1], tolerance);\n        offset += stride;\n        // skip P3 if it is equal to P2\n        if (x3 == x2 && y3 == y2) {\n            continue;\n        }\n        // calculate the delta between P1 and P2\n        var dx1 = x2 - x1;\n        var dy1 = y2 - y1;\n        // calculate the delta between P3 and P1\n        var dx2 = x3 - x1;\n        var dy2 = y3 - y1;\n        // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from\n        // P1 in the same direction then P2 is on the straight line between P1 and\n        // P3\n        if (dx1 * dy2 == dy1 * dx2 &&\n            ((dx1 < 0 && dx2 < dx1) || dx1 == dx2 || (dx1 > 0 && dx2 > dx1)) &&\n            ((dy1 < 0 && dy2 < dy1) || dy1 == dy2 || (dy1 > 0 && dy2 > dy1))) {\n            // discard P2 and set P2 = P3\n            x2 = x3;\n            y2 = y3;\n            continue;\n        }\n        // either P1, P2, and P3 are not colinear, or they are colinear but P3 is\n        // between P3 and P1 or on the opposite half of the line to P2.  add P2,\n        // and continue with P1 = P2 and P2 = P3\n        simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n        simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n        x1 = x2;\n        y1 = y2;\n        x2 = x3;\n        y2 = y3;\n    }\n    // add the last point (P2)\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n    return simplifiedOffset;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<number>} simplifiedEnds Simplified ends.\n * @return {number} Simplified offset.\n */\nexport function quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n        var end = ends[i];\n        simplifiedOffset = quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset);\n        simplifiedEnds.push(simplifiedOffset);\n        offset = end;\n    }\n    return simplifiedOffset;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<Array<number>>} simplifiedEndss Simplified endss.\n * @return {number} Simplified offset.\n */\nexport function quantizeMultiArray(flatCoordinates, offset, endss, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n        var ends = endss[i];\n        var simplifiedEnds = [];\n        simplifiedOffset = quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);\n        simplifiedEndss.push(simplifiedEnds);\n        offset = ends[ends.length - 1];\n    }\n    return simplifiedOffset;\n}\n//# sourceMappingURL=simplify.js.map","/**\n * @module ol/geom/flat/straightchunk\n */\n/**\n * @param {number} maxAngle Maximum acceptable angle delta between segments.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {Array<number>} Start and end of the first suitable chunk of the\n * given `flatCoordinates`.\n */\nexport function matchingChunk(maxAngle, flatCoordinates, offset, end, stride) {\n    var chunkStart = offset;\n    var chunkEnd = offset;\n    var chunkM = 0;\n    var m = 0;\n    var start = offset;\n    var acos, i, m12, m23, x1, y1, x12, y12, x23, y23;\n    for (i = offset; i < end; i += stride) {\n        var x2 = flatCoordinates[i];\n        var y2 = flatCoordinates[i + 1];\n        if (x1 !== undefined) {\n            x23 = x2 - x1;\n            y23 = y2 - y1;\n            m23 = Math.sqrt(x23 * x23 + y23 * y23);\n            if (x12 !== undefined) {\n                m += m12;\n                acos = Math.acos((x12 * x23 + y12 * y23) / (m12 * m23));\n                if (acos > maxAngle) {\n                    if (m > chunkM) {\n                        chunkM = m;\n                        chunkStart = start;\n                        chunkEnd = i;\n                    }\n                    m = 0;\n                    start = i - stride;\n                }\n            }\n            m12 = m23;\n            x12 = x23;\n            y12 = y23;\n        }\n        x1 = x2;\n        y1 = y2;\n    }\n    m += m23;\n    return m > chunkM ? [start, i] : [chunkStart, chunkEnd];\n}\n//# sourceMappingURL=straightchunk.js.map","/**\n * @module ol/geom/flat/textpath\n */\nimport { lerp } from '../../math.js';\nimport { rotate } from './transform.js';\n/**\n * @param {Array<number>} flatCoordinates Path to put text on.\n * @param {number} offset Start offset of the `flatCoordinates`.\n * @param {number} end End offset of the `flatCoordinates`.\n * @param {number} stride Stride.\n * @param {string} text Text to place on the path.\n * @param {number} startM m along the path where the text starts.\n * @param {number} maxAngle Max angle between adjacent chars in radians.\n * @param {number} scale The product of the text scale and the device pixel ratio.\n * @param {function(string, string, Object<string, number>):number} measureAndCacheTextWidth Measure and cache text width.\n * @param {string} font The font.\n * @param {Object<string, number>} cache A cache of measured widths.\n * @param {number} rotation Rotation to apply to the flatCoordinates to determine whether text needs to be reversed.\n * @return {Array<Array<*>>|null} The result array (or null if `maxAngle` was\n * exceeded). Entries of the array are x, y, anchorX, angle, chunk.\n */\nexport function drawTextOnPath(flatCoordinates, offset, end, stride, text, startM, maxAngle, scale, measureAndCacheTextWidth, font, cache, rotation) {\n    var x2 = flatCoordinates[offset];\n    var y2 = flatCoordinates[offset + 1];\n    var x1 = 0;\n    var y1 = 0;\n    var segmentLength = 0;\n    var segmentM = 0;\n    function advance() {\n        x1 = x2;\n        y1 = y2;\n        offset += stride;\n        x2 = flatCoordinates[offset];\n        y2 = flatCoordinates[offset + 1];\n        segmentM += segmentLength;\n        segmentLength = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n    }\n    do {\n        advance();\n    } while (offset < end - stride && segmentM + segmentLength < startM);\n    var interpolate = segmentLength === 0 ? 0 : (startM - segmentM) / segmentLength;\n    var beginX = lerp(x1, x2, interpolate);\n    var beginY = lerp(y1, y2, interpolate);\n    var startOffset = offset - stride;\n    var startLength = segmentM;\n    var endM = startM + scale * measureAndCacheTextWidth(font, text, cache);\n    while (offset < end - stride && segmentM + segmentLength < endM) {\n        advance();\n    }\n    interpolate = segmentLength === 0 ? 0 : (endM - segmentM) / segmentLength;\n    var endX = lerp(x1, x2, interpolate);\n    var endY = lerp(y1, y2, interpolate);\n    // Keep text upright\n    var reverse;\n    if (rotation) {\n        var flat = [beginX, beginY, endX, endY];\n        rotate(flat, 0, 4, 2, rotation, flat, flat);\n        reverse = flat[0] > flat[2];\n    }\n    else {\n        reverse = beginX > endX;\n    }\n    var PI = Math.PI;\n    var result = [];\n    var singleSegment = startOffset + stride === offset;\n    offset = startOffset;\n    segmentLength = 0;\n    segmentM = startLength;\n    x2 = flatCoordinates[offset];\n    y2 = flatCoordinates[offset + 1];\n    var previousAngle;\n    // All on the same segment\n    if (singleSegment) {\n        advance();\n        previousAngle = Math.atan2(y2 - y1, x2 - x1);\n        if (reverse) {\n            previousAngle += previousAngle > 0 ? -PI : PI;\n        }\n        var x = (endX + beginX) / 2;\n        var y = (endY + beginY) / 2;\n        result[0] = [x, y, (endM - startM) / 2, previousAngle, text];\n        return result;\n    }\n    // rendering across line segments\n    text = text.replace(/\\n/g, ' '); // ensure rendering in single-line as all calculations below don't handle multi-lines\n    for (var i = 0, ii = text.length; i < ii;) {\n        advance();\n        var angle = Math.atan2(y2 - y1, x2 - x1);\n        if (reverse) {\n            angle += angle > 0 ? -PI : PI;\n        }\n        if (previousAngle !== undefined) {\n            var delta = angle - previousAngle;\n            delta += delta > PI ? -2 * PI : delta < -PI ? 2 * PI : 0;\n            if (Math.abs(delta) > maxAngle) {\n                return null;\n            }\n        }\n        previousAngle = angle;\n        var iStart = i;\n        var charLength = 0;\n        for (; i < ii; ++i) {\n            var index = reverse ? ii - i - 1 : i;\n            var len = scale * measureAndCacheTextWidth(font, text[index], cache);\n            if (offset + stride < end &&\n                segmentM + segmentLength < startM + charLength + len / 2) {\n                break;\n            }\n            charLength += len;\n        }\n        if (i === iStart) {\n            continue;\n        }\n        var chars = reverse\n            ? text.substring(ii - iStart, ii - i)\n            : text.substring(iStart, i);\n        interpolate =\n            segmentLength === 0\n                ? 0\n                : (startM + charLength / 2 - segmentM) / segmentLength;\n        var x = lerp(x1, x2, interpolate);\n        var y = lerp(y1, y2, interpolate);\n        result.push([x, y, charLength / 2, angle, chars]);\n        startM += charLength;\n    }\n    return result;\n}\n//# sourceMappingURL=textpath.js.map","/**\n * @module ol/geom/flat/transform\n */\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../transform.js\").Transform} transform Transform.\n * @param {Array<number>} [opt_dest] Destination.\n * @return {Array<number>} Transformed coordinates.\n */\nexport function transform2D(flatCoordinates, offset, end, stride, transform, opt_dest) {\n    var dest = opt_dest ? opt_dest : [];\n    var i = 0;\n    for (var j = offset; j < end; j += stride) {\n        var x = flatCoordinates[j];\n        var y = flatCoordinates[j + 1];\n        dest[i++] = transform[0] * x + transform[2] * y + transform[4];\n        dest[i++] = transform[1] * x + transform[3] * y + transform[5];\n    }\n    if (opt_dest && dest.length != i) {\n        dest.length = i;\n    }\n    return dest;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} angle Angle.\n * @param {Array<number>} anchor Rotation anchor point.\n * @param {Array<number>} [opt_dest] Destination.\n * @return {Array<number>} Transformed coordinates.\n */\nexport function rotate(flatCoordinates, offset, end, stride, angle, anchor, opt_dest) {\n    var dest = opt_dest ? opt_dest : [];\n    var cos = Math.cos(angle);\n    var sin = Math.sin(angle);\n    var anchorX = anchor[0];\n    var anchorY = anchor[1];\n    var i = 0;\n    for (var j = offset; j < end; j += stride) {\n        var deltaX = flatCoordinates[j] - anchorX;\n        var deltaY = flatCoordinates[j + 1] - anchorY;\n        dest[i++] = anchorX + deltaX * cos - deltaY * sin;\n        dest[i++] = anchorY + deltaX * sin + deltaY * cos;\n        for (var k = j + 2; k < j + stride; ++k) {\n            dest[i++] = flatCoordinates[k];\n        }\n    }\n    if (opt_dest && dest.length != i) {\n        dest.length = i;\n    }\n    return dest;\n}\n/**\n * Scale the coordinates.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} sx Scale factor in the x-direction.\n * @param {number} sy Scale factor in the y-direction.\n * @param {Array<number>} anchor Scale anchor point.\n * @param {Array<number>} [opt_dest] Destination.\n * @return {Array<number>} Transformed coordinates.\n */\nexport function scale(flatCoordinates, offset, end, stride, sx, sy, anchor, opt_dest) {\n    var dest = opt_dest ? opt_dest : [];\n    var anchorX = anchor[0];\n    var anchorY = anchor[1];\n    var i = 0;\n    for (var j = offset; j < end; j += stride) {\n        var deltaX = flatCoordinates[j] - anchorX;\n        var deltaY = flatCoordinates[j + 1] - anchorY;\n        dest[i++] = anchorX + sx * deltaX;\n        dest[i++] = anchorY + sy * deltaY;\n        for (var k = j + 2; k < j + stride; ++k) {\n            dest[i++] = flatCoordinates[k];\n        }\n    }\n    if (opt_dest && dest.length != i) {\n        dest.length = i;\n    }\n    return dest;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} deltaX Delta X.\n * @param {number} deltaY Delta Y.\n * @param {Array<number>} [opt_dest] Destination.\n * @return {Array<number>} Transformed coordinates.\n */\nexport function translate(flatCoordinates, offset, end, stride, deltaX, deltaY, opt_dest) {\n    var dest = opt_dest ? opt_dest : [];\n    var i = 0;\n    for (var j = offset; j < end; j += stride) {\n        dest[i++] = flatCoordinates[j] + deltaX;\n        dest[i++] = flatCoordinates[j + 1] + deltaY;\n        for (var k = j + 2; k < j + stride; ++k) {\n            dest[i++] = flatCoordinates[k];\n        }\n    }\n    if (opt_dest && dest.length != i) {\n        dest.length = i;\n    }\n    return dest;\n}\n//# sourceMappingURL=transform.js.map"],"names":["TRUE","FALSE","VOID","memoizeOne","fn","lastResult","lastArgs","lastThis","called","nextArgs","Array","prototype","slice","call","arguments","this","apply","toPromise","getter","promiseGetter","value","err","Promise","reject","resolve","__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","p","hasOwnProperty","TypeError","String","__","constructor","create","tmpTransform","Geometry","_super","_this","extent_","extentRevision_","simplifiedGeometryMaxMinSquaredTolerance","simplifiedGeometryRevision","simplifyTransformedInternal","revision","squaredTolerance","opt_transform","getSimplifiedGeometry","clone","applyTransform","simplifyTransformed","getRevision","closestPointXY","x","y","closestPoint","minSquaredDistance","containsXY","coord","getClosestPoint","point","opt_closestPoint","NaN","Infinity","intersectsCoordinate","coordinate","computeExtent","extent","getExtent","opt_extent","isNaN","rotate","angle","anchor","scale","sx","opt_sy","opt_anchor","simplify","tolerance","getType","transformFn","intersectsExtent","translate","deltaX","deltaY","transform","source","destination","sourceProj","getUnits","inCoordinates","outCoordinates","stride","pixelExtent","projectedExtent","getWorldExtent","length","GeometryCollection","opt_geometries","geometries_","changeEventsKeys_","listenGeometriesChange_","unlistenGeometriesChange_","forEach","i","ii","push","changed","geometryCollection","setGeometries","applyProperties","geometries","getGeometries","cloneGeometries","getGeometriesArray","getGeometriesArrayRecursive","geometriesArray","concat","simplifiedGeometries","simplified","geometry","simplifiedGeometry","simplifiedGeometryCollection","setGeometriesArray","isEmpty","disposeInternal","clonedGeometries","XY","XYZ","XYM","XYZM","LineString","coordinates","opt_layout","flatMidpoint_","flatMidpointRevision_","maxDelta_","maxDeltaRevision_","undefined","isArray","setCoordinates","setFlatCoordinates","appendCoordinate","flatCoordinates","lineString","layout","Math","sqrt","forEachSegment","callback","getCoordinateAtM","m","opt_extrapolate","extrapolate","getCoordinates","getCoordinateAt","fraction","opt_dest","getLength","getFlatMidpoint","getSimplifiedGeometryInternal","simplifiedFlatCoordinates","setLayout","LinearRing","getArea","MultiLineString","opt_ends","ends_","getLayout","lineStrings","ends","getFlatCoordinates","appendLineString","multiLineString","opt_interpolate","interpolate","getEnds","getLineString","index","getLineStrings","offset","end","getFlatMidpoints","midpoints","midpoint","simplifiedEnds","MultiPoint","appendPoint","multiPoint","squaredDistance","j","getPoint","n","getPoints","points","linearRingss","endss","flatCenters","MultiPolygon","opt_endss","endss_","flatInteriorPointsRevision_","flatInteriorPoints_","orientedRevision_","orientedFlatCoordinates_","polygons","polygon","jj","appendPolygon","len","newEndss","multiPolygon","getOrientedFlatCoordinates","opt_right","orient","inflate","getEndss","getFlatInteriorPoints","getInteriorPoints","GeometryLayout","simplifiedEndss","getPolygon","prevEnds","Polygon","getPolygons","deflate","lastEnds","SimpleGeometry","Point","flatInteriorPointRevision_","flatInteriorPoint_","appendLinearRing","linearRing","getFlatInteriorPoint","flatCenter","getInteriorPoint","getLinearRingCount","getLinearRing","getLinearRings","linearRings","fromExtent","minX","minY","maxX","maxY","fromCircle","circle","opt_sides","opt_angle","sides","getStride","center","getCenter","arrayLength","makeRegular","getRadius","radius","startAngle","PI","cos","sin","getFirstCoordinate","getLastCoordinate","getStrideForLayout","nesting","getLayoutForStride","sy","transformGeom2D","simpleGeometry","twiceArea","x1","y1","x2","y2","area","assignClosest","offset1","offset2","dx","dy","t","maxSquaredDelta","max","squaredDelta","arrayMaxSquaredDelta","multiArrayMaxSquaredDelta","assignClosestPoint","maxDelta","isRing","opt_tmpPoint","tmpPoint","assignClosestArrayPoint","assignClosestMultiArrayPoint","linearRingContainsExtent","outside","linearRingContainsXY","wn","linearRingsContainsXY","linearRingssContainsXY","deflateCoordinate","deflateCoordinates","deflateCoordinatesArray","coordinatess","deflateMultiCoordinatesArray","coordinatesss","inflateCoordinates","opt_coordinates","inflateCoordinatesArray","opt_coordinatess","inflateMultiCoordinatesArray","opt_coordinatesss","getInteriorPointOfArray","flatCentersOffset","intersections","r","rr","pointX","maxSegmentLength","sort","segmentLength","abs","getInteriorPointsOfMultiArray","interiorPoints","interpolatePoint","opt_dimension","o","length_1","cumulativeLengths","target","dimension","dest","lineStringCoordinateAtM","lo","hi","mid","m0","m1","lineStringsCoordinateAtM","intersectsLineString","coordinatesExtent","point1","point2","intersectsLineStringArray","intersectsLinearRing","intersectsLinearRingArray","intersectsLinearRingMultiArray","lineStringLength","tmp","linearRingIsClockwise","edge","linearRingsAreOriented","right","isClockwise","linearRingssAreOriented","orientLinearRings","reverse","orientLinearRingsArray","ret","douglasPeucker","simplifiedOffset","markers","stack","last","pop","first","maxSquaredDistance","squaredDistance_1","douglasPeuckerArray","snap","round","quantize","x3","y3","dx1","dy1","dx2","dy2","quantizeArray","quantizeMultiArray","matchingChunk","maxAngle","acos","m12","m23","x12","y12","x23","y23","chunkStart","chunkEnd","chunkM","start","drawTextOnPath","text","startM","measureAndCacheTextWidth","font","cache","rotation","segmentM","advance","beginX","beginY","startOffset","startLength","endM","endX","endY","flat","previousAngle","result","singleSegment","atan2","replace","delta","iStart","charLength","chars","substring","transform2D","anchorX","anchorY","k"],"sourceRoot":""}
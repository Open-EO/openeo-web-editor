{"version":3,"file":"js/5137.3f88ca8a.js","mappings":"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","sources":["webpack://@openeo/web-editor/./node_modules/ol/reproj.js","webpack://@openeo/web-editor/./node_modules/ol/reproj/Tile.js","webpack://@openeo/web-editor/./node_modules/ol/reproj/Triangulation.js","webpack://@openeo/web-editor/./node_modules/ol/reproj/common.js","webpack://@openeo/web-editor/./node_modules/ol/resolutionconstraint.js","webpack://@openeo/web-editor/./node_modules/ol/rotationconstraint.js","webpack://@openeo/web-editor/./node_modules/ol/size.js"],"sourcesContent":["/**\n * @module ol/reproj\n */\nimport {\n  containsCoordinate,\n  createEmpty,\n  extend,\n  forEachCorner,\n  getCenter,\n  getHeight,\n  getTopLeft,\n  getWidth,\n} from './extent.js';\nimport {createCanvasContext2D, releaseCanvas} from './dom.js';\nimport {getPointResolution, transform} from './proj.js';\nimport {solveLinearSystem} from './math.js';\n\nlet brokenDiagonalRendering_;\n\n/**\n * @type {Array<HTMLCanvasElement>}\n */\nexport const canvasPool = [];\n\n/**\n * This draws a small triangle into a canvas by setting the triangle as the clip region\n * and then drawing a (too large) rectangle\n *\n * @param {CanvasRenderingContext2D} ctx The context in which to draw the triangle\n * @param {number} u1 The x-coordinate of the second point. The first point is 0,0.\n * @param {number} v1 The y-coordinate of the second point.\n * @param {number} u2 The x-coordinate of the third point.\n * @param {number} v2 The y-coordinate of the third point.\n */\nfunction drawTestTriangle(ctx, u1, v1, u2, v2) {\n  ctx.beginPath();\n  ctx.moveTo(0, 0);\n  ctx.lineTo(u1, v1);\n  ctx.lineTo(u2, v2);\n  ctx.closePath();\n  ctx.save();\n  ctx.clip();\n  ctx.fillRect(0, 0, Math.max(u1, u2) + 1, Math.max(v1, v2));\n  ctx.restore();\n}\n\n/**\n * Given the data from getImageData, see if the right values appear at the provided offset.\n * Returns true if either the color or transparency is off\n *\n * @param {Uint8ClampedArray} data The data returned from getImageData\n * @param {number} offset The pixel offset from the start of data.\n * @return {boolean} true if the diagonal rendering is broken\n */\nfunction verifyBrokenDiagonalRendering(data, offset) {\n  // the values ought to be close to the rgba(210, 0, 0, 0.75)\n  return (\n    Math.abs(data[offset * 4] - 210) > 2 ||\n    Math.abs(data[offset * 4 + 3] - 0.75 * 255) > 2\n  );\n}\n\n/**\n * Determines if the current browser configuration can render triangular clip regions correctly.\n * This value is cached so the function is only expensive the first time called.\n * Firefox on Windows (as of now) does not if HWA is enabled. See https://bugzilla.mozilla.org/show_bug.cgi?id=1606976\n * Chrome works, and everything seems to work on OSX and Android. This function caches the\n * result. I suppose that it is conceivably possible that a browser might flip modes while the app is\n * running, but lets hope not.\n *\n * @return {boolean} true if the Diagonal Rendering is broken.\n */\nfunction isBrokenDiagonalRendering() {\n  if (brokenDiagonalRendering_ === undefined) {\n    const ctx = createCanvasContext2D(6, 6, canvasPool);\n    ctx.globalCompositeOperation = 'lighter';\n    ctx.fillStyle = 'rgba(210, 0, 0, 0.75)';\n    drawTestTriangle(ctx, 4, 5, 4, 0);\n    drawTestTriangle(ctx, 4, 5, 0, 5);\n    const data = ctx.getImageData(0, 0, 3, 3).data;\n    brokenDiagonalRendering_ =\n      verifyBrokenDiagonalRendering(data, 0) ||\n      verifyBrokenDiagonalRendering(data, 4) ||\n      verifyBrokenDiagonalRendering(data, 8);\n    releaseCanvas(ctx);\n    canvasPool.push(ctx.canvas);\n  }\n\n  return brokenDiagonalRendering_;\n}\n\n/**\n * Calculates ideal resolution to use from the source in order to achieve\n * pixel mapping as close as possible to 1:1 during reprojection.\n * The resolution is calculated regardless of what resolutions\n * are actually available in the dataset (TileGrid, Image, ...).\n *\n * @param {import(\"./proj/Projection.js\").default} sourceProj Source projection.\n * @param {import(\"./proj/Projection.js\").default} targetProj Target projection.\n * @param {import(\"./coordinate.js\").Coordinate} targetCenter Target center.\n * @param {number} targetResolution Target resolution.\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\n */\nexport function calculateSourceResolution(\n  sourceProj,\n  targetProj,\n  targetCenter,\n  targetResolution\n) {\n  const sourceCenter = transform(targetCenter, targetProj, sourceProj);\n\n  // calculate the ideal resolution of the source data\n  let sourceResolution = getPointResolution(\n    targetProj,\n    targetResolution,\n    targetCenter\n  );\n\n  const targetMetersPerUnit = targetProj.getMetersPerUnit();\n  if (targetMetersPerUnit !== undefined) {\n    sourceResolution *= targetMetersPerUnit;\n  }\n  const sourceMetersPerUnit = sourceProj.getMetersPerUnit();\n  if (sourceMetersPerUnit !== undefined) {\n    sourceResolution /= sourceMetersPerUnit;\n  }\n\n  // Based on the projection properties, the point resolution at the specified\n  // coordinates may be slightly different. We need to reverse-compensate this\n  // in order to achieve optimal results.\n\n  const sourceExtent = sourceProj.getExtent();\n  if (!sourceExtent || containsCoordinate(sourceExtent, sourceCenter)) {\n    const compensationFactor =\n      getPointResolution(sourceProj, sourceResolution, sourceCenter) /\n      sourceResolution;\n    if (isFinite(compensationFactor) && compensationFactor > 0) {\n      sourceResolution /= compensationFactor;\n    }\n  }\n\n  return sourceResolution;\n}\n\n/**\n * Calculates ideal resolution to use from the source in order to achieve\n * pixel mapping as close as possible to 1:1 during reprojection.\n * The resolution is calculated regardless of what resolutions\n * are actually available in the dataset (TileGrid, Image, ...).\n *\n * @param {import(\"./proj/Projection.js\").default} sourceProj Source projection.\n * @param {import(\"./proj/Projection.js\").default} targetProj Target projection.\n * @param {import(\"./extent.js\").Extent} targetExtent Target extent\n * @param {number} targetResolution Target resolution.\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\n */\nexport function calculateSourceExtentResolution(\n  sourceProj,\n  targetProj,\n  targetExtent,\n  targetResolution\n) {\n  const targetCenter = getCenter(targetExtent);\n  let sourceResolution = calculateSourceResolution(\n    sourceProj,\n    targetProj,\n    targetCenter,\n    targetResolution\n  );\n\n  if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n    forEachCorner(targetExtent, function (corner) {\n      sourceResolution = calculateSourceResolution(\n        sourceProj,\n        targetProj,\n        corner,\n        targetResolution\n      );\n      return isFinite(sourceResolution) && sourceResolution > 0;\n    });\n  }\n\n  return sourceResolution;\n}\n\n/**\n * @typedef {Object} ImageExtent\n * @property {import(\"./extent.js\").Extent} extent Extent.\n * @property {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.\n */\n\n/**\n * Renders the source data into new canvas based on the triangulation.\n *\n * @param {number} width Width of the canvas.\n * @param {number} height Height of the canvas.\n * @param {number} pixelRatio Pixel ratio.\n * @param {number} sourceResolution Source resolution.\n * @param {import(\"./extent.js\").Extent} sourceExtent Extent of the data source.\n * @param {number} targetResolution Target resolution.\n * @param {import(\"./extent.js\").Extent} targetExtent Target extent.\n * @param {import(\"./reproj/Triangulation.js\").default} triangulation Calculated triangulation.\n * @param {Array<ImageExtent>} sources Array of sources.\n * @param {number} gutter Gutter of the sources.\n * @param {boolean} [renderEdges] Render reprojection edges.\n * @param {boolean} [interpolate] Use linear interpolation when resampling.\n * @return {HTMLCanvasElement} Canvas with reprojected data.\n */\nexport function render(\n  width,\n  height,\n  pixelRatio,\n  sourceResolution,\n  sourceExtent,\n  targetResolution,\n  targetExtent,\n  triangulation,\n  sources,\n  gutter,\n  renderEdges,\n  interpolate\n) {\n  const context = createCanvasContext2D(\n    Math.round(pixelRatio * width),\n    Math.round(pixelRatio * height),\n    canvasPool\n  );\n\n  if (!interpolate) {\n    context.imageSmoothingEnabled = false;\n  }\n\n  if (sources.length === 0) {\n    return context.canvas;\n  }\n\n  context.scale(pixelRatio, pixelRatio);\n\n  function pixelRound(value) {\n    return Math.round(value * pixelRatio) / pixelRatio;\n  }\n\n  context.globalCompositeOperation = 'lighter';\n\n  const sourceDataExtent = createEmpty();\n  sources.forEach(function (src, i, arr) {\n    extend(sourceDataExtent, src.extent);\n  });\n\n  const canvasWidthInUnits = getWidth(sourceDataExtent);\n  const canvasHeightInUnits = getHeight(sourceDataExtent);\n  const stitchContext = createCanvasContext2D(\n    Math.round((pixelRatio * canvasWidthInUnits) / sourceResolution),\n    Math.round((pixelRatio * canvasHeightInUnits) / sourceResolution),\n    canvasPool\n  );\n\n  if (!interpolate) {\n    stitchContext.imageSmoothingEnabled = false;\n  }\n\n  const stitchScale = pixelRatio / sourceResolution;\n\n  sources.forEach(function (src, i, arr) {\n    const xPos = src.extent[0] - sourceDataExtent[0];\n    const yPos = -(src.extent[3] - sourceDataExtent[3]);\n    const srcWidth = getWidth(src.extent);\n    const srcHeight = getHeight(src.extent);\n\n    // This test should never fail -- but it does. Need to find a fix the upstream condition\n    if (src.image.width > 0 && src.image.height > 0) {\n      stitchContext.drawImage(\n        src.image,\n        gutter,\n        gutter,\n        src.image.width - 2 * gutter,\n        src.image.height - 2 * gutter,\n        xPos * stitchScale,\n        yPos * stitchScale,\n        srcWidth * stitchScale,\n        srcHeight * stitchScale\n      );\n    }\n  });\n\n  const targetTopLeft = getTopLeft(targetExtent);\n\n  triangulation.getTriangles().forEach(function (triangle, i, arr) {\n    /* Calculate affine transform (src -> dst)\n     * Resulting matrix can be used to transform coordinate\n     * from `sourceProjection` to destination pixels.\n     *\n     * To optimize number of context calls and increase numerical stability,\n     * we also do the following operations:\n     * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)\n     * here before solving the linear system so [ui, vi] are pixel coordinates.\n     *\n     * Src points: xi, yi\n     * Dst points: ui, vi\n     * Affine coefficients: aij\n     *\n     * | x0 y0 1  0  0 0 |   |a00|   |u0|\n     * | x1 y1 1  0  0 0 |   |a01|   |u1|\n     * | x2 y2 1  0  0 0 | x |a02| = |u2|\n     * |  0  0 0 x0 y0 1 |   |a10|   |v0|\n     * |  0  0 0 x1 y1 1 |   |a11|   |v1|\n     * |  0  0 0 x2 y2 1 |   |a12|   |v2|\n     */\n    const source = triangle.source;\n    const target = triangle.target;\n    let x0 = source[0][0],\n      y0 = source[0][1];\n    let x1 = source[1][0],\n      y1 = source[1][1];\n    let x2 = source[2][0],\n      y2 = source[2][1];\n    // Make sure that everything is on pixel boundaries\n    const u0 = pixelRound((target[0][0] - targetTopLeft[0]) / targetResolution);\n    const v0 = pixelRound(\n      -(target[0][1] - targetTopLeft[1]) / targetResolution\n    );\n    const u1 = pixelRound((target[1][0] - targetTopLeft[0]) / targetResolution);\n    const v1 = pixelRound(\n      -(target[1][1] - targetTopLeft[1]) / targetResolution\n    );\n    const u2 = pixelRound((target[2][0] - targetTopLeft[0]) / targetResolution);\n    const v2 = pixelRound(\n      -(target[2][1] - targetTopLeft[1]) / targetResolution\n    );\n\n    // Shift all the source points to improve numerical stability\n    // of all the subsequent calculations. The [x0, y0] is used here.\n    // This is also used to simplify the linear system.\n    const sourceNumericalShiftX = x0;\n    const sourceNumericalShiftY = y0;\n    x0 = 0;\n    y0 = 0;\n    x1 -= sourceNumericalShiftX;\n    y1 -= sourceNumericalShiftY;\n    x2 -= sourceNumericalShiftX;\n    y2 -= sourceNumericalShiftY;\n\n    const augmentedMatrix = [\n      [x1, y1, 0, 0, u1 - u0],\n      [x2, y2, 0, 0, u2 - u0],\n      [0, 0, x1, y1, v1 - v0],\n      [0, 0, x2, y2, v2 - v0],\n    ];\n    const affineCoefs = solveLinearSystem(augmentedMatrix);\n    if (!affineCoefs) {\n      return;\n    }\n\n    context.save();\n    context.beginPath();\n\n    if (isBrokenDiagonalRendering() || !interpolate) {\n      // Make sure that all lines are horizontal or vertical\n      context.moveTo(u1, v1);\n      // This is the diagonal line. Do it in 4 steps\n      const steps = 4;\n      const ud = u0 - u1;\n      const vd = v0 - v1;\n      for (let step = 0; step < steps; step++) {\n        // Go horizontally\n        context.lineTo(\n          u1 + pixelRound(((step + 1) * ud) / steps),\n          v1 + pixelRound((step * vd) / (steps - 1))\n        );\n        // Go vertically\n        if (step != steps - 1) {\n          context.lineTo(\n            u1 + pixelRound(((step + 1) * ud) / steps),\n            v1 + pixelRound(((step + 1) * vd) / (steps - 1))\n          );\n        }\n      }\n      // We are almost at u0r, v0r\n      context.lineTo(u2, v2);\n    } else {\n      context.moveTo(u1, v1);\n      context.lineTo(u0, v0);\n      context.lineTo(u2, v2);\n    }\n\n    context.clip();\n\n    context.transform(\n      affineCoefs[0],\n      affineCoefs[2],\n      affineCoefs[1],\n      affineCoefs[3],\n      u0,\n      v0\n    );\n\n    context.translate(\n      sourceDataExtent[0] - sourceNumericalShiftX,\n      sourceDataExtent[3] - sourceNumericalShiftY\n    );\n\n    context.scale(\n      sourceResolution / pixelRatio,\n      -sourceResolution / pixelRatio\n    );\n\n    context.drawImage(stitchContext.canvas, 0, 0);\n    context.restore();\n  });\n\n  releaseCanvas(stitchContext);\n  canvasPool.push(stitchContext.canvas);\n\n  if (renderEdges) {\n    context.save();\n\n    context.globalCompositeOperation = 'source-over';\n    context.strokeStyle = 'black';\n    context.lineWidth = 1;\n\n    triangulation.getTriangles().forEach(function (triangle, i, arr) {\n      const target = triangle.target;\n      const u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;\n      const v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;\n      const u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;\n      const v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;\n      const u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;\n      const v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;\n\n      context.beginPath();\n      context.moveTo(u1, v1);\n      context.lineTo(u0, v0);\n      context.lineTo(u2, v2);\n      context.closePath();\n      context.stroke();\n    });\n\n    context.restore();\n  }\n  return context.canvas;\n}\n","/**\n * @module ol/reproj/Tile\n */\nimport {ERROR_THRESHOLD} from './common.js';\n\nimport EventType from '../events/EventType.js';\nimport Tile from '../Tile.js';\nimport TileState from '../TileState.js';\nimport Triangulation from './Triangulation.js';\nimport {\n  calculateSourceExtentResolution,\n  canvasPool,\n  render as renderReprojected,\n} from '../reproj.js';\nimport {clamp} from '../math.js';\nimport {getArea, getIntersection} from '../extent.js';\nimport {listen, unlistenByKey} from '../events.js';\nimport {releaseCanvas} from '../dom.js';\n\n/**\n * @typedef {function(number, number, number, number) : (import(\"../ImageTile.js\").default)} FunctionType\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected tile.\n * See {@link module:ol/source/TileImage~TileImage}.\n *\n */\nclass ReprojTile extends Tile {\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n   * @param {import(\"../tilecoord.js\").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {number} gutter Gutter of the source tiles.\n   * @param {FunctionType} getTileFunction\n   *     Function returning source tiles (z, x, y, pixelRatio).\n   * @param {number} [errorThreshold] Acceptable reprojection error (in px).\n   * @param {boolean} [renderEdges] Render reprojection edges.\n   * @param {boolean} [interpolate] Use linear interpolation when resampling.\n   */\n  constructor(\n    sourceProj,\n    sourceTileGrid,\n    targetProj,\n    targetTileGrid,\n    tileCoord,\n    wrappedTileCoord,\n    pixelRatio,\n    gutter,\n    getTileFunction,\n    errorThreshold,\n    renderEdges,\n    interpolate\n  ) {\n    super(tileCoord, TileState.IDLE, {interpolate: !!interpolate});\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.renderEdges_ = renderEdges !== undefined ? renderEdges : false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = pixelRatio;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = gutter;\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.sourceTileGrid_ = sourceTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.targetTileGrid_ = targetTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilecoord.js\").TileCoord}\n     */\n    this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\n\n    /**\n     * @private\n     * @type {!Array<import(\"../ImageTile.js\").default>}\n     */\n    this.sourceTiles_ = [];\n\n    /**\n     * @private\n     * @type {?Array<import(\"../events.js\").EventsKey>}\n     */\n    this.sourcesListenerKeys_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.sourceZ_ = 0;\n\n    const targetExtent = targetTileGrid.getTileCoordExtent(\n      this.wrappedTileCoord_\n    );\n    const maxTargetExtent = this.targetTileGrid_.getExtent();\n    let maxSourceExtent = this.sourceTileGrid_.getExtent();\n\n    const limitedTargetExtent = maxTargetExtent\n      ? getIntersection(targetExtent, maxTargetExtent)\n      : targetExtent;\n\n    if (getArea(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const sourceProjExtent = sourceProj.getExtent();\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n      }\n    }\n\n    const targetResolution = targetTileGrid.getResolution(\n      this.wrappedTileCoord_[0]\n    );\n\n    const sourceResolution = calculateSourceExtentResolution(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      targetResolution\n    );\n\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const errorThresholdInPixels =\n      errorThreshold !== undefined ? errorThreshold : ERROR_THRESHOLD;\n\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n    this.triangulation_ = new Triangulation(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      maxSourceExtent,\n      sourceResolution * errorThresholdInPixels,\n      targetResolution\n    );\n\n    if (this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\n    let sourceExtent = this.triangulation_.calculateSourceExtent();\n\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = clamp(\n          sourceExtent[1],\n          maxSourceExtent[1],\n          maxSourceExtent[3]\n        );\n        sourceExtent[3] = clamp(\n          sourceExtent[3],\n          maxSourceExtent[1],\n          maxSourceExtent[3]\n        );\n      } else {\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n\n    if (!getArea(sourceExtent)) {\n      this.state = TileState.EMPTY;\n    } else {\n      const sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(\n        sourceExtent,\n        this.sourceZ_\n      );\n\n      for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n        for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n          const tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);\n          if (tile) {\n            this.sourceTiles_.push(tile);\n          }\n        }\n      }\n\n      if (this.sourceTiles_.length === 0) {\n        this.state = TileState.EMPTY;\n      }\n    }\n  }\n\n  /**\n   * Get the HTML Canvas element for this tile.\n   * @return {HTMLCanvasElement} Canvas.\n   */\n  getImage() {\n    return this.canvas_;\n  }\n\n  /**\n   * @private\n   */\n  reproject_() {\n    const sources = [];\n    this.sourceTiles_.forEach((tile) => {\n      if (tile && tile.getState() == TileState.LOADED) {\n        sources.push({\n          extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),\n          image: tile.getImage(),\n        });\n      }\n    });\n    this.sourceTiles_.length = 0;\n\n    if (sources.length === 0) {\n      this.state = TileState.ERROR;\n    } else {\n      const z = this.wrappedTileCoord_[0];\n      const size = this.targetTileGrid_.getTileSize(z);\n      const width = typeof size === 'number' ? size : size[0];\n      const height = typeof size === 'number' ? size : size[1];\n      const targetResolution = this.targetTileGrid_.getResolution(z);\n      const sourceResolution = this.sourceTileGrid_.getResolution(\n        this.sourceZ_\n      );\n\n      const targetExtent = this.targetTileGrid_.getTileCoordExtent(\n        this.wrappedTileCoord_\n      );\n\n      this.canvas_ = renderReprojected(\n        width,\n        height,\n        this.pixelRatio_,\n        sourceResolution,\n        this.sourceTileGrid_.getExtent(),\n        targetResolution,\n        targetExtent,\n        this.triangulation_,\n        sources,\n        this.gutter_,\n        this.renderEdges_,\n        this.interpolate\n      );\n\n      this.state = TileState.LOADED;\n    }\n    this.changed();\n  }\n\n  /**\n   * Load not yet loaded URI.\n   */\n  load() {\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n\n      let leftToLoad = 0;\n\n      this.sourcesListenerKeys_ = [];\n      this.sourceTiles_.forEach((tile) => {\n        const state = tile.getState();\n        if (state == TileState.IDLE || state == TileState.LOADING) {\n          leftToLoad++;\n\n          const sourceListenKey = listen(\n            tile,\n            EventType.CHANGE,\n            function (e) {\n              const state = tile.getState();\n              if (\n                state == TileState.LOADED ||\n                state == TileState.ERROR ||\n                state == TileState.EMPTY\n              ) {\n                unlistenByKey(sourceListenKey);\n                leftToLoad--;\n                if (leftToLoad === 0) {\n                  this.unlistenSources_();\n                  this.reproject_();\n                }\n              }\n            },\n            this\n          );\n          this.sourcesListenerKeys_.push(sourceListenKey);\n        }\n      });\n\n      if (leftToLoad === 0) {\n        setTimeout(this.reproject_.bind(this), 0);\n      } else {\n        this.sourceTiles_.forEach(function (tile, i, arr) {\n          const state = tile.getState();\n          if (state == TileState.IDLE) {\n            tile.load();\n          }\n        });\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  unlistenSources_() {\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\n    this.sourcesListenerKeys_ = null;\n  }\n\n  /**\n   * Remove from the cache due to expiry\n   */\n  release() {\n    if (this.canvas_) {\n      releaseCanvas(this.canvas_.getContext('2d'));\n      canvasPool.push(this.canvas_);\n      this.canvas_ = null;\n    }\n    super.release();\n  }\n}\n\nexport default ReprojTile;\n","/**\n * @module ol/reproj/Triangulation\n */\nimport {\n  boundingExtent,\n  createEmpty,\n  extendCoordinate,\n  getArea,\n  getBottomLeft,\n  getBottomRight,\n  getTopLeft,\n  getTopRight,\n  getWidth,\n  intersects,\n} from '../extent.js';\nimport {getTransform} from '../proj.js';\nimport {modulo} from '../math.js';\n\n/**\n * Single triangle; consists of 3 source points and 3 target points.\n * @typedef {Object} Triangle\n * @property {Array<import(\"../coordinate.js\").Coordinate>} source Source.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} target Target.\n */\n\n/**\n * Maximum number of subdivision steps during raster reprojection triangulation.\n * Prevents high memory usage and large number of proj4 calls (for certain\n * transformations and areas). At most `2*(2^this)` triangles are created for\n * each triangulated extent (tile/image).\n * @type {number}\n */\nconst MAX_SUBDIVISION = 10;\n\n/**\n * Maximum allowed size of triangle relative to world width. When transforming\n * corners of world extent between certain projections, the resulting\n * triangulation seems to have zero error and no subdivision is performed. If\n * the triangle width is more than this (relative to world width; 0-1),\n * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.\n * @type {number}\n */\nconst MAX_TRIANGLE_WIDTH = 0.25;\n\n/**\n * @classdesc\n * Class containing triangulation of the given target extent.\n * Used for determining source data and the reprojection itself.\n */\nclass Triangulation {\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../extent.js\").Extent} targetExtent Target extent to triangulate.\n   * @param {import(\"../extent.js\").Extent} maxSourceExtent Maximal source extent that can be used.\n   * @param {number} errorThreshold Acceptable error (in source units).\n   * @param {?number} destinationResolution The (optional) resolution of the destination.\n   */\n  constructor(\n    sourceProj,\n    targetProj,\n    targetExtent,\n    maxSourceExtent,\n    errorThreshold,\n    destinationResolution\n  ) {\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     * @private\n     */\n    this.sourceProj_ = sourceProj;\n\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     * @private\n     */\n    this.targetProj_ = targetProj;\n\n    /** @type {!Object<string, import(\"../coordinate.js\").Coordinate>} */\n    let transformInvCache = {};\n    const transformInv = getTransform(this.targetProj_, this.sourceProj_);\n\n    /**\n     * @param {import(\"../coordinate.js\").Coordinate} c A coordinate.\n     * @return {import(\"../coordinate.js\").Coordinate} Transformed coordinate.\n     * @private\n     */\n    this.transformInv_ = function (c) {\n      const key = c[0] + '/' + c[1];\n      if (!transformInvCache[key]) {\n        transformInvCache[key] = transformInv(c);\n      }\n      return transformInvCache[key];\n    };\n\n    /**\n     * @type {import(\"../extent.js\").Extent}\n     * @private\n     */\n    this.maxSourceExtent_ = maxSourceExtent;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.errorThresholdSquared_ = errorThreshold * errorThreshold;\n\n    /**\n     * @type {Array<Triangle>}\n     * @private\n     */\n    this.triangles_ = [];\n\n    /**\n     * Indicates that the triangulation crosses edge of the source projection.\n     * @type {boolean}\n     * @private\n     */\n    this.wrapsXInSource_ = false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.canWrapXInSource_ =\n      this.sourceProj_.canWrapX() &&\n      !!maxSourceExtent &&\n      !!this.sourceProj_.getExtent() &&\n      getWidth(maxSourceExtent) == getWidth(this.sourceProj_.getExtent());\n\n    /**\n     * @type {?number}\n     * @private\n     */\n    this.sourceWorldWidth_ = this.sourceProj_.getExtent()\n      ? getWidth(this.sourceProj_.getExtent())\n      : null;\n\n    /**\n     * @type {?number}\n     * @private\n     */\n    this.targetWorldWidth_ = this.targetProj_.getExtent()\n      ? getWidth(this.targetProj_.getExtent())\n      : null;\n\n    const destinationTopLeft = getTopLeft(targetExtent);\n    const destinationTopRight = getTopRight(targetExtent);\n    const destinationBottomRight = getBottomRight(targetExtent);\n    const destinationBottomLeft = getBottomLeft(targetExtent);\n    const sourceTopLeft = this.transformInv_(destinationTopLeft);\n    const sourceTopRight = this.transformInv_(destinationTopRight);\n    const sourceBottomRight = this.transformInv_(destinationBottomRight);\n    const sourceBottomLeft = this.transformInv_(destinationBottomLeft);\n\n    /*\n     * The maxSubdivision controls how many splittings of the target area can\n     * be done. The idea here is to do a linear mapping of the target areas\n     * but the actual overal reprojection (can be) extremely non-linear. The\n     * default value of MAX_SUBDIVISION was chosen based on mapping a 256x256\n     * tile size. However this function is also called to remap canvas rendered\n     * layers which can be much larger. This calculation increases the maxSubdivision\n     * value by the right factor so that each 256x256 pixel area has\n     * MAX_SUBDIVISION divisions.\n     */\n    const maxSubdivision =\n      MAX_SUBDIVISION +\n      (destinationResolution\n        ? Math.max(\n            0,\n            Math.ceil(\n              Math.log2(\n                getArea(targetExtent) /\n                  (destinationResolution * destinationResolution * 256 * 256)\n              )\n            )\n          )\n        : 0);\n\n    this.addQuad_(\n      destinationTopLeft,\n      destinationTopRight,\n      destinationBottomRight,\n      destinationBottomLeft,\n      sourceTopLeft,\n      sourceTopRight,\n      sourceBottomRight,\n      sourceBottomLeft,\n      maxSubdivision\n    );\n\n    if (this.wrapsXInSource_) {\n      let leftBound = Infinity;\n      this.triangles_.forEach(function (triangle, i, arr) {\n        leftBound = Math.min(\n          leftBound,\n          triangle.source[0][0],\n          triangle.source[1][0],\n          triangle.source[2][0]\n        );\n      });\n\n      // Shift triangles to be as close to `leftBound` as possible\n      // (if the distance is more than `worldWidth / 2` it can be closer.\n      this.triangles_.forEach((triangle) => {\n        if (\n          Math.max(\n            triangle.source[0][0],\n            triangle.source[1][0],\n            triangle.source[2][0]\n          ) -\n            leftBound >\n          this.sourceWorldWidth_ / 2\n        ) {\n          const newTriangle = [\n            [triangle.source[0][0], triangle.source[0][1]],\n            [triangle.source[1][0], triangle.source[1][1]],\n            [triangle.source[2][0], triangle.source[2][1]],\n          ];\n          if (newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2) {\n            newTriangle[0][0] -= this.sourceWorldWidth_;\n          }\n          if (newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2) {\n            newTriangle[1][0] -= this.sourceWorldWidth_;\n          }\n          if (newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2) {\n            newTriangle[2][0] -= this.sourceWorldWidth_;\n          }\n\n          // Rarely (if the extent contains both the dateline and prime meridian)\n          // the shift can in turn break some triangles.\n          // Detect this here and don't shift in such cases.\n          const minX = Math.min(\n            newTriangle[0][0],\n            newTriangle[1][0],\n            newTriangle[2][0]\n          );\n          const maxX = Math.max(\n            newTriangle[0][0],\n            newTriangle[1][0],\n            newTriangle[2][0]\n          );\n          if (maxX - minX < this.sourceWorldWidth_ / 2) {\n            triangle.source = newTriangle;\n          }\n        }\n      });\n    }\n\n    transformInvCache = {};\n  }\n\n  /**\n   * Adds triangle to the triangulation.\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n   * @private\n   */\n  addTriangle_(a, b, c, aSrc, bSrc, cSrc) {\n    this.triangles_.push({\n      source: [aSrc, bSrc, cSrc],\n      target: [a, b, c],\n    });\n  }\n\n  /**\n   * Adds quad (points in clock-wise order) to the triangulation\n   * (and reprojects the vertices) if valid.\n   * Performs quad subdivision if needed to increase precision.\n   *\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} d The target d coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} dSrc The source d coordinate.\n   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.\n   * @private\n   */\n  addQuad_(a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {\n    const sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);\n    const sourceCoverageX = this.sourceWorldWidth_\n      ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_\n      : null;\n    const sourceWorldWidth = /** @type {number} */ (this.sourceWorldWidth_);\n\n    // when the quad is wrapped in the source projection\n    // it covers most of the projection extent, but not fully\n    const wrapsX =\n      this.sourceProj_.canWrapX() &&\n      sourceCoverageX > 0.5 &&\n      sourceCoverageX < 1;\n\n    let needsSubdivision = false;\n\n    if (maxSubdivision > 0) {\n      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {\n        const targetQuadExtent = boundingExtent([a, b, c, d]);\n        const targetCoverageX =\n          getWidth(targetQuadExtent) / this.targetWorldWidth_;\n        needsSubdivision =\n          targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n      }\n      if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {\n        needsSubdivision =\n          sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n      }\n    }\n\n    if (!needsSubdivision && this.maxSourceExtent_) {\n      if (\n        isFinite(sourceQuadExtent[0]) &&\n        isFinite(sourceQuadExtent[1]) &&\n        isFinite(sourceQuadExtent[2]) &&\n        isFinite(sourceQuadExtent[3])\n      ) {\n        if (!intersects(sourceQuadExtent, this.maxSourceExtent_)) {\n          // whole quad outside source projection extent -> ignore\n          return;\n        }\n      }\n    }\n\n    let isNotFinite = 0;\n\n    if (!needsSubdivision) {\n      if (\n        !isFinite(aSrc[0]) ||\n        !isFinite(aSrc[1]) ||\n        !isFinite(bSrc[0]) ||\n        !isFinite(bSrc[1]) ||\n        !isFinite(cSrc[0]) ||\n        !isFinite(cSrc[1]) ||\n        !isFinite(dSrc[0]) ||\n        !isFinite(dSrc[1])\n      ) {\n        if (maxSubdivision > 0) {\n          needsSubdivision = true;\n        } else {\n          // It might be the case that only 1 of the points is infinite. In this case\n          // we can draw a single triangle with the other three points\n          isNotFinite =\n            (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) +\n            (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) +\n            (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) +\n            (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);\n          if (\n            isNotFinite != 1 &&\n            isNotFinite != 2 &&\n            isNotFinite != 4 &&\n            isNotFinite != 8\n          ) {\n            return;\n          }\n        }\n      }\n    }\n\n    if (maxSubdivision > 0) {\n      if (!needsSubdivision) {\n        const center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];\n        const centerSrc = this.transformInv_(center);\n\n        let dx;\n        if (wrapsX) {\n          const centerSrcEstimX =\n            (modulo(aSrc[0], sourceWorldWidth) +\n              modulo(cSrc[0], sourceWorldWidth)) /\n            2;\n          dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);\n        } else {\n          dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];\n        }\n        const dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];\n        const centerSrcErrorSquared = dx * dx + dy * dy;\n        needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;\n      }\n      if (needsSubdivision) {\n        if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {\n          // split horizontally (top & bottom)\n          const bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];\n          const bcSrc = this.transformInv_(bc);\n          const da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];\n          const daSrc = this.transformInv_(da);\n\n          this.addQuad_(\n            a,\n            b,\n            bc,\n            da,\n            aSrc,\n            bSrc,\n            bcSrc,\n            daSrc,\n            maxSubdivision - 1\n          );\n          this.addQuad_(\n            da,\n            bc,\n            c,\n            d,\n            daSrc,\n            bcSrc,\n            cSrc,\n            dSrc,\n            maxSubdivision - 1\n          );\n        } else {\n          // split vertically (left & right)\n          const ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\n          const abSrc = this.transformInv_(ab);\n          const cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];\n          const cdSrc = this.transformInv_(cd);\n\n          this.addQuad_(\n            a,\n            ab,\n            cd,\n            d,\n            aSrc,\n            abSrc,\n            cdSrc,\n            dSrc,\n            maxSubdivision - 1\n          );\n          this.addQuad_(\n            ab,\n            b,\n            c,\n            cd,\n            abSrc,\n            bSrc,\n            cSrc,\n            cdSrc,\n            maxSubdivision - 1\n          );\n        }\n        return;\n      }\n    }\n\n    if (wrapsX) {\n      if (!this.canWrapXInSource_) {\n        return;\n      }\n      this.wrapsXInSource_ = true;\n    }\n\n    // Exactly zero or one of *Src is not finite\n    // The triangles must have the diagonal line as the first side\n    // This is to allow easy code in reproj.s to make it straight for broken\n    // browsers that can't handle diagonal clipping\n    if ((isNotFinite & 0xb) == 0) {\n      this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);\n    }\n    if ((isNotFinite & 0xe) == 0) {\n      this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);\n    }\n    if (isNotFinite) {\n      // Try the other two triangles\n      if ((isNotFinite & 0xd) == 0) {\n        this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);\n      }\n      if ((isNotFinite & 0x7) == 0) {\n        this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);\n      }\n    }\n  }\n\n  /**\n   * Calculates extent of the `source` coordinates from all the triangles.\n   *\n   * @return {import(\"../extent.js\").Extent} Calculated extent.\n   */\n  calculateSourceExtent() {\n    const extent = createEmpty();\n\n    this.triangles_.forEach(function (triangle, i, arr) {\n      const src = triangle.source;\n      extendCoordinate(extent, src[0]);\n      extendCoordinate(extent, src[1]);\n      extendCoordinate(extent, src[2]);\n    });\n\n    return extent;\n  }\n\n  /**\n   * @return {Array<Triangle>} Array of the calculated triangles.\n   */\n  getTriangles() {\n    return this.triangles_;\n  }\n}\n\nexport default Triangulation;\n","/**\n * @module ol/reproj/common\n */\n\n/**\n * Default maximum allowed threshold  (in pixels) for reprojection\n * triangulation.\n * @type {number}\n */\nexport const ERROR_THRESHOLD = 0.5;\n","/**\n * @module ol/resolutionconstraint\n */\nimport {clamp} from './math.js';\nimport {getHeight, getWidth} from './extent.js';\nimport {linearFindNearest} from './array.js';\n\n/**\n * @typedef {function((number|undefined), number, import(\"./size.js\").Size, boolean=): (number|undefined)} Type\n */\n\n/**\n * Returns a modified resolution taking into account the viewport size and maximum\n * allowed extent.\n * @param {number} resolution Resolution\n * @param {import(\"./extent.js\").Extent} maxExtent Maximum allowed extent.\n * @param {import(\"./size.js\").Size} viewportSize Viewport size.\n * @param {boolean} showFullExtent Whether to show the full extent.\n * @return {number} Capped resolution.\n */\nfunction getViewportClampedResolution(\n  resolution,\n  maxExtent,\n  viewportSize,\n  showFullExtent\n) {\n  const xResolution = getWidth(maxExtent) / viewportSize[0];\n  const yResolution = getHeight(maxExtent) / viewportSize[1];\n\n  if (showFullExtent) {\n    return Math.min(resolution, Math.max(xResolution, yResolution));\n  }\n  return Math.min(resolution, Math.min(xResolution, yResolution));\n}\n\n/**\n * Returns a modified resolution to be between maxResolution and minResolution while\n * still allowing the value to be slightly out of bounds.\n * Note: the computation is based on the logarithm function (ln):\n *  - at 1, ln(x) is 0\n *  - above 1, ln(x) keeps increasing but at a much slower pace than x\n * The final result is clamped to prevent getting too far away from bounds.\n * @param {number} resolution Resolution.\n * @param {number} maxResolution Max resolution.\n * @param {number} minResolution Min resolution.\n * @return {number} Smoothed resolution.\n */\nfunction getSmoothClampedResolution(resolution, maxResolution, minResolution) {\n  let result = Math.min(resolution, maxResolution);\n  const ratio = 50;\n\n  result *=\n    Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio +\n    1;\n  if (minResolution) {\n    result = Math.max(result, minResolution);\n    result /=\n      Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) /\n        ratio +\n      1;\n  }\n  return clamp(result, minResolution / 2, maxResolution * 2);\n}\n\n/**\n * @param {Array<number>} resolutions Resolutions.\n * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\n * @param {import(\"./extent.js\").Extent} [maxExtent] Maximum allowed extent.\n * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.\n * @return {Type} Zoom function.\n */\nexport function createSnapToResolutions(\n  resolutions,\n  smooth,\n  maxExtent,\n  showFullExtent\n) {\n  smooth = smooth !== undefined ? smooth : true;\n  return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} direction Direction.\n     * @param {import(\"./size.js\").Size} size Viewport size.\n     * @param {boolean} [isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, direction, size, isMoving) {\n      if (resolution !== undefined) {\n        const maxResolution = resolutions[0];\n        const minResolution = resolutions[resolutions.length - 1];\n        const cappedMaxRes = maxExtent\n          ? getViewportClampedResolution(\n              maxResolution,\n              maxExtent,\n              size,\n              showFullExtent\n            )\n          : maxResolution;\n\n        // during interacting or animating, allow intermediary values\n        if (isMoving) {\n          if (!smooth) {\n            return clamp(resolution, minResolution, cappedMaxRes);\n          }\n          return getSmoothClampedResolution(\n            resolution,\n            cappedMaxRes,\n            minResolution\n          );\n        }\n\n        const capped = Math.min(cappedMaxRes, resolution);\n        const z = Math.floor(linearFindNearest(resolutions, capped, direction));\n        if (resolutions[z] > cappedMaxRes && z < resolutions.length - 1) {\n          return resolutions[z + 1];\n        }\n        return resolutions[z];\n      }\n      return undefined;\n    }\n  );\n}\n\n/**\n * @param {number} power Power.\n * @param {number} maxResolution Maximum resolution.\n * @param {number} [minResolution] Minimum resolution.\n * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\n * @param {import(\"./extent.js\").Extent} [maxExtent] Maximum allowed extent.\n * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.\n * @return {Type} Zoom function.\n */\nexport function createSnapToPower(\n  power,\n  maxResolution,\n  minResolution,\n  smooth,\n  maxExtent,\n  showFullExtent\n) {\n  smooth = smooth !== undefined ? smooth : true;\n  minResolution = minResolution !== undefined ? minResolution : 0;\n\n  return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} direction Direction.\n     * @param {import(\"./size.js\").Size} size Viewport size.\n     * @param {boolean} [isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, direction, size, isMoving) {\n      if (resolution !== undefined) {\n        const cappedMaxRes = maxExtent\n          ? getViewportClampedResolution(\n              maxResolution,\n              maxExtent,\n              size,\n              showFullExtent\n            )\n          : maxResolution;\n\n        // during interacting or animating, allow intermediary values\n        if (isMoving) {\n          if (!smooth) {\n            return clamp(resolution, minResolution, cappedMaxRes);\n          }\n          return getSmoothClampedResolution(\n            resolution,\n            cappedMaxRes,\n            minResolution\n          );\n        }\n\n        const tolerance = 1e-9;\n        const minZoomLevel = Math.ceil(\n          Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance\n        );\n        const offset = -direction * (0.5 - tolerance) + 0.5;\n        const capped = Math.min(cappedMaxRes, resolution);\n        const cappedZoomLevel = Math.floor(\n          Math.log(maxResolution / capped) / Math.log(power) + offset\n        );\n        const zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);\n        const newResolution = maxResolution / Math.pow(power, zoomLevel);\n        return clamp(newResolution, minResolution, cappedMaxRes);\n      }\n      return undefined;\n    }\n  );\n}\n\n/**\n * @param {number} maxResolution Max resolution.\n * @param {number} minResolution Min resolution.\n * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\n * @param {import(\"./extent.js\").Extent} [maxExtent] Maximum allowed extent.\n * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.\n * @return {Type} Zoom function.\n */\nexport function createMinMaxResolution(\n  maxResolution,\n  minResolution,\n  smooth,\n  maxExtent,\n  showFullExtent\n) {\n  smooth = smooth !== undefined ? smooth : true;\n\n  return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} direction Direction.\n     * @param {import(\"./size.js\").Size} size Viewport size.\n     * @param {boolean} [isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, direction, size, isMoving) {\n      if (resolution !== undefined) {\n        const cappedMaxRes = maxExtent\n          ? getViewportClampedResolution(\n              maxResolution,\n              maxExtent,\n              size,\n              showFullExtent\n            )\n          : maxResolution;\n\n        if (!smooth || !isMoving) {\n          return clamp(resolution, minResolution, cappedMaxRes);\n        }\n        return getSmoothClampedResolution(\n          resolution,\n          cappedMaxRes,\n          minResolution\n        );\n      }\n      return undefined;\n    }\n  );\n}\n","/**\n * @module ol/rotationconstraint\n */\nimport {toRadians} from './math.js';\n\n/**\n * @typedef {function((number|undefined), boolean=): (number|undefined)} Type\n */\n\n/**\n * @param {number|undefined} rotation Rotation.\n * @return {number|undefined} Rotation.\n */\nexport function disable(rotation) {\n  if (rotation !== undefined) {\n    return 0;\n  }\n  return undefined;\n}\n\n/**\n * @param {number|undefined} rotation Rotation.\n * @return {number|undefined} Rotation.\n */\nexport function none(rotation) {\n  if (rotation !== undefined) {\n    return rotation;\n  }\n  return undefined;\n}\n\n/**\n * @param {number} n N.\n * @return {Type} Rotation constraint.\n */\nexport function createSnapToN(n) {\n  const theta = (2 * Math.PI) / n;\n  return (\n    /**\n     * @param {number|undefined} rotation Rotation.\n     * @param {boolean} [isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Rotation.\n     */\n    function (rotation, isMoving) {\n      if (isMoving) {\n        return rotation;\n      }\n\n      if (rotation !== undefined) {\n        rotation = Math.floor(rotation / theta + 0.5) * theta;\n        return rotation;\n      }\n      return undefined;\n    }\n  );\n}\n\n/**\n * @param {number} [tolerance] Tolerance.\n * @return {Type} Rotation constraint.\n */\nexport function createSnapToZero(tolerance) {\n  tolerance = tolerance || toRadians(5);\n  return (\n    /**\n     * @param {number|undefined} rotation Rotation.\n     * @param {boolean} [isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Rotation.\n     */\n    function (rotation, isMoving) {\n      if (isMoving) {\n        return rotation;\n      }\n\n      if (rotation !== undefined) {\n        if (Math.abs(rotation) <= tolerance) {\n          return 0;\n        }\n        return rotation;\n      }\n      return undefined;\n    }\n  );\n}\n","/**\n * @module ol/size\n */\n\n/**\n * An array of numbers representing a size: `[width, height]`.\n * @typedef {Array<number>} Size\n * @api\n */\n\n/**\n * Returns a buffered size.\n * @param {Size} size Size.\n * @param {number} num The amount by which to buffer.\n * @param {Size} [dest] Optional reusable size array.\n * @return {Size} The buffered size.\n */\nexport function buffer(size, num, dest) {\n  if (dest === undefined) {\n    dest = [0, 0];\n  }\n  dest[0] = size[0] + 2 * num;\n  dest[1] = size[1] + 2 * num;\n  return dest;\n}\n\n/**\n * Determines if a size has a positive area.\n * @param {Size} size The size to test.\n * @return {boolean} The size has a positive area.\n */\nexport function hasArea(size) {\n  return size[0] > 0 && size[1] > 0;\n}\n\n/**\n * Returns a size scaled by a ratio. The result will be an array of integers.\n * @param {Size} size Size.\n * @param {number} ratio Ratio.\n * @param {Size} [dest] Optional reusable size array.\n * @return {Size} The scaled size.\n */\nexport function scale(size, ratio, dest) {\n  if (dest === undefined) {\n    dest = [0, 0];\n  }\n  dest[0] = (size[0] * ratio + 0.5) | 0;\n  dest[1] = (size[1] * ratio + 0.5) | 0;\n  return dest;\n}\n\n/**\n * Returns an `Size` array for the passed in number (meaning: square) or\n * `Size` array.\n * (meaning: non-square),\n * @param {number|Size} size Width and height.\n * @param {Size} [dest] Optional reusable size array.\n * @return {Size} Size.\n * @api\n */\nexport function toSize(size, dest) {\n  if (Array.isArray(size)) {\n    return size;\n  }\n  if (dest === undefined) {\n    dest = [size, size];\n  } else {\n    dest[0] = size;\n    dest[1] = size;\n  }\n  return dest;\n}\n"],"names":["brokenDiagonalRendering_","canvasPool","drawTestTriangle","ctx","u1","v1","u2","v2","beginPath","moveTo","lineTo","closePath","save","clip","fillRect","Math","max","restore","verifyBrokenDiagonalRendering","data","offset","abs","isBrokenDiagonalRendering","undefined","globalCompositeOperation","fillStyle","getImageData","push","canvas","calculateSourceResolution","sourceProj","targetProj","targetCenter","targetResolution","sourceCenter","transform","sourceResolution","getPointResolution","targetMetersPerUnit","getMetersPerUnit","sourceMetersPerUnit","sourceExtent","getExtent","compensationFactor","isFinite","calculateSourceExtentResolution","targetExtent","corner","render","width","height","pixelRatio","triangulation","sources","gutter","renderEdges","interpolate","context","round","imageSmoothingEnabled","length","pixelRound","value","scale","sourceDataExtent","forEach","src","i","arr","extent","canvasWidthInUnits","canvasHeightInUnits","stitchContext","stitchScale","xPos","yPos","srcWidth","srcHeight","image","drawImage","targetTopLeft","getTriangles","triangle","source","target","x0","y0","x1","y1","x2","y2","u0","v0","sourceNumericalShiftX","sourceNumericalShiftY","augmentedMatrix","affineCoefs","steps","ud","vd","step","translate","strokeStyle","lineWidth","stroke","ReprojTile","constructor","sourceTileGrid","targetTileGrid","tileCoord","wrappedTileCoord","getTileFunction","errorThreshold","super","this","renderEdges_","pixelRatio_","gutter_","canvas_","sourceTileGrid_","targetTileGrid_","wrappedTileCoord_","sourceTiles_","sourcesListenerKeys_","sourceZ_","getTileCoordExtent","maxTargetExtent","maxSourceExtent","limitedTargetExtent","state","sourceProjExtent","getResolution","errorThresholdInPixels","triangulation_","getZForResolution","calculateSourceExtent","canWrapX","sourceRange","getTileRangeForExtentAndZ","srcX","minX","maxX","srcY","minY","maxY","tile","getImage","reproject_","getState","z","size","getTileSize","changed","load","leftToLoad","sourceListenKey","e","unlistenSources_","setTimeout","bind","release","getContext","MAX_SUBDIVISION","MAX_TRIANGLE_WIDTH","Triangulation","destinationResolution","sourceProj_","targetProj_","transformInvCache","transformInv","getTransform","transformInv_","c","key","maxSourceExtent_","errorThresholdSquared_","triangles_","wrapsXInSource_","canWrapXInSource_","sourceWorldWidth_","targetWorldWidth_","destinationTopLeft","destinationTopRight","destinationBottomRight","destinationBottomLeft","sourceTopLeft","sourceTopRight","sourceBottomRight","sourceBottomLeft","maxSubdivision","ceil","log2","addQuad_","leftBound","Infinity","min","newTriangle","addTriangle_","a","b","aSrc","bSrc","cSrc","d","dSrc","sourceQuadExtent","sourceCoverageX","sourceWorldWidth","wrapsX","needsSubdivision","isGlobal","targetQuadExtent","targetCoverageX","isNotFinite","center","centerSrc","dx","centerSrcEstimX","dy","centerSrcErrorSquared","bc","bcSrc","da","daSrc","ab","abSrc","cd","cdSrc","ERROR_THRESHOLD","getViewportClampedResolution","resolution","maxExtent","viewportSize","showFullExtent","xResolution","yResolution","getSmoothClampedResolution","maxResolution","minResolution","result","ratio","log","createSnapToResolutions","resolutions","smooth","direction","isMoving","cappedMaxRes","capped","floor","createSnapToPower","power","tolerance","minZoomLevel","cappedZoomLevel","zoomLevel","newResolution","pow","createMinMaxResolution","disable","rotation","none","createSnapToN","n","theta","PI","createSnapToZero","hasArea","dest","toSize","Array","isArray"],"sourceRoot":""}
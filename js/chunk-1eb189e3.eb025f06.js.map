{"version":3,"sources":["webpack:///./node_modules/ol/tilegrid/common.js","webpack:///./node_modules/ol/tilegrid.js","webpack:///./node_modules/ol/util.js","webpack:///./node_modules/ol/tilecoord.js","webpack:///./node_modules/ol/tilegrid/TileGrid.js","webpack:///./node_modules/ol/tileurlfunction.js","webpack:///./node_modules/ol/transform.js"],"names":["DEFAULT_MAX_ZOOM","DEFAULT_TILE_SIZE","getForProjection","projection","tileGrid","getDefaultTileGrid","createForProjection","setDefaultTileGrid","wrapX","tileCoord","z","center","getTileCoordCenter","projectionExtent","extentFromProjection","worldWidth","worldsAway","Math","ceil","getTileCoordForCoordAndZ","createForExtent","extent","opt_maxZoom","opt_tileSize","opt_corner","corner","undefined","TOP_LEFT","resolutions","resolutionsFromExtent","origin","tileSize","createXYZ","opt_options","xyzOptions","getExtent","gridOptions","minZoom","maxZoom","maxResolution","opt_maxResolution","height","width","max","length","Array","pow","half","DEGREES","getMetersPerUnit","abstract","Error","uidCounter_","getUid","obj","ol_uid","String","VERSION","createOrUpdate","x","y","opt_tileCoord","getKeyZXY","getKey","fromKey","key","split","map","Number","hash","withinExtentAndZ","getMinZoom","getMaxZoom","tileRange","getFullTileRange","containsXY","tmpTileCoord","DECIMALS","TileGrid","options","zoomFactor","this","resolutions_","a","b","origins","i","ii","zoomFactor_","origin_","origins_","tileSizes_","tileSizes","tileSize_","extent_","fullTileRanges_","tmpSize_","tmpExtent_","sizes","size","min","restrictedTileRange","getTileRangeForExtentAndZ","minX","maxX","minY","maxY","calculateTileRanges_","prototype","forEachTileCoord","zoom","callback","j","jj","forEachTileCoordParentTileRange","opt_tileRange","opt_extent","tileCoordExtent","getTileCoordExtent","floor","getOrigin","getResolution","getResolutions","getTileCoordChildTileRange","getTileRangeForTileCoordAndZ","tileCoordZ","tileCoordX","tileCoordY","factor","getTileRangeExtent","resolution","getTileSize","getTileCoordForXYAndZ_","getTileCoordForCoordAndResolution","coordinate","getTileCoordForXYAndResolution_","reverseIntersectionPolicy","getZForResolution","scale","getTileCoordResolution","opt_direction","fullTileRanges","createFromTemplate","template","zRegEx","xRegEx","yRegEx","dashYRegEx","pixelRatio","replace","toString","range","getHeight","createFromTemplates","templates","len","tileUrlFunctions","createFromTileUrlFunctions","h","index","expandUrl","url","urls","match","exec","startCharCode","charCodeAt","stopCharCode","charCode","push","fromCharCode","stop_1","parseInt","transformStringDiv","tmp_","create","reset","transform","set","multiply","transform1","transform2","a1","b1","c1","d1","e1","f1","a2","b2","c2","d2","e2","f2","c","d","e","f","setFromArray","apply","rotate","angle","cos","sin","makeScale","target","translate","dx","dy","compose","dx1","dy1","sx","sy","dx2","dy2","makeInverse","source","det","determinant","mat","transformString","join","node","document","createElement","style"],"mappings":"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","file":"js/chunk-1eb189e3.eb025f06.js","sourcesContent":["/**\n * @module ol/tilegrid/common\n */\n/**\n * Default maximum zoom for default tile grids.\n * @type {number}\n */\nexport var DEFAULT_MAX_ZOOM = 42;\n/**\n * Default tile size.\n * @type {number}\n */\nexport var DEFAULT_TILE_SIZE = 256;\n//# sourceMappingURL=common.js.map","/**\n * @module ol/tilegrid\n */\nimport Corner from './extent/Corner.js';\nimport TileGrid from './tilegrid/TileGrid.js';\nimport Units from './proj/Units.js';\nimport { DEFAULT_MAX_ZOOM, DEFAULT_TILE_SIZE } from './tilegrid/common.js';\nimport { METERS_PER_UNIT, get as getProjection } from './proj.js';\nimport { containsCoordinate, createOrUpdate, getCorner, getHeight, getWidth, } from './extent.js';\nimport { toSize } from './size.js';\n/**\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {!TileGrid} Default tile grid for the\n * passed projection.\n */\nexport function getForProjection(projection) {\n    var tileGrid = projection.getDefaultTileGrid();\n    if (!tileGrid) {\n        tileGrid = createForProjection(projection);\n        projection.setDefaultTileGrid(tileGrid);\n    }\n    return tileGrid;\n}\n/**\n * @param {TileGrid} tileGrid Tile grid.\n * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {import(\"./tilecoord.js\").TileCoord} Tile coordinate.\n */\nexport function wrapX(tileGrid, tileCoord, projection) {\n    var z = tileCoord[0];\n    var center = tileGrid.getTileCoordCenter(tileCoord);\n    var projectionExtent = extentFromProjection(projection);\n    if (!containsCoordinate(projectionExtent, center)) {\n        var worldWidth = getWidth(projectionExtent);\n        var worldsAway = Math.ceil((projectionExtent[0] - center[0]) / worldWidth);\n        center[0] += worldWidth * worldsAway;\n        return tileGrid.getTileCoordForCoordAndZ(center, z);\n    }\n    else {\n        return tileCoord;\n    }\n}\n/**\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number} [opt_maxZoom] Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size} [opt_tileSize] Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {import(\"./extent/Corner.js\").default} [opt_corner] Extent corner (default is `'top-left'`).\n * @return {!TileGrid} TileGrid instance.\n */\nexport function createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner) {\n    var corner = opt_corner !== undefined ? opt_corner : Corner.TOP_LEFT;\n    var resolutions = resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize);\n    return new TileGrid({\n        extent: extent,\n        origin: getCorner(extent, corner),\n        resolutions: resolutions,\n        tileSize: opt_tileSize,\n    });\n}\n/**\n * @typedef {Object} XYZOptions\n * @property {import(\"./extent.js\").Extent} [extent] Extent for the tile grid. The origin for an XYZ tile grid is the\n * top-left corner of the extent. If `maxResolution` is not provided the zero level of the grid is defined by the resolution\n * at which one tile fits in the provided extent. If not provided, the extent of the EPSG:3857 projection is used.\n * @property {number} [maxResolution] Resolution at level zero.\n * @property {number} [maxZoom] Maximum zoom. The default is `42`. This determines the number of levels\n * in the grid set. For example, a `maxZoom` of 21 means there are 22 levels in the grid set.\n * @property {number} [minZoom=0] Minimum zoom.\n * @property {number|import(\"./size.js\").Size} [tileSize=[256, 256]] Tile size in pixels.\n */\n/**\n * Creates a tile grid with a standard XYZ tiling scheme.\n * @param {XYZOptions} [opt_options] Tile grid options.\n * @return {!TileGrid} Tile grid instance.\n * @api\n */\nexport function createXYZ(opt_options) {\n    var xyzOptions = opt_options || {};\n    var extent = xyzOptions.extent || getProjection('EPSG:3857').getExtent();\n    var gridOptions = {\n        extent: extent,\n        minZoom: xyzOptions.minZoom,\n        tileSize: xyzOptions.tileSize,\n        resolutions: resolutionsFromExtent(extent, xyzOptions.maxZoom, xyzOptions.tileSize, xyzOptions.maxResolution),\n    };\n    return new TileGrid(gridOptions);\n}\n/**\n * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number} [opt_maxZoom] Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size} [opt_tileSize] Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {number} [opt_maxResolution] Resolution at level zero.\n * @return {!Array<number>} Resolutions array.\n */\nfunction resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize, opt_maxResolution) {\n    var maxZoom = opt_maxZoom !== undefined ? opt_maxZoom : DEFAULT_MAX_ZOOM;\n    var height = getHeight(extent);\n    var width = getWidth(extent);\n    var tileSize = toSize(opt_tileSize !== undefined ? opt_tileSize : DEFAULT_TILE_SIZE);\n    var maxResolution = opt_maxResolution > 0\n        ? opt_maxResolution\n        : Math.max(width / tileSize[0], height / tileSize[1]);\n    var length = maxZoom + 1;\n    var resolutions = new Array(length);\n    for (var z = 0; z < length; ++z) {\n        resolutions[z] = maxResolution / Math.pow(2, z);\n    }\n    return resolutions;\n}\n/**\n * @param {import(\"./proj.js\").ProjectionLike} projection Projection.\n * @param {number} [opt_maxZoom] Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size} [opt_tileSize] Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {import(\"./extent/Corner.js\").default} [opt_corner] Extent corner (default is `'top-left'`).\n * @return {!TileGrid} TileGrid instance.\n */\nexport function createForProjection(projection, opt_maxZoom, opt_tileSize, opt_corner) {\n    var extent = extentFromProjection(projection);\n    return createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner);\n}\n/**\n * Generate a tile grid extent from a projection.  If the projection has an\n * extent, it is used.  If not, a global extent is assumed.\n * @param {import(\"./proj.js\").ProjectionLike} projection Projection.\n * @return {import(\"./extent.js\").Extent} Extent.\n */\nexport function extentFromProjection(projection) {\n    projection = getProjection(projection);\n    var extent = projection.getExtent();\n    if (!extent) {\n        var half = (180 * METERS_PER_UNIT[Units.DEGREES]) / projection.getMetersPerUnit();\n        extent = createOrUpdate(-half, -half, half, half);\n    }\n    return extent;\n}\n//# sourceMappingURL=tilegrid.js.map","/**\n * @module ol/util\n */\n/**\n * @return {?} Any return.\n */\nexport function abstract() {\n    return /** @type {?} */ ((function () {\n        throw new Error('Unimplemented abstract method.');\n    })());\n}\n/**\n * Counter for getUid.\n * @type {number}\n * @private\n */\nvar uidCounter_ = 0;\n/**\n * Gets a unique ID for an object. This mutates the object so that further calls\n * with the same object as a parameter returns the same value. Unique IDs are generated\n * as a strictly increasing sequence. Adapted from goog.getUid.\n *\n * @param {Object} obj The object to get the unique ID for.\n * @return {string} The unique ID for the object.\n * @api\n */\nexport function getUid(obj) {\n    return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));\n}\n/**\n * OpenLayers version.\n * @type {string}\n */\nexport var VERSION = '6.14.1';\n//# sourceMappingURL=util.js.map","/**\n * @module ol/tilecoord\n */\n/**\n * An array of three numbers representing the location of a tile in a tile\n * grid. The order is `z` (zoom level), `x` (column), and `y` (row).\n * @typedef {Array<number>} TileCoord\n * @api\n */\n/**\n * @param {number} z Z.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {TileCoord} [opt_tileCoord] Tile coordinate.\n * @return {TileCoord} Tile coordinate.\n */\nexport function createOrUpdate(z, x, y, opt_tileCoord) {\n    if (opt_tileCoord !== undefined) {\n        opt_tileCoord[0] = z;\n        opt_tileCoord[1] = x;\n        opt_tileCoord[2] = y;\n        return opt_tileCoord;\n    }\n    else {\n        return [z, x, y];\n    }\n}\n/**\n * @param {number} z Z.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {string} Key.\n */\nexport function getKeyZXY(z, x, y) {\n    return z + '/' + x + '/' + y;\n}\n/**\n * Get the key for a tile coord.\n * @param {TileCoord} tileCoord The tile coord.\n * @return {string} Key.\n */\nexport function getKey(tileCoord) {\n    return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);\n}\n/**\n * Get the tile cache key for a tile key obtained through `tile.getKey()`.\n * @param {string} tileKey The tile key.\n * @return {string} The cache key.\n */\nexport function getCacheKeyForTileKey(tileKey) {\n    var _a = tileKey\n        .substring(tileKey.lastIndexOf('/') + 1, tileKey.length)\n        .split(',')\n        .map(Number), z = _a[0], x = _a[1], y = _a[2];\n    return getKeyZXY(z, x, y);\n}\n/**\n * Get a tile coord given a key.\n * @param {string} key The tile coord key.\n * @return {TileCoord} The tile coord.\n */\nexport function fromKey(key) {\n    return key.split('/').map(Number);\n}\n/**\n * @param {TileCoord} tileCoord Tile coord.\n * @return {number} Hash.\n */\nexport function hash(tileCoord) {\n    return (tileCoord[1] << tileCoord[0]) + tileCoord[2];\n}\n/**\n * @param {TileCoord} tileCoord Tile coordinate.\n * @param {!import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {boolean} Tile coordinate is within extent and zoom level range.\n */\nexport function withinExtentAndZ(tileCoord, tileGrid) {\n    var z = tileCoord[0];\n    var x = tileCoord[1];\n    var y = tileCoord[2];\n    if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {\n        return false;\n    }\n    var tileRange = tileGrid.getFullTileRange(z);\n    if (!tileRange) {\n        return true;\n    }\n    else {\n        return tileRange.containsXY(x, y);\n    }\n}\n//# sourceMappingURL=tilecoord.js.map","/**\n * @module ol/tilegrid/TileGrid\n */\nimport TileRange, { createOrUpdate as createOrUpdateTileRange, } from '../TileRange.js';\nimport { DEFAULT_TILE_SIZE } from './common.js';\nimport { assert } from '../asserts.js';\nimport { ceil, clamp, floor } from '../math.js';\nimport { createOrUpdate, getTopLeft } from '../extent.js';\nimport { createOrUpdate as createOrUpdateTileCoord } from '../tilecoord.js';\nimport { isSorted, linearFindNearest } from '../array.js';\nimport { toSize } from '../size.js';\n/**\n * @private\n * @type {import(\"../tilecoord.js\").TileCoord}\n */\nvar tmpTileCoord = [0, 0, 0];\n/**\n * Number of decimal digits to consider in integer values when rounding.\n * @type {number}\n */\nvar DECIMALS = 5;\n/**\n * @typedef {Object} Options\n * @property {import(\"../extent.js\").Extent} [extent] Extent for the tile grid. No tiles outside this\n * extent will be requested by {@link module:ol/source/Tile~TileSource} sources. When no `origin` or\n * `origins` are configured, the `origin` will be set to the top-left corner of the extent.\n * @property {number} [minZoom=0] Minimum zoom.\n * @property {import(\"../coordinate.js\").Coordinate} [origin] The tile grid origin, i.e. where the `x`\n * and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left to right and downwards. If not\n * specified, `extent` or `origins` must be provided.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} [origins] Tile grid origins, i.e. where\n * the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If given, the array length\n * should match the length of the `resolutions` array, i.e. each resolution can have a different\n * origin. Tile coordinates increase left to right and downwards. If not specified, `extent` or\n * `origin` must be provided.\n * @property {!Array<number>} resolutions Resolutions. The array index of each resolution needs\n * to match the zoom level. This means that even if a `minZoom` is configured, the resolutions\n * array will have a length of `maxZoom + 1`.\n * @property {Array<import(\"../size.js\").Size>} [sizes] Number of tile rows and columns\n * of the grid for each zoom level. If specified the values\n * define each zoom level's extent together with the `origin` or `origins`.\n * A grid `extent` can be configured in addition, and will further limit the extent\n * for which tile requests are made by sources. If the bottom-left corner of\n * an extent is used as `origin` or `origins`, then the `y` value must be\n * negative because OpenLayers tile coordinates use the top left as the origin.\n * @property {number|import(\"../size.js\").Size} [tileSize] Tile size.\n * Default is `[256, 256]`.\n * @property {Array<import(\"../size.js\").Size>} [tileSizes] Tile sizes. If given, the array length\n * should match the length of the `resolutions` array, i.e. each resolution can have a different\n * tile size.\n */\n/**\n * @classdesc\n * Base class for setting the grid pattern for sources accessing tiled-image\n * servers.\n * @api\n */\nvar TileGrid = /** @class */ (function () {\n    /**\n     * @param {Options} options Tile grid options.\n     */\n    function TileGrid(options) {\n        /**\n         * @protected\n         * @type {number}\n         */\n        this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;\n        /**\n         * @private\n         * @type {!Array<number>}\n         */\n        this.resolutions_ = options.resolutions;\n        assert(isSorted(this.resolutions_, function (a, b) {\n            return b - a;\n        }, true), 17); // `resolutions` must be sorted in descending order\n        // check if we've got a consistent zoom factor and origin\n        var zoomFactor;\n        if (!options.origins) {\n            for (var i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {\n                if (!zoomFactor) {\n                    zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];\n                }\n                else {\n                    if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {\n                        zoomFactor = undefined;\n                        break;\n                    }\n                }\n            }\n        }\n        /**\n         * @private\n         * @type {number|undefined}\n         */\n        this.zoomFactor_ = zoomFactor;\n        /**\n         * @protected\n         * @type {number}\n         */\n        this.maxZoom = this.resolutions_.length - 1;\n        /**\n         * @private\n         * @type {import(\"../coordinate.js\").Coordinate|null}\n         */\n        this.origin_ = options.origin !== undefined ? options.origin : null;\n        /**\n         * @private\n         * @type {Array<import(\"../coordinate.js\").Coordinate>}\n         */\n        this.origins_ = null;\n        if (options.origins !== undefined) {\n            this.origins_ = options.origins;\n            assert(this.origins_.length == this.resolutions_.length, 20); // Number of `origins` and `resolutions` must be equal\n        }\n        var extent = options.extent;\n        if (extent !== undefined && !this.origin_ && !this.origins_) {\n            this.origin_ = getTopLeft(extent);\n        }\n        assert((!this.origin_ && this.origins_) || (this.origin_ && !this.origins_), 18); // Either `origin` or `origins` must be configured, never both\n        /**\n         * @private\n         * @type {Array<number|import(\"../size.js\").Size>}\n         */\n        this.tileSizes_ = null;\n        if (options.tileSizes !== undefined) {\n            this.tileSizes_ = options.tileSizes;\n            assert(this.tileSizes_.length == this.resolutions_.length, 19); // Number of `tileSizes` and `resolutions` must be equal\n        }\n        /**\n         * @private\n         * @type {number|import(\"../size.js\").Size}\n         */\n        this.tileSize_ =\n            options.tileSize !== undefined\n                ? options.tileSize\n                : !this.tileSizes_\n                    ? DEFAULT_TILE_SIZE\n                    : null;\n        assert((!this.tileSize_ && this.tileSizes_) ||\n            (this.tileSize_ && !this.tileSizes_), 22); // Either `tileSize` or `tileSizes` must be configured, never both\n        /**\n         * @private\n         * @type {import(\"../extent.js\").Extent}\n         */\n        this.extent_ = extent !== undefined ? extent : null;\n        /**\n         * @private\n         * @type {Array<import(\"../TileRange.js\").default>}\n         */\n        this.fullTileRanges_ = null;\n        /**\n         * @private\n         * @type {import(\"../size.js\").Size}\n         */\n        this.tmpSize_ = [0, 0];\n        /**\n         * @private\n         * @type {import(\"../extent.js\").Extent}\n         */\n        this.tmpExtent_ = [0, 0, 0, 0];\n        if (options.sizes !== undefined) {\n            this.fullTileRanges_ = options.sizes.map(function (size, z) {\n                var tileRange = new TileRange(Math.min(0, size[0]), Math.max(size[0] - 1, -1), Math.min(0, size[1]), Math.max(size[1] - 1, -1));\n                if (extent) {\n                    var restrictedTileRange = this.getTileRangeForExtentAndZ(extent, z);\n                    tileRange.minX = Math.max(restrictedTileRange.minX, tileRange.minX);\n                    tileRange.maxX = Math.min(restrictedTileRange.maxX, tileRange.maxX);\n                    tileRange.minY = Math.max(restrictedTileRange.minY, tileRange.minY);\n                    tileRange.maxY = Math.min(restrictedTileRange.maxY, tileRange.maxY);\n                }\n                return tileRange;\n            }, this);\n        }\n        else if (extent) {\n            this.calculateTileRanges_(extent);\n        }\n    }\n    /**\n     * Call a function with each tile coordinate for a given extent and zoom level.\n     *\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @param {number} zoom Integer zoom level.\n     * @param {function(import(\"../tilecoord.js\").TileCoord): void} callback Function called with each tile coordinate.\n     * @api\n     */\n    TileGrid.prototype.forEachTileCoord = function (extent, zoom, callback) {\n        var tileRange = this.getTileRangeForExtentAndZ(extent, zoom);\n        for (var i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {\n            for (var j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {\n                callback([zoom, i, j]);\n            }\n        }\n    };\n    /**\n     * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n     * @param {function(number, import(\"../TileRange.js\").default): boolean} callback Callback.\n     * @param {import(\"../TileRange.js\").default} [opt_tileRange] Temporary import(\"../TileRange.js\").default object.\n     * @param {import(\"../extent.js\").Extent} [opt_extent] Temporary import(\"../extent.js\").Extent object.\n     * @return {boolean} Callback succeeded.\n     */\n    TileGrid.prototype.forEachTileCoordParentTileRange = function (tileCoord, callback, opt_tileRange, opt_extent) {\n        var tileRange, x, y;\n        var tileCoordExtent = null;\n        var z = tileCoord[0] - 1;\n        if (this.zoomFactor_ === 2) {\n            x = tileCoord[1];\n            y = tileCoord[2];\n        }\n        else {\n            tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);\n        }\n        while (z >= this.minZoom) {\n            if (this.zoomFactor_ === 2) {\n                x = Math.floor(x / 2);\n                y = Math.floor(y / 2);\n                tileRange = createOrUpdateTileRange(x, x, y, y, opt_tileRange);\n            }\n            else {\n                tileRange = this.getTileRangeForExtentAndZ(tileCoordExtent, z, opt_tileRange);\n            }\n            if (callback(z, tileRange)) {\n                return true;\n            }\n            --z;\n        }\n        return false;\n    };\n    /**\n     * Get the extent for this tile grid, if it was configured.\n     * @return {import(\"../extent.js\").Extent} Extent.\n     * @api\n     */\n    TileGrid.prototype.getExtent = function () {\n        return this.extent_;\n    };\n    /**\n     * Get the maximum zoom level for the grid.\n     * @return {number} Max zoom.\n     * @api\n     */\n    TileGrid.prototype.getMaxZoom = function () {\n        return this.maxZoom;\n    };\n    /**\n     * Get the minimum zoom level for the grid.\n     * @return {number} Min zoom.\n     * @api\n     */\n    TileGrid.prototype.getMinZoom = function () {\n        return this.minZoom;\n    };\n    /**\n     * Get the origin for the grid at the given zoom level.\n     * @param {number} z Integer zoom level.\n     * @return {import(\"../coordinate.js\").Coordinate} Origin.\n     * @api\n     */\n    TileGrid.prototype.getOrigin = function (z) {\n        if (this.origin_) {\n            return this.origin_;\n        }\n        else {\n            return this.origins_[z];\n        }\n    };\n    /**\n     * Get the resolution for the given zoom level.\n     * @param {number} z Integer zoom level.\n     * @return {number} Resolution.\n     * @api\n     */\n    TileGrid.prototype.getResolution = function (z) {\n        return this.resolutions_[z];\n    };\n    /**\n     * Get the list of resolutions for the tile grid.\n     * @return {Array<number>} Resolutions.\n     * @api\n     */\n    TileGrid.prototype.getResolutions = function () {\n        return this.resolutions_;\n    };\n    /**\n     * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n     * @param {import(\"../TileRange.js\").default} [opt_tileRange] Temporary import(\"../TileRange.js\").default object.\n     * @param {import(\"../extent.js\").Extent} [opt_extent] Temporary import(\"../extent.js\").Extent object.\n     * @return {import(\"../TileRange.js\").default} Tile range.\n     */\n    TileGrid.prototype.getTileCoordChildTileRange = function (tileCoord, opt_tileRange, opt_extent) {\n        if (tileCoord[0] < this.maxZoom) {\n            if (this.zoomFactor_ === 2) {\n                var minX = tileCoord[1] * 2;\n                var minY = tileCoord[2] * 2;\n                return createOrUpdateTileRange(minX, minX + 1, minY, minY + 1, opt_tileRange);\n            }\n            var tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent || this.tmpExtent_);\n            return this.getTileRangeForExtentAndZ(tileCoordExtent, tileCoord[0] + 1, opt_tileRange);\n        }\n        return null;\n    };\n    /**\n     * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n     * @param {number} z Integer zoom level.\n     * @param {import(\"../TileRange.js\").default} [opt_tileRange] Temporary import(\"../TileRange.js\").default object.\n     * @return {import(\"../TileRange.js\").default} Tile range.\n     */\n    TileGrid.prototype.getTileRangeForTileCoordAndZ = function (tileCoord, z, opt_tileRange) {\n        if (z > this.maxZoom || z < this.minZoom) {\n            return null;\n        }\n        var tileCoordZ = tileCoord[0];\n        var tileCoordX = tileCoord[1];\n        var tileCoordY = tileCoord[2];\n        if (z === tileCoordZ) {\n            return createOrUpdateTileRange(tileCoordX, tileCoordY, tileCoordX, tileCoordY, opt_tileRange);\n        }\n        if (this.zoomFactor_) {\n            var factor = Math.pow(this.zoomFactor_, z - tileCoordZ);\n            var minX = Math.floor(tileCoordX * factor);\n            var minY = Math.floor(tileCoordY * factor);\n            if (z < tileCoordZ) {\n                return createOrUpdateTileRange(minX, minX, minY, minY, opt_tileRange);\n            }\n            var maxX = Math.floor(factor * (tileCoordX + 1)) - 1;\n            var maxY = Math.floor(factor * (tileCoordY + 1)) - 1;\n            return createOrUpdateTileRange(minX, maxX, minY, maxY, opt_tileRange);\n        }\n        var tileCoordExtent = this.getTileCoordExtent(tileCoord, this.tmpExtent_);\n        return this.getTileRangeForExtentAndZ(tileCoordExtent, z, opt_tileRange);\n    };\n    /**\n     * Get the extent for a tile range.\n     * @param {number} z Integer zoom level.\n     * @param {import(\"../TileRange.js\").default} tileRange Tile range.\n     * @param {import(\"../extent.js\").Extent} [opt_extent] Temporary import(\"../extent.js\").Extent object.\n     * @return {import(\"../extent.js\").Extent} Extent.\n     */\n    TileGrid.prototype.getTileRangeExtent = function (z, tileRange, opt_extent) {\n        var origin = this.getOrigin(z);\n        var resolution = this.getResolution(z);\n        var tileSize = toSize(this.getTileSize(z), this.tmpSize_);\n        var minX = origin[0] + tileRange.minX * tileSize[0] * resolution;\n        var maxX = origin[0] + (tileRange.maxX + 1) * tileSize[0] * resolution;\n        var minY = origin[1] + tileRange.minY * tileSize[1] * resolution;\n        var maxY = origin[1] + (tileRange.maxY + 1) * tileSize[1] * resolution;\n        return createOrUpdate(minX, minY, maxX, maxY, opt_extent);\n    };\n    /**\n     * Get a tile range for the given extent and integer zoom level.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @param {number} z Integer zoom level.\n     * @param {import(\"../TileRange.js\").default} [opt_tileRange] Temporary tile range object.\n     * @return {import(\"../TileRange.js\").default} Tile range.\n     */\n    TileGrid.prototype.getTileRangeForExtentAndZ = function (extent, z, opt_tileRange) {\n        var tileCoord = tmpTileCoord;\n        this.getTileCoordForXYAndZ_(extent[0], extent[3], z, false, tileCoord);\n        var minX = tileCoord[1];\n        var minY = tileCoord[2];\n        this.getTileCoordForXYAndZ_(extent[2], extent[1], z, true, tileCoord);\n        return createOrUpdateTileRange(minX, tileCoord[1], minY, tileCoord[2], opt_tileRange);\n    };\n    /**\n     * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n     * @return {import(\"../coordinate.js\").Coordinate} Tile center.\n     */\n    TileGrid.prototype.getTileCoordCenter = function (tileCoord) {\n        var origin = this.getOrigin(tileCoord[0]);\n        var resolution = this.getResolution(tileCoord[0]);\n        var tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\n        return [\n            origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution,\n            origin[1] - (tileCoord[2] + 0.5) * tileSize[1] * resolution,\n        ];\n    };\n    /**\n     * Get the extent of a tile coordinate.\n     *\n     * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n     * @param {import(\"../extent.js\").Extent} [opt_extent] Temporary extent object.\n     * @return {import(\"../extent.js\").Extent} Extent.\n     * @api\n     */\n    TileGrid.prototype.getTileCoordExtent = function (tileCoord, opt_extent) {\n        var origin = this.getOrigin(tileCoord[0]);\n        var resolution = this.getResolution(tileCoord[0]);\n        var tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\n        var minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;\n        var minY = origin[1] - (tileCoord[2] + 1) * tileSize[1] * resolution;\n        var maxX = minX + tileSize[0] * resolution;\n        var maxY = minY + tileSize[1] * resolution;\n        return createOrUpdate(minX, minY, maxX, maxY, opt_extent);\n    };\n    /**\n     * Get the tile coordinate for the given map coordinate and resolution.  This\n     * method considers that coordinates that intersect tile boundaries should be\n     * assigned the higher tile coordinate.\n     *\n     * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @param {number} resolution Resolution.\n     * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Destination import(\"../tilecoord.js\").TileCoord object.\n     * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n     * @api\n     */\n    TileGrid.prototype.getTileCoordForCoordAndResolution = function (coordinate, resolution, opt_tileCoord) {\n        return this.getTileCoordForXYAndResolution_(coordinate[0], coordinate[1], resolution, false, opt_tileCoord);\n    };\n    /**\n     * Note that this method should not be called for resolutions that correspond\n     * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {number} resolution Resolution (for a non-integer zoom level).\n     * @param {boolean} reverseIntersectionPolicy Instead of letting edge\n     *     intersections go to the higher tile coordinate, let edge intersections\n     *     go to the lower tile coordinate.\n     * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Temporary import(\"../tilecoord.js\").TileCoord object.\n     * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n     * @private\n     */\n    TileGrid.prototype.getTileCoordForXYAndResolution_ = function (x, y, resolution, reverseIntersectionPolicy, opt_tileCoord) {\n        var z = this.getZForResolution(resolution);\n        var scale = resolution / this.getResolution(z);\n        var origin = this.getOrigin(z);\n        var tileSize = toSize(this.getTileSize(z), this.tmpSize_);\n        var tileCoordX = (scale * (x - origin[0])) / resolution / tileSize[0];\n        var tileCoordY = (scale * (origin[1] - y)) / resolution / tileSize[1];\n        if (reverseIntersectionPolicy) {\n            tileCoordX = ceil(tileCoordX, DECIMALS) - 1;\n            tileCoordY = ceil(tileCoordY, DECIMALS) - 1;\n        }\n        else {\n            tileCoordX = floor(tileCoordX, DECIMALS);\n            tileCoordY = floor(tileCoordY, DECIMALS);\n        }\n        return createOrUpdateTileCoord(z, tileCoordX, tileCoordY, opt_tileCoord);\n    };\n    /**\n     * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,\n     * they should have separate implementations.  This method is for integer zoom\n     * levels.  The other method should only be called for resolutions corresponding\n     * to non-integer zoom levels.\n     * @param {number} x Map x coordinate.\n     * @param {number} y Map y coordinate.\n     * @param {number} z Integer zoom level.\n     * @param {boolean} reverseIntersectionPolicy Instead of letting edge\n     *     intersections go to the higher tile coordinate, let edge intersections\n     *     go to the lower tile coordinate.\n     * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Temporary import(\"../tilecoord.js\").TileCoord object.\n     * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n     * @private\n     */\n    TileGrid.prototype.getTileCoordForXYAndZ_ = function (x, y, z, reverseIntersectionPolicy, opt_tileCoord) {\n        var origin = this.getOrigin(z);\n        var resolution = this.getResolution(z);\n        var tileSize = toSize(this.getTileSize(z), this.tmpSize_);\n        var tileCoordX = (x - origin[0]) / resolution / tileSize[0];\n        var tileCoordY = (origin[1] - y) / resolution / tileSize[1];\n        if (reverseIntersectionPolicy) {\n            tileCoordX = ceil(tileCoordX, DECIMALS) - 1;\n            tileCoordY = ceil(tileCoordY, DECIMALS) - 1;\n        }\n        else {\n            tileCoordX = floor(tileCoordX, DECIMALS);\n            tileCoordY = floor(tileCoordY, DECIMALS);\n        }\n        return createOrUpdateTileCoord(z, tileCoordX, tileCoordY, opt_tileCoord);\n    };\n    /**\n     * Get a tile coordinate given a map coordinate and zoom level.\n     * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @param {number} z Zoom level.\n     * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Destination import(\"../tilecoord.js\").TileCoord object.\n     * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n     * @api\n     */\n    TileGrid.prototype.getTileCoordForCoordAndZ = function (coordinate, z, opt_tileCoord) {\n        return this.getTileCoordForXYAndZ_(coordinate[0], coordinate[1], z, false, opt_tileCoord);\n    };\n    /**\n     * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n     * @return {number} Tile resolution.\n     */\n    TileGrid.prototype.getTileCoordResolution = function (tileCoord) {\n        return this.resolutions_[tileCoord[0]];\n    };\n    /**\n     * Get the tile size for a zoom level. The type of the return value matches the\n     * `tileSize` or `tileSizes` that the tile grid was configured with. To always\n     * get an {@link import(\"../size.js\").Size}, run the result through {@link module:ol/size.toSize}.\n     * @param {number} z Z.\n     * @return {number|import(\"../size.js\").Size} Tile size.\n     * @api\n     */\n    TileGrid.prototype.getTileSize = function (z) {\n        if (this.tileSize_) {\n            return this.tileSize_;\n        }\n        else {\n            return this.tileSizes_[z];\n        }\n    };\n    /**\n     * @param {number} z Zoom level.\n     * @return {import(\"../TileRange.js\").default} Extent tile range for the specified zoom level.\n     */\n    TileGrid.prototype.getFullTileRange = function (z) {\n        if (!this.fullTileRanges_) {\n            return this.extent_\n                ? this.getTileRangeForExtentAndZ(this.extent_, z)\n                : null;\n        }\n        else {\n            return this.fullTileRanges_[z];\n        }\n    };\n    /**\n     * @param {number} resolution Resolution.\n     * @param {number|import(\"../array.js\").NearestDirectionFunction} [opt_direction]\n     *     If 0, the nearest resolution will be used.\n     *     If 1, the nearest higher resolution (lower Z) will be used. If -1, the\n     *     nearest lower resolution (higher Z) will be used. Default is 0.\n     *     Use a {@link module:ol/array~NearestDirectionFunction} for more precise control.\n     *\n     * For example to change tile Z at the midpoint of zoom levels\n     * ```js\n     * function(value, high, low) {\n     *   return value - low * Math.sqrt(high / low);\n     * }\n     * ```\n     * @return {number} Z.\n     * @api\n     */\n    TileGrid.prototype.getZForResolution = function (resolution, opt_direction) {\n        var z = linearFindNearest(this.resolutions_, resolution, opt_direction || 0);\n        return clamp(z, this.minZoom, this.maxZoom);\n    };\n    /**\n     * @param {!import(\"../extent.js\").Extent} extent Extent for this tile grid.\n     * @private\n     */\n    TileGrid.prototype.calculateTileRanges_ = function (extent) {\n        var length = this.resolutions_.length;\n        var fullTileRanges = new Array(length);\n        for (var z = this.minZoom; z < length; ++z) {\n            fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);\n        }\n        this.fullTileRanges_ = fullTileRanges;\n    };\n    return TileGrid;\n}());\nexport default TileGrid;\n//# sourceMappingURL=TileGrid.js.map","/**\n * @module ol/tileurlfunction\n */\nimport { assert } from './asserts.js';\nimport { modulo } from './math.js';\nimport { hash as tileCoordHash } from './tilecoord.js';\n/**\n * @param {string} template Template.\n * @param {import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {import(\"./Tile.js\").UrlFunction} Tile URL function.\n */\nexport function createFromTemplate(template, tileGrid) {\n    var zRegEx = /\\{z\\}/g;\n    var xRegEx = /\\{x\\}/g;\n    var yRegEx = /\\{y\\}/g;\n    var dashYRegEx = /\\{-y\\}/g;\n    return (\n    /**\n     * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile Coordinate.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"./proj/Projection.js\").default} projection Projection.\n     * @return {string|undefined} Tile URL.\n     */\n    function (tileCoord, pixelRatio, projection) {\n        if (!tileCoord) {\n            return undefined;\n        }\n        else {\n            return template\n                .replace(zRegEx, tileCoord[0].toString())\n                .replace(xRegEx, tileCoord[1].toString())\n                .replace(yRegEx, tileCoord[2].toString())\n                .replace(dashYRegEx, function () {\n                var z = tileCoord[0];\n                var range = tileGrid.getFullTileRange(z);\n                assert(range, 55); // The {-y} placeholder requires a tile grid with extent\n                var y = range.getHeight() - tileCoord[2] - 1;\n                return y.toString();\n            });\n        }\n    });\n}\n/**\n * @param {Array<string>} templates Templates.\n * @param {import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {import(\"./Tile.js\").UrlFunction} Tile URL function.\n */\nexport function createFromTemplates(templates, tileGrid) {\n    var len = templates.length;\n    var tileUrlFunctions = new Array(len);\n    for (var i = 0; i < len; ++i) {\n        tileUrlFunctions[i] = createFromTemplate(templates[i], tileGrid);\n    }\n    return createFromTileUrlFunctions(tileUrlFunctions);\n}\n/**\n * @param {Array<import(\"./Tile.js\").UrlFunction>} tileUrlFunctions Tile URL Functions.\n * @return {import(\"./Tile.js\").UrlFunction} Tile URL function.\n */\nexport function createFromTileUrlFunctions(tileUrlFunctions) {\n    if (tileUrlFunctions.length === 1) {\n        return tileUrlFunctions[0];\n    }\n    return (\n    /**\n     * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile Coordinate.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"./proj/Projection.js\").default} projection Projection.\n     * @return {string|undefined} Tile URL.\n     */\n    function (tileCoord, pixelRatio, projection) {\n        if (!tileCoord) {\n            return undefined;\n        }\n        else {\n            var h = tileCoordHash(tileCoord);\n            var index = modulo(h, tileUrlFunctions.length);\n            return tileUrlFunctions[index](tileCoord, pixelRatio, projection);\n        }\n    });\n}\n/**\n * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @param {number} pixelRatio Pixel ratio.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {string|undefined} Tile URL.\n */\nexport function nullTileUrlFunction(tileCoord, pixelRatio, projection) {\n    return undefined;\n}\n/**\n * @param {string} url URL.\n * @return {Array<string>} Array of urls.\n */\nexport function expandUrl(url) {\n    var urls = [];\n    var match = /\\{([a-z])-([a-z])\\}/.exec(url);\n    if (match) {\n        // char range\n        var startCharCode = match[1].charCodeAt(0);\n        var stopCharCode = match[2].charCodeAt(0);\n        var charCode = void 0;\n        for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {\n            urls.push(url.replace(match[0], String.fromCharCode(charCode)));\n        }\n        return urls;\n    }\n    match = /\\{(\\d+)-(\\d+)\\}/.exec(url);\n    if (match) {\n        // number range\n        var stop_1 = parseInt(match[2], 10);\n        for (var i = parseInt(match[1], 10); i <= stop_1; i++) {\n            urls.push(url.replace(match[0], i.toString()));\n        }\n        return urls;\n    }\n    urls.push(url);\n    return urls;\n}\n//# sourceMappingURL=tileurlfunction.js.map","/**\n * @module ol/transform\n */\nimport { WORKER_OFFSCREEN_CANVAS } from './has.js';\nimport { assert } from './asserts.js';\n/**\n * An array representing an affine 2d transformation for use with\n * {@link module:ol/transform} functions. The array has 6 elements.\n * @typedef {!Array<number>} Transform\n * @api\n */\n/**\n * Collection of affine 2d transformation functions. The functions work on an\n * array of 6 elements. The element order is compatible with the [SVGMatrix\n * interface](https://developer.mozilla.org/en-US/docs/Web/API/SVGMatrix) and is\n * a subset (elements a to f) of a 33 matrix:\n * ```\n * [ a c e ]\n * [ b d f ]\n * [ 0 0 1 ]\n * ```\n */\n/**\n * @private\n * @type {Transform}\n */\nvar tmp_ = new Array(6);\n/**\n * Create an identity transform.\n * @return {!Transform} Identity transform.\n */\nexport function create() {\n    return [1, 0, 0, 1, 0, 0];\n}\n/**\n * Resets the given transform to an identity transform.\n * @param {!Transform} transform Transform.\n * @return {!Transform} Transform.\n */\nexport function reset(transform) {\n    return set(transform, 1, 0, 0, 1, 0, 0);\n}\n/**\n * Multiply the underlying matrices of two transforms and return the result in\n * the first transform.\n * @param {!Transform} transform1 Transform parameters of matrix 1.\n * @param {!Transform} transform2 Transform parameters of matrix 2.\n * @return {!Transform} transform1 multiplied with transform2.\n */\nexport function multiply(transform1, transform2) {\n    var a1 = transform1[0];\n    var b1 = transform1[1];\n    var c1 = transform1[2];\n    var d1 = transform1[3];\n    var e1 = transform1[4];\n    var f1 = transform1[5];\n    var a2 = transform2[0];\n    var b2 = transform2[1];\n    var c2 = transform2[2];\n    var d2 = transform2[3];\n    var e2 = transform2[4];\n    var f2 = transform2[5];\n    transform1[0] = a1 * a2 + c1 * b2;\n    transform1[1] = b1 * a2 + d1 * b2;\n    transform1[2] = a1 * c2 + c1 * d2;\n    transform1[3] = b1 * c2 + d1 * d2;\n    transform1[4] = a1 * e2 + c1 * f2 + e1;\n    transform1[5] = b1 * e2 + d1 * f2 + f1;\n    return transform1;\n}\n/**\n * Set the transform components a-f on a given transform.\n * @param {!Transform} transform Transform.\n * @param {number} a The a component of the transform.\n * @param {number} b The b component of the transform.\n * @param {number} c The c component of the transform.\n * @param {number} d The d component of the transform.\n * @param {number} e The e component of the transform.\n * @param {number} f The f component of the transform.\n * @return {!Transform} Matrix with transform applied.\n */\nexport function set(transform, a, b, c, d, e, f) {\n    transform[0] = a;\n    transform[1] = b;\n    transform[2] = c;\n    transform[3] = d;\n    transform[4] = e;\n    transform[5] = f;\n    return transform;\n}\n/**\n * Set transform on one matrix from another matrix.\n * @param {!Transform} transform1 Matrix to set transform to.\n * @param {!Transform} transform2 Matrix to set transform from.\n * @return {!Transform} transform1 with transform from transform2 applied.\n */\nexport function setFromArray(transform1, transform2) {\n    transform1[0] = transform2[0];\n    transform1[1] = transform2[1];\n    transform1[2] = transform2[2];\n    transform1[3] = transform2[3];\n    transform1[4] = transform2[4];\n    transform1[5] = transform2[5];\n    return transform1;\n}\n/**\n * Transforms the given coordinate with the given transform returning the\n * resulting, transformed coordinate. The coordinate will be modified in-place.\n *\n * @param {Transform} transform The transformation.\n * @param {import(\"./coordinate.js\").Coordinate|import(\"./pixel.js\").Pixel} coordinate The coordinate to transform.\n * @return {import(\"./coordinate.js\").Coordinate|import(\"./pixel.js\").Pixel} return coordinate so that operations can be\n *     chained together.\n */\nexport function apply(transform, coordinate) {\n    var x = coordinate[0];\n    var y = coordinate[1];\n    coordinate[0] = transform[0] * x + transform[2] * y + transform[4];\n    coordinate[1] = transform[1] * x + transform[3] * y + transform[5];\n    return coordinate;\n}\n/**\n * Applies rotation to the given transform.\n * @param {!Transform} transform Transform.\n * @param {number} angle Angle in radians.\n * @return {!Transform} The rotated transform.\n */\nexport function rotate(transform, angle) {\n    var cos = Math.cos(angle);\n    var sin = Math.sin(angle);\n    return multiply(transform, set(tmp_, cos, sin, -sin, cos, 0, 0));\n}\n/**\n * Applies scale to a given transform.\n * @param {!Transform} transform Transform.\n * @param {number} x Scale factor x.\n * @param {number} y Scale factor y.\n * @return {!Transform} The scaled transform.\n */\nexport function scale(transform, x, y) {\n    return multiply(transform, set(tmp_, x, 0, 0, y, 0, 0));\n}\n/**\n * Creates a scale transform.\n * @param {!Transform} target Transform to overwrite.\n * @param {number} x Scale factor x.\n * @param {number} y Scale factor y.\n * @return {!Transform} The scale transform.\n */\nexport function makeScale(target, x, y) {\n    return set(target, x, 0, 0, y, 0, 0);\n}\n/**\n * Applies translation to the given transform.\n * @param {!Transform} transform Transform.\n * @param {number} dx Translation x.\n * @param {number} dy Translation y.\n * @return {!Transform} The translated transform.\n */\nexport function translate(transform, dx, dy) {\n    return multiply(transform, set(tmp_, 1, 0, 0, 1, dx, dy));\n}\n/**\n * Creates a composite transform given an initial translation, scale, rotation, and\n * final translation (in that order only, not commutative).\n * @param {!Transform} transform The transform (will be modified in place).\n * @param {number} dx1 Initial translation x.\n * @param {number} dy1 Initial translation y.\n * @param {number} sx Scale factor x.\n * @param {number} sy Scale factor y.\n * @param {number} angle Rotation (in counter-clockwise radians).\n * @param {number} dx2 Final translation x.\n * @param {number} dy2 Final translation y.\n * @return {!Transform} The composite transform.\n */\nexport function compose(transform, dx1, dy1, sx, sy, angle, dx2, dy2) {\n    var sin = Math.sin(angle);\n    var cos = Math.cos(angle);\n    transform[0] = sx * cos;\n    transform[1] = sy * sin;\n    transform[2] = -sx * sin;\n    transform[3] = sy * cos;\n    transform[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;\n    transform[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;\n    return transform;\n}\n/**\n * Creates a composite transform given an initial translation, scale, rotation, and\n * final translation (in that order only, not commutative). The resulting transform\n * string can be applied as `transform` property of an HTMLElement's style.\n * @param {number} dx1 Initial translation x.\n * @param {number} dy1 Initial translation y.\n * @param {number} sx Scale factor x.\n * @param {number} sy Scale factor y.\n * @param {number} angle Rotation (in counter-clockwise radians).\n * @param {number} dx2 Final translation x.\n * @param {number} dy2 Final translation y.\n * @return {string} The composite css transform.\n * @api\n */\nexport function composeCssTransform(dx1, dy1, sx, sy, angle, dx2, dy2) {\n    return toString(compose(create(), dx1, dy1, sx, sy, angle, dx2, dy2));\n}\n/**\n * Invert the given transform.\n * @param {!Transform} source The source transform to invert.\n * @return {!Transform} The inverted (source) transform.\n */\nexport function invert(source) {\n    return makeInverse(source, source);\n}\n/**\n * Invert the given transform.\n * @param {!Transform} target Transform to be set as the inverse of\n *     the source transform.\n * @param {!Transform} source The source transform to invert.\n * @return {!Transform} The inverted (target) transform.\n */\nexport function makeInverse(target, source) {\n    var det = determinant(source);\n    assert(det !== 0, 32); // Transformation matrix cannot be inverted\n    var a = source[0];\n    var b = source[1];\n    var c = source[2];\n    var d = source[3];\n    var e = source[4];\n    var f = source[5];\n    target[0] = d / det;\n    target[1] = -b / det;\n    target[2] = -c / det;\n    target[3] = a / det;\n    target[4] = (c * f - d * e) / det;\n    target[5] = -(a * f - b * e) / det;\n    return target;\n}\n/**\n * Returns the determinant of the given matrix.\n * @param {!Transform} mat Matrix.\n * @return {number} Determinant.\n */\nexport function determinant(mat) {\n    return mat[0] * mat[3] - mat[1] * mat[2];\n}\n/**\n * @type {HTMLElement}\n * @private\n */\nvar transformStringDiv;\n/**\n * A rounded string version of the transform.  This can be used\n * for CSS transforms.\n * @param {!Transform} mat Matrix.\n * @return {string} The transform as a string.\n */\nexport function toString(mat) {\n    var transformString = 'matrix(' + mat.join(', ') + ')';\n    if (WORKER_OFFSCREEN_CANVAS) {\n        return transformString;\n    }\n    var node = transformStringDiv || (transformStringDiv = document.createElement('div'));\n    node.style.transform = transformString;\n    return node.style.transform;\n}\n//# sourceMappingURL=transform.js.map"],"sourceRoot":""}
{"version":3,"file":"js/5918.9f0dc0a6.js","mappings":"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","sources":["webpack://@openeo/web-editor/./node_modules/ol/renderer/Map.js","webpack://@openeo/web-editor/./node_modules/ol/renderer/Composite.js","webpack://@openeo/web-editor/./node_modules/ol/renderer/Layer.js","webpack://@openeo/web-editor/./node_modules/ol/renderer/canvas/ImageLayer.js","webpack://@openeo/web-editor/./node_modules/ol/renderer/canvas/Layer.js","webpack://@openeo/web-editor/./node_modules/ol/renderer/canvas/TileLayer.js","webpack://@openeo/web-editor/./node_modules/ol/renderer/canvas/VectorLayer.js","webpack://@openeo/web-editor/./node_modules/ol/renderer/canvas/VectorTileLayer.js","webpack://@openeo/web-editor/./node_modules/ol/renderer/vector.js","webpack://@openeo/web-editor/./node_modules/ol/renderer/webgl/Layer.js","webpack://@openeo/web-editor/./node_modules/ol/render/webgl/constants.js","webpack://@openeo/web-editor/./node_modules/ol/render/webgl/utils.js","webpack://@openeo/web-editor/./node_modules/ol/renderer/webgl/PointsLayer.js"],"sourcesContent":["/**\n * @module ol/renderer/Map\n */\nimport Disposable from '../Disposable.js';\nimport {TRUE} from '../functions.js';\nimport {abstract} from '../util.js';\nimport {compose as composeTransform, makeInverse} from '../transform.js';\nimport {getWidth} from '../extent.js';\nimport {shared as iconImageCache} from '../style/IconImageCache.js';\nimport {inView} from '../layer/Layer.js';\nimport {wrapX} from '../coordinate.js';\n\n/**\n * @typedef HitMatch\n * @property {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @property {import(\"../layer/Layer.js\").default} layer Layer.\n * @property {import(\"../geom/SimpleGeometry.js\").default} geometry Geometry.\n * @property {number} distanceSq Squared distance.\n * @property {import(\"./vector.js\").FeatureCallback<T>} callback Callback.\n * @template T\n */\n\n/**\n * @abstract\n */\nclass MapRenderer extends Disposable {\n  /**\n   * @param {import(\"../Map.js\").default} map Map.\n   */\n  constructor(map) {\n    super();\n\n    /**\n     * @private\n     * @type {import(\"../Map.js\").default}\n     */\n    this.map_ = map;\n  }\n\n  /**\n   * @abstract\n   * @param {import(\"../render/EventType.js\").default} type Event type.\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   */\n  dispatchRenderEvent(type, frameState) {\n    abstract();\n  }\n\n  /**\n   * @param {import(\"../Map.js\").FrameState} frameState FrameState.\n   * @protected\n   */\n  calculateMatrices2D(frameState) {\n    const viewState = frameState.viewState;\n    const coordinateToPixelTransform = frameState.coordinateToPixelTransform;\n    const pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;\n\n    composeTransform(\n      coordinateToPixelTransform,\n      frameState.size[0] / 2,\n      frameState.size[1] / 2,\n      1 / viewState.resolution,\n      -1 / viewState.resolution,\n      -viewState.rotation,\n      -viewState.center[0],\n      -viewState.center[1]\n    );\n\n    makeInverse(pixelToCoordinateTransform, coordinateToPixelTransform);\n  }\n\n  /**\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../Map.js\").FrameState} frameState FrameState.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {boolean} checkWrapped Check for wrapped geometries.\n   * @param {import(\"./vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {S} thisArg Value to use as `this` when executing `callback`.\n   * @param {function(this: U, import(\"../layer/Layer.js\").default): boolean} layerFilter Layer filter\n   *     function, only layers which are visible and for which this function\n   *     returns `true` will be tested for features.  By default, all visible\n   *     layers will be tested.\n   * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.\n   * @return {T|undefined} Callback result.\n   * @template S,T,U\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    checkWrapped,\n    callback,\n    thisArg,\n    layerFilter,\n    thisArg2\n  ) {\n    let result;\n    const viewState = frameState.viewState;\n\n    /**\n     * @param {boolean} managed Managed layer.\n     * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n     * @param {import(\"../layer/Layer.js\").default} layer Layer.\n     * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n     * @return {T|undefined} Callback result.\n     */\n    function forEachFeatureAtCoordinate(managed, feature, layer, geometry) {\n      return callback.call(thisArg, feature, managed ? layer : null, geometry);\n    }\n\n    const projection = viewState.projection;\n\n    const translatedCoordinate = wrapX(coordinate.slice(), projection);\n    const offsets = [[0, 0]];\n    if (projection.canWrapX() && checkWrapped) {\n      const projectionExtent = projection.getExtent();\n      const worldWidth = getWidth(projectionExtent);\n      offsets.push([-worldWidth, 0], [worldWidth, 0]);\n    }\n\n    const layerStates = frameState.layerStatesArray;\n    const numLayers = layerStates.length;\n\n    const matches = /** @type {Array<HitMatch<T>>} */ ([]);\n    const tmpCoord = [];\n    for (let i = 0; i < offsets.length; i++) {\n      for (let j = numLayers - 1; j >= 0; --j) {\n        const layerState = layerStates[j];\n        const layer = layerState.layer;\n        if (\n          layer.hasRenderer() &&\n          inView(layerState, viewState) &&\n          layerFilter.call(thisArg2, layer)\n        ) {\n          const layerRenderer = layer.getRenderer();\n          const source = layer.getSource();\n          if (layerRenderer && source) {\n            const coordinates = source.getWrapX()\n              ? translatedCoordinate\n              : coordinate;\n            const callback = forEachFeatureAtCoordinate.bind(\n              null,\n              layerState.managed\n            );\n            tmpCoord[0] = coordinates[0] + offsets[i][0];\n            tmpCoord[1] = coordinates[1] + offsets[i][1];\n            result = layerRenderer.forEachFeatureAtCoordinate(\n              tmpCoord,\n              frameState,\n              hitTolerance,\n              callback,\n              matches\n            );\n          }\n          if (result) {\n            return result;\n          }\n        }\n      }\n    }\n    if (matches.length === 0) {\n      return undefined;\n    }\n    const order = 1 / matches.length;\n    matches.forEach((m, i) => (m.distanceSq += i * order));\n    matches.sort((a, b) => a.distanceSq - b.distanceSq);\n    matches.some((m) => {\n      return (result = m.callback(m.feature, m.layer, m.geometry));\n    });\n    return result;\n  }\n\n  /**\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../Map.js\").FrameState} frameState FrameState.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {boolean} checkWrapped Check for wrapped geometries.\n   * @param {function(this: U, import(\"../layer/Layer.js\").default): boolean} layerFilter Layer filter\n   *     function, only layers which are visible and for which this function\n   *     returns `true` will be tested for features.  By default, all visible\n   *     layers will be tested.\n   * @param {U} thisArg Value to use as `this` when executing `layerFilter`.\n   * @return {boolean} Is there a feature at the given coordinate?\n   * @template U\n   */\n  hasFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    checkWrapped,\n    layerFilter,\n    thisArg\n  ) {\n    const hasFeature = this.forEachFeatureAtCoordinate(\n      coordinate,\n      frameState,\n      hitTolerance,\n      checkWrapped,\n      TRUE,\n      this,\n      layerFilter,\n      thisArg\n    );\n\n    return hasFeature !== undefined;\n  }\n\n  /**\n   * @return {import(\"../Map.js\").default} Map.\n   */\n  getMap() {\n    return this.map_;\n  }\n\n  /**\n   * Render.\n   * @abstract\n   * @param {?import(\"../Map.js\").FrameState} frameState Frame state.\n   */\n  renderFrame(frameState) {\n    abstract();\n  }\n\n  /**\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  scheduleExpireIconCache(frameState) {\n    if (iconImageCache.canExpireCache()) {\n      frameState.postRenderFunctions.push(expireIconCache);\n    }\n  }\n}\n\n/**\n * @param {import(\"../Map.js\").default} map Map.\n * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n */\nfunction expireIconCache(map, frameState) {\n  iconImageCache.expire();\n}\n\nexport default MapRenderer;\n","/**\n * @module ol/renderer/Composite\n */\nimport MapRenderer from './Map.js';\nimport ObjectEventType from '../ObjectEventType.js';\nimport RenderEvent from '../render/Event.js';\nimport RenderEventType from '../render/EventType.js';\nimport {CLASS_UNSELECTABLE} from '../css.js';\nimport {checkedFonts} from '../render/canvas.js';\nimport {inView} from '../layer/Layer.js';\nimport {listen, unlistenByKey} from '../events.js';\nimport {replaceChildren} from '../dom.js';\n\n/**\n * @classdesc\n * Canvas map renderer.\n * @api\n */\nclass CompositeMapRenderer extends MapRenderer {\n  /**\n   * @param {import(\"../Map.js\").default} map Map.\n   */\n  constructor(map) {\n    super(map);\n\n    /**\n     * @type {import(\"../events.js\").EventsKey}\n     */\n    this.fontChangeListenerKey_ = listen(\n      checkedFonts,\n      ObjectEventType.PROPERTYCHANGE,\n      map.redrawText.bind(map)\n    );\n\n    /**\n     * @private\n     * @type {HTMLDivElement}\n     */\n    this.element_ = document.createElement('div');\n    const style = this.element_.style;\n    style.position = 'absolute';\n    style.width = '100%';\n    style.height = '100%';\n    style.zIndex = '0';\n\n    this.element_.className = CLASS_UNSELECTABLE + ' ol-layers';\n\n    const container = map.getViewport();\n    container.insertBefore(this.element_, container.firstChild || null);\n\n    /**\n     * @private\n     * @type {Array<HTMLElement>}\n     */\n    this.children_ = [];\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.renderedVisible_ = true;\n  }\n\n  /**\n   * @param {import(\"../render/EventType.js\").default} type Event type.\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   */\n  dispatchRenderEvent(type, frameState) {\n    const map = this.getMap();\n    if (map.hasListener(type)) {\n      const event = new RenderEvent(type, undefined, frameState);\n      map.dispatchEvent(event);\n    }\n  }\n\n  disposeInternal() {\n    unlistenByKey(this.fontChangeListenerKey_);\n    this.element_.parentNode.removeChild(this.element_);\n    super.disposeInternal();\n  }\n\n  /**\n   * Render.\n   * @param {?import(\"../Map.js\").FrameState} frameState Frame state.\n   */\n  renderFrame(frameState) {\n    if (!frameState) {\n      if (this.renderedVisible_) {\n        this.element_.style.display = 'none';\n        this.renderedVisible_ = false;\n      }\n      return;\n    }\n\n    this.calculateMatrices2D(frameState);\n    this.dispatchRenderEvent(RenderEventType.PRECOMPOSE, frameState);\n\n    const layerStatesArray = frameState.layerStatesArray.sort(function (a, b) {\n      return a.zIndex - b.zIndex;\n    });\n    const viewState = frameState.viewState;\n\n    this.children_.length = 0;\n    /**\n     * @type {Array<import(\"../layer/BaseVector.js\").default>}\n     */\n    const declutterLayers = [];\n    let previousElement = null;\n    for (let i = 0, ii = layerStatesArray.length; i < ii; ++i) {\n      const layerState = layerStatesArray[i];\n      frameState.layerIndex = i;\n\n      const layer = layerState.layer;\n      const sourceState = layer.getSourceState();\n      if (\n        !inView(layerState, viewState) ||\n        (sourceState != 'ready' && sourceState != 'undefined')\n      ) {\n        layer.unrender();\n        continue;\n      }\n\n      const element = layer.render(frameState, previousElement);\n      if (!element) {\n        continue;\n      }\n      if (element !== previousElement) {\n        this.children_.push(element);\n        previousElement = element;\n      }\n      if ('getDeclutter' in layer) {\n        declutterLayers.push(\n          /** @type {import(\"../layer/BaseVector.js\").default} */ (layer)\n        );\n      }\n    }\n    for (let i = declutterLayers.length - 1; i >= 0; --i) {\n      declutterLayers[i].renderDeclutter(frameState);\n    }\n\n    replaceChildren(this.element_, this.children_);\n\n    this.dispatchRenderEvent(RenderEventType.POSTCOMPOSE, frameState);\n\n    if (!this.renderedVisible_) {\n      this.element_.style.display = '';\n      this.renderedVisible_ = true;\n    }\n\n    this.scheduleExpireIconCache(frameState);\n  }\n}\n\nexport default CompositeMapRenderer;\n","/**\n * @module ol/renderer/Layer\n */\nimport EventType from '../events/EventType.js';\nimport ImageState from '../ImageState.js';\nimport Observable from '../Observable.js';\nimport {abstract} from '../util.js';\n\n/**\n * @template {import(\"../layer/Layer.js\").default} LayerType\n */\nclass LayerRenderer extends Observable {\n  /**\n   * @param {LayerType} layer Layer.\n   */\n  constructor(layer) {\n    super();\n\n    /**\n     * The renderer is initialized and ready to render.\n     * @type {boolean}\n     */\n    this.ready = true;\n\n    /** @private */\n    this.boundHandleImageChange_ = this.handleImageChange_.bind(this);\n\n    /**\n     * @protected\n     * @type {LayerType}\n     */\n    this.layer_ = layer;\n\n    /**\n     * @type {import(\"../render/canvas/ExecutorGroup\").default}\n     */\n    this.declutterExecutorGroup = null;\n  }\n\n  /**\n   * Asynchronous layer level hit detection.\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../Feature\").FeatureLike>>} Promise that resolves with\n   * an array of features.\n   */\n  getFeatures(pixel) {\n    return abstract();\n  }\n\n  /**\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\n   */\n  getData(pixel) {\n    return null;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @abstract\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    return abstract();\n  }\n\n  /**\n   * Render the layer.\n   * @abstract\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState, target) {\n    return abstract();\n  }\n\n  /**\n   * @param {Object<number, Object<string, import(\"../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n   * @param {number} zoom Zoom level.\n   * @param {import(\"../Tile.js\").default} tile Tile.\n   * @return {boolean|void} If `false`, the tile will not be considered loaded.\n   */\n  loadedTileCallback(tiles, zoom, tile) {\n    if (!tiles[zoom]) {\n      tiles[zoom] = {};\n    }\n    tiles[zoom][tile.tileCoord.toString()] = tile;\n    return undefined;\n  }\n\n  /**\n   * Create a function that adds loaded tiles to the tile lookup.\n   * @param {import(\"../source/Tile.js\").default} source Tile source.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection of the tiles.\n   * @param {Object<number, Object<string, import(\"../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n   * @return {function(number, import(\"../TileRange.js\").default):boolean} A function that can be\n   *     called with a zoom level and a tile range to add loaded tiles to the lookup.\n   * @protected\n   */\n  createLoadedTileFinder(source, projection, tiles) {\n    return (\n      /**\n       * @param {number} zoom Zoom level.\n       * @param {import(\"../TileRange.js\").default} tileRange Tile range.\n       * @return {boolean} The tile range is fully loaded.\n       */\n      (zoom, tileRange) => {\n        const callback = this.loadedTileCallback.bind(this, tiles, zoom);\n        return source.forEachLoadedTile(projection, zoom, tileRange, callback);\n      }\n    );\n  }\n  /**\n   * @abstract\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"./vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"./Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches\n  ) {\n    return undefined;\n  }\n\n  /**\n   * @return {LayerType} Layer.\n   */\n  getLayer() {\n    return this.layer_;\n  }\n\n  /**\n   * Perform action necessary to get the layer rendered after new fonts have loaded\n   * @abstract\n   */\n  handleFontsChanged() {}\n\n  /**\n   * Handle changes in image state.\n   * @param {import(\"../events/Event.js\").default} event Image change event.\n   * @private\n   */\n  handleImageChange_(event) {\n    const image = /** @type {import(\"../Image.js\").default} */ (event.target);\n    if (image.getState() === ImageState.LOADED) {\n      this.renderIfReadyAndVisible();\n    }\n  }\n\n  /**\n   * Load the image if not already loaded, and register the image change\n   * listener if needed.\n   * @param {import(\"../ImageBase.js\").default} image Image.\n   * @return {boolean} `true` if the image is already loaded, `false` otherwise.\n   * @protected\n   */\n  loadImage(image) {\n    let imageState = image.getState();\n    if (imageState != ImageState.LOADED && imageState != ImageState.ERROR) {\n      image.addEventListener(EventType.CHANGE, this.boundHandleImageChange_);\n    }\n    if (imageState == ImageState.IDLE) {\n      image.load();\n      imageState = image.getState();\n    }\n    return imageState == ImageState.LOADED;\n  }\n\n  /**\n   * @protected\n   */\n  renderIfReadyAndVisible() {\n    const layer = this.getLayer();\n    if (layer && layer.getVisible() && layer.getSourceState() === 'ready') {\n      layer.changed();\n    }\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    delete this.layer_;\n    super.disposeInternal();\n  }\n}\n\nexport default LayerRenderer;\n","/**\n * @module ol/renderer/canvas/ImageLayer\n */\nimport CanvasLayerRenderer from './Layer.js';\nimport ImageState from '../../ImageState.js';\nimport ViewHint from '../../ViewHint.js';\nimport {\n  apply as applyTransform,\n  compose as composeTransform,\n  makeInverse,\n  toString as toTransformString,\n} from '../../transform.js';\nimport {\n  containsCoordinate,\n  containsExtent,\n  getHeight,\n  getIntersection,\n  getWidth,\n  intersects as intersectsExtent,\n  isEmpty,\n} from '../../extent.js';\nimport {fromUserExtent} from '../../proj.js';\n\n/**\n * @classdesc\n * Canvas renderer for image layers.\n * @api\n */\nclass CanvasImageLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {import(\"../../layer/Image.js\").default} imageLayer Image layer.\n   */\n  constructor(imageLayer) {\n    super(imageLayer);\n\n    /**\n     * @protected\n     * @type {?import(\"../../ImageBase.js\").default}\n     */\n    this.image_ = null;\n  }\n\n  /**\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   */\n  getImage() {\n    return this.image_ ? this.image_.getImage() : null;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const viewResolution = viewState.resolution;\n\n    const imageSource = this.getLayer().getSource();\n\n    const hints = frameState.viewHints;\n\n    let renderedExtent = frameState.extent;\n    if (layerState.extent !== undefined) {\n      renderedExtent = getIntersection(\n        renderedExtent,\n        fromUserExtent(layerState.extent, viewState.projection)\n      );\n    }\n\n    if (\n      !hints[ViewHint.ANIMATING] &&\n      !hints[ViewHint.INTERACTING] &&\n      !isEmpty(renderedExtent)\n    ) {\n      if (imageSource) {\n        const projection = viewState.projection;\n        const image = imageSource.getImage(\n          renderedExtent,\n          viewResolution,\n          pixelRatio,\n          projection\n        );\n        if (image) {\n          if (this.loadImage(image)) {\n            this.image_ = image;\n          } else if (image.getState() === ImageState.EMPTY) {\n            this.image_ = null;\n          }\n        }\n      } else {\n        this.image_ = null;\n      }\n    }\n\n    return !!this.image_;\n  }\n\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray} Data at the pixel location.\n   */\n  getData(pixel) {\n    const frameState = this.frameState;\n    if (!frameState) {\n      return null;\n    }\n\n    const layer = this.getLayer();\n    const coordinate = applyTransform(\n      frameState.pixelToCoordinateTransform,\n      pixel.slice()\n    );\n\n    const layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (!containsCoordinate(layerExtent, coordinate)) {\n        return null;\n      }\n    }\n\n    const imageExtent = this.image_.getExtent();\n    const img = this.getImage();\n\n    const imageMapWidth = getWidth(imageExtent);\n    const col = Math.floor(\n      img.width * ((coordinate[0] - imageExtent[0]) / imageMapWidth)\n    );\n    if (col < 0 || col >= img.width) {\n      return null;\n    }\n\n    const imageMapHeight = getHeight(imageExtent);\n    const row = Math.floor(\n      img.height * ((imageExtent[3] - coordinate[1]) / imageMapHeight)\n    );\n    if (row < 0 || row >= img.height) {\n      return null;\n    }\n\n    return this.getImageData(img, col, row);\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState, target) {\n    const image = this.image_;\n    const imageExtent = image.getExtent();\n    const imageResolution = image.getResolution();\n    const imagePixelRatio = image.getPixelRatio();\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const viewCenter = viewState.center;\n    const viewResolution = viewState.resolution;\n    const scale =\n      (pixelRatio * imageResolution) / (viewResolution * imagePixelRatio);\n\n    const extent = frameState.extent;\n    const resolution = viewState.resolution;\n    const rotation = viewState.rotation;\n    // desired dimensions of the canvas in pixels\n    const width = Math.round((getWidth(extent) / resolution) * pixelRatio);\n    const height = Math.round((getHeight(extent) / resolution) * pixelRatio);\n\n    // set forward and inverse pixel transforms\n    composeTransform(\n      this.pixelTransform,\n      frameState.size[0] / 2,\n      frameState.size[1] / 2,\n      1 / pixelRatio,\n      1 / pixelRatio,\n      rotation,\n      -width / 2,\n      -height / 2\n    );\n    makeInverse(this.inversePixelTransform, this.pixelTransform);\n\n    const canvasTransform = toTransformString(this.pixelTransform);\n\n    this.useContainer(target, canvasTransform, this.getBackground(frameState));\n\n    const context = this.context;\n    const canvas = context.canvas;\n\n    if (canvas.width != width || canvas.height != height) {\n      canvas.width = width;\n      canvas.height = height;\n    } else if (!this.containerReused) {\n      context.clearRect(0, 0, width, height);\n    }\n\n    // clipped rendering if layer extent is set\n    let clipped = false;\n    let render = true;\n    if (layerState.extent) {\n      const layerExtent = fromUserExtent(\n        layerState.extent,\n        viewState.projection\n      );\n      render = intersectsExtent(layerExtent, frameState.extent);\n      clipped = render && !containsExtent(layerExtent, frameState.extent);\n      if (clipped) {\n        this.clipUnrotated(context, frameState, layerExtent);\n      }\n    }\n\n    const img = this.getImage();\n\n    const transform = composeTransform(\n      this.tempTransform,\n      width / 2,\n      height / 2,\n      scale,\n      scale,\n      0,\n      (imagePixelRatio * (imageExtent[0] - viewCenter[0])) / imageResolution,\n      (imagePixelRatio * (viewCenter[1] - imageExtent[3])) / imageResolution\n    );\n\n    this.renderedResolution = (imageResolution * pixelRatio) / imagePixelRatio;\n\n    const dw = img.width * transform[0];\n    const dh = img.height * transform[3];\n\n    if (!this.getLayer().getSource().getInterpolate()) {\n      context.imageSmoothingEnabled = false;\n    }\n\n    this.preRender(context, frameState);\n    if (render && dw >= 0.5 && dh >= 0.5) {\n      const dx = transform[4];\n      const dy = transform[5];\n      const opacity = layerState.opacity;\n      let previousAlpha;\n      if (opacity !== 1) {\n        previousAlpha = context.globalAlpha;\n        context.globalAlpha = opacity;\n      }\n      context.drawImage(img, 0, 0, +img.width, +img.height, dx, dy, dw, dh);\n      if (opacity !== 1) {\n        context.globalAlpha = previousAlpha;\n      }\n    }\n    this.postRender(context, frameState);\n\n    if (clipped) {\n      context.restore();\n    }\n    context.imageSmoothingEnabled = true;\n\n    if (canvasTransform !== canvas.style.transform) {\n      canvas.style.transform = canvasTransform;\n    }\n\n    return this.container;\n  }\n}\n\nexport default CanvasImageLayerRenderer;\n","/**\n * @module ol/renderer/canvas/Layer\n */\nimport LayerRenderer from '../Layer.js';\nimport RenderEvent from '../../render/Event.js';\nimport RenderEventType from '../../render/EventType.js';\nimport {\n  apply as applyTransform,\n  compose as composeTransform,\n  create as createTransform,\n} from '../../transform.js';\nimport {asArray} from '../../color.js';\nimport {createCanvasContext2D} from '../../dom.js';\nimport {equals} from '../../array.js';\nimport {\n  getBottomLeft,\n  getBottomRight,\n  getTopLeft,\n  getTopRight,\n} from '../../extent.js';\n\n/**\n * @type {Array<HTMLCanvasElement>}\n */\nexport const canvasPool = [];\n\n/**\n * @type {CanvasRenderingContext2D}\n */\nlet pixelContext = null;\n\nfunction createPixelContext() {\n  pixelContext = createCanvasContext2D(1, 1, undefined, {\n    willReadFrequently: true,\n  });\n}\n\n/**\n * @abstract\n * @template {import(\"../../layer/Layer.js\").default} LayerType\n * @extends {LayerRenderer<LayerType>}\n */\nclass CanvasLayerRenderer extends LayerRenderer {\n  /**\n   * @param {LayerType} layer Layer.\n   */\n  constructor(layer) {\n    super(layer);\n\n    /**\n     * @protected\n     * @type {HTMLElement}\n     */\n    this.container = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedResolution;\n\n    /**\n     * A temporary transform.  The values in this transform should only be used in a\n     * function that sets the values.\n     * @protected\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.tempTransform = createTransform();\n\n    /**\n     * The transform for rendered pixels to viewport CSS pixels.  This transform must\n     * be set when rendering a frame and may be used by other functions after rendering.\n     * @protected\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.pixelTransform = createTransform();\n\n    /**\n     * The transform for viewport CSS pixels to rendered pixels.  This transform must\n     * be set when rendering a frame and may be used by other functions after rendering.\n     * @protected\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.inversePixelTransform = createTransform();\n\n    /**\n     * @type {CanvasRenderingContext2D}\n     */\n    this.context = null;\n\n    /**\n     * @type {boolean}\n     */\n    this.containerReused = false;\n\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n    this.pixelContext_ = null;\n\n    /**\n     * @protected\n     * @type {import(\"../../Map.js\").FrameState|null}\n     */\n    this.frameState = null;\n  }\n\n  /**\n   * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.\n   * @param {number} col The column index.\n   * @param {number} row The row index.\n   * @return {Uint8ClampedArray|null} The image data.\n   */\n  getImageData(image, col, row) {\n    if (!pixelContext) {\n      createPixelContext();\n    }\n    pixelContext.clearRect(0, 0, 1, 1);\n\n    let data;\n    try {\n      pixelContext.drawImage(image, col, row, 1, 1, 0, 0, 1, 1);\n      data = pixelContext.getImageData(0, 0, 1, 1).data;\n    } catch (err) {\n      pixelContext = null;\n      return null;\n    }\n    return data;\n  }\n\n  /**\n   * @param {import('../../Map.js').FrameState} frameState Frame state.\n   * @return {string} Background color.\n   */\n  getBackground(frameState) {\n    const layer = this.getLayer();\n    let background = layer.getBackground();\n    if (typeof background === 'function') {\n      background = background(frameState.viewState.resolution);\n    }\n    return background || undefined;\n  }\n\n  /**\n   * Get a rendering container from an existing target, if compatible.\n   * @param {HTMLElement} target Potential render target.\n   * @param {string} transform CSS Transform.\n   * @param {string} [backgroundColor] Background color.\n   */\n  useContainer(target, transform, backgroundColor) {\n    const layerClassName = this.getLayer().getClassName();\n    let container, context;\n    if (\n      target &&\n      target.className === layerClassName &&\n      (!backgroundColor ||\n        (target &&\n          target.style.backgroundColor &&\n          equals(\n            asArray(target.style.backgroundColor),\n            asArray(backgroundColor)\n          )))\n    ) {\n      const canvas = target.firstElementChild;\n      if (canvas instanceof HTMLCanvasElement) {\n        context = canvas.getContext('2d');\n      }\n    }\n    if (context && context.canvas.style.transform === transform) {\n      // Container of the previous layer renderer can be used.\n      this.container = target;\n      this.context = context;\n      this.containerReused = true;\n    } else if (this.containerReused) {\n      // Previously reused container cannot be used any more.\n      this.container = null;\n      this.context = null;\n      this.containerReused = false;\n    }\n    if (!this.container) {\n      container = document.createElement('div');\n      container.className = layerClassName;\n      let style = container.style;\n      style.position = 'absolute';\n      style.width = '100%';\n      style.height = '100%';\n      context = createCanvasContext2D();\n      const canvas = context.canvas;\n      container.appendChild(canvas);\n      style = canvas.style;\n      style.position = 'absolute';\n      style.left = '0';\n      style.transformOrigin = 'top left';\n      this.container = container;\n      this.context = context;\n    }\n    if (\n      !this.containerReused &&\n      backgroundColor &&\n      !this.container.style.backgroundColor\n    ) {\n      this.container.style.backgroundColor = backgroundColor;\n    }\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../extent.js\").Extent} extent Clip extent.\n   * @protected\n   */\n  clipUnrotated(context, frameState, extent) {\n    const topLeft = getTopLeft(extent);\n    const topRight = getTopRight(extent);\n    const bottomRight = getBottomRight(extent);\n    const bottomLeft = getBottomLeft(extent);\n\n    applyTransform(frameState.coordinateToPixelTransform, topLeft);\n    applyTransform(frameState.coordinateToPixelTransform, topRight);\n    applyTransform(frameState.coordinateToPixelTransform, bottomRight);\n    applyTransform(frameState.coordinateToPixelTransform, bottomLeft);\n\n    const inverted = this.inversePixelTransform;\n    applyTransform(inverted, topLeft);\n    applyTransform(inverted, topRight);\n    applyTransform(inverted, bottomRight);\n    applyTransform(inverted, bottomLeft);\n\n    context.save();\n    context.beginPath();\n    context.moveTo(Math.round(topLeft[0]), Math.round(topLeft[1]));\n    context.lineTo(Math.round(topRight[0]), Math.round(topRight[1]));\n    context.lineTo(Math.round(bottomRight[0]), Math.round(bottomRight[1]));\n    context.lineTo(Math.round(bottomLeft[0]), Math.round(bottomLeft[1]));\n    context.clip();\n  }\n\n  /**\n   * @param {import(\"../../render/EventType.js\").default} type Event type.\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @private\n   */\n  dispatchRenderEvent_(type, context, frameState) {\n    const layer = this.getLayer();\n    if (layer.hasListener(type)) {\n      const event = new RenderEvent(\n        type,\n        this.inversePixelTransform,\n        frameState,\n        context\n      );\n      layer.dispatchEvent(event);\n    }\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  preRender(context, frameState) {\n    this.frameState = frameState;\n    this.dispatchRenderEvent_(RenderEventType.PRERENDER, context, frameState);\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  postRender(context, frameState) {\n    this.dispatchRenderEvent_(RenderEventType.POSTRENDER, context, frameState);\n  }\n\n  /**\n   * Creates a transform for rendering to an element that will be rotated after rendering.\n   * @param {import(\"../../coordinate.js\").Coordinate} center Center.\n   * @param {number} resolution Resolution.\n   * @param {number} rotation Rotation.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {number} width Width of the rendered element (in pixels).\n   * @param {number} height Height of the rendered element (in pixels).\n   * @param {number} offsetX Offset on the x-axis in view coordinates.\n   * @protected\n   * @return {!import(\"../../transform.js\").Transform} Transform.\n   */\n  getRenderTransform(\n    center,\n    resolution,\n    rotation,\n    pixelRatio,\n    width,\n    height,\n    offsetX\n  ) {\n    const dx1 = width / 2;\n    const dy1 = height / 2;\n    const sx = pixelRatio / resolution;\n    const sy = -sx;\n    const dx2 = -center[0] + offsetX;\n    const dy2 = -center[1];\n    return composeTransform(\n      this.tempTransform,\n      dx1,\n      dy1,\n      sx,\n      sy,\n      -rotation,\n      dx2,\n      dy2\n    );\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    delete this.frameState;\n    super.disposeInternal();\n  }\n}\n\nexport default CanvasLayerRenderer;\n","/**\n * @module ol/renderer/canvas/TileLayer\n */\nimport CanvasLayerRenderer from './Layer.js';\nimport ImageTile from '../../ImageTile.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport {\n  apply as applyTransform,\n  compose as composeTransform,\n  makeInverse,\n  toString as toTransformString,\n} from '../../transform.js';\nimport {ascending} from '../../array.js';\nimport {\n  containsCoordinate,\n  createEmpty,\n  equals,\n  getHeight,\n  getIntersection,\n  getRotatedViewport,\n  getTopLeft,\n  getWidth,\n  intersects,\n} from '../../extent.js';\nimport {fromUserExtent} from '../../proj.js';\nimport {getUid} from '../../util.js';\nimport {toSize} from '../../size.js';\n\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n * @template {import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default} [LayerType=import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default]\n * @extends {CanvasLayerRenderer<LayerType>}\n */\nclass CanvasTileLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   */\n  constructor(tileLayer) {\n    super(tileLayer);\n\n    /**\n     * Rendered extent has changed since the previous `renderFrame()` call\n     * @type {boolean}\n     */\n    this.extentChanged = true;\n\n    /**\n     * @private\n     * @type {?import(\"../../extent.js\").Extent}\n     */\n    this.renderedExtent_ = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedPixelRatio;\n\n    /**\n     * @protected\n     * @type {import(\"../../proj/Projection.js\").default}\n     */\n    this.renderedProjection = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedRevision;\n\n    /**\n     * @protected\n     * @type {!Array<import(\"../../Tile.js\").default>}\n     */\n    this.renderedTiles = [];\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.newTiles_ = false;\n\n    /**\n     * @protected\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.tmpExtent = createEmpty();\n\n    /**\n     * @private\n     * @type {import(\"../../TileRange.js\").default}\n     */\n    this.tmpTileRange_ = new TileRange(0, 0, 0, 0);\n  }\n\n  /**\n   * @protected\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {boolean} Tile is drawable.\n   */\n  isDrawableTile(tile) {\n    const tileLayer = this.getLayer();\n    const tileState = tile.getState();\n    const useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();\n    return (\n      tileState == TileState.LOADED ||\n      tileState == TileState.EMPTY ||\n      (tileState == TileState.ERROR && !useInterimTilesOnError)\n    );\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {!import(\"../../Tile.js\").default} Tile.\n   */\n  getTile(z, x, y, frameState) {\n    const pixelRatio = frameState.pixelRatio;\n    const projection = frameState.viewState.projection;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    let tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n    if (tile.getState() == TileState.ERROR) {\n      if (tileLayer.getUseInterimTilesOnError() && tileLayer.getPreload() > 0) {\n        // Preloaded tiles for lower resolutions might have finished loading.\n        this.newTiles_ = true;\n      }\n    }\n    if (!this.isDrawableTile(tile)) {\n      tile = tile.getInterimTile();\n    }\n    return tile;\n  }\n\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray} Data at the pixel location.\n   */\n  getData(pixel) {\n    const frameState = this.frameState;\n    if (!frameState) {\n      return null;\n    }\n\n    const layer = this.getLayer();\n    const coordinate = applyTransform(\n      frameState.pixelToCoordinateTransform,\n      pixel.slice()\n    );\n\n    const layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (!containsCoordinate(layerExtent, coordinate)) {\n        return null;\n      }\n    }\n\n    const pixelRatio = frameState.pixelRatio;\n    const projection = frameState.viewState.projection;\n    const viewState = frameState.viewState;\n    const source = layer.getRenderSource();\n    const tileGrid = source.getTileGridForProjection(viewState.projection);\n    const tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);\n\n    for (\n      let z = tileGrid.getZForResolution(viewState.resolution);\n      z >= tileGrid.getMinZoom();\n      --z\n    ) {\n      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n      const tile = source.getTile(\n        z,\n        tileCoord[1],\n        tileCoord[2],\n        pixelRatio,\n        projection\n      );\n      if (\n        !(tile instanceof ImageTile || tile instanceof ReprojTile) ||\n        (tile instanceof ReprojTile && tile.getState() === TileState.EMPTY)\n      ) {\n        return null;\n      }\n\n      if (tile.getState() !== TileState.LOADED) {\n        continue;\n      }\n\n      const tileOrigin = tileGrid.getOrigin(z);\n      const tileSize = toSize(tileGrid.getTileSize(z));\n      const tileResolution = tileGrid.getResolution(z);\n\n      const col = Math.floor(\n        tilePixelRatio *\n          ((coordinate[0] - tileOrigin[0]) / tileResolution -\n            tileCoord[1] * tileSize[0])\n      );\n\n      const row = Math.floor(\n        tilePixelRatio *\n          ((tileOrigin[1] - coordinate[1]) / tileResolution -\n            tileCoord[2] * tileSize[1])\n      );\n\n      const gutter = Math.round(\n        tilePixelRatio * source.getGutterForProjection(viewState.projection)\n      );\n\n      return this.getImageData(tile.getImage(), col + gutter, row + gutter);\n    }\n\n    return null;\n  }\n\n  /**\n   * @param {Object<number, Object<string, import(\"../../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n   * @param {number} zoom Zoom level.\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {boolean|void} If `false`, the tile will not be considered loaded.\n   */\n  loadedTileCallback(tiles, zoom, tile) {\n    if (this.isDrawableTile(tile)) {\n      return super.loadedTileCallback(tiles, zoom, tile);\n    }\n    return false;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    return !!this.getLayer().getSource();\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState, target) {\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const viewResolution = viewState.resolution;\n    const viewCenter = viewState.center;\n    const rotation = viewState.rotation;\n    const pixelRatio = frameState.pixelRatio;\n\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const sourceRevision = tileSource.getRevision();\n    const tileGrid = tileSource.getTileGridForProjection(projection);\n    const z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);\n    const tileResolution = tileGrid.getResolution(z);\n\n    let extent = frameState.extent;\n    const resolution = frameState.viewState.resolution;\n    const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n    // desired dimensions of the canvas in pixels\n    const width = Math.round((getWidth(extent) / resolution) * pixelRatio);\n    const height = Math.round((getHeight(extent) / resolution) * pixelRatio);\n\n    const layerExtent =\n      layerState.extent && fromUserExtent(layerState.extent, projection);\n    if (layerExtent) {\n      extent = getIntersection(\n        extent,\n        fromUserExtent(layerState.extent, projection)\n      );\n    }\n\n    const dx = (tileResolution * width) / 2 / tilePixelRatio;\n    const dy = (tileResolution * height) / 2 / tilePixelRatio;\n    const canvasExtent = [\n      viewCenter[0] - dx,\n      viewCenter[1] - dy,\n      viewCenter[0] + dx,\n      viewCenter[1] + dy,\n    ];\n\n    const tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\n\n    /**\n     * @type {Object<number, Object<string, import(\"../../Tile.js\").default>>}\n     */\n    const tilesToDrawByZ = {};\n    tilesToDrawByZ[z] = {};\n\n    const findLoadedTiles = this.createLoadedTileFinder(\n      tileSource,\n      projection,\n      tilesToDrawByZ\n    );\n\n    const tmpExtent = this.tmpExtent;\n    const tmpTileRange = this.tmpTileRange_;\n    this.newTiles_ = false;\n    const viewport = rotation\n      ? getRotatedViewport(\n          viewState.center,\n          resolution,\n          rotation,\n          frameState.size\n        )\n      : undefined;\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        if (\n          rotation &&\n          !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)\n        ) {\n          continue;\n        }\n        const tile = this.getTile(z, x, y, frameState);\n        if (this.isDrawableTile(tile)) {\n          const uid = getUid(this);\n          if (tile.getState() == TileState.LOADED) {\n            tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;\n            let inTransition = tile.inTransition(uid);\n            if (inTransition && layerState.opacity !== 1) {\n              // Skipping transition when layer is not fully opaque avoids visual artifacts.\n              tile.endTransition(uid);\n              inTransition = false;\n            }\n            if (\n              !this.newTiles_ &&\n              (inTransition || !this.renderedTiles.includes(tile))\n            ) {\n              this.newTiles_ = true;\n            }\n          }\n          if (tile.getAlpha(uid, frameState.time) === 1) {\n            // don't look for alt tiles if alpha is 1\n            continue;\n          }\n        }\n\n        const childTileRange = tileGrid.getTileCoordChildTileRange(\n          tile.tileCoord,\n          tmpTileRange,\n          tmpExtent\n        );\n\n        let covered = false;\n        if (childTileRange) {\n          covered = findLoadedTiles(z + 1, childTileRange);\n        }\n        if (!covered) {\n          tileGrid.forEachTileCoordParentTileRange(\n            tile.tileCoord,\n            findLoadedTiles,\n            tmpTileRange,\n            tmpExtent\n          );\n        }\n      }\n    }\n\n    const canvasScale =\n      ((tileResolution / viewResolution) * pixelRatio) / tilePixelRatio;\n\n    // set forward and inverse pixel transforms\n    composeTransform(\n      this.pixelTransform,\n      frameState.size[0] / 2,\n      frameState.size[1] / 2,\n      1 / pixelRatio,\n      1 / pixelRatio,\n      rotation,\n      -width / 2,\n      -height / 2\n    );\n\n    const canvasTransform = toTransformString(this.pixelTransform);\n\n    this.useContainer(target, canvasTransform, this.getBackground(frameState));\n    const context = this.context;\n    const canvas = context.canvas;\n\n    makeInverse(this.inversePixelTransform, this.pixelTransform);\n\n    // set scale transform for calculating tile positions on the canvas\n    composeTransform(\n      this.tempTransform,\n      width / 2,\n      height / 2,\n      canvasScale,\n      canvasScale,\n      0,\n      -width / 2,\n      -height / 2\n    );\n\n    if (canvas.width != width || canvas.height != height) {\n      canvas.width = width;\n      canvas.height = height;\n    } else if (!this.containerReused) {\n      context.clearRect(0, 0, width, height);\n    }\n\n    if (layerExtent) {\n      this.clipUnrotated(context, frameState, layerExtent);\n    }\n\n    if (!tileSource.getInterpolate()) {\n      context.imageSmoothingEnabled = false;\n    }\n\n    this.preRender(context, frameState);\n\n    this.renderedTiles.length = 0;\n    /** @type {Array<number>} */\n    let zs = Object.keys(tilesToDrawByZ).map(Number);\n    zs.sort(ascending);\n\n    let clips, clipZs, currentClip;\n    if (\n      layerState.opacity === 1 &&\n      (!this.containerReused ||\n        tileSource.getOpaque(frameState.viewState.projection))\n    ) {\n      zs = zs.reverse();\n    } else {\n      clips = [];\n      clipZs = [];\n    }\n    for (let i = zs.length - 1; i >= 0; --i) {\n      const currentZ = zs[i];\n      const currentTilePixelSize = tileSource.getTilePixelSize(\n        currentZ,\n        pixelRatio,\n        projection\n      );\n      const currentResolution = tileGrid.getResolution(currentZ);\n      const currentScale = currentResolution / tileResolution;\n      const dx = currentTilePixelSize[0] * currentScale * canvasScale;\n      const dy = currentTilePixelSize[1] * currentScale * canvasScale;\n      const originTileCoord = tileGrid.getTileCoordForCoordAndZ(\n        getTopLeft(canvasExtent),\n        currentZ\n      );\n      const originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);\n      const origin = applyTransform(this.tempTransform, [\n        (tilePixelRatio * (originTileExtent[0] - canvasExtent[0])) /\n          tileResolution,\n        (tilePixelRatio * (canvasExtent[3] - originTileExtent[3])) /\n          tileResolution,\n      ]);\n      const tileGutter =\n        tilePixelRatio * tileSource.getGutterForProjection(projection);\n      const tilesToDraw = tilesToDrawByZ[currentZ];\n      for (const tileCoordKey in tilesToDraw) {\n        const tile = /** @type {import(\"../../ImageTile.js\").default} */ (\n          tilesToDraw[tileCoordKey]\n        );\n        const tileCoord = tile.tileCoord;\n\n        // Calculate integer positions and sizes so that tiles align\n        const xIndex = originTileCoord[1] - tileCoord[1];\n        const nextX = Math.round(origin[0] - (xIndex - 1) * dx);\n        const yIndex = originTileCoord[2] - tileCoord[2];\n        const nextY = Math.round(origin[1] - (yIndex - 1) * dy);\n        const x = Math.round(origin[0] - xIndex * dx);\n        const y = Math.round(origin[1] - yIndex * dy);\n        const w = nextX - x;\n        const h = nextY - y;\n        const transition = z === currentZ;\n\n        const inTransition =\n          transition && tile.getAlpha(getUid(this), frameState.time) !== 1;\n        let contextSaved = false;\n        if (!inTransition) {\n          if (clips) {\n            // Clip mask for regions in this tile that already filled by a higher z tile\n            currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];\n            for (let i = 0, ii = clips.length; i < ii; ++i) {\n              if (z !== currentZ && currentZ < clipZs[i]) {\n                const clip = clips[i];\n                if (\n                  intersects(\n                    [x, y, x + w, y + h],\n                    [clip[0], clip[3], clip[4], clip[7]]\n                  )\n                ) {\n                  if (!contextSaved) {\n                    context.save();\n                    contextSaved = true;\n                  }\n                  context.beginPath();\n                  // counter-clockwise (outer ring) for current tile\n                  context.moveTo(currentClip[0], currentClip[1]);\n                  context.lineTo(currentClip[2], currentClip[3]);\n                  context.lineTo(currentClip[4], currentClip[5]);\n                  context.lineTo(currentClip[6], currentClip[7]);\n                  // clockwise (inner ring) for higher z tile\n                  context.moveTo(clip[6], clip[7]);\n                  context.lineTo(clip[4], clip[5]);\n                  context.lineTo(clip[2], clip[3]);\n                  context.lineTo(clip[0], clip[1]);\n                  context.clip();\n                }\n              }\n            }\n            clips.push(currentClip);\n            clipZs.push(currentZ);\n          } else {\n            context.clearRect(x, y, w, h);\n          }\n        }\n        this.drawTileImage(\n          tile,\n          frameState,\n          x,\n          y,\n          w,\n          h,\n          tileGutter,\n          transition\n        );\n        if (clips && !inTransition) {\n          if (contextSaved) {\n            context.restore();\n          }\n          this.renderedTiles.unshift(tile);\n        } else {\n          this.renderedTiles.push(tile);\n        }\n        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);\n      }\n    }\n\n    this.renderedRevision = sourceRevision;\n    this.renderedResolution = tileResolution;\n    this.extentChanged =\n      !this.renderedExtent_ || !equals(this.renderedExtent_, canvasExtent);\n    this.renderedExtent_ = canvasExtent;\n    this.renderedPixelRatio = pixelRatio;\n    this.renderedProjection = projection;\n\n    this.manageTilePyramid(\n      frameState,\n      tileSource,\n      tileGrid,\n      pixelRatio,\n      projection,\n      extent,\n      z,\n      tileLayer.getPreload()\n    );\n    this.scheduleExpireCache(frameState, tileSource);\n\n    this.postRender(context, frameState);\n\n    if (layerState.extent) {\n      context.restore();\n    }\n    context.imageSmoothingEnabled = true;\n\n    if (canvasTransform !== canvas.style.transform) {\n      canvas.style.transform = canvasTransform;\n    }\n\n    return this.container;\n  }\n\n  /**\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   */\n  drawTileImage(tile, frameState, x, y, w, h, gutter, transition) {\n    const image = this.getTileImage(tile);\n    if (!image) {\n      return;\n    }\n    const uid = getUid(this);\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const alpha =\n      layerState.opacity *\n      (transition ? tile.getAlpha(uid, frameState.time) : 1);\n    const alphaChanged = alpha !== this.context.globalAlpha;\n    if (alphaChanged) {\n      this.context.save();\n      this.context.globalAlpha = alpha;\n    }\n    this.context.drawImage(\n      image,\n      gutter,\n      gutter,\n      image.width - 2 * gutter,\n      image.height - 2 * gutter,\n      x,\n      y,\n      w,\n      h\n    );\n\n    if (alphaChanged) {\n      this.context.restore();\n    }\n    if (alpha !== layerState.opacity) {\n      frameState.animate = true;\n    } else if (transition) {\n      tile.endTransition(uid);\n    }\n  }\n\n  /**\n   * @return {HTMLCanvasElement} Image\n   */\n  getImage() {\n    const context = this.context;\n    return context ? context.canvas : null;\n  }\n\n  /**\n   * Get the image from a tile.\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @protected\n   */\n  getTileImage(tile) {\n    return tile.getImage();\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @protected\n   */\n  scheduleExpireCache(frameState, tileSource) {\n    if (tileSource.canExpireCache()) {\n      /**\n       * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n       * @param {import(\"../../Map.js\").default} map Map.\n       * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n       */\n      const postRenderFunction = function (tileSource, map, frameState) {\n        const tileSourceKey = getUid(tileSource);\n        if (tileSourceKey in frameState.usedTiles) {\n          tileSource.expireCache(\n            frameState.viewState.projection,\n            frameState.usedTiles[tileSourceKey]\n          );\n        }\n      }.bind(null, tileSource);\n\n      frameState.postRenderFunctions.push(\n        /** @type {import(\"../../Map.js\").PostRenderFunction} */ (\n          postRenderFunction\n        )\n      );\n    }\n  }\n\n  /**\n   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import('../../Tile.js').default} tile Tile.\n   * @protected\n   */\n  updateUsedTiles(usedTiles, tileSource, tile) {\n    // FIXME should we use tilesToDrawByZ instead?\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in usedTiles)) {\n      usedTiles[tileSourceKey] = {};\n    }\n    usedTiles[tileSourceKey][tile.getKey()] = true;\n  }\n\n  /**\n   * Manage tile pyramid.\n   * This function performs a number of functions related to the tiles at the\n   * current zoom and lower zoom levels:\n   * - registers idle tiles in frameState.wantedTiles so that they are not\n   *   discarded by the tile queue\n   * - enqueues missing tiles\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @param {import(\"../../extent.js\").Extent} extent Extent.\n   * @param {number} currentZ Current Z.\n   * @param {number} preload Load low resolution tiles up to `preload` levels.\n   * @param {function(import(\"../../Tile.js\").default):void} [tileCallback] Tile callback.\n   * @protected\n   */\n  manageTilePyramid(\n    frameState,\n    tileSource,\n    tileGrid,\n    pixelRatio,\n    projection,\n    extent,\n    currentZ,\n    preload,\n    tileCallback\n  ) {\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n    const wantedTiles = frameState.wantedTiles[tileSourceKey];\n    const tileQueue = frameState.tileQueue;\n    const minZoom = tileGrid.getMinZoom();\n    const rotation = frameState.viewState.rotation;\n    const viewport = rotation\n      ? getRotatedViewport(\n          frameState.viewState.center,\n          frameState.viewState.resolution,\n          rotation,\n          frameState.size\n        )\n      : undefined;\n    let tileCount = 0;\n    let tile, tileRange, tileResolution, x, y, z;\n    for (z = minZoom; z <= currentZ; ++z) {\n      tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);\n      tileResolution = tileGrid.getResolution(z);\n      for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          if (\n            rotation &&\n            !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)\n          ) {\n            continue;\n          }\n          if (currentZ - z <= preload) {\n            ++tileCount;\n            tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n            if (tile.getState() == TileState.IDLE) {\n              wantedTiles[tile.getKey()] = true;\n              if (!tileQueue.isKeyQueued(tile.getKey())) {\n                tileQueue.enqueue([\n                  tile,\n                  tileSourceKey,\n                  tileGrid.getTileCoordCenter(tile.tileCoord),\n                  tileResolution,\n                ]);\n              }\n            }\n            if (tileCallback !== undefined) {\n              tileCallback(tile);\n            }\n          } else {\n            tileSource.useTile(z, x, y, projection);\n          }\n        }\n      }\n    }\n    tileSource.updateCacheSize(tileCount, projection);\n  }\n}\n\nexport default CanvasTileLayerRenderer;\n","/**\n * @module ol/renderer/canvas/VectorLayer\n */\nimport CanvasBuilderGroup from '../../render/canvas/BuilderGroup.js';\nimport CanvasLayerRenderer, {canvasPool} from './Layer.js';\nimport ExecutorGroup from '../../render/canvas/ExecutorGroup.js';\nimport ViewHint from '../../ViewHint.js';\nimport {\n  HIT_DETECT_RESOLUTION,\n  createHitDetectionImageData,\n  hitDetect,\n} from '../../render/canvas/hitdetect.js';\nimport {\n  apply,\n  makeInverse,\n  makeScale,\n  toString as transformToString,\n} from '../../transform.js';\nimport {\n  buffer,\n  containsExtent,\n  createEmpty,\n  getWidth,\n  intersects as intersectsExtent,\n  wrapX as wrapExtentX,\n} from '../../extent.js';\nimport {createCanvasContext2D, releaseCanvas} from '../../dom.js';\nimport {\n  defaultOrder as defaultRenderOrder,\n  getTolerance as getRenderTolerance,\n  getSquaredTolerance as getSquaredRenderTolerance,\n  renderFeature,\n} from '../vector.js';\nimport {equals} from '../../array.js';\nimport {\n  fromUserExtent,\n  getTransformFromProjections,\n  getUserProjection,\n  toUserExtent,\n  toUserResolution,\n} from '../../proj.js';\nimport {getUid} from '../../util.js';\nimport {wrapX as wrapCoordinateX} from '../../coordinate.js';\n\n/**\n * @classdesc\n * Canvas renderer for vector layers.\n * @api\n */\nclass CanvasVectorLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {import(\"../../layer/BaseVector.js\").default} vectorLayer Vector layer.\n   */\n  constructor(vectorLayer) {\n    super(vectorLayer);\n\n    /** @private */\n    this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this);\n\n    /**\n     * @type {boolean}\n     */\n    this.animatingOrInteracting_;\n\n    /**\n     * @type {ImageData|null}\n     */\n    this.hitDetectionImageData_ = null;\n\n    /**\n     * @type {Array<import(\"../../Feature.js\").default>}\n     */\n    this.renderedFeatures_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedRevision_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedResolution_ = NaN;\n\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.renderedExtent_ = createEmpty();\n\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.wrappedRenderedExtent_ = createEmpty();\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedRotation_;\n\n    /**\n     * @private\n     * @type {import(\"../../coordinate\").Coordinate}\n     */\n    this.renderedCenter_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../../proj/Projection\").default}\n     */\n    this.renderedProjection_ = null;\n\n    /**\n     * @private\n     * @type {function(import(\"../../Feature.js\").default, import(\"../../Feature.js\").default): number|null}\n     */\n    this.renderedRenderOrder_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../../render/canvas/ExecutorGroup\").default}\n     */\n    this.replayGroup_ = null;\n\n    /**\n     * A new replay group had to be created by `prepareFrame()`\n     * @type {boolean}\n     */\n    this.replayGroupChanged = true;\n\n    /**\n     * @type {import(\"../../render/canvas/ExecutorGroup\").default}\n     */\n    this.declutterExecutorGroup = null;\n\n    /**\n     * Clipping to be performed by `renderFrame()`\n     * @type {boolean}\n     */\n    this.clipping = true;\n\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n    this.compositionContext_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.opacity_ = 1;\n  }\n\n  /**\n   * @param {ExecutorGroup} executorGroup Executor group.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"rbush\").default} [declutterTree] Declutter tree.\n   */\n  renderWorlds(executorGroup, frameState, declutterTree) {\n    const extent = frameState.extent;\n    const viewState = frameState.viewState;\n    const center = viewState.center;\n    const resolution = viewState.resolution;\n    const projection = viewState.projection;\n    const rotation = viewState.rotation;\n    const projectionExtent = projection.getExtent();\n    const vectorSource = this.getLayer().getSource();\n    const pixelRatio = frameState.pixelRatio;\n    const viewHints = frameState.viewHints;\n    const snapToPixel = !(\n      viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]\n    );\n    const context = this.compositionContext_;\n    const width = Math.round(frameState.size[0] * pixelRatio);\n    const height = Math.round(frameState.size[1] * pixelRatio);\n\n    const multiWorld = vectorSource.getWrapX() && projection.canWrapX();\n    const worldWidth = multiWorld ? getWidth(projectionExtent) : null;\n    const endWorld = multiWorld\n      ? Math.ceil((extent[2] - projectionExtent[2]) / worldWidth) + 1\n      : 1;\n    let world = multiWorld\n      ? Math.floor((extent[0] - projectionExtent[0]) / worldWidth)\n      : 0;\n    do {\n      const transform = this.getRenderTransform(\n        center,\n        resolution,\n        rotation,\n        pixelRatio,\n        width,\n        height,\n        world * worldWidth\n      );\n      executorGroup.execute(\n        context,\n        1,\n        transform,\n        rotation,\n        snapToPixel,\n        undefined,\n        declutterTree\n      );\n    } while (++world < endWorld);\n  }\n\n  setupCompositionContext_() {\n    if (this.opacity_ !== 1) {\n      const compositionContext = createCanvasContext2D(\n        this.context.canvas.width,\n        this.context.canvas.height,\n        canvasPool\n      );\n      this.compositionContext_ = compositionContext;\n    } else {\n      this.compositionContext_ = this.context;\n    }\n  }\n\n  releaseCompositionContext_() {\n    if (this.opacity_ !== 1) {\n      const alpha = this.context.globalAlpha;\n      this.context.globalAlpha = this.opacity_;\n      this.context.drawImage(this.compositionContext_.canvas, 0, 0);\n      this.context.globalAlpha = alpha;\n      releaseCanvas(this.compositionContext_);\n      canvasPool.push(this.compositionContext_.canvas);\n      this.compositionContext_ = null;\n    }\n  }\n\n  /**\n   * Render declutter items for this layer\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   */\n  renderDeclutter(frameState) {\n    if (this.declutterExecutorGroup) {\n      this.setupCompositionContext_();\n      this.renderWorlds(\n        this.declutterExecutorGroup,\n        frameState,\n        frameState.declutterTree\n      );\n      this.releaseCompositionContext_();\n    }\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState, target) {\n    const pixelRatio = frameState.pixelRatio;\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n\n    // set forward and inverse pixel transforms\n    makeScale(this.pixelTransform, 1 / pixelRatio, 1 / pixelRatio);\n    makeInverse(this.inversePixelTransform, this.pixelTransform);\n\n    const canvasTransform = transformToString(this.pixelTransform);\n\n    this.useContainer(target, canvasTransform, this.getBackground(frameState));\n    const context = this.context;\n    const canvas = context.canvas;\n\n    const replayGroup = this.replayGroup_;\n    const declutterExecutorGroup = this.declutterExecutorGroup;\n    if (\n      (!replayGroup || replayGroup.isEmpty()) &&\n      (!declutterExecutorGroup || declutterExecutorGroup.isEmpty())\n    ) {\n      return null;\n    }\n\n    // resize and clear\n    const width = Math.round(frameState.size[0] * pixelRatio);\n    const height = Math.round(frameState.size[1] * pixelRatio);\n    if (canvas.width != width || canvas.height != height) {\n      canvas.width = width;\n      canvas.height = height;\n      if (canvas.style.transform !== canvasTransform) {\n        canvas.style.transform = canvasTransform;\n      }\n    } else if (!this.containerReused) {\n      context.clearRect(0, 0, width, height);\n    }\n\n    this.preRender(context, frameState);\n\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n\n    this.opacity_ = layerState.opacity;\n    this.setupCompositionContext_();\n\n    // clipped rendering if layer extent is set\n    let clipped = false;\n    let render = true;\n    if (layerState.extent && this.clipping) {\n      const layerExtent = fromUserExtent(layerState.extent, projection);\n      render = intersectsExtent(layerExtent, frameState.extent);\n      clipped = render && !containsExtent(layerExtent, frameState.extent);\n      if (clipped) {\n        this.clipUnrotated(this.compositionContext_, frameState, layerExtent);\n      }\n    }\n\n    if (render) {\n      this.renderWorlds(replayGroup, frameState);\n    }\n\n    if (clipped) {\n      this.compositionContext_.restore();\n    }\n\n    this.releaseCompositionContext_();\n\n    this.postRender(context, frameState);\n\n    if (this.renderedRotation_ !== viewState.rotation) {\n      this.renderedRotation_ = viewState.rotation;\n      this.hitDetectionImageData_ = null;\n    }\n    return this.container;\n  }\n\n  /**\n   * Asynchronous layer level hit detection.\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../../Feature\").default>>} Promise\n   * that resolves with an array of features.\n   */\n  getFeatures(pixel) {\n    return new Promise((resolve) => {\n      if (!this.hitDetectionImageData_ && !this.animatingOrInteracting_) {\n        const size = [this.context.canvas.width, this.context.canvas.height];\n        apply(this.pixelTransform, size);\n        const center = this.renderedCenter_;\n        const resolution = this.renderedResolution_;\n        const rotation = this.renderedRotation_;\n        const projection = this.renderedProjection_;\n        const extent = this.wrappedRenderedExtent_;\n        const layer = this.getLayer();\n        const transforms = [];\n        const width = size[0] * HIT_DETECT_RESOLUTION;\n        const height = size[1] * HIT_DETECT_RESOLUTION;\n        transforms.push(\n          this.getRenderTransform(\n            center,\n            resolution,\n            rotation,\n            HIT_DETECT_RESOLUTION,\n            width,\n            height,\n            0\n          ).slice()\n        );\n        const source = layer.getSource();\n        const projectionExtent = projection.getExtent();\n        if (\n          source.getWrapX() &&\n          projection.canWrapX() &&\n          !containsExtent(projectionExtent, extent)\n        ) {\n          let startX = extent[0];\n          const worldWidth = getWidth(projectionExtent);\n          let world = 0;\n          let offsetX;\n          while (startX < projectionExtent[0]) {\n            --world;\n            offsetX = worldWidth * world;\n            transforms.push(\n              this.getRenderTransform(\n                center,\n                resolution,\n                rotation,\n                HIT_DETECT_RESOLUTION,\n                width,\n                height,\n                offsetX\n              ).slice()\n            );\n            startX += worldWidth;\n          }\n          world = 0;\n          startX = extent[2];\n          while (startX > projectionExtent[2]) {\n            ++world;\n            offsetX = worldWidth * world;\n            transforms.push(\n              this.getRenderTransform(\n                center,\n                resolution,\n                rotation,\n                HIT_DETECT_RESOLUTION,\n                width,\n                height,\n                offsetX\n              ).slice()\n            );\n            startX -= worldWidth;\n          }\n        }\n\n        this.hitDetectionImageData_ = createHitDetectionImageData(\n          size,\n          transforms,\n          this.renderedFeatures_,\n          layer.getStyleFunction(),\n          extent,\n          resolution,\n          rotation\n        );\n      }\n      resolve(\n        hitDetect(pixel, this.renderedFeatures_, this.hitDetectionImageData_)\n      );\n    });\n  }\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches\n  ) {\n    if (!this.replayGroup_) {\n      return undefined;\n    }\n    const resolution = frameState.viewState.resolution;\n    const rotation = frameState.viewState.rotation;\n    const layer = this.getLayer();\n\n    /** @type {!Object<string, import(\"../Map.js\").HitMatch<T>|true>} */\n    const features = {};\n\n    /**\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     * @param {import(\"../../geom/SimpleGeometry.js\").default} geometry Geometry.\n     * @param {number} distanceSq The squared distance to the click position\n     * @return {T|undefined} Callback result.\n     */\n    const featureCallback = function (feature, geometry, distanceSq) {\n      const key = getUid(feature);\n      const match = features[key];\n      if (!match) {\n        if (distanceSq === 0) {\n          features[key] = true;\n          return callback(feature, layer, geometry);\n        }\n        matches.push(\n          (features[key] = {\n            feature: feature,\n            layer: layer,\n            geometry: geometry,\n            distanceSq: distanceSq,\n            callback: callback,\n          })\n        );\n      } else if (match !== true && distanceSq < match.distanceSq) {\n        if (distanceSq === 0) {\n          features[key] = true;\n          matches.splice(matches.lastIndexOf(match), 1);\n          return callback(feature, layer, geometry);\n        }\n        match.geometry = geometry;\n        match.distanceSq = distanceSq;\n      }\n      return undefined;\n    };\n\n    let result;\n    const executorGroups = [this.replayGroup_];\n    if (this.declutterExecutorGroup) {\n      executorGroups.push(this.declutterExecutorGroup);\n    }\n    executorGroups.some((executorGroup) => {\n      return (result = executorGroup.forEachFeatureAtCoordinate(\n        coordinate,\n        resolution,\n        rotation,\n        hitTolerance,\n        featureCallback,\n        executorGroup === this.declutterExecutorGroup &&\n          frameState.declutterTree\n          ? frameState.declutterTree.all().map((item) => item.value)\n          : null\n      ));\n    });\n\n    return result;\n  }\n\n  /**\n   * Perform action necessary to get the layer rendered after new fonts have loaded\n   */\n  handleFontsChanged() {\n    const layer = this.getLayer();\n    if (layer.getVisible() && this.replayGroup_) {\n      layer.changed();\n    }\n  }\n\n  /**\n   * Handle changes in image style state.\n   * @param {import(\"../../events/Event.js\").default} event Image style change event.\n   * @private\n   */\n  handleStyleImageChange_(event) {\n    this.renderIfReadyAndVisible();\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    const vectorLayer = this.getLayer();\n    const vectorSource = vectorLayer.getSource();\n    if (!vectorSource) {\n      return false;\n    }\n\n    const animating = frameState.viewHints[ViewHint.ANIMATING];\n    const interacting = frameState.viewHints[ViewHint.INTERACTING];\n    const updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();\n    const updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();\n\n    if (\n      (this.ready && !updateWhileAnimating && animating) ||\n      (!updateWhileInteracting && interacting)\n    ) {\n      this.animatingOrInteracting_ = true;\n      return true;\n    }\n    this.animatingOrInteracting_ = false;\n\n    const frameStateExtent = frameState.extent;\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const resolution = viewState.resolution;\n    const pixelRatio = frameState.pixelRatio;\n    const vectorLayerRevision = vectorLayer.getRevision();\n    const vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();\n    let vectorLayerRenderOrder = vectorLayer.getRenderOrder();\n\n    if (vectorLayerRenderOrder === undefined) {\n      vectorLayerRenderOrder = defaultRenderOrder;\n    }\n\n    const center = viewState.center.slice();\n    const extent = buffer(\n      frameStateExtent,\n      vectorLayerRenderBuffer * resolution\n    );\n    const renderedExtent = extent.slice();\n    const loadExtents = [extent.slice()];\n    const projectionExtent = projection.getExtent();\n\n    if (\n      vectorSource.getWrapX() &&\n      projection.canWrapX() &&\n      !containsExtent(projectionExtent, frameState.extent)\n    ) {\n      // For the replay group, we need an extent that intersects the real world\n      // (-180° to +180°). To support geometries in a coordinate range from -540°\n      // to +540°, we add at least 1 world width on each side of the projection\n      // extent. If the viewport is wider than the world, we need to add half of\n      // the viewport width to make sure we cover the whole viewport.\n      const worldWidth = getWidth(projectionExtent);\n      const gutter = Math.max(getWidth(extent) / 2, worldWidth);\n      extent[0] = projectionExtent[0] - gutter;\n      extent[2] = projectionExtent[2] + gutter;\n      wrapCoordinateX(center, projection);\n      const loadExtent = wrapExtentX(loadExtents[0], projection);\n      // If the extent crosses the date line, we load data for both edges of the worlds\n      if (\n        loadExtent[0] < projectionExtent[0] &&\n        loadExtent[2] < projectionExtent[2]\n      ) {\n        loadExtents.push([\n          loadExtent[0] + worldWidth,\n          loadExtent[1],\n          loadExtent[2] + worldWidth,\n          loadExtent[3],\n        ]);\n      } else if (\n        loadExtent[0] > projectionExtent[0] &&\n        loadExtent[2] > projectionExtent[2]\n      ) {\n        loadExtents.push([\n          loadExtent[0] - worldWidth,\n          loadExtent[1],\n          loadExtent[2] - worldWidth,\n          loadExtent[3],\n        ]);\n      }\n    }\n\n    if (\n      this.ready &&\n      this.renderedResolution_ == resolution &&\n      this.renderedRevision_ == vectorLayerRevision &&\n      this.renderedRenderOrder_ == vectorLayerRenderOrder &&\n      containsExtent(this.wrappedRenderedExtent_, extent)\n    ) {\n      if (!equals(this.renderedExtent_, renderedExtent)) {\n        this.hitDetectionImageData_ = null;\n        this.renderedExtent_ = renderedExtent;\n      }\n      this.renderedCenter_ = center;\n      this.replayGroupChanged = false;\n      return true;\n    }\n\n    this.replayGroup_ = null;\n\n    const replayGroup = new CanvasBuilderGroup(\n      getRenderTolerance(resolution, pixelRatio),\n      extent,\n      resolution,\n      pixelRatio\n    );\n\n    let declutterBuilderGroup;\n    if (this.getLayer().getDeclutter()) {\n      declutterBuilderGroup = new CanvasBuilderGroup(\n        getRenderTolerance(resolution, pixelRatio),\n        extent,\n        resolution,\n        pixelRatio\n      );\n    }\n\n    const userProjection = getUserProjection();\n    let userTransform;\n    if (userProjection) {\n      for (let i = 0, ii = loadExtents.length; i < ii; ++i) {\n        const extent = loadExtents[i];\n        const userExtent = toUserExtent(extent, projection);\n        vectorSource.loadFeatures(\n          userExtent,\n          toUserResolution(resolution, projection),\n          userProjection\n        );\n      }\n      userTransform = getTransformFromProjections(userProjection, projection);\n    } else {\n      for (let i = 0, ii = loadExtents.length; i < ii; ++i) {\n        vectorSource.loadFeatures(loadExtents[i], resolution, projection);\n      }\n    }\n\n    const squaredTolerance = getSquaredRenderTolerance(resolution, pixelRatio);\n    let ready = true;\n    const render =\n      /**\n       * @param {import(\"../../Feature.js\").default} feature Feature.\n       */\n      (feature) => {\n        let styles;\n        const styleFunction =\n          feature.getStyleFunction() || vectorLayer.getStyleFunction();\n        if (styleFunction) {\n          styles = styleFunction(feature, resolution);\n        }\n        if (styles) {\n          const dirty = this.renderFeature(\n            feature,\n            squaredTolerance,\n            styles,\n            replayGroup,\n            userTransform,\n            declutterBuilderGroup\n          );\n          ready = ready && !dirty;\n        }\n      };\n\n    const userExtent = toUserExtent(extent, projection);\n    /** @type {Array<import(\"../../Feature.js\").default>} */\n    const features = vectorSource.getFeaturesInExtent(userExtent);\n    if (vectorLayerRenderOrder) {\n      features.sort(vectorLayerRenderOrder);\n    }\n    for (let i = 0, ii = features.length; i < ii; ++i) {\n      render(features[i]);\n    }\n    this.renderedFeatures_ = features;\n    this.ready = ready;\n\n    const replayGroupInstructions = replayGroup.finish();\n    const executorGroup = new ExecutorGroup(\n      extent,\n      resolution,\n      pixelRatio,\n      vectorSource.getOverlaps(),\n      replayGroupInstructions,\n      vectorLayer.getRenderBuffer()\n    );\n\n    if (declutterBuilderGroup) {\n      this.declutterExecutorGroup = new ExecutorGroup(\n        extent,\n        resolution,\n        pixelRatio,\n        vectorSource.getOverlaps(),\n        declutterBuilderGroup.finish(),\n        vectorLayer.getRenderBuffer()\n      );\n    }\n\n    this.renderedResolution_ = resolution;\n    this.renderedRevision_ = vectorLayerRevision;\n    this.renderedRenderOrder_ = vectorLayerRenderOrder;\n    this.renderedExtent_ = renderedExtent;\n    this.wrappedRenderedExtent_ = extent;\n    this.renderedCenter_ = center;\n    this.renderedProjection_ = projection;\n    this.replayGroup_ = executorGroup;\n    this.hitDetectionImageData_ = null;\n\n    this.replayGroupChanged = true;\n    return true;\n  }\n\n  /**\n   * @param {import(\"../../Feature.js\").default} feature Feature.\n   * @param {number} squaredTolerance Squared render tolerance.\n   * @param {import(\"../../style/Style.js\").default|Array<import(\"../../style/Style.js\").default>} styles The style or array of styles.\n   * @param {import(\"../../render/canvas/BuilderGroup.js\").default} builderGroup Builder group.\n   * @param {import(\"../../proj.js\").TransformFunction} [transform] Transform from user to view projection.\n   * @param {import(\"../../render/canvas/BuilderGroup.js\").default} [declutterBuilderGroup] Builder for decluttering.\n   * @return {boolean} `true` if an image is loading.\n   */\n  renderFeature(\n    feature,\n    squaredTolerance,\n    styles,\n    builderGroup,\n    transform,\n    declutterBuilderGroup\n  ) {\n    if (!styles) {\n      return false;\n    }\n    let loading = false;\n    if (Array.isArray(styles)) {\n      for (let i = 0, ii = styles.length; i < ii; ++i) {\n        loading =\n          renderFeature(\n            builderGroup,\n            feature,\n            styles[i],\n            squaredTolerance,\n            this.boundHandleStyleImageChange_,\n            transform,\n            declutterBuilderGroup\n          ) || loading;\n      }\n    } else {\n      loading = renderFeature(\n        builderGroup,\n        feature,\n        styles,\n        squaredTolerance,\n        this.boundHandleStyleImageChange_,\n        transform,\n        declutterBuilderGroup\n      );\n    }\n    return loading;\n  }\n}\n\nexport default CanvasVectorLayerRenderer;\n","/**\n * @module ol/renderer/canvas/VectorTileLayer\n */\nimport CanvasBuilderGroup from '../../render/canvas/BuilderGroup.js';\nimport CanvasExecutorGroup from '../../render/canvas/ExecutorGroup.js';\nimport CanvasTileLayerRenderer from './TileLayer.js';\nimport TileState from '../../TileState.js';\nimport ViewHint from '../../ViewHint.js';\nimport {\n  HIT_DETECT_RESOLUTION,\n  createHitDetectionImageData,\n  hitDetect,\n} from '../../render/canvas/hitdetect.js';\nimport {\n  apply as applyTransform,\n  create as createTransform,\n  multiply,\n  reset as resetTransform,\n  scale,\n  scale as scaleTransform,\n  translate as translateTransform,\n} from '../../transform.js';\nimport {\n  boundingExtent,\n  buffer,\n  containsExtent,\n  equals,\n  getIntersection,\n  getTopLeft,\n  intersects,\n} from '../../extent.js';\nimport {\n  getSquaredTolerance as getSquaredRenderTolerance,\n  renderFeature,\n} from '../vector.js';\nimport {getUid} from '../../util.js';\nimport {toSize} from '../../size.js';\nimport {wrapX} from '../../coordinate.js';\n\n/**\n * @type {!Object<string, Array<import(\"../../render/canvas.js\").BuilderType>>}\n */\nconst IMAGE_REPLAYS = {\n  'image': ['Polygon', 'Circle', 'LineString', 'Image', 'Text'],\n  'hybrid': ['Polygon', 'LineString'],\n  'vector': [],\n};\n\n/**\n * @type {!Object<string, Array<import(\"../../render/canvas.js\").BuilderType>>}\n */\nconst VECTOR_REPLAYS = {\n  'hybrid': ['Image', 'Text', 'Default'],\n  'vector': ['Polygon', 'Circle', 'LineString', 'Image', 'Text', 'Default'],\n};\n\n/**\n * @classdesc\n * Canvas renderer for vector tile layers.\n * @api\n * @extends {CanvasTileLayerRenderer<import(\"../../layer/VectorTile.js\").default>}\n */\nclass CanvasVectorTileLayerRenderer extends CanvasTileLayerRenderer {\n  /**\n   * @param {import(\"../../layer/VectorTile.js\").default} layer VectorTile layer.\n   */\n  constructor(layer) {\n    super(layer);\n\n    /** @private */\n    this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this);\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedLayerRevision_;\n\n    /**\n     * @private\n     * @type {import(\"../../transform\").Transform}\n     */\n    this.renderedPixelToCoordinateTransform_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedRotation_;\n\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.tmpTransform_ = createTransform();\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection\").default} projection Projection.\n   * @return {boolean|undefined} Tile needs to be rendered.\n   */\n  prepareTile(tile, pixelRatio, projection) {\n    let render;\n    const state = tile.getState();\n    if (state === TileState.LOADED || state === TileState.ERROR) {\n      this.updateExecutorGroup_(tile, pixelRatio, projection);\n      if (this.tileImageNeedsRender_(tile)) {\n        render = true;\n      }\n    }\n    return render;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {!import(\"../../Tile.js\").default} Tile.\n   */\n  getTile(z, x, y, frameState) {\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const resolution = viewState.resolution;\n    const projection = viewState.projection;\n    const layer = this.getLayer();\n    const tile = layer.getSource().getTile(z, x, y, pixelRatio, projection);\n    const viewHints = frameState.viewHints;\n    const hifi = !(\n      viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]\n    );\n    if (hifi || !tile.wantedResolution) {\n      tile.wantedResolution = resolution;\n    }\n    const render = this.prepareTile(tile, pixelRatio, projection);\n    if (\n      render &&\n      (hifi || Date.now() - frameState.time < 8) &&\n      layer.getRenderMode() !== 'vector'\n    ) {\n      this.renderTileImage_(tile, frameState);\n    }\n    return super.getTile(z, x, y, frameState);\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @return {boolean} Tile is drawable.\n   */\n  isDrawableTile(tile) {\n    const layer = this.getLayer();\n    return (\n      super.isDrawableTile(tile) &&\n      (layer.getRenderMode() === 'vector'\n        ? getUid(layer) in tile.executorGroups\n        : tile.hasContext(layer))\n    );\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getTileImage(tile) {\n    return tile.getImage(this.getLayer());\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    const layerRevision = this.getLayer().getRevision();\n    if (this.renderedLayerRevision_ !== layerRevision) {\n      this.renderedLayerRevision_ = layerRevision;\n      this.renderedTiles.length = 0;\n    }\n    return super.prepareFrame(frameState);\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @private\n   */\n  updateExecutorGroup_(tile, pixelRatio, projection) {\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    const revision = layer.getRevision();\n    const renderOrder = layer.getRenderOrder() || null;\n\n    const resolution = tile.wantedResolution;\n    const builderState = tile.getReplayState(layer);\n    if (\n      !builderState.dirty &&\n      builderState.renderedResolution === resolution &&\n      builderState.renderedRevision == revision &&\n      builderState.renderedRenderOrder == renderOrder\n    ) {\n      return;\n    }\n\n    const source = layer.getSource();\n    const declutter = layer.getDeclutter();\n    const sourceTileGrid = source.getTileGrid();\n    const tileGrid = source.getTileGridForProjection(projection);\n    const tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n\n    const sourceTiles = source.getSourceTiles(pixelRatio, projection, tile);\n    const layerUid = getUid(layer);\n    delete tile.hitDetectionImageData[layerUid];\n    tile.executorGroups[layerUid] = [];\n    if (declutter) {\n      tile.declutterExecutorGroups[layerUid] = [];\n    }\n    builderState.dirty = false;\n    for (let t = 0, tt = sourceTiles.length; t < tt; ++t) {\n      const sourceTile = sourceTiles[t];\n      if (sourceTile.getState() != TileState.LOADED) {\n        continue;\n      }\n      const sourceTileCoord = sourceTile.tileCoord;\n      const sourceTileExtent =\n        sourceTileGrid.getTileCoordExtent(sourceTileCoord);\n      const sharedExtent = getIntersection(tileExtent, sourceTileExtent);\n      const builderExtent = buffer(\n        sharedExtent,\n        layer.getRenderBuffer() * resolution,\n        this.tmpExtent\n      );\n      const bufferedExtent = equals(sourceTileExtent, sharedExtent)\n        ? null\n        : builderExtent;\n      const builderGroup = new CanvasBuilderGroup(\n        0,\n        builderExtent,\n        resolution,\n        pixelRatio\n      );\n      const declutterBuilderGroup = declutter\n        ? new CanvasBuilderGroup(0, sharedExtent, resolution, pixelRatio)\n        : undefined;\n      const squaredTolerance = getSquaredRenderTolerance(\n        resolution,\n        pixelRatio\n      );\n\n      /**\n       * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n       * @this {CanvasVectorTileLayerRenderer}\n       */\n      const render = function (feature) {\n        let styles;\n        const styleFunction =\n          feature.getStyleFunction() || layer.getStyleFunction();\n        if (styleFunction) {\n          styles = styleFunction(feature, resolution);\n        }\n        if (styles) {\n          const dirty = this.renderFeature(\n            feature,\n            squaredTolerance,\n            styles,\n            builderGroup,\n            declutterBuilderGroup\n          );\n          builderState.dirty = builderState.dirty || dirty;\n        }\n      };\n\n      const features = sourceTile.getFeatures();\n      if (renderOrder && renderOrder !== builderState.renderedRenderOrder) {\n        features.sort(renderOrder);\n      }\n      for (let i = 0, ii = features.length; i < ii; ++i) {\n        const feature = features[i];\n        if (\n          !bufferedExtent ||\n          intersects(bufferedExtent, feature.getGeometry().getExtent())\n        ) {\n          render.call(this, feature);\n        }\n      }\n      const executorGroupInstructions = builderGroup.finish();\n      // no need to clip when the render tile is covered by a single source tile\n      const replayExtent =\n        layer.getRenderMode() !== 'vector' &&\n        declutter &&\n        sourceTiles.length === 1\n          ? null\n          : sharedExtent;\n      const renderingReplayGroup = new CanvasExecutorGroup(\n        replayExtent,\n        resolution,\n        pixelRatio,\n        source.getOverlaps(),\n        executorGroupInstructions,\n        layer.getRenderBuffer()\n      );\n      tile.executorGroups[layerUid].push(renderingReplayGroup);\n      if (declutterBuilderGroup) {\n        const declutterExecutorGroup = new CanvasExecutorGroup(\n          null,\n          resolution,\n          pixelRatio,\n          source.getOverlaps(),\n          declutterBuilderGroup.finish(),\n          layer.getRenderBuffer()\n        );\n        tile.declutterExecutorGroups[layerUid].push(declutterExecutorGroup);\n      }\n    }\n    builderState.renderedRevision = revision;\n    builderState.renderedRenderOrder = renderOrder;\n    builderState.renderedResolution = resolution;\n  }\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches\n  ) {\n    const resolution = frameState.viewState.resolution;\n    const rotation = frameState.viewState.rotation;\n    hitTolerance = hitTolerance == undefined ? 0 : hitTolerance;\n    const layer = this.getLayer();\n    const source = layer.getSource();\n    const tileGrid = source.getTileGridForProjection(\n      frameState.viewState.projection\n    );\n\n    const hitExtent = boundingExtent([coordinate]);\n    buffer(hitExtent, resolution * hitTolerance, hitExtent);\n\n    /** @type {!Object<string, import(\"../Map.js\").HitMatch<T>|true>} */\n    const features = {};\n\n    /**\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     * @param {import(\"../../geom/SimpleGeometry.js\").default} geometry Geometry.\n     * @param {number} distanceSq The squared distance to the click position.\n     * @return {T|undefined} Callback result.\n     */\n    const featureCallback = function (feature, geometry, distanceSq) {\n      let key = feature.getId();\n      if (key === undefined) {\n        key = getUid(feature);\n      }\n      const match = features[key];\n      if (!match) {\n        if (distanceSq === 0) {\n          features[key] = true;\n          return callback(feature, layer, geometry);\n        }\n        matches.push(\n          (features[key] = {\n            feature: feature,\n            layer: layer,\n            geometry: geometry,\n            distanceSq: distanceSq,\n            callback: callback,\n          })\n        );\n      } else if (match !== true && distanceSq < match.distanceSq) {\n        if (distanceSq === 0) {\n          features[key] = true;\n          matches.splice(matches.lastIndexOf(match), 1);\n          return callback(feature, layer, geometry);\n        }\n        match.geometry = geometry;\n        match.distanceSq = distanceSq;\n      }\n      return undefined;\n    };\n\n    const renderedTiles =\n      /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */ (\n        this.renderedTiles\n      );\n\n    let found;\n    for (let i = 0, ii = renderedTiles.length; !found && i < ii; ++i) {\n      const tile = renderedTiles[i];\n      const tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n      if (!intersects(tileExtent, hitExtent)) {\n        continue;\n      }\n\n      const layerUid = getUid(layer);\n      const executorGroups = [tile.executorGroups[layerUid]];\n      const declutterExecutorGroups = tile.declutterExecutorGroups[layerUid];\n      if (declutterExecutorGroups) {\n        executorGroups.push(declutterExecutorGroups);\n      }\n      executorGroups.some((executorGroups) => {\n        const declutteredFeatures =\n          executorGroups === declutterExecutorGroups\n            ? frameState.declutterTree.all().map((item) => item.value)\n            : null;\n        for (let t = 0, tt = executorGroups.length; t < tt; ++t) {\n          const executorGroup = executorGroups[t];\n          found = executorGroup.forEachFeatureAtCoordinate(\n            coordinate,\n            resolution,\n            rotation,\n            hitTolerance,\n            featureCallback,\n            declutteredFeatures\n          );\n          if (found) {\n            return true;\n          }\n        }\n      });\n    }\n    return found;\n  }\n\n  /**\n   * Asynchronous layer level hit detection.\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../../Feature.js\").FeatureLike>>} Promise that resolves with an array of features.\n   */\n  getFeatures(pixel) {\n    return new Promise((resolve, reject) => {\n      const layer = this.getLayer();\n      const layerUid = getUid(layer);\n      const source = layer.getSource();\n      const projection = this.renderedProjection;\n      const projectionExtent = projection.getExtent();\n      const resolution = this.renderedResolution;\n      const tileGrid = source.getTileGridForProjection(projection);\n      const coordinate = applyTransform(\n        this.renderedPixelToCoordinateTransform_,\n        pixel.slice()\n      );\n      const tileCoord = tileGrid.getTileCoordForCoordAndResolution(\n        coordinate,\n        resolution\n      );\n      /** @type {import(\"../../VectorRenderTile.js\").default|undefined} */\n      let tile;\n      for (let i = 0, ii = this.renderedTiles.length; i < ii; ++i) {\n        if (\n          tileCoord.toString() === this.renderedTiles[i].tileCoord.toString()\n        ) {\n          tile = /** @type {import(\"../../VectorRenderTile.js\").default} */ (\n            this.renderedTiles[i]\n          );\n          if (tile.getState() === TileState.LOADED) {\n            const extent = tileGrid.getTileCoordExtent(tile.tileCoord);\n            if (\n              source.getWrapX() &&\n              projection.canWrapX() &&\n              !containsExtent(projectionExtent, extent)\n            ) {\n              wrapX(coordinate, projection);\n            }\n            break;\n          }\n          tile = undefined;\n        }\n      }\n      if (!tile || tile.loadingSourceTiles > 0) {\n        resolve([]);\n        return;\n      }\n      const extent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n      const corner = getTopLeft(extent);\n      const tilePixel = [\n        (coordinate[0] - corner[0]) / resolution,\n        (corner[1] - coordinate[1]) / resolution,\n      ];\n      /** @type {Array<import(\"../../Feature.js\").FeatureLike>} */\n      const features = tile\n        .getSourceTiles()\n        .reduce(function (accumulator, sourceTile) {\n          return accumulator.concat(sourceTile.getFeatures());\n        }, []);\n      /** @type {ImageData|undefined} */\n      let hitDetectionImageData = tile.hitDetectionImageData[layerUid];\n      if (!hitDetectionImageData) {\n        const tileSize = toSize(\n          tileGrid.getTileSize(\n            tileGrid.getZForResolution(resolution, source.zDirection)\n          )\n        );\n        const rotation = this.renderedRotation_;\n        const transforms = [\n          this.getRenderTransform(\n            tileGrid.getTileCoordCenter(tile.wrappedTileCoord),\n            resolution,\n            0,\n            HIT_DETECT_RESOLUTION,\n            tileSize[0] * HIT_DETECT_RESOLUTION,\n            tileSize[1] * HIT_DETECT_RESOLUTION,\n            0\n          ),\n        ];\n        hitDetectionImageData = createHitDetectionImageData(\n          tileSize,\n          transforms,\n          features,\n          layer.getStyleFunction(),\n          tileGrid.getTileCoordExtent(tile.wrappedTileCoord),\n          tile.getReplayState(layer).renderedResolution,\n          rotation\n        );\n        tile.hitDetectionImageData[layerUid] = hitDetectionImageData;\n      }\n      resolve(hitDetect(tilePixel, features, hitDetectionImageData));\n    });\n  }\n\n  /**\n   * Perform action necessary to get the layer rendered after new fonts have loaded\n   */\n  handleFontsChanged() {\n    const layer = this.getLayer();\n    if (layer.getVisible() && this.renderedLayerRevision_ !== undefined) {\n      layer.changed();\n    }\n  }\n\n  /**\n   * Handle changes in image style state.\n   * @param {import(\"../../events/Event.js\").default} event Image style change event.\n   * @private\n   */\n  handleStyleImageChange_(event) {\n    this.renderIfReadyAndVisible();\n  }\n\n  /**\n   * Render declutter items for this layer\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   */\n  renderDeclutter(frameState) {\n    const context = this.context;\n    const alpha = context.globalAlpha;\n    context.globalAlpha = this.getLayer().getOpacity();\n    const viewHints = frameState.viewHints;\n    const hifi = !(\n      viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]\n    );\n    const tiles =\n      /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */ (\n        this.renderedTiles\n      );\n    for (let i = 0, ii = tiles.length; i < ii; ++i) {\n      const tile = tiles[i];\n      const declutterExecutorGroups =\n        tile.declutterExecutorGroups[getUid(this.getLayer())];\n      if (declutterExecutorGroups) {\n        for (let j = declutterExecutorGroups.length - 1; j >= 0; --j) {\n          declutterExecutorGroups[j].execute(\n            this.context,\n            1,\n            this.getTileRenderTransform(tile, frameState),\n            frameState.viewState.rotation,\n            hifi,\n            undefined,\n            frameState.declutterTree\n          );\n        }\n      }\n    }\n    context.globalAlpha = alpha;\n  }\n\n  getTileRenderTransform(tile, frameState) {\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const center = viewState.center;\n    const resolution = viewState.resolution;\n    const rotation = viewState.rotation;\n    const size = frameState.size;\n    const width = Math.round(size[0] * pixelRatio);\n    const height = Math.round(size[1] * pixelRatio);\n\n    const source = this.getLayer().getSource();\n    const tileGrid = source.getTileGridForProjection(\n      frameState.viewState.projection\n    );\n    const tileCoord = tile.tileCoord;\n    const tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n    const worldOffset =\n      tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent)[0] - tileExtent[0];\n    const transform = multiply(\n      scale(this.inversePixelTransform.slice(), 1 / pixelRatio, 1 / pixelRatio),\n      this.getRenderTransform(\n        center,\n        resolution,\n        rotation,\n        pixelRatio,\n        width,\n        height,\n        worldOffset\n      )\n    );\n    return transform;\n  }\n\n  /**\n   * Render the vectors for this layer.\n   * @param {CanvasRenderingContext2D} context Target context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   */\n  postRender(context, frameState) {\n    const viewHints = frameState.viewHints;\n    const hifi = !(\n      viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]\n    );\n\n    this.renderedPixelToCoordinateTransform_ =\n      frameState.pixelToCoordinateTransform.slice();\n    this.renderedRotation_ = frameState.viewState.rotation;\n\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    const renderMode = layer.getRenderMode();\n    const alpha = context.globalAlpha;\n    context.globalAlpha = layer.getOpacity();\n    const replayTypes = VECTOR_REPLAYS[renderMode];\n    const viewState = frameState.viewState;\n    const rotation = viewState.rotation;\n    const tileSource = layer.getSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n    const z = tileGrid.getZForResolution(\n      viewState.resolution,\n      tileSource.zDirection\n    );\n\n    const tiles = this.renderedTiles;\n    const clips = [];\n    const clipZs = [];\n    let ready = true;\n    for (let i = tiles.length - 1; i >= 0; --i) {\n      const tile = /** @type {import(\"../../VectorRenderTile.js\").default} */ (\n        tiles[i]\n      );\n      ready = ready && !tile.getReplayState(layer).dirty;\n      const executorGroups = tile.executorGroups[getUid(layer)].filter(\n        (group) => group.hasExecutors(replayTypes)\n      );\n      if (executorGroups.length === 0) {\n        continue;\n      }\n      const transform = this.getTileRenderTransform(tile, frameState);\n      const currentZ = tile.tileCoord[0];\n      let contextSaved = false;\n      // Clip mask for regions in this tile that already filled by a higher z tile\n      const currentClip = executorGroups[0].getClipCoords(transform);\n      if (currentClip) {\n        for (let j = 0, jj = clips.length; j < jj; ++j) {\n          if (z !== currentZ && currentZ < clipZs[j]) {\n            const clip = clips[j];\n            if (\n              intersects(\n                [\n                  currentClip[0],\n                  currentClip[3],\n                  currentClip[4],\n                  currentClip[7],\n                ],\n                [clip[0], clip[3], clip[4], clip[7]]\n              )\n            ) {\n              if (!contextSaved) {\n                context.save();\n                contextSaved = true;\n              }\n              context.beginPath();\n              // counter-clockwise (outer ring) for current tile\n              context.moveTo(currentClip[0], currentClip[1]);\n              context.lineTo(currentClip[2], currentClip[3]);\n              context.lineTo(currentClip[4], currentClip[5]);\n              context.lineTo(currentClip[6], currentClip[7]);\n              // clockwise (inner ring) for higher z tile\n              context.moveTo(clip[6], clip[7]);\n              context.lineTo(clip[4], clip[5]);\n              context.lineTo(clip[2], clip[3]);\n              context.lineTo(clip[0], clip[1]);\n              context.clip();\n            }\n          }\n        }\n        clips.push(currentClip);\n        clipZs.push(currentZ);\n      }\n      for (let t = 0, tt = executorGroups.length; t < tt; ++t) {\n        const executorGroup = executorGroups[t];\n        executorGroup.execute(\n          context,\n          1,\n          transform,\n          rotation,\n          hifi,\n          replayTypes\n        );\n      }\n      if (contextSaved) {\n        context.restore();\n      }\n    }\n    context.globalAlpha = alpha;\n    this.ready = ready;\n\n    super.postRender(context, frameState);\n  }\n\n  /**\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../../style/Style.js\").default|Array<import(\"../../style/Style.js\").default>} styles The style or array of styles.\n   * @param {import(\"../../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n   * @param {import(\"../../render/canvas/BuilderGroup.js\").default} [declutterBuilderGroup] Builder group for decluttering.\n   * @return {boolean} `true` if an image is loading.\n   */\n  renderFeature(\n    feature,\n    squaredTolerance,\n    styles,\n    builderGroup,\n    declutterBuilderGroup\n  ) {\n    if (!styles) {\n      return false;\n    }\n    let loading = false;\n    if (Array.isArray(styles)) {\n      for (let i = 0, ii = styles.length; i < ii; ++i) {\n        loading =\n          renderFeature(\n            builderGroup,\n            feature,\n            styles[i],\n            squaredTolerance,\n            this.boundHandleStyleImageChange_,\n            undefined,\n            declutterBuilderGroup\n          ) || loading;\n      }\n    } else {\n      loading = renderFeature(\n        builderGroup,\n        feature,\n        styles,\n        squaredTolerance,\n        this.boundHandleStyleImageChange_,\n        undefined,\n        declutterBuilderGroup\n      );\n    }\n    return loading;\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @return {boolean} A new tile image was rendered.\n   * @private\n   */\n  tileImageNeedsRender_(tile) {\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    if (layer.getRenderMode() === 'vector') {\n      return false;\n    }\n    const replayState = tile.getReplayState(layer);\n    const revision = layer.getRevision();\n    const resolution = tile.wantedResolution;\n    return (\n      replayState.renderedTileResolution !== resolution ||\n      replayState.renderedTileRevision !== revision\n    );\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {import(\"../../Map\").FrameState} frameState Frame state.\n   * @private\n   */\n  renderTileImage_(tile, frameState) {\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    const replayState = tile.getReplayState(layer);\n    const revision = layer.getRevision();\n    const executorGroups = tile.executorGroups[getUid(layer)];\n    replayState.renderedTileRevision = revision;\n\n    const tileCoord = tile.wrappedTileCoord;\n    const z = tileCoord[0];\n    const source = layer.getSource();\n    let pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const tileGrid = source.getTileGridForProjection(projection);\n    const tileResolution = tileGrid.getResolution(tile.tileCoord[0]);\n    const renderPixelRatio =\n      (frameState.pixelRatio / tile.wantedResolution) * tileResolution;\n    const resolution = tileGrid.getResolution(z);\n    const context = tile.getContext(layer);\n\n    // Increase tile size when overzooming for low pixel ratio, to avoid blurry tiles\n    pixelRatio = Math.round(\n      Math.max(pixelRatio, renderPixelRatio / pixelRatio)\n    );\n    const size = source.getTilePixelSize(z, pixelRatio, projection);\n    context.canvas.width = size[0];\n    context.canvas.height = size[1];\n    const renderScale = pixelRatio / renderPixelRatio;\n    if (renderScale !== 1) {\n      const canvasTransform = resetTransform(this.tmpTransform_);\n      scaleTransform(canvasTransform, renderScale, renderScale);\n      context.setTransform.apply(context, canvasTransform);\n    }\n    const tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);\n    const pixelScale = renderPixelRatio / resolution;\n    const transform = resetTransform(this.tmpTransform_);\n    scaleTransform(transform, pixelScale, -pixelScale);\n    translateTransform(transform, -tileExtent[0], -tileExtent[3]);\n    for (let i = 0, ii = executorGroups.length; i < ii; ++i) {\n      const executorGroup = executorGroups[i];\n      executorGroup.execute(\n        context,\n        renderScale,\n        transform,\n        0,\n        true,\n        IMAGE_REPLAYS[layer.getRenderMode()]\n      );\n    }\n    replayState.renderedTileResolution = tile.wantedResolution;\n  }\n}\n\nexport default CanvasVectorTileLayerRenderer;\n","/**\n * @module ol/renderer/vector\n */\nimport ImageState from '../ImageState.js';\nimport {getUid} from '../util.js';\n\n/**\n * Feature callback. The callback will be called with three arguments. The first\n * argument is one {@link module:ol/Feature~Feature feature} or {@link module:ol/render/Feature~RenderFeature render feature}\n * at the pixel, the second is the {@link module:ol/layer/Layer~Layer layer} of the feature and will be null for\n * unmanaged layers. The third is the {@link module:ol/geom/SimpleGeometry~SimpleGeometry} of the feature. For features\n * with a GeometryCollection geometry, it will be the first detected geometry from the collection.\n * @template T\n * @typedef {function(import(\"../Feature.js\").FeatureLike, import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>, import(\"../geom/SimpleGeometry.js\").default): T} FeatureCallback\n */\n\n/**\n * Tolerance for geometry simplification in device pixels.\n * @type {number}\n */\nconst SIMPLIFY_TOLERANCE = 0.5;\n\n/**\n * @const\n * @type {Object<import(\"../geom/Geometry.js\").Type,\n *                function(import(\"../render/canvas/BuilderGroup.js\").default, import(\"../geom/Geometry.js\").default,\n *                         import(\"../style/Style.js\").default, Object): void>}\n */\nconst GEOMETRY_RENDERERS = {\n  'Point': renderPointGeometry,\n  'LineString': renderLineStringGeometry,\n  'Polygon': renderPolygonGeometry,\n  'MultiPoint': renderMultiPointGeometry,\n  'MultiLineString': renderMultiLineStringGeometry,\n  'MultiPolygon': renderMultiPolygonGeometry,\n  'GeometryCollection': renderGeometryCollectionGeometry,\n  'Circle': renderCircleGeometry,\n};\n\n/**\n * @param {import(\"../Feature.js\").FeatureLike} feature1 Feature 1.\n * @param {import(\"../Feature.js\").FeatureLike} feature2 Feature 2.\n * @return {number} Order.\n */\nexport function defaultOrder(feature1, feature2) {\n  return parseInt(getUid(feature1), 10) - parseInt(getUid(feature2), 10);\n}\n\n/**\n * @param {number} resolution Resolution.\n * @param {number} pixelRatio Pixel ratio.\n * @return {number} Squared pixel tolerance.\n */\nexport function getSquaredTolerance(resolution, pixelRatio) {\n  const tolerance = getTolerance(resolution, pixelRatio);\n  return tolerance * tolerance;\n}\n\n/**\n * @param {number} resolution Resolution.\n * @param {number} pixelRatio Pixel ratio.\n * @return {number} Pixel tolerance.\n */\nexport function getTolerance(resolution, pixelRatio) {\n  return (SIMPLIFY_TOLERANCE * resolution) / pixelRatio;\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Builder group.\n * @param {import(\"../geom/Circle.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderCircleGeometry(\n  builderGroup,\n  geometry,\n  style,\n  feature,\n  declutterBuilderGroup\n) {\n  const fillStyle = style.getFill();\n  const strokeStyle = style.getStroke();\n  if (fillStyle || strokeStyle) {\n    const circleReplay = builderGroup.getBuilder(style.getZIndex(), 'Circle');\n    circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);\n    circleReplay.drawCircle(geometry, feature);\n  }\n  const textStyle = style.getText();\n  if (textStyle && textStyle.getText()) {\n    const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(\n      style.getZIndex(),\n      'Text'\n    );\n    textReplay.setTextStyle(textStyle);\n    textReplay.drawText(geometry, feature);\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} replayGroup Replay group.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {function(import(\"../events/Event.js\").default): void} listener Listener function.\n * @param {import(\"../proj.js\").TransformFunction} [transform] Transform from user to view projection.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [declutterBuilderGroup] Builder for decluttering.\n * @return {boolean} `true` if style is loading.\n */\nexport function renderFeature(\n  replayGroup,\n  feature,\n  style,\n  squaredTolerance,\n  listener,\n  transform,\n  declutterBuilderGroup\n) {\n  let loading = false;\n  const imageStyle = style.getImage();\n  if (imageStyle) {\n    const imageState = imageStyle.getImageState();\n    if (imageState == ImageState.LOADED || imageState == ImageState.ERROR) {\n      imageStyle.unlistenImageChange(listener);\n    } else {\n      if (imageState == ImageState.IDLE) {\n        imageStyle.load();\n      }\n      imageStyle.listenImageChange(listener);\n      loading = true;\n    }\n  }\n  renderFeatureInternal(\n    replayGroup,\n    feature,\n    style,\n    squaredTolerance,\n    transform,\n    declutterBuilderGroup\n  );\n\n  return loading;\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} replayGroup Replay group.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {import(\"../proj.js\").TransformFunction} [transform] Optional transform function.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderFeatureInternal(\n  replayGroup,\n  feature,\n  style,\n  squaredTolerance,\n  transform,\n  declutterBuilderGroup\n) {\n  const geometry = style.getGeometryFunction()(feature);\n  if (!geometry) {\n    return;\n  }\n  const simplifiedGeometry = geometry.simplifyTransformed(\n    squaredTolerance,\n    transform\n  );\n  const renderer = style.getRenderer();\n  if (renderer) {\n    renderGeometry(replayGroup, simplifiedGeometry, style, feature);\n  } else {\n    const geometryRenderer = GEOMETRY_RENDERERS[simplifiedGeometry.getType()];\n    geometryRenderer(\n      replayGroup,\n      simplifiedGeometry,\n      style,\n      feature,\n      declutterBuilderGroup\n    );\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} replayGroup Replay group.\n * @param {import(\"../geom/Geometry.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n */\nfunction renderGeometry(replayGroup, geometry, style, feature) {\n  if (geometry.getType() == 'GeometryCollection') {\n    const geometries =\n      /** @type {import(\"../geom/GeometryCollection.js\").default} */ (\n        geometry\n      ).getGeometries();\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      renderGeometry(replayGroup, geometries[i], style, feature);\n    }\n    return;\n  }\n  const replay = replayGroup.getBuilder(style.getZIndex(), 'Default');\n  replay.drawCustom(\n    /** @type {import(\"../geom/SimpleGeometry.js\").default} */ (geometry),\n    feature,\n    style.getRenderer(),\n    style.getHitDetectionRenderer()\n  );\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} replayGroup Replay group.\n * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderGeometryCollectionGeometry(\n  replayGroup,\n  geometry,\n  style,\n  feature,\n  declutterBuilderGroup\n) {\n  const geometries = geometry.getGeometriesArray();\n  let i, ii;\n  for (i = 0, ii = geometries.length; i < ii; ++i) {\n    const geometryRenderer = GEOMETRY_RENDERERS[geometries[i].getType()];\n    geometryRenderer(\n      replayGroup,\n      geometries[i],\n      style,\n      feature,\n      declutterBuilderGroup\n    );\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/LineString.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderLineStringGeometry(\n  builderGroup,\n  geometry,\n  style,\n  feature,\n  declutterBuilderGroup\n) {\n  const strokeStyle = style.getStroke();\n  if (strokeStyle) {\n    const lineStringReplay = builderGroup.getBuilder(\n      style.getZIndex(),\n      'LineString'\n    );\n    lineStringReplay.setFillStrokeStyle(null, strokeStyle);\n    lineStringReplay.drawLineString(geometry, feature);\n  }\n  const textStyle = style.getText();\n  if (textStyle && textStyle.getText()) {\n    const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(\n      style.getZIndex(),\n      'Text'\n    );\n    textReplay.setTextStyle(textStyle);\n    textReplay.drawText(geometry, feature);\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/MultiLineString.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderMultiLineStringGeometry(\n  builderGroup,\n  geometry,\n  style,\n  feature,\n  declutterBuilderGroup\n) {\n  const strokeStyle = style.getStroke();\n  if (strokeStyle) {\n    const lineStringReplay = builderGroup.getBuilder(\n      style.getZIndex(),\n      'LineString'\n    );\n    lineStringReplay.setFillStrokeStyle(null, strokeStyle);\n    lineStringReplay.drawMultiLineString(geometry, feature);\n  }\n  const textStyle = style.getText();\n  if (textStyle && textStyle.getText()) {\n    const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(\n      style.getZIndex(),\n      'Text'\n    );\n    textReplay.setTextStyle(textStyle);\n    textReplay.drawText(geometry, feature);\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderMultiPolygonGeometry(\n  builderGroup,\n  geometry,\n  style,\n  feature,\n  declutterBuilderGroup\n) {\n  const fillStyle = style.getFill();\n  const strokeStyle = style.getStroke();\n  if (strokeStyle || fillStyle) {\n    const polygonReplay = builderGroup.getBuilder(style.getZIndex(), 'Polygon');\n    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);\n    polygonReplay.drawMultiPolygon(geometry, feature);\n  }\n  const textStyle = style.getText();\n  if (textStyle && textStyle.getText()) {\n    const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(\n      style.getZIndex(),\n      'Text'\n    );\n    textReplay.setTextStyle(textStyle);\n    textReplay.drawText(geometry, feature);\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/Point.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderPointGeometry(\n  builderGroup,\n  geometry,\n  style,\n  feature,\n  declutterBuilderGroup\n) {\n  const imageStyle = style.getImage();\n  const textStyle = style.getText();\n  /** @type {import(\"../render/canvas.js\").DeclutterImageWithText} */\n  let declutterImageWithText;\n  if (imageStyle) {\n    if (imageStyle.getImageState() != ImageState.LOADED) {\n      return;\n    }\n    let imageBuilderGroup = builderGroup;\n    if (declutterBuilderGroup) {\n      const declutterMode = imageStyle.getDeclutterMode();\n      if (declutterMode !== 'none') {\n        imageBuilderGroup = declutterBuilderGroup;\n        if (declutterMode === 'obstacle') {\n          // draw in non-declutter group:\n          const imageReplay = builderGroup.getBuilder(\n            style.getZIndex(),\n            'Image'\n          );\n          imageReplay.setImageStyle(imageStyle, declutterImageWithText);\n          imageReplay.drawPoint(geometry, feature);\n        } else if (textStyle && textStyle.getText()) {\n          declutterImageWithText = {};\n        }\n      }\n    }\n    const imageReplay = imageBuilderGroup.getBuilder(\n      style.getZIndex(),\n      'Image'\n    );\n    imageReplay.setImageStyle(imageStyle, declutterImageWithText);\n    imageReplay.drawPoint(geometry, feature);\n  }\n  if (textStyle && textStyle.getText()) {\n    let textBuilderGroup = builderGroup;\n    if (declutterBuilderGroup) {\n      textBuilderGroup = declutterBuilderGroup;\n    }\n    const textReplay = textBuilderGroup.getBuilder(style.getZIndex(), 'Text');\n    textReplay.setTextStyle(textStyle, declutterImageWithText);\n    textReplay.drawText(geometry, feature);\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/MultiPoint.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderMultiPointGeometry(\n  builderGroup,\n  geometry,\n  style,\n  feature,\n  declutterBuilderGroup\n) {\n  const imageStyle = style.getImage();\n  const textStyle = style.getText();\n  /** @type {import(\"../render/canvas.js\").DeclutterImageWithText} */\n  let declutterImageWithText;\n  if (imageStyle) {\n    if (imageStyle.getImageState() != ImageState.LOADED) {\n      return;\n    }\n    let imageBuilderGroup = builderGroup;\n    if (declutterBuilderGroup) {\n      const declutterMode = imageStyle.getDeclutterMode();\n      if (declutterMode !== 'none') {\n        imageBuilderGroup = declutterBuilderGroup;\n        if (declutterMode === 'obstacle') {\n          // draw in non-declutter group:\n          const imageReplay = builderGroup.getBuilder(\n            style.getZIndex(),\n            'Image'\n          );\n          imageReplay.setImageStyle(imageStyle, declutterImageWithText);\n          imageReplay.drawMultiPoint(geometry, feature);\n        } else if (textStyle && textStyle.getText()) {\n          declutterImageWithText = {};\n        }\n      }\n    }\n    const imageReplay = imageBuilderGroup.getBuilder(\n      style.getZIndex(),\n      'Image'\n    );\n    imageReplay.setImageStyle(imageStyle, declutterImageWithText);\n    imageReplay.drawMultiPoint(geometry, feature);\n  }\n  if (textStyle && textStyle.getText()) {\n    let textBuilderGroup = builderGroup;\n    if (declutterBuilderGroup) {\n      textBuilderGroup = declutterBuilderGroup;\n    }\n    const textReplay = textBuilderGroup.getBuilder(style.getZIndex(), 'Text');\n    textReplay.setTextStyle(textStyle, declutterImageWithText);\n    textReplay.drawText(geometry, feature);\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/Polygon.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderPolygonGeometry(\n  builderGroup,\n  geometry,\n  style,\n  feature,\n  declutterBuilderGroup\n) {\n  const fillStyle = style.getFill();\n  const strokeStyle = style.getStroke();\n  if (fillStyle || strokeStyle) {\n    const polygonReplay = builderGroup.getBuilder(style.getZIndex(), 'Polygon');\n    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);\n    polygonReplay.drawPolygon(geometry, feature);\n  }\n  const textStyle = style.getText();\n  if (textStyle && textStyle.getText()) {\n    const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(\n      style.getZIndex(),\n      'Text'\n    );\n    textReplay.setTextStyle(textStyle);\n    textReplay.drawText(geometry, feature);\n  }\n}\n","/**\n * @module ol/renderer/webgl/Layer\n */\nimport LayerProperty from '../../layer/Property.js';\nimport LayerRenderer from '../Layer.js';\nimport RenderEvent from '../../render/Event.js';\nimport RenderEventType from '../../render/EventType.js';\nimport WebGLHelper from '../../webgl/Helper.js';\nimport {\n  compose as composeTransform,\n  create as createTransform,\n} from '../../transform.js';\n\n/**\n * @typedef {Object} PostProcessesOptions\n * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than\n * the main canvas that will then be sampled up (useful for saving resource on blur steps).\n * @property {string} [vertexShader] Vertex shader source\n * @property {string} [fragmentShader] Fragment shader source\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process step\n */\n\n/**\n * @typedef {Object} Options\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process steps\n * @property {Array<PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n\n/**\n * @classdesc\n * Base WebGL renderer class.\n * Holds all logic related to data manipulation & some common rendering logic\n * @template {import(\"../../layer/Layer.js\").default} LayerType\n * @extends {LayerRenderer<LayerType>}\n */\nclass WebGLLayerRenderer extends LayerRenderer {\n  /**\n   * @param {LayerType} layer Layer.\n   * @param {Options} [options] Options.\n   */\n  constructor(layer, options) {\n    super(layer);\n\n    options = options || {};\n\n    /**\n     * The transform for viewport CSS pixels to rendered pixels.  This transform is only\n     * set before dispatching rendering events.\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.inversePixelTransform_ = createTransform();\n\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n    this.pixelContext_ = null;\n\n    /**\n     * @private\n     */\n    this.postProcesses_ = options.postProcesses;\n\n    /**\n     * @private\n     */\n    this.uniforms_ = options.uniforms;\n\n    /**\n     * @type {WebGLHelper}\n     * @protected\n     */\n    this.helper;\n\n    layer.addChangeListener(LayerProperty.MAP, this.removeHelper.bind(this));\n\n    this.dispatchPreComposeEvent = this.dispatchPreComposeEvent.bind(this);\n    this.dispatchPostComposeEvent = this.dispatchPostComposeEvent.bind(this);\n  }\n\n  /**\n   * @param {WebGLRenderingContext} context The WebGL rendering context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  dispatchPreComposeEvent(context, frameState) {\n    const layer = this.getLayer();\n    if (layer.hasListener(RenderEventType.PRECOMPOSE)) {\n      const event = new RenderEvent(\n        RenderEventType.PRECOMPOSE,\n        undefined,\n        frameState,\n        context\n      );\n      layer.dispatchEvent(event);\n    }\n  }\n\n  /**\n   * @param {WebGLRenderingContext} context The WebGL rendering context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  dispatchPostComposeEvent(context, frameState) {\n    const layer = this.getLayer();\n    if (layer.hasListener(RenderEventType.POSTCOMPOSE)) {\n      const event = new RenderEvent(\n        RenderEventType.POSTCOMPOSE,\n        undefined,\n        frameState,\n        context\n      );\n      layer.dispatchEvent(event);\n    }\n  }\n\n  /**\n   * Reset options (only handles uniforms).\n   * @param {Options} options Options.\n   */\n  reset(options) {\n    this.uniforms_ = options.uniforms;\n    if (this.helper) {\n      this.helper.setUniforms(this.uniforms_);\n    }\n  }\n\n  /**\n   * @protected\n   */\n  removeHelper() {\n    if (this.helper) {\n      this.helper.dispose();\n      delete this.helper;\n    }\n  }\n\n  /**\n   * Determine whether renderFrame should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    if (this.getLayer().getRenderSource()) {\n      let incrementGroup = true;\n      let groupNumber = -1;\n      let className;\n      for (let i = 0, ii = frameState.layerStatesArray.length; i < ii; i++) {\n        const layer = frameState.layerStatesArray[i].layer;\n        const renderer = layer.getRenderer();\n        if (!(renderer instanceof WebGLLayerRenderer)) {\n          incrementGroup = true;\n          continue;\n        }\n        const layerClassName = layer.getClassName();\n        if (incrementGroup || layerClassName !== className) {\n          groupNumber += 1;\n          incrementGroup = false;\n        }\n        className = layerClassName;\n        if (renderer === this) {\n          break;\n        }\n      }\n\n      const canvasCacheKey =\n        'map/' + frameState.mapId + '/group/' + groupNumber;\n\n      if (!this.helper || !this.helper.canvasCacheKeyMatches(canvasCacheKey)) {\n        this.removeHelper();\n\n        this.helper = new WebGLHelper({\n          postProcesses: this.postProcesses_,\n          uniforms: this.uniforms_,\n          canvasCacheKey: canvasCacheKey,\n        });\n\n        if (className) {\n          this.helper.getCanvas().className = className;\n        }\n\n        this.afterHelperCreated();\n      }\n    }\n\n    return this.prepareFrameInternal(frameState);\n  }\n\n  /**\n   * @protected\n   */\n  afterHelperCreated() {}\n\n  /**\n   * Determine whether renderFrame should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   * @protected\n   */\n  prepareFrameInternal(frameState) {\n    return true;\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    this.removeHelper();\n    super.disposeInternal();\n  }\n\n  /**\n   * @param {import(\"../../render/EventType.js\").default} type Event type.\n   * @param {WebGLRenderingContext} context The rendering context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @private\n   */\n  dispatchRenderEvent_(type, context, frameState) {\n    const layer = this.getLayer();\n    if (layer.hasListener(type)) {\n      composeTransform(\n        this.inversePixelTransform_,\n        0,\n        0,\n        frameState.pixelRatio,\n        -frameState.pixelRatio,\n        0,\n        0,\n        -frameState.size[1]\n      );\n\n      const event = new RenderEvent(\n        type,\n        this.inversePixelTransform_,\n        frameState,\n        context\n      );\n      layer.dispatchEvent(event);\n    }\n  }\n\n  /**\n   * @param {WebGLRenderingContext} context The rendering context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  preRender(context, frameState) {\n    this.dispatchRenderEvent_(RenderEventType.PRERENDER, context, frameState);\n  }\n\n  /**\n   * @param {WebGLRenderingContext} context The rendering context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  postRender(context, frameState) {\n    this.dispatchRenderEvent_(RenderEventType.POSTRENDER, context, frameState);\n  }\n}\n\nexport default WebGLLayerRenderer;\n","/**\n * @module ol/render/webgl/constants\n */\n\n/**\n * @enum {string}\n */\nexport const WebGLWorkerMessageType = {\n  GENERATE_POLYGON_BUFFERS: 'GENERATE_POLYGON_BUFFERS',\n  GENERATE_POINT_BUFFERS: 'GENERATE_POINT_BUFFERS',\n  GENERATE_LINE_STRING_BUFFERS: 'GENERATE_LINE_STRING_BUFFERS',\n};\n\n/**\n * @typedef {Object} WebGLWorkerGenerateBuffersMessage\n * This message will trigger the generation of a vertex and an index buffer based on the given render instructions.\n * When the buffers are generated, the worked will send a message of the same type to the main thread, with\n * the generated buffers in it.\n * Note that any addition properties present in the message *will* be sent back to the main thread.\n * @property {number} id Message id; will be used both in request and response as a means of identification\n * @property {WebGLWorkerMessageType} type Message type\n * @property {ArrayBuffer} renderInstructions Polygon render instructions raw binary buffer.\n * @property {number} [customAttributesSize] Amount of custom attributes count in the polygon render instructions.\n * @property {ArrayBuffer} [vertexBuffer] Vertices array raw binary buffer (sent by the worker).\n * @property {ArrayBuffer} [indexBuffer] Indices array raw binary buffer (sent by the worker).\n * @property {import(\"../../transform\").Transform} [renderInstructionsTransform] Transformation matrix used to project the instructions coordinates\n */\n","/**\n * @module ol/render/webgl/utils\n */\nimport earcut from 'earcut';\nimport {apply as applyTransform} from '../../transform.js';\nimport {clamp} from '../../math.js';\n\nconst tmpArray_ = [];\n\n/**\n * An object holding positions both in an index and a vertex buffer.\n * @typedef {Object} BufferPositions\n * @property {number} vertexPosition Position in the vertex buffer\n * @property {number} indexPosition Position in the index buffer\n */\nconst bufferPositions_ = {vertexPosition: 0, indexPosition: 0};\n\nfunction writePointVertex(buffer, pos, x, y, index) {\n  buffer[pos + 0] = x;\n  buffer[pos + 1] = y;\n  buffer[pos + 2] = index;\n}\n\n/**\n * Pushes a quad (two triangles) based on a point geometry\n * @param {Float32Array} instructions Array of render instructions for points.\n * @param {number} elementIndex Index from which render instructions will be read.\n * @param {Float32Array} vertexBuffer Buffer in the form of a typed array.\n * @param {Uint32Array} indexBuffer Buffer in the form of a typed array.\n * @param {number} customAttributesSize Amount of custom attributes for each element.\n * @param {BufferPositions} [bufferPositions] Buffer write positions; if not specified, positions will be set at 0.\n * @return {BufferPositions} New buffer positions where to write next\n * @property {number} vertexPosition New position in the vertex buffer where future writes should start.\n * @property {number} indexPosition New position in the index buffer where future writes should start.\n * @private\n */\nexport function writePointFeatureToBuffers(\n  instructions,\n  elementIndex,\n  vertexBuffer,\n  indexBuffer,\n  customAttributesSize,\n  bufferPositions\n) {\n  // This is for x, y and index\n  const baseVertexAttrsCount = 3;\n  const baseInstructionsCount = 2;\n  const stride = baseVertexAttrsCount + customAttributesSize;\n\n  const x = instructions[elementIndex + 0];\n  const y = instructions[elementIndex + 1];\n\n  // read custom numerical attributes on the feature\n  const customAttrs = tmpArray_;\n  customAttrs.length = customAttributesSize;\n  for (let i = 0; i < customAttrs.length; i++) {\n    customAttrs[i] = instructions[elementIndex + baseInstructionsCount + i];\n  }\n\n  let vPos = bufferPositions ? bufferPositions.vertexPosition : 0;\n  let iPos = bufferPositions ? bufferPositions.indexPosition : 0;\n  const baseIndex = vPos / stride;\n\n  // push vertices for each of the four quad corners (first standard then custom attributes)\n  writePointVertex(vertexBuffer, vPos, x, y, 0);\n  customAttrs.length &&\n    vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n\n  writePointVertex(vertexBuffer, vPos, x, y, 1);\n  customAttrs.length &&\n    vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n\n  writePointVertex(vertexBuffer, vPos, x, y, 2);\n  customAttrs.length &&\n    vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n\n  writePointVertex(vertexBuffer, vPos, x, y, 3);\n  customAttrs.length &&\n    vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n\n  indexBuffer[iPos++] = baseIndex;\n  indexBuffer[iPos++] = baseIndex + 1;\n  indexBuffer[iPos++] = baseIndex + 3;\n  indexBuffer[iPos++] = baseIndex + 1;\n  indexBuffer[iPos++] = baseIndex + 2;\n  indexBuffer[iPos++] = baseIndex + 3;\n\n  bufferPositions_.vertexPosition = vPos;\n  bufferPositions_.indexPosition = iPos;\n\n  return bufferPositions_;\n}\n\n/**\n * Pushes a single quad to form a line segment; also includes a computation for the join angles with previous and next\n * segment, in order to be able to offset the vertices correctly in the shader\n * @param {Float32Array} instructions Array of render instructions for lines.\n * @param {number} segmentStartIndex Index of the segment start point from which render instructions will be read.\n * @param {number} segmentEndIndex Index of the segment start point from which render instructions will be read.\n * @param {number|null} beforeSegmentIndex Index of the point right before the segment (null if none, e.g this is a line start)\n * @param {number|null} afterSegmentIndex Index of the point right after the segment (null if none, e.g this is a line end)\n * @param {Array<number>} vertexArray Array containing vertices.\n * @param {Array<number>} indexArray Array containing indices.\n * @param {Array<number>} customAttributes Array of custom attributes value\n * @param {import('../../transform.js').Transform} instructionsTransform Transform matrix used to project coordinates in instructions\n * @param {import('../../transform.js').Transform} invertInstructionsTransform Transform matrix used to project coordinates in instructions\n * @private\n */\nexport function writeLineSegmentToBuffers(\n  instructions,\n  segmentStartIndex,\n  segmentEndIndex,\n  beforeSegmentIndex,\n  afterSegmentIndex,\n  vertexArray,\n  indexArray,\n  customAttributes,\n  instructionsTransform,\n  invertInstructionsTransform\n) {\n  // compute the stride to determine how many vertices were already pushed\n  const baseVertexAttrsCount = 5; // base attributes: x0, y0, x1, y1, params (vertex number [0-3], join angle 1, join angle 2)\n  const stride = baseVertexAttrsCount + customAttributes.length;\n  const baseIndex = vertexArray.length / stride;\n\n  // The segment is composed of two positions called P0[x0, y0] and P1[x1, y1]\n  // Depending on whether there are points before and after the segment, its final shape\n  // will be different\n  const p0 = [\n    instructions[segmentStartIndex + 0],\n    instructions[segmentStartIndex + 1],\n  ];\n  const p1 = [instructions[segmentEndIndex], instructions[segmentEndIndex + 1]];\n\n  // to compute offsets from the line center we need to reproject\n  // coordinates back in world units and compute the length of the segment\n  const p0world = applyTransform(invertInstructionsTransform, [...p0]);\n  const p1world = applyTransform(invertInstructionsTransform, [...p1]);\n\n  function computeVertexParameters(vertexNumber, joinAngle1, joinAngle2) {\n    const shift = 10000;\n    const anglePrecision = 1500;\n    return (\n      Math.round(joinAngle1 * anglePrecision) +\n      Math.round(joinAngle2 * anglePrecision) * shift +\n      vertexNumber * shift * shift\n    );\n  }\n\n  // compute the angle between p0pA and p0pB\n  // returns a value in [0, 2PI]\n  function angleBetween(p0, pA, pB) {\n    const lenA = Math.sqrt(\n      (pA[0] - p0[0]) * (pA[0] - p0[0]) + (pA[1] - p0[1]) * (pA[1] - p0[1])\n    );\n    const tangentA = [(pA[0] - p0[0]) / lenA, (pA[1] - p0[1]) / lenA];\n    const orthoA = [-tangentA[1], tangentA[0]];\n    const lenB = Math.sqrt(\n      (pB[0] - p0[0]) * (pB[0] - p0[0]) + (pB[1] - p0[1]) * (pB[1] - p0[1])\n    );\n    const tangentB = [(pB[0] - p0[0]) / lenB, (pB[1] - p0[1]) / lenB];\n\n    // this angle can be clockwise or anticlockwise; hence the computation afterwards\n    const angle =\n      lenA === 0 || lenB === 0\n        ? 0\n        : Math.acos(\n            clamp(tangentB[0] * tangentA[0] + tangentB[1] * tangentA[1], -1, 1)\n          );\n    const isClockwise = tangentB[0] * orthoA[0] + tangentB[1] * orthoA[1] > 0;\n    return !isClockwise ? Math.PI * 2 - angle : angle;\n  }\n\n  const joinBefore = beforeSegmentIndex !== null;\n  const joinAfter = afterSegmentIndex !== null;\n\n  let angle0 = 0;\n  let angle1 = 0;\n\n  // add vertices and adapt offsets for P0 in case of join\n  if (joinBefore) {\n    // B for before\n    const pB = [\n      instructions[beforeSegmentIndex],\n      instructions[beforeSegmentIndex + 1],\n    ];\n    const pBworld = applyTransform(invertInstructionsTransform, [...pB]);\n    angle0 = angleBetween(p0world, p1world, pBworld);\n  }\n  // adapt offsets for P1 in case of join\n  if (joinAfter) {\n    // A for after\n    const pA = [\n      instructions[afterSegmentIndex],\n      instructions[afterSegmentIndex + 1],\n    ];\n    const pAworld = applyTransform(invertInstructionsTransform, [...pA]);\n    angle1 = angleBetween(p1world, p0world, pAworld);\n  }\n\n  // add main segment triangles\n  vertexArray.push(\n    p0[0],\n    p0[1],\n    p1[0],\n    p1[1],\n    computeVertexParameters(0, angle0, angle1)\n  );\n  vertexArray.push(...customAttributes);\n\n  vertexArray.push(\n    p0[0],\n    p0[1],\n    p1[0],\n    p1[1],\n    computeVertexParameters(1, angle0, angle1)\n  );\n  vertexArray.push(...customAttributes);\n\n  vertexArray.push(\n    p0[0],\n    p0[1],\n    p1[0],\n    p1[1],\n    computeVertexParameters(2, angle0, angle1)\n  );\n  vertexArray.push(...customAttributes);\n\n  vertexArray.push(\n    p0[0],\n    p0[1],\n    p1[0],\n    p1[1],\n    computeVertexParameters(3, angle0, angle1)\n  );\n  vertexArray.push(...customAttributes);\n\n  indexArray.push(\n    baseIndex,\n    baseIndex + 1,\n    baseIndex + 2,\n    baseIndex + 1,\n    baseIndex + 3,\n    baseIndex + 2\n  );\n}\n\n/**\n * Pushes several triangles to form a polygon, including holes\n * @param {Float32Array} instructions Array of render instructions for lines.\n * @param {number} polygonStartIndex Index of the polygon start point from which render instructions will be read.\n * @param {Array<number>} vertexArray Array containing vertices.\n * @param {Array<number>} indexArray Array containing indices.\n * @param {number} customAttributesSize Amount of custom attributes for each element.\n * @return {number} Next polygon instructions index\n * @private\n */\nexport function writePolygonTrianglesToBuffers(\n  instructions,\n  polygonStartIndex,\n  vertexArray,\n  indexArray,\n  customAttributesSize\n) {\n  const instructionsPerVertex = 2; // x, y\n  const attributesPerVertex = 2 + customAttributesSize;\n  let instructionsIndex = polygonStartIndex;\n  const customAttributes = instructions.slice(\n    instructionsIndex,\n    instructionsIndex + customAttributesSize\n  );\n  instructionsIndex += customAttributesSize;\n  const ringsCount = instructions[instructionsIndex++];\n  let verticesCount = 0;\n  const holes = new Array(ringsCount - 1);\n  for (let i = 0; i < ringsCount; i++) {\n    verticesCount += instructions[instructionsIndex++];\n    if (i < ringsCount - 1) {\n      holes[i] = verticesCount;\n    }\n  }\n  const flatCoords = instructions.slice(\n    instructionsIndex,\n    instructionsIndex + verticesCount * instructionsPerVertex\n  );\n\n  // pushing to vertices and indices!! this is where the magic happens\n  const result = earcut(flatCoords, holes, instructionsPerVertex);\n  for (let i = 0; i < result.length; i++) {\n    indexArray.push(result[i] + vertexArray.length / attributesPerVertex);\n  }\n  for (let i = 0; i < flatCoords.length; i += 2) {\n    vertexArray.push(flatCoords[i], flatCoords[i + 1], ...customAttributes);\n  }\n\n  return instructionsIndex + verticesCount * instructionsPerVertex;\n}\n\n/**\n * Returns a texture of 1x1 pixel, white\n * @private\n * @return {ImageData} Image data.\n */\nexport function getBlankImageData() {\n  const canvas = document.createElement('canvas');\n  const image = canvas.getContext('2d').createImageData(1, 1);\n  image.data[0] = 255;\n  image.data[1] = 255;\n  image.data[2] = 255;\n  image.data[3] = 255;\n  return image;\n}\n\n/**\n * Generates a color array based on a numerical id\n * Note: the range for each component is 0 to 1 with 256 steps\n * @param {number} id Id\n * @param {Array<number>} [array] Reusable array\n * @return {Array<number>} Color array containing the encoded id\n */\nexport function colorEncodeId(id, array) {\n  array = array || [];\n  const radix = 256;\n  const divide = radix - 1;\n  array[0] = Math.floor(id / radix / radix / radix) / divide;\n  array[1] = (Math.floor(id / radix / radix) % radix) / divide;\n  array[2] = (Math.floor(id / radix) % radix) / divide;\n  array[3] = (id % radix) / divide;\n  return array;\n}\n\n/**\n * Reads an id from a color-encoded array\n * Note: the expected range for each component is 0 to 1 with 256 steps.\n * @param {Array<number>} color Color array containing the encoded id\n * @return {number} Decoded id\n */\nexport function colorDecodeId(color) {\n  let id = 0;\n  const radix = 256;\n  const mult = radix - 1;\n  id += Math.round(color[0] * radix * radix * radix * mult);\n  id += Math.round(color[1] * radix * radix * mult);\n  id += Math.round(color[2] * radix * mult);\n  id += Math.round(color[3] * mult);\n  return id;\n}\n","/**\n * @module ol/renderer/webgl/PointsLayer\n */\nimport BaseVector from '../../layer/BaseVector.js';\nimport VectorEventType from '../../source/VectorEventType.js';\nimport ViewHint from '../../ViewHint.js';\nimport WebGLArrayBuffer from '../../webgl/Buffer.js';\nimport WebGLLayerRenderer from './Layer.js';\nimport WebGLRenderTarget from '../../webgl/RenderTarget.js';\nimport {ARRAY_BUFFER, DYNAMIC_DRAW, ELEMENT_ARRAY_BUFFER} from '../../webgl.js';\nimport {AttributeType, DefaultUniform} from '../../webgl/Helper.js';\nimport {WebGLWorkerMessageType} from '../../render/webgl/constants.js';\nimport {\n  apply as applyTransform,\n  create as createTransform,\n  makeInverse as makeInverseTransform,\n  multiply as multiplyTransform,\n  translate as translateTransform,\n} from '../../transform.js';\nimport {assert} from '../../asserts.js';\nimport {buffer, createEmpty, equals, getWidth} from '../../extent.js';\nimport {colorDecodeId, colorEncodeId} from '../../render/webgl/utils.js';\nimport {create as createWebGLWorker} from '../../worker/webgl.js';\nimport {getUid} from '../../util.js';\nimport {listen, unlistenByKey} from '../../events.js';\n\n/**\n * @typedef {Object} CustomAttribute A description of a custom attribute to be passed on to the GPU, with a value different\n * for each feature.\n * @property {string} name Attribute name.\n * @property {function(import(\"../../Feature\").default, Object<string, *>):number} callback This callback computes the numerical value of the\n * attribute for a given feature (properties are available as 2nd arg for quicker access).\n */\n\n/**\n * @typedef {Object} FeatureCacheItem Object that holds a reference to a feature, its geometry and properties. Used to optimize\n * rebuildBuffers by accessing these objects quicker.\n * @property {import(\"../../Feature\").default} feature Feature\n * @property {Object<string, *>} properties Feature properties\n * @property {import(\"../../geom\").Geometry} geometry Feature geometry\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the canvas element.\n * @property {Array<CustomAttribute>} [attributes] These attributes will be read from the features in the source and then\n * passed to the GPU. The `name` property of each attribute will serve as its identifier:\n *  * In the vertex shader as an `attribute` by prefixing it with `a_`\n *  * In the fragment shader as a `varying` by prefixing it with `v_`\n * Please note that these can only be numerical values.\n * @property {string} vertexShader Vertex shader source, mandatory.\n * @property {string} fragmentShader Fragment shader source, mandatory.\n * @property {string} [hitVertexShader] Vertex shader source for hit detection rendering.\n * @property {string} [hitFragmentShader] Fragment shader source for hit detection rendering.\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process steps\n * Please note that `u_texture` is reserved for the main texture slot and `u_opacity` is reserved for the layer opacity.\n * @property {Array<import(\"./Layer\").PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n\n/**\n * @classdesc\n * WebGL vector renderer optimized for points.\n * All features will be rendered as quads (two triangles forming a square). New data will be flushed to the GPU\n * every time the vector source changes.\n *\n * You need to provide vertex and fragment shaders for rendering. This can be done using\n * {@link module:ol/webgl/ShaderBuilder~ShaderBuilder} utilities. These shaders shall expect a `a_position` attribute\n * containing the screen-space projected center of the quad, as well as a `a_index` attribute\n * whose value (0, 1, 2 or 3) indicates which quad vertex is currently getting processed (see structure below).\n *\n * To include variable attributes in the shaders, you need to declare them using the `attributes` property of\n * the options object like so:\n * ```js\n * new WebGLPointsLayerRenderer(layer, {\n *   attributes: [\n *     {\n *       name: 'size',\n *       callback: function(feature) {\n *         // compute something with the feature\n *       }\n *     },\n *     {\n *       name: 'weight',\n *       callback: function(feature) {\n *         // compute something with the feature\n *       }\n *     },\n *   ],\n *   vertexShader:\n *     // shader using attribute a_weight and a_size\n *   fragmentShader:\n *     // shader using varying v_weight and v_size\n * ```\n *\n * To enable hit detection, you must as well provide dedicated shaders using the `hitVertexShader`\n * and `hitFragmentShader` properties. These shall expect the `a_hitColor` attribute to contain\n * the final color that will have to be output for hit detection to work.\n *\n * The following uniform is used for the main texture: `u_texture`.\n * The following uniform is used for the layer opacity: `u_opacity`.\n *\n * Please note that the main shader output should have premultiplied alpha, otherwise visual anomalies may occur.\n *\n * Points are rendered as quads with the following structure:\n *\n * ```\n *   (u0, v1)      (u1, v1)\n *  [3]----------[2]\n *   |`           |\n *   |  `         |\n *   |    `       |\n *   |      `     |\n *   |        `   |\n *   |          ` |\n *  [0]----------[1]\n *   (u0, v0)      (u1, v0)\n *  ```\n *\n * This uses {@link module:ol/webgl/Helper~WebGLHelper} internally.\n *\n * @api\n */\nclass WebGLPointsLayerRenderer extends WebGLLayerRenderer {\n  /**\n   * @param {import(\"../../layer/Layer.js\").default} layer Layer.\n   * @param {Options} options Options.\n   */\n  constructor(layer, options) {\n    const uniforms = options.uniforms || {};\n    const projectionMatrixTransform = createTransform();\n    uniforms[DefaultUniform.PROJECTION_MATRIX] = projectionMatrixTransform;\n\n    super(layer, {\n      uniforms: uniforms,\n      postProcesses: options.postProcesses,\n    });\n\n    this.sourceRevision_ = -1;\n\n    this.verticesBuffer_ = new WebGLArrayBuffer(ARRAY_BUFFER, DYNAMIC_DRAW);\n    this.hitVerticesBuffer_ = new WebGLArrayBuffer(ARRAY_BUFFER, DYNAMIC_DRAW);\n    this.indicesBuffer_ = new WebGLArrayBuffer(\n      ELEMENT_ARRAY_BUFFER,\n      DYNAMIC_DRAW\n    );\n\n    /**\n     * @private\n     */\n    this.vertexShader_ = options.vertexShader;\n\n    /**\n     * @private\n     */\n    this.fragmentShader_ = options.fragmentShader;\n\n    /**\n     * @type {WebGLProgram}\n     * @private\n     */\n    this.program_;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hitDetectionEnabled_ =\n      options.hitFragmentShader && options.hitVertexShader ? true : false;\n\n    /**\n     * @private\n     */\n    this.hitVertexShader_ = options.hitVertexShader;\n\n    /**\n     * @private\n     */\n    this.hitFragmentShader_ = options.hitFragmentShader;\n\n    /**\n     * @type {WebGLProgram}\n     * @private\n     */\n    this.hitProgram_;\n\n    const customAttributes = options.attributes\n      ? options.attributes.map(function (attribute) {\n          return {\n            name: 'a_' + attribute.name,\n            size: 1,\n            type: AttributeType.FLOAT,\n          };\n        })\n      : [];\n\n    /**\n     * A list of attributes used by the renderer. By default only the position and\n     * index of the vertex (0 to 3) are required.\n     * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n     */\n    this.attributes = [\n      {\n        name: 'a_position',\n        size: 2,\n        type: AttributeType.FLOAT,\n      },\n      {\n        name: 'a_index',\n        size: 1,\n        type: AttributeType.FLOAT,\n      },\n    ].concat(customAttributes);\n\n    /**\n     * A list of attributes used for hit detection.\n     * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n     */\n    this.hitDetectionAttributes = [\n      {\n        name: 'a_position',\n        size: 2,\n        type: AttributeType.FLOAT,\n      },\n      {\n        name: 'a_index',\n        size: 1,\n        type: AttributeType.FLOAT,\n      },\n      {\n        name: 'a_hitColor',\n        size: 4,\n        type: AttributeType.FLOAT,\n      },\n      {\n        name: 'a_featureUid',\n        size: 1,\n        type: AttributeType.FLOAT,\n      },\n    ].concat(customAttributes);\n\n    this.customAttributes = options.attributes ? options.attributes : [];\n\n    this.previousExtent_ = createEmpty();\n\n    /**\n     * This transform is updated on every frame and is the composition of:\n     * - invert of the world->screen transform that was used when rebuilding buffers (see `this.renderTransform_`)\n     * - current world->screen transform\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.currentTransform_ = projectionMatrixTransform;\n\n    /**\n     * This transform is updated when buffers are rebuilt and converts world space coordinates to screen space\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.renderTransform_ = createTransform();\n\n    /**\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.invertRenderTransform_ = createTransform();\n\n    /**\n     * @type {Float32Array}\n     * @private\n     */\n    this.renderInstructions_ = new Float32Array(0);\n\n    /**\n     * These instructions are used for hit detection\n     * @type {Float32Array}\n     * @private\n     */\n    this.hitRenderInstructions_ = new Float32Array(0);\n\n    /**\n     * @type {WebGLRenderTarget}\n     * @private\n     */\n    this.hitRenderTarget_;\n\n    /**\n     * Keep track of latest message sent to worker\n     * @type {number}\n     * @private\n     */\n    this.lastSentId = 0;\n\n    /**\n     * @private\n     */\n    this.worker_ = createWebGLWorker();\n\n    this.worker_.addEventListener(\n      'message',\n      /**\n       * @param {*} event Event.\n       */\n      (event) => {\n        const received = event.data;\n        if (received.type === WebGLWorkerMessageType.GENERATE_POINT_BUFFERS) {\n          const projectionTransform = received.projectionTransform;\n          if (received.hitDetection) {\n            this.hitVerticesBuffer_.fromArrayBuffer(received.vertexBuffer);\n            this.helper.flushBufferData(this.hitVerticesBuffer_);\n          } else {\n            this.verticesBuffer_.fromArrayBuffer(received.vertexBuffer);\n            this.helper.flushBufferData(this.verticesBuffer_);\n          }\n          this.indicesBuffer_.fromArrayBuffer(received.indexBuffer);\n          this.helper.flushBufferData(this.indicesBuffer_);\n\n          this.renderTransform_ = projectionTransform;\n          makeInverseTransform(\n            this.invertRenderTransform_,\n            this.renderTransform_\n          );\n          if (received.hitDetection) {\n            this.hitRenderInstructions_ = new Float32Array(\n              event.data.renderInstructions\n            );\n          } else {\n            this.renderInstructions_ = new Float32Array(\n              event.data.renderInstructions\n            );\n            if (received.id === this.lastSentId) {\n              this.ready = true;\n            }\n          }\n\n          this.getLayer().changed();\n        }\n      }\n    );\n\n    /**\n     * This object will be updated when the source changes. Key is uid.\n     * @type {Object<string, FeatureCacheItem>}\n     * @private\n     */\n    this.featureCache_ = {};\n\n    /**\n     * Amount of features in the cache.\n     * @type {number}\n     * @private\n     */\n    this.featureCount_ = 0;\n\n    const source = this.getLayer().getSource();\n    this.sourceListenKeys_ = [\n      listen(\n        source,\n        VectorEventType.ADDFEATURE,\n        this.handleSourceFeatureAdded_,\n        this\n      ),\n      listen(\n        source,\n        VectorEventType.CHANGEFEATURE,\n        this.handleSourceFeatureChanged_,\n        this\n      ),\n      listen(\n        source,\n        VectorEventType.REMOVEFEATURE,\n        this.handleSourceFeatureDelete_,\n        this\n      ),\n      listen(\n        source,\n        VectorEventType.CLEAR,\n        this.handleSourceFeatureClear_,\n        this\n      ),\n    ];\n    source.forEachFeature((feature) => {\n      this.featureCache_[getUid(feature)] = {\n        feature: feature,\n        properties: feature.getProperties(),\n        geometry: feature.getGeometry(),\n      };\n      this.featureCount_++;\n    });\n  }\n\n  afterHelperCreated() {\n    this.program_ = this.helper.getProgram(\n      this.fragmentShader_,\n      this.vertexShader_\n    );\n\n    if (this.hitDetectionEnabled_) {\n      this.hitProgram_ = this.helper.getProgram(\n        this.hitFragmentShader_,\n        this.hitVertexShader_\n      );\n\n      this.hitRenderTarget_ = new WebGLRenderTarget(this.helper);\n    }\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureAdded_(event) {\n    const feature = event.feature;\n    this.featureCache_[getUid(feature)] = {\n      feature: feature,\n      properties: feature.getProperties(),\n      geometry: feature.getGeometry(),\n    };\n    this.featureCount_++;\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureChanged_(event) {\n    const feature = event.feature;\n    this.featureCache_[getUid(feature)] = {\n      feature: feature,\n      properties: feature.getProperties(),\n      geometry: feature.getGeometry(),\n    };\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureDelete_(event) {\n    const feature = event.feature;\n    delete this.featureCache_[getUid(feature)];\n    this.featureCount_--;\n  }\n\n  /**\n   * @private\n   */\n  handleSourceFeatureClear_() {\n    this.featureCache_ = {};\n    this.featureCount_ = 0;\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState) {\n    const gl = this.helper.getGL();\n    this.preRender(gl, frameState);\n\n    const projection = frameState.viewState.projection;\n    const layer = this.getLayer();\n    const vectorSource = layer.getSource();\n    // FIXME fix hit detection isn't reliable when rendering multiple worlds\n    const multiWorld = vectorSource.getWrapX() && projection.canWrapX();\n    const projectionExtent = projection.getExtent();\n\n    const extent = frameState.extent;\n    const worldWidth = multiWorld ? getWidth(projectionExtent) : null;\n    const endWorld = multiWorld\n      ? Math.ceil((extent[2] - projectionExtent[2]) / worldWidth) + 1\n      : 1;\n\n    const startWorld = multiWorld\n      ? Math.floor((extent[0] - projectionExtent[0]) / worldWidth)\n      : 0;\n\n    let world = startWorld;\n    const renderCount = this.indicesBuffer_.getSize();\n\n    do {\n      // apply the current projection transform with the invert of the one used to fill buffers\n      this.helper.makeProjectionTransform(frameState, this.currentTransform_);\n      translateTransform(this.currentTransform_, world * worldWidth, 0);\n      multiplyTransform(this.currentTransform_, this.invertRenderTransform_);\n      this.helper.applyUniforms(frameState);\n\n      this.helper.drawElements(0, renderCount);\n    } while (++world < endWorld);\n\n    this.helper.finalizeDraw(\n      frameState,\n      this.dispatchPreComposeEvent,\n      this.dispatchPostComposeEvent\n    );\n    const canvas = this.helper.getCanvas();\n\n    if (this.hitDetectionEnabled_) {\n      this.renderHitDetection(frameState, startWorld, endWorld, worldWidth);\n      this.hitRenderTarget_.clearCachedData();\n    }\n\n    this.postRender(gl, frameState);\n\n    return canvas;\n  }\n\n  /**\n   * Determine whether renderFrame should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrameInternal(frameState) {\n    const layer = this.getLayer();\n    const vectorSource = layer.getSource();\n    const viewState = frameState.viewState;\n    const viewNotMoving =\n      !frameState.viewHints[ViewHint.ANIMATING] &&\n      !frameState.viewHints[ViewHint.INTERACTING];\n    const extentChanged = !equals(this.previousExtent_, frameState.extent);\n    const sourceChanged = this.sourceRevision_ < vectorSource.getRevision();\n\n    if (sourceChanged) {\n      this.sourceRevision_ = vectorSource.getRevision();\n    }\n\n    if (viewNotMoving && (extentChanged || sourceChanged)) {\n      const projection = viewState.projection;\n      const resolution = viewState.resolution;\n\n      const renderBuffer =\n        layer instanceof BaseVector ? layer.getRenderBuffer() : 0;\n      const extent = buffer(frameState.extent, renderBuffer * resolution);\n      vectorSource.loadFeatures(extent, resolution, projection);\n\n      this.rebuildBuffers_(frameState);\n      this.previousExtent_ = frameState.extent.slice();\n    }\n\n    this.helper.useProgram(this.program_, frameState);\n    this.helper.prepareDraw(frameState);\n\n    // write new data\n    this.helper.bindBuffer(this.verticesBuffer_);\n    this.helper.bindBuffer(this.indicesBuffer_);\n    this.helper.enableAttributes(this.attributes);\n\n    return true;\n  }\n\n  /**\n   * Rebuild internal webgl buffers based on current view extent; costly, should not be called too much\n   * @param {import(\"../../Map\").FrameState} frameState Frame state.\n   * @private\n   */\n  rebuildBuffers_(frameState) {\n    // saves the projection transform for the current frame state\n    const projectionTransform = createTransform();\n    this.helper.makeProjectionTransform(frameState, projectionTransform);\n\n    // here we anticipate the amount of render instructions that we well generate\n    // this can be done since we know that for normal render we only have x, y as base instructions,\n    // and x, y, r, g, b, a and featureUid for hit render instructions\n    // and we also know the amount of custom attributes to append to these\n    const totalInstructionsCount =\n      (2 + this.customAttributes.length) * this.featureCount_;\n    if (\n      !this.renderInstructions_ ||\n      this.renderInstructions_.length !== totalInstructionsCount\n    ) {\n      this.renderInstructions_ = new Float32Array(totalInstructionsCount);\n    }\n    if (this.hitDetectionEnabled_) {\n      const totalHitInstructionsCount =\n        (7 + this.customAttributes.length) * this.featureCount_;\n      if (\n        !this.hitRenderInstructions_ ||\n        this.hitRenderInstructions_.length !== totalHitInstructionsCount\n      ) {\n        this.hitRenderInstructions_ = new Float32Array(\n          totalHitInstructionsCount\n        );\n      }\n    }\n\n    // loop on features to fill the buffer\n    let featureCache, geometry;\n    const tmpCoords = [];\n    const tmpColor = [];\n    let renderIndex = 0;\n    let hitIndex = 0;\n    let hitColor;\n    for (const featureUid in this.featureCache_) {\n      featureCache = this.featureCache_[featureUid];\n      geometry = /** @type {import(\"../../geom\").Point} */ (\n        featureCache.geometry\n      );\n      if (!geometry || geometry.getType() !== 'Point') {\n        continue;\n      }\n\n      tmpCoords[0] = geometry.getFlatCoordinates()[0];\n      tmpCoords[1] = geometry.getFlatCoordinates()[1];\n      applyTransform(projectionTransform, tmpCoords);\n\n      hitColor = colorEncodeId(hitIndex + 6, tmpColor);\n\n      this.renderInstructions_[renderIndex++] = tmpCoords[0];\n      this.renderInstructions_[renderIndex++] = tmpCoords[1];\n\n      // for hit detection, the feature uid is saved in the opacity value\n      // and the index of the opacity value is encoded in the color values\n      if (this.hitDetectionEnabled_) {\n        this.hitRenderInstructions_[hitIndex++] = tmpCoords[0];\n        this.hitRenderInstructions_[hitIndex++] = tmpCoords[1];\n        this.hitRenderInstructions_[hitIndex++] = hitColor[0];\n        this.hitRenderInstructions_[hitIndex++] = hitColor[1];\n        this.hitRenderInstructions_[hitIndex++] = hitColor[2];\n        this.hitRenderInstructions_[hitIndex++] = hitColor[3];\n        this.hitRenderInstructions_[hitIndex++] = Number(featureUid);\n      }\n\n      // pushing custom attributes\n      let value;\n      for (let j = 0; j < this.customAttributes.length; j++) {\n        value = this.customAttributes[j].callback(\n          featureCache.feature,\n          featureCache.properties\n        );\n        this.renderInstructions_[renderIndex++] = value;\n        if (this.hitDetectionEnabled_) {\n          this.hitRenderInstructions_[hitIndex++] = value;\n        }\n      }\n    }\n\n    /** @type {import('../../render/webgl/constants.js').WebGLWorkerGenerateBuffersMessage} */\n    const message = {\n      id: ++this.lastSentId,\n      type: WebGLWorkerMessageType.GENERATE_POINT_BUFFERS,\n      renderInstructions: this.renderInstructions_.buffer,\n      customAttributesSize: this.customAttributes.length,\n    };\n    // additional properties will be sent back as-is by the worker\n    message['projectionTransform'] = projectionTransform;\n    this.ready = false;\n    this.worker_.postMessage(message, [this.renderInstructions_.buffer]);\n    this.renderInstructions_ = null;\n\n    /** @type {import('../../render/webgl/constants.js').WebGLWorkerGenerateBuffersMessage} */\n    if (this.hitDetectionEnabled_) {\n      const hitMessage = {\n        id: 0,\n        type: WebGLWorkerMessageType.GENERATE_POINT_BUFFERS,\n        renderInstructions: this.hitRenderInstructions_.buffer,\n        customAttributesSize: 5 + this.customAttributes.length,\n      };\n      hitMessage['projectionTransform'] = projectionTransform;\n      hitMessage['hitDetection'] = true;\n      this.worker_.postMessage(hitMessage, [\n        this.hitRenderInstructions_.buffer,\n      ]);\n      this.hitRenderInstructions_ = null;\n    }\n  }\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches\n  ) {\n    assert(this.hitDetectionEnabled_, 66);\n    if (!this.hitRenderInstructions_) {\n      return undefined;\n    }\n\n    const pixel = applyTransform(\n      frameState.coordinateToPixelTransform,\n      coordinate.slice()\n    );\n\n    const data = this.hitRenderTarget_.readPixel(pixel[0] / 2, pixel[1] / 2);\n    const color = [data[0] / 255, data[1] / 255, data[2] / 255, data[3] / 255];\n    const index = colorDecodeId(color);\n    const opacity = this.hitRenderInstructions_[index];\n    const uid = Math.floor(opacity).toString();\n\n    const source = this.getLayer().getSource();\n    const feature = source.getFeatureByUid(uid);\n    if (feature) {\n      return callback(feature, this.getLayer(), null);\n    }\n    return undefined;\n  }\n\n  /**\n   * Render the hit detection data to the corresponding render target\n   * @param {import(\"../../Map.js\").FrameState} frameState current frame state\n   * @param {number} startWorld the world to render in the first iteration\n   * @param {number} endWorld the last world to render\n   * @param {number} worldWidth the width of the worlds being rendered\n   */\n  renderHitDetection(frameState, startWorld, endWorld, worldWidth) {\n    // skip render entirely if vertex buffers not ready/generated yet\n    if (!this.hitVerticesBuffer_.getSize()) {\n      return;\n    }\n\n    let world = startWorld;\n\n    this.hitRenderTarget_.setSize([\n      Math.floor(frameState.size[0] / 2),\n      Math.floor(frameState.size[1] / 2),\n    ]);\n\n    this.helper.useProgram(this.hitProgram_, frameState);\n    this.helper.prepareDrawToRenderTarget(\n      frameState,\n      this.hitRenderTarget_,\n      true\n    );\n\n    this.helper.bindBuffer(this.hitVerticesBuffer_);\n    this.helper.bindBuffer(this.indicesBuffer_);\n    this.helper.enableAttributes(this.hitDetectionAttributes);\n\n    do {\n      this.helper.makeProjectionTransform(frameState, this.currentTransform_);\n      translateTransform(this.currentTransform_, world * worldWidth, 0);\n      multiplyTransform(this.currentTransform_, this.invertRenderTransform_);\n      this.helper.applyUniforms(frameState);\n\n      const renderCount = this.indicesBuffer_.getSize();\n      this.helper.drawElements(0, renderCount);\n    } while (++world < endWorld);\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    this.worker_.terminate();\n    this.layer_ = null;\n    this.sourceListenKeys_.forEach(function (key) {\n      unlistenByKey(key);\n    });\n    this.sourceListenKeys_ = null;\n    super.disposeInternal();\n  }\n}\n\nexport default WebGLPointsLayerRenderer;\n"],"names":["MapRenderer","Disposable","constructor","map","super","this","map_","dispatchRenderEvent","type","frameState","calculateMatrices2D","viewState","coordinateToPixelTransform","pixelToCoordinateTransform","size","resolution","rotation","center","forEachFeatureAtCoordinate","coordinate","hitTolerance","checkWrapped","callback","thisArg","layerFilter","thisArg2","result","managed","feature","layer","geometry","call","projection","translatedCoordinate","slice","offsets","canWrapX","projectionExtent","getExtent","worldWidth","push","layerStates","layerStatesArray","numLayers","length","matches","tmpCoord","i","j","layerState","hasRenderer","layerRenderer","getRenderer","source","getSource","coordinates","getWrapX","bind","order","forEach","m","distanceSq","sort","a","b","some","hasFeatureAtCoordinate","hasFeature","undefined","getMap","renderFrame","scheduleExpireIconCache","canExpireCache","postRenderFunctions","expireIconCache","expire","CompositeMapRenderer","Map","fontChangeListenerKey_","ObjectEventType","PROPERTYCHANGE","redrawText","element_","document","createElement","style","position","width","height","zIndex","className","container","getViewport","insertBefore","firstChild","children_","renderedVisible_","hasListener","event","dispatchEvent","disposeInternal","parentNode","removeChild","display","PRECOMPOSE","declutterLayers","previousElement","ii","layerIndex","sourceState","getSourceState","unrender","element","render","renderDeclutter","POSTCOMPOSE","LayerRenderer","ready","boundHandleImageChange_","handleImageChange_","layer_","declutterExecutorGroup","getFeatures","pixel","getData","prepareFrame","target","loadedTileCallback","tiles","zoom","tile","tileCoord","toString","createLoadedTileFinder","tileRange","forEachLoadedTile","getLayer","handleFontsChanged","image","getState","LOADED","renderIfReadyAndVisible","loadImage","imageState","ERROR","addEventListener","CHANGE","IDLE","load","getVisible","changed","CanvasImageLayerRenderer","imageLayer","image_","getImage","pixelRatio","viewResolution","imageSource","hints","viewHints","renderedExtent","extent","fromUserExtent","ANIMATING","INTERACTING","EMPTY","layerExtent","imageExtent","img","imageMapWidth","col","Math","floor","imageMapHeight","row","getImageData","imageResolution","getResolution","imagePixelRatio","getPixelRatio","viewCenter","scale","round","pixelTransform","inversePixelTransform","canvasTransform","useContainer","getBackground","context","canvas","containerReused","clearRect","clipped","clipUnrotated","transform","tempTransform","renderedResolution","dw","dh","getInterpolate","imageSmoothingEnabled","preRender","dx","dy","opacity","previousAlpha","globalAlpha","drawImage","postRender","restore","canvasPool","pixelContext","createPixelContext","willReadFrequently","CanvasLayerRenderer","pixelContext_","data","err","background","backgroundColor","layerClassName","getClassName","firstElementChild","HTMLCanvasElement","getContext","appendChild","left","transformOrigin","topLeft","topRight","bottomRight","bottomLeft","inverted","save","beginPath","moveTo","lineTo","clip","dispatchRenderEvent_","PRERENDER","POSTRENDER","getRenderTransform","offsetX","dx1","dy1","sx","sy","dx2","dy2","CanvasTileLayerRenderer","tileLayer","extentChanged","renderedExtent_","renderedPixelRatio","renderedProjection","renderedRevision","renderedTiles","newTiles_","tmpExtent","tmpTileRange_","isDrawableTile","tileState","useInterimTilesOnError","getUseInterimTilesOnError","getTile","z","x","y","tileSource","getPreload","getInterimTile","getRenderSource","tileGrid","getTileGridForProjection","tilePixelRatio","getTilePixelRatio","getZForResolution","getMinZoom","getTileCoordForCoordAndZ","tileOrigin","getOrigin","tileSize","getTileSize","tileResolution","gutter","getGutterForProjection","sourceRevision","getRevision","zDirection","canvasExtent","getTileRangeForExtentAndZ","tilesToDrawByZ","findLoadedTiles","tmpTileRange","viewport","minX","maxX","minY","maxY","tileCoordIntersectsViewport","uid","inTransition","endTransition","includes","getAlpha","time","childTileRange","getTileCoordChildTileRange","covered","forEachTileCoordParentTileRange","canvasScale","clips","clipZs","currentClip","zs","Object","keys","Number","getOpaque","reverse","currentZ","currentTilePixelSize","getTilePixelSize","currentResolution","currentScale","originTileCoord","originTileExtent","getTileCoordExtent","origin","tileGutter","tilesToDraw","tileCoordKey","xIndex","nextX","yIndex","nextY","w","h","transition","contextSaved","drawTileImage","unshift","updateUsedTiles","usedTiles","manageTilePyramid","scheduleExpireCache","getTileImage","alpha","alphaChanged","animate","postRenderFunction","tileSourceKey","expireCache","getKey","preload","tileCallback","wantedTiles","tileQueue","minZoom","tileCount","isKeyQueued","enqueue","getTileCoordCenter","useTile","updateCacheSize","CanvasVectorLayerRenderer","vectorLayer","boundHandleStyleImageChange_","handleStyleImageChange_","animatingOrInteracting_","hitDetectionImageData_","renderedFeatures_","renderedRevision_","renderedResolution_","NaN","wrappedRenderedExtent_","renderedRotation_","renderedCenter_","renderedProjection_","renderedRenderOrder_","replayGroup_","replayGroupChanged","clipping","compositionContext_","opacity_","renderWorlds","executorGroup","declutterTree","vectorSource","snapToPixel","multiWorld","endWorld","ceil","world","execute","setupCompositionContext_","compositionContext","releaseCompositionContext_","replayGroup","isEmpty","Promise","resolve","transforms","startX","getStyleFunction","features","featureCallback","key","match","splice","lastIndexOf","executorGroups","all","item","value","animating","interacting","updateWhileAnimating","getUpdateWhileAnimating","updateWhileInteracting","getUpdateWhileInteracting","frameStateExtent","vectorLayerRevision","vectorLayerRenderBuffer","getRenderBuffer","vectorLayerRenderOrder","getRenderOrder","loadExtents","max","loadExtent","declutterBuilderGroup","getDeclutter","userProjection","getUserProjection","userTransform","userExtent","toUserExtent","loadFeatures","toUserResolution","getTransformFromProjections","squaredTolerance","styles","styleFunction","dirty","renderFeature","getFeaturesInExtent","replayGroupInstructions","finish","getOverlaps","builderGroup","loading","Array","isArray","IMAGE_REPLAYS","VECTOR_REPLAYS","CanvasVectorTileLayerRenderer","renderedLayerRevision_","renderedPixelToCoordinateTransform_","tmpTransform_","prepareTile","state","updateExecutorGroup_","tileImageNeedsRender_","hifi","wantedResolution","Date","now","getRenderMode","renderTileImage_","hasContext","layerRevision","revision","renderOrder","builderState","getReplayState","renderedRenderOrder","declutter","sourceTileGrid","getTileGrid","tileExtent","wrappedTileCoord","sourceTiles","getSourceTiles","layerUid","hitDetectionImageData","declutterExecutorGroups","t","tt","sourceTile","sourceTileCoord","sourceTileExtent","sharedExtent","builderExtent","bufferedExtent","getGeometry","executorGroupInstructions","replayExtent","renderingReplayGroup","hitExtent","getId","found","declutteredFeatures","reject","getTileCoordForCoordAndResolution","loadingSourceTiles","corner","tilePixel","reduce","accumulator","concat","getOpacity","getTileRenderTransform","worldOffset","renderMode","replayTypes","filter","group","hasExecutors","getClipCoords","jj","replayState","renderedTileResolution","renderedTileRevision","renderPixelRatio","renderScale","setTransform","apply","pixelScale","SIMPLIFY_TOLERANCE","GEOMETRY_RENDERERS","renderPointGeometry","renderLineStringGeometry","renderPolygonGeometry","renderMultiPointGeometry","renderMultiLineStringGeometry","renderMultiPolygonGeometry","renderGeometryCollectionGeometry","renderCircleGeometry","defaultOrder","feature1","feature2","parseInt","getSquaredTolerance","tolerance","getTolerance","fillStyle","getFill","strokeStyle","getStroke","circleReplay","getBuilder","getZIndex","setFillStrokeStyle","drawCircle","textStyle","getText","textReplay","setTextStyle","drawText","listener","imageStyle","getImageState","unlistenImageChange","listenImageChange","renderFeatureInternal","getGeometryFunction","simplifiedGeometry","simplifyTransformed","renderer","renderGeometry","geometryRenderer","getType","geometries","getGeometries","replay","drawCustom","getHitDetectionRenderer","getGeometriesArray","lineStringReplay","drawLineString","drawMultiLineString","polygonReplay","drawMultiPolygon","declutterImageWithText","imageBuilderGroup","declutterMode","getDeclutterMode","imageReplay","setImageStyle","drawPoint","textBuilderGroup","drawMultiPoint","drawPolygon","WebGLLayerRenderer","options","inversePixelTransform_","postProcesses_","postProcesses","uniforms_","uniforms","helper","addChangeListener","MAP","removeHelper","dispatchPreComposeEvent","dispatchPostComposeEvent","reset","setUniforms","dispose","incrementGroup","groupNumber","canvasCacheKey","mapId","canvasCacheKeyMatches","getCanvas","afterHelperCreated","prepareFrameInternal","WebGLWorkerMessageType","GENERATE_POLYGON_BUFFERS","GENERATE_POINT_BUFFERS","GENERATE_LINE_STRING_BUFFERS","colorEncodeId","id","array","radix","divide","colorDecodeId","color","mult","WebGLPointsLayerRenderer","projectionMatrixTransform","PROJECTION_MATRIX","sourceRevision_","verticesBuffer_","hitVerticesBuffer_","indicesBuffer_","vertexShader_","vertexShader","fragmentShader_","fragmentShader","program_","hitDetectionEnabled_","hitFragmentShader","hitVertexShader","hitVertexShader_","hitFragmentShader_","hitProgram_","customAttributes","attributes","attribute","name","FLOAT","hitDetectionAttributes","previousExtent_","currentTransform_","renderTransform_","invertRenderTransform_","renderInstructions_","Float32Array","hitRenderInstructions_","hitRenderTarget_","lastSentId","worker_","received","projectionTransform","hitDetection","fromArrayBuffer","vertexBuffer","flushBufferData","indexBuffer","renderInstructions","featureCache_","featureCount_","sourceListenKeys_","VectorEventType","ADDFEATURE","handleSourceFeatureAdded_","CHANGEFEATURE","handleSourceFeatureChanged_","REMOVEFEATURE","handleSourceFeatureDelete_","CLEAR","handleSourceFeatureClear_","forEachFeature","properties","getProperties","getProgram","gl","getGL","startWorld","renderCount","getSize","makeProjectionTransform","applyUniforms","drawElements","finalizeDraw","renderHitDetection","clearCachedData","viewNotMoving","ViewHint","sourceChanged","renderBuffer","BaseVector","rebuildBuffers_","useProgram","prepareDraw","bindBuffer","enableAttributes","totalInstructionsCount","totalHitInstructionsCount","featureCache","tmpCoords","tmpColor","hitColor","renderIndex","hitIndex","featureUid","getFlatCoordinates","message","buffer","customAttributesSize","postMessage","hitMessage","readPixel","index","getFeatureByUid","setSize","prepareDrawToRenderTarget","terminate"],"sourceRoot":""}
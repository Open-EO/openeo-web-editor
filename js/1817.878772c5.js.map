{"version":3,"file":"js/1817.878772c5.js","mappings":"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","sources":["webpack://@openeo/web-editor/./node_modules/ol/uri.js","webpack://@openeo/web-editor/./node_modules/ol/tilegrid/WMTS.js","webpack://@openeo/web-editor/./node_modules/ol/source/WMTS.js","webpack://@openeo/web-editor/./node_modules/ol/webgl/styleparser.js","webpack://@openeo/web-editor/./node_modules/ol/layer/WebGLTile.js","webpack://@openeo/web-editor/./node_modules/ol/source/DataTile.js","webpack://@openeo/web-editor/./node_modules/ol/node_modules/geotiff/dist-module/compression/index.js","webpack://@openeo/web-editor/./node_modules/ol/node_modules/geotiff/dist-module/pool.js","webpack://@openeo/web-editor/./node_modules/ol/node_modules/geotiff/dist-module/rgb.js","webpack://@openeo/web-editor/./node_modules/ol/node_modules/geotiff/dist-module/resample.js","webpack://@openeo/web-editor/./node_modules/ol/node_modules/geotiff/dist-module/geotiffimage.js","webpack://@openeo/web-editor/./node_modules/ol/node_modules/geotiff/dist-module/dataview64.js","webpack://@openeo/web-editor/./node_modules/ol/node_modules/geotiff/dist-module/dataslice.js","webpack://@openeo/web-editor/./node_modules/ol/node_modules/geotiff/dist-module/source/httputils.js","webpack://@openeo/web-editor/./node_modules/ol/node_modules/geotiff/dist-module/source/basesource.js","webpack://@openeo/web-editor/./node_modules/ol/node_modules/geotiff/dist-module/utils.js","webpack://@openeo/web-editor/./node_modules/ol/node_modules/geotiff/dist-module/source/blockedsource.js","webpack://@openeo/web-editor/./node_modules/ol/node_modules/geotiff/dist-module/source/client/base.js","webpack://@openeo/web-editor/./node_modules/ol/node_modules/geotiff/dist-module/source/client/fetch.js","webpack://@openeo/web-editor/./node_modules/ol/node_modules/geotiff/dist-module/source/client/xhr.js","webpack://@openeo/web-editor/./node_modules/ol/node_modules/geotiff/dist-module/source/client/http.js","webpack://@openeo/web-editor/./node_modules/ol/node_modules/geotiff/dist-module/source/remote.js","webpack://@openeo/web-editor/./node_modules/ol/node_modules/geotiff/dist-module/source/filereader.js","webpack://@openeo/web-editor/./node_modules/ol/node_modules/geotiff/dist-module/geotiff.js","webpack://@openeo/web-editor/./node_modules/ol/source/GeoTIFF.js","webpack://@openeo/web-editor/./node_modules/ol/node_modules/geotiff/dist-module/globals.js"],"sourcesContent":["/**\n * @module ol/uri\n */\n\n/**\n * Appends query parameters to a URI.\n *\n * @param {string} uri The original URI, which may already have query data.\n * @param {!Object} params An object where keys are URI-encoded parameter keys,\n *     and the values are arbitrary types or arrays.\n * @return {string} The new URI.\n */\nexport function appendParams(uri, params) {\n  /** @type {Array<string>} */\n  const keyParams = [];\n  // Skip any null or undefined parameter values\n  Object.keys(params).forEach(function (k) {\n    if (params[k] !== null && params[k] !== undefined) {\n      keyParams.push(k + '=' + encodeURIComponent(params[k]));\n    }\n  });\n  const qs = keyParams.join('&');\n  // remove any trailing ? or &\n  uri = uri.replace(/[?&]$/, '');\n  // append ? or & depending on whether uri has existing parameters\n  uri += uri.includes('?') ? '&' : '?';\n  return uri + qs;\n}\n","/**\n * @module ol/tilegrid/WMTS\n */\n\nimport TileGrid from './TileGrid.js';\nimport {get as getProjection} from '../proj.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../extent.js\").Extent} [extent] Extent for the tile grid. No tiles\n * outside this extent will be requested by {@link module:ol/source/Tile~TileSource} sources.\n * When no `origin` or `origins` are configured, the `origin` will be set to the\n * top-left corner of the extent.\n * @property {import(\"../coordinate.js\").Coordinate} [origin] The tile grid origin, i.e.\n * where the `x` and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left\n * to right and downwards. If not specified, `extent` or `origins` must be provided.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} [origins] Tile grid origins,\n * i.e. where the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If\n * given, the array length should match the length of the `resolutions` array, i.e.\n * each resolution can have a different origin. Tile coordinates increase left to\n * right and downwards. If not specified, `extent` or `origin` must be provided.\n * @property {!Array<number>} resolutions Resolutions. The array index of each\n * resolution needs to match the zoom level. This means that even if a `minZoom`\n * is configured, the resolutions array will have a length of `maxZoom + 1`\n * @property {!Array<string>} matrixIds matrix IDs. The length of this array needs\n * to match the length of the `resolutions` array.\n * @property {Array<import(\"../size.js\").Size>} [sizes] Number of tile rows and columns\n * of the grid for each zoom level. The values here are the `TileMatrixWidth` and\n * `TileMatrixHeight` advertised in the GetCapabilities response of the WMTS, and\n * define each zoom level's extent together with the `origin` or `origins`.\n * A grid `extent` can be configured in addition, and will further limit the extent for\n * which tile requests are made by sources. If the bottom-left corner of\n * an extent is used as `origin` or `origins`, then the `y` value must be\n * negative because OpenLayers tile coordinates use the top left as the origin.\n * @property {number|import(\"../size.js\").Size} [tileSize] Tile size.\n * @property {Array<number|import(\"../size.js\").Size>} [tileSizes] Tile sizes. The length of\n * this array needs to match the length of the `resolutions` array.\n */\n\n/**\n * @classdesc\n * Set the grid pattern for sources accessing WMTS tiled-image servers.\n * @api\n */\nclass WMTSTileGrid extends TileGrid {\n  /**\n   * @param {Options} options WMTS options.\n   */\n  constructor(options) {\n    super({\n      extent: options.extent,\n      origin: options.origin,\n      origins: options.origins,\n      resolutions: options.resolutions,\n      tileSize: options.tileSize,\n      tileSizes: options.tileSizes,\n      sizes: options.sizes,\n    });\n\n    /**\n     * @private\n     * @type {!Array<string>}\n     */\n    this.matrixIds_ = options.matrixIds;\n  }\n\n  /**\n   * @param {number} z Z.\n   * @return {string} MatrixId..\n   */\n  getMatrixId(z) {\n    return this.matrixIds_[z];\n  }\n\n  /**\n   * Get the list of matrix identifiers.\n   * @return {Array<string>} MatrixIds.\n   * @api\n   */\n  getMatrixIds() {\n    return this.matrixIds_;\n  }\n}\n\nexport default WMTSTileGrid;\n\n/**\n * Create a tile grid from a WMTS capabilities matrix set and an\n * optional TileMatrixSetLimits.\n * @param {Object} matrixSet An object representing a matrixSet in the\n *     capabilities document.\n * @param {import(\"../extent.js\").Extent} [extent] An optional extent to restrict the tile\n *     ranges the server provides.\n * @param {Array<Object>} [matrixLimits] An optional object representing\n *     the available matrices for tileGrid.\n * @return {WMTSTileGrid} WMTS tileGrid instance.\n * @api\n */\nexport function createFromCapabilitiesMatrixSet(\n  matrixSet,\n  extent,\n  matrixLimits,\n) {\n  /** @type {!Array<number>} */\n  const resolutions = [];\n  /** @type {!Array<string>} */\n  const matrixIds = [];\n  /** @type {!Array<import(\"../coordinate.js\").Coordinate>} */\n  const origins = [];\n  /** @type {!Array<number|import(\"../size.js\").Size>} */\n  const tileSizes = [];\n  /** @type {!Array<import(\"../size.js\").Size>} */\n  const sizes = [];\n\n  matrixLimits = matrixLimits !== undefined ? matrixLimits : [];\n\n  const supportedCRSPropName = 'SupportedCRS';\n  const matrixIdsPropName = 'TileMatrix';\n  const identifierPropName = 'Identifier';\n  const scaleDenominatorPropName = 'ScaleDenominator';\n  const topLeftCornerPropName = 'TopLeftCorner';\n  const tileWidthPropName = 'TileWidth';\n  const tileHeightPropName = 'TileHeight';\n\n  const code = matrixSet[supportedCRSPropName];\n  const projection = getProjection(code);\n  const metersPerUnit = projection.getMetersPerUnit();\n  // swap origin x and y coordinates if axis orientation is lat/long\n  const switchOriginXY = projection.getAxisOrientation().substr(0, 2) == 'ne';\n\n  matrixSet[matrixIdsPropName].sort(function (a, b) {\n    return b[scaleDenominatorPropName] - a[scaleDenominatorPropName];\n  });\n\n  matrixSet[matrixIdsPropName].forEach(function (elt) {\n    let matrixAvailable;\n    // use of matrixLimits to filter TileMatrices from GetCapabilities\n    // TileMatrixSet from unavailable matrix levels.\n    if (matrixLimits.length > 0) {\n      matrixAvailable = matrixLimits.find(function (elt_ml) {\n        if (elt[identifierPropName] == elt_ml[matrixIdsPropName]) {\n          return true;\n        }\n        // Fallback for tileMatrix identifiers that don't get prefixed\n        // by their tileMatrixSet identifiers.\n        if (!elt[identifierPropName].includes(':')) {\n          return (\n            matrixSet[identifierPropName] + ':' + elt[identifierPropName] ===\n            elt_ml[matrixIdsPropName]\n          );\n        }\n        return false;\n      });\n    } else {\n      matrixAvailable = true;\n    }\n\n    if (matrixAvailable) {\n      matrixIds.push(elt[identifierPropName]);\n      const resolution =\n        (elt[scaleDenominatorPropName] * 0.28e-3) / metersPerUnit;\n      const tileWidth = elt[tileWidthPropName];\n      const tileHeight = elt[tileHeightPropName];\n      if (switchOriginXY) {\n        origins.push([\n          elt[topLeftCornerPropName][1],\n          elt[topLeftCornerPropName][0],\n        ]);\n      } else {\n        origins.push(elt[topLeftCornerPropName]);\n      }\n      resolutions.push(resolution);\n      tileSizes.push(\n        tileWidth == tileHeight ? tileWidth : [tileWidth, tileHeight],\n      );\n      sizes.push([elt['MatrixWidth'], elt['MatrixHeight']]);\n    }\n  });\n\n  return new WMTSTileGrid({\n    extent: extent,\n    origins: origins,\n    resolutions: resolutions,\n    matrixIds: matrixIds,\n    tileSizes: tileSizes,\n    sizes: sizes,\n  });\n}\n","/**\n * @module ol/source/WMTS\n */\n\nimport TileImage from './TileImage.js';\nimport {appendParams} from '../uri.js';\nimport {containsExtent} from '../extent.js';\nimport {createFromCapabilitiesMatrixSet} from '../tilegrid/WMTS.js';\nimport {createFromTileUrlFunctions, expandUrl} from '../tileurlfunction.js';\nimport {equivalent, get as getProjection, transformExtent} from '../proj.js';\n\n/**\n * Request encoding. One of 'KVP', 'REST'.\n * @typedef {'KVP' | 'REST'} RequestEncoding\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.\n * @property {import(\"../tilegrid/WMTS.js\").default} tileGrid Tile grid.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection. Default is the view projection.\n * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\n * Higher values can increase reprojection performance, but decrease precision.\n * @property {RequestEncoding} [requestEncoding='KVP'] Request encoding.\n * @property {string} layer Layer name as advertised in the WMTS capabilities.\n * @property {string} style Style name as advertised in the WMTS capabilities.\n * @property {typeof import(\"../ImageTile.js\").default} [tileClass]  Class used to instantiate image tiles. Default is {@link module:ol/ImageTile~ImageTile}.\n * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service.\n * For example, if the tile service advertizes 256px by 256px tiles but actually sends 512px\n * by 512px images (for retina/hidpi devices) then `tilePixelRatio`\n * should be set to `2`.\n * @property {string} [format='image/jpeg'] Image format. Only used when `requestEncoding` is `'KVP'`.\n * @property {string} [version='1.0.0'] WMTS version.\n * @property {string} matrixSet Matrix set.\n * @property {!Object} [dimensions] Additional \"dimensions\" for tile requests.\n * This is an object with properties named like the advertised WMTS dimensions.\n * @property {string} [url]  A URL for the service.\n * For the RESTful request encoding, this is a URL\n * template.  For KVP encoding, it is normal URL. A `{?-?}` template pattern,\n * for example `subdomain{a-f}.domain.com`, may be used instead of defining\n * each one separately in the `urls` option.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is\n * ```js\n * function(imageTile, src) {\n *   imageTile.getImage().src = src;\n * };\n * ```\n * @property {Array<string>} [urls] An array of URLs.\n * Requests will be distributed among the URLs in this array.\n * @property {boolean} [wrapX=false] Whether to wrap the world horizontally.\n * @property {number} [transition] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n\n/**\n * @classdesc\n * Layer source for tile data from WMTS servers.\n * @api\n */\nclass WMTS extends TileImage {\n  /**\n   * @param {Options} options WMTS options.\n   */\n  constructor(options) {\n    // TODO: add support for TileMatrixLimits\n\n    const requestEncoding =\n      options.requestEncoding !== undefined ? options.requestEncoding : 'KVP';\n\n    // FIXME: should we create a default tileGrid?\n    // we could issue a getCapabilities xhr to retrieve missing configuration\n    const tileGrid = options.tileGrid;\n\n    let urls = options.urls;\n    if (urls === undefined && options.url !== undefined) {\n      urls = expandUrl(options.url);\n    }\n\n    super({\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      cacheSize: options.cacheSize,\n      crossOrigin: options.crossOrigin,\n      interpolate: options.interpolate,\n      projection: options.projection,\n      reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n      tileClass: options.tileClass,\n      tileGrid: tileGrid,\n      tileLoadFunction: options.tileLoadFunction,\n      tilePixelRatio: options.tilePixelRatio,\n      urls: urls,\n      wrapX: options.wrapX !== undefined ? options.wrapX : false,\n      transition: options.transition,\n      zDirection: options.zDirection,\n    });\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.version_ = options.version !== undefined ? options.version : '1.0.0';\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.format_ = options.format !== undefined ? options.format : 'image/jpeg';\n\n    /**\n     * @private\n     * @type {!Object}\n     */\n    this.dimensions_ =\n      options.dimensions !== undefined ? options.dimensions : {};\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.layer_ = options.layer;\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.matrixSet_ = options.matrixSet;\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.style_ = options.style;\n\n    // FIXME: should we guess this requestEncoding from options.url(s)\n    //        structure? that would mean KVP only if a template is not provided.\n\n    /**\n     * @private\n     * @type {RequestEncoding}\n     */\n    this.requestEncoding_ = requestEncoding;\n\n    this.setKey(this.getKeyForDimensions_());\n\n    if (urls && urls.length > 0) {\n      this.tileUrlFunction = createFromTileUrlFunctions(\n        urls.map(this.createFromWMTSTemplate.bind(this)),\n      );\n    }\n  }\n\n  /**\n   * Set the URLs to use for requests.\n   * URLs may contain OGC conform URL Template Variables: {TileMatrix}, {TileRow}, {TileCol}.\n   * @param {Array<string>} urls URLs.\n   */\n  setUrls(urls) {\n    this.urls = urls;\n    const key = urls.join('\\n');\n    this.setTileUrlFunction(\n      createFromTileUrlFunctions(\n        urls.map(this.createFromWMTSTemplate.bind(this)),\n      ),\n      key,\n    );\n  }\n\n  /**\n   * Get the dimensions, i.e. those passed to the constructor through the\n   * \"dimensions\" option, and possibly updated using the updateDimensions\n   * method.\n   * @return {!Object} Dimensions.\n   * @api\n   */\n  getDimensions() {\n    return this.dimensions_;\n  }\n\n  /**\n   * Return the image format of the WMTS source.\n   * @return {string} Format.\n   * @api\n   */\n  getFormat() {\n    return this.format_;\n  }\n\n  /**\n   * Return the layer of the WMTS source.\n   * @return {string} Layer.\n   * @api\n   */\n  getLayer() {\n    return this.layer_;\n  }\n\n  /**\n   * Return the matrix set of the WMTS source.\n   * @return {string} MatrixSet.\n   * @api\n   */\n  getMatrixSet() {\n    return this.matrixSet_;\n  }\n\n  /**\n   * Return the request encoding, either \"KVP\" or \"REST\".\n   * @return {RequestEncoding} Request encoding.\n   * @api\n   */\n  getRequestEncoding() {\n    return this.requestEncoding_;\n  }\n\n  /**\n   * Return the style of the WMTS source.\n   * @return {string} Style.\n   * @api\n   */\n  getStyle() {\n    return this.style_;\n  }\n\n  /**\n   * Return the version of the WMTS source.\n   * @return {string} Version.\n   * @api\n   */\n  getVersion() {\n    return this.version_;\n  }\n\n  /**\n   * @private\n   * @return {string} The key for the current dimensions.\n   */\n  getKeyForDimensions_() {\n    const res = this.urls ? this.urls.slice(0) : [];\n    for (const key in this.dimensions_) {\n      res.push(key + '-' + this.dimensions_[key]);\n    }\n    return res.join('/');\n  }\n\n  /**\n   * Update the dimensions.\n   * @param {Object} dimensions Dimensions.\n   * @api\n   */\n  updateDimensions(dimensions) {\n    Object.assign(this.dimensions_, dimensions);\n    this.setKey(this.getKeyForDimensions_());\n  }\n\n  /**\n   * @param {string} template Template.\n   * @return {import(\"../Tile.js\").UrlFunction} Tile URL function.\n   */\n  createFromWMTSTemplate(template) {\n    const requestEncoding = this.requestEncoding_;\n\n    // context property names are lower case to allow for a case insensitive\n    // replacement as some services use different naming conventions\n    const context = {\n      'layer': this.layer_,\n      'style': this.style_,\n      'tilematrixset': this.matrixSet_,\n    };\n\n    if (requestEncoding == 'KVP') {\n      Object.assign(context, {\n        'Service': 'WMTS',\n        'Request': 'GetTile',\n        'Version': this.version_,\n        'Format': this.format_,\n      });\n    }\n\n    // TODO: we may want to create our own appendParams function so that params\n    // order conforms to wmts spec guidance, and so that we can avoid to escape\n    // special template params\n\n    template =\n      requestEncoding == 'KVP'\n        ? appendParams(template, context)\n        : template.replace(/\\{(\\w+?)\\}/g, function (m, p) {\n            return p.toLowerCase() in context ? context[p.toLowerCase()] : m;\n          });\n\n    const tileGrid = /** @type {import(\"../tilegrid/WMTS.js\").default} */ (\n      this.tileGrid\n    );\n    const dimensions = this.dimensions_;\n\n    return (\n      /**\n       * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n       * @param {number} pixelRatio Pixel ratio.\n       * @param {import(\"../proj/Projection.js\").default} projection Projection.\n       * @return {string|undefined} Tile URL.\n       */\n      function (tileCoord, pixelRatio, projection) {\n        if (!tileCoord) {\n          return undefined;\n        }\n        const localContext = {\n          'TileMatrix': tileGrid.getMatrixId(tileCoord[0]),\n          'TileCol': tileCoord[1],\n          'TileRow': tileCoord[2],\n        };\n        Object.assign(localContext, dimensions);\n        let url = template;\n        if (requestEncoding == 'KVP') {\n          url = appendParams(url, localContext);\n        } else {\n          url = url.replace(/\\{(\\w+?)\\}/g, function (m, p) {\n            return localContext[p];\n          });\n        }\n        return url;\n      }\n    );\n  }\n}\n\nexport default WMTS;\n\n/**\n * Generate source options from a capabilities object.\n * @param {Object} wmtsCap An object representing the capabilities document.\n * @param {!Object} config Configuration properties for the layer.  Defaults for\n *                  the layer will apply if not provided.\n *\n * Required config properties:\n *  - layer - {string} The layer identifier.\n *\n * Optional config properties:\n *  - matrixSet - {string} The matrix set identifier, required if there is\n *       more than one matrix set in the layer capabilities.\n *  - projection - {string} The desired CRS when no matrixSet is specified.\n *       eg: \"EPSG:3857\". If the desired projection is not available,\n *       an error is thrown.\n *  - requestEncoding - {string} url encoding format for the layer. Default is\n *       the first tile url format found in the GetCapabilities response.\n *  - style - {string} The name of the style\n *  - format - {string} Image format for the layer. Default is the first\n *       format returned in the GetCapabilities response.\n *  - crossOrigin - {string|null|undefined} Cross origin. Default is `undefined`.\n * @return {Options|null} WMTS source options object or `null` if the layer was not found.\n * @api\n */\nexport function optionsFromCapabilities(wmtsCap, config) {\n  const layers = wmtsCap['Contents']['Layer'];\n  const l = layers?.find(function (elt) {\n    return elt['Identifier'] == config['layer'];\n  });\n  if (!l) {\n    return null;\n  }\n  const tileMatrixSets = wmtsCap['Contents']['TileMatrixSet'];\n  let idx;\n  if (l['TileMatrixSetLink'].length > 1) {\n    if ('projection' in config) {\n      idx = l['TileMatrixSetLink'].findIndex(function (elt) {\n        const tileMatrixSet = tileMatrixSets.find(function (el) {\n          return el['Identifier'] == elt['TileMatrixSet'];\n        });\n        const supportedCRS = tileMatrixSet['SupportedCRS'];\n        const proj1 = getProjection(supportedCRS);\n        const proj2 = getProjection(config['projection']);\n        if (proj1 && proj2) {\n          return equivalent(proj1, proj2);\n        }\n        return supportedCRS == config['projection'];\n      });\n    } else {\n      idx = l['TileMatrixSetLink'].findIndex(function (elt) {\n        return elt['TileMatrixSet'] == config['matrixSet'];\n      });\n    }\n  } else {\n    idx = 0;\n  }\n  if (idx < 0) {\n    idx = 0;\n  }\n  const matrixSet =\n    /** @type {string} */\n    (l['TileMatrixSetLink'][idx]['TileMatrixSet']);\n  const matrixLimits =\n    /** @type {Array<Object>} */\n    (l['TileMatrixSetLink'][idx]['TileMatrixSetLimits']);\n\n  let format = /** @type {string} */ (l['Format'][0]);\n  if ('format' in config) {\n    format = config['format'];\n  }\n  idx = l['Style'].findIndex(function (elt) {\n    if ('style' in config) {\n      return elt['Title'] == config['style'];\n    }\n    return elt['isDefault'];\n  });\n  if (idx < 0) {\n    idx = 0;\n  }\n  const style = /** @type {string} */ (l['Style'][idx]['Identifier']);\n\n  const dimensions = {};\n  if ('Dimension' in l) {\n    l['Dimension'].forEach(function (elt, index, array) {\n      const key = elt['Identifier'];\n      let value = elt['Default'];\n      if (value === undefined) {\n        value = elt['Value'][0];\n      }\n      dimensions[key] = value;\n    });\n  }\n\n  const matrixSets = wmtsCap['Contents']['TileMatrixSet'];\n  const matrixSetObj = matrixSets.find(function (elt) {\n    return elt['Identifier'] == matrixSet;\n  });\n\n  let projection;\n  const code = matrixSetObj['SupportedCRS'];\n  if (code) {\n    projection = getProjection(code);\n  }\n  if ('projection' in config) {\n    const projConfig = getProjection(config['projection']);\n    if (projConfig) {\n      if (!projection || equivalent(projConfig, projection)) {\n        projection = projConfig;\n      }\n    }\n  }\n\n  let wrapX = false;\n  const switchXY = projection.getAxisOrientation().substr(0, 2) == 'ne';\n\n  let matrix = matrixSetObj.TileMatrix[0];\n\n  // create default matrixLimit\n  let selectedMatrixLimit = {\n    MinTileCol: 0,\n    MinTileRow: 0,\n    // subtract one to end up at tile top left\n    MaxTileCol: matrix.MatrixWidth - 1,\n    MaxTileRow: matrix.MatrixHeight - 1,\n  };\n\n  //in case of matrix limits, use matrix limits to calculate extent\n  if (matrixLimits) {\n    selectedMatrixLimit = matrixLimits[matrixLimits.length - 1];\n    const m = matrixSetObj.TileMatrix.find(\n      (tileMatrixValue) =>\n        tileMatrixValue.Identifier === selectedMatrixLimit.TileMatrix ||\n        matrixSetObj.Identifier + ':' + tileMatrixValue.Identifier ===\n          selectedMatrixLimit.TileMatrix,\n    );\n    if (m) {\n      matrix = m;\n    }\n  }\n\n  const resolution =\n    (matrix.ScaleDenominator * 0.00028) / projection.getMetersPerUnit(); // WMTS 1.0.0: standardized rendering pixel size\n  const origin = switchXY\n    ? [matrix.TopLeftCorner[1], matrix.TopLeftCorner[0]]\n    : matrix.TopLeftCorner;\n  const tileSpanX = matrix.TileWidth * resolution;\n  const tileSpanY = matrix.TileHeight * resolution;\n  let matrixSetExtent = matrixSetObj['BoundingBox'];\n  if (matrixSetExtent && switchXY) {\n    matrixSetExtent = [\n      matrixSetExtent[1],\n      matrixSetExtent[0],\n      matrixSetExtent[3],\n      matrixSetExtent[2],\n    ];\n  }\n  let extent = [\n    origin[0] + tileSpanX * selectedMatrixLimit.MinTileCol,\n    // add one to get proper bottom/right coordinate\n    origin[1] - tileSpanY * (1 + selectedMatrixLimit.MaxTileRow),\n    origin[0] + tileSpanX * (1 + selectedMatrixLimit.MaxTileCol),\n    origin[1] - tileSpanY * selectedMatrixLimit.MinTileRow,\n  ];\n\n  if (\n    matrixSetExtent !== undefined &&\n    !containsExtent(matrixSetExtent, extent)\n  ) {\n    const wgs84BoundingBox = l['WGS84BoundingBox'];\n    const wgs84ProjectionExtent = getProjection('EPSG:4326').getExtent();\n    extent = matrixSetExtent;\n    if (wgs84BoundingBox) {\n      wrapX =\n        wgs84BoundingBox[0] === wgs84ProjectionExtent[0] &&\n        wgs84BoundingBox[2] === wgs84ProjectionExtent[2];\n    } else {\n      const wgs84MatrixSetExtent = transformExtent(\n        matrixSetExtent,\n        matrixSetObj['SupportedCRS'],\n        'EPSG:4326',\n      );\n      // Ignore slight deviation from the correct x limits\n      wrapX =\n        wgs84MatrixSetExtent[0] - 1e-10 <= wgs84ProjectionExtent[0] &&\n        wgs84MatrixSetExtent[2] + 1e-10 >= wgs84ProjectionExtent[2];\n    }\n  }\n\n  const tileGrid = createFromCapabilitiesMatrixSet(\n    matrixSetObj,\n    extent,\n    matrixLimits,\n  );\n\n  /** @type {!Array<string>} */\n  const urls = [];\n  let requestEncoding = config['requestEncoding'];\n  requestEncoding = requestEncoding !== undefined ? requestEncoding : '';\n\n  if (\n    'OperationsMetadata' in wmtsCap &&\n    'GetTile' in wmtsCap['OperationsMetadata']\n  ) {\n    const gets = wmtsCap['OperationsMetadata']['GetTile']['DCP']['HTTP']['Get'];\n\n    for (let i = 0, ii = gets.length; i < ii; ++i) {\n      if (gets[i]['Constraint']) {\n        const constraint = gets[i]['Constraint'].find(function (element) {\n          return element['name'] == 'GetEncoding';\n        });\n        const encodings = constraint['AllowedValues']['Value'];\n\n        if (requestEncoding === '') {\n          // requestEncoding not provided, use the first encoding from the list\n          requestEncoding = encodings[0];\n        }\n        if (requestEncoding === 'KVP') {\n          if (encodings.includes('KVP')) {\n            urls.push(/** @type {string} */ (gets[i]['href']));\n          }\n        } else {\n          break;\n        }\n      } else if (gets[i]['href']) {\n        requestEncoding = 'KVP';\n        urls.push(/** @type {string} */ (gets[i]['href']));\n      }\n    }\n  }\n  if (urls.length === 0) {\n    requestEncoding = 'REST';\n    l['ResourceURL'].forEach(function (element) {\n      if (element['resourceType'] === 'tile') {\n        format = element['format'];\n        urls.push(/** @type {string} */ (element['template']));\n      }\n    });\n  }\n\n  return {\n    urls: urls,\n    layer: config['layer'],\n    matrixSet: matrixSet,\n    format: format,\n    projection: projection,\n    requestEncoding: requestEncoding,\n    tileGrid: tileGrid,\n    style: style,\n    dimensions: dimensions,\n    wrapX: wrapX,\n    crossOrigin: config['crossOrigin'],\n  };\n}\n","/**\n * Utilities for parsing literal style objects\n * @module ol/webgl/styleparser\n */\nimport {\n  BooleanType,\n  ColorType,\n  NumberArrayType,\n  NumberType,\n  SizeType,\n  StringType,\n  newParsingContext,\n} from '../expr/expression.js';\nimport {ShaderBuilder} from './ShaderBuilder.js';\nimport {\n  arrayToGlsl,\n  buildExpression,\n  getStringNumberEquivalent,\n  stringToGlsl,\n  uniformNameForVariable,\n} from '../expr/gpu.js';\nimport {asArray} from '../color.js';\n\n/**\n * Recursively parses a style expression and outputs a GLSL-compatible string. Takes in a compilation context that\n * will be read and modified during the parsing operation.\n * @param {import(\"../expr/gpu.js\").CompilationContext} compilationContext Compilation context\n * @param {import(\"../expr/expression.js\").EncodedExpression} value Value\n * @param {number} [expectedType] Expected final type (can be several types combined)\n * @return {string} GLSL-compatible output\n */\nexport function expressionToGlsl(compilationContext, value, expectedType) {\n  const parsingContext = newParsingContext();\n  parsingContext.style = compilationContext.style;\n  return buildExpression(\n    value,\n    expectedType,\n    parsingContext,\n    compilationContext,\n  );\n}\n\n/**\n * Packs all components of a color into a two-floats array\n * @param {import(\"../color.js\").Color|string} color Color as array of numbers or string\n * @return {Array<number>} Vec2 array containing the color in compressed form\n */\nexport function packColor(color) {\n  const array = asArray(color);\n  const r = array[0] * 256;\n  const g = array[1];\n  const b = array[2] * 256;\n  const a = Math.round(array[3] * 255);\n  return [r + g, b + a];\n}\n\nconst UNPACK_COLOR_FN = `vec4 unpackColor(vec2 packedColor) {\n  return fract(packedColor[1] / 256.0) * vec4(\n    fract(floor(packedColor[0] / 256.0) / 256.0),\n    fract(packedColor[0] / 256.0),\n    fract(floor(packedColor[1] / 256.0) / 256.0),\n    1.0\n  );\n}`;\n\n/**\n * @param {number} type Value type\n * @return {1|2|3|4} The amount of components for this value\n */\nfunction getGlslSizeFromType(type) {\n  if (type === ColorType || type === SizeType) {\n    return 2;\n  }\n  if (type === NumberArrayType) {\n    return 4;\n  }\n  return 1;\n}\n\n/**\n * @param {number} type Value type\n * @return {'float'|'vec2'|'vec3'|'vec4'} The corresponding GLSL type for this value\n */\nfunction getGlslTypeFromType(type) {\n  const size = getGlslSizeFromType(type);\n  if (size > 1) {\n    return /** @type {'vec2'|'vec3'|'vec4'} */ (`vec${size}`);\n  }\n  return 'float';\n}\n\n/**\n * see https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript\n * @param {Object|string} input The hash input, either an object or string\n * @return {string} Hash (if the object cannot be serialized, it is based on `getUid`)\n */\nexport function computeHash(input) {\n  const hash = JSON.stringify(input)\n    .split('')\n    .reduce((prev, curr) => (prev << 5) - prev + curr.charCodeAt(0), 0);\n  return (hash >>> 0).toString();\n}\n\n/**\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {'shape-'|'circle-'|'icon-'} prefix Properties prefix\n */\nfunction parseCommonSymbolProperties(style, builder, vertContext, prefix) {\n  if (`${prefix}radius` in style && prefix !== 'icon-') {\n    let radius = expressionToGlsl(\n      vertContext,\n      style[`${prefix}radius`],\n      NumberType,\n    );\n    if (`${prefix}radius2` in style) {\n      const radius2 = expressionToGlsl(\n        vertContext,\n        style[`${prefix}radius2`],\n        NumberType,\n      );\n      radius = `max(${radius}, ${radius2})`;\n    }\n    if (`${prefix}stroke-width` in style) {\n      radius = `(${radius} + ${expressionToGlsl(\n        vertContext,\n        style[`${prefix}stroke-width`],\n        NumberType,\n      )} * 0.5)`;\n    }\n    builder.setSymbolSizeExpression(`vec2(${radius} * 2. + 0.5)`); // adding some padding for antialiasing\n  }\n  if (`${prefix}scale` in style) {\n    const scale = expressionToGlsl(\n      vertContext,\n      style[`${prefix}scale`],\n      SizeType,\n    );\n    builder.setSymbolSizeExpression(\n      `${builder.getSymbolSizeExpression()} * ${scale}`,\n    );\n  }\n  if (`${prefix}displacement` in style) {\n    builder.setSymbolOffsetExpression(\n      expressionToGlsl(\n        vertContext,\n        style[`${prefix}displacement`],\n        NumberArrayType,\n      ),\n    );\n  }\n  if (`${prefix}rotation` in style) {\n    builder.setSymbolRotationExpression(\n      expressionToGlsl(vertContext, style[`${prefix}rotation`], NumberType),\n    );\n  }\n  if (`${prefix}rotate-with-view` in style) {\n    builder.setSymbolRotateWithView(!!style[`${prefix}rotate-with-view`]);\n  }\n}\n\n/**\n * @param {string} distanceField The distance field expression\n * @param {string|null} fillColor The fill color expression; null if no fill\n * @param {string|null} strokeColor The stroke color expression; null if no stroke\n * @param {string|null} strokeWidth The stroke width expression; null if no stroke\n * @param {string|null} opacity The opacity expression; null if no stroke\n * @return {string} The final color expression, based on the distance field and given params\n */\nfunction getColorFromDistanceField(\n  distanceField,\n  fillColor,\n  strokeColor,\n  strokeWidth,\n  opacity,\n) {\n  let color = 'vec4(0.)';\n  if (fillColor !== null) {\n    color = fillColor;\n  }\n  if (strokeColor !== null && strokeWidth !== null) {\n    const strokeFillRatio = `smoothstep(-${strokeWidth} + 0.63, -${strokeWidth} - 0.58, ${distanceField})`;\n    color = `mix(${strokeColor}, ${color}, ${strokeFillRatio})`;\n  }\n  const shapeOpacity = `(1.0 - smoothstep(-0.63, 0.58, ${distanceField}))`;\n  let result = `${color} * ${shapeOpacity}`;\n  if (opacity !== null) {\n    result = `${result} * ${opacity}`;\n  }\n  return result;\n}\n\n/**\n * This will parse an image property provided by `<prefix>-src`\n * The image size expression in GLSL will be returned\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {'icon-'|'fill-pattern-'|'stroke-pattern-'} prefix Property prefix\n * @param {string} textureId A identifier that will be used in the generated uniforms: `sample2d u_texture<id>` and `vec2 u_texture<id>_size`\n * @return {string} The image size expression\n */\nfunction parseImageProperties(style, builder, uniforms, prefix, textureId) {\n  const image = new Image();\n  let size;\n  image.crossOrigin =\n    style[`${prefix}cross-origin`] === undefined\n      ? 'anonymous'\n      : style[`${prefix}cross-origin`];\n  image.src = style[`${prefix}src`];\n\n  if (image.complete && image.width && image.height) {\n    size = arrayToGlsl([image.width, image.height]);\n  } else {\n    // the size is provided asynchronously using a uniform\n    uniforms[`u_texture${textureId}_size`] = () => {\n      return image.complete ? [image.width, image.height] : [0, 0];\n    };\n    builder.addUniform(`vec2 u_texture${textureId}_size`);\n    size = `u_texture${textureId}_size`;\n  }\n  uniforms[`u_texture${textureId}`] = image;\n  builder.addUniform(`sampler2D u_texture${textureId}`);\n  return size;\n}\n\n/**\n * This will parse an image's offset properties provided by `<prefix>-offset`, `<prefix>-offset-origin` and `<prefix>-size`\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {'icon-'|'fill-pattern-'|'stroke-pattern-'} prefix Property prefix\n * @param {import(\"../expr/gpu.js\").CompilationContext} context Shader compilation context (vertex or fragment)\n * @param {string} imageSize Pixel size of the full image as a GLSL expression\n * @param {string} sampleSize Pixel size of the sample in the image as a GLSL expression\n * @return {string} The offset expression\n */\nfunction parseImageOffsetProperties(\n  style,\n  prefix,\n  context,\n  imageSize,\n  sampleSize,\n) {\n  let offsetExpression = expressionToGlsl(\n    context,\n    style[`${prefix}offset`],\n    NumberArrayType,\n  );\n  if (`${prefix}offset-origin` in style) {\n    switch (style[`${prefix}offset-origin`]) {\n      case 'top-right':\n        offsetExpression = `vec2(${imageSize}.x, 0.) + ${sampleSize} * vec2(-1., 0.) + ${offsetExpression} * vec2(-1., 1.)`;\n        break;\n      case 'bottom-left':\n        offsetExpression = `vec2(0., ${imageSize}.y) + ${sampleSize} * vec2(0., -1.) + ${offsetExpression} * vec2(1., -1.)`;\n        break;\n      case 'bottom-right':\n        offsetExpression = `${imageSize} - ${sampleSize} - ${offsetExpression}`;\n        break;\n      default: // pass\n    }\n  }\n  return offsetExpression;\n}\n\n/**\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\n */\nfunction parseCircleProperties(\n  style,\n  builder,\n  uniforms,\n  vertContext,\n  fragContext,\n) {\n  // this function takes in screen coordinates in pixels and returns the signed distance field\n  // (0 on the boundary, negative inside the circle, positive outside, values in pixels)\n  fragContext.functions['circleDistanceField'] =\n    `float circleDistanceField(vec2 point, float radius) {\n  return length(point) - radius;\n}`;\n\n  parseCommonSymbolProperties(style, builder, vertContext, 'circle-');\n\n  // OPACITY\n  let opacity = null;\n  if ('circle-opacity' in style) {\n    opacity = expressionToGlsl(\n      fragContext,\n      style['circle-opacity'],\n      NumberType,\n    );\n  }\n\n  // SCALE\n  let currentPoint = 'coordsPx';\n  if ('circle-scale' in style) {\n    const scale = expressionToGlsl(\n      fragContext,\n      style['circle-scale'],\n      SizeType,\n    );\n    currentPoint = `coordsPx / ${scale}`;\n  }\n\n  // FILL COLOR\n  let fillColor = null;\n  if ('circle-fill-color' in style) {\n    fillColor = expressionToGlsl(\n      fragContext,\n      style['circle-fill-color'],\n      ColorType,\n    );\n  }\n\n  // STROKE COLOR\n  let strokeColor = null;\n  if ('circle-stroke-color' in style) {\n    strokeColor = expressionToGlsl(\n      fragContext,\n      style['circle-stroke-color'],\n      ColorType,\n    );\n  }\n\n  // RADIUS\n  let radius = expressionToGlsl(\n    fragContext,\n    style['circle-radius'],\n    NumberType,\n  );\n\n  // STROKE WIDTH\n  let strokeWidth = null;\n  if ('circle-stroke-width' in style) {\n    strokeWidth = expressionToGlsl(\n      fragContext,\n      style['circle-stroke-width'],\n      NumberType,\n    );\n    radius = `(${radius} + ${strokeWidth} * 0.5)`;\n  }\n\n  // FINAL COLOR\n  const distanceField = `circleDistanceField(${currentPoint}, ${radius})`;\n  const colorExpression = getColorFromDistanceField(\n    distanceField,\n    fillColor,\n    strokeColor,\n    strokeWidth,\n    opacity,\n  );\n  builder.setSymbolColorExpression(colorExpression);\n}\n\n/**\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\n */\nfunction parseShapeProperties(\n  style,\n  builder,\n  uniforms,\n  vertContext,\n  fragContext,\n) {\n  fragContext.functions['round'] = `float round(float v) {\n  return sign(v) * floor(abs(v) + 0.5);\n}`;\n\n  // these functions take in screen coordinates in pixels and returns the signed distance field\n  // (0 on the boundary, negative inside the polygon, positive outside, values in pixels)\n  // inspired by https://github.com/zranger1/PixelblazePatterns/blob/master/Toolkit/sdf2d.md#n-sided-regular-polygon\n  fragContext.functions['starDistanceField'] =\n    `float starDistanceField(vec2 point, float numPoints, float radius, float radius2, float angle) {\n  float startAngle = -PI * 0.5 + angle; // tip starts upwards and rotates clockwise with angle\n  float c = cos(startAngle);\n  float s = sin(startAngle);\n  vec2 pointRotated = vec2(c * point.x - s * point.y, s * point.x + c * point.y);\n  float alpha = TWO_PI / numPoints; // the angle of one sector\n  float beta = atan(pointRotated.y, pointRotated.x);\n  float gamma = round(beta / alpha) * alpha; // angle in sector\n  c = cos(-gamma);\n  s = sin(-gamma);\n  vec2 inSector = vec2(c * pointRotated.x - s * pointRotated.y, abs(s * pointRotated.x + c * pointRotated.y));\n  vec2 tipToPoint = inSector + vec2(-radius, 0.);\n  vec2 edgeNormal = vec2(radius2 * sin(alpha * 0.5), -radius2 * cos(alpha * 0.5) + radius);\n  return dot(normalize(edgeNormal), tipToPoint);\n}`;\n  fragContext.functions['regularDistanceField'] =\n    `float regularDistanceField(vec2 point, float numPoints, float radius, float angle) {\n  float startAngle = -PI * 0.5 + angle; // tip starts upwards and rotates clockwise with angle\n  float c = cos(startAngle);\n  float s = sin(startAngle);\n  vec2 pointRotated = vec2(c * point.x - s * point.y, s * point.x + c * point.y);\n  float alpha = TWO_PI / numPoints; // the angle of one sector\n  float radiusIn = radius * cos(PI / numPoints);\n  float beta = atan(pointRotated.y, pointRotated.x);\n  float gamma = round((beta - alpha * 0.5) / alpha) * alpha + alpha * 0.5; // angle in sector from mid\n  c = cos(-gamma);\n  s = sin(-gamma);\n  vec2 inSector = vec2(c * pointRotated.x - s * pointRotated.y, abs(s * pointRotated.x + c * pointRotated.y));\n  return inSector.x - radiusIn;\n}`;\n\n  parseCommonSymbolProperties(style, builder, vertContext, 'shape-');\n\n  // OPACITY\n  let opacity = null;\n  if ('shape-opacity' in style) {\n    opacity = expressionToGlsl(fragContext, style['shape-opacity'], NumberType);\n  }\n\n  // SCALE\n  let currentPoint = 'coordsPx';\n  if ('shape-scale' in style) {\n    const scale = expressionToGlsl(fragContext, style['shape-scale'], SizeType);\n    currentPoint = `coordsPx / ${scale}`;\n  }\n\n  // FILL COLOR\n  let fillColor = null;\n  if ('shape-fill-color' in style) {\n    fillColor = expressionToGlsl(\n      fragContext,\n      style['shape-fill-color'],\n      ColorType,\n    );\n  }\n\n  // STROKE COLOR\n  let strokeColor = null;\n  if ('shape-stroke-color' in style) {\n    strokeColor = expressionToGlsl(\n      fragContext,\n      style['shape-stroke-color'],\n      ColorType,\n    );\n  }\n\n  // STROKE WIDTH\n  let strokeWidth = null;\n  if ('shape-stroke-width' in style) {\n    strokeWidth = expressionToGlsl(\n      fragContext,\n      style['shape-stroke-width'],\n      NumberType,\n    );\n  }\n\n  // SHAPE TYPE\n  const numPoints = expressionToGlsl(\n    fragContext,\n    style['shape-points'],\n    NumberType,\n  );\n  let angle = '0.';\n  if ('shape-angle' in style) {\n    angle = expressionToGlsl(fragContext, style['shape-angle'], NumberType);\n  }\n  let shapeField;\n  let radius = expressionToGlsl(fragContext, style['shape-radius'], NumberType);\n  if (strokeWidth !== null) {\n    radius = `${radius} + ${strokeWidth} * 0.5`;\n  }\n  if ('shape-radius2' in style) {\n    let radius2 = expressionToGlsl(\n      fragContext,\n      style['shape-radius2'],\n      NumberType,\n    );\n    if (strokeWidth !== null) {\n      radius2 = `${radius2} + ${strokeWidth} * 0.5`;\n    }\n    shapeField = `starDistanceField(${currentPoint}, ${numPoints}, ${radius}, ${radius2}, ${angle})`;\n  } else {\n    shapeField = `regularDistanceField(${currentPoint}, ${numPoints}, ${radius}, ${angle})`;\n  }\n\n  // FINAL COLOR\n  const colorExpression = getColorFromDistanceField(\n    shapeField,\n    fillColor,\n    strokeColor,\n    strokeWidth,\n    opacity,\n  );\n  builder.setSymbolColorExpression(colorExpression);\n}\n\n/**\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\n */\nfunction parseIconProperties(\n  style,\n  builder,\n  uniforms,\n  vertContext,\n  fragContext,\n) {\n  // COLOR\n  let color = 'vec4(1.0)';\n  if ('icon-color' in style) {\n    color = expressionToGlsl(fragContext, style['icon-color'], ColorType);\n  }\n\n  // OPACITY\n  if ('icon-opacity' in style) {\n    color = `${color} * ${expressionToGlsl(\n      fragContext,\n      style['icon-opacity'],\n      NumberType,\n    )}`;\n  }\n\n  // IMAGE & SIZE\n  const textureId = computeHash(style['icon-src']);\n  const sizeExpression = parseImageProperties(\n    style,\n    builder,\n    uniforms,\n    'icon-',\n    textureId,\n  );\n  builder\n    .setSymbolColorExpression(\n      `${color} * samplePremultiplied(u_texture${textureId}, v_texCoord)`,\n    )\n    .setSymbolSizeExpression(sizeExpression);\n\n  // override size if width/height were specified\n  if ('icon-width' in style && 'icon-height' in style) {\n    builder.setSymbolSizeExpression(\n      `vec2(${expressionToGlsl(\n        vertContext,\n        style['icon-width'],\n        NumberType,\n      )}, ${expressionToGlsl(vertContext, style['icon-height'], NumberType)})`,\n    );\n  }\n\n  // tex coord\n  if ('icon-offset' in style && 'icon-size' in style) {\n    const sampleSize = expressionToGlsl(\n      vertContext,\n      style['icon-size'],\n      NumberArrayType,\n    );\n    const fullsize = builder.getSymbolSizeExpression();\n    builder.setSymbolSizeExpression(sampleSize);\n    const offset = parseImageOffsetProperties(\n      style,\n      'icon-',\n      vertContext,\n      'v_quadSizePx',\n      sampleSize,\n    );\n    builder.setTextureCoordinateExpression(\n      `(vec4((${offset}).xyxy) + vec4(0., 0., ${sampleSize})) / (${fullsize}).xyxy`,\n    );\n  }\n\n  parseCommonSymbolProperties(style, builder, vertContext, 'icon-');\n\n  if ('icon-anchor' in style) {\n    const anchor = expressionToGlsl(\n      vertContext,\n      style['icon-anchor'],\n      NumberArrayType,\n    );\n    let scale = `1.0`;\n    if (`icon-scale` in style) {\n      scale = expressionToGlsl(vertContext, style[`icon-scale`], SizeType);\n    }\n    let shiftPx;\n    if (\n      style['icon-anchor-x-units'] === 'pixels' &&\n      style['icon-anchor-y-units'] === 'pixels'\n    ) {\n      shiftPx = `${anchor} * ${scale}`;\n    } else if (style['icon-anchor-x-units'] === 'pixels') {\n      shiftPx = `${anchor} * vec2(vec2(${scale}).x, v_quadSizePx.y)`;\n    } else if (style['icon-anchor-y-units'] === 'pixels') {\n      shiftPx = `${anchor} * vec2(v_quadSizePx.x, vec2(${scale}).x)`;\n    } else {\n      shiftPx = `${anchor} * v_quadSizePx`;\n    }\n    // default origin is top-left\n    let offsetPx = `v_quadSizePx * vec2(0.5, -0.5) + ${shiftPx} * vec2(-1., 1.)`;\n    if ('icon-anchor-origin' in style) {\n      switch (style['icon-anchor-origin']) {\n        case 'top-right':\n          offsetPx = `v_quadSizePx * -0.5 + ${shiftPx}`;\n          break;\n        case 'bottom-left':\n          offsetPx = `v_quadSizePx * 0.5 - ${shiftPx}`;\n          break;\n        case 'bottom-right':\n          offsetPx = `v_quadSizePx * vec2(-0.5, 0.5) + ${shiftPx} * vec2(1., -1.)`;\n          break;\n        default: // pass\n      }\n    }\n    builder.setSymbolOffsetExpression(\n      `${builder.getSymbolOffsetExpression()} + ${offsetPx}`,\n    );\n  }\n}\n\n/**\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader Builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\n */\nfunction parseStrokeProperties(\n  style,\n  builder,\n  uniforms,\n  vertContext,\n  fragContext,\n) {\n  if ('stroke-color' in style) {\n    builder.setStrokeColorExpression(\n      expressionToGlsl(fragContext, style['stroke-color'], ColorType),\n    );\n  }\n  if ('stroke-pattern-src' in style) {\n    const textureId = computeHash(style['stroke-pattern-src']);\n    const sizeExpression = parseImageProperties(\n      style,\n      builder,\n      uniforms,\n      'stroke-pattern-',\n      textureId,\n    );\n    let sampleSizeExpression = sizeExpression;\n    let offsetExpression = 'vec2(0.)';\n    if ('stroke-pattern-offset' in style && 'stroke-pattern-size' in style) {\n      sampleSizeExpression = expressionToGlsl(\n        fragContext,\n        style[`stroke-pattern-size`],\n        NumberArrayType,\n      );\n      offsetExpression = parseImageOffsetProperties(\n        style,\n        'stroke-pattern-',\n        fragContext,\n        sizeExpression,\n        sampleSizeExpression,\n      );\n    }\n    let spacingExpression = '0.';\n    if ('stroke-pattern-spacing' in style) {\n      spacingExpression = expressionToGlsl(\n        fragContext,\n        style['stroke-pattern-spacing'],\n        NumberType,\n      );\n    }\n    fragContext.functions['sampleStrokePattern'] =\n      `vec4 sampleStrokePattern(sampler2D texture, vec2 textureSize, vec2 textureOffset, vec2 sampleSize, float spacingPx, float currentLengthPx, float currentRadiusRatio, float lineWidth) {\n  float currentLengthScaled = currentLengthPx * sampleSize.y / lineWidth;\n  float spacingScaled = spacingPx * sampleSize.y / lineWidth;\n  float uCoordPx = mod(currentLengthScaled, (sampleSize.x + spacingScaled));\n  // make sure that we're not sampling too close to the borders to avoid interpolation with outside pixels\n  uCoordPx = clamp(uCoordPx, 0.5, sampleSize.x - 0.5);\n  float vCoordPx = (-currentRadiusRatio * 0.5 + 0.5) * sampleSize.y;\n  vec2 texCoord = (vec2(uCoordPx, vCoordPx) + textureOffset) / textureSize;\n  return samplePremultiplied(texture, texCoord);\n}`;\n    const textureName = `u_texture${textureId}`;\n    let tintExpression = '1.';\n    if ('stroke-color' in style) {\n      tintExpression = builder.getStrokeColorExpression();\n    }\n    builder.setStrokeColorExpression(\n      `${tintExpression} * sampleStrokePattern(${textureName}, ${sizeExpression}, ${offsetExpression}, ${sampleSizeExpression}, ${spacingExpression}, currentLengthPx, currentRadiusRatio, v_width)`,\n    );\n  }\n\n  if ('stroke-width' in style) {\n    builder.setStrokeWidthExpression(\n      expressionToGlsl(vertContext, style['stroke-width'], NumberType),\n    );\n  }\n\n  if ('stroke-offset' in style) {\n    builder.setStrokeOffsetExpression(\n      expressionToGlsl(vertContext, style['stroke-offset'], NumberType),\n    );\n  }\n\n  if ('stroke-line-cap' in style) {\n    builder.setStrokeCapExpression(\n      expressionToGlsl(vertContext, style['stroke-line-cap'], StringType),\n    );\n  }\n\n  if ('stroke-line-join' in style) {\n    builder.setStrokeJoinExpression(\n      expressionToGlsl(vertContext, style['stroke-line-join'], StringType),\n    );\n  }\n\n  if ('stroke-miter-limit' in style) {\n    builder.setStrokeMiterLimitExpression(\n      expressionToGlsl(vertContext, style['stroke-miter-limit'], NumberType),\n    );\n  }\n\n  if ('stroke-line-dash' in style) {\n    fragContext.functions['getSingleDashDistance'] =\n      `float getSingleDashDistance(float distance, float radius, float dashOffset, float dashLength, float dashLengthTotal, float capType) {\n  float localDistance = mod(distance, dashLengthTotal);\n  float distanceSegment = abs(localDistance - dashOffset - dashLength * 0.5) - dashLength * 0.5;\n  distanceSegment = min(distanceSegment, dashLengthTotal - localDistance);\n  if (capType == ${stringToGlsl('square')}) {\n    distanceSegment -= v_width * 0.5;\n  } else if (capType == ${stringToGlsl('round')}) {\n    distanceSegment = min(distanceSegment, sqrt(distanceSegment * distanceSegment + radius * radius) - v_width * 0.5);\n  }\n  return distanceSegment;\n}`;\n\n    let dashPattern = style['stroke-line-dash'].map((v) =>\n      expressionToGlsl(fragContext, v, NumberType),\n    );\n    // if pattern has odd length, concatenate it with itself to be even\n    if (dashPattern.length % 2 === 1) {\n      dashPattern = [...dashPattern, ...dashPattern];\n    }\n\n    let offsetExpression = '0.';\n    if ('stroke-line-dash-offset' in style) {\n      offsetExpression = expressionToGlsl(\n        vertContext,\n        style['stroke-line-dash-offset'],\n        NumberType,\n      );\n    }\n\n    // define a function for this dash specifically\n    const uniqueDashKey = computeHash(style['stroke-line-dash']);\n    const dashFunctionName = `dashDistanceField_${uniqueDashKey}`;\n\n    const dashLengthsDef = dashPattern.map(\n      (v, i) => `float dashLength${i} = ${v};`,\n    );\n    const totalLengthDef = dashPattern\n      .map((v, i) => `dashLength${i}`)\n      .join(' + ');\n    let currentDashOffset = '0.';\n    let distanceExpression = `getSingleDashDistance(distance, radius, ${currentDashOffset}, dashLength0, totalDashLength, capType)`;\n    for (let i = 2; i < dashPattern.length; i += 2) {\n      currentDashOffset = `${currentDashOffset} + dashLength${\n        i - 2\n      } + dashLength${i - 1}`;\n      distanceExpression = `min(${distanceExpression}, getSingleDashDistance(distance, radius, ${currentDashOffset}, dashLength${i}, totalDashLength, capType))`;\n    }\n\n    fragContext.functions[dashFunctionName] =\n      `float ${dashFunctionName}(float distance, float radius, float capType) {\n  ${dashLengthsDef.join('\\n  ')}\n  float totalDashLength = ${totalLengthDef};\n  return ${distanceExpression};\n}`;\n    builder.setStrokeDistanceFieldExpression(\n      `${dashFunctionName}(currentLengthPx + ${offsetExpression}, currentRadiusPx, capType)`,\n    );\n  }\n}\n\n/**\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader Builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\n */\nfunction parseFillProperties(\n  style,\n  builder,\n  uniforms,\n  vertContext,\n  fragContext,\n) {\n  if ('fill-color' in style) {\n    builder.setFillColorExpression(\n      expressionToGlsl(fragContext, style['fill-color'], ColorType),\n    );\n  }\n  if ('fill-pattern-src' in style) {\n    const textureId = computeHash(style['fill-pattern-src']);\n    const sizeExpression = parseImageProperties(\n      style,\n      builder,\n      uniforms,\n      'fill-pattern-',\n      textureId,\n    );\n    let sampleSizeExpression = sizeExpression;\n    let offsetExpression = 'vec2(0.)';\n    if ('fill-pattern-offset' in style && 'fill-pattern-size' in style) {\n      sampleSizeExpression = expressionToGlsl(\n        fragContext,\n        style[`fill-pattern-size`],\n        NumberArrayType,\n      );\n      offsetExpression = parseImageOffsetProperties(\n        style,\n        'fill-pattern-',\n        fragContext,\n        sizeExpression,\n        sampleSizeExpression,\n      );\n    }\n    fragContext.functions['sampleFillPattern'] =\n      `vec4 sampleFillPattern(sampler2D texture, vec2 textureSize, vec2 textureOffset, vec2 sampleSize, vec2 pxOrigin, vec2 pxPosition) {\n  float scaleRatio = pow(2., mod(u_zoom + 0.5, 1.) - 0.5);\n  vec2 pxRelativePos = pxPosition - pxOrigin;\n  // rotate the relative position from origin by the current view rotation\n  pxRelativePos = vec2(pxRelativePos.x * cos(u_rotation) - pxRelativePos.y * sin(u_rotation), pxRelativePos.x * sin(u_rotation) + pxRelativePos.y * cos(u_rotation));\n  // sample position is computed according to the sample offset & size\n  vec2 samplePos = mod(pxRelativePos / scaleRatio, sampleSize);\n  // also make sure that we're not sampling too close to the borders to avoid interpolation with outside pixels\n  samplePos = clamp(samplePos, vec2(0.5), sampleSize - vec2(0.5));\n  samplePos.y = sampleSize.y - samplePos.y; // invert y axis so that images appear upright\n  return samplePremultiplied(texture, (samplePos + textureOffset) / textureSize);\n}`;\n    const textureName = `u_texture${textureId}`;\n    let tintExpression = '1.';\n    if ('fill-color' in style) {\n      tintExpression = builder.getFillColorExpression();\n    }\n    builder.setFillColorExpression(\n      `${tintExpression} * sampleFillPattern(${textureName}, ${sizeExpression}, ${offsetExpression}, ${sampleSizeExpression}, pxOrigin, pxPos)`,\n    );\n  }\n}\n\n/**\n * @typedef {Object} StyleParseResult\n * @property {ShaderBuilder} builder Shader builder pre-configured according to a given style\n * @property {import(\"../render/webgl/VectorStyleRenderer.js\").UniformDefinitions} uniforms Uniform definitions\n * @property {import(\"../render/webgl/VectorStyleRenderer.js\").AttributeDefinitions} attributes Attribute definitions\n */\n\n/**\n * Parses a {@link import(\"../style/webgl.js\").WebGLStyle} object and returns a {@link ShaderBuilder}\n * object that has been configured according to the given style, as well as `attributes` and `uniforms`\n * arrays to be fed to the `WebGLPointsRenderer` class.\n *\n * Also returns `uniforms` and `attributes` properties as expected by the\n * {@link module:ol/renderer/webgl/PointsLayer~WebGLPointsLayerRenderer}.\n *\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Literal style.\n * @return {StyleParseResult} Result containing shader params, attributes and uniforms.\n */\nexport function parseLiteralStyle(style) {\n  /**\n   * @type {import(\"../expr/gpu.js\").CompilationContext}\n   */\n  const vertContext = {\n    inFragmentShader: false,\n    properties: {},\n    variables: {},\n    functions: {},\n    style,\n  };\n\n  /**\n   * @type {import(\"../expr/gpu.js\").CompilationContext}\n   */\n  const fragContext = {\n    inFragmentShader: true,\n    variables: vertContext.variables,\n    properties: {},\n    functions: {},\n    style,\n  };\n\n  const builder = new ShaderBuilder();\n\n  /** @type {Object<string,import(\"../webgl/Helper\").UniformValue>} */\n  const uniforms = {};\n\n  if ('icon-src' in style) {\n    parseIconProperties(style, builder, uniforms, vertContext, fragContext);\n  } else if ('shape-points' in style) {\n    parseShapeProperties(style, builder, uniforms, vertContext, fragContext);\n  } else if ('circle-radius' in style) {\n    parseCircleProperties(style, builder, uniforms, vertContext, fragContext);\n  }\n  parseStrokeProperties(style, builder, uniforms, vertContext, fragContext);\n  parseFillProperties(style, builder, uniforms, vertContext, fragContext);\n\n  if (style.filter) {\n    const parsedFilter = expressionToGlsl(\n      fragContext,\n      style.filter,\n      BooleanType,\n    );\n    builder.setFragmentDiscardExpression(`!${parsedFilter}`);\n  }\n\n  // define one uniform per variable\n  Object.keys(fragContext.variables).forEach(function (varName) {\n    const variable = fragContext.variables[varName];\n    const uniformName = uniformNameForVariable(variable.name);\n    builder.addUniform(`${getGlslTypeFromType(variable.type)} ${uniformName}`);\n\n    let callback;\n    if (variable.type === StringType) {\n      callback = () =>\n        getStringNumberEquivalent(\n          /** @type {string} */ (style.variables[variable.name]),\n        );\n    } else if (variable.type === ColorType) {\n      callback = () =>\n        packColor([\n          ...asArray(\n            /** @type {string|Array<number>} */ (\n              style.variables[variable.name]\n            ) || '#eee',\n          ),\n        ]);\n    } else if (variable.type === BooleanType) {\n      callback = () =>\n        /** @type {boolean} */ (style.variables[variable.name]) ? 1.0 : 0.0;\n    } else {\n      callback = () => /** @type {number} */ (style.variables[variable.name]);\n    }\n    uniforms[uniformName] = callback;\n  });\n\n  // for each feature attribute used in the fragment shader, define a varying that will be used to pass data\n  // from the vertex to the fragment shader, as well as an attribute in the vertex shader (if not already present)\n  Object.keys(fragContext.properties).forEach(function (propName) {\n    const property = fragContext.properties[propName];\n    if (!vertContext.properties[propName]) {\n      vertContext.properties[propName] = property;\n    }\n    let type = getGlslTypeFromType(property.type);\n    let expression = `a_prop_${property.name}`;\n    if (property.type === ColorType) {\n      type = 'vec4';\n      expression = `unpackColor(${expression})`;\n      builder.addVertexShaderFunction(UNPACK_COLOR_FN);\n    }\n    builder.addVarying(`v_prop_${property.name}`, type, expression);\n  });\n\n  // for each feature attribute used in the vertex shader, define an attribute in the vertex shader.\n  Object.keys(vertContext.properties).forEach(function (propName) {\n    const property = vertContext.properties[propName];\n    builder.addAttribute(\n      `${getGlslTypeFromType(property.type)} a_prop_${property.name}`,\n    );\n  });\n\n  const attributes = Object.keys(vertContext.properties).map(\n    function (propName) {\n      const property = vertContext.properties[propName];\n      let callback;\n      if (property.evaluator) {\n        callback = property.evaluator;\n      } else if (property.type === StringType) {\n        callback = (feature) =>\n          getStringNumberEquivalent(feature.get(property.name));\n      } else if (property.type === ColorType) {\n        callback = (feature) =>\n          packColor([...asArray(feature.get(property.name) || '#eee')]);\n      } else if (property.type === BooleanType) {\n        callback = (feature) => (feature.get(property.name) ? 1.0 : 0.0);\n      } else {\n        callback = (feature) => feature.get(property.name);\n      }\n\n      return {\n        name: property.name,\n        size: getGlslSizeFromType(property.type),\n        callback,\n      };\n    },\n  );\n\n  // add functions that were collected in the compilation contexts\n  for (const functionName in vertContext.functions) {\n    builder.addVertexShaderFunction(vertContext.functions[functionName]);\n  }\n  for (const functionName in fragContext.functions) {\n    builder.addFragmentShaderFunction(fragContext.functions[functionName]);\n  }\n\n  return {\n    builder: builder,\n    attributes: attributes.reduce(\n      (prev, curr) => ({\n        ...prev,\n        [curr.name]: {callback: curr.callback, size: curr.size},\n      }),\n      {},\n    ),\n    uniforms: uniforms,\n  };\n}\n","/**\n * @module ol/layer/WebGLTile\n */\nimport BaseTileLayer from './BaseTile.js';\nimport LayerProperty from '../layer/Property.js';\nimport WebGLTileLayerRenderer, {\n  Attributes,\n  Uniforms,\n} from '../renderer/webgl/TileLayer.js';\nimport {ColorType, NumberType} from '../expr/expression.js';\nimport {\n  PALETTE_TEXTURE_ARRAY,\n  getStringNumberEquivalent,\n  newCompilationContext,\n  uniformNameForVariable,\n} from '../expr/gpu.js';\nimport {expressionToGlsl} from '../webgl/styleparser.js';\n\n/**\n * @typedef {import(\"../source/DataTile.js\").default|import(\"../source/TileImage.js\").default} SourceType\n */\n\n/**\n * @typedef {Object} Style\n * Translates tile data to rendered pixels.\n *\n * @property {Object<string, (string|number)>} [variables] Style variables.  Each variable must hold a number or string.  These\n * variables can be used in the `color`, `brightness`, `contrast`, `exposure`, `saturation` and `gamma`\n * {@link import(\"../expr/expression.js\").ExpressionValue expressions}, using the `['var', 'varName']` operator.\n * To update style variables, use the {@link import(\"./WebGLTile.js\").default#updateStyleVariables} method.\n * @property {import(\"../expr/expression.js\").ExpressionValue} [color] An expression applied to color values.\n * @property {import(\"../expr/expression.js\").ExpressionValue} [brightness=0] Value used to decrease or increase\n * the layer brightness.  Values range from -1 to 1.\n * @property {import(\"../expr/expression.js\").ExpressionValue} [contrast=0] Value used to decrease or increase\n * the layer contrast.  Values range from -1 to 1.\n * @property {import(\"../expr/expression.js\").ExpressionValue} [exposure=0] Value used to decrease or increase\n * the layer exposure.  Values range from -1 to 1.\n * @property {import(\"../expr/expression.js\").ExpressionValue} [saturation=0] Value used to decrease or increase\n * the layer saturation.  Values range from -1 to 1.\n * @property {import(\"../expr/expression.js\").ExpressionValue} [gamma=1] Apply a gamma correction to the layer.\n * Values range from 0 to infinity.\n */\n\n/**\n * @typedef {Object} Options\n * @property {Style} [style] Style to apply to the layer.\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`\n * means no preloading.\n * @property {SourceType} [source] Source for this layer.\n * @property {Array<SourceType>|function(import(\"../extent.js\").Extent, number):Array<SourceType>} [sources] Array\n * of sources for this layer. Takes precedence over `source`. Can either be an array of sources, or a function that\n * expects an extent and a resolution (in view projection units per pixel) and returns an array of sources. See\n * {@link module:ol/source.sourcesFromTileGrid} for a helper function to generate sources that are organized in a\n * pyramid following the same pattern as a tile grid. **Note:** All sources must have the same band count and content.\n * @property {import(\"../Map.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\n * use {@link module:ol/Map~Map#addLayer}.\n * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.\n * @property {number} [cacheSize=512] The internal texture cache size.  This needs to be large enough to render\n * two zoom levels worth of tiles.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n\n/**\n * @typedef {Object} ParsedStyle\n * @property {string} vertexShader The vertex shader.\n * @property {string} fragmentShader The fragment shader.\n * @property {Object<string,import(\"../webgl/Helper.js\").UniformValue>} uniforms Uniform definitions.\n * @property {Array<import(\"../webgl/PaletteTexture.js\").default>} paletteTextures Palette textures.\n */\n\n/**\n * @param {Style} style The layer style.\n * @param {number} [bandCount] The number of bands.\n * @return {ParsedStyle} Shaders and uniforms generated from the style.\n */\nfunction parseStyle(style, bandCount) {\n  const vertexShader = `\n    attribute vec2 ${Attributes.TEXTURE_COORD};\n    uniform mat4 ${Uniforms.TILE_TRANSFORM};\n    uniform float ${Uniforms.TEXTURE_PIXEL_WIDTH};\n    uniform float ${Uniforms.TEXTURE_PIXEL_HEIGHT};\n    uniform float ${Uniforms.TEXTURE_RESOLUTION};\n    uniform float ${Uniforms.TEXTURE_ORIGIN_X};\n    uniform float ${Uniforms.TEXTURE_ORIGIN_Y};\n    uniform float ${Uniforms.DEPTH};\n\n    varying vec2 v_textureCoord;\n    varying vec2 v_mapCoord;\n\n    void main() {\n      v_textureCoord = ${Attributes.TEXTURE_COORD};\n      v_mapCoord = vec2(\n        ${Uniforms.TEXTURE_ORIGIN_X} + ${Uniforms.TEXTURE_RESOLUTION} * ${Uniforms.TEXTURE_PIXEL_WIDTH} * v_textureCoord[0],\n        ${Uniforms.TEXTURE_ORIGIN_Y} - ${Uniforms.TEXTURE_RESOLUTION} * ${Uniforms.TEXTURE_PIXEL_HEIGHT} * v_textureCoord[1]\n      );\n      gl_Position = ${Uniforms.TILE_TRANSFORM} * vec4(${Attributes.TEXTURE_COORD}, ${Uniforms.DEPTH}, 1.0);\n    }\n  `;\n\n  /**\n   * @type {import(\"../expr/gpu.js\").CompilationContext}\n   */\n  const context = {\n    ...newCompilationContext(),\n    inFragmentShader: true,\n    bandCount: bandCount,\n    style: style,\n  };\n\n  const pipeline = [];\n\n  if (style.color !== undefined) {\n    const color = expressionToGlsl(context, style.color, ColorType);\n    pipeline.push(`color = ${color};`);\n  }\n\n  if (style.contrast !== undefined) {\n    const contrast = expressionToGlsl(context, style.contrast, NumberType);\n    pipeline.push(\n      `color.rgb = clamp((${contrast} + 1.0) * color.rgb - (${contrast} / 2.0), vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));`,\n    );\n  }\n\n  if (style.exposure !== undefined) {\n    const exposure = expressionToGlsl(context, style.exposure, NumberType);\n    pipeline.push(\n      `color.rgb = clamp((${exposure} + 1.0) * color.rgb, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));`,\n    );\n  }\n\n  if (style.saturation !== undefined) {\n    const saturation = expressionToGlsl(context, style.saturation, NumberType);\n    pipeline.push(`\n      float saturation = ${saturation} + 1.0;\n      float sr = (1.0 - saturation) * 0.2126;\n      float sg = (1.0 - saturation) * 0.7152;\n      float sb = (1.0 - saturation) * 0.0722;\n      mat3 saturationMatrix = mat3(\n        sr + saturation, sr, sr,\n        sg, sg + saturation, sg,\n        sb, sb, sb + saturation\n      );\n      color.rgb = clamp(saturationMatrix * color.rgb, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    `);\n  }\n\n  if (style.gamma !== undefined) {\n    const gamma = expressionToGlsl(context, style.gamma, NumberType);\n    pipeline.push(`color.rgb = pow(color.rgb, vec3(1.0 / ${gamma}));`);\n  }\n\n  if (style.brightness !== undefined) {\n    const brightness = expressionToGlsl(context, style.brightness, NumberType);\n    pipeline.push(\n      `color.rgb = clamp(color.rgb + ${brightness}, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));`,\n    );\n  }\n\n  /** @type {Object<string,import(\"../webgl/Helper\").UniformValue>} */\n  const uniforms = {};\n\n  const numVariables = Object.keys(context.variables).length;\n  if (numVariables > 1 && !style.variables) {\n    throw new Error(\n      `Missing variables in style (expected ${context.variables})`,\n    );\n  }\n\n  for (let i = 0; i < numVariables; ++i) {\n    const variable = context.variables[Object.keys(context.variables)[i]];\n    if (!(variable.name in style.variables)) {\n      throw new Error(`Missing '${variable.name}' in style variables`);\n    }\n    const uniformName = uniformNameForVariable(variable.name);\n    uniforms[uniformName] = function () {\n      let value = style.variables[variable.name];\n      if (typeof value === 'string') {\n        value = getStringNumberEquivalent(value);\n      }\n      return value !== undefined ? value : -9999999; // to avoid matching with the first string literal\n    };\n  }\n\n  const uniformDeclarations = Object.keys(uniforms).map(function (name) {\n    return `uniform float ${name};`;\n  });\n\n  const textureCount = Math.ceil(bandCount / 4);\n  uniformDeclarations.push(\n    `uniform sampler2D ${Uniforms.TILE_TEXTURE_ARRAY}[${textureCount}];`,\n  );\n\n  if (context.paletteTextures) {\n    uniformDeclarations.push(\n      `uniform sampler2D ${PALETTE_TEXTURE_ARRAY}[${context.paletteTextures.length}];`,\n    );\n  }\n\n  const functionDefintions = Object.keys(context.functions).map(\n    function (name) {\n      return context.functions[name];\n    },\n  );\n\n  const fragmentShader = `\n    #ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n    #else\n    precision mediump float;\n    #endif\n\n    varying vec2 v_textureCoord;\n    varying vec2 v_mapCoord;\n    uniform vec4 ${Uniforms.RENDER_EXTENT};\n    uniform float ${Uniforms.TRANSITION_ALPHA};\n    uniform float ${Uniforms.TEXTURE_PIXEL_WIDTH};\n    uniform float ${Uniforms.TEXTURE_PIXEL_HEIGHT};\n    uniform float ${Uniforms.RESOLUTION};\n    uniform float ${Uniforms.ZOOM};\n\n    ${uniformDeclarations.join('\\n')}\n\n    ${functionDefintions.join('\\n')}\n\n    void main() {\n      if (\n        v_mapCoord[0] < ${Uniforms.RENDER_EXTENT}[0] ||\n        v_mapCoord[1] < ${Uniforms.RENDER_EXTENT}[1] ||\n        v_mapCoord[0] > ${Uniforms.RENDER_EXTENT}[2] ||\n        v_mapCoord[1] > ${Uniforms.RENDER_EXTENT}[3]\n      ) {\n        discard;\n      }\n\n      vec4 color = texture2D(${\n        Uniforms.TILE_TEXTURE_ARRAY\n      }[0],  v_textureCoord);\n\n      ${pipeline.join('\\n')}\n\n      gl_FragColor = color;\n      gl_FragColor.rgb *= gl_FragColor.a;\n      gl_FragColor *= ${Uniforms.TRANSITION_ALPHA};\n    }`;\n\n  return {\n    vertexShader: vertexShader,\n    fragmentShader: fragmentShader,\n    uniforms: uniforms,\n    paletteTextures: context.paletteTextures,\n  };\n}\n\n/**\n * @classdesc\n * For layer sources that provide pre-rendered, tiled images in grids that are\n * organized by zoom levels for specific resolutions.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @extends BaseTileLayer<SourceType, WebGLTileLayerRenderer>\n * @fires import(\"../render/Event.js\").RenderEvent\n * @api\n */\nclass WebGLTileLayer extends BaseTileLayer {\n  /**\n   * @param {Options} options Tile layer options.\n   */\n  constructor(options) {\n    options = options ? Object.assign({}, options) : {};\n\n    const style = options.style || {};\n    delete options.style;\n\n    const cacheSize = options.cacheSize;\n    delete options.cacheSize;\n\n    super(options);\n\n    /**\n     * @type {Array<SourceType>|function(import(\"../extent.js\").Extent, number):Array<SourceType>}\n     * @private\n     */\n    this.sources_ = options.sources;\n\n    /**\n     * @type {SourceType|null}\n     * @private\n     */\n    this.renderedSource_ = null;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.renderedResolution_ = NaN;\n\n    /**\n     * @type {Style}\n     * @private\n     */\n    this.style_ = style;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.cacheSize_ = cacheSize;\n\n    /**\n     * @type {Object<string, (string|number)>}\n     * @private\n     */\n    this.styleVariables_ = this.style_.variables || {};\n\n    this.addChangeListener(LayerProperty.SOURCE, this.handleSourceUpdate_);\n  }\n\n  /**\n   * Gets the sources for this layer, for a given extent and resolution.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @return {Array<SourceType>} Sources.\n   */\n  getSources(extent, resolution) {\n    const source = this.getSource();\n    return this.sources_\n      ? typeof this.sources_ === 'function'\n        ? this.sources_(extent, resolution)\n        : this.sources_\n      : source\n        ? [source]\n        : [];\n  }\n\n  /**\n   * @return {SourceType} The source being rendered.\n   */\n  getRenderSource() {\n    return this.renderedSource_ || this.getSource();\n  }\n\n  /**\n   * @return {import(\"../source/Source.js\").State} Source state.\n   */\n  getSourceState() {\n    const source = this.getRenderSource();\n    return source ? source.getState() : 'undefined';\n  }\n\n  /**\n   * @private\n   */\n  handleSourceUpdate_() {\n    if (this.hasRenderer()) {\n      this.getRenderer().clearCache();\n    }\n    if (this.getSource()) {\n      this.setStyle(this.style_);\n    }\n  }\n\n  /**\n   * @private\n   * @return {number} The number of source bands.\n   */\n  getSourceBandCount_() {\n    const max = Number.MAX_SAFE_INTEGER;\n    const sources = this.getSources([-max, -max, max, max], max);\n    return sources && sources.length && 'bandCount' in sources[0]\n      ? sources[0].bandCount\n      : 4;\n  }\n\n  createRenderer() {\n    const parsedStyle = parseStyle(this.style_, this.getSourceBandCount_());\n\n    return new WebGLTileLayerRenderer(this, {\n      vertexShader: parsedStyle.vertexShader,\n      fragmentShader: parsedStyle.fragmentShader,\n      uniforms: parsedStyle.uniforms,\n      cacheSize: this.cacheSize_,\n      paletteTextures: parsedStyle.paletteTextures,\n    });\n  }\n\n  /**\n   * @param {import(\"../Map\").FrameState} frameState Frame state.\n   * @param {Array<SourceType>} sources Sources.\n   * @return {HTMLElement} Canvas.\n   */\n  renderSources(frameState, sources) {\n    const layerRenderer = this.getRenderer();\n    let canvas;\n    for (let i = 0, ii = sources.length; i < ii; ++i) {\n      this.renderedSource_ = sources[i];\n      if (layerRenderer.prepareFrame(frameState)) {\n        canvas = layerRenderer.renderFrame(frameState);\n      }\n    }\n    return canvas;\n  }\n\n  /**\n   * @param {?import(\"../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target which the renderer may (but need not) use\n   * for rendering its content.\n   * @return {HTMLElement} The rendered element.\n   */\n  render(frameState, target) {\n    this.rendered = true;\n    const viewState = frameState.viewState;\n    const sources = this.getSources(frameState.extent, viewState.resolution);\n    let ready = true;\n    for (let i = 0, ii = sources.length; i < ii; ++i) {\n      const source = sources[i];\n      const sourceState = source.getState();\n      if (sourceState == 'loading') {\n        const onChange = () => {\n          if (source.getState() == 'ready') {\n            source.removeEventListener('change', onChange);\n            this.changed();\n          }\n        };\n        source.addEventListener('change', onChange);\n      }\n      ready = ready && sourceState == 'ready';\n    }\n    const canvas = this.renderSources(frameState, sources);\n    if (this.getRenderer().renderComplete && ready) {\n      // Fully rendered, done.\n      this.renderedResolution_ = viewState.resolution;\n      return canvas;\n    }\n    // Render sources from previously fully rendered frames\n    if (this.renderedResolution_ > 0.5 * viewState.resolution) {\n      const altSources = this.getSources(\n        frameState.extent,\n        this.renderedResolution_,\n      ).filter((source) => !sources.includes(source));\n      if (altSources.length > 0) {\n        return this.renderSources(frameState, altSources);\n      }\n    }\n    return canvas;\n  }\n\n  /**\n   * Update the layer style.  The `updateStyleVariables` function is a more efficient\n   * way to update layer rendering.  In cases where the whole style needs to be updated,\n   * this method may be called instead.  Note that calling this method will also replace\n   * any previously set variables, so the new style also needs to include new variables,\n   * if needed.\n   * @param {Style} style The new style.\n   */\n  setStyle(style) {\n    this.styleVariables_ = style.variables || {};\n    this.style_ = style;\n    const parsedStyle = parseStyle(this.style_, this.getSourceBandCount_());\n    const renderer = this.getRenderer();\n    renderer.reset({\n      vertexShader: parsedStyle.vertexShader,\n      fragmentShader: parsedStyle.fragmentShader,\n      uniforms: parsedStyle.uniforms,\n      paletteTextures: parsedStyle.paletteTextures,\n    });\n    this.changed();\n  }\n\n  /**\n   * Update any variables used by the layer style and trigger a re-render.\n   * @param {Object<string, number>} variables Variables to update.\n   * @api\n   */\n  updateStyleVariables(variables) {\n    Object.assign(this.styleVariables_, variables);\n    this.changed();\n  }\n}\n\n/**\n * Clean up underlying WebGL resources.\n * @function\n * @api\n */\nWebGLTileLayer.prototype.dispose;\n\nexport default WebGLTileLayer;\n","/**\n * @module ol/source/DataTile\n */\nimport DataTile from '../DataTile.js';\nimport EventType from '../events/EventType.js';\nimport ReprojDataTile from '../reproj/DataTile.js';\nimport TileCache from '../TileCache.js';\nimport TileEventType from './TileEventType.js';\nimport TileSource, {TileSourceEvent} from './Tile.js';\nimport TileState from '../TileState.js';\nimport {\n  createXYZ,\n  extentFromProjection,\n  getForProjection as getTileGridForProjection,\n} from '../tilegrid.js';\nimport {equivalent, get as getProjection} from '../proj.js';\nimport {getKeyZXY} from '../tilecoord.js';\nimport {getUid} from '../util.js';\nimport {toPromise} from '../functions.js';\nimport {toSize} from '../size.js';\n\n/**\n * Data tile loading function.  The function is called with z, x, and y tile coordinates and\n * returns {@link import(\"../DataTile.js\").Data data} for a tile or a promise for the same.\n * @typedef {function(number, number, number) : (import(\"../DataTile.js\").Data|Promise<import(\"../DataTile.js\").Data>)} Loader\n */\n\n/**\n * @typedef {Object} Options\n * @property {Loader} [loader] Data loader.  Called with z, x, and y tile coordinates.\n * Returns {@link import(\"../DataTile.js\").Data data} for a tile or a promise for the same.\n * For loaders that generate images, the promise should not resolve until the image is loaded.\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [maxZoom=42] Optional max zoom level. Not used if `tileGrid` is provided.\n * @property {number} [minZoom=0] Optional min zoom level. Not used if `tileGrid` is provided.\n * @property {number|import(\"../size.js\").Size} [tileSize=[256, 256]] The pixel width and height of the source tiles.\n * This may be different than the rendered pixel size if a `tileGrid` is provided.\n * @property {number} [gutter=0] The size in pixels of the gutter around data tiles to ignore.\n * This allows artifacts of rendering at tile edges to be ignored.\n * Supported data should be wider and taller than the tile size by a value of `2 x gutter`.\n * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.\n * @property {import(\"../proj.js\").ProjectionLike} [projection='EPSG:3857'] Tile projection.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {boolean} [opaque=false] Whether the layer is opaque.\n * @property {import(\"./Source.js\").State} [state] The source state.\n * @property {boolean} [wrapX=false] Render tiles beyond the antimeridian.\n * @property {number} [transition] Transition time when fading in new tiles (in milliseconds).\n * @property {number} [bandCount=4] Number of bands represented in the data.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n */\n\n/**\n * @classdesc\n * A source for typed array data tiles.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n * @api\n */\nclass DataTileSource extends TileSource {\n  /**\n   * @param {Options} options DataTile source options.\n   */\n  constructor(options) {\n    const projection =\n      options.projection === undefined ? 'EPSG:3857' : options.projection;\n\n    let tileGrid = options.tileGrid;\n    if (tileGrid === undefined && projection) {\n      tileGrid = createXYZ({\n        extent: extentFromProjection(projection),\n        maxResolution: options.maxResolution,\n        maxZoom: options.maxZoom,\n        minZoom: options.minZoom,\n        tileSize: options.tileSize,\n      });\n    }\n\n    super({\n      cacheSize: 0.1, // don't cache on the source\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      projection: projection,\n      tileGrid: tileGrid,\n      opaque: options.opaque,\n      state: options.state,\n      wrapX: options.wrapX,\n      transition: options.transition,\n      interpolate: options.interpolate,\n    });\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = options.gutter !== undefined ? options.gutter : 0;\n\n    /**\n     * @private\n     * @type {import('../size.js').Size|null}\n     */\n    this.tileSize_ = options.tileSize ? toSize(options.tileSize) : null;\n\n    /**\n     * @private\n     * @type {Array<import('../size.js').Size>|null}\n     */\n    this.tileSizes_ = null;\n\n    /**\n     * @private\n     * @type {!Object<string, boolean>}\n     */\n    this.tileLoadingKeys_ = {};\n\n    /**\n     * @private\n     */\n    this.loader_ = options.loader;\n\n    this.handleTileChange_ = this.handleTileChange_.bind(this);\n\n    /**\n     * @type {number}\n     */\n    this.bandCount = options.bandCount === undefined ? 4 : options.bandCount; // assume RGBA if undefined\n\n    /**\n     * @private\n     * @type {!Object<string, import(\"../tilegrid/TileGrid.js\").default>}\n     */\n    this.tileGridForProjection_ = {};\n\n    /**\n     * @private\n     * @type {!Object<string, import(\"../TileCache.js\").default>}\n     */\n    this.tileCacheForProjection_ = {};\n  }\n\n  /**\n   * Set the source tile sizes.  The length of the array is expected to match the number of\n   * levels in the tile grid.\n   * @protected\n   * @param {Array<import('../size.js').Size>} tileSizes An array of tile sizes.\n   */\n  setTileSizes(tileSizes) {\n    this.tileSizes_ = tileSizes;\n  }\n\n  /**\n   * Get the source tile size at the given zoom level.  This may be different than the rendered tile\n   * size.\n   * @protected\n   * @param {number} z Tile zoom level.\n   * @return {import('../size.js').Size} The source tile size.\n   */\n  getTileSize(z) {\n    if (this.tileSizes_) {\n      return this.tileSizes_[z];\n    }\n    if (this.tileSize_) {\n      return this.tileSize_;\n    }\n    const tileGrid = this.getTileGrid();\n    return tileGrid ? toSize(tileGrid.getTileSize(z)) : [256, 256];\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {number} Gutter.\n   */\n  getGutterForProjection(projection) {\n    const thisProj = this.getProjection();\n    if (!thisProj || equivalent(thisProj, projection)) {\n      return this.gutter_;\n    }\n\n    return 0;\n  }\n\n  /**\n   * @param {Loader} loader The data loader.\n   * @protected\n   */\n  setLoader(loader) {\n    this.loader_ = loader;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../proj/Projection.js\").default} targetProj The output projection.\n   * @param {import(\"../proj/Projection.js\").default} sourceProj The input projection.\n   * @return {!DataTile} Tile.\n   */\n  getReprojTile_(z, x, y, targetProj, sourceProj) {\n    const cache = this.getTileCacheForProjection(targetProj);\n    const tileCoordKey = getKeyZXY(z, x, y);\n    if (cache.containsKey(tileCoordKey)) {\n      const tile = cache.get(tileCoordKey);\n      if (tile && tile.key == this.getKey()) {\n        return tile;\n      }\n    }\n\n    const tileGrid = this.getTileGrid();\n    const reprojTilePixelRatio = Math.max.apply(\n      null,\n      tileGrid.getResolutions().map((r, z) => {\n        const tileSize = toSize(tileGrid.getTileSize(z));\n        const textureSize = this.getTileSize(z);\n        return Math.max(\n          textureSize[0] / tileSize[0],\n          textureSize[1] / tileSize[1],\n        );\n      }),\n    );\n\n    const sourceTileGrid = this.getTileGridForProjection(sourceProj);\n    const targetTileGrid = this.getTileGridForProjection(targetProj);\n    const tileCoord = [z, x, y];\n    const wrappedTileCoord = this.getTileCoordForTileUrlFunction(\n      tileCoord,\n      targetProj,\n    );\n\n    const options = Object.assign(\n      {\n        sourceProj,\n        sourceTileGrid,\n        targetProj,\n        targetTileGrid,\n        tileCoord,\n        wrappedTileCoord,\n        pixelRatio: reprojTilePixelRatio,\n        gutter: this.getGutterForProjection(sourceProj),\n        getTileFunction: (z, x, y, pixelRatio) =>\n          this.getTile(z, x, y, pixelRatio, sourceProj),\n      },\n      this.tileOptions,\n    );\n    const newTile = new ReprojDataTile(options);\n    newTile.key = this.getKey();\n    return newTile;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!DataTile} Tile.\n   */\n  getTile(z, x, y, pixelRatio, projection) {\n    const sourceProjection = this.getProjection();\n    if (\n      sourceProjection &&\n      projection &&\n      !equivalent(sourceProjection, projection)\n    ) {\n      return this.getReprojTile_(z, x, y, projection, sourceProjection);\n    }\n\n    const size = this.getTileSize(z);\n    const tileCoordKey = getKeyZXY(z, x, y);\n    if (this.tileCache.containsKey(tileCoordKey)) {\n      return this.tileCache.get(tileCoordKey);\n    }\n\n    const sourceLoader = this.loader_;\n\n    function loader() {\n      return toPromise(function () {\n        return sourceLoader(z, x, y);\n      });\n    }\n\n    const options = Object.assign(\n      {\n        tileCoord: [z, x, y],\n        loader: loader,\n        size: size,\n      },\n      this.tileOptions,\n    );\n\n    const tile = new DataTile(options);\n    tile.key = this.getKey();\n    tile.addEventListener(EventType.CHANGE, this.handleTileChange_);\n\n    this.tileCache.set(tileCoordKey, tile);\n    return tile;\n  }\n\n  /**\n   * Handle tile change events.\n   * @param {import(\"../events/Event.js\").default} event Event.\n   */\n  handleTileChange_(event) {\n    const tile = /** @type {import(\"../Tile.js\").default} */ (event.target);\n    const uid = getUid(tile);\n    const tileState = tile.getState();\n    let type;\n    if (tileState == TileState.LOADING) {\n      this.tileLoadingKeys_[uid] = true;\n      type = TileEventType.TILELOADSTART;\n    } else if (uid in this.tileLoadingKeys_) {\n      delete this.tileLoadingKeys_[uid];\n      type =\n        tileState == TileState.ERROR\n          ? TileEventType.TILELOADERROR\n          : tileState == TileState.LOADED\n            ? TileEventType.TILELOADEND\n            : undefined;\n    }\n    if (type) {\n      this.dispatchEvent(new TileSourceEvent(type, tile));\n    }\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n   */\n  getTileGridForProjection(projection) {\n    const thisProj = this.getProjection();\n    if (this.tileGrid && (!thisProj || equivalent(thisProj, projection))) {\n      return this.tileGrid;\n    }\n\n    const projKey = getUid(projection);\n    if (!(projKey in this.tileGridForProjection_)) {\n      this.tileGridForProjection_[projKey] =\n        getTileGridForProjection(projection);\n    }\n    return this.tileGridForProjection_[projKey];\n  }\n\n  /**\n   * Sets the tile grid to use when reprojecting the tiles to the given\n   * projection instead of the default tile grid for the projection.\n   *\n   * This can be useful when the default tile grid cannot be created\n   * (e.g. projection has no extent defined) or\n   * for optimization reasons (custom tile size, resolutions, ...).\n   *\n   * @param {import(\"../proj.js\").ProjectionLike} projection Projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} tilegrid Tile grid to use for the projection.\n   * @api\n   */\n  setTileGridForProjection(projection, tilegrid) {\n    const proj = getProjection(projection);\n    if (proj) {\n      const projKey = getUid(proj);\n      if (!(projKey in this.tileGridForProjection_)) {\n        this.tileGridForProjection_[projKey] = tilegrid;\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../TileCache.js\").default} Tile cache.\n   */\n  getTileCacheForProjection(projection) {\n    const thisProj = this.getProjection();\n    if (!thisProj || equivalent(thisProj, projection)) {\n      return this.tileCache;\n    }\n\n    const projKey = getUid(projection);\n    if (!(projKey in this.tileCacheForProjection_)) {\n      this.tileCacheForProjection_[projKey] = new TileCache(0.1); // don't cache\n    }\n    return this.tileCacheForProjection_[projKey];\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @param {!Object<string, boolean>} usedTiles Used tiles.\n   */\n  expireCache(projection, usedTiles) {\n    const usedTileCache = this.getTileCacheForProjection(projection);\n\n    this.tileCache.expireCache(\n      this.tileCache == usedTileCache ? usedTiles : {},\n    );\n    for (const id in this.tileCacheForProjection_) {\n      const tileCache = this.tileCacheForProjection_[id];\n      tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});\n    }\n  }\n\n  clear() {\n    super.clear();\n    for (const id in this.tileCacheForProjection_) {\n      this.tileCacheForProjection_[id].clear();\n    }\n  }\n}\n\nexport default DataTileSource;\n","const registry = new Map();\n\nexport function addDecoder(cases, importFn) {\n  if (!Array.isArray(cases)) {\n    cases = [cases]; // eslint-disable-line no-param-reassign\n  }\n  cases.forEach((c) => registry.set(c, importFn));\n}\n\nexport async function getDecoder(fileDirectory) {\n  const importFn = registry.get(fileDirectory.Compression);\n  if (!importFn) {\n    throw new Error(`Unknown compression method identifier: ${fileDirectory.Compression}`);\n  }\n  const Decoder = await importFn();\n  return new Decoder(fileDirectory);\n}\n\n// Add default decoders to registry (end-user may override with other implementations)\naddDecoder([undefined, 1], () => import('./raw.js').then((m) => m.default));\naddDecoder(5, () => import('./lzw.js').then((m) => m.default));\naddDecoder(6, () => {\n  throw new Error('old style JPEG compression is not supported.');\n});\naddDecoder(7, () => import('./jpeg.js').then((m) => m.default));\naddDecoder([8, 32946], () => import('./deflate.js').then((m) => m.default));\naddDecoder(32773, () => import('./packbits.js').then((m) => m.default));\naddDecoder(34887, () => import('./lerc.js')\n  .then(async (m) => {\n    await m.zstd.init();\n    return m;\n  })\n  .then((m) => m.default),\n);\naddDecoder(50001, () => import('./webimage.js').then((m) => m.default));\n","import { getDecoder } from './compression/index.js';\n\nconst defaultPoolSize = typeof navigator !== 'undefined' ? (navigator.hardwareConcurrency || 2) : 2;\n\n/**\n * @module pool\n */\n\n/**\n * Pool for workers to decode chunks of the images.\n */\nclass Pool {\n  /**\n   * @constructor\n   * @param {Number} [size] The size of the pool. Defaults to the number of CPUs\n   *                      available. When this parameter is `null` or 0, then the\n   *                      decoding will be done in the main thread.\n   * @param {function(): Worker} [createWorker] A function that creates the decoder worker.\n   * Defaults to a worker with all decoders that ship with geotiff.js. The `createWorker()`\n   * function is expected to return a `Worker` compatible with Web Workers. For code that\n   * runs in Node, [web-worker](https://www.npmjs.com/package/web-worker) is a good choice.\n   *\n   * A worker that uses a custom lzw decoder would look like this `my-custom-worker.js` file:\n   * ```js\n   * import { addDecoder, getDecoder } from 'geotiff';\n   * addDecoder(5, () => import ('./my-custom-lzw').then((m) => m.default));\n   * self.addEventListener('message', async (e) => {\n   *   const { id, fileDirectory, buffer } = e.data;\n   *   const decoder = await getDecoder(fileDirectory);\n   *   const decoded = await decoder.decode(fileDirectory, buffer);\n   *   self.postMessage({ decoded, id }, [decoded]);\n   * });\n   * ```\n   * The way the above code is built into a worker by the `createWorker()` function\n   * depends on the used bundler. For most bundlers, something like this will work:\n   * ```js\n   * function createWorker() {\n   *   return new Worker(new URL('./my-custom-worker.js', import.meta.url));\n   * }\n   * ```\n   */\n  constructor(size = defaultPoolSize, createWorker) {\n    this.workers = null;\n    this._awaitingDecoder = null;\n    this.size = size;\n    this.messageId = 0;\n    if (size) {\n      this._awaitingDecoder = createWorker ? Promise.resolve(createWorker) : new Promise((resolve) => {\n        import('./worker/decoder.js').then((module) => {\n          resolve(module.create);\n        });\n      });\n      this._awaitingDecoder.then((create) => {\n        this._awaitingDecoder = null;\n        this.workers = [];\n        for (let i = 0; i < size; i++) {\n          this.workers.push({ worker: create(), idle: true });\n        }\n      });\n    }\n  }\n\n  /**\n   * Decode the given block of bytes with the set compression method.\n   * @param {ArrayBuffer} buffer the array buffer of bytes to decode.\n   * @returns {Promise<ArrayBuffer>} the decoded result as a `Promise`\n   */\n  async decode(fileDirectory, buffer) {\n    if (this._awaitingDecoder) {\n      await this._awaitingDecoder;\n    }\n    return this.size === 0\n      ? getDecoder(fileDirectory).then((decoder) => decoder.decode(fileDirectory, buffer))\n      : new Promise((resolve) => {\n        const worker = this.workers.find((candidate) => candidate.idle)\n          || this.workers[Math.floor(Math.random() * this.size)];\n        worker.idle = false;\n        const id = this.messageId++;\n        const onMessage = (e) => {\n          if (e.data.id === id) {\n            worker.idle = true;\n            resolve(e.data.decoded);\n            worker.worker.removeEventListener('message', onMessage);\n          }\n        };\n        worker.worker.addEventListener('message', onMessage);\n        worker.worker.postMessage({ fileDirectory, buffer, id }, [buffer]);\n      });\n  }\n\n  destroy() {\n    if (this.workers) {\n      this.workers.forEach((worker) => {\n        worker.worker.terminate();\n      });\n      this.workers = null;\n    }\n  }\n}\n\nexport default Pool;\n","export function fromWhiteIsZero(raster, max) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  let value;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    value = 256 - (raster[i] / max * 256);\n    rgbRaster[j] = value;\n    rgbRaster[j + 1] = value;\n    rgbRaster[j + 2] = value;\n  }\n  return rgbRaster;\n}\n\nexport function fromBlackIsZero(raster, max) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  let value;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    value = raster[i] / max * 256;\n    rgbRaster[j] = value;\n    rgbRaster[j + 1] = value;\n    rgbRaster[j + 2] = value;\n  }\n  return rgbRaster;\n}\n\nexport function fromPalette(raster, colorMap) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  const greenOffset = colorMap.length / 3;\n  const blueOffset = colorMap.length / 3 * 2;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    const mapIndex = raster[i];\n    rgbRaster[j] = colorMap[mapIndex] / 65536 * 256;\n    rgbRaster[j + 1] = colorMap[mapIndex + greenOffset] / 65536 * 256;\n    rgbRaster[j + 2] = colorMap[mapIndex + blueOffset] / 65536 * 256;\n  }\n  return rgbRaster;\n}\n\nexport function fromCMYK(cmykRaster) {\n  const { width, height } = cmykRaster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  for (let i = 0, j = 0; i < cmykRaster.length; i += 4, j += 3) {\n    const c = cmykRaster[i];\n    const m = cmykRaster[i + 1];\n    const y = cmykRaster[i + 2];\n    const k = cmykRaster[i + 3];\n\n    rgbRaster[j] = 255 * ((255 - c) / 256) * ((255 - k) / 256);\n    rgbRaster[j + 1] = 255 * ((255 - m) / 256) * ((255 - k) / 256);\n    rgbRaster[j + 2] = 255 * ((255 - y) / 256) * ((255 - k) / 256);\n  }\n  return rgbRaster;\n}\n\nexport function fromYCbCr(yCbCrRaster) {\n  const { width, height } = yCbCrRaster;\n  const rgbRaster = new Uint8ClampedArray(width * height * 3);\n  for (let i = 0, j = 0; i < yCbCrRaster.length; i += 3, j += 3) {\n    const y = yCbCrRaster[i];\n    const cb = yCbCrRaster[i + 1];\n    const cr = yCbCrRaster[i + 2];\n\n    rgbRaster[j] = (y + (1.40200 * (cr - 0x80)));\n    rgbRaster[j + 1] = (y - (0.34414 * (cb - 0x80)) - (0.71414 * (cr - 0x80)));\n    rgbRaster[j + 2] = (y + (1.77200 * (cb - 0x80)));\n  }\n  return rgbRaster;\n}\n\nconst Xn = 0.95047;\nconst Yn = 1.00000;\nconst Zn = 1.08883;\n\n// from https://github.com/antimatter15/rgb-lab/blob/master/color.js\n\nexport function fromCIELab(cieLabRaster) {\n  const { width, height } = cieLabRaster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n\n  for (let i = 0, j = 0; i < cieLabRaster.length; i += 3, j += 3) {\n    const L = cieLabRaster[i + 0];\n    const a_ = cieLabRaster[i + 1] << 24 >> 24; // conversion from uint8 to int8\n    const b_ = cieLabRaster[i + 2] << 24 >> 24; // same\n\n    let y = (L + 16) / 116;\n    let x = (a_ / 500) + y;\n    let z = y - (b_ / 200);\n    let r;\n    let g;\n    let b;\n\n    x = Xn * ((x * x * x > 0.008856) ? x * x * x : (x - (16 / 116)) / 7.787);\n    y = Yn * ((y * y * y > 0.008856) ? y * y * y : (y - (16 / 116)) / 7.787);\n    z = Zn * ((z * z * z > 0.008856) ? z * z * z : (z - (16 / 116)) / 7.787);\n\n    r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n    g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n    b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\n    r = (r > 0.0031308) ? ((1.055 * (r ** (1 / 2.4))) - 0.055) : 12.92 * r;\n    g = (g > 0.0031308) ? ((1.055 * (g ** (1 / 2.4))) - 0.055) : 12.92 * g;\n    b = (b > 0.0031308) ? ((1.055 * (b ** (1 / 2.4))) - 0.055) : 12.92 * b;\n\n    rgbRaster[j] = Math.max(0, Math.min(1, r)) * 255;\n    rgbRaster[j + 1] = Math.max(0, Math.min(1, g)) * 255;\n    rgbRaster[j + 2] = Math.max(0, Math.min(1, b)) * 255;\n  }\n  return rgbRaster;\n}\n","/**\n * @module resample\n */\n\nfunction copyNewSize(array, width, height, samplesPerPixel = 1) {\n  return new (Object.getPrototypeOf(array).constructor)(width * height * samplesPerPixel);\n}\n\n/**\n * Resample the input arrays using nearest neighbor value selection.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  return valueArrays.map((array) => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n    for (let y = 0; y < outHeight; ++y) {\n      const cy = Math.min(Math.round(relY * y), inHeight - 1);\n      for (let x = 0; x < outWidth; ++x) {\n        const cx = Math.min(Math.round(relX * x), inWidth - 1);\n        const value = array[(cy * inWidth) + cx];\n        newArray[(y * outWidth) + x] = value;\n      }\n    }\n    return newArray;\n  });\n}\n\n// simple linear interpolation, code from:\n// https://en.wikipedia.org/wiki/Linear_interpolation#Programming_language_support\nfunction lerp(v0, v1, t) {\n  return ((1 - t) * v0) + (t * v1);\n}\n\n/**\n * Resample the input arrays using bilinear interpolation.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n\n  return valueArrays.map((array) => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n    for (let y = 0; y < outHeight; ++y) {\n      const rawY = relY * y;\n\n      const yl = Math.floor(rawY);\n      const yh = Math.min(Math.ceil(rawY), (inHeight - 1));\n\n      for (let x = 0; x < outWidth; ++x) {\n        const rawX = relX * x;\n        const tx = rawX % 1;\n\n        const xl = Math.floor(rawX);\n        const xh = Math.min(Math.ceil(rawX), (inWidth - 1));\n\n        const ll = array[(yl * inWidth) + xl];\n        const hl = array[(yl * inWidth) + xh];\n        const lh = array[(yh * inWidth) + xl];\n        const hh = array[(yh * inWidth) + xh];\n\n        const value = lerp(\n          lerp(ll, hl, tx),\n          lerp(lh, hh, tx),\n          rawY % 1,\n        );\n        newArray[(y * outWidth) + x] = value;\n      }\n    }\n    return newArray;\n  });\n}\n\n/**\n * Resample the input arrays using the selected resampling method.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resample(valueArrays, inWidth, inHeight, outWidth, outHeight, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight);\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight);\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n\n/**\n * Resample the pixel interleaved input array using nearest neighbor value selection.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\nexport function resampleNearestInterleaved(\n  valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n  for (let y = 0; y < outHeight; ++y) {\n    const cy = Math.min(Math.round(relY * y), inHeight - 1);\n    for (let x = 0; x < outWidth; ++x) {\n      const cx = Math.min(Math.round(relX * x), inWidth - 1);\n      for (let i = 0; i < samples; ++i) {\n        const value = valueArray[(cy * inWidth * samples) + (cx * samples) + i];\n        newArray[(y * outWidth * samples) + (x * samples) + i] = value;\n      }\n    }\n  }\n  return newArray;\n}\n\n/**\n * Resample the pixel interleaved input array using bilinear interpolation.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\nexport function resampleBilinearInterleaved(\n  valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n  for (let y = 0; y < outHeight; ++y) {\n    const rawY = relY * y;\n\n    const yl = Math.floor(rawY);\n    const yh = Math.min(Math.ceil(rawY), (inHeight - 1));\n\n    for (let x = 0; x < outWidth; ++x) {\n      const rawX = relX * x;\n      const tx = rawX % 1;\n\n      const xl = Math.floor(rawX);\n      const xh = Math.min(Math.ceil(rawX), (inWidth - 1));\n\n      for (let i = 0; i < samples; ++i) {\n        const ll = valueArray[(yl * inWidth * samples) + (xl * samples) + i];\n        const hl = valueArray[(yl * inWidth * samples) + (xh * samples) + i];\n        const lh = valueArray[(yh * inWidth * samples) + (xl * samples) + i];\n        const hh = valueArray[(yh * inWidth * samples) + (xh * samples) + i];\n\n        const value = lerp(\n          lerp(ll, hl, tx),\n          lerp(lh, hh, tx),\n          rawY % 1,\n        );\n        newArray[(y * outWidth * samples) + (x * samples) + i] = value;\n      }\n    }\n  }\n  return newArray;\n}\n\n/**\n * Resample the pixel interleaved input array using the selected resampling method.\n * @param {TypedArray} valueArray The input array to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                                 interleaved data\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray} The resampled rasters\n */\nexport function resampleInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearestInterleaved(\n        valueArray, inWidth, inHeight, outWidth, outHeight, samples,\n      );\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinearInterleaved(\n        valueArray, inWidth, inHeight, outWidth, outHeight, samples,\n      );\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n","/** @module geotiffimage */\nimport { getFloat16 } from '@petamoriken/float16';\nimport getAttribute from 'xml-utils/get-attribute.js';\nimport findTagsByName from 'xml-utils/find-tags-by-name.js';\n\nimport { photometricInterpretations, ExtraSamplesValues } from './globals.js';\nimport { fromWhiteIsZero, fromBlackIsZero, fromPalette, fromCMYK, fromYCbCr, fromCIELab } from './rgb.js';\nimport { getDecoder } from './compression/index.js';\nimport { resample, resampleInterleaved } from './resample.js';\n\n/**\n * @typedef {Object} ReadRasterOptions\n * @property {Array<number>} [window=whole window] the subset to read data from in pixels.\n * @property {Array<number>} [bbox=whole image] the subset to read data from in\n *                                           geographical coordinates.\n * @property {Array<number>} [samples=all samples] the selection of samples to read from. Default is all samples.\n * @property {boolean} [interleave=false] whether the data shall be read\n *                                             in one single array or separate\n *                                             arrays.\n * @property {Pool} [pool=null] The optional decoder pool to use.\n * @property {number} [width] The desired width of the output. When the width is not the\n *                                 same as the images, resampling will be performed.\n * @property {number} [height] The desired height of the output. When the width is not the\n *                                  same as the images, resampling will be performed.\n * @property {string} [resampleMethod='nearest'] The desired resampling method.\n * @property {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                                       to be aborted\n * @property {number|number[]} [fillValue] The value to use for parts of the image\n *                                              outside of the images extent. When multiple\n *                                              samples are requested, an array of fill values\n *                                              can be passed.\n */\n\n/** @typedef {import(\"./geotiff.js\").TypedArray} TypedArray */\n/** @typedef {import(\"./geotiff.js\").ReadRasterResult} ReadRasterResult */\n\nfunction sum(array, start, end) {\n  let s = 0;\n  for (let i = start; i < end; ++i) {\n    s += array[i];\n  }\n  return s;\n}\n\nfunction arrayForType(format, bitsPerSample, size) {\n  switch (format) {\n    case 1: // unsigned integer data\n      if (bitsPerSample <= 8) {\n        return new Uint8Array(size);\n      } else if (bitsPerSample <= 16) {\n        return new Uint16Array(size);\n      } else if (bitsPerSample <= 32) {\n        return new Uint32Array(size);\n      }\n      break;\n    case 2: // twos complement signed integer data\n      if (bitsPerSample === 8) {\n        return new Int8Array(size);\n      } else if (bitsPerSample === 16) {\n        return new Int16Array(size);\n      } else if (bitsPerSample === 32) {\n        return new Int32Array(size);\n      }\n      break;\n    case 3: // floating point data\n      switch (bitsPerSample) {\n        case 16:\n        case 32:\n          return new Float32Array(size);\n        case 64:\n          return new Float64Array(size);\n        default:\n          break;\n      }\n      break;\n    default:\n      break;\n  }\n  throw Error('Unsupported data format/bitsPerSample');\n}\n\nfunction needsNormalization(format, bitsPerSample) {\n  if ((format === 1 || format === 2) && bitsPerSample <= 32 && bitsPerSample % 8 === 0) {\n    return false;\n  } else if (format === 3 && (bitsPerSample === 16 || bitsPerSample === 32 || bitsPerSample === 64)) {\n    return false;\n  }\n  return true;\n}\n\nfunction normalizeArray(inBuffer, format, planarConfiguration, samplesPerPixel, bitsPerSample, tileWidth, tileHeight) {\n  // const inByteArray = new Uint8Array(inBuffer);\n  const view = new DataView(inBuffer);\n  const outSize = planarConfiguration === 2\n    ? tileHeight * tileWidth\n    : tileHeight * tileWidth * samplesPerPixel;\n  const samplesToTransfer = planarConfiguration === 2\n    ? 1 : samplesPerPixel;\n  const outArray = arrayForType(format, bitsPerSample, outSize);\n  // let pixel = 0;\n\n  const bitMask = parseInt('1'.repeat(bitsPerSample), 2);\n\n  if (format === 1) { // unsigned integer\n    // translation of https://github.com/OSGeo/gdal/blob/master/gdal/frmts/gtiff/geotiff.cpp#L7337\n    let pixelBitSkip;\n    // let sampleBitOffset = 0;\n    if (planarConfiguration === 1) {\n      pixelBitSkip = samplesPerPixel * bitsPerSample;\n      // sampleBitOffset = (samplesPerPixel - 1) * bitsPerSample;\n    } else {\n      pixelBitSkip = bitsPerSample;\n    }\n\n    // Bits per line rounds up to next byte boundary.\n    let bitsPerLine = tileWidth * pixelBitSkip;\n    if ((bitsPerLine & 7) !== 0) {\n      bitsPerLine = (bitsPerLine + 7) & (~7);\n    }\n\n    for (let y = 0; y < tileHeight; ++y) {\n      const lineBitOffset = y * bitsPerLine;\n      for (let x = 0; x < tileWidth; ++x) {\n        const pixelBitOffset = lineBitOffset + (x * samplesToTransfer * bitsPerSample);\n        for (let i = 0; i < samplesToTransfer; ++i) {\n          const bitOffset = pixelBitOffset + (i * bitsPerSample);\n          const outIndex = (((y * tileWidth) + x) * samplesToTransfer) + i;\n\n          const byteOffset = Math.floor(bitOffset / 8);\n          const innerBitOffset = bitOffset % 8;\n          if (innerBitOffset + bitsPerSample <= 8) {\n            outArray[outIndex] = (view.getUint8(byteOffset) >> (8 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 16) {\n            outArray[outIndex] = (view.getUint16(byteOffset) >> (16 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 24) {\n            const raw = (view.getUint16(byteOffset) << 8) | (view.getUint8(byteOffset + 2));\n            outArray[outIndex] = (raw >> (24 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else {\n            outArray[outIndex] = (view.getUint32(byteOffset) >> (32 - bitsPerSample) - innerBitOffset) & bitMask;\n          }\n\n          // let outWord = 0;\n          // for (let bit = 0; bit < bitsPerSample; ++bit) {\n          //   if (inByteArray[bitOffset >> 3]\n          //     & (0x80 >> (bitOffset & 7))) {\n          //     outWord |= (1 << (bitsPerSample - 1 - bit));\n          //   }\n          //   ++bitOffset;\n          // }\n\n          // outArray[outIndex] = outWord;\n          // outArray[pixel] = outWord;\n          // pixel += 1;\n        }\n        // bitOffset = bitOffset + pixelBitSkip - bitsPerSample;\n      }\n    }\n  } else if (format === 3) { // floating point\n    // Float16 is handled elsewhere\n    // normalize 16/24 bit floats to 32 bit floats in the array\n    // console.time();\n    // if (bitsPerSample === 16) {\n    //   for (let byte = 0, outIndex = 0; byte < inBuffer.byteLength; byte += 2, ++outIndex) {\n    //     outArray[outIndex] = getFloat16(view, byte);\n    //   }\n    // }\n    // console.timeEnd()\n  }\n\n  return outArray.buffer;\n}\n\n/**\n * GeoTIFF sub-file image.\n */\nclass GeoTIFFImage {\n  /**\n   * @constructor\n   * @param {Object} fileDirectory The parsed file directory\n   * @param {Object} geoKeys The parsed geo-keys\n   * @param {DataView} dataView The DataView for the underlying file.\n   * @param {Boolean} littleEndian Whether the file is encoded in little or big endian\n   * @param {Boolean} cache Whether or not decoded tiles shall be cached\n   * @param {import('./source/basesource').BaseSource} source The datasource to read from\n   */\n  constructor(fileDirectory, geoKeys, dataView, littleEndian, cache, source) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeys = geoKeys;\n    this.dataView = dataView;\n    this.littleEndian = littleEndian;\n    this.tiles = cache ? {} : null;\n    this.isTiled = !fileDirectory.StripOffsets;\n    const planarConfiguration = fileDirectory.PlanarConfiguration;\n    this.planarConfiguration = (typeof planarConfiguration === 'undefined') ? 1 : planarConfiguration;\n    if (this.planarConfiguration !== 1 && this.planarConfiguration !== 2) {\n      throw new Error('Invalid planar configuration.');\n    }\n\n    this.source = source;\n  }\n\n  /**\n   * Returns the associated parsed file directory.\n   * @returns {Object} the parsed file directory\n   */\n  getFileDirectory() {\n    return this.fileDirectory;\n  }\n\n  /**\n   * Returns the associated parsed geo keys.\n   * @returns {Object} the parsed geo keys\n   */\n  getGeoKeys() {\n    return this.geoKeys;\n  }\n\n  /**\n   * Returns the width of the image.\n   * @returns {Number} the width of the image\n   */\n  getWidth() {\n    return this.fileDirectory.ImageWidth;\n  }\n\n  /**\n   * Returns the height of the image.\n   * @returns {Number} the height of the image\n   */\n  getHeight() {\n    return this.fileDirectory.ImageLength;\n  }\n\n  /**\n   * Returns the number of samples per pixel.\n   * @returns {Number} the number of samples per pixel\n   */\n  getSamplesPerPixel() {\n    return typeof this.fileDirectory.SamplesPerPixel !== 'undefined'\n      ? this.fileDirectory.SamplesPerPixel : 1;\n  }\n\n  /**\n   * Returns the width of each tile.\n   * @returns {Number} the width of each tile\n   */\n  getTileWidth() {\n    return this.isTiled ? this.fileDirectory.TileWidth : this.getWidth();\n  }\n\n  /**\n   * Returns the height of each tile.\n   * @returns {Number} the height of each tile\n   */\n  getTileHeight() {\n    if (this.isTiled) {\n      return this.fileDirectory.TileLength;\n    }\n    if (typeof this.fileDirectory.RowsPerStrip !== 'undefined') {\n      return Math.min(this.fileDirectory.RowsPerStrip, this.getHeight());\n    }\n    return this.getHeight();\n  }\n\n  getBlockWidth() {\n    return this.getTileWidth();\n  }\n\n  getBlockHeight(y) {\n    if (this.isTiled || (y + 1) * this.getTileHeight() <= this.getHeight()) {\n      return this.getTileHeight();\n    } else {\n      return this.getHeight() - (y * this.getTileHeight());\n    }\n  }\n\n  /**\n   * Calculates the number of bytes for each pixel across all samples. Only full\n   * bytes are supported, an exception is thrown when this is not the case.\n   * @returns {Number} the bytes per pixel\n   */\n  getBytesPerPixel() {\n    let bytes = 0;\n    for (let i = 0; i < this.fileDirectory.BitsPerSample.length; ++i) {\n      bytes += this.getSampleByteSize(i);\n    }\n    return bytes;\n  }\n\n  getSampleByteSize(i) {\n    if (i >= this.fileDirectory.BitsPerSample.length) {\n      throw new RangeError(`Sample index ${i} is out of range.`);\n    }\n    return Math.ceil(this.fileDirectory.BitsPerSample[i] / 8);\n  }\n\n  getReaderForSample(sampleIndex) {\n    const format = this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n    const bitsPerSample = this.fileDirectory.BitsPerSample[sampleIndex];\n    switch (format) {\n      case 1: // unsigned integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getUint8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getUint16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getUint32;\n        }\n        break;\n      case 2: // twos complement signed integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getInt8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getInt16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getInt32;\n        }\n        break;\n      case 3:\n        switch (bitsPerSample) {\n          case 16:\n            return function (offset, littleEndian) {\n              return getFloat16(this, offset, littleEndian);\n            };\n          case 32:\n            return DataView.prototype.getFloat32;\n          case 64:\n            return DataView.prototype.getFloat64;\n          default:\n            break;\n        }\n        break;\n      default:\n        break;\n    }\n    throw Error('Unsupported data format/bitsPerSample');\n  }\n\n  getSampleFormat(sampleIndex = 0) {\n    return this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n  }\n\n  getBitsPerSample(sampleIndex = 0) {\n    return this.fileDirectory.BitsPerSample[sampleIndex];\n  }\n\n  getArrayForSample(sampleIndex, size) {\n    const format = this.getSampleFormat(sampleIndex);\n    const bitsPerSample = this.getBitsPerSample(sampleIndex);\n    return arrayForType(format, bitsPerSample, size);\n  }\n\n  /**\n   * Returns the decoded strip or tile.\n   * @param {Number} x the strip or tile x-offset\n   * @param {Number} y the tile y-offset (0 for stripped images)\n   * @param {Number} sample the sample to get for separated samples\n   * @param {import(\"./geotiff\").Pool|import(\"./geotiff\").BaseDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise.<ArrayBuffer>}\n   */\n  async getTileOrStrip(x, y, sample, poolOrDecoder, signal) {\n    const numTilesPerRow = Math.ceil(this.getWidth() / this.getTileWidth());\n    const numTilesPerCol = Math.ceil(this.getHeight() / this.getTileHeight());\n    let index;\n    const { tiles } = this;\n    if (this.planarConfiguration === 1) {\n      index = (y * numTilesPerRow) + x;\n    } else if (this.planarConfiguration === 2) {\n      index = (sample * numTilesPerRow * numTilesPerCol) + (y * numTilesPerRow) + x;\n    }\n\n    let offset;\n    let byteCount;\n    if (this.isTiled) {\n      offset = this.fileDirectory.TileOffsets[index];\n      byteCount = this.fileDirectory.TileByteCounts[index];\n    } else {\n      offset = this.fileDirectory.StripOffsets[index];\n      byteCount = this.fileDirectory.StripByteCounts[index];\n    }\n    const slice = (await this.source.fetch([{ offset, length: byteCount }], signal))[0];\n\n    let request;\n    if (tiles === null || !tiles[index]) {\n    // resolve each request by potentially applying array normalization\n      request = (async () => {\n        let data = await poolOrDecoder.decode(this.fileDirectory, slice);\n        const sampleFormat = this.getSampleFormat();\n        const bitsPerSample = this.getBitsPerSample();\n        if (needsNormalization(sampleFormat, bitsPerSample)) {\n          data = normalizeArray(\n            data,\n            sampleFormat,\n            this.planarConfiguration,\n            this.getSamplesPerPixel(),\n            bitsPerSample,\n            this.getTileWidth(),\n            this.getBlockHeight(y),\n          );\n        }\n        return data;\n      })();\n\n      // set the cache\n      if (tiles !== null) {\n        tiles[index] = request;\n      }\n    } else {\n      // get from the cache\n      request = tiles[index];\n    }\n\n    // cache the tile request\n    return { x, y, sample, data: await request };\n  }\n\n  /**\n   * Internal read function.\n   * @private\n   * @param {Array} imageWindow The image window in pixel coordinates\n   * @param {Array} samples The selected samples (0-based indices)\n   * @param {TypedArray|TypedArray[]} valueArrays The array(s) to write into\n   * @param {Boolean} interleave Whether or not to write in an interleaved manner\n   * @param {import(\"./geotiff\").Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {number} width the width of window to be read into\n   * @param {number} height the height of window to be read into\n   * @param {number} resampleMethod the resampling method to be used when interpolating\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise<ReadRasterResult>}\n   */\n  async _readRaster(imageWindow, samples, valueArrays, interleave, poolOrDecoder, width,\n    height, resampleMethod, signal) {\n    const tileWidth = this.getTileWidth();\n    const tileHeight = this.getTileHeight();\n    const imageWidth = this.getWidth();\n    const imageHeight = this.getHeight();\n\n    const minXTile = Math.max(Math.floor(imageWindow[0] / tileWidth), 0);\n    const maxXTile = Math.min(\n      Math.ceil(imageWindow[2] / tileWidth),\n      Math.ceil(imageWidth / tileWidth),\n    );\n    const minYTile = Math.max(Math.floor(imageWindow[1] / tileHeight), 0);\n    const maxYTile = Math.min(\n      Math.ceil(imageWindow[3] / tileHeight),\n      Math.ceil(imageHeight / tileHeight),\n    );\n    const windowWidth = imageWindow[2] - imageWindow[0];\n\n    let bytesPerPixel = this.getBytesPerPixel();\n\n    const srcSampleOffsets = [];\n    const sampleReaders = [];\n    for (let i = 0; i < samples.length; ++i) {\n      if (this.planarConfiguration === 1) {\n        srcSampleOffsets.push(sum(this.fileDirectory.BitsPerSample, 0, samples[i]) / 8);\n      } else {\n        srcSampleOffsets.push(0);\n      }\n      sampleReaders.push(this.getReaderForSample(samples[i]));\n    }\n\n    const promises = [];\n    const { littleEndian } = this;\n\n    for (let yTile = minYTile; yTile < maxYTile; ++yTile) {\n      for (let xTile = minXTile; xTile < maxXTile; ++xTile) {\n        let getPromise;\n        if (this.planarConfiguration === 1) {\n          getPromise = this.getTileOrStrip(xTile, yTile, 0, poolOrDecoder, signal);\n        }\n        for (let sampleIndex = 0; sampleIndex < samples.length; ++sampleIndex) {\n          const si = sampleIndex;\n          const sample = samples[sampleIndex];\n          if (this.planarConfiguration === 2) {\n            bytesPerPixel = this.getSampleByteSize(sample);\n            getPromise = this.getTileOrStrip(xTile, yTile, sample, poolOrDecoder, signal);\n          }\n          const promise = getPromise.then((tile) => {\n            const buffer = tile.data;\n            const dataView = new DataView(buffer);\n            const blockHeight = this.getBlockHeight(tile.y);\n            const firstLine = tile.y * tileHeight;\n            const firstCol = tile.x * tileWidth;\n            const lastLine = firstLine + blockHeight;\n            const lastCol = (tile.x + 1) * tileWidth;\n            const reader = sampleReaders[si];\n\n            const ymax = Math.min(blockHeight, blockHeight - (lastLine - imageWindow[3]), imageHeight - firstLine);\n            const xmax = Math.min(tileWidth, tileWidth - (lastCol - imageWindow[2]), imageWidth - firstCol);\n\n            for (let y = Math.max(0, imageWindow[1] - firstLine); y < ymax; ++y) {\n              for (let x = Math.max(0, imageWindow[0] - firstCol); x < xmax; ++x) {\n                const pixelOffset = ((y * tileWidth) + x) * bytesPerPixel;\n                const value = reader.call(\n                  dataView, pixelOffset + srcSampleOffsets[si], littleEndian,\n                );\n                let windowCoordinate;\n                if (interleave) {\n                  windowCoordinate = ((y + firstLine - imageWindow[1]) * windowWidth * samples.length)\n                    + ((x + firstCol - imageWindow[0]) * samples.length)\n                    + si;\n                  valueArrays[windowCoordinate] = value;\n                } else {\n                  windowCoordinate = (\n                    (y + firstLine - imageWindow[1]) * windowWidth\n                  ) + x + firstCol - imageWindow[0];\n                  valueArrays[si][windowCoordinate] = value;\n                }\n              }\n            }\n          });\n          promises.push(promise);\n        }\n      }\n    }\n    await Promise.all(promises);\n\n    if ((width && (imageWindow[2] - imageWindow[0]) !== width)\n        || (height && (imageWindow[3] - imageWindow[1]) !== height)) {\n      let resampled;\n      if (interleave) {\n        resampled = resampleInterleaved(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          samples.length,\n          resampleMethod,\n        );\n      } else {\n        resampled = resample(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          resampleMethod,\n        );\n      }\n      resampled.width = width;\n      resampled.height = height;\n      return resampled;\n    }\n\n    valueArrays.width = width || imageWindow[2] - imageWindow[0];\n    valueArrays.height = height || imageWindow[3] - imageWindow[1];\n\n    return valueArrays;\n  }\n\n  /**\n   * Reads raster data from the image. This function reads all selected samples\n   * into separate arrays of the correct type for that sample or into a single\n   * combined array when `interleave` is set. When provided, only a subset\n   * of the raster is read for each sample.\n   *\n   * @param {ReadRasterOptions} [options={}] optional parameters\n   * @returns {Promise<ReadRasterResult>} the decoded arrays as a promise\n   */\n  async readRasters({\n    window: wnd, samples = [], interleave, pool = null,\n    width, height, resampleMethod, fillValue, signal,\n  } = {}) {\n    const imageWindow = wnd || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const imageWindowWidth = imageWindow[2] - imageWindow[0];\n    const imageWindowHeight = imageWindow[3] - imageWindow[1];\n    const numPixels = imageWindowWidth * imageWindowHeight;\n    const samplesPerPixel = this.getSamplesPerPixel();\n\n    if (!samples || !samples.length) {\n      for (let i = 0; i < samplesPerPixel; ++i) {\n        samples.push(i);\n      }\n    } else {\n      for (let i = 0; i < samples.length; ++i) {\n        if (samples[i] >= samplesPerPixel) {\n          return Promise.reject(new RangeError(`Invalid sample index '${samples[i]}'.`));\n        }\n      }\n    }\n    let valueArrays;\n    if (interleave) {\n      const format = this.fileDirectory.SampleFormat\n        ? Math.max.apply(null, this.fileDirectory.SampleFormat) : 1;\n      const bitsPerSample = Math.max.apply(null, this.fileDirectory.BitsPerSample);\n      valueArrays = arrayForType(format, bitsPerSample, numPixels * samples.length);\n      if (fillValue) {\n        valueArrays.fill(fillValue);\n      }\n    } else {\n      valueArrays = [];\n      for (let i = 0; i < samples.length; ++i) {\n        const valueArray = this.getArrayForSample(samples[i], numPixels);\n        if (Array.isArray(fillValue) && i < fillValue.length) {\n          valueArray.fill(fillValue[i]);\n        } else if (fillValue && !Array.isArray(fillValue)) {\n          valueArray.fill(fillValue);\n        }\n        valueArrays.push(valueArray);\n      }\n    }\n\n    const poolOrDecoder = pool || await getDecoder(this.fileDirectory);\n\n    const result = await this._readRaster(\n      imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod, signal,\n    );\n    return result;\n  }\n\n  /**\n   * Reads raster data from the image as RGB. The result is always an\n   * interleaved typed array.\n   * Colorspaces other than RGB will be transformed to RGB, color maps expanded.\n   * When no other method is applicable, the first sample is used to produce a\n   * grayscale image.\n   * When provided, only a subset of the raster is read for each sample.\n   *\n   * @param {Object} [options] optional parameters\n   * @param {Array<number>} [options.window] the subset to read data from in pixels.\n   * @param {boolean} [options.interleave=true] whether the data shall be read\n   *                                             in one single array or separate\n   *                                             arrays.\n   * @param {import(\"./geotiff\").Pool} [options.pool=null] The optional decoder pool to use.\n   * @param {number} [options.width] The desired width of the output. When the width is no the\n   *                                 same as the images, resampling will be performed.\n   * @param {number} [options.height] The desired height of the output. When the width is no the\n   *                                  same as the images, resampling will be performed.\n   * @param {string} [options.resampleMethod='nearest'] The desired resampling method.\n   * @param {boolean} [options.enableAlpha=false] Enable reading alpha channel if present.\n   * @param {AbortSignal} [options.signal] An AbortSignal that may be signalled if the request is\n   *                                       to be aborted\n   * @returns {Promise<ReadRasterResult>} the RGB array as a Promise\n   */\n  async readRGB({ window, interleave = true, pool = null, width, height,\n    resampleMethod, enableAlpha = false, signal } = {}) {\n    const imageWindow = window || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const pi = this.fileDirectory.PhotometricInterpretation;\n\n    if (pi === photometricInterpretations.RGB) {\n      let s = [0, 1, 2];\n      if ((!(this.fileDirectory.ExtraSamples === ExtraSamplesValues.Unspecified)) && enableAlpha) {\n        s = [];\n        for (let i = 0; i < this.fileDirectory.BitsPerSample.length; i += 1) {\n          s.push(i);\n        }\n      }\n      return this.readRasters({\n        window,\n        interleave,\n        samples: s,\n        pool,\n        width,\n        height,\n        resampleMethod,\n        signal,\n      });\n    }\n\n    let samples;\n    switch (pi) {\n      case photometricInterpretations.WhiteIsZero:\n      case photometricInterpretations.BlackIsZero:\n      case photometricInterpretations.Palette:\n        samples = [0];\n        break;\n      case photometricInterpretations.CMYK:\n        samples = [0, 1, 2, 3];\n        break;\n      case photometricInterpretations.YCbCr:\n      case photometricInterpretations.CIELab:\n        samples = [0, 1, 2];\n        break;\n      default:\n        throw new Error('Invalid or unsupported photometric interpretation.');\n    }\n\n    const subOptions = {\n      window: imageWindow,\n      interleave: true,\n      samples,\n      pool,\n      width,\n      height,\n      resampleMethod,\n      signal,\n    };\n    const { fileDirectory } = this;\n    const raster = await this.readRasters(subOptions);\n\n    const max = 2 ** this.fileDirectory.BitsPerSample[0];\n    let data;\n    switch (pi) {\n      case photometricInterpretations.WhiteIsZero:\n        data = fromWhiteIsZero(raster, max);\n        break;\n      case photometricInterpretations.BlackIsZero:\n        data = fromBlackIsZero(raster, max);\n        break;\n      case photometricInterpretations.Palette:\n        data = fromPalette(raster, fileDirectory.ColorMap);\n        break;\n      case photometricInterpretations.CMYK:\n        data = fromCMYK(raster);\n        break;\n      case photometricInterpretations.YCbCr:\n        data = fromYCbCr(raster);\n        break;\n      case photometricInterpretations.CIELab:\n        data = fromCIELab(raster);\n        break;\n      default:\n        throw new Error('Unsupported photometric interpretation.');\n    }\n\n    // if non-interleaved data is requested, we must split the channels\n    // into their respective arrays\n    if (!interleave) {\n      const red = new Uint8Array(data.length / 3);\n      const green = new Uint8Array(data.length / 3);\n      const blue = new Uint8Array(data.length / 3);\n      for (let i = 0, j = 0; i < data.length; i += 3, ++j) {\n        red[j] = data[i];\n        green[j] = data[i + 1];\n        blue[j] = data[i + 2];\n      }\n      data = [red, green, blue];\n    }\n\n    data.width = raster.width;\n    data.height = raster.height;\n    return data;\n  }\n\n  /**\n   * Returns an array of tiepoints.\n   * @returns {Object[]}\n   */\n  getTiePoints() {\n    if (!this.fileDirectory.ModelTiepoint) {\n      return [];\n    }\n\n    const tiePoints = [];\n    for (let i = 0; i < this.fileDirectory.ModelTiepoint.length; i += 6) {\n      tiePoints.push({\n        i: this.fileDirectory.ModelTiepoint[i],\n        j: this.fileDirectory.ModelTiepoint[i + 1],\n        k: this.fileDirectory.ModelTiepoint[i + 2],\n        x: this.fileDirectory.ModelTiepoint[i + 3],\n        y: this.fileDirectory.ModelTiepoint[i + 4],\n        z: this.fileDirectory.ModelTiepoint[i + 5],\n      });\n    }\n    return tiePoints;\n  }\n\n  /**\n   * Returns the parsed GDAL metadata items.\n   *\n   * If sample is passed to null, dataset-level metadata will be returned.\n   * Otherwise only metadata specific to the provided sample will be returned.\n   *\n   * @param {number} [sample=null] The sample index.\n   * @returns {Object}\n   */\n  getGDALMetadata(sample = null) {\n    const metadata = {};\n    if (!this.fileDirectory.GDAL_METADATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_METADATA;\n\n    let items = findTagsByName(string, 'Item');\n\n    if (sample === null) {\n      items = items.filter((item) => getAttribute(item, 'sample') === undefined);\n    } else {\n      items = items.filter((item) => Number(getAttribute(item, 'sample')) === sample);\n    }\n\n    for (let i = 0; i < items.length; ++i) {\n      const item = items[i];\n      metadata[getAttribute(item, 'name')] = item.inner;\n    }\n    return metadata;\n  }\n\n  /**\n   * Returns the GDAL nodata value\n   * @returns {number|null}\n   */\n  getGDALNoData() {\n    if (!this.fileDirectory.GDAL_NODATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_NODATA;\n    return Number(string.substring(0, string.length - 1));\n  }\n\n  /**\n   * Returns the image origin as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @returns {Array<number>} The origin as a vector\n   */\n  getOrigin() {\n    const tiePoints = this.fileDirectory.ModelTiepoint;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n    if (tiePoints && tiePoints.length === 6) {\n      return [\n        tiePoints[3],\n        tiePoints[4],\n        tiePoints[5],\n      ];\n    }\n    if (modelTransformation) {\n      return [\n        modelTransformation[3],\n        modelTransformation[7],\n        modelTransformation[11],\n      ];\n    }\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns the image resolution as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @param {GeoTIFFImage} [referenceImage=null] A reference image to calculate the resolution from\n   *                                             in cases when the current image does not have the\n   *                                             required tags on its own.\n   * @returns {Array<number>} The resolution as a vector\n   */\n  getResolution(referenceImage = null) {\n    const modelPixelScale = this.fileDirectory.ModelPixelScale;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n\n    if (modelPixelScale) {\n      return [\n        modelPixelScale[0],\n        -modelPixelScale[1],\n        modelPixelScale[2],\n      ];\n    }\n    if (modelTransformation) {\n      if (modelTransformation[1] === 0 && modelTransformation[4] === 0) {\n        return [\n          modelTransformation[0],\n          -modelTransformation[5],\n          modelTransformation[10],\n        ];\n      }\n      return [\n        Math.sqrt((modelTransformation[0] * modelTransformation[0])\n          + (modelTransformation[4] * modelTransformation[4])),\n        -Math.sqrt((modelTransformation[1] * modelTransformation[1])\n          + (modelTransformation[5] * modelTransformation[5])),\n        modelTransformation[10]];\n    }\n\n    if (referenceImage) {\n      const [refResX, refResY, refResZ] = referenceImage.getResolution();\n      return [\n        refResX * referenceImage.getWidth() / this.getWidth(),\n        refResY * referenceImage.getHeight() / this.getHeight(),\n        refResZ * referenceImage.getWidth() / this.getWidth(),\n      ];\n    }\n\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns whether or not the pixels of the image depict an area (or point).\n   * @returns {Boolean} Whether the pixels are a point\n   */\n  pixelIsArea() {\n    return this.geoKeys.GTRasterTypeGeoKey === 1;\n  }\n\n  /**\n   * Returns the image bounding box as an array of 4 values: min-x, min-y,\n   * max-x and max-y. When the image has no affine transformation, then an\n   * exception is thrown.\n   * @param {boolean} [tilegrid=false] If true return extent for a tilegrid\n   *                                   without adjustment for ModelTransformation.\n   * @returns {Array<number>} The bounding box\n   */\n  getBoundingBox(tilegrid = false) {\n    const height = this.getHeight();\n    const width = this.getWidth();\n\n    if (this.fileDirectory.ModelTransformation && !tilegrid) {\n      // eslint-disable-next-line no-unused-vars\n      const [a, b, c, d, e, f, g, h] = this.fileDirectory.ModelTransformation;\n\n      const corners = [\n        [0, 0],\n        [0, height],\n        [width, 0],\n        [width, height],\n      ];\n\n      const projected = corners.map(([I, J]) => [\n        d + (a * I) + (b * J),\n        h + (e * I) + (f * J),\n      ]);\n\n      const xs = projected.map((pt) => pt[0]);\n      const ys = projected.map((pt) => pt[1]);\n\n      return [\n        Math.min(...xs),\n        Math.min(...ys),\n        Math.max(...xs),\n        Math.max(...ys),\n      ];\n    } else {\n      const origin = this.getOrigin();\n      const resolution = this.getResolution();\n\n      const x1 = origin[0];\n      const y1 = origin[1];\n\n      const x2 = x1 + (resolution[0] * width);\n      const y2 = y1 + (resolution[1] * height);\n\n      return [\n        Math.min(x1, x2),\n        Math.min(y1, y2),\n        Math.max(x1, x2),\n        Math.max(y1, y2),\n      ];\n    }\n  }\n}\n\nexport default GeoTIFFImage;\n","import { getFloat16 } from '@petamoriken/float16';\n\nexport default class DataView64 {\n  constructor(arrayBuffer) {\n    this._dataView = new DataView(arrayBuffer);\n  }\n\n  get buffer() {\n    return this._dataView.buffer;\n  }\n\n  getUint64(offset, littleEndian) {\n    const left = this.getUint32(offset, littleEndian);\n    const right = this.getUint32(offset + 4, littleEndian);\n    let combined;\n    if (littleEndian) {\n      combined = left + ((2 ** 32) * right);\n      if (!Number.isSafeInteger(combined)) {\n        throw new Error(\n          `${combined} exceeds MAX_SAFE_INTEGER. `\n          + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n        );\n      }\n      return combined;\n    }\n    combined = ((2 ** 32) * left) + right;\n    if (!Number.isSafeInteger(combined)) {\n      throw new Error(\n        `${combined} exceeds MAX_SAFE_INTEGER. `\n        + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n      );\n    }\n\n    return combined;\n  }\n\n  // adapted from https://stackoverflow.com/a/55338384/8060591\n  getInt64(offset, littleEndian) {\n    let value = 0;\n    const isNegative = (this._dataView.getUint8(offset + (littleEndian ? 7 : 0)) & 0x80) > 0;\n    let carrying = true;\n    for (let i = 0; i < 8; i++) {\n      let byte = this._dataView.getUint8(offset + (littleEndian ? i : 7 - i));\n      if (isNegative) {\n        if (carrying) {\n          if (byte !== 0x00) {\n            byte = ~(byte - 1) & 0xff;\n            carrying = false;\n          }\n        } else {\n          byte = ~byte & 0xff;\n        }\n      }\n      value += byte * (256 ** i);\n    }\n    if (isNegative) {\n      value = -value;\n    }\n    return value;\n  }\n\n  getUint8(offset, littleEndian) {\n    return this._dataView.getUint8(offset, littleEndian);\n  }\n\n  getInt8(offset, littleEndian) {\n    return this._dataView.getInt8(offset, littleEndian);\n  }\n\n  getUint16(offset, littleEndian) {\n    return this._dataView.getUint16(offset, littleEndian);\n  }\n\n  getInt16(offset, littleEndian) {\n    return this._dataView.getInt16(offset, littleEndian);\n  }\n\n  getUint32(offset, littleEndian) {\n    return this._dataView.getUint32(offset, littleEndian);\n  }\n\n  getInt32(offset, littleEndian) {\n    return this._dataView.getInt32(offset, littleEndian);\n  }\n\n  getFloat16(offset, littleEndian) {\n    return getFloat16(this._dataView, offset, littleEndian);\n  }\n\n  getFloat32(offset, littleEndian) {\n    return this._dataView.getFloat32(offset, littleEndian);\n  }\n\n  getFloat64(offset, littleEndian) {\n    return this._dataView.getFloat64(offset, littleEndian);\n  }\n}\n","export default class DataSlice {\n  constructor(arrayBuffer, sliceOffset, littleEndian, bigTiff) {\n    this._dataView = new DataView(arrayBuffer);\n    this._sliceOffset = sliceOffset;\n    this._littleEndian = littleEndian;\n    this._bigTiff = bigTiff;\n  }\n\n  get sliceOffset() {\n    return this._sliceOffset;\n  }\n\n  get sliceTop() {\n    return this._sliceOffset + this.buffer.byteLength;\n  }\n\n  get littleEndian() {\n    return this._littleEndian;\n  }\n\n  get bigTiff() {\n    return this._bigTiff;\n  }\n\n  get buffer() {\n    return this._dataView.buffer;\n  }\n\n  covers(offset, length) {\n    return this.sliceOffset <= offset && this.sliceTop >= offset + length;\n  }\n\n  readUint8(offset) {\n    return this._dataView.getUint8(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt8(offset) {\n    return this._dataView.getInt8(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint16(offset) {\n    return this._dataView.getUint16(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt16(offset) {\n    return this._dataView.getInt16(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint32(offset) {\n    return this._dataView.getUint32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt32(offset) {\n    return this._dataView.getInt32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readFloat32(offset) {\n    return this._dataView.getFloat32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readFloat64(offset) {\n    return this._dataView.getFloat64(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint64(offset) {\n    const left = this.readUint32(offset);\n    const right = this.readUint32(offset + 4);\n    let combined;\n    if (this._littleEndian) {\n      combined = left + ((2 ** 32) * right);\n      if (!Number.isSafeInteger(combined)) {\n        throw new Error(\n          `${combined} exceeds MAX_SAFE_INTEGER. `\n          + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n        );\n      }\n      return combined;\n    }\n    combined = ((2 ** 32) * left) + right;\n    if (!Number.isSafeInteger(combined)) {\n      throw new Error(\n        `${combined} exceeds MAX_SAFE_INTEGER. `\n        + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n      );\n    }\n\n    return combined;\n  }\n\n  // adapted from https://stackoverflow.com/a/55338384/8060591\n  readInt64(offset) {\n    let value = 0;\n    const isNegative = (this._dataView.getUint8(offset + (this._littleEndian ? 7 : 0)) & 0x80)\n      > 0;\n    let carrying = true;\n    for (let i = 0; i < 8; i++) {\n      let byte = this._dataView.getUint8(\n        offset + (this._littleEndian ? i : 7 - i),\n      );\n      if (isNegative) {\n        if (carrying) {\n          if (byte !== 0x00) {\n            byte = ~(byte - 1) & 0xff;\n            carrying = false;\n          }\n        } else {\n          byte = ~byte & 0xff;\n        }\n      }\n      value += byte * (256 ** i);\n    }\n    if (isNegative) {\n      value = -value;\n    }\n    return value;\n  }\n\n  readOffset(offset) {\n    if (this._bigTiff) {\n      return this.readUint64(offset);\n    }\n    return this.readUint32(offset);\n  }\n}\n","const CRLFCRLF = '\\r\\n\\r\\n';\n\n/*\n * Shim for 'Object.fromEntries'\n */\nfunction itemsToObject(items) {\n  if (typeof Object.fromEntries !== 'undefined') {\n    return Object.fromEntries(items);\n  }\n  const obj = {};\n  for (const [key, value] of items) {\n    obj[key.toLowerCase()] = value;\n  }\n  return obj;\n}\n\n/**\n * Parse HTTP headers from a given string.\n * @param {String} text the text to parse the headers from\n * @returns {Object} the parsed headers with lowercase keys\n */\nfunction parseHeaders(text) {\n  const items = text\n    .split('\\r\\n')\n    .map((line) => {\n      const kv = line.split(':').map((str) => str.trim());\n      kv[0] = kv[0].toLowerCase();\n      return kv;\n    });\n\n  return itemsToObject(items);\n}\n\n/**\n * Parse a 'Content-Type' header value to the content-type and parameters\n * @param {String} rawContentType the raw string to parse from\n * @returns {Object} the parsed content type with the fields: type and params\n */\nexport function parseContentType(rawContentType) {\n  const [type, ...rawParams] = rawContentType.split(';').map((s) => s.trim());\n  const paramsItems = rawParams.map((param) => param.split('='));\n  return { type, params: itemsToObject(paramsItems) };\n}\n\n/**\n * Parse a 'Content-Range' header value to its start, end, and total parts\n * @param {String} rawContentRange the raw string to parse from\n * @returns {Object} the parsed parts\n */\nexport function parseContentRange(rawContentRange) {\n  let start;\n  let end;\n  let total;\n\n  if (rawContentRange) {\n    [, start, end, total] = rawContentRange.match(/bytes (\\d+)-(\\d+)\\/(\\d+)/);\n    start = parseInt(start, 10);\n    end = parseInt(end, 10);\n    total = parseInt(total, 10);\n  }\n\n  return { start, end, total };\n}\n\n/**\n * Parses a list of byteranges from the given 'multipart/byteranges' HTTP response.\n * Each item in the list has the following properties:\n * - headers: the HTTP headers\n * - data: the sliced ArrayBuffer for that specific part\n * - offset: the offset of the byterange within its originating file\n * - length: the length of the byterange\n * @param {ArrayBuffer} responseArrayBuffer the response to be parsed and split\n * @param {String} boundary the boundary string used to split the sections\n * @returns {Object[]} the parsed byteranges\n */\nexport function parseByteRanges(responseArrayBuffer, boundary) {\n  let offset = null;\n  const decoder = new TextDecoder('ascii');\n  const out = [];\n\n  const startBoundary = `--${boundary}`;\n  const endBoundary = `${startBoundary}--`;\n\n  // search for the initial boundary, may be offset by some bytes\n  // TODO: more efficient to check for `--` in bytes directly\n  for (let i = 0; i < 10; ++i) {\n    const text = decoder.decode(\n      new Uint8Array(responseArrayBuffer, i, startBoundary.length),\n    );\n    if (text === startBoundary) {\n      offset = i;\n    }\n  }\n\n  if (offset === null) {\n    throw new Error('Could not find initial boundary');\n  }\n\n  while (offset < responseArrayBuffer.byteLength) {\n    const text = decoder.decode(\n      new Uint8Array(responseArrayBuffer, offset,\n        Math.min(startBoundary.length + 1024, responseArrayBuffer.byteLength - offset),\n      ),\n    );\n\n    // break if we arrived at the end\n    if (text.length === 0 || text.startsWith(endBoundary)) {\n      break;\n    }\n\n    // assert that we are actually dealing with a byterange and are at the correct offset\n    if (!text.startsWith(startBoundary)) {\n      throw new Error('Part does not start with boundary');\n    }\n\n    // get a substring from where we read the headers\n    const innerText = text.substr(startBoundary.length + 2);\n\n    if (innerText.length === 0) {\n      break;\n    }\n\n    // find the double linebreak that denotes the end of the headers\n    const endOfHeaders = innerText.indexOf(CRLFCRLF);\n\n    // parse the headers to get the content range size\n    const headers = parseHeaders(innerText.substr(0, endOfHeaders));\n    const { start, end, total } = parseContentRange(headers['content-range']);\n\n    // calculate the length of the slice and the next offset\n    const startOfData = offset + startBoundary.length + endOfHeaders + CRLFCRLF.length;\n    const length = parseInt(end, 10) + 1 - parseInt(start, 10);\n    out.push({\n      headers,\n      data: responseArrayBuffer.slice(startOfData, startOfData + length),\n      offset: start,\n      length,\n      fileSize: total,\n    });\n\n    offset = startOfData + length + 4;\n  }\n\n  return out;\n}\n","/**\n * @typedef Slice\n * @property {number} offset\n * @property {number} length\n */\n\nexport class BaseSource {\n  /**\n   *\n   * @param {Slice[]} slices\n   * @returns {ArrayBuffer[]}\n   */\n  async fetch(slices, signal = undefined) {\n    return Promise.all(\n      slices.map((slice) => this.fetchSlice(slice, signal)),\n    );\n  }\n\n  /**\n   *\n   * @param {Slice} slice\n   * @returns {ArrayBuffer}\n   */\n  async fetchSlice(slice) {\n    throw new Error(`fetching of slice ${slice} not possible, not implemented`);\n  }\n\n  /**\n   * Returns the filesize if already determined and null otherwise\n   */\n  get fileSize() {\n    return null;\n  }\n\n  async close() {\n    // no-op by default\n  }\n}\n","export function assign(target, source) {\n  for (const key in source) {\n    if (source.hasOwnProperty(key)) {\n      target[key] = source[key];\n    }\n  }\n}\n\nexport function chunk(iterable, length) {\n  const results = [];\n  const lengthOfIterable = iterable.length;\n  for (let i = 0; i < lengthOfIterable; i += length) {\n    const chunked = [];\n    for (let ci = i; ci < i + length; ci++) {\n      chunked.push(iterable[ci]);\n    }\n    results.push(chunked);\n  }\n  return results;\n}\n\nexport function endsWith(string, expectedEnding) {\n  if (string.length < expectedEnding.length) {\n    return false;\n  }\n  const actualEnding = string.substr(string.length - expectedEnding.length);\n  return actualEnding === expectedEnding;\n}\n\nexport function forEach(iterable, func) {\n  const { length } = iterable;\n  for (let i = 0; i < length; i++) {\n    func(iterable[i], i);\n  }\n}\n\nexport function invert(oldObj) {\n  const newObj = {};\n  for (const key in oldObj) {\n    if (oldObj.hasOwnProperty(key)) {\n      const value = oldObj[key];\n      newObj[value] = key;\n    }\n  }\n  return newObj;\n}\n\nexport function range(n) {\n  const results = [];\n  for (let i = 0; i < n; i++) {\n    results.push(i);\n  }\n  return results;\n}\n\nexport function times(numTimes, func) {\n  const results = [];\n  for (let i = 0; i < numTimes; i++) {\n    results.push(func(i));\n  }\n  return results;\n}\n\nexport function toArray(iterable) {\n  const results = [];\n  const { length } = iterable;\n  for (let i = 0; i < length; i++) {\n    results.push(iterable[i]);\n  }\n  return results;\n}\n\nexport function toArrayRecursively(input) {\n  if (input.length) {\n    return toArray(input).map(toArrayRecursively);\n  }\n  return input;\n}\n\n// copied from https://github.com/academia-de-codigo/parse-content-range-header/blob/master/index.js\nexport function parseContentRange(headerValue) {\n  if (!headerValue) {\n    return null;\n  }\n\n  if (typeof headerValue !== 'string') {\n    throw new Error('invalid argument');\n  }\n\n  const parseInt = (number) => Number.parseInt(number, 10);\n\n  // Check for presence of unit\n  let matches = headerValue.match(/^(\\w*) /);\n  const unit = matches && matches[1];\n\n  // check for start-end/size header format\n  matches = headerValue.match(/(\\d+)-(\\d+)\\/(\\d+|\\*)/);\n  if (matches) {\n    return {\n      unit,\n      first: parseInt(matches[1]),\n      last: parseInt(matches[2]),\n      length: matches[3] === '*' ? null : parseInt(matches[3]),\n    };\n  }\n\n  // check for size header format\n  matches = headerValue.match(/(\\d+|\\*)/);\n  if (matches) {\n    return {\n      unit,\n      first: null,\n      last: null,\n      length: matches[1] === '*' ? null : parseInt(matches[1]),\n    };\n  }\n\n  return null;\n}\n\n/*\n * Promisified wrapper around 'setTimeout' to allow 'await'\n */\nexport async function wait(milliseconds) {\n  return new Promise((resolve) => setTimeout(resolve, milliseconds));\n}\n\nexport function zip(a, b) {\n  const A = Array.isArray(a) ? a : Array.from(a);\n  const B = Array.isArray(b) ? b : Array.from(b);\n  return A.map((k, i) => [k, B[i]]);\n}\n\n// Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error\nexport class AbortError extends Error {\n  constructor(params) {\n    // Pass remaining arguments (including vendor specific ones) to parent constructor\n    super(params);\n\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AbortError);\n    }\n\n    this.name = 'AbortError';\n  }\n}\n\nexport class CustomAggregateError extends Error {\n  constructor(errors, message) {\n    super(message);\n    this.errors = errors;\n    this.message = message;\n    this.name = 'AggregateError';\n  }\n}\n\nexport const AggregateError = CustomAggregateError;\n","import QuickLRU from 'quick-lru';\nimport { BaseSource } from './basesource.js';\nimport { AbortError, AggregateError, wait, zip } from '../utils.js';\n\nclass Block {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {ArrayBuffer} [data]\n   */\n  constructor(offset, length, data = null) {\n    this.offset = offset;\n    this.length = length;\n    this.data = data;\n  }\n\n  /**\n   * @returns {number} the top byte border\n   */\n  get top() {\n    return this.offset + this.length;\n  }\n}\n\nclass BlockGroup {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {number[]} blockIds\n   */\n  constructor(offset, length, blockIds) {\n    this.offset = offset;\n    this.length = length;\n    this.blockIds = blockIds;\n  }\n}\n\nexport class BlockedSource extends BaseSource {\n  /**\n   *\n   * @param {BaseSource} source The underlying source that shall be blocked and cached\n   * @param {object} options\n   * @param {number} [options.blockSize]\n   * @param {number} [options.cacheSize]\n   */\n  constructor(source, { blockSize = 65536, cacheSize = 100 } = {}) {\n    super();\n    this.source = source;\n    this.blockSize = blockSize;\n\n    this.blockCache = new QuickLRU({\n      maxSize: cacheSize,\n      onEviction: (blockId, block) => {\n        this.evictedBlocks.set(blockId, block);\n      },\n    });\n\n    /** @type {Map<number, Block>} */\n    this.evictedBlocks = new Map();\n\n    // mapping blockId -> Block instance\n    this.blockRequests = new Map();\n\n    // set of blockIds missing for the current requests\n    this.blockIdsToFetch = new Set();\n\n    this.abortedBlockIds = new Set();\n  }\n\n  get fileSize() {\n    return this.source.fileSize;\n  }\n\n  /**\n   *\n   * @param {import(\"./basesource\").Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    const blockRequests = [];\n    const missingBlockIds = [];\n    const allBlockIds = [];\n    this.evictedBlocks.clear();\n\n    for (const { offset, length } of slices) {\n      let top = offset + length;\n\n      const { fileSize } = this;\n      if (fileSize !== null) {\n        top = Math.min(top, fileSize);\n      }\n\n      const firstBlockOffset = Math.floor(offset / this.blockSize) * this.blockSize;\n\n      for (let current = firstBlockOffset; current < top; current += this.blockSize) {\n        const blockId = Math.floor(current / this.blockSize);\n        if (!this.blockCache.has(blockId) && !this.blockRequests.has(blockId)) {\n          this.blockIdsToFetch.add(blockId);\n          missingBlockIds.push(blockId);\n        }\n        if (this.blockRequests.has(blockId)) {\n          blockRequests.push(this.blockRequests.get(blockId));\n        }\n        allBlockIds.push(blockId);\n      }\n    }\n\n    // allow additional block requests to accumulate\n    await wait();\n    this.fetchBlocks(signal);\n\n    // Gather all of the new requests that this fetch call is contributing to `fetch`.\n    const missingRequests = [];\n    for (const blockId of missingBlockIds) {\n      // The requested missing block could already be in the cache\n      // instead of having its request still be outstanding.\n      if (this.blockRequests.has(blockId)) {\n        missingRequests.push(this.blockRequests.get(blockId));\n      }\n    }\n\n    // Actually await all pending requests that are needed for this `fetch`.\n    await Promise.allSettled(blockRequests);\n    await Promise.allSettled(missingRequests);\n\n    // Perform retries if a block was interrupted by a previous signal\n    const abortedBlockRequests = [];\n    const abortedBlockIds = allBlockIds\n      .filter((id) => this.abortedBlockIds.has(id) || !this.blockCache.has(id));\n    abortedBlockIds.forEach((id) => this.blockIdsToFetch.add(id));\n    // start the retry of some blocks if required\n    if (abortedBlockIds.length > 0 && signal && !signal.aborted) {\n      this.fetchBlocks(null);\n      for (const blockId of abortedBlockIds) {\n        const block = this.blockRequests.get(blockId);\n        if (!block) {\n          throw new Error(`Block ${blockId} is not in the block requests`);\n        }\n        abortedBlockRequests.push(block);\n      }\n      await Promise.allSettled(abortedBlockRequests);\n    }\n\n    // throw an  abort error\n    if (signal && signal.aborted) {\n      throw new AbortError('Request was aborted');\n    }\n\n    const blocks = allBlockIds.map((id) => this.blockCache.get(id) || this.evictedBlocks.get(id));\n    const failedBlocks = blocks.filter((i) => !i);\n    if (failedBlocks.length) {\n      throw new AggregateError(failedBlocks, 'Request failed');\n    }\n\n    // create a final Map, with all required blocks for this request to satisfy\n    const requiredBlocks = new Map(zip(allBlockIds, blocks));\n\n    // TODO: satisfy each slice\n    return this.readSliceData(slices, requiredBlocks);\n  }\n\n  /**\n   *\n   * @param {AbortSignal} signal\n   */\n  fetchBlocks(signal) {\n    // check if we still need to\n    if (this.blockIdsToFetch.size > 0) {\n      const groups = this.groupBlocks(this.blockIdsToFetch);\n\n      // start requesting slices of data\n      const groupRequests = this.source.fetch(groups, signal);\n\n      for (let groupIndex = 0; groupIndex < groups.length; ++groupIndex) {\n        const group = groups[groupIndex];\n\n        for (const blockId of group.blockIds) {\n          // make an async IIFE for each block\n          this.blockRequests.set(blockId, (async () => {\n            try {\n              const response = (await groupRequests)[groupIndex];\n              const blockOffset = blockId * this.blockSize;\n              const o = blockOffset - response.offset;\n              const t = Math.min(o + this.blockSize, response.data.byteLength);\n              const data = response.data.slice(o, t);\n              const block = new Block(\n                blockOffset,\n                data.byteLength,\n                data,\n                blockId,\n              );\n              this.blockCache.set(blockId, block);\n              this.abortedBlockIds.delete(blockId);\n            } catch (err) {\n              if (err.name === 'AbortError') {\n                // store the signal here, we need it to determine later if an\n                // error was caused by this signal\n                err.signal = signal;\n                this.blockCache.delete(blockId);\n                this.abortedBlockIds.add(blockId);\n              } else {\n                throw err;\n              }\n            } finally {\n              this.blockRequests.delete(blockId);\n            }\n          })());\n        }\n      }\n      this.blockIdsToFetch.clear();\n    }\n  }\n\n  /**\n   *\n   * @param {Set} blockIds\n   * @returns {BlockGroup[]}\n   */\n  groupBlocks(blockIds) {\n    const sortedBlockIds = Array.from(blockIds).sort((a, b) => a - b);\n    if (sortedBlockIds.length === 0) {\n      return [];\n    }\n    let current = [];\n    let lastBlockId = null;\n    const groups = [];\n\n    for (const blockId of sortedBlockIds) {\n      if (lastBlockId === null || lastBlockId + 1 === blockId) {\n        current.push(blockId);\n        lastBlockId = blockId;\n      } else {\n        groups.push(new BlockGroup(\n          current[0] * this.blockSize,\n          current.length * this.blockSize,\n          current,\n        ));\n        current = [blockId];\n        lastBlockId = blockId;\n      }\n    }\n\n    groups.push(new BlockGroup(\n      current[0] * this.blockSize,\n      current.length * this.blockSize,\n      current,\n    ));\n\n    return groups;\n  }\n\n  /**\n   *\n   * @param {import(\"./basesource\").Slice[]} slices\n   * @param {Map} blocks\n   */\n  readSliceData(slices, blocks) {\n    return slices.map((slice) => {\n      let top = slice.offset + slice.length;\n      if (this.fileSize !== null) {\n        top = Math.min(this.fileSize, top);\n      }\n      const blockIdLow = Math.floor(slice.offset / this.blockSize);\n      const blockIdHigh = Math.floor(top / this.blockSize);\n      const sliceData = new ArrayBuffer(slice.length);\n      const sliceView = new Uint8Array(sliceData);\n\n      for (let blockId = blockIdLow; blockId <= blockIdHigh; ++blockId) {\n        const block = blocks.get(blockId);\n        const delta = block.offset - slice.offset;\n        const topDelta = block.top - top;\n        let blockInnerOffset = 0;\n        let rangeInnerOffset = 0;\n        let usedBlockLength;\n\n        if (delta < 0) {\n          blockInnerOffset = -delta;\n        } else if (delta > 0) {\n          rangeInnerOffset = delta;\n        }\n\n        if (topDelta < 0) {\n          usedBlockLength = block.length - blockInnerOffset;\n        } else {\n          usedBlockLength = top - block.offset - blockInnerOffset;\n        }\n\n        const blockView = new Uint8Array(block.data, blockInnerOffset, usedBlockLength);\n        sliceView.set(blockView, rangeInnerOffset);\n      }\n\n      return sliceData;\n    });\n  }\n}\n","export class BaseResponse {\n  /**\n   * Returns whether the response has an ok'ish status code\n   */\n  get ok() {\n    return this.status >= 200 && this.status <= 299;\n  }\n\n  /**\n   * Returns the status code of the response\n   */\n  get status() {\n    throw new Error('not implemented');\n  }\n\n  /**\n   * Returns the value of the specified header\n   * @param {string} headerName the header name\n   * @returns {string} the header value\n   */\n  getHeader(headerName) { // eslint-disable-line no-unused-vars\n    throw new Error('not implemented');\n  }\n\n  /**\n   * @returns {ArrayBuffer} the response data of the request\n   */\n  async getData() {\n    throw new Error('not implemented');\n  }\n}\n\nexport class BaseClient {\n  constructor(url) {\n    this.url = url;\n  }\n\n  /**\n   * Send a request with the options\n   * @param {{headers: HeadersInit, signal: AbortSignal}} [options={}]\n   * @returns {Promise<BaseResponse>}\n   */\n  async request({ headers, signal } = {}) { // eslint-disable-line no-unused-vars\n    throw new Error('request is not implemented');\n  }\n}\n","import { BaseClient, BaseResponse } from './base.js';\n\nclass FetchResponse extends BaseResponse {\n  /**\n   * BaseResponse facade for fetch API Response\n   * @param {Response} response\n   */\n  constructor(response) {\n    super();\n    this.response = response;\n  }\n\n  get status() {\n    return this.response.status;\n  }\n\n  getHeader(name) {\n    return this.response.headers.get(name);\n  }\n\n  async getData() {\n    const data = this.response.arrayBuffer\n      ? await this.response.arrayBuffer()\n      : (await this.response.buffer()).buffer;\n    return data;\n  }\n}\n\nexport class FetchClient extends BaseClient {\n  constructor(url, credentials) {\n    super(url);\n    this.credentials = credentials;\n  }\n\n  /**\n   * @param {{headers: HeadersInit, signal: AbortSignal}} [options={}]\n   * @returns {Promise<FetchResponse>}\n   */\n  async request({ headers, signal } = {}) {\n    const response = await fetch(this.url, {\n      headers, credentials: this.credentials, signal,\n    });\n    return new FetchResponse(response);\n  }\n}\n","import { BaseClient, BaseResponse } from './base.js';\nimport { AbortError } from '../../utils.js';\n\nclass XHRResponse extends BaseResponse {\n  /**\n   * BaseResponse facade for XMLHttpRequest\n   * @param {XMLHttpRequest} xhr\n   * @param {ArrayBuffer} data\n   */\n  constructor(xhr, data) {\n    super();\n    this.xhr = xhr;\n    this.data = data;\n  }\n\n  get status() {\n    return this.xhr.status;\n  }\n\n  getHeader(name) {\n    return this.xhr.getResponseHeader(name);\n  }\n\n  async getData() {\n    return this.data;\n  }\n}\n\nexport class XHRClient extends BaseClient {\n  constructRequest(headers, signal) {\n    return new Promise((resolve, reject) => {\n      const xhr = new XMLHttpRequest();\n      xhr.open('GET', this.url);\n      xhr.responseType = 'arraybuffer';\n      for (const [key, value] of Object.entries(headers)) {\n        xhr.setRequestHeader(key, value);\n      }\n\n      // hook signals\n      xhr.onload = () => {\n        const data = xhr.response;\n        resolve(new XHRResponse(xhr, data));\n      };\n      xhr.onerror = reject;\n      xhr.onabort = () => reject(new AbortError('Request aborted'));\n      xhr.send();\n\n      if (signal) {\n        if (signal.aborted) {\n          xhr.abort();\n        }\n        signal.addEventListener('abort', () => xhr.abort());\n      }\n    });\n  }\n\n  async request({ headers, signal } = {}) {\n    const response = await this.constructRequest(headers, signal);\n    return response;\n  }\n}\n","import http from 'http';\nimport https from 'https';\nimport urlMod from 'url';\n\nimport { BaseClient, BaseResponse } from './base.js';\nimport { AbortError } from '../../utils.js';\n\nclass HttpResponse extends BaseResponse {\n  /**\n   * BaseResponse facade for node HTTP/HTTPS API Response\n   * @param {http.ServerResponse} response\n   */\n  constructor(response, dataPromise) {\n    super();\n    this.response = response;\n    this.dataPromise = dataPromise;\n  }\n\n  get status() {\n    return this.response.statusCode;\n  }\n\n  getHeader(name) {\n    return this.response.headers[name];\n  }\n\n  async getData() {\n    const data = await this.dataPromise;\n    return data;\n  }\n}\n\nexport class HttpClient extends BaseClient {\n  constructor(url) {\n    super(url);\n    this.parsedUrl = urlMod.parse(this.url);\n    this.httpApi = (this.parsedUrl.protocol === 'http:' ? http : https);\n  }\n\n  constructRequest(headers, signal) {\n    return new Promise((resolve, reject) => {\n      const request = this.httpApi.get(\n        {\n          ...this.parsedUrl,\n          headers,\n        },\n        (response) => {\n          const dataPromise = new Promise((resolveData) => {\n            const chunks = [];\n\n            // collect chunks\n            response.on('data', (chunk) => {\n              chunks.push(chunk);\n            });\n\n            // concatenate all chunks and resolve the promise with the resulting buffer\n            response.on('end', () => {\n              const data = Buffer.concat(chunks).buffer;\n              resolveData(data);\n            });\n            response.on('error', reject);\n          });\n          resolve(new HttpResponse(response, dataPromise));\n        },\n      );\n      request.on('error', reject);\n\n      if (signal) {\n        if (signal.aborted) {\n          request.destroy(new AbortError('Request aborted'));\n        }\n        signal.addEventListener('abort', () => request.destroy(new AbortError('Request aborted')));\n      }\n    });\n  }\n\n  async request({ headers, signal } = {}) {\n    const response = await this.constructRequest(headers, signal);\n    return response;\n  }\n}\n","import { parseByteRanges, parseContentRange, parseContentType } from './httputils.js';\nimport { BaseSource } from './basesource.js';\nimport { BlockedSource } from './blockedsource.js';\n\nimport { FetchClient } from './client/fetch.js';\nimport { XHRClient } from './client/xhr.js';\nimport { HttpClient } from './client/http.js';\n\nclass RemoteSource extends BaseSource {\n  /**\n   *\n   * @param {BaseClient} client\n   * @param {object} headers\n   * @param {numbers} maxRanges\n   * @param {boolean} allowFullFile\n   */\n  constructor(client, headers, maxRanges, allowFullFile) {\n    super();\n    this.client = client;\n    this.headers = headers;\n    this.maxRanges = maxRanges;\n    this.allowFullFile = allowFullFile;\n    this._fileSize = null;\n  }\n\n  /**\n   *\n   * @param {Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    // if we allow multi-ranges, split the incoming request into that many sub-requests\n    // and join them afterwards\n    if (this.maxRanges >= slices.length) {\n      return this.fetchSlices(slices, signal);\n    } else if (this.maxRanges > 0 && slices.length > 1) {\n      // TODO: split into multiple multi-range requests\n\n      // const subSlicesRequests = [];\n      // for (let i = 0; i < slices.length; i += this.maxRanges) {\n      //   subSlicesRequests.push(\n      //     this.fetchSlices(slices.slice(i, i + this.maxRanges), signal),\n      //   );\n      // }\n      // return (await Promise.all(subSlicesRequests)).flat();\n    }\n\n    // otherwise make a single request for each slice\n    return Promise.all(\n      slices.map((slice) => this.fetchSlice(slice, signal)),\n    );\n  }\n\n  async fetchSlices(slices, signal) {\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${slices\n          .map(({ offset, length }) => `${offset}-${offset + length}`)\n          .join(',')\n        }`,\n      },\n      signal,\n    });\n\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const { type, params } = parseContentType(response.getHeader('content-type'));\n      if (type === 'multipart/byteranges') {\n        const byteRanges = parseByteRanges(await response.getData(), params.boundary);\n        this._fileSize = byteRanges[0].fileSize || null;\n        return byteRanges;\n      }\n\n      const data = await response.getData();\n\n      const { start, end, total } = parseContentRange(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      const first = [{\n        data,\n        offset: start,\n        length: end - start,\n      }];\n\n      if (slices.length > 1) {\n        // we requested more than one slice, but got only the first\n        // unfortunately, some HTTP Servers don't support multi-ranges\n        // and return only the first\n\n        // get the rest of the slices and fetch them iteratively\n        const others = await Promise.all(slices.slice(1).map((slice) => this.fetchSlice(slice, signal)));\n        return first.concat(others);\n      }\n      return first;\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n      const data = await response.getData();\n      this._fileSize = data.byteLength;\n      return [{\n        data,\n        offset: 0,\n        length: data.byteLength,\n      }];\n    }\n  }\n\n  async fetchSlice(slice, signal) {\n    const { offset, length } = slice;\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${offset}-${offset + length}`,\n      },\n      signal,\n    });\n\n    // check the response was okay and if the server actually understands range requests\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const data = await response.getData();\n\n      const { total } = parseContentRange(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      return {\n        data,\n        offset,\n        length,\n      };\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n\n      const data = await response.getData();\n\n      this._fileSize = data.byteLength;\n      return {\n        data,\n        offset: 0,\n        length: data.byteLength,\n      };\n    }\n  }\n\n  get fileSize() {\n    return this._fileSize;\n  }\n}\n\nfunction maybeWrapInBlockedSource(source, { blockSize, cacheSize }) {\n  if (blockSize === null) {\n    return source;\n  }\n  return new BlockedSource(source, { blockSize, cacheSize });\n}\n\nexport function makeFetchSource(url, { headers = {}, credentials, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new FetchClient(url, credentials);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nexport function makeXHRSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new XHRClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nexport function makeHttpSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new HttpClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nexport function makeCustomSource(client, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\n/**\n *\n * @param {string} url\n * @param {object} options\n */\nexport function makeRemoteSource(url, { forceXHR = false, ...clientOptions } = {}) {\n  if (typeof fetch === 'function' && !forceXHR) {\n    return makeFetchSource(url, clientOptions);\n  }\n  if (typeof XMLHttpRequest !== 'undefined') {\n    return makeXHRSource(url, clientOptions);\n  }\n  return makeHttpSource(url, clientOptions);\n}\n","import { BaseSource } from './basesource.js';\n\nclass FileReaderSource extends BaseSource {\n  constructor(file) {\n    super();\n    this.file = file;\n  }\n\n  async fetchSlice(slice, signal) {\n    return new Promise((resolve, reject) => {\n      const blob = this.file.slice(slice.offset, slice.offset + slice.length);\n      const reader = new FileReader();\n      reader.onload = (event) => resolve(event.target.result);\n      reader.onerror = reject;\n      reader.onabort = reject;\n      reader.readAsArrayBuffer(blob);\n\n      if (signal) {\n        signal.addEventListener('abort', () => reader.abort());\n      }\n    });\n  }\n}\n\n/**\n * Create a new source from a given file/blob.\n * @param {Blob} file The file or blob to read from.\n * @returns The constructed source\n */\nexport function makeFileReaderSource(file) {\n  return new FileReaderSource(file);\n}\n","/** @module geotiff */\nimport GeoTIFFImage from './geotiffimage.js';\nimport DataView64 from './dataview64.js';\nimport DataSlice from './dataslice.js';\nimport Pool from './pool.js';\n\nimport { makeRemoteSource, makeCustomSource } from './source/remote.js';\nimport { makeBufferSource } from './source/arraybuffer.js';\nimport { makeFileReaderSource } from './source/filereader.js';\nimport { makeFileSource } from './source/file.js';\nimport { BaseClient, BaseResponse } from './source/client/base.js';\n\nimport { fieldTypes, fieldTagNames, arrayFields, geoKeyNames } from './globals.js';\nimport { writeGeotiff } from './geotiffwriter.js';\nimport * as globals from './globals.js';\nimport * as rgb from './rgb.js';\nimport { getDecoder, addDecoder } from './compression/index.js';\nimport { setLogger } from './logging.js';\n\nexport { globals };\nexport { rgb };\nexport { default as BaseDecoder } from './compression/basedecoder.js';\nexport { getDecoder, addDecoder };\nexport { setLogger };\n\n/**\n * @typedef {Uint8Array | Int8Array | Uint16Array | Int16Array | Uint32Array | Int32Array | Float32Array | Float64Array}\n * TypedArray\n */\n\n/**\n * @typedef {{ height:number, width: number }} Dimensions\n */\n\n/**\n * The autogenerated docs are a little confusing here. The effective type is:\n *\n * `TypedArray & { height: number; width: number}`\n * @typedef {TypedArray & Dimensions} TypedArrayWithDimensions\n */\n\n/**\n * The autogenerated docs are a little confusing here. The effective type is:\n *\n * `TypedArray[] & { height: number; width: number}`\n * @typedef {TypedArray[] & Dimensions} TypedArrayArrayWithDimensions\n */\n\n/**\n *  The autogenerated docs are a little confusing here. The effective type is:\n *\n * `(TypedArray | TypedArray[]) & { height: number; width: number}`\n * @typedef {TypedArrayWithDimensions | TypedArrayArrayWithDimensions} ReadRasterResult\n */\n\nfunction getFieldTypeLength(fieldType) {\n  switch (fieldType) {\n    case fieldTypes.BYTE: case fieldTypes.ASCII: case fieldTypes.SBYTE: case fieldTypes.UNDEFINED:\n      return 1;\n    case fieldTypes.SHORT: case fieldTypes.SSHORT:\n      return 2;\n    case fieldTypes.LONG: case fieldTypes.SLONG: case fieldTypes.FLOAT: case fieldTypes.IFD:\n      return 4;\n    case fieldTypes.RATIONAL: case fieldTypes.SRATIONAL: case fieldTypes.DOUBLE:\n    case fieldTypes.LONG8: case fieldTypes.SLONG8: case fieldTypes.IFD8:\n      return 8;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n}\n\nfunction parseGeoKeyDirectory(fileDirectory) {\n  const rawGeoKeyDirectory = fileDirectory.GeoKeyDirectory;\n  if (!rawGeoKeyDirectory) {\n    return null;\n  }\n\n  const geoKeyDirectory = {};\n  for (let i = 4; i <= rawGeoKeyDirectory[3] * 4; i += 4) {\n    const key = geoKeyNames[rawGeoKeyDirectory[i]];\n    const location = (rawGeoKeyDirectory[i + 1])\n      ? (fieldTagNames[rawGeoKeyDirectory[i + 1]]) : null;\n    const count = rawGeoKeyDirectory[i + 2];\n    const offset = rawGeoKeyDirectory[i + 3];\n\n    let value = null;\n    if (!location) {\n      value = offset;\n    } else {\n      value = fileDirectory[location];\n      if (typeof value === 'undefined' || value === null) {\n        throw new Error(`Could not get value of geoKey '${key}'.`);\n      } else if (typeof value === 'string') {\n        value = value.substring(offset, offset + count - 1);\n      } else if (value.subarray) {\n        value = value.subarray(offset, offset + count);\n        if (count === 1) {\n          value = value[0];\n        }\n      }\n    }\n    geoKeyDirectory[key] = value;\n  }\n  return geoKeyDirectory;\n}\n\nfunction getValues(dataSlice, fieldType, count, offset) {\n  let values = null;\n  let readMethod = null;\n  const fieldTypeLength = getFieldTypeLength(fieldType);\n\n  switch (fieldType) {\n    case fieldTypes.BYTE: case fieldTypes.ASCII: case fieldTypes.UNDEFINED:\n      values = new Uint8Array(count); readMethod = dataSlice.readUint8;\n      break;\n    case fieldTypes.SBYTE:\n      values = new Int8Array(count); readMethod = dataSlice.readInt8;\n      break;\n    case fieldTypes.SHORT:\n      values = new Uint16Array(count); readMethod = dataSlice.readUint16;\n      break;\n    case fieldTypes.SSHORT:\n      values = new Int16Array(count); readMethod = dataSlice.readInt16;\n      break;\n    case fieldTypes.LONG: case fieldTypes.IFD:\n      values = new Uint32Array(count); readMethod = dataSlice.readUint32;\n      break;\n    case fieldTypes.SLONG:\n      values = new Int32Array(count); readMethod = dataSlice.readInt32;\n      break;\n    case fieldTypes.LONG8: case fieldTypes.IFD8:\n      values = new Array(count); readMethod = dataSlice.readUint64;\n      break;\n    case fieldTypes.SLONG8:\n      values = new Array(count); readMethod = dataSlice.readInt64;\n      break;\n    case fieldTypes.RATIONAL:\n      values = new Uint32Array(count * 2); readMethod = dataSlice.readUint32;\n      break;\n    case fieldTypes.SRATIONAL:\n      values = new Int32Array(count * 2); readMethod = dataSlice.readInt32;\n      break;\n    case fieldTypes.FLOAT:\n      values = new Float32Array(count); readMethod = dataSlice.readFloat32;\n      break;\n    case fieldTypes.DOUBLE:\n      values = new Float64Array(count); readMethod = dataSlice.readFloat64;\n      break;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n\n  // normal fields\n  if (!(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {\n    for (let i = 0; i < count; ++i) {\n      values[i] = readMethod.call(\n        dataSlice, offset + (i * fieldTypeLength),\n      );\n    }\n  } else { // RATIONAL or SRATIONAL\n    for (let i = 0; i < count; i += 2) {\n      values[i] = readMethod.call(\n        dataSlice, offset + (i * fieldTypeLength),\n      );\n      values[i + 1] = readMethod.call(\n        dataSlice, offset + ((i * fieldTypeLength) + 4),\n      );\n    }\n  }\n\n  if (fieldType === fieldTypes.ASCII) {\n    return new TextDecoder('utf-8').decode(values);\n  }\n  return values;\n}\n\n/**\n * Data class to store the parsed file directory, geo key directory and\n * offset to the next IFD\n */\nclass ImageFileDirectory {\n  constructor(fileDirectory, geoKeyDirectory, nextIFDByteOffset) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeyDirectory = geoKeyDirectory;\n    this.nextIFDByteOffset = nextIFDByteOffset;\n  }\n}\n\n/**\n * Error class for cases when an IFD index was requested, that does not exist\n * in the file.\n */\nclass GeoTIFFImageIndexError extends Error {\n  constructor(index) {\n    super(`No image at index ${index}`);\n    this.index = index;\n  }\n}\n\nclass GeoTIFFBase {\n  /**\n   * (experimental) Reads raster data from the best fitting image. This function uses\n   * the image with the lowest resolution that is still a higher resolution than the\n   * requested resolution.\n   * When specified, the `bbox` option is translated to the `window` option and the\n   * `resX` and `resY` to `width` and `height` respectively.\n   * Then, the [readRasters]{@link GeoTIFFImage#readRasters} method of the selected\n   * image is called and the result returned.\n   * @see GeoTIFFImage.readRasters\n   * @param {import('./geotiffimage').ReadRasterOptions} [options={}] optional parameters\n   * @returns {Promise<ReadRasterResult>} the decoded array(s), with `height` and `width`, as a promise\n   */\n  async readRasters(options = {}) {\n    const { window: imageWindow, width, height } = options;\n    let { resX, resY, bbox } = options;\n\n    const firstImage = await this.getImage();\n    let usedImage = firstImage;\n    const imageCount = await this.getImageCount();\n    const imgBBox = firstImage.getBoundingBox();\n\n    if (imageWindow && bbox) {\n      throw new Error('Both \"bbox\" and \"window\" passed.');\n    }\n\n    // if width/height is passed, transform it to resolution\n    if (width || height) {\n      // if we have an image window (pixel coordinates), transform it to a BBox\n      // using the origin/resolution of the first image.\n      if (imageWindow) {\n        const [oX, oY] = firstImage.getOrigin();\n        const [rX, rY] = firstImage.getResolution();\n\n        bbox = [\n          oX + (imageWindow[0] * rX),\n          oY + (imageWindow[1] * rY),\n          oX + (imageWindow[2] * rX),\n          oY + (imageWindow[3] * rY),\n        ];\n      }\n\n      // if we have a bbox (or calculated one)\n\n      const usedBBox = bbox || imgBBox;\n\n      if (width) {\n        if (resX) {\n          throw new Error('Both width and resX passed');\n        }\n        resX = (usedBBox[2] - usedBBox[0]) / width;\n      }\n      if (height) {\n        if (resY) {\n          throw new Error('Both width and resY passed');\n        }\n        resY = (usedBBox[3] - usedBBox[1]) / height;\n      }\n    }\n\n    // if resolution is set or calculated, try to get the image with the worst acceptable resolution\n    if (resX || resY) {\n      const allImages = [];\n      for (let i = 0; i < imageCount; ++i) {\n        const image = await this.getImage(i);\n        const { SubfileType: subfileType, NewSubfileType: newSubfileType } = image.fileDirectory;\n        if (i === 0 || subfileType === 2 || newSubfileType & 1) {\n          allImages.push(image);\n        }\n      }\n\n      allImages.sort((a, b) => a.getWidth() - b.getWidth());\n      for (let i = 0; i < allImages.length; ++i) {\n        const image = allImages[i];\n        const imgResX = (imgBBox[2] - imgBBox[0]) / image.getWidth();\n        const imgResY = (imgBBox[3] - imgBBox[1]) / image.getHeight();\n\n        usedImage = image;\n        if ((resX && resX > imgResX) || (resY && resY > imgResY)) {\n          break;\n        }\n      }\n    }\n\n    let wnd = imageWindow;\n    if (bbox) {\n      const [oX, oY] = firstImage.getOrigin();\n      const [imageResX, imageResY] = usedImage.getResolution(firstImage);\n\n      wnd = [\n        Math.round((bbox[0] - oX) / imageResX),\n        Math.round((bbox[1] - oY) / imageResY),\n        Math.round((bbox[2] - oX) / imageResX),\n        Math.round((bbox[3] - oY) / imageResY),\n      ];\n      wnd = [\n        Math.min(wnd[0], wnd[2]),\n        Math.min(wnd[1], wnd[3]),\n        Math.max(wnd[0], wnd[2]),\n        Math.max(wnd[1], wnd[3]),\n      ];\n    }\n\n    return usedImage.readRasters({ ...options, window: wnd });\n  }\n}\n\n/**\n * @typedef {Object} GeoTIFFOptions\n * @property {boolean} [cache=false] whether or not decoded tiles shall be cached.\n */\n\n/**\n * The abstraction for a whole GeoTIFF file.\n * @augments GeoTIFFBase\n */\nclass GeoTIFF extends GeoTIFFBase {\n  /**\n   * @constructor\n   * @param {*} source The datasource to read from.\n   * @param {boolean} littleEndian Whether the image uses little endian.\n   * @param {boolean} bigTiff Whether the image uses bigTIFF conventions.\n   * @param {number} firstIFDOffset The numeric byte-offset from the start of the image\n   *                                to the first IFD.\n   * @param {GeoTIFFOptions} [options] further options.\n   */\n  constructor(source, littleEndian, bigTiff, firstIFDOffset, options = {}) {\n    super();\n    this.source = source;\n    this.littleEndian = littleEndian;\n    this.bigTiff = bigTiff;\n    this.firstIFDOffset = firstIFDOffset;\n    this.cache = options.cache || false;\n    this.ifdRequests = [];\n    this.ghostValues = null;\n  }\n\n  async getSlice(offset, size) {\n    const fallbackSize = this.bigTiff ? 4048 : 1024;\n    return new DataSlice(\n      (await this.source.fetch([{\n        offset,\n        length: typeof size !== 'undefined' ? size : fallbackSize,\n      }]))[0],\n      offset,\n      this.littleEndian,\n      this.bigTiff,\n    );\n  }\n\n  /**\n   * Instructs to parse an image file directory at the given file offset.\n   * As there is no way to ensure that a location is indeed the start of an IFD,\n   * this function must be called with caution (e.g only using the IFD offsets from\n   * the headers or other IFDs).\n   * @param {number} offset the offset to parse the IFD at\n   * @returns {Promise<ImageFileDirectory>} the parsed IFD\n   */\n  async parseFileDirectoryAt(offset) {\n    const entrySize = this.bigTiff ? 20 : 12;\n    const offsetSize = this.bigTiff ? 8 : 2;\n\n    let dataSlice = await this.getSlice(offset);\n    const numDirEntries = this.bigTiff\n      ? dataSlice.readUint64(offset)\n      : dataSlice.readUint16(offset);\n\n    // if the slice does not cover the whole IFD, request a bigger slice, where the\n    // whole IFD fits: num of entries + n x tag length + offset to next IFD\n    const byteSize = (numDirEntries * entrySize) + (this.bigTiff ? 16 : 6);\n    if (!dataSlice.covers(offset, byteSize)) {\n      dataSlice = await this.getSlice(offset, byteSize);\n    }\n\n    const fileDirectory = {};\n\n    // loop over the IFD and create a file directory object\n    let i = offset + (this.bigTiff ? 8 : 2);\n    for (let entryCount = 0; entryCount < numDirEntries; i += entrySize, ++entryCount) {\n      const fieldTag = dataSlice.readUint16(i);\n      const fieldType = dataSlice.readUint16(i + 2);\n      const typeCount = this.bigTiff\n        ? dataSlice.readUint64(i + 4)\n        : dataSlice.readUint32(i + 4);\n\n      let fieldValues;\n      let value;\n      const fieldTypeLength = getFieldTypeLength(fieldType);\n      const valueOffset = i + (this.bigTiff ? 12 : 8);\n\n      // check whether the value is directly encoded in the tag or refers to a\n      // different external byte range\n      if (fieldTypeLength * typeCount <= (this.bigTiff ? 8 : 4)) {\n        fieldValues = getValues(dataSlice, fieldType, typeCount, valueOffset);\n      } else {\n        // resolve the reference to the actual byte range\n        const actualOffset = dataSlice.readOffset(valueOffset);\n        const length = getFieldTypeLength(fieldType) * typeCount;\n\n        // check, whether we actually cover the referenced byte range; if not,\n        // request a new slice of bytes to read from it\n        if (dataSlice.covers(actualOffset, length)) {\n          fieldValues = getValues(dataSlice, fieldType, typeCount, actualOffset);\n        } else {\n          const fieldDataSlice = await this.getSlice(actualOffset, length);\n          fieldValues = getValues(fieldDataSlice, fieldType, typeCount, actualOffset);\n        }\n      }\n\n      // unpack single values from the array\n      if (typeCount === 1 && arrayFields.indexOf(fieldTag) === -1\n        && !(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {\n        value = fieldValues[0];\n      } else {\n        value = fieldValues;\n      }\n\n      // write the tags value to the file directly\n      fileDirectory[fieldTagNames[fieldTag]] = value;\n    }\n    const geoKeyDirectory = parseGeoKeyDirectory(fileDirectory);\n    const nextIFDByteOffset = dataSlice.readOffset(\n      offset + offsetSize + (entrySize * numDirEntries),\n    );\n\n    return new ImageFileDirectory(\n      fileDirectory,\n      geoKeyDirectory,\n      nextIFDByteOffset,\n    );\n  }\n\n  async requestIFD(index) {\n    // see if we already have that IFD index requested.\n    if (this.ifdRequests[index]) {\n      // attach to an already requested IFD\n      return this.ifdRequests[index];\n    } else if (index === 0) {\n      // special case for index 0\n      this.ifdRequests[index] = this.parseFileDirectoryAt(this.firstIFDOffset);\n      return this.ifdRequests[index];\n    } else if (!this.ifdRequests[index - 1]) {\n      // if the previous IFD was not yet loaded, load that one first\n      // this is the recursive call.\n      try {\n        this.ifdRequests[index - 1] = this.requestIFD(index - 1);\n      } catch (e) {\n        // if the previous one already was an index error, rethrow\n        // with the current index\n        if (e instanceof GeoTIFFImageIndexError) {\n          throw new GeoTIFFImageIndexError(index);\n        }\n        // rethrow anything else\n        throw e;\n      }\n    }\n    // if the previous IFD was loaded, we can finally fetch the one we are interested in.\n    // we need to wrap this in an IIFE, otherwise this.ifdRequests[index] would be delayed\n    this.ifdRequests[index] = (async () => {\n      const previousIfd = await this.ifdRequests[index - 1];\n      if (previousIfd.nextIFDByteOffset === 0) {\n        throw new GeoTIFFImageIndexError(index);\n      }\n      return this.parseFileDirectoryAt(previousIfd.nextIFDByteOffset);\n    })();\n    return this.ifdRequests[index];\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {number} [index=0] the index of the image to return.\n   * @returns {Promise<GeoTIFFImage>} the image at the given index\n   */\n  async getImage(index = 0) {\n    const ifd = await this.requestIFD(index);\n    return new GeoTIFFImage(\n      ifd.fileDirectory, ifd.geoKeyDirectory,\n      this.dataView, this.littleEndian, this.cache, this.source,\n    );\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Promise<number>} the number of internal subfile images\n   */\n  async getImageCount() {\n    let index = 0;\n    // loop until we run out of IFDs\n    let hasNext = true;\n    while (hasNext) {\n      try {\n        await this.requestIFD(index);\n        ++index;\n      } catch (e) {\n        if (e instanceof GeoTIFFImageIndexError) {\n          hasNext = false;\n        } else {\n          throw e;\n        }\n      }\n    }\n    return index;\n  }\n\n  /**\n   * Get the values of the COG ghost area as a parsed map.\n   * See https://gdal.org/drivers/raster/cog.html#header-ghost-area for reference\n   * @returns {Promise<Object>} the parsed ghost area or null, if no such area was found\n   */\n  async getGhostValues() {\n    const offset = this.bigTiff ? 16 : 8;\n    if (this.ghostValues) {\n      return this.ghostValues;\n    }\n    const detectionString = 'GDAL_STRUCTURAL_METADATA_SIZE=';\n    const heuristicAreaSize = detectionString.length + 100;\n    let slice = await this.getSlice(offset, heuristicAreaSize);\n    if (detectionString === getValues(slice, fieldTypes.ASCII, detectionString.length, offset)) {\n      const valuesString = getValues(slice, fieldTypes.ASCII, heuristicAreaSize, offset);\n      const firstLine = valuesString.split('\\n')[0];\n      const metadataSize = Number(firstLine.split('=')[1].split(' ')[0]) + firstLine.length;\n      if (metadataSize > heuristicAreaSize) {\n        slice = await this.getSlice(offset, metadataSize);\n      }\n      const fullString = getValues(slice, fieldTypes.ASCII, metadataSize, offset);\n      this.ghostValues = {};\n      fullString\n        .split('\\n')\n        .filter((line) => line.length > 0)\n        .map((line) => line.split('='))\n        .forEach(([key, value]) => {\n          this.ghostValues[key] = value;\n        });\n    }\n    return this.ghostValues;\n  }\n\n  /**\n   * Parse a (Geo)TIFF file from the given source.\n   *\n   * @param {*} source The source of data to parse from.\n   * @param {GeoTIFFOptions} [options] Additional options.\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   */\n  static async fromSource(source, options, signal) {\n    const headerData = (await source.fetch([{ offset: 0, length: 1024 }], signal))[0];\n    const dataView = new DataView64(headerData);\n\n    const BOM = dataView.getUint16(0, 0);\n    let littleEndian;\n    if (BOM === 0x4949) {\n      littleEndian = true;\n    } else if (BOM === 0x4D4D) {\n      littleEndian = false;\n    } else {\n      throw new TypeError('Invalid byte order value.');\n    }\n\n    const magicNumber = dataView.getUint16(2, littleEndian);\n    let bigTiff;\n    if (magicNumber === 42) {\n      bigTiff = false;\n    } else if (magicNumber === 43) {\n      bigTiff = true;\n      const offsetByteSize = dataView.getUint16(4, littleEndian);\n      if (offsetByteSize !== 8) {\n        throw new Error('Unsupported offset byte-size.');\n      }\n    } else {\n      throw new TypeError('Invalid magic number.');\n    }\n\n    const firstIFDOffset = bigTiff\n      ? dataView.getUint64(8, littleEndian)\n      : dataView.getUint32(4, littleEndian);\n    return new GeoTIFF(source, littleEndian, bigTiff, firstIFDOffset, options);\n  }\n\n  /**\n   * Closes the underlying file buffer\n   * N.B. After the GeoTIFF has been completely processed it needs\n   * to be closed but only if it has been constructed from a file.\n   */\n  close() {\n    if (typeof this.source.close === 'function') {\n      return this.source.close();\n    }\n    return false;\n  }\n}\n\nexport { GeoTIFF };\nexport default GeoTIFF;\n\n/**\n * Wrapper for GeoTIFF files that have external overviews.\n * @augments GeoTIFFBase\n */\nclass MultiGeoTIFF extends GeoTIFFBase {\n  /**\n   * Construct a new MultiGeoTIFF from a main and several overview files.\n   * @param {GeoTIFF} mainFile The main GeoTIFF file.\n   * @param {GeoTIFF[]} overviewFiles An array of overview files.\n   */\n  constructor(mainFile, overviewFiles) {\n    super();\n    this.mainFile = mainFile;\n    this.overviewFiles = overviewFiles;\n    this.imageFiles = [mainFile].concat(overviewFiles);\n\n    this.fileDirectoriesPerFile = null;\n    this.fileDirectoriesPerFileParsing = null;\n    this.imageCount = null;\n  }\n\n  async parseFileDirectoriesPerFile() {\n    const requests = [this.mainFile.parseFileDirectoryAt(this.mainFile.firstIFDOffset)]\n      .concat(this.overviewFiles.map((file) => file.parseFileDirectoryAt(file.firstIFDOffset)));\n\n    this.fileDirectoriesPerFile = await Promise.all(requests);\n    return this.fileDirectoriesPerFile;\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {number} [index=0] the index of the image to return.\n   * @returns {Promise<GeoTIFFImage>} the image at the given index\n   */\n  async getImage(index = 0) {\n    await this.getImageCount();\n    await this.parseFileDirectoriesPerFile();\n    let visited = 0;\n    let relativeIndex = 0;\n    for (let i = 0; i < this.imageFiles.length; i++) {\n      const imageFile = this.imageFiles[i];\n      for (let ii = 0; ii < this.imageCounts[i]; ii++) {\n        if (index === visited) {\n          const ifd = await imageFile.requestIFD(relativeIndex);\n          return new GeoTIFFImage(\n            ifd.fileDirectory, ifd.geoKeyDirectory,\n            imageFile.dataView, imageFile.littleEndian, imageFile.cache, imageFile.source,\n          );\n        }\n        visited++;\n        relativeIndex++;\n      }\n      relativeIndex = 0;\n    }\n\n    throw new RangeError('Invalid image index');\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Promise<number>} the number of internal subfile images\n   */\n  async getImageCount() {\n    if (this.imageCount !== null) {\n      return this.imageCount;\n    }\n    const requests = [this.mainFile.getImageCount()]\n      .concat(this.overviewFiles.map((file) => file.getImageCount()));\n    this.imageCounts = await Promise.all(requests);\n    this.imageCount = this.imageCounts.reduce((count, ifds) => count + ifds, 0);\n    return this.imageCount;\n  }\n}\n\nexport { MultiGeoTIFF };\n\n/**\n * Creates a new GeoTIFF from a remote URL.\n * @param {string} url The URL to access the image from\n * @param {object} [options] Additional options to pass to the source.\n *                           See {@link makeRemoteSource} for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromUrl(url, options = {}, signal) {\n  return GeoTIFF.fromSource(makeRemoteSource(url, options), signal);\n}\n\n/**\n * Creates a new GeoTIFF from a custom {@link BaseClient}.\n * @param {BaseClient} client The client.\n * @param {object} [options] Additional options to pass to the source.\n *                           See {@link makeRemoteSource} for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromCustomClient(client, options = {}, signal) {\n  return GeoTIFF.fromSource(makeCustomSource(client, options), signal);\n}\n\n/**\n * Construct a new GeoTIFF from an\n * [ArrayBuffer]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer}.\n * @param {ArrayBuffer} arrayBuffer The data to read the file from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromArrayBuffer(arrayBuffer, signal) {\n  return GeoTIFF.fromSource(makeBufferSource(arrayBuffer), signal);\n}\n\n/**\n * Construct a GeoTIFF from a local file path. This uses the node\n * [filesystem API]{@link https://nodejs.org/api/fs.html} and is\n * not available on browsers.\n *\n * N.B. After the GeoTIFF has been completely processed it needs\n * to be closed but only if it has been constructed from a file.\n * @param {string} path The file path to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromFile(path, signal) {\n  return GeoTIFF.fromSource(makeFileSource(path), signal);\n}\n\n/**\n * Construct a GeoTIFF from an HTML\n * [Blob]{@link https://developer.mozilla.org/en-US/docs/Web/API/Blob} or\n * [File]{@link https://developer.mozilla.org/en-US/docs/Web/API/File}\n * object.\n * @param {Blob|File} blob The Blob or File object to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromBlob(blob, signal) {\n  return GeoTIFF.fromSource(makeFileReaderSource(blob), signal);\n}\n\n/**\n * Construct a MultiGeoTIFF from the given URLs.\n * @param {string} mainUrl The URL for the main file.\n * @param {string[]} overviewUrls An array of URLs for the overview images.\n * @param {Object} [options] Additional options to pass to the source.\n *                           See [makeRemoteSource]{@link module:source.makeRemoteSource}\n *                           for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<MultiGeoTIFF>} The resulting MultiGeoTIFF file.\n */\nexport async function fromUrls(mainUrl, overviewUrls = [], options = {}, signal) {\n  const mainFile = await GeoTIFF.fromSource(makeRemoteSource(mainUrl, options), signal);\n  const overviewFiles = await Promise.all(\n    overviewUrls.map((url) => GeoTIFF.fromSource(makeRemoteSource(url, options))),\n  );\n\n  return new MultiGeoTIFF(mainFile, overviewFiles);\n}\n\n/**\n * Main creating function for GeoTIFF files.\n * @param {(Array)} array of pixel values\n * @returns {metadata} metadata\n */\nexport function writeArrayBuffer(values, metadata) {\n  return writeGeotiff(values, metadata);\n}\n\nexport { Pool };\nexport { GeoTIFFImage };\nexport { BaseClient, BaseResponse };\n","/**\n * @module ol/source/GeoTIFF\n */\nimport DataTile from './DataTile.js';\nimport TileGrid from '../tilegrid/TileGrid.js';\nimport {\n  Pool,\n  globals as geotiffGlobals,\n  fromBlob as tiffFromBlob,\n  fromUrl as tiffFromUrl,\n  fromUrls as tiffFromUrls,\n} from 'geotiff';\nimport {\n  Projection,\n  get as getCachedProjection,\n  toUserCoordinate,\n  toUserExtent,\n} from '../proj.js';\nimport {clamp} from '../math.js';\nimport {getCenter, getIntersection} from '../extent.js';\nimport {error as logError} from '../console.js';\nimport {fromCode as unitsFromCode} from '../proj/Units.js';\n\n/**\n * Determine if an image type is a mask.\n * See https://www.awaresystems.be/imaging/tiff/tifftags/newsubfiletype.html\n * @param {GeoTIFFImage} image The image.\n * @return {boolean} The image is a mask.\n */\nfunction isMask(image) {\n  const fileDirectory = image.fileDirectory;\n  const type = fileDirectory.NewSubfileType || 0;\n  return (type & 4) === 4;\n}\n\n/**\n * @param {true|false|'auto'} preference The convertToRGB option.\n * @param {GeoTIFFImage} image The image.\n * @return {boolean} Use the `image.readRGB()` method.\n */\nfunction readRGB(preference, image) {\n  if (!preference) {\n    return false;\n  }\n  if (preference === true) {\n    return true;\n  }\n  if (image.getSamplesPerPixel() !== 3) {\n    return false;\n  }\n  const interpretation = image.fileDirectory.PhotometricInterpretation;\n  const interpretations = geotiffGlobals.photometricInterpretations;\n  return (\n    interpretation === interpretations.CMYK ||\n    interpretation === interpretations.YCbCr ||\n    interpretation === interpretations.CIELab ||\n    interpretation === interpretations.ICCLab\n  );\n}\n\n/**\n * @typedef {Object} SourceInfo\n * @property {string} [url] URL for the source GeoTIFF.\n * @property {Array<string>} [overviews] List of any overview URLs, only applies if the url parameter is given.\n * @property {Blob} [blob] Blob containing the source GeoTIFF. `blob` and `url` are mutually exclusive.\n * @property {number} [min=0] The minimum source data value.  Rendered values are scaled from 0 to 1 based on\n * the configured min and max.  If not provided and raster statistics are available, those will be used instead.\n * If neither are available, the minimum for the data type will be used.  To disable this behavior, set\n * the `normalize` option to `false` in the constructor.\n * @property {number} [max] The maximum source data value.  Rendered values are scaled from 0 to 1 based on\n * the configured min and max.  If not provided and raster statistics are available, those will be used instead.\n * If neither are available, the maximum for the data type will be used.  To disable this behavior, set\n * the `normalize` option to `false` in the constructor.\n * @property {number} [nodata] Values to discard (overriding any nodata values in the metadata).\n * When provided, an additional alpha band will be added to the data.  Often the GeoTIFF metadata\n * will include information about nodata values, so you should only need to set this property if\n * you find that it is not already extracted from the metadata.\n * @property {Array<number>} [bands] Band numbers to be read from (where the first band is `1`). If not provided, all bands will\n * be read. For example, if a GeoTIFF has blue (1), green (2), red (3), and near-infrared (4) bands, and you only need the\n * near-infrared band, configure `bands: [4]`.\n */\n\n/**\n * @typedef {Object} GeoKeys\n * @property {number} GTModelTypeGeoKey Model type.\n * @property {number} GTRasterTypeGeoKey Raster type.\n * @property {number} GeogAngularUnitsGeoKey Angular units.\n * @property {number} GeogInvFlatteningGeoKey Inverse flattening.\n * @property {number} GeogSemiMajorAxisGeoKey Semi-major axis.\n * @property {number} GeographicTypeGeoKey Geographic coordinate system code.\n * @property {number} ProjLinearUnitsGeoKey Projected linear unit code.\n * @property {number} ProjectedCSTypeGeoKey Projected coordinate system code.\n */\n\n/**\n * @typedef {import(\"geotiff\").GeoTIFF} GeoTIFF\n */\n\n/**\n * @typedef {import(\"geotiff\").MultiGeoTIFF} MultiGeoTIFF\n */\n\n/**\n * @typedef {Object} GDALMetadata\n * @property {string} STATISTICS_MINIMUM The minimum value (as a string).\n * @property {string} STATISTICS_MAXIMUM The maximum value (as a string).\n */\n\nconst STATISTICS_MAXIMUM = 'STATISTICS_MAXIMUM';\nconst STATISTICS_MINIMUM = 'STATISTICS_MINIMUM';\n\nconst defaultTileSize = 256;\n\n/**\n * @typedef {import(\"geotiff\").GeoTIFFImage} GeoTIFFImage\n */\n\nlet workerPool;\nfunction getWorkerPool() {\n  if (!workerPool) {\n    workerPool = new Pool();\n  }\n  return workerPool;\n}\n\n/**\n * Get the bounding box of an image.  If the image does not have an affine transform,\n * the pixel bounds are returned.\n * @param {GeoTIFFImage} image The image.\n * @return {Array<number>} The image bounding box.\n */\nfunction getBoundingBox(image) {\n  try {\n    return image.getBoundingBox();\n  } catch (_) {\n    return [0, 0, image.getWidth(), image.getHeight()];\n  }\n}\n\n/**\n * Get the origin of an image.  If the image does not have an affine transform,\n * the top-left corner of the pixel bounds is returned.\n * @param {GeoTIFFImage} image The image.\n * @return {Array<number>} The image origin.\n */\nfunction getOrigin(image) {\n  try {\n    return image.getOrigin().slice(0, 2);\n  } catch (_) {\n    return [0, image.getHeight()];\n  }\n}\n\n/**\n * Get the resolution of an image.  If the image does not have an affine transform,\n * the width of the image is compared with the reference image.\n * @param {GeoTIFFImage} image The image.\n * @param {GeoTIFFImage} referenceImage The reference image.\n * @return {Array<number>} The map x and y units per pixel.\n */\nfunction getResolutions(image, referenceImage) {\n  try {\n    return image.getResolution(referenceImage);\n  } catch (_) {\n    return [\n      referenceImage.getWidth() / image.getWidth(),\n      referenceImage.getHeight() / image.getHeight(),\n    ];\n  }\n}\n\n/**\n * @param {GeoTIFFImage} image A GeoTIFF.\n * @return {import(\"../proj/Projection.js\").default} The image projection.\n */\nfunction getProjection(image) {\n  const geoKeys = image.geoKeys;\n  if (!geoKeys) {\n    return null;\n  }\n\n  if (\n    geoKeys.ProjectedCSTypeGeoKey &&\n    geoKeys.ProjectedCSTypeGeoKey !== 32767\n  ) {\n    const code = 'EPSG:' + geoKeys.ProjectedCSTypeGeoKey;\n    let projection = getCachedProjection(code);\n    if (!projection) {\n      const units = unitsFromCode(geoKeys.ProjLinearUnitsGeoKey);\n      if (units) {\n        projection = new Projection({\n          code: code,\n          units: units,\n        });\n      }\n    }\n    return projection;\n  }\n\n  if (geoKeys.GeographicTypeGeoKey && geoKeys.GeographicTypeGeoKey !== 32767) {\n    const code = 'EPSG:' + geoKeys.GeographicTypeGeoKey;\n    let projection = getCachedProjection(code);\n    if (!projection) {\n      const units = unitsFromCode(geoKeys.GeogAngularUnitsGeoKey);\n      if (units) {\n        projection = new Projection({\n          code: code,\n          units: units,\n        });\n      }\n    }\n    return projection;\n  }\n\n  return null;\n}\n\n/**\n * @param {GeoTIFF|MultiGeoTIFF} tiff A GeoTIFF.\n * @return {Promise<Array<GeoTIFFImage>>} Resolves to a list of images.\n */\nfunction getImagesForTIFF(tiff) {\n  return tiff.getImageCount().then(function (count) {\n    const requests = new Array(count);\n    for (let i = 0; i < count; ++i) {\n      requests[i] = tiff.getImage(i);\n    }\n    return Promise.all(requests);\n  });\n}\n\n/**\n * @param {SourceInfo} source The GeoTIFF source.\n * @param {Object} options Options for the GeoTIFF source.\n * @return {Promise<Array<GeoTIFFImage>>} Resolves to a list of images.\n */\nfunction getImagesForSource(source, options) {\n  let request;\n  if (source.blob) {\n    request = tiffFromBlob(source.blob);\n  } else if (source.overviews) {\n    request = tiffFromUrls(source.url, source.overviews, options);\n  } else {\n    request = tiffFromUrl(source.url, options);\n  }\n  return request.then(getImagesForTIFF);\n}\n\n/**\n * @param {number|Array<number>|Array<Array<number>>} expected Expected value.\n * @param {number|Array<number>|Array<Array<number>>} got Actual value.\n * @param {number} tolerance Accepted tolerance in fraction of expected between expected and got.\n * @param {string} message The error message.\n * @param {function(Error):void} rejector A function to be called with any error.\n */\nfunction assertEqual(expected, got, tolerance, message, rejector) {\n  if (Array.isArray(expected)) {\n    const length = expected.length;\n    if (!Array.isArray(got) || length != got.length) {\n      const error = new Error(message);\n      rejector(error);\n      throw error;\n    }\n    for (let i = 0; i < length; ++i) {\n      assertEqual(expected[i], got[i], tolerance, message, rejector);\n    }\n    return;\n  }\n\n  got = /** @type {number} */ (got);\n  if (Math.abs(expected - got) > tolerance * expected) {\n    throw new Error(message);\n  }\n}\n\n/**\n * @param {Array} array The data array.\n * @return {number} The minimum value.\n */\nfunction getMinForDataType(array) {\n  if (array instanceof Int8Array) {\n    return -128;\n  }\n  if (array instanceof Int16Array) {\n    return -32768;\n  }\n  if (array instanceof Int32Array) {\n    return -2147483648;\n  }\n  if (array instanceof Float32Array) {\n    return 1.2e-38;\n  }\n  return 0;\n}\n\n/**\n * @param {Array} array The data array.\n * @return {number} The maximum value.\n */\nfunction getMaxForDataType(array) {\n  if (array instanceof Int8Array) {\n    return 127;\n  }\n  if (array instanceof Uint8Array) {\n    return 255;\n  }\n  if (array instanceof Uint8ClampedArray) {\n    return 255;\n  }\n  if (array instanceof Int16Array) {\n    return 32767;\n  }\n  if (array instanceof Uint16Array) {\n    return 65535;\n  }\n  if (array instanceof Int32Array) {\n    return 2147483647;\n  }\n  if (array instanceof Uint32Array) {\n    return 4294967295;\n  }\n  if (array instanceof Float32Array) {\n    return 3.4e38;\n  }\n  return 255;\n}\n\n/**\n * @typedef {Object} GeoTIFFSourceOptions\n * @property {boolean} [forceXHR=false] Whether to force the usage of the browsers XMLHttpRequest API.\n * @property {Object<string, string>} [headers] additional key-value pairs of headers to be passed with each request. Key is the header name, value the header value.\n * @property {string} [credentials] How credentials shall be handled. See\n * https://developer.mozilla.org/en-US/docs/Web/API/fetch for reference and possible values\n * @property {number} [maxRanges] The maximum amount of ranges to request in a single multi-range request.\n * By default only a single range is used.\n * @property {boolean} [allowFullFile=false] Whether or not a full file is accepted when only a portion is\n * requested. Only use this when you know the source image to be small enough to fit in memory.\n * @property {number} [blockSize=65536] The block size to use.\n * @property {number} [cacheSize=100] The number of blocks that shall be held in a LRU cache.\n */\n\n/**\n * @typedef {Object} Options\n * @property {Array<SourceInfo>} sources List of information about GeoTIFF sources.\n * Multiple sources can be combined when their resolution sets are equal after applying a scale.\n * The list of sources defines a mapping between input bands as they are read from each GeoTIFF and\n * the output bands that are provided by data tiles. To control which bands to read from each GeoTIFF,\n * use the {@link import(\"./GeoTIFF.js\").SourceInfo bands} property. If, for example, you specify two\n * sources, one with 3 bands and {@link import(\"./GeoTIFF.js\").SourceInfo nodata} configured, and\n * another with 1 band, the resulting data tiles will have 5 bands: 3 from the first source, 1 alpha\n * band from the first source, and 1 band from the second source.\n * @property {GeoTIFFSourceOptions} [sourceOptions] Additional options to be passed to [geotiff.js](https://geotiffjs.github.io/geotiff.js/module-geotiff.html)'s `fromUrl` or `fromUrls` methods.\n * @property {true|false|'auto'} [convertToRGB=false] By default, bands from the sources are read as-is. When\n * reading GeoTIFFs with the purpose of displaying them as RGB images, setting this to `true` will\n * convert other color spaces (YCbCr, CMYK) to RGB.  Setting the option to `'auto'` will make it so CMYK, YCbCr,\n * CIELab, and ICCLab images will automatically be converted to RGB.\n * @property {boolean} [normalize=true] By default, the source data is normalized to values between\n * 0 and 1 with scaling factors based on the raster statistics or `min` and `max` properties of each source.\n * If instead you want to work with the raw values in a style expression, set this to `false`.  Setting this option\n * to `false` will make it so any `min` and `max` properties on sources are ignored.\n * @property {boolean} [opaque=false] Whether the layer is opaque.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Source projection.  If not provided, the GeoTIFF metadata\n * will be read for projection information.\n * @property {number} [transition=250] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {boolean} [wrapX=false] Render tiles beyond the tile grid extent.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * the linear interpolation is used to resample the data.  If false, nearest neighbor is used.\n */\n\n/**\n * @classdesc\n * A source for working with GeoTIFF data.\n * **Note for users of the full build**: The `GeoTIFF` source requires the\n * [geotiff.js](https://github.com/geotiffjs/geotiff.js) library to be loaded as well.\n *\n * @api\n */\nclass GeoTIFFSource extends DataTile {\n  /**\n   * @param {Options} options Data tile options.\n   */\n  constructor(options) {\n    super({\n      state: 'loading',\n      tileGrid: null,\n      projection: options.projection || null,\n      opaque: options.opaque,\n      transition: options.transition,\n      interpolate: options.interpolate !== false,\n      wrapX: options.wrapX,\n    });\n\n    /**\n     * @type {Array<SourceInfo>}\n     * @private\n     */\n    this.sourceInfo_ = options.sources;\n\n    const numSources = this.sourceInfo_.length;\n\n    /**\n     * @type {Object}\n     * @private\n     */\n    this.sourceOptions_ = options.sourceOptions;\n\n    /**\n     * @type {Array<Array<GeoTIFFImage>>}\n     * @private\n     */\n    this.sourceImagery_ = new Array(numSources);\n\n    /**\n     * @type {Array<Array<GeoTIFFImage>>}\n     * @private\n     */\n    this.sourceMasks_ = new Array(numSources);\n\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    this.resolutionFactors_ = new Array(numSources);\n\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    this.samplesPerPixel_;\n\n    /**\n     * @type {Array<Array<number>>}\n     * @private\n     */\n    this.nodataValues_;\n\n    /**\n     * @type {Array<Array<GDALMetadata>>}\n     * @private\n     */\n    this.metadata_;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.normalize_ = options.normalize !== false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.addAlpha_ = false;\n\n    /**\n     * @type {Error}\n     * @private\n     */\n    this.error_ = null;\n\n    /**\n     * @type {true|false|'auto'}\n     */\n    this.convertToRGB_ = options.convertToRGB || false;\n\n    this.setKey(this.sourceInfo_.map((source) => source.url).join(','));\n\n    const self = this;\n    const requests = new Array(numSources);\n    for (let i = 0; i < numSources; ++i) {\n      requests[i] = getImagesForSource(\n        this.sourceInfo_[i],\n        this.sourceOptions_,\n      );\n    }\n    Promise.all(requests)\n      .then(function (sources) {\n        self.configure_(sources);\n      })\n      .catch(function (error) {\n        logError(error);\n        self.error_ = error;\n        self.setState('error');\n      });\n  }\n\n  /**\n   * @return {Error} A source loading error. When the source state is `error`, use this function\n   * to get more information about the error. To debug a faulty configuration, you may want to use\n   * a listener like\n   * ```js\n   * geotiffSource.on('change', () => {\n   *   if (geotiffSource.getState() === 'error') {\n   *     console.error(geotiffSource.getError());\n   *   }\n   * });\n   * ```\n   */\n  getError() {\n    return this.error_;\n  }\n\n  /**\n   * Determine the projection of the images in this GeoTIFF.\n   * The default implementation looks at the ProjectedCSTypeGeoKey and the GeographicTypeGeoKey\n   * of each image in turn.\n   * You can override this method in a subclass to support more projections.\n   *\n   * @param {Array<Array<GeoTIFFImage>>} sources Each source is a list of images\n   * from a single GeoTIFF.\n   */\n  determineProjection(sources) {\n    const firstSource = sources[0];\n    for (let i = firstSource.length - 1; i >= 0; --i) {\n      const image = firstSource[i];\n      const projection = getProjection(image);\n      if (projection) {\n        this.projection = projection;\n        break;\n      }\n    }\n  }\n\n  /**\n   * Configure the tile grid based on images within the source GeoTIFFs.  Each GeoTIFF\n   * must have the same internal tiled structure.\n   * @param {Array<Array<GeoTIFFImage>>} sources Each source is a list of images\n   * from a single GeoTIFF.\n   * @private\n   */\n  configure_(sources) {\n    let extent;\n    let origin;\n    let commonRenderTileSizes;\n    let commonSourceTileSizes;\n    let resolutions;\n    const samplesPerPixel = new Array(sources.length);\n    const nodataValues = new Array(sources.length);\n    const metadata = new Array(sources.length);\n    let minZoom = 0;\n\n    const sourceCount = sources.length;\n    for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n      const images = [];\n      const masks = [];\n      sources[sourceIndex].forEach((item) => {\n        if (isMask(item)) {\n          masks.push(item);\n        } else {\n          images.push(item);\n        }\n      });\n\n      const imageCount = images.length;\n      if (masks.length > 0 && masks.length !== imageCount) {\n        throw new Error(\n          `Expected one mask per image found ${masks.length} masks and ${imageCount} images`,\n        );\n      }\n\n      let sourceExtent;\n      let sourceOrigin;\n      const sourceTileSizes = new Array(imageCount);\n      const renderTileSizes = new Array(imageCount);\n      const sourceResolutions = new Array(imageCount);\n\n      nodataValues[sourceIndex] = new Array(imageCount);\n      metadata[sourceIndex] = new Array(imageCount);\n\n      for (let imageIndex = 0; imageIndex < imageCount; ++imageIndex) {\n        const image = images[imageIndex];\n        const nodataValue = image.getGDALNoData();\n        metadata[sourceIndex][imageIndex] = image.getGDALMetadata(0);\n        nodataValues[sourceIndex][imageIndex] = nodataValue;\n\n        const wantedSamples = this.sourceInfo_[sourceIndex].bands;\n        samplesPerPixel[sourceIndex] = wantedSamples\n          ? wantedSamples.length\n          : image.getSamplesPerPixel();\n        const level = imageCount - (imageIndex + 1);\n\n        if (!sourceExtent) {\n          sourceExtent = getBoundingBox(image);\n        }\n\n        if (!sourceOrigin) {\n          sourceOrigin = getOrigin(image);\n        }\n\n        const imageResolutions = getResolutions(image, images[0]);\n        sourceResolutions[level] = imageResolutions[0];\n\n        const sourceTileSize = [image.getTileWidth(), image.getTileHeight()];\n\n        // request larger blocks for untiled layouts\n        if (\n          sourceTileSize[0] !== sourceTileSize[1] &&\n          sourceTileSize[1] < defaultTileSize\n        ) {\n          sourceTileSize[0] = defaultTileSize;\n          sourceTileSize[1] = defaultTileSize;\n        }\n\n        sourceTileSizes[level] = sourceTileSize;\n\n        const aspectRatio = imageResolutions[0] / Math.abs(imageResolutions[1]);\n        renderTileSizes[level] = [\n          sourceTileSize[0],\n          sourceTileSize[1] / aspectRatio,\n        ];\n      }\n\n      if (!extent) {\n        extent = sourceExtent;\n      } else {\n        getIntersection(extent, sourceExtent, extent);\n      }\n\n      if (!origin) {\n        origin = sourceOrigin;\n      } else {\n        const message = `Origin mismatch for source ${sourceIndex}, got [${sourceOrigin}] but expected [${origin}]`;\n        assertEqual(origin, sourceOrigin, 0, message, this.viewRejector);\n      }\n\n      if (!resolutions) {\n        resolutions = sourceResolutions;\n        this.resolutionFactors_[sourceIndex] = 1;\n      } else {\n        if (resolutions.length - minZoom > sourceResolutions.length) {\n          minZoom = resolutions.length - sourceResolutions.length;\n        }\n        const resolutionFactor =\n          resolutions[resolutions.length - 1] /\n          sourceResolutions[sourceResolutions.length - 1];\n        this.resolutionFactors_[sourceIndex] = resolutionFactor;\n        const scaledSourceResolutions = sourceResolutions.map(\n          (resolution) => (resolution *= resolutionFactor),\n        );\n        const message = `Resolution mismatch for source ${sourceIndex}, got [${scaledSourceResolutions}] but expected [${resolutions}]`;\n        assertEqual(\n          resolutions.slice(minZoom, resolutions.length),\n          scaledSourceResolutions,\n          0.02,\n          message,\n          this.viewRejector,\n        );\n      }\n\n      if (!commonRenderTileSizes) {\n        commonRenderTileSizes = renderTileSizes;\n      } else {\n        assertEqual(\n          commonRenderTileSizes.slice(minZoom, commonRenderTileSizes.length),\n          renderTileSizes,\n          0.01,\n          `Tile size mismatch for source ${sourceIndex}`,\n          this.viewRejector,\n        );\n      }\n\n      if (!commonSourceTileSizes) {\n        commonSourceTileSizes = sourceTileSizes;\n      } else {\n        assertEqual(\n          commonSourceTileSizes.slice(minZoom, commonSourceTileSizes.length),\n          sourceTileSizes,\n          0,\n          `Tile size mismatch for source ${sourceIndex}`,\n          this.viewRejector,\n        );\n      }\n\n      this.sourceImagery_[sourceIndex] = images.reverse();\n      this.sourceMasks_[sourceIndex] = masks.reverse();\n    }\n\n    for (let i = 0, ii = this.sourceImagery_.length; i < ii; ++i) {\n      const sourceImagery = this.sourceImagery_[i];\n      while (sourceImagery.length < resolutions.length) {\n        sourceImagery.unshift(undefined);\n      }\n    }\n\n    if (!this.getProjection()) {\n      this.determineProjection(sources);\n    }\n\n    this.samplesPerPixel_ = samplesPerPixel;\n    this.nodataValues_ = nodataValues;\n    this.metadata_ = metadata;\n\n    // decide if we need to add an alpha band to handle nodata\n    outer: for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n      // option 1: source is configured with a nodata value\n      if (this.sourceInfo_[sourceIndex].nodata !== undefined) {\n        this.addAlpha_ = true;\n        break;\n      }\n      if (this.sourceMasks_[sourceIndex].length) {\n        this.addAlpha_ = true;\n        break;\n      }\n\n      const values = nodataValues[sourceIndex];\n\n      // option 2: check image metadata for limited bands\n      const bands = this.sourceInfo_[sourceIndex].bands;\n      if (bands) {\n        for (let i = 0; i < bands.length; ++i) {\n          if (values[bands[i] - 1] !== null) {\n            this.addAlpha_ = true;\n            break outer;\n          }\n        }\n        continue;\n      }\n\n      // option 3: check image metadata for all bands\n      for (let imageIndex = 0; imageIndex < values.length; ++imageIndex) {\n        if (values[imageIndex] !== null) {\n          this.addAlpha_ = true;\n          break outer;\n        }\n      }\n    }\n\n    let bandCount = this.addAlpha_ ? 1 : 0;\n    for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n      bandCount += samplesPerPixel[sourceIndex];\n    }\n    this.bandCount = bandCount;\n\n    const tileGrid = new TileGrid({\n      extent: extent,\n      minZoom: minZoom,\n      origin: origin,\n      resolutions: resolutions,\n      tileSizes: commonRenderTileSizes,\n    });\n\n    this.tileGrid = tileGrid;\n    this.setTileSizes(commonSourceTileSizes);\n\n    this.setLoader(this.loadTile_.bind(this));\n    this.setState('ready');\n\n    const zoom = 1;\n    if (resolutions.length === 2) {\n      resolutions = [resolutions[0], resolutions[1], resolutions[1] / 2];\n    } else if (resolutions.length === 1) {\n      resolutions = [resolutions[0] * 2, resolutions[0], resolutions[0] / 2];\n    }\n\n    this.viewResolver({\n      showFullExtent: true,\n      projection: this.projection,\n      resolutions: resolutions,\n      center: toUserCoordinate(getCenter(extent), this.projection),\n      extent: toUserExtent(extent, this.projection),\n      zoom: zoom,\n    });\n  }\n\n  /**\n   * @param {number} z The z tile index.\n   * @param {number} x The x tile index.\n   * @param {number} y The y tile index.\n   * @return {Promise} The composed tile data.\n   * @private\n   */\n  loadTile_(z, x, y) {\n    const sourceTileSize = this.getTileSize(z);\n    const sourceCount = this.sourceImagery_.length;\n    const requests = new Array(sourceCount * 2);\n    const nodataValues = this.nodataValues_;\n    const sourceInfo = this.sourceInfo_;\n    const pool = getWorkerPool();\n    for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n      const source = sourceInfo[sourceIndex];\n      const resolutionFactor = this.resolutionFactors_[sourceIndex];\n      const pixelBounds = [\n        Math.round(x * (sourceTileSize[0] * resolutionFactor)),\n        Math.round(y * (sourceTileSize[1] * resolutionFactor)),\n        Math.round((x + 1) * (sourceTileSize[0] * resolutionFactor)),\n        Math.round((y + 1) * (sourceTileSize[1] * resolutionFactor)),\n      ];\n      const image = this.sourceImagery_[sourceIndex][z];\n      let samples;\n      if (source.bands) {\n        samples = source.bands.map(function (bandNumber) {\n          return bandNumber - 1;\n        });\n      }\n\n      /** @type {number|Array<number>} */\n      let fillValue;\n      if ('nodata' in source && source.nodata !== null) {\n        fillValue = source.nodata;\n      } else {\n        if (!samples) {\n          fillValue = nodataValues[sourceIndex];\n        } else {\n          fillValue = samples.map(function (sampleIndex) {\n            return nodataValues[sourceIndex][sampleIndex];\n          });\n        }\n      }\n\n      const readOptions = {\n        window: pixelBounds,\n        width: sourceTileSize[0],\n        height: sourceTileSize[1],\n        samples: samples,\n        fillValue: fillValue,\n        pool: pool,\n        interleave: false,\n      };\n      if (readRGB(this.convertToRGB_, image)) {\n        requests[sourceIndex] = image.readRGB(readOptions);\n      } else {\n        requests[sourceIndex] = image.readRasters(readOptions);\n      }\n\n      // requests after `sourceCount` are for mask data (if any)\n      const maskIndex = sourceCount + sourceIndex;\n      const mask = this.sourceMasks_[sourceIndex][z];\n      if (!mask) {\n        requests[maskIndex] = Promise.resolve(null);\n        continue;\n      }\n\n      requests[maskIndex] = mask.readRasters({\n        window: pixelBounds,\n        width: sourceTileSize[0],\n        height: sourceTileSize[1],\n        samples: [0],\n        pool: pool,\n        interleave: false,\n      });\n    }\n\n    return Promise.all(requests)\n      .then(this.composeTile_.bind(this, sourceTileSize))\n      .catch(function (error) {\n        logError(error);\n        throw error;\n      });\n  }\n\n  /**\n   * @param {import(\"../size.js\").Size} sourceTileSize The source tile size.\n   * @param {Array} sourceSamples The source samples.\n   * @return {import(\"../DataTile.js\").Data} The composed tile data.\n   * @private\n   */\n  composeTile_(sourceTileSize, sourceSamples) {\n    const metadata = this.metadata_;\n    const sourceInfo = this.sourceInfo_;\n    const sourceCount = this.sourceImagery_.length;\n    const bandCount = this.bandCount;\n    const samplesPerPixel = this.samplesPerPixel_;\n    const nodataValues = this.nodataValues_;\n    const normalize = this.normalize_;\n    const addAlpha = this.addAlpha_;\n\n    const pixelCount = sourceTileSize[0] * sourceTileSize[1];\n    const dataLength = pixelCount * bandCount;\n\n    /** @type {Uint8Array|Float32Array} */\n    let data;\n    if (normalize) {\n      data = new Uint8Array(dataLength);\n    } else {\n      data = new Float32Array(dataLength);\n    }\n\n    let dataIndex = 0;\n    for (let pixelIndex = 0; pixelIndex < pixelCount; ++pixelIndex) {\n      let transparent = addAlpha;\n      for (let sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {\n        const source = sourceInfo[sourceIndex];\n\n        let min = source.min;\n        let max = source.max;\n        let gain, bias;\n        if (normalize) {\n          const stats = metadata[sourceIndex][0];\n          if (min === undefined) {\n            if (stats && STATISTICS_MINIMUM in stats) {\n              min = parseFloat(stats[STATISTICS_MINIMUM]);\n            } else {\n              min = getMinForDataType(sourceSamples[sourceIndex][0]);\n            }\n          }\n          if (max === undefined) {\n            if (stats && STATISTICS_MAXIMUM in stats) {\n              max = parseFloat(stats[STATISTICS_MAXIMUM]);\n            } else {\n              max = getMaxForDataType(sourceSamples[sourceIndex][0]);\n            }\n          }\n\n          gain = 255 / (max - min);\n          bias = -min * gain;\n        }\n\n        for (\n          let sampleIndex = 0;\n          sampleIndex < samplesPerPixel[sourceIndex];\n          ++sampleIndex\n        ) {\n          const sourceValue =\n            sourceSamples[sourceIndex][sampleIndex][pixelIndex];\n\n          let value;\n          if (normalize) {\n            value = clamp(gain * sourceValue + bias, 0, 255);\n          } else {\n            value = sourceValue;\n          }\n\n          if (!addAlpha) {\n            data[dataIndex] = value;\n          } else {\n            let nodata = source.nodata;\n            if (nodata === undefined) {\n              let bandIndex;\n              if (source.bands) {\n                bandIndex = source.bands[sampleIndex] - 1;\n              } else {\n                bandIndex = sampleIndex;\n              }\n              nodata = nodataValues[sourceIndex][bandIndex];\n            }\n\n            const nodataIsNaN = isNaN(nodata);\n            if (\n              (!nodataIsNaN && sourceValue !== nodata) ||\n              (nodataIsNaN && !isNaN(sourceValue))\n            ) {\n              transparent = false;\n              data[dataIndex] = value;\n            }\n          }\n          dataIndex++;\n        }\n        if (!transparent) {\n          const maskIndex = sourceCount + sourceIndex;\n          const mask = sourceSamples[maskIndex];\n          if (mask && !mask[0][pixelIndex]) {\n            transparent = true;\n          }\n        }\n      }\n      if (addAlpha) {\n        if (!transparent) {\n          data[dataIndex] = 255;\n        }\n        dataIndex++;\n      }\n    }\n\n    return data;\n  }\n}\n\n/**\n * Get a promise for view properties based on the source.  Use the result of this function\n * as the `view` option in a map constructor.\n *\n *     const source = new GeoTIFF(options);\n *\n *     const map = new Map({\n *       target: 'map',\n *       layers: [\n *         new TileLayer({\n *           source: source,\n *         }),\n *       ],\n *       view: source.getView(),\n *     });\n *\n * @function\n * @return {Promise<import(\"../View.js\").ViewOptions>} A promise for view-related properties.\n * @api\n *\n */\nGeoTIFFSource.prototype.getView;\n\nexport default GeoTIFFSource;\n","export const fieldTagNames = {\n  // TIFF Baseline\n  0x013B: 'Artist',\n  0x0102: 'BitsPerSample',\n  0x0109: 'CellLength',\n  0x0108: 'CellWidth',\n  0x0140: 'ColorMap',\n  0x0103: 'Compression',\n  0x8298: 'Copyright',\n  0x0132: 'DateTime',\n  0x0152: 'ExtraSamples',\n  0x010A: 'FillOrder',\n  0x0121: 'FreeByteCounts',\n  0x0120: 'FreeOffsets',\n  0x0123: 'GrayResponseCurve',\n  0x0122: 'GrayResponseUnit',\n  0x013C: 'HostComputer',\n  0x010E: 'ImageDescription',\n  0x0101: 'ImageLength',\n  0x0100: 'ImageWidth',\n  0x010F: 'Make',\n  0x0119: 'MaxSampleValue',\n  0x0118: 'MinSampleValue',\n  0x0110: 'Model',\n  0x00FE: 'NewSubfileType',\n  0x0112: 'Orientation',\n  0x0106: 'PhotometricInterpretation',\n  0x011C: 'PlanarConfiguration',\n  0x0128: 'ResolutionUnit',\n  0x0116: 'RowsPerStrip',\n  0x0115: 'SamplesPerPixel',\n  0x0131: 'Software',\n  0x0117: 'StripByteCounts',\n  0x0111: 'StripOffsets',\n  0x00FF: 'SubfileType',\n  0x0107: 'Threshholding',\n  0x011A: 'XResolution',\n  0x011B: 'YResolution',\n\n  // TIFF Extended\n  0x0146: 'BadFaxLines',\n  0x0147: 'CleanFaxData',\n  0x0157: 'ClipPath',\n  0x0148: 'ConsecutiveBadFaxLines',\n  0x01B1: 'Decode',\n  0x01B2: 'DefaultImageColor',\n  0x010D: 'DocumentName',\n  0x0150: 'DotRange',\n  0x0141: 'HalftoneHints',\n  0x015A: 'Indexed',\n  0x015B: 'JPEGTables',\n  0x011D: 'PageName',\n  0x0129: 'PageNumber',\n  0x013D: 'Predictor',\n  0x013F: 'PrimaryChromaticities',\n  0x0214: 'ReferenceBlackWhite',\n  0x0153: 'SampleFormat',\n  0x0154: 'SMinSampleValue',\n  0x0155: 'SMaxSampleValue',\n  0x022F: 'StripRowCounts',\n  0x014A: 'SubIFDs',\n  0x0124: 'T4Options',\n  0x0125: 'T6Options',\n  0x0145: 'TileByteCounts',\n  0x0143: 'TileLength',\n  0x0144: 'TileOffsets',\n  0x0142: 'TileWidth',\n  0x012D: 'TransferFunction',\n  0x013E: 'WhitePoint',\n  0x0158: 'XClipPathUnits',\n  0x011E: 'XPosition',\n  0x0211: 'YCbCrCoefficients',\n  0x0213: 'YCbCrPositioning',\n  0x0212: 'YCbCrSubSampling',\n  0x0159: 'YClipPathUnits',\n  0x011F: 'YPosition',\n\n  // EXIF\n  0x9202: 'ApertureValue',\n  0xA001: 'ColorSpace',\n  0x9004: 'DateTimeDigitized',\n  0x9003: 'DateTimeOriginal',\n  0x8769: 'Exif IFD',\n  0x9000: 'ExifVersion',\n  0x829A: 'ExposureTime',\n  0xA300: 'FileSource',\n  0x9209: 'Flash',\n  0xA000: 'FlashpixVersion',\n  0x829D: 'FNumber',\n  0xA420: 'ImageUniqueID',\n  0x9208: 'LightSource',\n  0x927C: 'MakerNote',\n  0x9201: 'ShutterSpeedValue',\n  0x9286: 'UserComment',\n\n  // IPTC\n  0x83BB: 'IPTC',\n\n  // ICC\n  0x8773: 'ICC Profile',\n\n  // XMP\n  0x02BC: 'XMP',\n\n  // GDAL\n  0xA480: 'GDAL_METADATA',\n  0xA481: 'GDAL_NODATA',\n\n  // Photoshop\n  0x8649: 'Photoshop',\n\n  // GeoTiff\n  0x830E: 'ModelPixelScale',\n  0x8482: 'ModelTiepoint',\n  0x85D8: 'ModelTransformation',\n  0x87AF: 'GeoKeyDirectory',\n  0x87B0: 'GeoDoubleParams',\n  0x87B1: 'GeoAsciiParams',\n\n  // LERC\n  0xC5F2: 'LercParameters',\n};\n\nexport const fieldTags = {};\nfor (const key in fieldTagNames) {\n  if (fieldTagNames.hasOwnProperty(key)) {\n    fieldTags[fieldTagNames[key]] = parseInt(key, 10);\n  }\n}\n\nexport const fieldTagTypes = {\n  256: 'SHORT',\n  257: 'SHORT',\n  258: 'SHORT',\n  259: 'SHORT',\n  262: 'SHORT',\n  273: 'LONG',\n  274: 'SHORT',\n  277: 'SHORT',\n  278: 'LONG',\n  279: 'LONG',\n  282: 'RATIONAL',\n  283: 'RATIONAL',\n  284: 'SHORT',\n  286: 'SHORT',\n  287: 'RATIONAL',\n  296: 'SHORT',\n  297: 'SHORT',\n  305: 'ASCII',\n  306: 'ASCII',\n  338: 'SHORT',\n  339: 'SHORT',\n  513: 'LONG',\n  514: 'LONG',\n  1024: 'SHORT',\n  1025: 'SHORT',\n  2048: 'SHORT',\n  2049: 'ASCII',\n  3072: 'SHORT',\n  3073: 'ASCII',\n  33550: 'DOUBLE',\n  33922: 'DOUBLE',\n  34264: 'DOUBLE',\n  34665: 'LONG',\n  34735: 'SHORT',\n  34736: 'DOUBLE',\n  34737: 'ASCII',\n  42113: 'ASCII',\n};\n\nexport const arrayFields = [\n  fieldTags.BitsPerSample,\n  fieldTags.ExtraSamples,\n  fieldTags.SampleFormat,\n  fieldTags.StripByteCounts,\n  fieldTags.StripOffsets,\n  fieldTags.StripRowCounts,\n  fieldTags.TileByteCounts,\n  fieldTags.TileOffsets,\n  fieldTags.SubIFDs,\n];\n\nexport const fieldTypeNames = {\n  0x0001: 'BYTE',\n  0x0002: 'ASCII',\n  0x0003: 'SHORT',\n  0x0004: 'LONG',\n  0x0005: 'RATIONAL',\n  0x0006: 'SBYTE',\n  0x0007: 'UNDEFINED',\n  0x0008: 'SSHORT',\n  0x0009: 'SLONG',\n  0x000A: 'SRATIONAL',\n  0x000B: 'FLOAT',\n  0x000C: 'DOUBLE',\n  // IFD offset, suggested by https://owl.phy.queensu.ca/~phil/exiftool/standards.html\n  0x000D: 'IFD',\n  // introduced by BigTIFF\n  0x0010: 'LONG8',\n  0x0011: 'SLONG8',\n  0x0012: 'IFD8',\n};\n\nexport const fieldTypes = {};\nfor (const key in fieldTypeNames) {\n  if (fieldTypeNames.hasOwnProperty(key)) {\n    fieldTypes[fieldTypeNames[key]] = parseInt(key, 10);\n  }\n}\n\nexport const photometricInterpretations = {\n  WhiteIsZero: 0,\n  BlackIsZero: 1,\n  RGB: 2,\n  Palette: 3,\n  TransparencyMask: 4,\n  CMYK: 5,\n  YCbCr: 6,\n\n  CIELab: 8,\n  ICCLab: 9,\n};\n\nexport const ExtraSamplesValues = {\n  Unspecified: 0,\n  Assocalpha: 1,\n  Unassalpha: 2,\n};\n\nexport const LercParameters = {\n  Version: 0,\n  AddCompression: 1,\n};\n\nexport const LercAddCompression = {\n  None: 0,\n  Deflate: 1,\n  Zstandard: 2,\n};\n\nexport const geoKeyNames = {\n  1024: 'GTModelTypeGeoKey',\n  1025: 'GTRasterTypeGeoKey',\n  1026: 'GTCitationGeoKey',\n  2048: 'GeographicTypeGeoKey',\n  2049: 'GeogCitationGeoKey',\n  2050: 'GeogGeodeticDatumGeoKey',\n  2051: 'GeogPrimeMeridianGeoKey',\n  2052: 'GeogLinearUnitsGeoKey',\n  2053: 'GeogLinearUnitSizeGeoKey',\n  2054: 'GeogAngularUnitsGeoKey',\n  2055: 'GeogAngularUnitSizeGeoKey',\n  2056: 'GeogEllipsoidGeoKey',\n  2057: 'GeogSemiMajorAxisGeoKey',\n  2058: 'GeogSemiMinorAxisGeoKey',\n  2059: 'GeogInvFlatteningGeoKey',\n  2060: 'GeogAzimuthUnitsGeoKey',\n  2061: 'GeogPrimeMeridianLongGeoKey',\n  2062: 'GeogTOWGS84GeoKey',\n  3072: 'ProjectedCSTypeGeoKey',\n  3073: 'PCSCitationGeoKey',\n  3074: 'ProjectionGeoKey',\n  3075: 'ProjCoordTransGeoKey',\n  3076: 'ProjLinearUnitsGeoKey',\n  3077: 'ProjLinearUnitSizeGeoKey',\n  3078: 'ProjStdParallel1GeoKey',\n  3079: 'ProjStdParallel2GeoKey',\n  3080: 'ProjNatOriginLongGeoKey',\n  3081: 'ProjNatOriginLatGeoKey',\n  3082: 'ProjFalseEastingGeoKey',\n  3083: 'ProjFalseNorthingGeoKey',\n  3084: 'ProjFalseOriginLongGeoKey',\n  3085: 'ProjFalseOriginLatGeoKey',\n  3086: 'ProjFalseOriginEastingGeoKey',\n  3087: 'ProjFalseOriginNorthingGeoKey',\n  3088: 'ProjCenterLongGeoKey',\n  3089: 'ProjCenterLatGeoKey',\n  3090: 'ProjCenterEastingGeoKey',\n  3091: 'ProjCenterNorthingGeoKey',\n  3092: 'ProjScaleAtNatOriginGeoKey',\n  3093: 'ProjScaleAtCenterGeoKey',\n  3094: 'ProjAzimuthAngleGeoKey',\n  3095: 'ProjStraightVertPoleLongGeoKey',\n  3096: 'ProjRectifiedGridAngleGeoKey',\n  4096: 'VerticalCSTypeGeoKey',\n  4097: 'VerticalCitationGeoKey',\n  4098: 'VerticalDatumGeoKey',\n  4099: 'VerticalUnitsGeoKey',\n};\n\nexport const geoKeys = {};\nfor (const key in geoKeyNames) {\n  if (geoKeyNames.hasOwnProperty(key)) {\n    geoKeys[geoKeyNames[key]] = parseInt(key, 10);\n  }\n}\n"],"names":["appendParams","uri","params","keyParams","Object","keys","forEach","k","undefined","push","encodeURIComponent","qs","join","replace","includes","WMTSTileGrid","TileGrid","constructor","options","super","extent","origin","origins","resolutions","tileSize","tileSizes","sizes","this","matrixIds_","matrixIds","getMatrixId","z","getMatrixIds","createFromCapabilitiesMatrixSet","matrixSet","matrixLimits","supportedCRSPropName","matrixIdsPropName","identifierPropName","scaleDenominatorPropName","topLeftCornerPropName","tileWidthPropName","tileHeightPropName","code","projection","get","metersPerUnit","getMetersPerUnit","switchOriginXY","getAxisOrientation","substr","sort","a","b","elt","matrixAvailable","length","find","elt_ml","resolution","tileWidth","tileHeight","TileImage","requestEncoding","tileGrid","urls","url","attributions","attributionsCollapsible","cacheSize","crossOrigin","interpolate","reprojectionErrorThreshold","tileClass","tileLoadFunction","tilePixelRatio","wrapX","transition","zDirection","version_","version","format_","format","dimensions_","dimensions","layer_","layer","matrixSet_","style_","style","requestEncoding_","setKey","getKeyForDimensions_","tileUrlFunction","map","createFromWMTSTemplate","bind","setUrls","key","setTileUrlFunction","getDimensions","getFormat","getLayer","getMatrixSet","getRequestEncoding","getStyle","getVersion","res","slice","updateDimensions","assign","template","context","m","p","toLowerCase","tileCoord","pixelRatio","localContext","optionsFromCapabilities","wmtsCap","config","layers","l","tileMatrixSets","idx","findIndex","tileMatrixSet","el","supportedCRS","proj1","proj2","equivalent","index","array","value","matrixSets","matrixSetObj","projConfig","switchXY","matrix","TileMatrix","selectedMatrixLimit","MinTileCol","MinTileRow","MaxTileCol","MatrixWidth","MaxTileRow","MatrixHeight","tileMatrixValue","Identifier","ScaleDenominator","TopLeftCorner","tileSpanX","TileWidth","tileSpanY","TileHeight","matrixSetExtent","wgs84BoundingBox","wgs84ProjectionExtent","getExtent","wgs84MatrixSetExtent","transformExtent","gets","i","ii","constraint","element","encodings","expressionToGlsl","compilationContext","expectedType","parsingContext","parseStyle","bandCount","vertexShader","TEXTURE_COORD","TILE_TRANSFORM","TEXTURE_PIXEL_WIDTH","TEXTURE_PIXEL_HEIGHT","TEXTURE_RESOLUTION","TEXTURE_ORIGIN_X","TEXTURE_ORIGIN_Y","DEPTH","inFragmentShader","pipeline","color","contrast","exposure","saturation","gamma","brightness","uniforms","numVariables","variables","Error","variable","name","uniformName","uniformDeclarations","textureCount","Math","ceil","TILE_TEXTURE_ARRAY","paletteTextures","functionDefintions","functions","fragmentShader","RENDER_EXTENT","TRANSITION_ALPHA","RESOLUTION","ZOOM","WebGLTileLayer","BaseTile","sources_","sources","renderedSource_","renderedResolution_","NaN","cacheSize_","styleVariables_","addChangeListener","SOURCE","handleSourceUpdate_","getSources","source","getSource","getRenderSource","getSourceState","getState","hasRenderer","getRenderer","clearCache","setStyle","getSourceBandCount_","max","Number","MAX_SAFE_INTEGER","createRenderer","parsedStyle","renderSources","frameState","layerRenderer","canvas","prepareFrame","renderFrame","render","target","rendered","viewState","ready","sourceState","onChange","removeEventListener","changed","addEventListener","renderComplete","altSources","filter","renderer","reset","updateStyleVariables","prototype","dispose","DataTileSource","Tile","maxResolution","maxZoom","minZoom","opaque","state","gutter_","gutter","tileSize_","tileSizes_","tileLoadingKeys_","loader_","loader","handleTileChange_","tileGridForProjection_","tileCacheForProjection_","setTileSizes","getTileSize","getTileGrid","getGutterForProjection","thisProj","getProjection","setLoader","getReprojTile_","x","y","targetProj","sourceProj","cache","getTileCacheForProjection","tileCoordKey","containsKey","tile","getKey","reprojTilePixelRatio","apply","getResolutions","r","textureSize","sourceTileGrid","getTileGridForProjection","targetTileGrid","wrappedTileCoord","getTileCoordForTileUrlFunction","getTileFunction","getTile","tileOptions","newTile","sourceProjection","size","tileCache","sourceLoader","DataTile","EventType","CHANGE","set","event","uid","tileState","type","TileState","LOADING","TileEventType","TILELOADSTART","ERROR","TILELOADERROR","LOADED","TILELOADEND","dispatchEvent","projKey","setTileGridForProjection","tilegrid","proj","TileCache","expireCache","usedTiles","usedTileCache","id","clear","registry","Map","addDecoder","cases","importFn","Array","isArray","c","async","getDecoder","fileDirectory","Compression","Decoder","then","default","zstd","init","defaultPoolSize","navigator","hardwareConcurrency","Pool","createWorker","workers","_awaitingDecoder","messageId","Promise","resolve","module","create","worker","idle","decode","buffer","decoder","candidate","floor","random","onMessage","e","data","decoded","postMessage","destroy","terminate","fromWhiteIsZero","raster","width","height","rgbRaster","Uint8Array","j","fromBlackIsZero","fromPalette","colorMap","greenOffset","blueOffset","mapIndex","fromCMYK","cmykRaster","fromYCbCr","yCbCrRaster","Uint8ClampedArray","cb","cr","Xn","Yn","Zn","fromCIELab","cieLabRaster","L","a_","b_","g","min","copyNewSize","samplesPerPixel","getPrototypeOf","resampleNearest","valueArrays","inWidth","inHeight","outWidth","outHeight","relX","relY","newArray","cy","round","cx","lerp","v0","v1","t","resampleBilinear","rawY","yl","yh","rawX","tx","xl","xh","ll","hl","lh","hh","resample","method","resampleNearestInterleaved","valueArray","samples","resampleBilinearInterleaved","resampleInterleaved","sum","start","end","s","arrayForType","bitsPerSample","Uint16Array","Uint32Array","Int8Array","Int16Array","Int32Array","Float32Array","Float64Array","needsNormalization","normalizeArray","inBuffer","planarConfiguration","view","DataView","outSize","samplesToTransfer","outArray","bitMask","parseInt","repeat","pixelBitSkip","bitsPerLine","lineBitOffset","pixelBitOffset","bitOffset","outIndex","byteOffset","innerBitOffset","getUint8","getUint16","raw","getUint32","GeoTIFFImage","geoKeys","dataView","littleEndian","tiles","isTiled","StripOffsets","PlanarConfiguration","getFileDirectory","getGeoKeys","getWidth","ImageWidth","getHeight","ImageLength","getSamplesPerPixel","SamplesPerPixel","getTileWidth","getTileHeight","TileLength","RowsPerStrip","getBlockWidth","getBlockHeight","getBytesPerPixel","bytes","BitsPerSample","getSampleByteSize","RangeError","getReaderForSample","sampleIndex","SampleFormat","getInt8","getInt16","getInt32","offset","getFloat32","getFloat64","getSampleFormat","getBitsPerSample","getArrayForSample","getTileOrStrip","sample","poolOrDecoder","signal","numTilesPerRow","numTilesPerCol","byteCount","TileOffsets","TileByteCounts","StripByteCounts","fetch","request","sampleFormat","_readRaster","imageWindow","interleave","resampleMethod","imageWidth","imageHeight","minXTile","maxXTile","minYTile","maxYTile","windowWidth","bytesPerPixel","srcSampleOffsets","sampleReaders","promises","yTile","xTile","getPromise","si","promise","blockHeight","firstLine","firstCol","lastLine","lastCol","reader","ymax","xmax","pixelOffset","call","windowCoordinate","all","resampled","readRasters","window","wnd","pool","fillValue","imageWindowWidth","imageWindowHeight","numPixels","reject","fill","result","readRGB","enableAlpha","pi","PhotometricInterpretation","RGB","ExtraSamples","Unspecified","WhiteIsZero","BlackIsZero","Palette","CMYK","YCbCr","CIELab","subOptions","ColorMap","red","green","blue","getTiePoints","ModelTiepoint","tiePoints","getGDALMetadata","metadata","GDAL_METADATA","string","items","item","inner","getGDALNoData","GDAL_NODATA","substring","getOrigin","modelTransformation","ModelTransformation","getResolution","referenceImage","modelPixelScale","ModelPixelScale","sqrt","refResX","refResY","refResZ","pixelIsArea","GTRasterTypeGeoKey","getBoundingBox","d","f","h","corners","projected","I","J","xs","pt","ys","x1","y1","x2","y2","DataView64","arrayBuffer","_dataView","getUint64","left","right","combined","isSafeInteger","getInt64","isNegative","carrying","byte","getFloat16","DataSlice","sliceOffset","bigTiff","_sliceOffset","_littleEndian","_bigTiff","sliceTop","byteLength","covers","readUint8","readInt8","readUint16","readInt16","readUint32","readInt32","readFloat32","readFloat64","readUint64","readInt64","readOffset","CRLFCRLF","itemsToObject","fromEntries","obj","parseHeaders","text","split","line","kv","str","trim","parseContentType","rawContentType","rawParams","paramsItems","param","parseContentRange","rawContentRange","total","match","parseByteRanges","responseArrayBuffer","boundary","TextDecoder","out","startBoundary","endBoundary","startsWith","innerText","endOfHeaders","indexOf","headers","startOfData","fileSize","BaseSource","slices","fetchSlice","close","wait","milliseconds","setTimeout","zip","A","from","B","AbortError","captureStackTrace","CustomAggregateError","errors","message","AggregateError","Block","top","BlockGroup","blockIds","BlockedSource","blockSize","blockCache","maxSize","onEviction","blockId","block","evictedBlocks","blockRequests","blockIdsToFetch","Set","abortedBlockIds","missingBlockIds","allBlockIds","firstBlockOffset","current","has","add","fetchBlocks","missingRequests","allSettled","abortedBlockRequests","aborted","blocks","failedBlocks","requiredBlocks","readSliceData","groups","groupBlocks","groupRequests","groupIndex","group","response","blockOffset","o","delete","err","sortedBlockIds","lastBlockId","blockIdLow","blockIdHigh","sliceData","ArrayBuffer","sliceView","delta","topDelta","usedBlockLength","blockInnerOffset","rangeInnerOffset","blockView","BaseResponse","ok","status","getHeader","headerName","getData","BaseClient","FetchResponse","FetchClient","credentials","XHRResponse","xhr","getResponseHeader","XHRClient","constructRequest","XMLHttpRequest","open","responseType","entries","setRequestHeader","onload","onerror","onabort","send","abort","HttpResponse","dataPromise","statusCode","HttpClient","parsedUrl","httpApi","protocol","resolveData","chunks","on","chunk","Buffer","concat","RemoteSource","client","maxRanges","allowFullFile","_fileSize","fetchSlices","Range","byteRanges","first","others","maybeWrapInBlockedSource","makeFetchSource","blockOptions","makeXHRSource","makeHttpSource","makeRemoteSource","forceXHR","clientOptions","FileReaderSource","file","blob","FileReader","readAsArrayBuffer","makeFileReaderSource","getFieldTypeLength","fieldType","BYTE","ASCII","SBYTE","UNDEFINED","SHORT","SSHORT","LONG","SLONG","FLOAT","IFD","RATIONAL","SRATIONAL","DOUBLE","LONG8","SLONG8","IFD8","parseGeoKeyDirectory","rawGeoKeyDirectory","GeoKeyDirectory","geoKeyDirectory","location","count","subarray","getValues","dataSlice","values","readMethod","fieldTypeLength","ImageFileDirectory","nextIFDByteOffset","GeoTIFFImageIndexError","GeoTIFFBase","resX","resY","bbox","firstImage","getImage","usedImage","imageCount","getImageCount","imgBBox","oX","oY","rX","rY","usedBBox","allImages","image","SubfileType","subfileType","NewSubfileType","newSubfileType","imgResX","imgResY","imageResX","imageResY","GeoTIFF","firstIFDOffset","ifdRequests","ghostValues","getSlice","fallbackSize","parseFileDirectoryAt","entrySize","offsetSize","numDirEntries","byteSize","entryCount","fieldTag","typeCount","fieldValues","valueOffset","actualOffset","fieldDataSlice","requestIFD","previousIfd","ifd","hasNext","getGhostValues","detectionString","heuristicAreaSize","valuesString","metadataSize","fullString","fromSource","headerData","BOM","TypeError","magicNumber","offsetByteSize","MultiGeoTIFF","mainFile","overviewFiles","imageFiles","fileDirectoriesPerFile","fileDirectoriesPerFileParsing","parseFileDirectoriesPerFile","requests","visited","relativeIndex","imageFile","imageCounts","reduce","ifds","fromUrl","fromBlob","fromUrls","mainUrl","overviewUrls","isMask","preference","interpretation","interpretations","ICCLab","STATISTICS_MAXIMUM","STATISTICS_MINIMUM","defaultTileSize","workerPool","getWorkerPool","_","ProjectedCSTypeGeoKey","units","ProjLinearUnitsGeoKey","Projection","GeographicTypeGeoKey","GeogAngularUnitsGeoKey","getImagesForTIFF","tiff","getImagesForSource","overviews","assertEqual","expected","got","tolerance","rejector","error","abs","getMinForDataType","getMaxForDataType","GeoTIFFSource","sourceInfo_","numSources","sourceOptions_","sourceOptions","sourceImagery_","sourceMasks_","resolutionFactors_","samplesPerPixel_","nodataValues_","metadata_","normalize_","normalize","addAlpha_","error_","convertToRGB_","convertToRGB","self","configure_","catch","setState","getError","determineProjection","firstSource","commonRenderTileSizes","commonSourceTileSizes","nodataValues","sourceCount","sourceIndex","images","masks","sourceExtent","sourceOrigin","sourceTileSizes","renderTileSizes","sourceResolutions","imageIndex","nodataValue","wantedSamples","bands","level","imageResolutions","sourceTileSize","aspectRatio","viewRejector","resolutionFactor","scaledSourceResolutions","reverse","sourceImagery","unshift","outer","nodata","loadTile_","zoom","viewResolver","showFullExtent","center","toUserCoordinate","toUserExtent","sourceInfo","pixelBounds","bandNumber","readOptions","maskIndex","mask","composeTile_","sourceSamples","addAlpha","pixelCount","dataLength","dataIndex","pixelIndex","transparent","gain","bias","stats","parseFloat","sourceValue","bandIndex","nodataIsNaN","isNaN","getView","fieldTagNames","fieldTags","hasOwnProperty","arrayFields","StripRowCounts","SubIFDs","fieldTypeNames","fieldTypes","photometricInterpretations","TransparencyMask","ExtraSamplesValues","Assocalpha","Unassalpha","LercParameters","Version","AddCompression","LercAddCompression","None","Deflate","Zstandard","geoKeyNames"],"sourceRoot":""}
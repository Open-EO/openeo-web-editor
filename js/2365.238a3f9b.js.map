{"version":3,"file":"js/2365.238a3f9b.js","mappings":"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","sources":["webpack://@openeo/web-editor/./node_modules/ol/reproj/DataTile.js","webpack://@openeo/web-editor/./node_modules/ol/reproj/Tile.js","webpack://@openeo/web-editor/./node_modules/ol/reproj/Triangulation.js","webpack://@openeo/web-editor/./node_modules/ol/reproj/common.js"],"sourcesContent":["/**\n * @module ol/reproj/DataTile\n */\nimport {ERROR_THRESHOLD} from './common.js';\n\nimport DataTile, {asArrayLike, asImageLike, toArray} from '../DataTile.js';\nimport EventType from '../events/EventType.js';\nimport TileState from '../TileState.js';\nimport Triangulation from './Triangulation.js';\nimport {\n  calculateSourceExtentResolution,\n  canvasPool,\n  render as renderReprojected,\n} from '../reproj.js';\nimport {clamp} from '../math.js';\nimport {createCanvasContext2D, releaseCanvas} from '../dom.js';\nimport {getArea, getIntersection, getWidth, wrapAndSliceX} from '../extent.js';\nimport {listen, unlistenByKey} from '../events.js';\n\n/**\n * @typedef {function(number, number, number, number) : import(\"../DataTile.js\").default} TileGetter\n */\n\n/**\n * @typedef {Object} TileOffset\n * @property {DataTile} tile Tile.\n * @property {number} offset Offset.\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n * @property {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n * @property {import(\"../proj/Projection.js\").default} targetProj Target projection.\n * @property {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n * @property {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n * @property {import(\"../tilecoord.js\").TileCoord} [wrappedTileCoord] Coordinate of the tile wrapped in X.\n * @property {number} pixelRatio Pixel ratio.\n * @property {number} gutter Gutter of the source tiles.\n * @property {TileGetter} getTileFunction Function returning source tiles (z, x, y, pixelRatio).\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n * @property {number} [errorThreshold] Acceptable reprojection error (in px).\n * @property {number} [transition=250] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected data tile.\n * See {@link module:ol/source/DataTile~DataTileSource}.\n *\n */\nclass ReprojDataTile extends DataTile {\n  /**\n   * @param {Options} options Tile options.\n   */\n  constructor(options) {\n    super({\n      tileCoord: options.tileCoord,\n      loader: () => Promise.resolve(new Uint8Array(4)),\n      interpolate: options.interpolate,\n      transition: options.transition,\n    });\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = options.pixelRatio;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = options.gutter;\n\n    /**\n     * @type {import(\"../DataTile.js\").Data}\n     * @private\n     */\n    this.reprojData_ = null;\n\n    /**\n     * @type {Error}\n     * @private\n     */\n    this.reprojError_ = null;\n\n    /**\n     * @type {import('../size.js').Size}\n     * @private\n     */\n    this.reprojSize_ = undefined;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.sourceTileGrid_ = options.sourceTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.targetTileGrid_ = options.targetTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilecoord.js\").TileCoord}\n     */\n    this.wrappedTileCoord_ = options.wrappedTileCoord || options.tileCoord;\n\n    /**\n     * @private\n     * @type {!Array<TileOffset>}\n     */\n    this.sourceTiles_ = [];\n\n    /**\n     * @private\n     * @type {?Array<import(\"../events.js\").EventsKey>}\n     */\n    this.sourcesListenerKeys_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.sourceZ_ = 0;\n\n    const sourceProj = options.sourceProj;\n    const sourceProjExtent = sourceProj.getExtent();\n    const sourceTileGridExtent = options.sourceTileGrid.getExtent();\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.clipExtent_ = sourceProj.canWrapX()\n      ? sourceTileGridExtent\n        ? getIntersection(sourceProjExtent, sourceTileGridExtent)\n        : sourceProjExtent\n      : sourceTileGridExtent;\n\n    const targetExtent = this.targetTileGrid_.getTileCoordExtent(\n      this.wrappedTileCoord_,\n    );\n    const maxTargetExtent = this.targetTileGrid_.getExtent();\n    let maxSourceExtent = this.sourceTileGrid_.getExtent();\n\n    const limitedTargetExtent = maxTargetExtent\n      ? getIntersection(targetExtent, maxTargetExtent)\n      : targetExtent;\n\n    if (getArea(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n      }\n    }\n\n    const targetResolution = this.targetTileGrid_.getResolution(\n      this.wrappedTileCoord_[0],\n    );\n\n    const targetProj = options.targetProj;\n    const sourceResolution = calculateSourceExtentResolution(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      targetResolution,\n    );\n\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const errorThresholdInPixels =\n      options.errorThreshold !== undefined\n        ? options.errorThreshold\n        : ERROR_THRESHOLD;\n\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n    this.triangulation_ = new Triangulation(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      maxSourceExtent,\n      sourceResolution * errorThresholdInPixels,\n      targetResolution,\n    );\n\n    if (this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    this.sourceZ_ = this.sourceTileGrid_.getZForResolution(sourceResolution);\n    let sourceExtent = this.triangulation_.calculateSourceExtent();\n\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = clamp(\n          sourceExtent[1],\n          maxSourceExtent[1],\n          maxSourceExtent[3],\n        );\n        sourceExtent[3] = clamp(\n          sourceExtent[3],\n          maxSourceExtent[1],\n          maxSourceExtent[3],\n        );\n      } else {\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n\n    if (!getArea(sourceExtent)) {\n      this.state = TileState.EMPTY;\n    } else {\n      let worldWidth = 0;\n      let worldsAway = 0;\n      if (sourceProj.canWrapX()) {\n        worldWidth = getWidth(sourceProjExtent);\n        worldsAway = Math.floor(\n          (sourceExtent[0] - sourceProjExtent[0]) / worldWidth,\n        );\n      }\n\n      const sourceExtents = wrapAndSliceX(\n        sourceExtent.slice(),\n        sourceProj,\n        true,\n      );\n      sourceExtents.forEach((extent) => {\n        const sourceRange = this.sourceTileGrid_.getTileRangeForExtentAndZ(\n          extent,\n          this.sourceZ_,\n        );\n        const getTile = options.getTileFunction;\n        for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n          for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n            const tile = getTile(this.sourceZ_, srcX, srcY, this.pixelRatio_);\n            if (tile) {\n              const offset = worldsAway * worldWidth;\n              this.sourceTiles_.push({tile, offset});\n            }\n          }\n        }\n        ++worldsAway;\n      });\n\n      if (this.sourceTiles_.length === 0) {\n        this.state = TileState.EMPTY;\n      }\n    }\n  }\n\n  /**\n   * Get the tile size.\n   * @return {import('../size.js').Size} Tile size.\n   */\n  getSize() {\n    return this.reprojSize_;\n  }\n\n  /**\n   * Get the data for the tile.\n   * @return {import(\"../DataTile.js\").Data} Tile data.\n   */\n  getData() {\n    return this.reprojData_;\n  }\n\n  /**\n   * Get any loading error.\n   * @return {Error} Loading error.\n   */\n  getError() {\n    return this.reprojError_;\n  }\n\n  /**\n   * @private\n   */\n  reproject_() {\n    const dataSources = [];\n    this.sourceTiles_.forEach((source) => {\n      const tile = source.tile;\n      if (!tile || tile.getState() !== TileState.LOADED) {\n        return;\n      }\n      const size = tile.getSize();\n      const gutter = this.gutter_;\n      /**\n       * @type {import(\"../DataTile.js\").ArrayLike}\n       */\n      let tileData;\n      const arrayData = asArrayLike(tile.getData());\n      if (arrayData) {\n        tileData = arrayData;\n      } else {\n        tileData = toArray(asImageLike(tile.getData()));\n      }\n      const pixelSize = [size[0] + 2 * gutter, size[1] + 2 * gutter];\n      const isFloat = tileData instanceof Float32Array;\n      const pixelCount = pixelSize[0] * pixelSize[1];\n      const DataType = isFloat ? Float32Array : Uint8Array;\n      const tileDataR = new DataType(tileData.buffer);\n      const bytesPerElement = DataType.BYTES_PER_ELEMENT;\n      const bytesPerPixel = (bytesPerElement * tileDataR.length) / pixelCount;\n      const bytesPerRow = tileDataR.byteLength / pixelSize[1];\n      const bandCount = Math.floor(\n        bytesPerRow / bytesPerElement / pixelSize[0],\n      );\n      const packedLength = pixelCount * bandCount;\n      let packedData = tileDataR;\n      if (tileDataR.length !== packedLength) {\n        packedData = new DataType(packedLength);\n        let dataIndex = 0;\n        let rowOffset = 0;\n        const colCount = pixelSize[0] * bandCount;\n        for (let rowIndex = 0; rowIndex < pixelSize[1]; ++rowIndex) {\n          for (let colIndex = 0; colIndex < colCount; ++colIndex) {\n            packedData[dataIndex++] = tileDataR[rowOffset + colIndex];\n          }\n          rowOffset += bytesPerRow / bytesPerElement;\n        }\n      }\n      const extent = this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord);\n      extent[0] += source.offset;\n      extent[2] += source.offset;\n      const clipExtent = this.clipExtent_?.slice();\n      if (clipExtent) {\n        clipExtent[0] += source.offset;\n        clipExtent[2] += source.offset;\n      }\n      dataSources.push({\n        extent: extent,\n        clipExtent: clipExtent,\n        data: new Uint8Array(packedData.buffer),\n        dataType: DataType,\n        bytesPerPixel: bytesPerPixel,\n        pixelSize: pixelSize,\n      });\n    });\n    this.sourceTiles_.length = 0;\n\n    if (dataSources.length === 0) {\n      this.state = TileState.ERROR;\n    } else {\n      const z = this.wrappedTileCoord_[0];\n      const size = this.targetTileGrid_.getTileSize(z);\n      const targetWidth = typeof size === 'number' ? size : size[0];\n      const targetHeight = typeof size === 'number' ? size : size[1];\n      const targetResolution = this.targetTileGrid_.getResolution(z);\n      const sourceResolution = this.sourceTileGrid_.getResolution(\n        this.sourceZ_,\n      );\n\n      const targetExtent = this.targetTileGrid_.getTileCoordExtent(\n        this.wrappedTileCoord_,\n      );\n\n      let dataR, dataU;\n\n      const bytesPerPixel = dataSources[0].bytesPerPixel;\n\n      const reprojs = Math.ceil(bytesPerPixel / 3);\n      for (let reproj = reprojs - 1; reproj >= 0; --reproj) {\n        const sources = [];\n        for (let i = 0, len = dataSources.length; i < len; ++i) {\n          const dataSource = dataSources[i];\n          const buffer = dataSource.data;\n          const pixelSize = dataSource.pixelSize;\n          const width = pixelSize[0];\n          const height = pixelSize[1];\n          const context = createCanvasContext2D(width, height, canvasPool);\n          const imageData = context.createImageData(width, height);\n          const data = imageData.data;\n          let offset = reproj * 3;\n          for (let j = 0, len = data.length; j < len; j += 4) {\n            data[j] = buffer[offset];\n            data[j + 1] = buffer[offset + 1];\n            data[j + 2] = buffer[offset + 2];\n            data[j + 3] = 255;\n            offset += bytesPerPixel;\n          }\n          context.putImageData(imageData, 0, 0);\n          sources.push({\n            extent: dataSource.extent,\n            clipExtent: dataSource.clipExtent,\n            image: context.canvas,\n          });\n        }\n\n        const canvas = renderReprojected(\n          targetWidth,\n          targetHeight,\n          this.pixelRatio_,\n          sourceResolution,\n          this.sourceTileGrid_.getExtent(),\n          targetResolution,\n          targetExtent,\n          this.triangulation_,\n          sources,\n          this.gutter_,\n          false,\n          false,\n          false,\n          //true,\n        );\n\n        for (let i = 0, len = sources.length; i < len; ++i) {\n          const canvas = sources[i].image;\n          const context = canvas.getContext('2d');\n          releaseCanvas(context);\n          canvasPool.push(context.canvas);\n        }\n\n        const context = canvas.getContext('2d');\n        const imageData = context.getImageData(\n          0,\n          0,\n          canvas.width,\n          canvas.height,\n        );\n\n        releaseCanvas(context);\n        canvasPool.push(canvas);\n\n        if (!dataR) {\n          dataU = new Uint8Array(\n            bytesPerPixel * imageData.width * imageData.height,\n          );\n          dataR = new dataSources[0].dataType(dataU.buffer);\n        }\n\n        const data = imageData.data;\n        let offset = reproj * 3;\n        for (let i = 0, len = data.length; i < len; i += 4) {\n          if (data[i + 3] === 255) {\n            dataU[offset] = data[i];\n            dataU[offset + 1] = data[i + 1];\n            dataU[offset + 2] = data[i + 2];\n          } else {\n            dataU[offset] = 0;\n            dataU[offset + 1] = 0;\n            dataU[offset + 2] = 0;\n          }\n          offset += bytesPerPixel;\n        }\n      }\n\n      this.reprojData_ = dataR;\n      this.reprojSize_ = [\n        Math.round(targetWidth * this.pixelRatio_),\n        Math.round(targetHeight * this.pixelRatio_),\n      ];\n      this.state = TileState.LOADED;\n    }\n    this.changed();\n  }\n\n  /**\n   * Load not yet loaded URI.\n   */\n  load() {\n    if (this.state !== TileState.IDLE && this.state !== TileState.ERROR) {\n      return;\n    }\n    this.state = TileState.LOADING;\n    this.changed();\n\n    let leftToLoad = 0;\n\n    this.sourcesListenerKeys_ = [];\n    this.sourceTiles_.forEach(({tile}) => {\n      const state = tile.getState();\n      if (state !== TileState.IDLE && state !== TileState.LOADING) {\n        return;\n      }\n      leftToLoad++;\n\n      const sourceListenKey = listen(\n        tile,\n        EventType.CHANGE,\n        function () {\n          const state = tile.getState();\n          if (\n            state == TileState.LOADED ||\n            state == TileState.ERROR ||\n            state == TileState.EMPTY\n          ) {\n            unlistenByKey(sourceListenKey);\n            leftToLoad--;\n            if (leftToLoad === 0) {\n              this.unlistenSources_();\n              this.reproject_();\n            }\n          }\n        },\n        this,\n      );\n      this.sourcesListenerKeys_.push(sourceListenKey);\n    });\n\n    if (leftToLoad === 0) {\n      setTimeout(this.reproject_.bind(this), 0);\n    } else {\n      this.sourceTiles_.forEach(function ({tile}) {\n        const state = tile.getState();\n        if (state == TileState.IDLE) {\n          tile.load();\n        }\n      });\n    }\n  }\n\n  /**\n   * @private\n   */\n  unlistenSources_() {\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\n    this.sourcesListenerKeys_ = null;\n  }\n}\n\nexport default ReprojDataTile;\n","/**\n * @module ol/reproj/Tile\n */\nimport {ERROR_THRESHOLD} from './common.js';\n\nimport EventType from '../events/EventType.js';\nimport Tile from '../Tile.js';\nimport TileState from '../TileState.js';\nimport Triangulation from './Triangulation.js';\nimport {\n  calculateSourceExtentResolution,\n  canvasPool,\n  render as renderReprojected,\n} from '../reproj.js';\nimport {clamp} from '../math.js';\nimport {getArea, getIntersection, getWidth, wrapAndSliceX} from '../extent.js';\nimport {listen, unlistenByKey} from '../events.js';\nimport {releaseCanvas} from '../dom.js';\n\n/**\n * @typedef {function(number, number, number, number) : (import(\"../ImageTile.js\").default)} FunctionType\n */\n\n/**\n * @typedef {Object} TileOffset\n * @property {import(\"../ImageTile.js\").default} tile Tile.\n * @property {number} offset Offset.\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected tile.\n * See {@link module:ol/source/TileImage~TileImage}.\n *\n */\nclass ReprojTile extends Tile {\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n   * @param {import(\"../tilecoord.js\").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {number} gutter Gutter of the source tiles.\n   * @param {FunctionType} getTileFunction\n   *     Function returning source tiles (z, x, y, pixelRatio).\n   * @param {number} [errorThreshold] Acceptable reprojection error (in px).\n   * @param {boolean} [renderEdges] Render reprojection edges.\n   * @param {import(\"../Tile.js\").Options} [options] Tile options.\n   */\n  constructor(\n    sourceProj,\n    sourceTileGrid,\n    targetProj,\n    targetTileGrid,\n    tileCoord,\n    wrappedTileCoord,\n    pixelRatio,\n    gutter,\n    getTileFunction,\n    errorThreshold,\n    renderEdges,\n    options,\n  ) {\n    super(tileCoord, TileState.IDLE, options);\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.renderEdges_ = renderEdges !== undefined ? renderEdges : false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = pixelRatio;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = gutter;\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.sourceTileGrid_ = sourceTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.targetTileGrid_ = targetTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilecoord.js\").TileCoord}\n     */\n    this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\n\n    /**\n     * @private\n     * @type {!Array<TileOffset>}\n     */\n    this.sourceTiles_ = [];\n\n    /**\n     * @private\n     * @type {?Array<import(\"../events.js\").EventsKey>}\n     */\n    this.sourcesListenerKeys_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.sourceZ_ = 0;\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.clipExtent_ = sourceProj.canWrapX()\n      ? sourceProj.getExtent()\n      : undefined;\n\n    const targetExtent = targetTileGrid.getTileCoordExtent(\n      this.wrappedTileCoord_,\n    );\n    const maxTargetExtent = this.targetTileGrid_.getExtent();\n    let maxSourceExtent = this.sourceTileGrid_.getExtent();\n\n    const limitedTargetExtent = maxTargetExtent\n      ? getIntersection(targetExtent, maxTargetExtent)\n      : targetExtent;\n\n    if (getArea(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const sourceProjExtent = sourceProj.getExtent();\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n      }\n    }\n\n    const targetResolution = targetTileGrid.getResolution(\n      this.wrappedTileCoord_[0],\n    );\n\n    const sourceResolution = calculateSourceExtentResolution(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      targetResolution,\n    );\n\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const errorThresholdInPixels =\n      errorThreshold !== undefined ? errorThreshold : ERROR_THRESHOLD;\n\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n    this.triangulation_ = new Triangulation(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      maxSourceExtent,\n      sourceResolution * errorThresholdInPixels,\n      targetResolution,\n    );\n\n    if (this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\n    let sourceExtent = this.triangulation_.calculateSourceExtent();\n\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = clamp(\n          sourceExtent[1],\n          maxSourceExtent[1],\n          maxSourceExtent[3],\n        );\n        sourceExtent[3] = clamp(\n          sourceExtent[3],\n          maxSourceExtent[1],\n          maxSourceExtent[3],\n        );\n      } else {\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n\n    if (!getArea(sourceExtent)) {\n      this.state = TileState.EMPTY;\n    } else {\n      let worldWidth = 0;\n      let worldsAway = 0;\n      if (sourceProj.canWrapX()) {\n        worldWidth = getWidth(sourceProjExtent);\n        worldsAway = Math.floor(\n          (sourceExtent[0] - sourceProjExtent[0]) / worldWidth,\n        );\n      }\n\n      const sourceExtents = wrapAndSliceX(\n        sourceExtent.slice(),\n        sourceProj,\n        true,\n      );\n      sourceExtents.forEach((extent) => {\n        const sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(\n          extent,\n          this.sourceZ_,\n        );\n\n        for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n          for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n            const tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);\n            if (tile) {\n              const offset = worldsAway * worldWidth;\n              this.sourceTiles_.push({tile, offset});\n            }\n          }\n        }\n        ++worldsAway;\n      });\n\n      if (this.sourceTiles_.length === 0) {\n        this.state = TileState.EMPTY;\n      }\n    }\n  }\n\n  /**\n   * Get the HTML Canvas element for this tile.\n   * @return {HTMLCanvasElement} Canvas.\n   */\n  getImage() {\n    return this.canvas_;\n  }\n\n  /**\n   * @private\n   */\n  reproject_() {\n    const sources = [];\n    this.sourceTiles_.forEach((source) => {\n      const tile = source.tile;\n      if (tile && tile.getState() == TileState.LOADED) {\n        const extent = this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord);\n        extent[0] += source.offset;\n        extent[2] += source.offset;\n        const clipExtent = this.clipExtent_?.slice();\n        if (clipExtent) {\n          clipExtent[0] += source.offset;\n          clipExtent[2] += source.offset;\n        }\n        sources.push({\n          extent: extent,\n          clipExtent: clipExtent,\n          image: tile.getImage(),\n        });\n      }\n    });\n    this.sourceTiles_.length = 0;\n\n    if (sources.length === 0) {\n      this.state = TileState.ERROR;\n    } else {\n      const z = this.wrappedTileCoord_[0];\n      const size = this.targetTileGrid_.getTileSize(z);\n      const width = typeof size === 'number' ? size : size[0];\n      const height = typeof size === 'number' ? size : size[1];\n      const targetResolution = this.targetTileGrid_.getResolution(z);\n      const sourceResolution = this.sourceTileGrid_.getResolution(\n        this.sourceZ_,\n      );\n\n      const targetExtent = this.targetTileGrid_.getTileCoordExtent(\n        this.wrappedTileCoord_,\n      );\n\n      this.canvas_ = renderReprojected(\n        width,\n        height,\n        this.pixelRatio_,\n        sourceResolution,\n        this.sourceTileGrid_.getExtent(),\n        targetResolution,\n        targetExtent,\n        this.triangulation_,\n        sources,\n        this.gutter_,\n        this.renderEdges_,\n        this.interpolate,\n      );\n\n      this.state = TileState.LOADED;\n    }\n    this.changed();\n  }\n\n  /**\n   * Load not yet loaded URI.\n   */\n  load() {\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n\n      let leftToLoad = 0;\n\n      this.sourcesListenerKeys_ = [];\n      this.sourceTiles_.forEach(({tile}) => {\n        const state = tile.getState();\n        if (state == TileState.IDLE || state == TileState.LOADING) {\n          leftToLoad++;\n\n          const sourceListenKey = listen(\n            tile,\n            EventType.CHANGE,\n            function (e) {\n              const state = tile.getState();\n              if (\n                state == TileState.LOADED ||\n                state == TileState.ERROR ||\n                state == TileState.EMPTY\n              ) {\n                unlistenByKey(sourceListenKey);\n                leftToLoad--;\n                if (leftToLoad === 0) {\n                  this.unlistenSources_();\n                  this.reproject_();\n                }\n              }\n            },\n            this,\n          );\n          this.sourcesListenerKeys_.push(sourceListenKey);\n        }\n      });\n\n      if (leftToLoad === 0) {\n        setTimeout(this.reproject_.bind(this), 0);\n      } else {\n        this.sourceTiles_.forEach(function ({tile}, i, arr) {\n          const state = tile.getState();\n          if (state == TileState.IDLE) {\n            tile.load();\n          }\n        });\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  unlistenSources_() {\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\n    this.sourcesListenerKeys_ = null;\n  }\n\n  /**\n   * Remove from the cache due to expiry\n   */\n  release() {\n    if (this.canvas_) {\n      releaseCanvas(this.canvas_.getContext('2d'));\n      canvasPool.push(this.canvas_);\n      this.canvas_ = null;\n    }\n    super.release();\n  }\n}\n\nexport default ReprojTile;\n","/**\n * @module ol/reproj/Triangulation\n */\nimport {\n  boundingExtent,\n  createEmpty,\n  extendCoordinate,\n  getArea,\n  getBottomLeft,\n  getBottomRight,\n  getTopLeft,\n  getTopRight,\n  getWidth,\n  intersects,\n} from '../extent.js';\nimport {getTransform} from '../proj.js';\nimport {modulo} from '../math.js';\n\n/**\n * Single triangle; consists of 3 source points and 3 target points.\n * @typedef {Object} Triangle\n * @property {Array<import(\"../coordinate.js\").Coordinate>} source Source.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} target Target.\n */\n\n/**\n * Maximum number of subdivision steps during raster reprojection triangulation.\n * Prevents high memory usage and large number of proj4 calls (for certain\n * transformations and areas). At most `2*(2^this)` triangles are created for\n * each triangulated extent (tile/image).\n * @type {number}\n */\nconst MAX_SUBDIVISION = 10;\n\n/**\n * Maximum allowed size of triangle relative to world width. When transforming\n * corners of world extent between certain projections, the resulting\n * triangulation seems to have zero error and no subdivision is performed. If\n * the triangle width is more than this (relative to world width; 0-1),\n * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.\n * @type {number}\n */\nconst MAX_TRIANGLE_WIDTH = 0.25;\n\n/**\n * @classdesc\n * Class containing triangulation of the given target extent.\n * Used for determining source data and the reprojection itself.\n */\nclass Triangulation {\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../extent.js\").Extent} targetExtent Target extent to triangulate.\n   * @param {import(\"../extent.js\").Extent} maxSourceExtent Maximal source extent that can be used.\n   * @param {number} errorThreshold Acceptable error (in source units).\n   * @param {?number} destinationResolution The (optional) resolution of the destination.\n   */\n  constructor(\n    sourceProj,\n    targetProj,\n    targetExtent,\n    maxSourceExtent,\n    errorThreshold,\n    destinationResolution,\n  ) {\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     * @private\n     */\n    this.sourceProj_ = sourceProj;\n\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     * @private\n     */\n    this.targetProj_ = targetProj;\n\n    /** @type {!Object<string, import(\"../coordinate.js\").Coordinate>} */\n    let transformInvCache = {};\n    const transformInv = getTransform(this.targetProj_, this.sourceProj_);\n\n    /**\n     * @param {import(\"../coordinate.js\").Coordinate} c A coordinate.\n     * @return {import(\"../coordinate.js\").Coordinate} Transformed coordinate.\n     * @private\n     */\n    this.transformInv_ = function (c) {\n      const key = c[0] + '/' + c[1];\n      if (!transformInvCache[key]) {\n        transformInvCache[key] = transformInv(c);\n      }\n      return transformInvCache[key];\n    };\n\n    /**\n     * @type {import(\"../extent.js\").Extent}\n     * @private\n     */\n    this.maxSourceExtent_ = maxSourceExtent;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.errorThresholdSquared_ = errorThreshold * errorThreshold;\n\n    /**\n     * @type {Array<Triangle>}\n     * @private\n     */\n    this.triangles_ = [];\n\n    /**\n     * Indicates that the triangulation crosses edge of the source projection.\n     * @type {boolean}\n     * @private\n     */\n    this.wrapsXInSource_ = false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.canWrapXInSource_ =\n      this.sourceProj_.canWrapX() &&\n      !!maxSourceExtent &&\n      !!this.sourceProj_.getExtent() &&\n      getWidth(maxSourceExtent) >= getWidth(this.sourceProj_.getExtent());\n\n    /**\n     * @type {?number}\n     * @private\n     */\n    this.sourceWorldWidth_ = this.sourceProj_.getExtent()\n      ? getWidth(this.sourceProj_.getExtent())\n      : null;\n\n    /**\n     * @type {?number}\n     * @private\n     */\n    this.targetWorldWidth_ = this.targetProj_.getExtent()\n      ? getWidth(this.targetProj_.getExtent())\n      : null;\n\n    const destinationTopLeft = getTopLeft(targetExtent);\n    const destinationTopRight = getTopRight(targetExtent);\n    const destinationBottomRight = getBottomRight(targetExtent);\n    const destinationBottomLeft = getBottomLeft(targetExtent);\n    const sourceTopLeft = this.transformInv_(destinationTopLeft);\n    const sourceTopRight = this.transformInv_(destinationTopRight);\n    const sourceBottomRight = this.transformInv_(destinationBottomRight);\n    const sourceBottomLeft = this.transformInv_(destinationBottomLeft);\n\n    /*\n     * The maxSubdivision controls how many splittings of the target area can\n     * be done. The idea here is to do a linear mapping of the target areas\n     * but the actual overall reprojection (can be) extremely non-linear. The\n     * default value of MAX_SUBDIVISION was chosen based on mapping a 256x256\n     * tile size. However this function is also called to remap canvas rendered\n     * layers which can be much larger. This calculation increases the maxSubdivision\n     * value by the right factor so that each 256x256 pixel area has\n     * MAX_SUBDIVISION divisions.\n     */\n    const maxSubdivision =\n      MAX_SUBDIVISION +\n      (destinationResolution\n        ? Math.max(\n            0,\n            Math.ceil(\n              Math.log2(\n                getArea(targetExtent) /\n                  (destinationResolution * destinationResolution * 256 * 256),\n              ),\n            ),\n          )\n        : 0);\n\n    this.addQuad_(\n      destinationTopLeft,\n      destinationTopRight,\n      destinationBottomRight,\n      destinationBottomLeft,\n      sourceTopLeft,\n      sourceTopRight,\n      sourceBottomRight,\n      sourceBottomLeft,\n      maxSubdivision,\n    );\n\n    if (this.wrapsXInSource_) {\n      let leftBound = Infinity;\n      this.triangles_.forEach(function (triangle, i, arr) {\n        leftBound = Math.min(\n          leftBound,\n          triangle.source[0][0],\n          triangle.source[1][0],\n          triangle.source[2][0],\n        );\n      });\n\n      // Shift triangles to be as close to `leftBound` as possible\n      // (if the distance is more than `worldWidth / 2` it can be closer.\n      this.triangles_.forEach((triangle) => {\n        if (\n          Math.max(\n            triangle.source[0][0],\n            triangle.source[1][0],\n            triangle.source[2][0],\n          ) -\n            leftBound >\n          this.sourceWorldWidth_ / 2\n        ) {\n          const newTriangle = [\n            [triangle.source[0][0], triangle.source[0][1]],\n            [triangle.source[1][0], triangle.source[1][1]],\n            [triangle.source[2][0], triangle.source[2][1]],\n          ];\n          if (newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2) {\n            newTriangle[0][0] -= this.sourceWorldWidth_;\n          }\n          if (newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2) {\n            newTriangle[1][0] -= this.sourceWorldWidth_;\n          }\n          if (newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2) {\n            newTriangle[2][0] -= this.sourceWorldWidth_;\n          }\n\n          // Rarely (if the extent contains both the dateline and prime meridian)\n          // the shift can in turn break some triangles.\n          // Detect this here and don't shift in such cases.\n          const minX = Math.min(\n            newTriangle[0][0],\n            newTriangle[1][0],\n            newTriangle[2][0],\n          );\n          const maxX = Math.max(\n            newTriangle[0][0],\n            newTriangle[1][0],\n            newTriangle[2][0],\n          );\n          if (maxX - minX < this.sourceWorldWidth_ / 2) {\n            triangle.source = newTriangle;\n          }\n        }\n      });\n    }\n\n    transformInvCache = {};\n  }\n\n  /**\n   * Adds triangle to the triangulation.\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n   * @private\n   */\n  addTriangle_(a, b, c, aSrc, bSrc, cSrc) {\n    this.triangles_.push({\n      source: [aSrc, bSrc, cSrc],\n      target: [a, b, c],\n    });\n  }\n\n  /**\n   * Adds quad (points in clock-wise order) to the triangulation\n   * (and reprojects the vertices) if valid.\n   * Performs quad subdivision if needed to increase precision.\n   *\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} d The target d coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} dSrc The source d coordinate.\n   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.\n   * @private\n   */\n  addQuad_(a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {\n    const sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);\n    const sourceCoverageX = this.sourceWorldWidth_\n      ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_\n      : null;\n    const sourceWorldWidth = /** @type {number} */ (this.sourceWorldWidth_);\n\n    // when the quad is wrapped in the source projection\n    // it covers most of the projection extent, but not fully\n    const wrapsX =\n      this.sourceProj_.canWrapX() &&\n      sourceCoverageX > 0.5 &&\n      sourceCoverageX < 1;\n\n    let needsSubdivision = false;\n\n    if (maxSubdivision > 0) {\n      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {\n        const targetQuadExtent = boundingExtent([a, b, c, d]);\n        const targetCoverageX =\n          getWidth(targetQuadExtent) / this.targetWorldWidth_;\n        needsSubdivision =\n          targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n      }\n      if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {\n        needsSubdivision =\n          sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n      }\n    }\n\n    if (!needsSubdivision && this.maxSourceExtent_) {\n      if (\n        isFinite(sourceQuadExtent[0]) &&\n        isFinite(sourceQuadExtent[1]) &&\n        isFinite(sourceQuadExtent[2]) &&\n        isFinite(sourceQuadExtent[3])\n      ) {\n        if (!intersects(sourceQuadExtent, this.maxSourceExtent_)) {\n          // whole quad outside source projection extent -> ignore\n          return;\n        }\n      }\n    }\n\n    let isNotFinite = 0;\n\n    if (!needsSubdivision) {\n      if (\n        !isFinite(aSrc[0]) ||\n        !isFinite(aSrc[1]) ||\n        !isFinite(bSrc[0]) ||\n        !isFinite(bSrc[1]) ||\n        !isFinite(cSrc[0]) ||\n        !isFinite(cSrc[1]) ||\n        !isFinite(dSrc[0]) ||\n        !isFinite(dSrc[1])\n      ) {\n        if (maxSubdivision > 0) {\n          needsSubdivision = true;\n        } else {\n          // It might be the case that only 1 of the points is infinite. In this case\n          // we can draw a single triangle with the other three points\n          isNotFinite =\n            (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) +\n            (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) +\n            (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) +\n            (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);\n          if (\n            isNotFinite != 1 &&\n            isNotFinite != 2 &&\n            isNotFinite != 4 &&\n            isNotFinite != 8\n          ) {\n            return;\n          }\n        }\n      }\n    }\n\n    if (maxSubdivision > 0) {\n      if (!needsSubdivision) {\n        const center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];\n        const centerSrc = this.transformInv_(center);\n\n        let dx;\n        if (wrapsX) {\n          const centerSrcEstimX =\n            (modulo(aSrc[0], sourceWorldWidth) +\n              modulo(cSrc[0], sourceWorldWidth)) /\n            2;\n          dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);\n        } else {\n          dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];\n        }\n        const dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];\n        const centerSrcErrorSquared = dx * dx + dy * dy;\n        needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;\n      }\n      if (needsSubdivision) {\n        if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {\n          // split horizontally (top & bottom)\n          const bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];\n          const bcSrc = this.transformInv_(bc);\n          const da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];\n          const daSrc = this.transformInv_(da);\n\n          this.addQuad_(\n            a,\n            b,\n            bc,\n            da,\n            aSrc,\n            bSrc,\n            bcSrc,\n            daSrc,\n            maxSubdivision - 1,\n          );\n          this.addQuad_(\n            da,\n            bc,\n            c,\n            d,\n            daSrc,\n            bcSrc,\n            cSrc,\n            dSrc,\n            maxSubdivision - 1,\n          );\n        } else {\n          // split vertically (left & right)\n          const ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\n          const abSrc = this.transformInv_(ab);\n          const cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];\n          const cdSrc = this.transformInv_(cd);\n\n          this.addQuad_(\n            a,\n            ab,\n            cd,\n            d,\n            aSrc,\n            abSrc,\n            cdSrc,\n            dSrc,\n            maxSubdivision - 1,\n          );\n          this.addQuad_(\n            ab,\n            b,\n            c,\n            cd,\n            abSrc,\n            bSrc,\n            cSrc,\n            cdSrc,\n            maxSubdivision - 1,\n          );\n        }\n        return;\n      }\n    }\n\n    if (wrapsX) {\n      if (!this.canWrapXInSource_) {\n        return;\n      }\n      this.wrapsXInSource_ = true;\n    }\n\n    // Exactly zero or one of *Src is not finite\n    // The triangles must have the diagonal line as the first side\n    // This is to allow easy code in reproj.s to make it straight for broken\n    // browsers that can't handle diagonal clipping\n    if ((isNotFinite & 0xb) == 0) {\n      this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);\n    }\n    if ((isNotFinite & 0xe) == 0) {\n      this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);\n    }\n    if (isNotFinite) {\n      // Try the other two triangles\n      if ((isNotFinite & 0xd) == 0) {\n        this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);\n      }\n      if ((isNotFinite & 0x7) == 0) {\n        this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);\n      }\n    }\n  }\n\n  /**\n   * Calculates extent of the `source` coordinates from all the triangles.\n   *\n   * @return {import(\"../extent.js\").Extent} Calculated extent.\n   */\n  calculateSourceExtent() {\n    const extent = createEmpty();\n\n    this.triangles_.forEach(function (triangle, i, arr) {\n      const src = triangle.source;\n      extendCoordinate(extent, src[0]);\n      extendCoordinate(extent, src[1]);\n      extendCoordinate(extent, src[2]);\n    });\n\n    return extent;\n  }\n\n  /**\n   * @return {Array<Triangle>} Array of the calculated triangles.\n   */\n  getTriangles() {\n    return this.triangles_;\n  }\n}\n\nexport default Triangulation;\n","/**\n * @module ol/reproj/common\n */\n\n/**\n * Default maximum allowed threshold  (in pixels) for reprojection\n * triangulation.\n * @type {number}\n */\nexport const ERROR_THRESHOLD = 0.5;\n"],"names":["ReprojDataTile","constructor","options","super","tileCoord","loader","Promise","resolve","Uint8Array","interpolate","transition","this","pixelRatio_","pixelRatio","gutter_","gutter","reprojData_","reprojError_","reprojSize_","undefined","sourceTileGrid_","sourceTileGrid","targetTileGrid_","targetTileGrid","wrappedTileCoord_","wrappedTileCoord","sourceTiles_","sourcesListenerKeys_","sourceZ_","sourceProj","sourceProjExtent","getExtent","sourceTileGridExtent","clipExtent_","canWrapX","targetExtent","getTileCoordExtent","maxTargetExtent","maxSourceExtent","limitedTargetExtent","state","EMPTY","targetResolution","getResolution","targetProj","sourceResolution","isFinite","errorThresholdInPixels","errorThreshold","triangulation_","getTriangles","length","getZForResolution","sourceExtent","calculateSourceExtent","worldWidth","worldsAway","Math","floor","sourceExtents","slice","forEach","extent","sourceRange","getTileRangeForExtentAndZ","getTile","getTileFunction","srcX","minX","maxX","srcY","minY","maxY","tile","offset","push","getSize","getData","getError","reproject_","dataSources","source","getState","LOADED","size","tileData","arrayData","pixelSize","isFloat","Float32Array","pixelCount","DataType","tileDataR","buffer","bytesPerElement","BYTES_PER_ELEMENT","bytesPerPixel","bytesPerRow","byteLength","bandCount","packedLength","packedData","dataIndex","rowOffset","colCount","rowIndex","colIndex","clipExtent","data","dataType","ERROR","z","getTileSize","targetWidth","targetHeight","dataR","dataU","reprojs","ceil","reproj","sources","i","len","dataSource","width","height","context","imageData","createImageData","j","putImageData","image","canvas","getContext","getImageData","round","changed","load","IDLE","LOADING","leftToLoad","sourceListenKey","CHANGE","unlistenSources_","setTimeout","bind","ReprojTile","renderEdges","renderEdges_","canvas_","getImage","e","arr","release","MAX_SUBDIVISION","MAX_TRIANGLE_WIDTH","Triangulation","destinationResolution","sourceProj_","targetProj_","transformInvCache","transformInv","getTransform","transformInv_","c","key","maxSourceExtent_","errorThresholdSquared_","triangles_","wrapsXInSource_","canWrapXInSource_","sourceWorldWidth_","targetWorldWidth_","destinationTopLeft","destinationTopRight","destinationBottomRight","destinationBottomLeft","sourceTopLeft","sourceTopRight","sourceBottomRight","sourceBottomLeft","maxSubdivision","max","log2","addQuad_","leftBound","Infinity","triangle","min","newTriangle","addTriangle_","a","b","aSrc","bSrc","cSrc","target","d","dSrc","sourceQuadExtent","sourceCoverageX","sourceWorldWidth","wrapsX","needsSubdivision","isGlobal","targetQuadExtent","targetCoverageX","isNotFinite","center","centerSrc","dx","centerSrcEstimX","dy","centerSrcErrorSquared","abs","bc","bcSrc","da","daSrc","ab","abSrc","cd","cdSrc","src","ERROR_THRESHOLD"],"sourceRoot":""}
{"version":3,"file":"js/4717.edbb0b22.js","mappings":"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","sources":["webpack://@openeo/web-editor/src/components/maps/GeoJsonMixin.vue","webpack://@openeo/web-editor/./src/components/maps/GeoJsonMixin.vue?c6d3","webpack://@openeo/web-editor/./src/components/maps/GeoJsonMixin.vue","webpack://@openeo/web-editor/src/components/maps/ExtentMixin.vue","webpack://@openeo/web-editor/./src/components/maps/ExtentMixin.vue?105c","webpack://@openeo/web-editor/./src/components/maps/ExtentMixin.vue","webpack://@openeo/web-editor/./node_modules/ol/format/Feature.js","webpack://@openeo/web-editor/./node_modules/ol/format/JSONFeature.js","webpack://@openeo/web-editor/./node_modules/ol/format/GeoJSON.js","webpack://@openeo/web-editor/./node_modules/ol/geom/GeometryCollection.js","webpack://@openeo/web-editor/./node_modules/ol/geom/LineString.js","webpack://@openeo/web-editor/./node_modules/ol/geom/MultiLineString.js","webpack://@openeo/web-editor/./node_modules/ol/geom/MultiPoint.js","webpack://@openeo/web-editor/./node_modules/ol/geom/flat/center.js","webpack://@openeo/web-editor/./node_modules/ol/geom/MultiPolygon.js","webpack://@openeo/web-editor/./node_modules/ol/geom/flat/interpolate.js","webpack://@openeo/web-editor/./node_modules/ol/interaction/Select.js"],"sourcesContent":["<script>\nimport Utils from '../../utils.js';\nimport EventBusMixin from '../EventBusMixin.js';\n\nimport { isEmpty as extentIsEmpty } from 'ol/extent';\nimport { singleClick } from 'ol/events/condition';\nimport GeoJSON from 'ol/format/GeoJSON';\nimport Select from 'ol/interaction/Select';\nimport VectorLayer from 'ol/layer/Vector';\nimport VectorSource from 'ol/source/Vector';\n\n// Requires the MapMixin to be included, too.\nexport default {\n\tmixins: [\n\t\tEventBusMixin\n\t],\n\tmethods: {\n\t\taddGeoJson(geojson, selectable = false, title = \"GeoJSON\", fill = true) {\n\t\t\tlet source;\n\t\t\tif (geojson instanceof VectorSource) {\n\t\t\t\tsource = geojson;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsource = this.createGeoJsonSource(geojson, this.map.getView().getProjection());\n\t\t\t}\n\n\t\t\tlet layer = new VectorLayer({title, source});\n\t\t\tif(!fill && this.removeLayerFill) {\n\t\t\t\tthis.removeLayerFill(layer);\n\t\t\t}\n\t\t\tthis.map.addLayer(layer);\n\t\t\tlet extent = source.getExtent();\n\t\t\tif (!extentIsEmpty(extent)) {\n\t\t\t\tthis.map.getView().fit(extent, this.getFitOptions());\n\t\t\t}\n\n\t\t\tif (selectable) {\n\t\t\t\tvar select = new Select({\n\t\t\t\t\thitTolerance: 5,\n\t\t\t\t\tmulti: false,\n\t\t\t\t\tcondition: singleClick,\n\t\t\t\t\tlayers: [\n\t\t\t\t\t\tlayer\n\t\t\t\t\t]\n\t\t\t\t});\n\t\t\t\tselect.on('select', this.onSelect);\n\t\t\t\tthis.map.addInteraction(select);\n\t\t\t}\n\n\t\t\treturn layer;\n\t\t},\n\t\tonSelect(event) {\n\t\t\tif (event.selected.length > 0) {\n\t\t\t\tlet feature = event.selected[0];\n\t\t\t\tlet props = Utils.omitFromObject(feature.getProperties(), ['geometry']);\n\t\t\t\tlet title = feature.getId() || \"Feature Properties\";\n\t\t\t\tthis.broadcast('showDataModal', props, title);\n\t\t\t}\n\t\t},\n\t\tcreateGeoJsonSource(geojson, projection) {\n\t\t\tlet features = [];\n\t\t\tif (Utils.detectGeoJson(geojson)) {\n\t\t\t\tfeatures = (new GeoJSON()).readFeatures(geojson, { featureProjection: projection })\n\t\t\t}\n\t\t\treturn new VectorSource({\n\t\t\t\tfeatures,\n\t\t\t\twrapX: false\n\t\t\t});\n\t\t}\n\t}\n};\n</script>","import mod from \"-!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./GeoJsonMixin.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./GeoJsonMixin.vue?vue&type=script&lang=js&\"","var render, staticRenderFns\nimport script from \"./GeoJsonMixin.vue?vue&type=script&lang=js&\"\nexport * from \"./GeoJsonMixin.vue?vue&type=script&lang=js&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","<script>\nimport GeoJsonMixin from './GeoJsonMixin.vue';\nimport Utils from '../../utils.js';\n\nimport Feature from 'ol/Feature';\nimport { fromExtent as PolygonFromExtent } from 'ol/geom/Polygon';\nimport VectorLayer from 'ol/layer/Vector';\nimport VectorSource from 'ol/source/Vector';\n\nexport default {\n\tmixins: [GeoJsonMixin],\n\tmethods: {\n\t\t// data can be:\n\t\t// bbox: Array of Array (west, south, east, north - WGS84) or STAC Collection\n\t\t// geometry: GeoJSON Object (WGS84) or STAC Item\n\t\taddExtent(data, fill = true) {\n\t\t\tlet footprint = null;\n\t\t\tif (Utils.isObject(data)) {\n\t\t\t\tif (typeof data.west !== 'undefined' && typeof data.east !== 'undefined' && typeof data.south !== 'undefined' && typeof data.north !== 'undefined') {\n\t\t\t\t\tfootprint = [data];\n\t\t\t\t}\n\t\t\t\telse if (data.type === 'Collection') {\n\t\t\t\t\tfootprint = data.extent.spatial.bbox.map(bbox => Utils.extentToBBox(bbox));\n\t\t\t\t}\n\t\t\t\telse if (data.type !== 'Feature' || data.geometry || data.bbox) {\n\t\t\t\t\tfootprint = data;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfootprint = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfootprint = data;\n\t\t\t}\n\n\t\t\tif (Array.isArray(footprint) && footprint.length > 0) {\n\t\t\t\treturn this.addRectangles(footprint, fill);\n\t\t\t}\n\t\t\telse if (footprint) {\n\t\t\t\treturn this.addGeoJson(footprint, false, \"Footprint\", fill);\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\n\t\taddRectangles(rectangles, fill = true) {\n\t\t\tlet mapProj = this.map.getView().getProjection();\n\t\t\tlet features = rectangles.map(bbox => {\n\t\t\t\tlet polygon = PolygonFromExtent([bbox.west, bbox.south, bbox.east, bbox.north]).transform(\"EPSG:4326\", mapProj);\n\t\t\t\treturn new Feature(polygon);\n\t\t\t});\n\t\t\tlet source = new VectorSource({\n\t\t\t\tfeatures,\n\t\t\t\tprojection: mapProj,\n\t\t\t\twrapX: false\n\t\t\t});\n\t\t\tlet layer = new VectorLayer({\n\t\t\t\ttitle: \"Bounding Boxes\",\n\t\t\t\tdisplayInLayerSwitcher: false,\n\t\t\t\tsource\n\t\t\t});\n\t\t\tif (!fill) {\n\t\t\t\tthis.removeLayerFill(layer);\n\t\t\t}\n\t\t\tthis.map.addLayer(layer);\n\t\t\t// ToDo: The Collection component has some smart fitting behavior in setMapSize()\n\t\t\t// Implement something similar here, too.\n\t\t\tthis.map.getView().fit(source.getExtent(), this.getFitOptions());\n\t\t\treturn layer;\n\t\t},\n\n\t\tremoveLayerFill(layer) {\n\t\t\tlet style = layer.getStyle();\n\t\t\t// https://github.com/openlayers/openlayers/issues/10131\n\t\t\tif (typeof style === 'function') {\n\t\t\t\tstyle = style()[0];\n\t\t\t}\n\t\t\tstyle.setFill(null);\n\t\t}\n\n\t}\n\n}\n</script>","import mod from \"-!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./ExtentMixin.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[1]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./ExtentMixin.vue?vue&type=script&lang=js&\"","var render, staticRenderFns\nimport script from \"./ExtentMixin.vue?vue&type=script&lang=js&\"\nexport * from \"./ExtentMixin.vue?vue&type=script&lang=js&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","/**\n * @module ol/format/Feature\n */\nimport {abstract} from '../util.js';\nimport {\n  equivalent as equivalentProjection,\n  get as getProjection,\n  transformExtent,\n} from '../proj.js';\n\n/**\n * @typedef {Object} ReadOptions\n * @property {import(\"../proj.js\").ProjectionLike} [dataProjection] Projection of the data we are reading.\n * If not provided, the projection will be derived from the data (where possible) or\n * the `dataProjection` of the format is assigned (where set). If the projection\n * can not be derived from the data and if no `dataProjection` is set for a format,\n * the features will not be reprojected.\n * @property {import(\"../extent.js\").Extent} [extent] Tile extent in map units of the tile being read.\n * This is only required when reading data with tile pixels as geometry units. When configured,\n * a `dataProjection` with `TILE_PIXELS` as `units` and the tile's pixel extent as `extent` needs to be\n * provided.\n * @property {import(\"../proj.js\").ProjectionLike} [featureProjection] Projection of the feature geometries\n * created by the format reader. If not provided, features will be returned in the\n * `dataProjection`.\n */\n\n/**\n * @typedef {Object} WriteOptions\n * @property {import(\"../proj.js\").ProjectionLike} [dataProjection] Projection of the data we are writing.\n * If not provided, the `dataProjection` of the format is assigned (where set).\n * If no `dataProjection` is set for a format, the features will be returned\n * in the `featureProjection`.\n * @property {import(\"../proj.js\").ProjectionLike} [featureProjection] Projection of the feature geometries\n * that will be serialized by the format writer. If not provided, geometries are assumed\n * to be in the `dataProjection` if that is set; in other words, they are not transformed.\n * @property {boolean} [rightHanded] When writing geometries, follow the right-hand\n * rule for linear ring orientation.  This means that polygons will have counter-clockwise\n * exterior rings and clockwise interior rings.  By default, coordinates are serialized\n * as they are provided at construction.  If `true`, the right-hand rule will\n * be applied.  If `false`, the left-hand rule will be applied (clockwise for\n * exterior and counter-clockwise for interior rings).  Note that not all\n * formats support this.  The GeoJSON format does use this property when writing\n * geometries.\n * @property {number} [decimals] Maximum number of decimal places for coordinates.\n * Coordinates are stored internally as floats, but floating-point arithmetic can create\n * coordinates with a large number of decimal places, not generally wanted on output.\n * Set a number here to round coordinates. Can also be used to ensure that\n * coordinates read in can be written back out with the same number of decimals.\n * Default is no rounding.\n */\n\n/**\n * @typedef {'arraybuffer' | 'json' | 'text' | 'xml'} Type\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for feature formats.\n * {@link module:ol/format/Feature~FeatureFormat} subclasses provide the ability to decode and encode\n * {@link module:ol/Feature~Feature} objects from a variety of commonly used geospatial\n * file formats.  See the documentation for each format for more details.\n *\n * @abstract\n * @api\n */\nclass FeatureFormat {\n  constructor() {\n    /**\n     * @protected\n     * @type {import(\"../proj/Projection.js\").default|undefined}\n     */\n    this.dataProjection = undefined;\n\n    /**\n     * @protected\n     * @type {import(\"../proj/Projection.js\").default|undefined}\n     */\n    this.defaultFeatureProjection = undefined;\n\n    /**\n     * A list media types supported by the format in descending order of preference.\n     * @type {Array<string>}\n     */\n    this.supportedMediaTypes = null;\n  }\n\n  /**\n   * Adds the data projection to the read options.\n   * @param {Document|Element|Object|string} source Source.\n   * @param {ReadOptions} [options] Options.\n   * @return {ReadOptions|undefined} Options.\n   * @protected\n   */\n  getReadOptions(source, options) {\n    if (options) {\n      let dataProjection = options.dataProjection\n        ? getProjection(options.dataProjection)\n        : this.readProjection(source);\n      if (\n        options.extent &&\n        dataProjection &&\n        dataProjection.getUnits() === 'tile-pixels'\n      ) {\n        dataProjection = getProjection(dataProjection);\n        dataProjection.setWorldExtent(options.extent);\n      }\n      options = {\n        dataProjection: dataProjection,\n        featureProjection: options.featureProjection,\n      };\n    }\n    return this.adaptOptions(options);\n  }\n\n  /**\n   * Sets the `dataProjection` on the options, if no `dataProjection`\n   * is set.\n   * @param {WriteOptions|ReadOptions|undefined} options\n   *     Options.\n   * @protected\n   * @return {WriteOptions|ReadOptions|undefined}\n   *     Updated options.\n   */\n  adaptOptions(options) {\n    return Object.assign(\n      {\n        dataProjection: this.dataProjection,\n        featureProjection: this.defaultFeatureProjection,\n      },\n      options\n    );\n  }\n\n  /**\n   * @abstract\n   * @return {Type} The format type.\n   */\n  getType() {\n    return abstract();\n  }\n\n  /**\n   * Read a single feature from a source.\n   *\n   * @abstract\n   * @param {Document|Element|Object|string} source Source.\n   * @param {ReadOptions} [options] Read options.\n   * @return {import(\"../Feature.js\").FeatureLike} Feature.\n   */\n  readFeature(source, options) {\n    return abstract();\n  }\n\n  /**\n   * Read all features from a source.\n   *\n   * @abstract\n   * @param {Document|Element|ArrayBuffer|Object|string} source Source.\n   * @param {ReadOptions} [options] Read options.\n   * @return {Array<import(\"../Feature.js\").FeatureLike>} Features.\n   */\n  readFeatures(source, options) {\n    return abstract();\n  }\n\n  /**\n   * Read a single geometry from a source.\n   *\n   * @abstract\n   * @param {Document|Element|Object|string} source Source.\n   * @param {ReadOptions} [options] Read options.\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometry(source, options) {\n    return abstract();\n  }\n\n  /**\n   * Read the projection from a source.\n   *\n   * @abstract\n   * @param {Document|Element|Object|string} source Source.\n   * @return {import(\"../proj/Projection.js\").default|undefined} Projection.\n   */\n  readProjection(source) {\n    return abstract();\n  }\n\n  /**\n   * Encode a feature in this format.\n   *\n   * @abstract\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {WriteOptions} [options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   */\n  writeFeature(feature, options) {\n    return abstract();\n  }\n\n  /**\n   * Encode an array of features in this format.\n   *\n   * @abstract\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {WriteOptions} [options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   */\n  writeFeatures(features, options) {\n    return abstract();\n  }\n\n  /**\n   * Write a single geometry in this format.\n   *\n   * @abstract\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {WriteOptions} [options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   */\n  writeGeometry(geometry, options) {\n    return abstract();\n  }\n}\n\nexport default FeatureFormat;\n\n/**\n * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {boolean} write Set to true for writing, false for reading.\n * @param {WriteOptions|ReadOptions} [options] Options.\n * @return {import(\"../geom/Geometry.js\").default} Transformed geometry.\n */\nexport function transformGeometryWithOptions(geometry, write, options) {\n  const featureProjection = options\n    ? getProjection(options.featureProjection)\n    : null;\n  const dataProjection = options ? getProjection(options.dataProjection) : null;\n\n  let transformed;\n  if (\n    featureProjection &&\n    dataProjection &&\n    !equivalentProjection(featureProjection, dataProjection)\n  ) {\n    transformed = (write ? geometry.clone() : geometry).transform(\n      write ? featureProjection : dataProjection,\n      write ? dataProjection : featureProjection\n    );\n  } else {\n    transformed = geometry;\n  }\n  if (\n    write &&\n    options &&\n    /** @type {WriteOptions} */ (options).decimals !== undefined\n  ) {\n    const power = Math.pow(10, /** @type {WriteOptions} */ (options).decimals);\n    // if decimals option on write, round each coordinate appropriately\n    /**\n     * @param {Array<number>} coordinates Coordinates.\n     * @return {Array<number>} Transformed coordinates.\n     */\n    const transform = function (coordinates) {\n      for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n        coordinates[i] = Math.round(coordinates[i] * power) / power;\n      }\n      return coordinates;\n    };\n    if (transformed === geometry) {\n      transformed = geometry.clone();\n    }\n    transformed.applyTransform(transform);\n  }\n  return transformed;\n}\n\n/**\n * @param {import(\"../extent.js\").Extent} extent Extent.\n * @param {ReadOptions} [options] Read options.\n * @return {import(\"../extent.js\").Extent} Transformed extent.\n */\nexport function transformExtentWithOptions(extent, options) {\n  const featureProjection = options\n    ? getProjection(options.featureProjection)\n    : null;\n  const dataProjection = options ? getProjection(options.dataProjection) : null;\n\n  if (\n    featureProjection &&\n    dataProjection &&\n    !equivalentProjection(featureProjection, dataProjection)\n  ) {\n    return transformExtent(extent, dataProjection, featureProjection);\n  }\n  return extent;\n}\n","/**\n * @module ol/format/JSONFeature\n */\nimport FeatureFormat from './Feature.js';\nimport {abstract} from '../util.js';\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for JSON feature formats.\n *\n * @abstract\n */\nclass JSONFeature extends FeatureFormat {\n  constructor() {\n    super();\n  }\n\n  /**\n   * @return {import(\"./Feature.js\").Type} Format.\n   */\n  getType() {\n    return 'json';\n  }\n\n  /**\n   * Read a feature.  Only works for a single feature. Use `readFeatures` to\n   * read a feature collection.\n   *\n   * @param {ArrayBuffer|Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   * @api\n   */\n  readFeature(source, options) {\n    return this.readFeatureFromObject(\n      getObject(source),\n      this.getReadOptions(source, options)\n    );\n  }\n\n  /**\n   * Read all features.  Works with both a single feature and a feature\n   * collection.\n   *\n   * @param {ArrayBuffer|Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   * @api\n   */\n  readFeatures(source, options) {\n    return this.readFeaturesFromObject(\n      getObject(source),\n      this.getReadOptions(source, options)\n    );\n  }\n\n  /**\n   * @abstract\n   * @param {Object} object Object.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {import(\"../Feature.js\").default} Feature.\n   */\n  readFeatureFromObject(object, options) {\n    return abstract();\n  }\n\n  /**\n   * @abstract\n   * @param {Object} object Object.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   */\n  readFeaturesFromObject(object, options) {\n    return abstract();\n  }\n\n  /**\n   * Read a geometry.\n   *\n   * @param {ArrayBuffer|Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   * @api\n   */\n  readGeometry(source, options) {\n    return this.readGeometryFromObject(\n      getObject(source),\n      this.getReadOptions(source, options)\n    );\n  }\n\n  /**\n   * @abstract\n   * @param {Object} object Object.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometryFromObject(object, options) {\n    return abstract();\n  }\n\n  /**\n   * Read the projection.\n   *\n   * @param {ArrayBuffer|Document|Element|Object|string} source Source.\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   * @api\n   */\n  readProjection(source) {\n    return this.readProjectionFromObject(getObject(source));\n  }\n\n  /**\n   * @abstract\n   * @param {Object} object Object.\n   * @protected\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n  readProjectionFromObject(object) {\n    return abstract();\n  }\n\n  /**\n   * Encode a feature as string.\n   *\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string} Encoded feature.\n   * @api\n   */\n  writeFeature(feature, options) {\n    return JSON.stringify(this.writeFeatureObject(feature, options));\n  }\n\n  /**\n   * @abstract\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {Object} Object.\n   */\n  writeFeatureObject(feature, options) {\n    return abstract();\n  }\n\n  /**\n   * Encode an array of features as string.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string} Encoded features.\n   * @api\n   */\n  writeFeatures(features, options) {\n    return JSON.stringify(this.writeFeaturesObject(features, options));\n  }\n\n  /**\n   * @abstract\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {Object} Object.\n   */\n  writeFeaturesObject(features, options) {\n    return abstract();\n  }\n\n  /**\n   * Encode a geometry as string.\n   *\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string} Encoded geometry.\n   * @api\n   */\n  writeGeometry(geometry, options) {\n    return JSON.stringify(this.writeGeometryObject(geometry, options));\n  }\n\n  /**\n   * @abstract\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {Object} Object.\n   */\n  writeGeometryObject(geometry, options) {\n    return abstract();\n  }\n}\n\n/**\n * @param {Document|Element|Object|string} source Source.\n * @return {Object} Object.\n */\nfunction getObject(source) {\n  if (typeof source === 'string') {\n    const object = JSON.parse(source);\n    return object ? /** @type {Object} */ (object) : null;\n  } else if (source !== null) {\n    return source;\n  }\n  return null;\n}\n\nexport default JSONFeature;\n","/**\n * @module ol/format/GeoJSON\n */\n\nimport Feature from '../Feature.js';\nimport GeometryCollection from '../geom/GeometryCollection.js';\nimport JSONFeature from './JSONFeature.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport {assert} from '../asserts.js';\nimport {get as getProjection} from '../proj.js';\nimport {isEmpty} from '../obj.js';\nimport {transformGeometryWithOptions} from './Feature.js';\n\n/**\n * @typedef {import(\"geojson\").GeoJSON} GeoJSONObject\n * @typedef {import(\"geojson\").Feature} GeoJSONFeature\n * @typedef {import(\"geojson\").FeatureCollection} GeoJSONFeatureCollection\n * @typedef {import(\"geojson\").Geometry} GeoJSONGeometry\n * @typedef {import(\"geojson\").Point} GeoJSONPoint\n * @typedef {import(\"geojson\").LineString} GeoJSONLineString\n * @typedef {import(\"geojson\").Polygon} GeoJSONPolygon\n * @typedef {import(\"geojson\").MultiPoint} GeoJSONMultiPoint\n * @typedef {import(\"geojson\").MultiLineString} GeoJSONMultiLineString\n * @typedef {import(\"geojson\").MultiPolygon} GeoJSONMultiPolygon\n * @typedef {import(\"geojson\").GeometryCollection} GeoJSONGeometryCollection\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../proj.js\").ProjectionLike} [dataProjection='EPSG:4326'] Default data projection.\n * @property {import(\"../proj.js\").ProjectionLike} [featureProjection] Projection for features read or\n * written by the format.  Options passed to read or write methods will take precedence.\n * @property {string} [geometryName] Geometry name to use when creating features.\n * @property {boolean} [extractGeometryName=false] Certain GeoJSON providers include\n * the geometry_name field in the feature GeoJSON. If set to `true` the GeoJSON reader\n * will look for that field to set the geometry name. If both this field is set to `true`\n * and a `geometryName` is provided, the `geometryName` will take precedence.\n */\n\n/**\n * @classdesc\n * Feature format for reading and writing data in the GeoJSON format.\n *\n * @api\n */\nclass GeoJSON extends JSONFeature {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    super();\n\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     */\n    this.dataProjection = getProjection(\n      options.dataProjection ? options.dataProjection : 'EPSG:4326'\n    );\n\n    if (options.featureProjection) {\n      /**\n       * @type {import(\"../proj/Projection.js\").default}\n       */\n      this.defaultFeatureProjection = getProjection(options.featureProjection);\n    }\n\n    /**\n     * Name of the geometry attribute for features.\n     * @type {string|undefined}\n     * @private\n     */\n    this.geometryName_ = options.geometryName;\n\n    /**\n     * Look for the geometry name in the feature GeoJSON\n     * @type {boolean|undefined}\n     * @private\n     */\n    this.extractGeometryName_ = options.extractGeometryName;\n\n    this.supportedMediaTypes = [\n      'application/geo+json',\n      'application/vnd.geo+json',\n    ];\n  }\n\n  /**\n   * @param {Object} object Object.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {import(\"../Feature.js\").default} Feature.\n   */\n  readFeatureFromObject(object, options) {\n    /**\n     * @type {GeoJSONFeature}\n     */\n    let geoJSONFeature = null;\n    if (object['type'] === 'Feature') {\n      geoJSONFeature = /** @type {GeoJSONFeature} */ (object);\n    } else {\n      geoJSONFeature = {\n        'type': 'Feature',\n        'geometry': /** @type {GeoJSONGeometry} */ (object),\n        'properties': null,\n      };\n    }\n\n    const geometry = readGeometry(geoJSONFeature['geometry'], options);\n    const feature = new Feature();\n    if (this.geometryName_) {\n      feature.setGeometryName(this.geometryName_);\n    } else if (\n      this.extractGeometryName_ &&\n      'geometry_name' in geoJSONFeature !== undefined\n    ) {\n      feature.setGeometryName(geoJSONFeature['geometry_name']);\n    }\n    feature.setGeometry(geometry);\n\n    if ('id' in geoJSONFeature) {\n      feature.setId(geoJSONFeature['id']);\n    }\n\n    if (geoJSONFeature['properties']) {\n      feature.setProperties(geoJSONFeature['properties'], true);\n    }\n    return feature;\n  }\n\n  /**\n   * @param {Object} object Object.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {Array<Feature>} Features.\n   */\n  readFeaturesFromObject(object, options) {\n    const geoJSONObject = /** @type {GeoJSONObject} */ (object);\n    /** @type {Array<import(\"../Feature.js\").default>} */\n    let features = null;\n    if (geoJSONObject['type'] === 'FeatureCollection') {\n      const geoJSONFeatureCollection = /** @type {GeoJSONFeatureCollection} */ (\n        object\n      );\n      features = [];\n      const geoJSONFeatures = geoJSONFeatureCollection['features'];\n      for (let i = 0, ii = geoJSONFeatures.length; i < ii; ++i) {\n        features.push(this.readFeatureFromObject(geoJSONFeatures[i], options));\n      }\n    } else {\n      features = [this.readFeatureFromObject(object, options)];\n    }\n    return features;\n  }\n\n  /**\n   * @param {GeoJSONGeometry} object Object.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometryFromObject(object, options) {\n    return readGeometry(object, options);\n  }\n\n  /**\n   * @param {Object} object Object.\n   * @protected\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n  readProjectionFromObject(object) {\n    const crs = object['crs'];\n    let projection;\n    if (crs) {\n      if (crs['type'] == 'name') {\n        projection = getProjection(crs['properties']['name']);\n      } else if (crs['type'] === 'EPSG') {\n        projection = getProjection('EPSG:' + crs['properties']['code']);\n      } else {\n        assert(false, 36); // Unknown SRS type\n      }\n    } else {\n      projection = this.dataProjection;\n    }\n    return /** @type {import(\"../proj/Projection.js\").default} */ (projection);\n  }\n\n  /**\n   * Encode a feature as a GeoJSON Feature object.\n   *\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {GeoJSONFeature} Object.\n   * @api\n   */\n  writeFeatureObject(feature, options) {\n    options = this.adaptOptions(options);\n\n    /** @type {GeoJSONFeature} */\n    const object = {\n      'type': 'Feature',\n      geometry: null,\n      properties: null,\n    };\n\n    const id = feature.getId();\n    if (id !== undefined) {\n      object.id = id;\n    }\n\n    if (!feature.hasProperties()) {\n      return object;\n    }\n\n    const properties = feature.getProperties();\n    const geometry = feature.getGeometry();\n    if (geometry) {\n      object.geometry = writeGeometry(geometry, options);\n\n      delete properties[feature.getGeometryName()];\n    }\n\n    if (!isEmpty(properties)) {\n      object.properties = properties;\n    }\n\n    return object;\n  }\n\n  /**\n   * Encode an array of features as a GeoJSON object.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {GeoJSONFeatureCollection} GeoJSON Object.\n   * @api\n   */\n  writeFeaturesObject(features, options) {\n    options = this.adaptOptions(options);\n    const objects = [];\n    for (let i = 0, ii = features.length; i < ii; ++i) {\n      objects.push(this.writeFeatureObject(features[i], options));\n    }\n    return {\n      type: 'FeatureCollection',\n      features: objects,\n    };\n  }\n\n  /**\n   * Encode a geometry as a GeoJSON object.\n   *\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {GeoJSONGeometry|GeoJSONGeometryCollection} Object.\n   * @api\n   */\n  writeGeometryObject(geometry, options) {\n    return writeGeometry(geometry, this.adaptOptions(options));\n  }\n}\n\n/**\n * @param {GeoJSONGeometry|GeoJSONGeometryCollection} object Object.\n * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n * @return {import(\"../geom/Geometry.js\").default} Geometry.\n */\nfunction readGeometry(object, options) {\n  if (!object) {\n    return null;\n  }\n\n  /**\n   * @type {import(\"../geom/Geometry.js\").default}\n   */\n  let geometry;\n  switch (object['type']) {\n    case 'Point': {\n      geometry = readPointGeometry(/** @type {GeoJSONPoint} */ (object));\n      break;\n    }\n    case 'LineString': {\n      geometry = readLineStringGeometry(\n        /** @type {GeoJSONLineString} */ (object)\n      );\n      break;\n    }\n    case 'Polygon': {\n      geometry = readPolygonGeometry(/** @type {GeoJSONPolygon} */ (object));\n      break;\n    }\n    case 'MultiPoint': {\n      geometry = readMultiPointGeometry(\n        /** @type {GeoJSONMultiPoint} */ (object)\n      );\n      break;\n    }\n    case 'MultiLineString': {\n      geometry = readMultiLineStringGeometry(\n        /** @type {GeoJSONMultiLineString} */ (object)\n      );\n      break;\n    }\n    case 'MultiPolygon': {\n      geometry = readMultiPolygonGeometry(\n        /** @type {GeoJSONMultiPolygon} */ (object)\n      );\n      break;\n    }\n    case 'GeometryCollection': {\n      geometry = readGeometryCollectionGeometry(\n        /** @type {GeoJSONGeometryCollection} */ (object)\n      );\n      break;\n    }\n    default: {\n      throw new Error('Unsupported GeoJSON type: ' + object['type']);\n    }\n  }\n  return transformGeometryWithOptions(geometry, false, options);\n}\n\n/**\n * @param {GeoJSONGeometryCollection} object Object.\n * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n * @return {GeometryCollection} Geometry collection.\n */\nfunction readGeometryCollectionGeometry(object, options) {\n  const geometries = object['geometries'].map(\n    /**\n     * @param {GeoJSONGeometry} geometry Geometry.\n     * @return {import(\"../geom/Geometry.js\").default} geometry Geometry.\n     */\n    function (geometry) {\n      return readGeometry(geometry, options);\n    }\n  );\n  return new GeometryCollection(geometries);\n}\n\n/**\n * @param {GeoJSONPoint} object Object.\n * @return {Point} Point.\n */\nfunction readPointGeometry(object) {\n  return new Point(object['coordinates']);\n}\n\n/**\n * @param {GeoJSONLineString} object Object.\n * @return {LineString} LineString.\n */\nfunction readLineStringGeometry(object) {\n  return new LineString(object['coordinates']);\n}\n\n/**\n * @param {GeoJSONMultiLineString} object Object.\n * @return {MultiLineString} MultiLineString.\n */\nfunction readMultiLineStringGeometry(object) {\n  return new MultiLineString(object['coordinates']);\n}\n\n/**\n * @param {GeoJSONMultiPoint} object Object.\n * @return {MultiPoint} MultiPoint.\n */\nfunction readMultiPointGeometry(object) {\n  return new MultiPoint(object['coordinates']);\n}\n\n/**\n * @param {GeoJSONMultiPolygon} object Object.\n * @return {MultiPolygon} MultiPolygon.\n */\nfunction readMultiPolygonGeometry(object) {\n  return new MultiPolygon(object['coordinates']);\n}\n\n/**\n * @param {GeoJSONPolygon} object Object.\n * @return {Polygon} Polygon.\n */\nfunction readPolygonGeometry(object) {\n  return new Polygon(object['coordinates']);\n}\n\n/**\n * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writeGeometry(geometry, options) {\n  geometry = transformGeometryWithOptions(geometry, true, options);\n  const type = geometry.getType();\n\n  /** @type {GeoJSONGeometry} */\n  let geoJSON;\n  switch (type) {\n    case 'Point': {\n      geoJSON = writePointGeometry(/** @type {Point} */ (geometry), options);\n      break;\n    }\n    case 'LineString': {\n      geoJSON = writeLineStringGeometry(\n        /** @type {LineString} */ (geometry),\n        options\n      );\n      break;\n    }\n    case 'Polygon': {\n      geoJSON = writePolygonGeometry(\n        /** @type {Polygon} */ (geometry),\n        options\n      );\n      break;\n    }\n    case 'MultiPoint': {\n      geoJSON = writeMultiPointGeometry(\n        /** @type {MultiPoint} */ (geometry),\n        options\n      );\n      break;\n    }\n    case 'MultiLineString': {\n      geoJSON = writeMultiLineStringGeometry(\n        /** @type {MultiLineString} */ (geometry),\n        options\n      );\n      break;\n    }\n    case 'MultiPolygon': {\n      geoJSON = writeMultiPolygonGeometry(\n        /** @type {MultiPolygon} */ (geometry),\n        options\n      );\n      break;\n    }\n    case 'GeometryCollection': {\n      geoJSON = writeGeometryCollectionGeometry(\n        /** @type {GeometryCollection} */ (geometry),\n        options\n      );\n      break;\n    }\n    case 'Circle': {\n      geoJSON = {\n        type: 'GeometryCollection',\n        geometries: [],\n      };\n      break;\n    }\n    default: {\n      throw new Error('Unsupported geometry type: ' + type);\n    }\n  }\n  return geoJSON;\n}\n\n/**\n * @param {GeometryCollection} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometryCollection} GeoJSON geometry collection.\n */\nfunction writeGeometryCollectionGeometry(geometry, options) {\n  options = Object.assign({}, options);\n  delete options.featureProjection;\n  const geometries = geometry.getGeometriesArray().map(function (geometry) {\n    return writeGeometry(geometry, options);\n  });\n  return {\n    type: 'GeometryCollection',\n    geometries: geometries,\n  };\n}\n\n/**\n * @param {LineString} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writeLineStringGeometry(geometry, options) {\n  return {\n    type: 'LineString',\n    coordinates: geometry.getCoordinates(),\n  };\n}\n\n/**\n * @param {MultiLineString} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writeMultiLineStringGeometry(geometry, options) {\n  return {\n    type: 'MultiLineString',\n    coordinates: geometry.getCoordinates(),\n  };\n}\n\n/**\n * @param {MultiPoint} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writeMultiPointGeometry(geometry, options) {\n  return {\n    type: 'MultiPoint',\n    coordinates: geometry.getCoordinates(),\n  };\n}\n\n/**\n * @param {MultiPolygon} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writeMultiPolygonGeometry(geometry, options) {\n  let right;\n  if (options) {\n    right = options.rightHanded;\n  }\n  return {\n    type: 'MultiPolygon',\n    coordinates: geometry.getCoordinates(right),\n  };\n}\n\n/**\n * @param {Point} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writePointGeometry(geometry, options) {\n  return {\n    type: 'Point',\n    coordinates: geometry.getCoordinates(),\n  };\n}\n\n/**\n * @param {Polygon} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writePolygonGeometry(geometry, options) {\n  let right;\n  if (options) {\n    right = options.rightHanded;\n  }\n  return {\n    type: 'Polygon',\n    coordinates: geometry.getCoordinates(right),\n  };\n}\n\nexport default GeoJSON;\n","/**\n * @module ol/geom/GeometryCollection\n */\nimport EventType from '../events/EventType.js';\nimport Geometry from './Geometry.js';\nimport {\n  closestSquaredDistanceXY,\n  createOrUpdateEmpty,\n  extend,\n  getCenter,\n} from '../extent.js';\nimport {listen, unlistenByKey} from '../events.js';\n\n/**\n * @classdesc\n * An array of {@link module:ol/geom/Geometry~Geometry} objects.\n *\n * @api\n */\nclass GeometryCollection extends Geometry {\n  /**\n   * @param {Array<Geometry>} [geometries] Geometries.\n   */\n  constructor(geometries) {\n    super();\n\n    /**\n     * @private\n     * @type {Array<Geometry>}\n     */\n    this.geometries_ = geometries ? geometries : null;\n\n    /**\n     * @type {Array<import(\"../events.js\").EventsKey>}\n     */\n    this.changeEventsKeys_ = [];\n\n    this.listenGeometriesChange_();\n  }\n\n  /**\n   * @private\n   */\n  unlistenGeometriesChange_() {\n    this.changeEventsKeys_.forEach(unlistenByKey);\n    this.changeEventsKeys_.length = 0;\n  }\n\n  /**\n   * @private\n   */\n  listenGeometriesChange_() {\n    if (!this.geometries_) {\n      return;\n    }\n    for (let i = 0, ii = this.geometries_.length; i < ii; ++i) {\n      this.changeEventsKeys_.push(\n        listen(this.geometries_[i], EventType.CHANGE, this.changed, this)\n      );\n    }\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!GeometryCollection} Clone.\n   * @api\n   */\n  clone() {\n    const geometryCollection = new GeometryCollection(null);\n    geometryCollection.setGeometries(this.geometries_);\n    geometryCollection.applyProperties(this);\n    return geometryCollection;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      minSquaredDistance = geometries[i].closestPointXY(\n        x,\n        y,\n        closestPoint,\n        minSquaredDistance\n      );\n    }\n    return minSquaredDistance;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @return {boolean} Contains (x, y).\n   */\n  containsXY(x, y) {\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      if (geometries[i].containsXY(x, y)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @protected\n   * @return {import(\"../extent.js\").Extent} extent Extent.\n   */\n  computeExtent(extent) {\n    createOrUpdateEmpty(extent);\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      extend(extent, geometries[i].getExtent());\n    }\n    return extent;\n  }\n\n  /**\n   * Return the geometries that make up this geometry collection.\n   * @return {Array<Geometry>} Geometries.\n   * @api\n   */\n  getGeometries() {\n    return cloneGeometries(this.geometries_);\n  }\n\n  /**\n   * @return {Array<Geometry>} Geometries.\n   */\n  getGeometriesArray() {\n    return this.geometries_;\n  }\n\n  /**\n   * @return {Array<Geometry>} Geometries.\n   */\n  getGeometriesArrayRecursive() {\n    /** @type {Array<Geometry>} */\n    let geometriesArray = [];\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      if (geometries[i].getType() === this.getType()) {\n        geometriesArray = geometriesArray.concat(\n          /** @type {GeometryCollection} */ (\n            geometries[i]\n          ).getGeometriesArrayRecursive()\n        );\n      } else {\n        geometriesArray.push(geometries[i]);\n      }\n    }\n    return geometriesArray;\n  }\n\n  /**\n   * Create a simplified version of this geometry using the Douglas Peucker algorithm.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {GeometryCollection} Simplified GeometryCollection.\n   */\n  getSimplifiedGeometry(squaredTolerance) {\n    if (this.simplifiedGeometryRevision !== this.getRevision()) {\n      this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n      this.simplifiedGeometryRevision = this.getRevision();\n    }\n    if (\n      squaredTolerance < 0 ||\n      (this.simplifiedGeometryMaxMinSquaredTolerance !== 0 &&\n        squaredTolerance < this.simplifiedGeometryMaxMinSquaredTolerance)\n    ) {\n      return this;\n    }\n\n    const simplifiedGeometries = [];\n    const geometries = this.geometries_;\n    let simplified = false;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      const geometry = geometries[i];\n      const simplifiedGeometry =\n        geometry.getSimplifiedGeometry(squaredTolerance);\n      simplifiedGeometries.push(simplifiedGeometry);\n      if (simplifiedGeometry !== geometry) {\n        simplified = true;\n      }\n    }\n    if (simplified) {\n      const simplifiedGeometryCollection = new GeometryCollection(null);\n      simplifiedGeometryCollection.setGeometriesArray(simplifiedGeometries);\n      return simplifiedGeometryCollection;\n    }\n    this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;\n    return this;\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   */\n  getType() {\n    return 'GeometryCollection';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   */\n  intersectsExtent(extent) {\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      if (geometries[i].intersectsExtent(extent)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @return {boolean} Is empty.\n   */\n  isEmpty() {\n    return this.geometries_.length === 0;\n  }\n\n  /**\n   * Rotate the geometry around a given coordinate. This modifies the geometry\n   * coordinates in place.\n   * @param {number} angle Rotation angle in radians.\n   * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\n   * @api\n   */\n  rotate(angle, anchor) {\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      geometries[i].rotate(angle, anchor);\n    }\n    this.changed();\n  }\n\n  /**\n   * Scale the geometry (with an optional origin).  This modifies the geometry\n   * coordinates in place.\n   * @abstract\n   * @param {number} sx The scaling factor in the x-direction.\n   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).\n   * @param {import(\"../coordinate.js\").Coordinate} [anchor] The scale origin (defaults to the center\n   *     of the geometry extent).\n   * @api\n   */\n  scale(sx, sy, anchor) {\n    if (!anchor) {\n      anchor = getCenter(this.getExtent());\n    }\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      geometries[i].scale(sx, sy, anchor);\n    }\n    this.changed();\n  }\n\n  /**\n   * Set the geometries that make up this geometry collection.\n   * @param {Array<Geometry>} geometries Geometries.\n   * @api\n   */\n  setGeometries(geometries) {\n    this.setGeometriesArray(cloneGeometries(geometries));\n  }\n\n  /**\n   * @param {Array<Geometry>} geometries Geometries.\n   */\n  setGeometriesArray(geometries) {\n    this.unlistenGeometriesChange_();\n    this.geometries_ = geometries;\n    this.listenGeometriesChange_();\n    this.changed();\n  }\n\n  /**\n   * Apply a transform function to the coordinates of the geometry.\n   * The geometry is modified in place.\n   * If you do not want the geometry modified in place, first `clone()` it and\n   * then use this function on the clone.\n   * @param {import(\"../proj.js\").TransformFunction} transformFn Transform function.\n   * Called with a flat array of geometry coordinates.\n   * @api\n   */\n  applyTransform(transformFn) {\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      geometries[i].applyTransform(transformFn);\n    }\n    this.changed();\n  }\n\n  /**\n   * Translate the geometry.  This modifies the geometry coordinates in place.  If\n   * instead you want a new geometry, first `clone()` this geometry.\n   * @param {number} deltaX Delta X.\n   * @param {number} deltaY Delta Y.\n   * @api\n   */\n  translate(deltaX, deltaY) {\n    const geometries = this.geometries_;\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      geometries[i].translate(deltaX, deltaY);\n    }\n    this.changed();\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    this.unlistenGeometriesChange_();\n    super.disposeInternal();\n  }\n}\n\n/**\n * @param {Array<Geometry>} geometries Geometries.\n * @return {Array<Geometry>} Cloned geometries.\n */\nfunction cloneGeometries(geometries) {\n  const clonedGeometries = [];\n  for (let i = 0, ii = geometries.length; i < ii; ++i) {\n    clonedGeometries.push(geometries[i].clone());\n  }\n  return clonedGeometries;\n}\n\nexport default GeometryCollection;\n","/**\n * @module ol/geom/LineString\n */\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {assignClosestPoint, maxSquaredDelta} from './flat/closest.js';\nimport {closestSquaredDistanceXY} from '../extent.js';\nimport {deflateCoordinates} from './flat/deflate.js';\nimport {douglasPeucker} from './flat/simplify.js';\nimport {extend} from '../array.js';\nimport {forEach as forEachSegment} from './flat/segments.js';\nimport {inflateCoordinates} from './flat/inflate.js';\nimport {interpolatePoint, lineStringCoordinateAtM} from './flat/interpolate.js';\nimport {intersectsLineString} from './flat/intersectsextent.js';\nimport {lineStringLength} from './flat/length.js';\n\n/**\n * @classdesc\n * Linestring geometry.\n *\n * @api\n */\nclass LineString extends SimpleGeometry {\n  /**\n   * @param {Array<import(\"../coordinate.js\").Coordinate>|Array<number>} coordinates Coordinates.\n   *     For internal use, flat coordinates in combination with `layout` are also accepted.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   */\n  constructor(coordinates, layout) {\n    super();\n\n    /**\n     * @private\n     * @type {import(\"../coordinate.js\").Coordinate}\n     */\n    this.flatMidpoint_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.flatMidpointRevision_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n\n    if (layout !== undefined && !Array.isArray(coordinates[0])) {\n      this.setFlatCoordinates(\n        layout,\n        /** @type {Array<number>} */ (coordinates)\n      );\n    } else {\n      this.setCoordinates(\n        /** @type {Array<import(\"../coordinate.js\").Coordinate>} */ (\n          coordinates\n        ),\n        layout\n      );\n    }\n  }\n\n  /**\n   * Append the passed coordinate to the coordinates of the linestring.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @api\n   */\n  appendCoordinate(coordinate) {\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = coordinate.slice();\n    } else {\n      extend(this.flatCoordinates, coordinate);\n    }\n    this.changed();\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!LineString} Clone.\n   * @api\n   */\n  clone() {\n    const lineString = new LineString(\n      this.flatCoordinates.slice(),\n      this.layout\n    );\n    lineString.applyProperties(this);\n    return lineString;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(\n        maxSquaredDelta(\n          this.flatCoordinates,\n          0,\n          this.flatCoordinates.length,\n          this.stride,\n          0\n        )\n      );\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestPoint(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      this.maxDelta_,\n      false,\n      x,\n      y,\n      closestPoint,\n      minSquaredDistance\n    );\n  }\n\n  /**\n   * Iterate over each segment, calling the provided callback.\n   * If the callback returns a truthy value the function returns that\n   * value immediately. Otherwise the function returns `false`.\n   *\n   * @param {function(this: S, import(\"../coordinate.js\").Coordinate, import(\"../coordinate.js\").Coordinate): T} callback Function\n   *     called for each segment. The function will receive two arguments, the start and end coordinates of the segment.\n   * @return {T|boolean} Value.\n   * @template T,S\n   * @api\n   */\n  forEachSegment(callback) {\n    return forEachSegment(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      callback\n    );\n  }\n\n  /**\n   * Returns the coordinate at `m` using linear interpolation, or `null` if no\n   * such coordinate exists.\n   *\n   * `extrapolate` controls extrapolation beyond the range of Ms in the\n   * MultiLineString. If `extrapolate` is `true` then Ms less than the first\n   * M will return the first coordinate and Ms greater than the last M will\n   * return the last coordinate.\n   *\n   * @param {number} m M.\n   * @param {boolean} [extrapolate] Extrapolate. Default is `false`.\n   * @return {import(\"../coordinate.js\").Coordinate|null} Coordinate.\n   * @api\n   */\n  getCoordinateAtM(m, extrapolate) {\n    if (this.layout != 'XYM' && this.layout != 'XYZM') {\n      return null;\n    }\n    extrapolate = extrapolate !== undefined ? extrapolate : false;\n    return lineStringCoordinateAtM(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      m,\n      extrapolate\n    );\n  }\n\n  /**\n   * Return the coordinates of the linestring.\n   * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates.\n   * @api\n   */\n  getCoordinates() {\n    return inflateCoordinates(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride\n    );\n  }\n\n  /**\n   * Return the coordinate at the provided fraction along the linestring.\n   * The `fraction` is a number between 0 and 1, where 0 is the start of the\n   * linestring and 1 is the end.\n   * @param {number} fraction Fraction.\n   * @param {import(\"../coordinate.js\").Coordinate} [dest] Optional coordinate whose values will\n   *     be modified. If not provided, a new coordinate will be returned.\n   * @return {import(\"../coordinate.js\").Coordinate} Coordinate of the interpolated point.\n   * @api\n   */\n  getCoordinateAt(fraction, dest) {\n    return interpolatePoint(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      fraction,\n      dest,\n      this.stride\n    );\n  }\n\n  /**\n   * Return the length of the linestring on projected plane.\n   * @return {number} Length (on projected plane).\n   * @api\n   */\n  getLength() {\n    return lineStringLength(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride\n    );\n  }\n\n  /**\n   * @return {Array<number>} Flat midpoint.\n   */\n  getFlatMidpoint() {\n    if (this.flatMidpointRevision_ != this.getRevision()) {\n      this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_);\n      this.flatMidpointRevision_ = this.getRevision();\n    }\n    return this.flatMidpoint_;\n  }\n\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {LineString} Simplified LineString.\n   * @protected\n   */\n  getSimplifiedGeometryInternal(squaredTolerance) {\n    const simplifiedFlatCoordinates = [];\n    simplifiedFlatCoordinates.length = douglasPeucker(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      squaredTolerance,\n      simplifiedFlatCoordinates,\n      0\n    );\n    return new LineString(simplifiedFlatCoordinates, 'XY');\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   */\n  getType() {\n    return 'LineString';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   */\n  intersectsExtent(extent) {\n    return intersectsLineString(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      extent\n    );\n  }\n\n  /**\n   * Set the coordinates of the linestring.\n   * @param {!Array<import(\"../coordinate.js\").Coordinate>} coordinates Coordinates.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @api\n   */\n  setCoordinates(coordinates, layout) {\n    this.setLayout(layout, coordinates, 1);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    this.flatCoordinates.length = deflateCoordinates(\n      this.flatCoordinates,\n      0,\n      coordinates,\n      this.stride\n    );\n    this.changed();\n  }\n}\n\nexport default LineString;\n","/**\n * @module ol/geom/MultiLineString\n */\nimport LineString from './LineString.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {arrayMaxSquaredDelta, assignClosestArrayPoint} from './flat/closest.js';\nimport {closestSquaredDistanceXY} from '../extent.js';\nimport {deflateCoordinatesArray} from './flat/deflate.js';\nimport {douglasPeuckerArray} from './flat/simplify.js';\nimport {extend} from '../array.js';\nimport {inflateCoordinatesArray} from './flat/inflate.js';\nimport {\n  interpolatePoint,\n  lineStringsCoordinateAtM,\n} from './flat/interpolate.js';\nimport {intersectsLineStringArray} from './flat/intersectsextent.js';\n\n/**\n * @classdesc\n * Multi-linestring geometry.\n *\n * @api\n */\nclass MultiLineString extends SimpleGeometry {\n  /**\n   * @param {Array<Array<import(\"../coordinate.js\").Coordinate>|LineString>|Array<number>} coordinates\n   *     Coordinates or LineString geometries. (For internal use, flat coordinates in\n   *     combination with `layout` and `ends` are also accepted.)\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @param {Array<number>} [ends] Flat coordinate ends for internal use.\n   */\n  constructor(coordinates, layout, ends) {\n    super();\n\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    this.ends_ = [];\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n\n    if (Array.isArray(coordinates[0])) {\n      this.setCoordinates(\n        /** @type {Array<Array<import(\"../coordinate.js\").Coordinate>>} */ (\n          coordinates\n        ),\n        layout\n      );\n    } else if (layout !== undefined && ends) {\n      this.setFlatCoordinates(\n        layout,\n        /** @type {Array<number>} */ (coordinates)\n      );\n      this.ends_ = ends;\n    } else {\n      let layout = this.getLayout();\n      const lineStrings = /** @type {Array<LineString>} */ (coordinates);\n      const flatCoordinates = [];\n      const ends = [];\n      for (let i = 0, ii = lineStrings.length; i < ii; ++i) {\n        const lineString = lineStrings[i];\n        if (i === 0) {\n          layout = lineString.getLayout();\n        }\n        extend(flatCoordinates, lineString.getFlatCoordinates());\n        ends.push(flatCoordinates.length);\n      }\n      this.setFlatCoordinates(layout, flatCoordinates);\n      this.ends_ = ends;\n    }\n  }\n\n  /**\n   * Append the passed linestring to the multilinestring.\n   * @param {LineString} lineString LineString.\n   * @api\n   */\n  appendLineString(lineString) {\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = lineString.getFlatCoordinates().slice();\n    } else {\n      extend(this.flatCoordinates, lineString.getFlatCoordinates().slice());\n    }\n    this.ends_.push(this.flatCoordinates.length);\n    this.changed();\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!MultiLineString} Clone.\n   * @api\n   */\n  clone() {\n    const multiLineString = new MultiLineString(\n      this.flatCoordinates.slice(),\n      this.layout,\n      this.ends_.slice()\n    );\n    multiLineString.applyProperties(this);\n    return multiLineString;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(\n        arrayMaxSquaredDelta(\n          this.flatCoordinates,\n          0,\n          this.ends_,\n          this.stride,\n          0\n        )\n      );\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestArrayPoint(\n      this.flatCoordinates,\n      0,\n      this.ends_,\n      this.stride,\n      this.maxDelta_,\n      false,\n      x,\n      y,\n      closestPoint,\n      minSquaredDistance\n    );\n  }\n\n  /**\n   * Returns the coordinate at `m` using linear interpolation, or `null` if no\n   * such coordinate exists.\n   *\n   * `extrapolate` controls extrapolation beyond the range of Ms in the\n   * MultiLineString. If `extrapolate` is `true` then Ms less than the first\n   * M will return the first coordinate and Ms greater than the last M will\n   * return the last coordinate.\n   *\n   * `interpolate` controls interpolation between consecutive LineStrings\n   * within the MultiLineString. If `interpolate` is `true` the coordinates\n   * will be linearly interpolated between the last coordinate of one LineString\n   * and the first coordinate of the next LineString.  If `interpolate` is\n   * `false` then the function will return `null` for Ms falling between\n   * LineStrings.\n   *\n   * @param {number} m M.\n   * @param {boolean} [extrapolate] Extrapolate. Default is `false`.\n   * @param {boolean} [interpolate] Interpolate. Default is `false`.\n   * @return {import(\"../coordinate.js\").Coordinate|null} Coordinate.\n   * @api\n   */\n  getCoordinateAtM(m, extrapolate, interpolate) {\n    if (\n      (this.layout != 'XYM' && this.layout != 'XYZM') ||\n      this.flatCoordinates.length === 0\n    ) {\n      return null;\n    }\n    extrapolate = extrapolate !== undefined ? extrapolate : false;\n    interpolate = interpolate !== undefined ? interpolate : false;\n    return lineStringsCoordinateAtM(\n      this.flatCoordinates,\n      0,\n      this.ends_,\n      this.stride,\n      m,\n      extrapolate,\n      interpolate\n    );\n  }\n\n  /**\n   * Return the coordinates of the multilinestring.\n   * @return {Array<Array<import(\"../coordinate.js\").Coordinate>>} Coordinates.\n   * @api\n   */\n  getCoordinates() {\n    return inflateCoordinatesArray(\n      this.flatCoordinates,\n      0,\n      this.ends_,\n      this.stride\n    );\n  }\n\n  /**\n   * @return {Array<number>} Ends.\n   */\n  getEnds() {\n    return this.ends_;\n  }\n\n  /**\n   * Return the linestring at the specified index.\n   * @param {number} index Index.\n   * @return {LineString} LineString.\n   * @api\n   */\n  getLineString(index) {\n    if (index < 0 || this.ends_.length <= index) {\n      return null;\n    }\n    return new LineString(\n      this.flatCoordinates.slice(\n        index === 0 ? 0 : this.ends_[index - 1],\n        this.ends_[index]\n      ),\n      this.layout\n    );\n  }\n\n  /**\n   * Return the linestrings of this multilinestring.\n   * @return {Array<LineString>} LineStrings.\n   * @api\n   */\n  getLineStrings() {\n    const flatCoordinates = this.flatCoordinates;\n    const ends = this.ends_;\n    const layout = this.layout;\n    /** @type {Array<LineString>} */\n    const lineStrings = [];\n    let offset = 0;\n    for (let i = 0, ii = ends.length; i < ii; ++i) {\n      const end = ends[i];\n      const lineString = new LineString(\n        flatCoordinates.slice(offset, end),\n        layout\n      );\n      lineStrings.push(lineString);\n      offset = end;\n    }\n    return lineStrings;\n  }\n\n  /**\n   * @return {Array<number>} Flat midpoints.\n   */\n  getFlatMidpoints() {\n    const midpoints = [];\n    const flatCoordinates = this.flatCoordinates;\n    let offset = 0;\n    const ends = this.ends_;\n    const stride = this.stride;\n    for (let i = 0, ii = ends.length; i < ii; ++i) {\n      const end = ends[i];\n      const midpoint = interpolatePoint(\n        flatCoordinates,\n        offset,\n        end,\n        stride,\n        0.5\n      );\n      extend(midpoints, midpoint);\n      offset = end;\n    }\n    return midpoints;\n  }\n\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {MultiLineString} Simplified MultiLineString.\n   * @protected\n   */\n  getSimplifiedGeometryInternal(squaredTolerance) {\n    const simplifiedFlatCoordinates = [];\n    const simplifiedEnds = [];\n    simplifiedFlatCoordinates.length = douglasPeuckerArray(\n      this.flatCoordinates,\n      0,\n      this.ends_,\n      this.stride,\n      squaredTolerance,\n      simplifiedFlatCoordinates,\n      0,\n      simplifiedEnds\n    );\n    return new MultiLineString(simplifiedFlatCoordinates, 'XY', simplifiedEnds);\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   */\n  getType() {\n    return 'MultiLineString';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   */\n  intersectsExtent(extent) {\n    return intersectsLineStringArray(\n      this.flatCoordinates,\n      0,\n      this.ends_,\n      this.stride,\n      extent\n    );\n  }\n\n  /**\n   * Set the coordinates of the multilinestring.\n   * @param {!Array<Array<import(\"../coordinate.js\").Coordinate>>} coordinates Coordinates.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @api\n   */\n  setCoordinates(coordinates, layout) {\n    this.setLayout(layout, coordinates, 2);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    const ends = deflateCoordinatesArray(\n      this.flatCoordinates,\n      0,\n      coordinates,\n      this.stride,\n      this.ends_\n    );\n    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];\n    this.changed();\n  }\n}\n\nexport default MultiLineString;\n","/**\n * @module ol/geom/MultiPoint\n */\nimport Point from './Point.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {closestSquaredDistanceXY, containsXY} from '../extent.js';\nimport {deflateCoordinates} from './flat/deflate.js';\nimport {extend} from '../array.js';\nimport {inflateCoordinates} from './flat/inflate.js';\nimport {squaredDistance as squaredDx} from '../math.js';\n\n/**\n * @classdesc\n * Multi-point geometry.\n *\n * @api\n */\nclass MultiPoint extends SimpleGeometry {\n  /**\n   * @param {Array<import(\"../coordinate.js\").Coordinate>|Array<number>} coordinates Coordinates.\n   *     For internal use, flat coordinates in combination with `layout` are also accepted.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   */\n  constructor(coordinates, layout) {\n    super();\n    if (layout && !Array.isArray(coordinates[0])) {\n      this.setFlatCoordinates(\n        layout,\n        /** @type {Array<number>} */ (coordinates)\n      );\n    } else {\n      this.setCoordinates(\n        /** @type {Array<import(\"../coordinate.js\").Coordinate>} */ (\n          coordinates\n        ),\n        layout\n      );\n    }\n  }\n\n  /**\n   * Append the passed point to this multipoint.\n   * @param {Point} point Point.\n   * @api\n   */\n  appendPoint(point) {\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = point.getFlatCoordinates().slice();\n    } else {\n      extend(this.flatCoordinates, point.getFlatCoordinates());\n    }\n    this.changed();\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!MultiPoint} Clone.\n   * @api\n   */\n  clone() {\n    const multiPoint = new MultiPoint(\n      this.flatCoordinates.slice(),\n      this.layout\n    );\n    multiPoint.applyProperties(this);\n    return multiPoint;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    const flatCoordinates = this.flatCoordinates;\n    const stride = this.stride;\n    for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n      const squaredDistance = squaredDx(\n        x,\n        y,\n        flatCoordinates[i],\n        flatCoordinates[i + 1]\n      );\n      if (squaredDistance < minSquaredDistance) {\n        minSquaredDistance = squaredDistance;\n        for (let j = 0; j < stride; ++j) {\n          closestPoint[j] = flatCoordinates[i + j];\n        }\n        closestPoint.length = stride;\n      }\n    }\n    return minSquaredDistance;\n  }\n\n  /**\n   * Return the coordinates of the multipoint.\n   * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates.\n   * @api\n   */\n  getCoordinates() {\n    return inflateCoordinates(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride\n    );\n  }\n\n  /**\n   * Return the point at the specified index.\n   * @param {number} index Index.\n   * @return {Point} Point.\n   * @api\n   */\n  getPoint(index) {\n    const n = !this.flatCoordinates\n      ? 0\n      : this.flatCoordinates.length / this.stride;\n    if (index < 0 || n <= index) {\n      return null;\n    }\n    return new Point(\n      this.flatCoordinates.slice(\n        index * this.stride,\n        (index + 1) * this.stride\n      ),\n      this.layout\n    );\n  }\n\n  /**\n   * Return the points of this multipoint.\n   * @return {Array<Point>} Points.\n   * @api\n   */\n  getPoints() {\n    const flatCoordinates = this.flatCoordinates;\n    const layout = this.layout;\n    const stride = this.stride;\n    /** @type {Array<Point>} */\n    const points = [];\n    for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n      const point = new Point(flatCoordinates.slice(i, i + stride), layout);\n      points.push(point);\n    }\n    return points;\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   */\n  getType() {\n    return 'MultiPoint';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   */\n  intersectsExtent(extent) {\n    const flatCoordinates = this.flatCoordinates;\n    const stride = this.stride;\n    for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n      const x = flatCoordinates[i];\n      const y = flatCoordinates[i + 1];\n      if (containsXY(extent, x, y)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Set the coordinates of the multipoint.\n   * @param {!Array<import(\"../coordinate.js\").Coordinate>} coordinates Coordinates.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @api\n   */\n  setCoordinates(coordinates, layout) {\n    this.setLayout(layout, coordinates, 1);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    this.flatCoordinates.length = deflateCoordinates(\n      this.flatCoordinates,\n      0,\n      coordinates,\n      this.stride\n    );\n    this.changed();\n  }\n}\n\nexport default MultiPoint;\n","/**\n * @module ol/geom/flat/center\n */\nimport {createEmpty, createOrUpdateFromFlatCoordinates} from '../../extent.js';\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @return {Array<number>} Flat centers.\n */\nexport function linearRingss(flatCoordinates, offset, endss, stride) {\n  const flatCenters = [];\n  let extent = createEmpty();\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    extent = createOrUpdateFromFlatCoordinates(\n      flatCoordinates,\n      offset,\n      ends[0],\n      stride\n    );\n    flatCenters.push((extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2);\n    offset = ends[ends.length - 1];\n  }\n  return flatCenters;\n}\n","/**\n * @module ol/geom/MultiPolygon\n */\nimport MultiPoint from './MultiPoint.js';\nimport Polygon from './Polygon.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {\n  assignClosestMultiArrayPoint,\n  multiArrayMaxSquaredDelta,\n} from './flat/closest.js';\nimport {closestSquaredDistanceXY} from '../extent.js';\nimport {deflateMultiCoordinatesArray} from './flat/deflate.js';\nimport {extend} from '../array.js';\nimport {getInteriorPointsOfMultiArray} from './flat/interiorpoint.js';\nimport {inflateMultiCoordinatesArray} from './flat/inflate.js';\nimport {intersectsLinearRingMultiArray} from './flat/intersectsextent.js';\nimport {\n  linearRingssAreOriented,\n  orientLinearRingsArray,\n} from './flat/orient.js';\nimport {linearRingss as linearRingssArea} from './flat/area.js';\nimport {linearRingss as linearRingssCenter} from './flat/center.js';\nimport {linearRingssContainsXY} from './flat/contains.js';\nimport {quantizeMultiArray} from './flat/simplify.js';\n\n/**\n * @classdesc\n * Multi-polygon geometry.\n *\n * @api\n */\nclass MultiPolygon extends SimpleGeometry {\n  /**\n   * @param {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.\n   *     For internal use, flat coordinates in combination with `layout` and `endss` are also accepted.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @param {Array<Array<number>>} [endss] Array of ends for internal use with flat coordinates.\n   */\n  constructor(coordinates, layout, endss) {\n    super();\n\n    /**\n     * @type {Array<Array<number>>}\n     * @private\n     */\n    this.endss_ = [];\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.flatInteriorPointsRevision_ = -1;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.flatInteriorPoints_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.orientedRevision_ = -1;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.orientedFlatCoordinates_ = null;\n\n    if (!endss && !Array.isArray(coordinates[0])) {\n      let thisLayout = this.getLayout();\n      const polygons = /** @type {Array<Polygon>} */ (coordinates);\n      const flatCoordinates = [];\n      const thisEndss = [];\n      for (let i = 0, ii = polygons.length; i < ii; ++i) {\n        const polygon = polygons[i];\n        if (i === 0) {\n          thisLayout = polygon.getLayout();\n        }\n        const offset = flatCoordinates.length;\n        const ends = polygon.getEnds();\n        for (let j = 0, jj = ends.length; j < jj; ++j) {\n          ends[j] += offset;\n        }\n        extend(flatCoordinates, polygon.getFlatCoordinates());\n        thisEndss.push(ends);\n      }\n      layout = thisLayout;\n      coordinates = flatCoordinates;\n      endss = thisEndss;\n    }\n    if (layout !== undefined && endss) {\n      this.setFlatCoordinates(\n        layout,\n        /** @type {Array<number>} */ (coordinates)\n      );\n      this.endss_ = endss;\n    } else {\n      this.setCoordinates(\n        /** @type {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} */ (\n          coordinates\n        ),\n        layout\n      );\n    }\n  }\n\n  /**\n   * Append the passed polygon to this multipolygon.\n   * @param {Polygon} polygon Polygon.\n   * @api\n   */\n  appendPolygon(polygon) {\n    /** @type {Array<number>} */\n    let ends;\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = polygon.getFlatCoordinates().slice();\n      ends = polygon.getEnds().slice();\n      this.endss_.push();\n    } else {\n      const offset = this.flatCoordinates.length;\n      extend(this.flatCoordinates, polygon.getFlatCoordinates());\n      ends = polygon.getEnds().slice();\n      for (let i = 0, ii = ends.length; i < ii; ++i) {\n        ends[i] += offset;\n      }\n    }\n    this.endss_.push(ends);\n    this.changed();\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!MultiPolygon} Clone.\n   * @api\n   */\n  clone() {\n    const len = this.endss_.length;\n    const newEndss = new Array(len);\n    for (let i = 0; i < len; ++i) {\n      newEndss[i] = this.endss_[i].slice();\n    }\n\n    const multiPolygon = new MultiPolygon(\n      this.flatCoordinates.slice(),\n      this.layout,\n      newEndss\n    );\n    multiPolygon.applyProperties(this);\n\n    return multiPolygon;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(\n        multiArrayMaxSquaredDelta(\n          this.flatCoordinates,\n          0,\n          this.endss_,\n          this.stride,\n          0\n        )\n      );\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestMultiArrayPoint(\n      this.getOrientedFlatCoordinates(),\n      0,\n      this.endss_,\n      this.stride,\n      this.maxDelta_,\n      true,\n      x,\n      y,\n      closestPoint,\n      minSquaredDistance\n    );\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @return {boolean} Contains (x, y).\n   */\n  containsXY(x, y) {\n    return linearRingssContainsXY(\n      this.getOrientedFlatCoordinates(),\n      0,\n      this.endss_,\n      this.stride,\n      x,\n      y\n    );\n  }\n\n  /**\n   * Return the area of the multipolygon on projected plane.\n   * @return {number} Area (on projected plane).\n   * @api\n   */\n  getArea() {\n    return linearRingssArea(\n      this.getOrientedFlatCoordinates(),\n      0,\n      this.endss_,\n      this.stride\n    );\n  }\n\n  /**\n   * Get the coordinate array for this geometry.  This array has the structure\n   * of a GeoJSON coordinate array for multi-polygons.\n   *\n   * @param {boolean} [right] Orient coordinates according to the right-hand\n   *     rule (counter-clockwise for exterior and clockwise for interior rings).\n   *     If `false`, coordinates will be oriented according to the left-hand rule\n   *     (clockwise for exterior and counter-clockwise for interior rings).\n   *     By default, coordinate orientation will depend on how the geometry was\n   *     constructed.\n   * @return {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} Coordinates.\n   * @api\n   */\n  getCoordinates(right) {\n    let flatCoordinates;\n    if (right !== undefined) {\n      flatCoordinates = this.getOrientedFlatCoordinates().slice();\n      orientLinearRingsArray(\n        flatCoordinates,\n        0,\n        this.endss_,\n        this.stride,\n        right\n      );\n    } else {\n      flatCoordinates = this.flatCoordinates;\n    }\n\n    return inflateMultiCoordinatesArray(\n      flatCoordinates,\n      0,\n      this.endss_,\n      this.stride\n    );\n  }\n\n  /**\n   * @return {Array<Array<number>>} Endss.\n   */\n  getEndss() {\n    return this.endss_;\n  }\n\n  /**\n   * @return {Array<number>} Flat interior points.\n   */\n  getFlatInteriorPoints() {\n    if (this.flatInteriorPointsRevision_ != this.getRevision()) {\n      const flatCenters = linearRingssCenter(\n        this.flatCoordinates,\n        0,\n        this.endss_,\n        this.stride\n      );\n      this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(\n        this.getOrientedFlatCoordinates(),\n        0,\n        this.endss_,\n        this.stride,\n        flatCenters\n      );\n      this.flatInteriorPointsRevision_ = this.getRevision();\n    }\n    return this.flatInteriorPoints_;\n  }\n\n  /**\n   * Return the interior points as {@link module:ol/geom/MultiPoint~MultiPoint multipoint}.\n   * @return {MultiPoint} Interior points as XYM coordinates, where M is\n   * the length of the horizontal intersection that the point belongs to.\n   * @api\n   */\n  getInteriorPoints() {\n    return new MultiPoint(this.getFlatInteriorPoints().slice(), 'XYM');\n  }\n\n  /**\n   * @return {Array<number>} Oriented flat coordinates.\n   */\n  getOrientedFlatCoordinates() {\n    if (this.orientedRevision_ != this.getRevision()) {\n      const flatCoordinates = this.flatCoordinates;\n      if (\n        linearRingssAreOriented(flatCoordinates, 0, this.endss_, this.stride)\n      ) {\n        this.orientedFlatCoordinates_ = flatCoordinates;\n      } else {\n        this.orientedFlatCoordinates_ = flatCoordinates.slice();\n        this.orientedFlatCoordinates_.length = orientLinearRingsArray(\n          this.orientedFlatCoordinates_,\n          0,\n          this.endss_,\n          this.stride\n        );\n      }\n      this.orientedRevision_ = this.getRevision();\n    }\n    return this.orientedFlatCoordinates_;\n  }\n\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {MultiPolygon} Simplified MultiPolygon.\n   * @protected\n   */\n  getSimplifiedGeometryInternal(squaredTolerance) {\n    const simplifiedFlatCoordinates = [];\n    const simplifiedEndss = [];\n    simplifiedFlatCoordinates.length = quantizeMultiArray(\n      this.flatCoordinates,\n      0,\n      this.endss_,\n      this.stride,\n      Math.sqrt(squaredTolerance),\n      simplifiedFlatCoordinates,\n      0,\n      simplifiedEndss\n    );\n    return new MultiPolygon(simplifiedFlatCoordinates, 'XY', simplifiedEndss);\n  }\n\n  /**\n   * Return the polygon at the specified index.\n   * @param {number} index Index.\n   * @return {Polygon} Polygon.\n   * @api\n   */\n  getPolygon(index) {\n    if (index < 0 || this.endss_.length <= index) {\n      return null;\n    }\n    let offset;\n    if (index === 0) {\n      offset = 0;\n    } else {\n      const prevEnds = this.endss_[index - 1];\n      offset = prevEnds[prevEnds.length - 1];\n    }\n    const ends = this.endss_[index].slice();\n    const end = ends[ends.length - 1];\n    if (offset !== 0) {\n      for (let i = 0, ii = ends.length; i < ii; ++i) {\n        ends[i] -= offset;\n      }\n    }\n    return new Polygon(\n      this.flatCoordinates.slice(offset, end),\n      this.layout,\n      ends\n    );\n  }\n\n  /**\n   * Return the polygons of this multipolygon.\n   * @return {Array<Polygon>} Polygons.\n   * @api\n   */\n  getPolygons() {\n    const layout = this.layout;\n    const flatCoordinates = this.flatCoordinates;\n    const endss = this.endss_;\n    const polygons = [];\n    let offset = 0;\n    for (let i = 0, ii = endss.length; i < ii; ++i) {\n      const ends = endss[i].slice();\n      const end = ends[ends.length - 1];\n      if (offset !== 0) {\n        for (let j = 0, jj = ends.length; j < jj; ++j) {\n          ends[j] -= offset;\n        }\n      }\n      const polygon = new Polygon(\n        flatCoordinates.slice(offset, end),\n        layout,\n        ends\n      );\n      polygons.push(polygon);\n      offset = end;\n    }\n    return polygons;\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   */\n  getType() {\n    return 'MultiPolygon';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   */\n  intersectsExtent(extent) {\n    return intersectsLinearRingMultiArray(\n      this.getOrientedFlatCoordinates(),\n      0,\n      this.endss_,\n      this.stride,\n      extent\n    );\n  }\n\n  /**\n   * Set the coordinates of the multipolygon.\n   * @param {!Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} coordinates Coordinates.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @api\n   */\n  setCoordinates(coordinates, layout) {\n    this.setLayout(layout, coordinates, 3);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    const endss = deflateMultiCoordinatesArray(\n      this.flatCoordinates,\n      0,\n      coordinates,\n      this.stride,\n      this.endss_\n    );\n    if (endss.length === 0) {\n      this.flatCoordinates.length = 0;\n    } else {\n      const lastEnds = endss[endss.length - 1];\n      this.flatCoordinates.length =\n        lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];\n    }\n    this.changed();\n  }\n}\n\nexport default MultiPolygon;\n","/**\n * @module ol/geom/flat/interpolate\n */\nimport {binarySearch} from '../../array.js';\nimport {lerp} from '../../math.js';\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} fraction Fraction.\n * @param {Array<number>} [dest] Destination.\n * @param {number} [dimension] Destination dimension (default is `2`)\n * @return {Array<number>} Destination.\n */\nexport function interpolatePoint(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  fraction,\n  dest,\n  dimension\n) {\n  let o, t;\n  const n = (end - offset) / stride;\n  if (n === 1) {\n    o = offset;\n  } else if (n === 2) {\n    o = offset;\n    t = fraction;\n  } else if (n !== 0) {\n    let x1 = flatCoordinates[offset];\n    let y1 = flatCoordinates[offset + 1];\n    let length = 0;\n    const cumulativeLengths = [0];\n    for (let i = offset + stride; i < end; i += stride) {\n      const x2 = flatCoordinates[i];\n      const y2 = flatCoordinates[i + 1];\n      length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n      cumulativeLengths.push(length);\n      x1 = x2;\n      y1 = y2;\n    }\n    const target = fraction * length;\n    const index = binarySearch(cumulativeLengths, target);\n    if (index < 0) {\n      t =\n        (target - cumulativeLengths[-index - 2]) /\n        (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);\n      o = offset + (-index - 2) * stride;\n    } else {\n      o = offset + index * stride;\n    }\n  }\n  dimension = dimension > 1 ? dimension : 2;\n  dest = dest ? dest : new Array(dimension);\n  for (let i = 0; i < dimension; ++i) {\n    dest[i] =\n      o === undefined\n        ? NaN\n        : t === undefined\n        ? flatCoordinates[o + i]\n        : lerp(flatCoordinates[o + i], flatCoordinates[o + stride + i], t);\n  }\n  return dest;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @return {import(\"../../coordinate.js\").Coordinate|null} Coordinate.\n */\nexport function lineStringCoordinateAtM(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  m,\n  extrapolate\n) {\n  if (end == offset) {\n    return null;\n  }\n  let coordinate;\n  if (m < flatCoordinates[offset + stride - 1]) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(offset, offset + stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    }\n    return null;\n  } else if (flatCoordinates[end - 1] < m) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(end - stride, end);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    }\n    return null;\n  }\n  // FIXME use O(1) search\n  if (m == flatCoordinates[offset + stride - 1]) {\n    return flatCoordinates.slice(offset, offset + stride);\n  }\n  let lo = offset / stride;\n  let hi = end / stride;\n  while (lo < hi) {\n    const mid = (lo + hi) >> 1;\n    if (m < flatCoordinates[(mid + 1) * stride - 1]) {\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n  const m0 = flatCoordinates[lo * stride - 1];\n  if (m == m0) {\n    return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);\n  }\n  const m1 = flatCoordinates[(lo + 1) * stride - 1];\n  const t = (m - m0) / (m1 - m0);\n  coordinate = [];\n  for (let i = 0; i < stride - 1; ++i) {\n    coordinate.push(\n      lerp(\n        flatCoordinates[(lo - 1) * stride + i],\n        flatCoordinates[lo * stride + i],\n        t\n      )\n    );\n  }\n  coordinate.push(m);\n  return coordinate;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @param {boolean} interpolate Interpolate.\n * @return {import(\"../../coordinate.js\").Coordinate|null} Coordinate.\n */\nexport function lineStringsCoordinateAtM(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  m,\n  extrapolate,\n  interpolate\n) {\n  if (interpolate) {\n    return lineStringCoordinateAtM(\n      flatCoordinates,\n      offset,\n      ends[ends.length - 1],\n      stride,\n      m,\n      extrapolate\n    );\n  }\n  let coordinate;\n  if (m < flatCoordinates[stride - 1]) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(0, stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    }\n    return null;\n  }\n  if (flatCoordinates[flatCoordinates.length - 1] < m) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(flatCoordinates.length - stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    }\n    return null;\n  }\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    if (offset == end) {\n      continue;\n    }\n    if (m < flatCoordinates[offset + stride - 1]) {\n      return null;\n    } else if (m <= flatCoordinates[end - 1]) {\n      return lineStringCoordinateAtM(\n        flatCoordinates,\n        offset,\n        end,\n        stride,\n        m,\n        false\n      );\n    }\n    offset = end;\n  }\n  return null;\n}\n","/**\n * @module ol/interaction/Select\n */\nimport Collection from '../Collection.js';\nimport CollectionEventType from '../CollectionEventType.js';\nimport Event from '../events/Event.js';\nimport Feature from '../Feature.js';\nimport Interaction from './Interaction.js';\nimport VectorLayer from '../layer/Vector.js';\nimport {TRUE} from '../functions.js';\nimport {clear} from '../obj.js';\nimport {createEditingStyle} from '../style/Style.js';\nimport {extend} from '../array.js';\nimport {getUid} from '../util.js';\nimport {never, shiftKeyOnly, singleClick} from '../events/condition.js';\n\n/**\n * @enum {string}\n */\nconst SelectEventType = {\n  /**\n   * Triggered when feature(s) has been (de)selected.\n   * @event SelectEvent#select\n   * @api\n   */\n  SELECT: 'select',\n};\n\n/**\n * A function that takes an {@link module:ol/Feature~Feature} and returns `true` if the feature may be\n * selected or `false` otherwise.\n * @typedef {function(import(\"../Feature.js\").default, import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>):boolean} FilterFunction\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../events/condition.js\").Condition} [addCondition] A function\n * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * By default, this is {@link module:ol/events/condition.never}. Use this if you\n * want to use different events for add and remove instead of `toggle`.\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled. This is the event\n * for the selected features as a whole. By default, this is\n * {@link module:ol/events/condition.singleClick}. Clicking on a feature selects that\n * feature and removes any that were in the selection. Clicking outside any\n * feature removes all from the selection.\n * See `toggle`, `add`, `remove` options for adding/removing extra features to/\n * from the selection.\n * @property {Array<import(\"../layer/Layer.js\").default>|function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean} [layers]\n * A list of layers from which features should be selected. Alternatively, a\n * filter function can be provided. The function will be called for each layer\n * in the map and should return `true` for layers that you want to be\n * selectable. If the option is absent, all visible layers will be considered\n * selectable.\n * @property {import(\"../style/Style.js\").StyleLike|null} [style]\n * Style for the selected features. By default the default edit style is used\n * (see {@link module:ol/style/Style~Style}). Set to `null` if this interaction should not apply\n * any style changes for selected features.\n * If set to a falsey value, the selected feature's style will not change.\n * @property {import(\"../events/condition.js\").Condition} [removeCondition] A function\n * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * By default, this is {@link module:ol/events/condition.never}. Use this if you\n * want to use different events for add and remove instead of `toggle`.\n * @property {import(\"../events/condition.js\").Condition} [toggleCondition] A function\n * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled. This is in addition\n * to the `condition` event. By default,\n * {@link module:ol/events/condition.shiftKeyOnly}, i.e. pressing `shift` as\n * well as the `condition` event, adds that feature to the current selection if\n * it is not currently selected, and removes it if it is. See `add` and `remove`\n * if you want to use different events instead of a toggle.\n * @property {boolean} [multi=false] A boolean that determines if the default\n * behaviour should select only single features or all (overlapping) features at\n * the clicked map position. The default of `false` means single select.\n * @property {Collection<Feature>} [features]\n * Collection where the interaction will place selected features. Optional. If\n * not set the interaction will create a collection. In any case the collection\n * used by the interaction is returned by\n * {@link module:ol/interaction/Select~Select#getFeatures}.\n * @property {FilterFunction} [filter] A function\n * that takes an {@link module:ol/Feature~Feature} and an\n * {@link module:ol/layer/Layer~Layer} and returns `true` if the feature may be\n * selected or `false` otherwise.\n * @property {number} [hitTolerance=0] Hit-detection tolerance. Pixels inside\n * the radius around the given position will be checked for features.\n */\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/Select~Select} instances are instances of\n * this type.\n */\nexport class SelectEvent extends Event {\n  /**\n   * @param {SelectEventType} type The event type.\n   * @param {Array<import(\"../Feature.js\").default>} selected Selected features.\n   * @param {Array<import(\"../Feature.js\").default>} deselected Deselected features.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Associated\n   *     {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\n   */\n  constructor(type, selected, deselected, mapBrowserEvent) {\n    super(type);\n\n    /**\n     * Selected features array.\n     * @type {Array<import(\"../Feature.js\").default>}\n     * @api\n     */\n    this.selected = selected;\n\n    /**\n     * Deselected features array.\n     * @type {Array<import(\"../Feature.js\").default>}\n     * @api\n     */\n    this.deselected = deselected;\n\n    /**\n     * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\n     * @type {import(\"../MapBrowserEvent.js\").default}\n     * @api\n     */\n    this.mapBrowserEvent = mapBrowserEvent;\n  }\n}\n\n/**\n * Original feature styles to reset to when features are no longer selected.\n * @type {Object<number, import(\"../style/Style.js\").default|Array<import(\"../style/Style.js\").default>|import(\"../style/Style.js\").StyleFunction>}\n */\nconst originalFeatureStyles = {};\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'select', SelectEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'select', Return>} SelectOnSignature\n */\n\n/**\n * @classdesc\n * Interaction for selecting vector features. By default, selected features are\n * styled differently, so this interaction can be used for visual highlighting,\n * as well as selecting features for other actions, such as modification or\n * output. There are three ways of controlling which features are selected:\n * using the browser event as defined by the `condition` and optionally the\n * `toggle`, `add`/`remove`, and `multi` options; a `layers` filter; and a\n * further feature filter using the `filter` option.\n *\n * @fires SelectEvent\n * @api\n */\nclass Select extends Interaction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n\n    /***\n     * @type {SelectOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {SelectOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {SelectOnSignature<void>}\n     */\n    this.un;\n\n    options = options ? options : {};\n\n    /**\n     * @private\n     */\n    this.boundAddFeature_ = this.addFeature_.bind(this);\n\n    /**\n     * @private\n     */\n    this.boundRemoveFeature_ = this.removeFeature_.bind(this);\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.condition_ = options.condition ? options.condition : singleClick;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.addCondition_ = options.addCondition ? options.addCondition : never;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.removeCondition_ = options.removeCondition\n      ? options.removeCondition\n      : never;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.toggleCondition_ = options.toggleCondition\n      ? options.toggleCondition\n      : shiftKeyOnly;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.multi_ = options.multi ? options.multi : false;\n\n    /**\n     * @private\n     * @type {FilterFunction}\n     */\n    this.filter_ = options.filter ? options.filter : TRUE;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;\n\n    /**\n     * @private\n     * @type {import(\"../style/Style.js\").default|Array<import(\"../style/Style.js\").default>|import(\"../style/Style.js\").StyleFunction|null}\n     */\n    this.style_ =\n      options.style !== undefined ? options.style : getDefaultStyleFunction();\n\n    /**\n     * @private\n     * @type {Collection<Feature>}\n     */\n    this.features_ = options.features || new Collection();\n\n    /** @type {function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean} */\n    let layerFilter;\n    if (options.layers) {\n      if (typeof options.layers === 'function') {\n        layerFilter = options.layers;\n      } else {\n        const layers = options.layers;\n        layerFilter = function (layer) {\n          return layers.includes(layer);\n        };\n      }\n    } else {\n      layerFilter = TRUE;\n    }\n\n    /**\n     * @private\n     * @type {function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean}\n     */\n    this.layerFilter_ = layerFilter;\n\n    /**\n     * An association between selected feature (key)\n     * and layer (value)\n     * @private\n     * @type {Object<string, import(\"../layer/Layer.js\").default>}\n     */\n    this.featureLayerAssociation_ = {};\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"../layer/Layer.js\").default} layer Layer.\n   * @private\n   */\n  addFeatureLayerAssociation_(feature, layer) {\n    this.featureLayerAssociation_[getUid(feature)] = layer;\n  }\n\n  /**\n   * Get the selected features.\n   * @return {Collection<Feature>} Features collection.\n   * @api\n   */\n  getFeatures() {\n    return this.features_;\n  }\n\n  /**\n   * Returns the Hit-detection tolerance.\n   * @return {number} Hit tolerance in pixels.\n   * @api\n   */\n  getHitTolerance() {\n    return this.hitTolerance_;\n  }\n\n  /**\n   * Returns the associated {@link module:ol/layer/Vector~VectorLayer vector layer} of\n   * a selected feature.\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @return {import('../layer/Vector.js').default} Layer.\n   * @api\n   */\n  getLayer(feature) {\n    return /** @type {import('../layer/Vector.js').default} */ (\n      this.featureLayerAssociation_[getUid(feature)]\n    );\n  }\n\n  /**\n   * Hit-detection tolerance. Pixels inside the radius around the given position\n   * will be checked for features.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @api\n   */\n  setHitTolerance(hitTolerance) {\n    this.hitTolerance_ = hitTolerance;\n  }\n\n  /**\n   * Remove the interaction from its current map, if any,  and attach it to a new\n   * map, if any. Pass `null` to just remove the interaction from the current map.\n   * @param {import(\"../Map.js\").default|null} map Map.\n   * @api\n   */\n  setMap(map) {\n    const currentMap = this.getMap();\n    if (currentMap && this.style_) {\n      this.features_.forEach(this.restorePreviousStyle_.bind(this));\n    }\n    super.setMap(map);\n    if (map) {\n      this.features_.addEventListener(\n        CollectionEventType.ADD,\n        this.boundAddFeature_\n      );\n      this.features_.addEventListener(\n        CollectionEventType.REMOVE,\n        this.boundRemoveFeature_\n      );\n\n      if (this.style_) {\n        this.features_.forEach(this.applySelectedStyle_.bind(this));\n      }\n    } else {\n      this.features_.removeEventListener(\n        CollectionEventType.ADD,\n        this.boundAddFeature_\n      );\n      this.features_.removeEventListener(\n        CollectionEventType.REMOVE,\n        this.boundRemoveFeature_\n      );\n    }\n  }\n\n  /**\n   * @param {import(\"../Collection.js\").CollectionEvent<Feature>} evt Event.\n   * @private\n   */\n  addFeature_(evt) {\n    const feature = evt.element;\n    if (this.style_) {\n      this.applySelectedStyle_(feature);\n    }\n    if (!this.getLayer(feature)) {\n      const layer = /** @type {VectorLayer} */ (\n        this.getMap()\n          .getAllLayers()\n          .find(function (layer) {\n            if (\n              layer instanceof VectorLayer &&\n              layer.getSource() &&\n              layer.getSource().hasFeature(feature)\n            ) {\n              return layer;\n            }\n          })\n      );\n      if (layer) {\n        this.addFeatureLayerAssociation_(feature, layer);\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../Collection.js\").CollectionEvent<Feature>} evt Event.\n   * @private\n   */\n  removeFeature_(evt) {\n    if (this.style_) {\n      this.restorePreviousStyle_(evt.element);\n    }\n  }\n\n  /**\n   * @return {import(\"../style/Style.js\").StyleLike|null} Select style.\n   */\n  getStyle() {\n    return this.style_;\n  }\n\n  /**\n   * @param {Feature} feature Feature\n   * @private\n   */\n  applySelectedStyle_(feature) {\n    const key = getUid(feature);\n    if (!(key in originalFeatureStyles)) {\n      originalFeatureStyles[key] = feature.getStyle();\n    }\n    feature.setStyle(this.style_);\n  }\n\n  /**\n   * @param {Feature} feature Feature\n   * @private\n   */\n  restorePreviousStyle_(feature) {\n    const interactions = this.getMap().getInteractions().getArray();\n    for (let i = interactions.length - 1; i >= 0; --i) {\n      const interaction = interactions[i];\n      if (\n        interaction !== this &&\n        interaction instanceof Select &&\n        interaction.getStyle() &&\n        interaction.getFeatures().getArray().lastIndexOf(feature) !== -1\n      ) {\n        feature.setStyle(interaction.getStyle());\n        return;\n      }\n    }\n\n    const key = getUid(feature);\n    feature.setStyle(originalFeatureStyles[key]);\n    delete originalFeatureStyles[key];\n  }\n\n  /**\n   * @param {Feature} feature Feature.\n   * @private\n   */\n  removeFeatureLayerAssociation_(feature) {\n    delete this.featureLayerAssociation_[getUid(feature)];\n  }\n\n  /**\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may change the\n   * selected state of features.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   */\n  handleEvent(mapBrowserEvent) {\n    if (!this.condition_(mapBrowserEvent)) {\n      return true;\n    }\n    const add = this.addCondition_(mapBrowserEvent);\n    const remove = this.removeCondition_(mapBrowserEvent);\n    const toggle = this.toggleCondition_(mapBrowserEvent);\n    const set = !add && !remove && !toggle;\n    const map = mapBrowserEvent.map;\n    const features = this.getFeatures();\n\n    /**\n     * @type {Array<Feature>}\n     */\n    const deselected = [];\n\n    /**\n     * @type {Array<Feature>}\n     */\n    const selected = [];\n\n    if (set) {\n      // Replace the currently selected feature(s) with the feature(s) at the\n      // pixel, or clear the selected feature(s) if there is no feature at\n      // the pixel.\n      clear(this.featureLayerAssociation_);\n      map.forEachFeatureAtPixel(\n        mapBrowserEvent.pixel,\n        /**\n         * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n         * @param {import(\"../layer/Layer.js\").default} layer Layer.\n         * @return {boolean|undefined} Continue to iterate over the features.\n         */\n        (feature, layer) => {\n          if (!(feature instanceof Feature) || !this.filter_(feature, layer)) {\n            return;\n          }\n          this.addFeatureLayerAssociation_(feature, layer);\n          selected.push(feature);\n          return !this.multi_;\n        },\n        {\n          layerFilter: this.layerFilter_,\n          hitTolerance: this.hitTolerance_,\n        }\n      );\n      for (let i = features.getLength() - 1; i >= 0; --i) {\n        const feature = features.item(i);\n        const index = selected.indexOf(feature);\n        if (index > -1) {\n          // feature is already selected\n          selected.splice(index, 1);\n        } else {\n          features.remove(feature);\n          deselected.push(feature);\n        }\n      }\n      if (selected.length !== 0) {\n        features.extend(selected);\n      }\n    } else {\n      // Modify the currently selected feature(s).\n      map.forEachFeatureAtPixel(\n        mapBrowserEvent.pixel,\n        /**\n         * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n         * @param {import(\"../layer/Layer.js\").default} layer Layer.\n         * @return {boolean|undefined} Continue to iterate over the features.\n         */\n        (feature, layer) => {\n          if (!(feature instanceof Feature) || !this.filter_(feature, layer)) {\n            return;\n          }\n          if ((add || toggle) && !features.getArray().includes(feature)) {\n            this.addFeatureLayerAssociation_(feature, layer);\n            selected.push(feature);\n          } else if (\n            (remove || toggle) &&\n            features.getArray().includes(feature)\n          ) {\n            deselected.push(feature);\n            this.removeFeatureLayerAssociation_(feature);\n          }\n          return !this.multi_;\n        },\n        {\n          layerFilter: this.layerFilter_,\n          hitTolerance: this.hitTolerance_,\n        }\n      );\n      for (let j = deselected.length - 1; j >= 0; --j) {\n        features.remove(deselected[j]);\n      }\n      features.extend(selected);\n    }\n    if (selected.length > 0 || deselected.length > 0) {\n      this.dispatchEvent(\n        new SelectEvent(\n          SelectEventType.SELECT,\n          selected,\n          deselected,\n          mapBrowserEvent\n        )\n      );\n    }\n    return true;\n  }\n}\n\n/**\n * @return {import(\"../style/Style.js\").StyleFunction} Styles.\n */\nfunction getDefaultStyleFunction() {\n  const styles = createEditingStyle();\n  extend(styles['Polygon'], styles['LineString']);\n  extend(styles['GeometryCollection'], styles['LineString']);\n\n  return function (feature) {\n    if (!feature.getGeometry()) {\n      return null;\n    }\n    return styles[feature.getGeometry().getType()];\n  };\n}\n\nexport default Select;\n"],"names":["mixins","EventBusMixin","methods","addGeoJson","source","title","hitTolerance","multi","condition","layers","layer","select","onSelect","createGeoJsonSource","features","featureProjection","wrapX","render","staticRenderFns","component","addExtent","footprint","addRectangles","projection","displayInLayerSwitcher","removeLayerFill","style","FeatureFormat","constructor","this","dataProjection","undefined","defaultFeatureProjection","supportedMediaTypes","getReadOptions","options","get","readProjection","extent","getUnits","setWorldExtent","adaptOptions","Object","assign","getType","readFeature","readFeatures","readGeometry","writeFeature","feature","writeFeatures","writeGeometry","geometry","transformGeometryWithOptions","write","transformed","equivalent","clone","transform","decimals","power","Math","pow","coordinates","i","ii","length","round","applyTransform","JSONFeature","super","readFeatureFromObject","getObject","readFeaturesFromObject","object","readGeometryFromObject","readProjectionFromObject","JSON","stringify","writeFeatureObject","writeFeaturesObject","writeGeometryObject","parse","GeoJSON","geometryName_","geometryName","extractGeometryName_","extractGeometryName","geoJSONFeature","Feature","setGeometryName","setGeometry","setId","setProperties","geoJSONObject","geoJSONFeatureCollection","geoJSONFeatures","push","crs","properties","id","getId","hasProperties","getProperties","getGeometry","getGeometryName","objects","type","readPointGeometry","readLineStringGeometry","readPolygonGeometry","readMultiPointGeometry","readMultiLineStringGeometry","readMultiPolygonGeometry","readGeometryCollectionGeometry","Error","geometries","map","GeometryCollection","Point","LineString","MultiLineString","MultiPoint","MultiPolygon","Polygon","geoJSON","writePointGeometry","writeLineStringGeometry","writePolygonGeometry","writeMultiPointGeometry","writeMultiLineStringGeometry","writeMultiPolygonGeometry","writeGeometryCollectionGeometry","getGeometriesArray","getCoordinates","right","rightHanded","geometries_","changeEventsKeys_","listenGeometriesChange_","unlistenGeometriesChange_","forEach","changed","geometryCollection","setGeometries","applyProperties","closestPointXY","x","y","closestPoint","minSquaredDistance","getExtent","containsXY","computeExtent","getGeometries","cloneGeometries","getGeometriesArrayRecursive","geometriesArray","concat","getSimplifiedGeometry","squaredTolerance","simplifiedGeometryRevision","getRevision","simplifiedGeometryMaxMinSquaredTolerance","simplifiedGeometries","simplified","simplifiedGeometry","simplifiedGeometryCollection","setGeometriesArray","intersectsExtent","isEmpty","rotate","angle","anchor","scale","sx","sy","transformFn","translate","deltaX","deltaY","disposeInternal","clonedGeometries","layout","flatMidpoint_","flatMidpointRevision_","maxDelta_","maxDeltaRevision_","Array","isArray","setCoordinates","setFlatCoordinates","appendCoordinate","coordinate","flatCoordinates","slice","lineString","sqrt","stride","forEachSegment","callback","getCoordinateAtM","m","extrapolate","getCoordinateAt","fraction","dest","getLength","getFlatMidpoint","getSimplifiedGeometryInternal","simplifiedFlatCoordinates","setLayout","ends","ends_","getLayout","lineStrings","getFlatCoordinates","appendLineString","multiLineString","interpolate","getEnds","getLineString","index","getLineStrings","offset","end","getFlatMidpoints","midpoints","midpoint","simplifiedEnds","appendPoint","point","multiPoint","squaredDistance","j","getPoint","n","getPoints","points","linearRingss","endss","flatCenters","SimpleGeometry","endss_","flatInteriorPointsRevision_","flatInteriorPoints_","orientedRevision_","orientedFlatCoordinates_","thisLayout","polygons","thisEndss","polygon","jj","appendPolygon","len","newEndss","multiPolygon","getOrientedFlatCoordinates","getArea","orient","inflate","getEndss","getFlatInteriorPoints","getInteriorPoints","simplifiedEndss","getPolygon","prevEnds","getPolygons","deflate","lastEnds","interpolatePoint","dimension","o","t","x1","y1","cumulativeLengths","x2","y2","target","NaN","lineStringCoordinateAtM","lo","hi","mid","m0","m1","lineStringsCoordinateAtM","SelectEventType","SELECT","SelectEvent","selected","deselected","mapBrowserEvent","originalFeatureStyles","Select","layerFilter","on","once","un","boundAddFeature_","addFeature_","bind","boundRemoveFeature_","removeFeature_","condition_","addCondition_","addCondition","removeCondition_","removeCondition","toggleCondition_","toggleCondition","multi_","filter_","filter","hitTolerance_","style_","getDefaultStyleFunction","features_","includes","layerFilter_","featureLayerAssociation_","addFeatureLayerAssociation_","getFeatures","getHitTolerance","getLayer","setHitTolerance","setMap","currentMap","getMap","restorePreviousStyle_","addEventListener","applySelectedStyle_","removeEventListener","evt","element","getAllLayers","find","getSource","hasFeature","getStyle","key","setStyle","interactions","getInteractions","getArray","interaction","lastIndexOf","removeFeatureLayerAssociation_","handleEvent","add","remove","toggle","set","forEachFeatureAtPixel","pixel","item","indexOf","splice","extend","dispatchEvent","styles","createEditingStyle"],"sourceRoot":""}
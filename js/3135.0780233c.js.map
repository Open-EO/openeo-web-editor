{"version":3,"file":"js/3135.0780233c.js","mappings":"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","sources":["webpack://@openeo/web-editor/./node_modules/ol/has.js","webpack://@openeo/web-editor/./node_modules/ol/interaction/Interaction.js","webpack://@openeo/web-editor/./node_modules/ol/interaction/Pointer.js","webpack://@openeo/web-editor/./node_modules/ol/interaction/Property.js","webpack://@openeo/web-editor/./node_modules/ol/interaction/Select.js","webpack://@openeo/web-editor/./node_modules/ol/interaction/DoubleClickZoom.js","webpack://@openeo/web-editor/./node_modules/ol/interaction/DragPan.js","webpack://@openeo/web-editor/./node_modules/ol/interaction/DragRotate.js","webpack://@openeo/web-editor/./node_modules/ol/interaction/DragBox.js","webpack://@openeo/web-editor/./node_modules/ol/interaction/DragZoom.js","webpack://@openeo/web-editor/./node_modules/ol/interaction/KeyboardPan.js","webpack://@openeo/web-editor/./node_modules/ol/interaction/KeyboardZoom.js","webpack://@openeo/web-editor/./node_modules/ol/interaction/MouseWheelZoom.js","webpack://@openeo/web-editor/./node_modules/ol/interaction/PinchRotate.js","webpack://@openeo/web-editor/./node_modules/ol/interaction/PinchZoom.js","webpack://@openeo/web-editor/./node_modules/ol/interaction/defaults.js","webpack://@openeo/web-editor/./node_modules/ol/layer/Base.js","webpack://@openeo/web-editor/./node_modules/ol/layer/BaseTile.js","webpack://@openeo/web-editor/./node_modules/ol/layer/BaseVector.js","webpack://@openeo/web-editor/./node_modules/ol/layer/Group.js","webpack://@openeo/web-editor/./node_modules/ol/layer/Heatmap.js","webpack://@openeo/web-editor/./node_modules/ol/layer/BaseImage.js","webpack://@openeo/web-editor/./node_modules/ol/layer/Image.js","webpack://@openeo/web-editor/./node_modules/ol/layer/Layer.js","webpack://@openeo/web-editor/./node_modules/ol/layer/Property.js","webpack://@openeo/web-editor/./node_modules/ol/layer/Tile.js","webpack://@openeo/web-editor/./node_modules/ol/layer/TileProperty.js","webpack://@openeo/web-editor/./node_modules/ol/layer/Vector.js","webpack://@openeo/web-editor/./node_modules/ol/layer/VectorTile.js","webpack://@openeo/web-editor/./node_modules/ol/loadingstrategy.js","webpack://@openeo/web-editor/./node_modules/ol/obj.js"],"sourcesContent":["/**\n * @module ol/has\n */\n\nconst ua =\n  typeof navigator !== 'undefined' && typeof navigator.userAgent !== 'undefined'\n    ? navigator.userAgent.toLowerCase()\n    : '';\n\n/**\n * User agent string says we are dealing with Firefox as browser.\n * @type {boolean}\n */\nexport const FIREFOX = ua.includes('firefox');\n\n/**\n * User agent string says we are dealing with Safari as browser.\n * @type {boolean}\n */\nexport const SAFARI = ua.includes('safari') && !ua.includes('chrom');\n\n/**\n * https://bugs.webkit.org/show_bug.cgi?id=237906\n * @type {boolean}\n */\nexport const SAFARI_BUG_237906 =\n  SAFARI &&\n  (ua.includes('version/15.4') ||\n    /cpu (os|iphone os) 15_4 like mac os x/.test(ua));\n\n/**\n * User agent string says we are dealing with a WebKit engine.\n * @type {boolean}\n */\nexport const WEBKIT = ua.includes('webkit') && !ua.includes('edge');\n\n/**\n * User agent string says we are dealing with a Mac as platform.\n * @type {boolean}\n */\nexport const MAC = ua.includes('macintosh');\n\n/**\n * The ratio between physical pixels and device-independent pixels\n * (dips) on the device (`window.devicePixelRatio`).\n * @const\n * @type {number}\n * @api\n */\nexport const DEVICE_PIXEL_RATIO =\n  typeof devicePixelRatio !== 'undefined' ? devicePixelRatio : 1;\n\n/**\n * The execution context is a worker with OffscreenCanvas available.\n * @const\n * @type {boolean}\n */\nexport const WORKER_OFFSCREEN_CANVAS =\n  typeof WorkerGlobalScope !== 'undefined' &&\n  typeof OffscreenCanvas !== 'undefined' &&\n  self instanceof WorkerGlobalScope; //eslint-disable-line\n\n/**\n * Image.prototype.decode() is supported.\n * @type {boolean}\n */\nexport const IMAGE_DECODE =\n  typeof Image !== 'undefined' && Image.prototype.decode;\n\n/**\n * @type {boolean}\n */\nexport const PASSIVE_EVENT_LISTENERS = (function () {\n  let passive = false;\n  try {\n    const options = Object.defineProperty({}, 'passive', {\n      get: function () {\n        passive = true;\n      },\n    });\n\n    window.addEventListener('_', null, options);\n    window.removeEventListener('_', null, options);\n  } catch (error) {\n    // passive not supported\n  }\n  return passive;\n})();\n","/**\n * @module ol/interaction/Interaction\n */\nimport BaseObject from '../Object.js';\nimport InteractionProperty from './Property.js';\nimport {easeOut, linear} from '../easing.js';\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active', Return>} InteractionOnSignature\n */\n\n/**\n * Object literal with config options for interactions.\n * @typedef {Object} InteractionOptions\n * @property {function(import(\"../MapBrowserEvent.js\").default):boolean} handleEvent\n * Method called by the map to notify the interaction that a browser event was\n * dispatched to the map. If the function returns a falsy value, propagation of\n * the event to other interactions in the map's interactions chain will be\n * prevented (this includes functions with no explicit return). The interactions\n * are traversed in reverse order of the interactions collection of the map.\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * User actions that change the state of the map. Some are similar to controls,\n * but are not associated with a DOM element.\n * For example, {@link module:ol/interaction/KeyboardZoom~KeyboardZoom} is\n * functionally the same as {@link module:ol/control/Zoom~Zoom}, but triggered\n * by a keyboard event not a button element event.\n * Although interactions do not have a DOM element, some of them do render\n * vectors and so are visible on the screen.\n * @api\n */\nclass Interaction extends BaseObject {\n  /**\n   * @param {InteractionOptions} [options] Options.\n   */\n  constructor(options) {\n    super();\n\n    /***\n     * @type {InteractionOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {InteractionOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {InteractionOnSignature<void>}\n     */\n    this.un;\n\n    if (options && options.handleEvent) {\n      this.handleEvent = options.handleEvent;\n    }\n\n    /**\n     * @private\n     * @type {import(\"../Map.js\").default|null}\n     */\n    this.map_ = null;\n\n    this.setActive(true);\n  }\n\n  /**\n   * Return whether the interaction is currently active.\n   * @return {boolean} `true` if the interaction is active, `false` otherwise.\n   * @observable\n   * @api\n   */\n  getActive() {\n    return /** @type {boolean} */ (this.get(InteractionProperty.ACTIVE));\n  }\n\n  /**\n   * Get the map associated with this interaction.\n   * @return {import(\"../Map.js\").default|null} Map.\n   * @api\n   */\n  getMap() {\n    return this.map_;\n  }\n\n  /**\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event}.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   * @api\n   */\n  handleEvent(mapBrowserEvent) {\n    return true;\n  }\n\n  /**\n   * Activate or deactivate the interaction.\n   * @param {boolean} active Active.\n   * @observable\n   * @api\n   */\n  setActive(active) {\n    this.set(InteractionProperty.ACTIVE, active);\n  }\n\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../Map.js\").default|null} map Map.\n   */\n  setMap(map) {\n    this.map_ = map;\n  }\n}\n\n/**\n * @param {import(\"../View.js\").default} view View.\n * @param {import(\"../coordinate.js\").Coordinate} delta Delta.\n * @param {number} [duration] Duration.\n */\nexport function pan(view, delta, duration) {\n  const currentCenter = view.getCenterInternal();\n  if (currentCenter) {\n    const center = [currentCenter[0] + delta[0], currentCenter[1] + delta[1]];\n    view.animateInternal({\n      duration: duration !== undefined ? duration : 250,\n      easing: linear,\n      center: view.getConstrainedCenter(center),\n    });\n  }\n}\n\n/**\n * @param {import(\"../View.js\").default} view View.\n * @param {number} delta Delta from previous zoom level.\n * @param {import(\"../coordinate.js\").Coordinate} [anchor] Anchor coordinate in the user projection.\n * @param {number} [duration] Duration.\n */\nexport function zoomByDelta(view, delta, anchor, duration) {\n  const currentZoom = view.getZoom();\n\n  if (currentZoom === undefined) {\n    return;\n  }\n\n  const newZoom = view.getConstrainedZoom(currentZoom + delta);\n  const newResolution = view.getResolutionForZoom(newZoom);\n\n  if (view.getAnimating()) {\n    view.cancelAnimations();\n  }\n  view.animate({\n    resolution: newResolution,\n    anchor: anchor,\n    duration: duration !== undefined ? duration : 250,\n    easing: easeOut,\n  });\n}\n\nexport default Interaction;\n","/**\n * @module ol/interaction/Pointer\n */\nimport Interaction from './Interaction.js';\nimport MapBrowserEventType from '../MapBrowserEventType.js';\n\n/**\n * @typedef {Object} Options\n * @property {function(import(\"../MapBrowserEvent.js\").default):boolean} [handleDownEvent]\n * Function handling \"down\" events. If the function returns `true` then a drag\n * sequence is started.\n * @property {function(import(\"../MapBrowserEvent.js\").default):void} [handleDragEvent]\n * Function handling \"drag\" events. This function is called on \"move\" events\n * during a drag sequence.\n * @property {function(import(\"../MapBrowserEvent.js\").default):boolean} [handleEvent]\n * Method called by the map to notify the interaction that a browser event was\n * dispatched to the map. The function may return `false` to prevent the\n * propagation of the event to other interactions in the map's interactions\n * chain.\n * @property {function(import(\"../MapBrowserEvent.js\").default):void} [handleMoveEvent]\n * Function handling \"move\" events. This function is called on \"move\" events.\n * This functions is also called during a drag sequence, so during a drag\n * sequence both the `handleDragEvent` function and this function are called.\n * If `handleDownEvent` is defined and it returns true this function will not\n * be called during a drag sequence.\n * @property {function(import(\"../MapBrowserEvent.js\").default):boolean} [handleUpEvent]\n *  Function handling \"up\" events. If the function returns `false` then the\n * current drag sequence is stopped.\n * @property {function(boolean):boolean} [stopDown]\n * Should the down event be propagated to other interactions, or should be\n * stopped?\n */\n\n/**\n * @classdesc\n * Base class that calls user-defined functions on `down`, `move` and `up`\n * events. This class also manages \"drag sequences\".\n *\n * When the `handleDownEvent` user function returns `true` a drag sequence is\n * started. During a drag sequence the `handleDragEvent` user function is\n * called on `move` events. The drag sequence ends when the `handleUpEvent`\n * user function is called and returns `false`.\n * @api\n */\nclass PointerInteraction extends Interaction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    super(\n      /** @type {import(\"./Interaction.js\").InteractionOptions} */ (options)\n    );\n\n    if (options.handleDownEvent) {\n      this.handleDownEvent = options.handleDownEvent;\n    }\n\n    if (options.handleDragEvent) {\n      this.handleDragEvent = options.handleDragEvent;\n    }\n\n    if (options.handleMoveEvent) {\n      this.handleMoveEvent = options.handleMoveEvent;\n    }\n\n    if (options.handleUpEvent) {\n      this.handleUpEvent = options.handleUpEvent;\n    }\n\n    if (options.stopDown) {\n      this.stopDown = options.stopDown;\n    }\n\n    /**\n     * @type {boolean}\n     * @protected\n     */\n    this.handlingDownUpSequence = false;\n\n    /**\n     * @type {Array<PointerEvent>}\n     * @protected\n     */\n    this.targetPointers = [];\n  }\n\n  /**\n   * Returns the current number of pointers involved in the interaction,\n   * e.g. `2` when two fingers are used.\n   * @return {number} The number of pointers.\n   * @api\n   */\n  getPointerCount() {\n    return this.targetPointers.length;\n  }\n\n  /**\n   * Handle pointer down events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   * @protected\n   */\n  handleDownEvent(mapBrowserEvent) {\n    return false;\n  }\n\n  /**\n   * Handle pointer drag events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @protected\n   */\n  handleDragEvent(mapBrowserEvent) {}\n\n  /**\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may call into\n   * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are\n   * detected.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   * @api\n   */\n  handleEvent(mapBrowserEvent) {\n    if (!mapBrowserEvent.originalEvent) {\n      return true;\n    }\n\n    let stopEvent = false;\n    this.updateTrackedPointers_(mapBrowserEvent);\n    if (this.handlingDownUpSequence) {\n      if (mapBrowserEvent.type == MapBrowserEventType.POINTERDRAG) {\n        this.handleDragEvent(mapBrowserEvent);\n        // prevent page scrolling during dragging\n        mapBrowserEvent.originalEvent.preventDefault();\n      } else if (mapBrowserEvent.type == MapBrowserEventType.POINTERUP) {\n        const handledUp = this.handleUpEvent(mapBrowserEvent);\n        this.handlingDownUpSequence =\n          handledUp && this.targetPointers.length > 0;\n      }\n    } else {\n      if (mapBrowserEvent.type == MapBrowserEventType.POINTERDOWN) {\n        const handled = this.handleDownEvent(mapBrowserEvent);\n        this.handlingDownUpSequence = handled;\n        stopEvent = this.stopDown(handled);\n      } else if (mapBrowserEvent.type == MapBrowserEventType.POINTERMOVE) {\n        this.handleMoveEvent(mapBrowserEvent);\n      }\n    }\n    return !stopEvent;\n  }\n\n  /**\n   * Handle pointer move events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @protected\n   */\n  handleMoveEvent(mapBrowserEvent) {}\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   * @protected\n   */\n  handleUpEvent(mapBrowserEvent) {\n    return false;\n  }\n\n  /**\n   * This function is used to determine if \"down\" events should be propagated\n   * to other interactions or should be stopped.\n   * @param {boolean} handled Was the event handled by the interaction?\n   * @return {boolean} Should the `down` event be stopped?\n   */\n  stopDown(handled) {\n    return handled;\n  }\n\n  /**\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @private\n   */\n  updateTrackedPointers_(mapBrowserEvent) {\n    if (mapBrowserEvent.activePointers) {\n      this.targetPointers = mapBrowserEvent.activePointers;\n    }\n  }\n}\n\n/**\n * @param {Array<PointerEvent>} pointerEvents List of events.\n * @return {{clientX: number, clientY: number}} Centroid pixel.\n */\nexport function centroid(pointerEvents) {\n  const length = pointerEvents.length;\n  let clientX = 0;\n  let clientY = 0;\n  for (let i = 0; i < length; i++) {\n    clientX += pointerEvents[i].clientX;\n    clientY += pointerEvents[i].clientY;\n  }\n  return {clientX: clientX / length, clientY: clientY / length};\n}\n\nexport default PointerInteraction;\n","/**\n * @module ol/interaction/Property\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  ACTIVE: 'active',\n};\n","/**\n * @module ol/interaction/Select\n */\nimport Collection from '../Collection.js';\nimport CollectionEventType from '../CollectionEventType.js';\nimport Event from '../events/Event.js';\nimport Feature from '../Feature.js';\nimport Interaction from './Interaction.js';\nimport VectorLayer from '../layer/Vector.js';\nimport {TRUE} from '../functions.js';\nimport {clear} from '../obj.js';\nimport {createEditingStyle} from '../style/Style.js';\nimport {extend} from '../array.js';\nimport {getUid} from '../util.js';\nimport {never, shiftKeyOnly, singleClick} from '../events/condition.js';\n\n/**\n * @enum {string}\n */\nconst SelectEventType = {\n  /**\n   * Triggered when feature(s) has been (de)selected.\n   * @event SelectEvent#select\n   * @api\n   */\n  SELECT: 'select',\n};\n\n/**\n * A function that takes an {@link module:ol/Feature~Feature} and returns `true` if the feature may be\n * selected or `false` otherwise.\n * @typedef {function(import(\"../Feature.js\").default, import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>):boolean} FilterFunction\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../events/condition.js\").Condition} [addCondition] A function\n * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * By default, this is {@link module:ol/events/condition.never}. Use this if you\n * want to use different events for add and remove instead of `toggle`.\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled. This is the event\n * for the selected features as a whole. By default, this is\n * {@link module:ol/events/condition.singleClick}. Clicking on a feature selects that\n * feature and removes any that were in the selection. Clicking outside any\n * feature removes all from the selection.\n * See `toggle`, `add`, `remove` options for adding/removing extra features to/\n * from the selection.\n * @property {Array<import(\"../layer/Layer.js\").default>|function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean} [layers]\n * A list of layers from which features should be selected. Alternatively, a\n * filter function can be provided. The function will be called for each layer\n * in the map and should return `true` for layers that you want to be\n * selectable. If the option is absent, all visible layers will be considered\n * selectable.\n * @property {import(\"../style/Style.js\").StyleLike|null} [style]\n * Style for the selected features. By default the default edit style is used\n * (see {@link module:ol/style/Style~Style}). Set to `null` if this interaction should not apply\n * any style changes for selected features.\n * If set to a falsey value, the selected feature's style will not change.\n * @property {import(\"../events/condition.js\").Condition} [removeCondition] A function\n * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * By default, this is {@link module:ol/events/condition.never}. Use this if you\n * want to use different events for add and remove instead of `toggle`.\n * @property {import(\"../events/condition.js\").Condition} [toggleCondition] A function\n * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled. This is in addition\n * to the `condition` event. By default,\n * {@link module:ol/events/condition.shiftKeyOnly}, i.e. pressing `shift` as\n * well as the `condition` event, adds that feature to the current selection if\n * it is not currently selected, and removes it if it is. See `add` and `remove`\n * if you want to use different events instead of a toggle.\n * @property {boolean} [multi=false] A boolean that determines if the default\n * behaviour should select only single features or all (overlapping) features at\n * the clicked map position. The default of `false` means single select.\n * @property {Collection<Feature>} [features]\n * Collection where the interaction will place selected features. Optional. If\n * not set the interaction will create a collection. In any case the collection\n * used by the interaction is returned by\n * {@link module:ol/interaction/Select~Select#getFeatures}.\n * @property {FilterFunction} [filter] A function\n * that takes an {@link module:ol/Feature~Feature} and an\n * {@link module:ol/layer/Layer~Layer} and returns `true` if the feature may be\n * selected or `false` otherwise.\n * @property {number} [hitTolerance=0] Hit-detection tolerance. Pixels inside\n * the radius around the given position will be checked for features.\n */\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/Select~Select} instances are instances of\n * this type.\n */\nexport class SelectEvent extends Event {\n  /**\n   * @param {SelectEventType} type The event type.\n   * @param {Array<import(\"../Feature.js\").default>} selected Selected features.\n   * @param {Array<import(\"../Feature.js\").default>} deselected Deselected features.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Associated\n   *     {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\n   */\n  constructor(type, selected, deselected, mapBrowserEvent) {\n    super(type);\n\n    /**\n     * Selected features array.\n     * @type {Array<import(\"../Feature.js\").default>}\n     * @api\n     */\n    this.selected = selected;\n\n    /**\n     * Deselected features array.\n     * @type {Array<import(\"../Feature.js\").default>}\n     * @api\n     */\n    this.deselected = deselected;\n\n    /**\n     * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\n     * @type {import(\"../MapBrowserEvent.js\").default}\n     * @api\n     */\n    this.mapBrowserEvent = mapBrowserEvent;\n  }\n}\n\n/**\n * Original feature styles to reset to when features are no longer selected.\n * @type {Object<number, import(\"../style/Style.js\").default|Array<import(\"../style/Style.js\").default>|import(\"../style/Style.js\").StyleFunction>}\n */\nconst originalFeatureStyles = {};\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'select', SelectEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'select', Return>} SelectOnSignature\n */\n\n/**\n * @classdesc\n * Interaction for selecting vector features. By default, selected features are\n * styled differently, so this interaction can be used for visual highlighting,\n * as well as selecting features for other actions, such as modification or\n * output. There are three ways of controlling which features are selected:\n * using the browser event as defined by the `condition` and optionally the\n * `toggle`, `add`/`remove`, and `multi` options; a `layers` filter; and a\n * further feature filter using the `filter` option.\n *\n * @fires SelectEvent\n * @api\n */\nclass Select extends Interaction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n\n    /***\n     * @type {SelectOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {SelectOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {SelectOnSignature<void>}\n     */\n    this.un;\n\n    options = options ? options : {};\n\n    /**\n     * @private\n     */\n    this.boundAddFeature_ = this.addFeature_.bind(this);\n\n    /**\n     * @private\n     */\n    this.boundRemoveFeature_ = this.removeFeature_.bind(this);\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.condition_ = options.condition ? options.condition : singleClick;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.addCondition_ = options.addCondition ? options.addCondition : never;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.removeCondition_ = options.removeCondition\n      ? options.removeCondition\n      : never;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.toggleCondition_ = options.toggleCondition\n      ? options.toggleCondition\n      : shiftKeyOnly;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.multi_ = options.multi ? options.multi : false;\n\n    /**\n     * @private\n     * @type {FilterFunction}\n     */\n    this.filter_ = options.filter ? options.filter : TRUE;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;\n\n    /**\n     * @private\n     * @type {import(\"../style/Style.js\").default|Array<import(\"../style/Style.js\").default>|import(\"../style/Style.js\").StyleFunction|null}\n     */\n    this.style_ =\n      options.style !== undefined ? options.style : getDefaultStyleFunction();\n\n    /**\n     * @private\n     * @type {Collection<Feature>}\n     */\n    this.features_ = options.features || new Collection();\n\n    /** @type {function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean} */\n    let layerFilter;\n    if (options.layers) {\n      if (typeof options.layers === 'function') {\n        layerFilter = options.layers;\n      } else {\n        const layers = options.layers;\n        layerFilter = function (layer) {\n          return layers.includes(layer);\n        };\n      }\n    } else {\n      layerFilter = TRUE;\n    }\n\n    /**\n     * @private\n     * @type {function(import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>): boolean}\n     */\n    this.layerFilter_ = layerFilter;\n\n    /**\n     * An association between selected feature (key)\n     * and layer (value)\n     * @private\n     * @type {Object<string, import(\"../layer/Layer.js\").default>}\n     */\n    this.featureLayerAssociation_ = {};\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"../layer/Layer.js\").default} layer Layer.\n   * @private\n   */\n  addFeatureLayerAssociation_(feature, layer) {\n    this.featureLayerAssociation_[getUid(feature)] = layer;\n  }\n\n  /**\n   * Get the selected features.\n   * @return {Collection<Feature>} Features collection.\n   * @api\n   */\n  getFeatures() {\n    return this.features_;\n  }\n\n  /**\n   * Returns the Hit-detection tolerance.\n   * @return {number} Hit tolerance in pixels.\n   * @api\n   */\n  getHitTolerance() {\n    return this.hitTolerance_;\n  }\n\n  /**\n   * Returns the associated {@link module:ol/layer/Vector~VectorLayer vector layer} of\n   * a selected feature.\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @return {import('../layer/Vector.js').default} Layer.\n   * @api\n   */\n  getLayer(feature) {\n    return /** @type {import('../layer/Vector.js').default} */ (\n      this.featureLayerAssociation_[getUid(feature)]\n    );\n  }\n\n  /**\n   * Hit-detection tolerance. Pixels inside the radius around the given position\n   * will be checked for features.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @api\n   */\n  setHitTolerance(hitTolerance) {\n    this.hitTolerance_ = hitTolerance;\n  }\n\n  /**\n   * Remove the interaction from its current map, if any,  and attach it to a new\n   * map, if any. Pass `null` to just remove the interaction from the current map.\n   * @param {import(\"../Map.js\").default|null} map Map.\n   * @api\n   */\n  setMap(map) {\n    const currentMap = this.getMap();\n    if (currentMap && this.style_) {\n      this.features_.forEach(this.restorePreviousStyle_.bind(this));\n    }\n    super.setMap(map);\n    if (map) {\n      this.features_.addEventListener(\n        CollectionEventType.ADD,\n        this.boundAddFeature_\n      );\n      this.features_.addEventListener(\n        CollectionEventType.REMOVE,\n        this.boundRemoveFeature_\n      );\n\n      if (this.style_) {\n        this.features_.forEach(this.applySelectedStyle_.bind(this));\n      }\n    } else {\n      this.features_.removeEventListener(\n        CollectionEventType.ADD,\n        this.boundAddFeature_\n      );\n      this.features_.removeEventListener(\n        CollectionEventType.REMOVE,\n        this.boundRemoveFeature_\n      );\n    }\n  }\n\n  /**\n   * @param {import(\"../Collection.js\").CollectionEvent<Feature>} evt Event.\n   * @private\n   */\n  addFeature_(evt) {\n    const feature = evt.element;\n    if (this.style_) {\n      this.applySelectedStyle_(feature);\n    }\n    if (!this.getLayer(feature)) {\n      const layer = /** @type {VectorLayer} */ (\n        this.getMap()\n          .getAllLayers()\n          .find(function (layer) {\n            if (\n              layer instanceof VectorLayer &&\n              layer.getSource() &&\n              layer.getSource().hasFeature(feature)\n            ) {\n              return layer;\n            }\n          })\n      );\n      if (layer) {\n        this.addFeatureLayerAssociation_(feature, layer);\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../Collection.js\").CollectionEvent<Feature>} evt Event.\n   * @private\n   */\n  removeFeature_(evt) {\n    if (this.style_) {\n      this.restorePreviousStyle_(evt.element);\n    }\n  }\n\n  /**\n   * @return {import(\"../style/Style.js\").StyleLike|null} Select style.\n   */\n  getStyle() {\n    return this.style_;\n  }\n\n  /**\n   * @param {Feature} feature Feature\n   * @private\n   */\n  applySelectedStyle_(feature) {\n    const key = getUid(feature);\n    if (!(key in originalFeatureStyles)) {\n      originalFeatureStyles[key] = feature.getStyle();\n    }\n    feature.setStyle(this.style_);\n  }\n\n  /**\n   * @param {Feature} feature Feature\n   * @private\n   */\n  restorePreviousStyle_(feature) {\n    const interactions = this.getMap().getInteractions().getArray();\n    for (let i = interactions.length - 1; i >= 0; --i) {\n      const interaction = interactions[i];\n      if (\n        interaction !== this &&\n        interaction instanceof Select &&\n        interaction.getStyle() &&\n        interaction.getFeatures().getArray().lastIndexOf(feature) !== -1\n      ) {\n        feature.setStyle(interaction.getStyle());\n        return;\n      }\n    }\n\n    const key = getUid(feature);\n    feature.setStyle(originalFeatureStyles[key]);\n    delete originalFeatureStyles[key];\n  }\n\n  /**\n   * @param {Feature} feature Feature.\n   * @private\n   */\n  removeFeatureLayerAssociation_(feature) {\n    delete this.featureLayerAssociation_[getUid(feature)];\n  }\n\n  /**\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may change the\n   * selected state of features.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   */\n  handleEvent(mapBrowserEvent) {\n    if (!this.condition_(mapBrowserEvent)) {\n      return true;\n    }\n    const add = this.addCondition_(mapBrowserEvent);\n    const remove = this.removeCondition_(mapBrowserEvent);\n    const toggle = this.toggleCondition_(mapBrowserEvent);\n    const set = !add && !remove && !toggle;\n    const map = mapBrowserEvent.map;\n    const features = this.getFeatures();\n\n    /**\n     * @type {Array<Feature>}\n     */\n    const deselected = [];\n\n    /**\n     * @type {Array<Feature>}\n     */\n    const selected = [];\n\n    if (set) {\n      // Replace the currently selected feature(s) with the feature(s) at the\n      // pixel, or clear the selected feature(s) if there is no feature at\n      // the pixel.\n      clear(this.featureLayerAssociation_);\n      map.forEachFeatureAtPixel(\n        mapBrowserEvent.pixel,\n        /**\n         * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n         * @param {import(\"../layer/Layer.js\").default} layer Layer.\n         * @return {boolean|undefined} Continue to iterate over the features.\n         */\n        (feature, layer) => {\n          if (!(feature instanceof Feature) || !this.filter_(feature, layer)) {\n            return;\n          }\n          this.addFeatureLayerAssociation_(feature, layer);\n          selected.push(feature);\n          return !this.multi_;\n        },\n        {\n          layerFilter: this.layerFilter_,\n          hitTolerance: this.hitTolerance_,\n        }\n      );\n      for (let i = features.getLength() - 1; i >= 0; --i) {\n        const feature = features.item(i);\n        const index = selected.indexOf(feature);\n        if (index > -1) {\n          // feature is already selected\n          selected.splice(index, 1);\n        } else {\n          features.remove(feature);\n          deselected.push(feature);\n        }\n      }\n      if (selected.length !== 0) {\n        features.extend(selected);\n      }\n    } else {\n      // Modify the currently selected feature(s).\n      map.forEachFeatureAtPixel(\n        mapBrowserEvent.pixel,\n        /**\n         * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n         * @param {import(\"../layer/Layer.js\").default} layer Layer.\n         * @return {boolean|undefined} Continue to iterate over the features.\n         */\n        (feature, layer) => {\n          if (!(feature instanceof Feature) || !this.filter_(feature, layer)) {\n            return;\n          }\n          if ((add || toggle) && !features.getArray().includes(feature)) {\n            this.addFeatureLayerAssociation_(feature, layer);\n            selected.push(feature);\n          } else if (\n            (remove || toggle) &&\n            features.getArray().includes(feature)\n          ) {\n            deselected.push(feature);\n            this.removeFeatureLayerAssociation_(feature);\n          }\n          return !this.multi_;\n        },\n        {\n          layerFilter: this.layerFilter_,\n          hitTolerance: this.hitTolerance_,\n        }\n      );\n      for (let j = deselected.length - 1; j >= 0; --j) {\n        features.remove(deselected[j]);\n      }\n      features.extend(selected);\n    }\n    if (selected.length > 0 || deselected.length > 0) {\n      this.dispatchEvent(\n        new SelectEvent(\n          SelectEventType.SELECT,\n          selected,\n          deselected,\n          mapBrowserEvent\n        )\n      );\n    }\n    return true;\n  }\n}\n\n/**\n * @return {import(\"../style/Style.js\").StyleFunction} Styles.\n */\nfunction getDefaultStyleFunction() {\n  const styles = createEditingStyle();\n  extend(styles['Polygon'], styles['LineString']);\n  extend(styles['GeometryCollection'], styles['LineString']);\n\n  return function (feature) {\n    if (!feature.getGeometry()) {\n      return null;\n    }\n    return styles[feature.getGeometry().getType()];\n  };\n}\n\nexport default Select;\n","/**\n * @module ol/interaction/DoubleClickZoom\n */\nimport Interaction, {zoomByDelta} from './Interaction.js';\nimport MapBrowserEventType from '../MapBrowserEventType.js';\n\n/**\n * @typedef {Object} Options\n * @property {number} [duration=250] Animation duration in milliseconds.\n * @property {number} [delta=1] The zoom delta applied on each double click.\n */\n\n/**\n * @classdesc\n * Allows the user to zoom by double-clicking on the map.\n * @api\n */\nclass DoubleClickZoom extends Interaction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n\n    options = options ? options : {};\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.delta_ = options.delta ? options.delta : 1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 250;\n  }\n\n  /**\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a\n   * doubleclick) and eventually zooms the map.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   */\n  handleEvent(mapBrowserEvent) {\n    let stopEvent = false;\n    if (mapBrowserEvent.type == MapBrowserEventType.DBLCLICK) {\n      const browserEvent = /** @type {MouseEvent} */ (\n        mapBrowserEvent.originalEvent\n      );\n      const map = mapBrowserEvent.map;\n      const anchor = mapBrowserEvent.coordinate;\n      const delta = browserEvent.shiftKey ? -this.delta_ : this.delta_;\n      const view = map.getView();\n      zoomByDelta(view, delta, anchor, this.duration_);\n      browserEvent.preventDefault();\n      stopEvent = true;\n    }\n    return !stopEvent;\n  }\n}\n\nexport default DoubleClickZoom;\n","/**\n * @module ol/interaction/DragPan\n */\nimport PointerInteraction, {\n  centroid as centroidFromPointers,\n} from './Pointer.js';\nimport {FALSE} from '../functions.js';\nimport {\n  all,\n  focusWithTabindex,\n  noModifierKeys,\n  primaryAction,\n} from '../events/condition.js';\nimport {easeOut} from '../easing.js';\nimport {\n  rotate as rotateCoordinate,\n  scale as scaleCoordinate,\n} from '../coordinate.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean\n * to indicate whether that event should be handled.\n * Default is {@link module:ol/events/condition.noModifierKeys} and {@link module:ol/events/condition.primaryAction}.\n * @property {boolean} [onFocusOnly=false] When the map's target has a `tabindex` attribute set,\n * the interaction will only handle events when the map has the focus.\n * @property {import(\"../Kinetic.js\").default} [kinetic] Kinetic inertia to apply to the pan.\n */\n\n/**\n * @classdesc\n * Allows the user to pan the map by dragging the map.\n * @api\n */\nclass DragPan extends PointerInteraction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super({\n      stopDown: FALSE,\n    });\n\n    options = options ? options : {};\n\n    /**\n     * @private\n     * @type {import(\"../Kinetic.js\").default|undefined}\n     */\n    this.kinetic_ = options.kinetic;\n\n    /**\n     * @type {import(\"../pixel.js\").Pixel}\n     */\n    this.lastCentroid = null;\n\n    /**\n     * @type {number}\n     */\n    this.lastPointersCount_;\n\n    /**\n     * @type {boolean}\n     */\n    this.panning_ = false;\n\n    const condition = options.condition\n      ? options.condition\n      : all(noModifierKeys, primaryAction);\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.condition_ = options.onFocusOnly\n      ? all(focusWithTabindex, condition)\n      : condition;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.noKinetic_ = false;\n  }\n\n  /**\n   * Handle pointer drag events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   */\n  handleDragEvent(mapBrowserEvent) {\n    const map = mapBrowserEvent.map;\n    if (!this.panning_) {\n      this.panning_ = true;\n      map.getView().beginInteraction();\n    }\n    const targetPointers = this.targetPointers;\n    const centroid = map.getEventPixel(centroidFromPointers(targetPointers));\n    if (targetPointers.length == this.lastPointersCount_) {\n      if (this.kinetic_) {\n        this.kinetic_.update(centroid[0], centroid[1]);\n      }\n      if (this.lastCentroid) {\n        const delta = [\n          this.lastCentroid[0] - centroid[0],\n          centroid[1] - this.lastCentroid[1],\n        ];\n        const map = mapBrowserEvent.map;\n        const view = map.getView();\n        scaleCoordinate(delta, view.getResolution());\n        rotateCoordinate(delta, view.getRotation());\n        view.adjustCenterInternal(delta);\n      }\n    } else if (this.kinetic_) {\n      // reset so we don't overestimate the kinetic energy after\n      // after one finger down, tiny drag, second finger down\n      this.kinetic_.begin();\n    }\n    this.lastCentroid = centroid;\n    this.lastPointersCount_ = targetPointers.length;\n    mapBrowserEvent.originalEvent.preventDefault();\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleUpEvent(mapBrowserEvent) {\n    const map = mapBrowserEvent.map;\n    const view = map.getView();\n    if (this.targetPointers.length === 0) {\n      if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {\n        const distance = this.kinetic_.getDistance();\n        const angle = this.kinetic_.getAngle();\n        const center = view.getCenterInternal();\n        const centerpx = map.getPixelFromCoordinateInternal(center);\n        const dest = map.getCoordinateFromPixelInternal([\n          centerpx[0] - distance * Math.cos(angle),\n          centerpx[1] - distance * Math.sin(angle),\n        ]);\n        view.animateInternal({\n          center: view.getConstrainedCenter(dest),\n          duration: 500,\n          easing: easeOut,\n        });\n      }\n      if (this.panning_) {\n        this.panning_ = false;\n        view.endInteraction();\n      }\n      return false;\n    }\n    if (this.kinetic_) {\n      // reset so we don't overestimate the kinetic energy after\n      // after one finger up, tiny drag, second finger up\n      this.kinetic_.begin();\n    }\n    this.lastCentroid = null;\n    return true;\n  }\n\n  /**\n   * Handle pointer down events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleDownEvent(mapBrowserEvent) {\n    if (this.targetPointers.length > 0 && this.condition_(mapBrowserEvent)) {\n      const map = mapBrowserEvent.map;\n      const view = map.getView();\n      this.lastCentroid = null;\n      // stop any current animation\n      if (view.getAnimating()) {\n        view.cancelAnimations();\n      }\n      if (this.kinetic_) {\n        this.kinetic_.begin();\n      }\n      // No kinetic as soon as more than one pointer on the screen is\n      // detected. This is to prevent nasty pans after pinch.\n      this.noKinetic_ = this.targetPointers.length > 1;\n      return true;\n    }\n    return false;\n  }\n}\n\nexport default DragPan;\n","/**\n * @module ol/interaction/DragRotate\n */\nimport PointerInteraction from './Pointer.js';\nimport {FALSE} from '../functions.js';\nimport {\n  altShiftKeysOnly,\n  mouseActionButton,\n  mouseOnly,\n} from '../events/condition.js';\nimport {disable} from '../rotationconstraint.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that takes an\n * {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean\n * to indicate whether that event should be handled.\n * Default is {@link module:ol/events/condition.altShiftKeysOnly}.\n * @property {number} [duration=250] Animation duration in milliseconds.\n */\n\n/**\n * @classdesc\n * Allows the user to rotate the map by clicking and dragging on the map,\n * normally combined with an {@link module:ol/events/condition} that limits\n * it to when the alt and shift keys are held down.\n *\n * This interaction is only supported for mouse devices.\n * @api\n */\nclass DragRotate extends PointerInteraction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    super({\n      stopDown: FALSE,\n    });\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.condition_ = options.condition ? options.condition : altShiftKeysOnly;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.lastAngle_ = undefined;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 250;\n  }\n\n  /**\n   * Handle pointer drag events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   */\n  handleDragEvent(mapBrowserEvent) {\n    if (!mouseOnly(mapBrowserEvent)) {\n      return;\n    }\n\n    const map = mapBrowserEvent.map;\n    const view = map.getView();\n    if (view.getConstraints().rotation === disable) {\n      return;\n    }\n    const size = map.getSize();\n    const offset = mapBrowserEvent.pixel;\n    const theta = Math.atan2(size[1] / 2 - offset[1], offset[0] - size[0] / 2);\n    if (this.lastAngle_ !== undefined) {\n      const delta = theta - this.lastAngle_;\n      view.adjustRotationInternal(-delta);\n    }\n    this.lastAngle_ = theta;\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleUpEvent(mapBrowserEvent) {\n    if (!mouseOnly(mapBrowserEvent)) {\n      return true;\n    }\n\n    const map = mapBrowserEvent.map;\n    const view = map.getView();\n    view.endInteraction(this.duration_);\n    return false;\n  }\n\n  /**\n   * Handle pointer down events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleDownEvent(mapBrowserEvent) {\n    if (!mouseOnly(mapBrowserEvent)) {\n      return false;\n    }\n\n    if (\n      mouseActionButton(mapBrowserEvent) &&\n      this.condition_(mapBrowserEvent)\n    ) {\n      const map = mapBrowserEvent.map;\n      map.getView().beginInteraction();\n      this.lastAngle_ = undefined;\n      return true;\n    }\n    return false;\n  }\n}\n\nexport default DragRotate;\n","/**\n * @module ol/interaction/DragBox\n */\n// FIXME draw drag box\nimport Event from '../events/Event.js';\nimport PointerInteraction from './Pointer.js';\nimport RenderBox from '../render/Box.js';\nimport {mouseActionButton} from '../events/condition.js';\n\n/**\n * A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and two\n * {@link module:ol/pixel~Pixel}s and returns a `{boolean}`. If the condition is met,\n * true should be returned.\n * @typedef {function(this: ?, import(\"../MapBrowserEvent.js\").default, import(\"../pixel.js\").Pixel, import(\"../pixel.js\").Pixel):boolean} EndCondition\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-dragbox'] CSS class name for styling the box.\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean\n * to indicate whether that event should be handled.\n * Default is {@link ol/events/condition~mouseActionButton}.\n * @property {number} [minArea=64] The minimum area of the box in pixel, this value is used by the default\n * `boxEndCondition` function.\n * @property {EndCondition} [boxEndCondition] A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and two\n * {@link module:ol/pixel~Pixel}s to indicate whether a `boxend` event should be fired.\n * Default is `true` if the area of the box is bigger than the `minArea` option.\n * @property {function(this:DragBox, import(\"../MapBrowserEvent.js\").default):void} [onBoxEnd] Code to execute just\n * before `boxend` is fired.\n */\n\n/**\n * @enum {string}\n */\nconst DragBoxEventType = {\n  /**\n   * Triggered upon drag box start.\n   * @event DragBoxEvent#boxstart\n   * @api\n   */\n  BOXSTART: 'boxstart',\n\n  /**\n   * Triggered on drag when box is active.\n   * @event DragBoxEvent#boxdrag\n   * @api\n   */\n  BOXDRAG: 'boxdrag',\n\n  /**\n   * Triggered upon drag box end.\n   * @event DragBoxEvent#boxend\n   * @api\n   */\n  BOXEND: 'boxend',\n\n  /**\n   * Triggered upon drag box canceled.\n   * @event DragBoxEvent#boxcancel\n   * @api\n   */\n  BOXCANCEL: 'boxcancel',\n};\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/DragBox~DragBox} instances are instances of\n * this type.\n */\nexport class DragBoxEvent extends Event {\n  /**\n   * @param {string} type The event type.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate The event coordinate.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Originating event.\n   */\n  constructor(type, coordinate, mapBrowserEvent) {\n    super(type);\n\n    /**\n     * The coordinate of the drag event.\n     * @const\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @api\n     */\n    this.coordinate = coordinate;\n\n    /**\n     * @const\n     * @type {import(\"../MapBrowserEvent.js\").default}\n     * @api\n     */\n    this.mapBrowserEvent = mapBrowserEvent;\n  }\n}\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'boxcancel'|'boxdrag'|'boxend'|'boxstart', DragBoxEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'boxcancel'|'boxdrag'|'boxend', Return>} DragBoxOnSignature\n */\n\n/**\n * @classdesc\n * Allows the user to draw a vector box by clicking and dragging on the map,\n * normally combined with an {@link module:ol/events/condition} that limits\n * it to when the shift or other key is held down. This is used, for example,\n * for zooming to a specific area of the map\n * (see {@link module:ol/interaction/DragZoom~DragZoom} and\n * {@link module:ol/interaction/DragRotateAndZoom~DragRotateAndZoom}).\n *\n * @fires DragBoxEvent\n * @api\n */\nclass DragBox extends PointerInteraction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n\n    /***\n     * @type {DragBoxOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {DragBoxOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {DragBoxOnSignature<void>}\n     */\n    this.un;\n\n    options = options ? options : {};\n\n    /**\n     * @type {import(\"../render/Box.js\").default}\n     * @private\n     */\n    this.box_ = new RenderBox(options.className || 'ol-dragbox');\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.minArea_ = options.minArea !== undefined ? options.minArea : 64;\n\n    if (options.onBoxEnd) {\n      this.onBoxEnd = options.onBoxEnd;\n    }\n\n    /**\n     * @type {import(\"../pixel.js\").Pixel}\n     * @private\n     */\n    this.startPixel_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.condition_ = options.condition ? options.condition : mouseActionButton;\n\n    /**\n     * @private\n     * @type {EndCondition}\n     */\n    this.boxEndCondition_ = options.boxEndCondition\n      ? options.boxEndCondition\n      : this.defaultBoxEndCondition;\n  }\n\n  /**\n   * The default condition for determining whether the boxend event\n   * should fire.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent The originating MapBrowserEvent\n   *     leading to the box end.\n   * @param {import(\"../pixel.js\").Pixel} startPixel The starting pixel of the box.\n   * @param {import(\"../pixel.js\").Pixel} endPixel The end pixel of the box.\n   * @return {boolean} Whether or not the boxend condition should be fired.\n   */\n  defaultBoxEndCondition(mapBrowserEvent, startPixel, endPixel) {\n    const width = endPixel[0] - startPixel[0];\n    const height = endPixel[1] - startPixel[1];\n    return width * width + height * height >= this.minArea_;\n  }\n\n  /**\n   * Returns geometry of last drawn box.\n   * @return {import(\"../geom/Polygon.js\").default} Geometry.\n   * @api\n   */\n  getGeometry() {\n    return this.box_.getGeometry();\n  }\n\n  /**\n   * Handle pointer drag events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   */\n  handleDragEvent(mapBrowserEvent) {\n    this.box_.setPixels(this.startPixel_, mapBrowserEvent.pixel);\n\n    this.dispatchEvent(\n      new DragBoxEvent(\n        DragBoxEventType.BOXDRAG,\n        mapBrowserEvent.coordinate,\n        mapBrowserEvent\n      )\n    );\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleUpEvent(mapBrowserEvent) {\n    this.box_.setMap(null);\n\n    const completeBox = this.boxEndCondition_(\n      mapBrowserEvent,\n      this.startPixel_,\n      mapBrowserEvent.pixel\n    );\n    if (completeBox) {\n      this.onBoxEnd(mapBrowserEvent);\n    }\n    this.dispatchEvent(\n      new DragBoxEvent(\n        completeBox ? DragBoxEventType.BOXEND : DragBoxEventType.BOXCANCEL,\n        mapBrowserEvent.coordinate,\n        mapBrowserEvent\n      )\n    );\n    return false;\n  }\n\n  /**\n   * Handle pointer down events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleDownEvent(mapBrowserEvent) {\n    if (this.condition_(mapBrowserEvent)) {\n      this.startPixel_ = mapBrowserEvent.pixel;\n      this.box_.setMap(mapBrowserEvent.map);\n      this.box_.setPixels(this.startPixel_, this.startPixel_);\n      this.dispatchEvent(\n        new DragBoxEvent(\n          DragBoxEventType.BOXSTART,\n          mapBrowserEvent.coordinate,\n          mapBrowserEvent\n        )\n      );\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Function to execute just before `onboxend` is fired\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   */\n  onBoxEnd(event) {}\n}\n\nexport default DragBox;\n","/**\n * @module ol/interaction/DragZoom\n */\nimport DragBox from './DragBox.js';\nimport {easeOut} from '../easing.js';\nimport {shiftKeyOnly} from '../events/condition.js';\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-dragzoom'] CSS class name for styling the\n * box.\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * Default is {@link module:ol/events/condition.shiftKeyOnly}.\n * @property {number} [duration=200] Animation duration in milliseconds.\n * @property {boolean} [out=false] Use interaction for zooming out.\n * @property {number} [minArea=64] The minimum area of the box in pixel, this value is used by the parent default\n * `boxEndCondition` function.\n */\n\n/**\n * @classdesc\n * Allows the user to zoom the map by clicking and dragging on the map,\n * normally combined with an {@link module:ol/events/condition} that limits\n * it to when a key, shift by default, is held down.\n *\n * To change the style of the box, use CSS and the `.ol-dragzoom` selector, or\n * your custom one configured with `className`.\n * @api\n */\nclass DragZoom extends DragBox {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const condition = options.condition ? options.condition : shiftKeyOnly;\n\n    super({\n      condition: condition,\n      className: options.className || 'ol-dragzoom',\n      minArea: options.minArea,\n    });\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 200;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.out_ = options.out !== undefined ? options.out : false;\n  }\n\n  /**\n   * Function to execute just before `onboxend` is fired\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   */\n  onBoxEnd(event) {\n    const map = this.getMap();\n    const view = /** @type {!import(\"../View.js\").default} */ (map.getView());\n    let geometry = this.getGeometry();\n\n    if (this.out_) {\n      const rotatedExtent = view.rotatedExtentForGeometry(geometry);\n      const resolution = view.getResolutionForExtentInternal(rotatedExtent);\n      const factor = view.getResolution() / resolution;\n      geometry = geometry.clone();\n      geometry.scale(factor * factor);\n    }\n\n    view.fitInternal(geometry, {\n      duration: this.duration_,\n      easing: easeOut,\n    });\n  }\n}\n\nexport default DragZoom;\n","/**\n * @module ol/interaction/KeyboardPan\n */\nimport EventType from '../events/EventType.js';\nimport Interaction, {pan} from './Interaction.js';\nimport KeyCode from '../events/KeyCode.js';\nimport {noModifierKeys, targetNotEditable} from '../events/condition.js';\nimport {rotate as rotateCoordinate} from '../coordinate.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled. Default is\n * {@link module:ol/events/condition.noModifierKeys} and\n * {@link module:ol/events/condition.targetNotEditable}.\n * @property {number} [duration=100] Animation duration in milliseconds.\n * @property {number} [pixelDelta=128] The amount of pixels to pan on each key\n * press.\n */\n\n/**\n * @classdesc\n * Allows the user to pan the map using keyboard arrows.\n * Note that, although this interaction is by default included in maps,\n * the keys can only be used when browser focus is on the element to which\n * the keyboard events are attached. By default, this is the map div,\n * though you can change this with the `keyboardEventTarget` in\n * {@link module:ol/Map~Map}. `document` never loses focus but, for any other\n * element, focus will have to be on, and returned to, this element if the keys\n * are to function.\n * See also {@link module:ol/interaction/KeyboardZoom~KeyboardZoom}.\n * @api\n */\nclass KeyboardPan extends Interaction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n\n    options = options || {};\n\n    /**\n     * @private\n     * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Browser event.\n     * @return {boolean} Combined condition result.\n     */\n    this.defaultCondition_ = function (mapBrowserEvent) {\n      return (\n        noModifierKeys(mapBrowserEvent) && targetNotEditable(mapBrowserEvent)\n      );\n    };\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.condition_ =\n      options.condition !== undefined\n        ? options.condition\n        : this.defaultCondition_;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 100;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelDelta_ =\n      options.pixelDelta !== undefined ? options.pixelDelta : 128;\n  }\n\n  /**\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a\n   * `KeyEvent`, and decides the direction to pan to (if an arrow key was\n   * pressed).\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   */\n  handleEvent(mapBrowserEvent) {\n    let stopEvent = false;\n    if (mapBrowserEvent.type == EventType.KEYDOWN) {\n      const keyEvent = /** @type {KeyboardEvent} */ (\n        mapBrowserEvent.originalEvent\n      );\n      const keyCode = keyEvent.keyCode;\n      if (\n        this.condition_(mapBrowserEvent) &&\n        (keyCode == KeyCode.DOWN ||\n          keyCode == KeyCode.LEFT ||\n          keyCode == KeyCode.RIGHT ||\n          keyCode == KeyCode.UP)\n      ) {\n        const map = mapBrowserEvent.map;\n        const view = map.getView();\n        const mapUnitsDelta = view.getResolution() * this.pixelDelta_;\n        let deltaX = 0,\n          deltaY = 0;\n        if (keyCode == KeyCode.DOWN) {\n          deltaY = -mapUnitsDelta;\n        } else if (keyCode == KeyCode.LEFT) {\n          deltaX = -mapUnitsDelta;\n        } else if (keyCode == KeyCode.RIGHT) {\n          deltaX = mapUnitsDelta;\n        } else {\n          deltaY = mapUnitsDelta;\n        }\n        const delta = [deltaX, deltaY];\n        rotateCoordinate(delta, view.getRotation());\n        pan(view, delta, this.duration_);\n        keyEvent.preventDefault();\n        stopEvent = true;\n      }\n    }\n    return !stopEvent;\n  }\n}\n\nexport default KeyboardPan;\n","/**\n * @module ol/interaction/KeyboardZoom\n */\nimport EventType from '../events/EventType.js';\nimport Interaction, {zoomByDelta} from './Interaction.js';\nimport {targetNotEditable} from '../events/condition.js';\n\n/**\n * @typedef {Object} Options\n * @property {number} [duration=100] Animation duration in milliseconds.\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled. Default is\n * {@link module:ol/events/condition.targetNotEditable}.\n * @property {number} [delta=1] The zoom level delta on each key press.\n */\n\n/**\n * @classdesc\n * Allows the user to zoom the map using keyboard + and -.\n * Note that, although this interaction is by default included in maps,\n * the keys can only be used when browser focus is on the element to which\n * the keyboard events are attached. By default, this is the map div,\n * though you can change this with the `keyboardEventTarget` in\n * {@link module:ol/Map~Map}. `document` never loses focus but, for any other\n * element, focus will have to be on, and returned to, this element if the keys\n * are to function.\n * See also {@link module:ol/interaction/KeyboardPan~KeyboardPan}.\n * @api\n */\nclass KeyboardZoom extends Interaction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n\n    options = options ? options : {};\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.condition_ = options.condition ? options.condition : targetNotEditable;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.delta_ = options.delta ? options.delta : 1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 100;\n  }\n\n  /**\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a\n   * `KeyEvent`, and decides whether to zoom in or out (depending on whether the\n   * key pressed was '+' or '-').\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   */\n  handleEvent(mapBrowserEvent) {\n    let stopEvent = false;\n    if (\n      mapBrowserEvent.type == EventType.KEYDOWN ||\n      mapBrowserEvent.type == EventType.KEYPRESS\n    ) {\n      const keyEvent = /** @type {KeyboardEvent} */ (\n        mapBrowserEvent.originalEvent\n      );\n      const key = keyEvent.key;\n      if (this.condition_(mapBrowserEvent) && (key === '+' || key === '-')) {\n        const map = mapBrowserEvent.map;\n        const delta = key === '+' ? this.delta_ : -this.delta_;\n        const view = map.getView();\n        zoomByDelta(view, delta, undefined, this.duration_);\n        keyEvent.preventDefault();\n        stopEvent = true;\n      }\n    }\n    return !stopEvent;\n  }\n}\n\nexport default KeyboardZoom;\n","/**\n * @module ol/interaction/MouseWheelZoom\n */\nimport EventType from '../events/EventType.js';\nimport Interaction, {zoomByDelta} from './Interaction.js';\nimport {DEVICE_PIXEL_RATIO, FIREFOX} from '../has.js';\nimport {all, always, focusWithTabindex} from '../events/condition.js';\nimport {clamp} from '../math.js';\n\n/**\n * @typedef {'trackpad' | 'wheel'} Mode\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled. Default is\n * {@link module:ol/events/condition.always}.\n * @property {boolean} [onFocusOnly=false] When the map's target has a `tabindex` attribute set,\n * the interaction will only handle events when the map has the focus.\n * @property {number} [maxDelta=1] Maximum mouse wheel delta.\n * @property {number} [duration=250] Animation duration in milliseconds.\n * @property {number} [timeout=80] Mouse wheel timeout duration in milliseconds.\n * @property {boolean} [useAnchor=true] Enable zooming using the mouse's\n * location as the anchor. When set to `false`, zooming in and out will zoom to\n * the center of the screen instead of zooming on the mouse's location.\n * @property {boolean} [constrainResolution=false] If true, the mouse wheel zoom\n * event will always animate to the closest zoom level after an interaction;\n * false means intermediary zoom levels are allowed.\n */\n\n/**\n * @classdesc\n * Allows the user to zoom the map by scrolling the mouse wheel.\n * @api\n */\nclass MouseWheelZoom extends Interaction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    super(\n      /** @type {import(\"./Interaction.js\").InteractionOptions} */ (options)\n    );\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.totalDelta_ = 0;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.lastDelta_ = 0;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = options.maxDelta !== undefined ? options.maxDelta : 1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 250;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.timeout_ = options.timeout !== undefined ? options.timeout : 80;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.useAnchor_ =\n      options.useAnchor !== undefined ? options.useAnchor : true;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.constrainResolution_ =\n      options.constrainResolution !== undefined\n        ? options.constrainResolution\n        : false;\n\n    const condition = options.condition ? options.condition : always;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.condition_ = options.onFocusOnly\n      ? all(focusWithTabindex, condition)\n      : condition;\n\n    /**\n     * @private\n     * @type {?import(\"../coordinate.js\").Coordinate}\n     */\n    this.lastAnchor_ = null;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.startTime_ = undefined;\n\n    /**\n     * @private\n     * @type {?}\n     */\n    this.timeoutId_;\n\n    /**\n     * @private\n     * @type {Mode|undefined}\n     */\n    this.mode_ = undefined;\n\n    /**\n     * Trackpad events separated by this delay will be considered separate\n     * interactions.\n     * @type {number}\n     */\n    this.trackpadEventGap_ = 400;\n\n    /**\n     * @type {?}\n     */\n    this.trackpadTimeoutId_;\n\n    /**\n     * The number of delta values per zoom level\n     * @private\n     * @type {number}\n     */\n    this.deltaPerZoom_ = 300;\n  }\n\n  /**\n   * @private\n   */\n  endInteraction_() {\n    this.trackpadTimeoutId_ = undefined;\n    const map = this.getMap();\n    if (!map) {\n      return;\n    }\n    const view = map.getView();\n    view.endInteraction(\n      undefined,\n      this.lastDelta_ ? (this.lastDelta_ > 0 ? 1 : -1) : 0,\n      this.lastAnchor_\n    );\n  }\n\n  /**\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a mousewheel-event) and eventually\n   * zooms the map.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   */\n  handleEvent(mapBrowserEvent) {\n    if (!this.condition_(mapBrowserEvent)) {\n      return true;\n    }\n    const type = mapBrowserEvent.type;\n    if (type !== EventType.WHEEL) {\n      return true;\n    }\n\n    const map = mapBrowserEvent.map;\n    const wheelEvent = /** @type {WheelEvent} */ (\n      mapBrowserEvent.originalEvent\n    );\n    wheelEvent.preventDefault();\n\n    if (this.useAnchor_) {\n      this.lastAnchor_ = mapBrowserEvent.coordinate;\n    }\n\n    // Delta normalisation inspired by\n    // https://github.com/mapbox/mapbox-gl-js/blob/001c7b9/js/ui/handler/scroll_zoom.js\n    let delta;\n    if (mapBrowserEvent.type == EventType.WHEEL) {\n      delta = wheelEvent.deltaY;\n      if (FIREFOX && wheelEvent.deltaMode === WheelEvent.DOM_DELTA_PIXEL) {\n        delta /= DEVICE_PIXEL_RATIO;\n      }\n      if (wheelEvent.deltaMode === WheelEvent.DOM_DELTA_LINE) {\n        delta *= 40;\n      }\n    }\n\n    if (delta === 0) {\n      return false;\n    }\n    this.lastDelta_ = delta;\n\n    const now = Date.now();\n\n    if (this.startTime_ === undefined) {\n      this.startTime_ = now;\n    }\n\n    if (!this.mode_ || now - this.startTime_ > this.trackpadEventGap_) {\n      this.mode_ = Math.abs(delta) < 4 ? 'trackpad' : 'wheel';\n    }\n\n    const view = map.getView();\n    if (\n      this.mode_ === 'trackpad' &&\n      !(view.getConstrainResolution() || this.constrainResolution_)\n    ) {\n      if (this.trackpadTimeoutId_) {\n        clearTimeout(this.trackpadTimeoutId_);\n      } else {\n        if (view.getAnimating()) {\n          view.cancelAnimations();\n        }\n        view.beginInteraction();\n      }\n      this.trackpadTimeoutId_ = setTimeout(\n        this.endInteraction_.bind(this),\n        this.timeout_\n      );\n      view.adjustZoom(-delta / this.deltaPerZoom_, this.lastAnchor_);\n      this.startTime_ = now;\n      return false;\n    }\n\n    this.totalDelta_ += delta;\n\n    const timeLeft = Math.max(this.timeout_ - (now - this.startTime_), 0);\n\n    clearTimeout(this.timeoutId_);\n    this.timeoutId_ = setTimeout(\n      this.handleWheelZoom_.bind(this, map),\n      timeLeft\n    );\n\n    return false;\n  }\n\n  /**\n   * @private\n   * @param {import(\"../Map.js\").default} map Map.\n   */\n  handleWheelZoom_(map) {\n    const view = map.getView();\n    if (view.getAnimating()) {\n      view.cancelAnimations();\n    }\n    let delta =\n      -clamp(\n        this.totalDelta_,\n        -this.maxDelta_ * this.deltaPerZoom_,\n        this.maxDelta_ * this.deltaPerZoom_\n      ) / this.deltaPerZoom_;\n    if (view.getConstrainResolution() || this.constrainResolution_) {\n      // view has a zoom constraint, zoom by 1\n      delta = delta ? (delta > 0 ? 1 : -1) : 0;\n    }\n    zoomByDelta(view, delta, this.lastAnchor_, this.duration_);\n\n    this.mode_ = undefined;\n    this.totalDelta_ = 0;\n    this.lastAnchor_ = null;\n    this.startTime_ = undefined;\n    this.timeoutId_ = undefined;\n  }\n\n  /**\n   * Enable or disable using the mouse's location as an anchor when zooming\n   * @param {boolean} useAnchor true to zoom to the mouse's location, false\n   * to zoom to the center of the map\n   * @api\n   */\n  setMouseAnchor(useAnchor) {\n    this.useAnchor_ = useAnchor;\n    if (!useAnchor) {\n      this.lastAnchor_ = null;\n    }\n  }\n}\n\nexport default MouseWheelZoom;\n","/**\n * @module ol/interaction/PinchRotate\n */\nimport PointerInteraction, {\n  centroid as centroidFromPointers,\n} from './Pointer.js';\nimport {FALSE} from '../functions.js';\nimport {disable} from '../rotationconstraint.js';\n\n/**\n * @typedef {Object} Options\n * @property {number} [duration=250] The duration of the animation in\n * milliseconds.\n * @property {number} [threshold=0.3] Minimal angle in radians to start a rotation.\n */\n\n/**\n * @classdesc\n * Allows the user to rotate the map by twisting with two fingers\n * on a touch screen.\n * @api\n */\nclass PinchRotate extends PointerInteraction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const pointerOptions = /** @type {import(\"./Pointer.js\").Options} */ (\n      options\n    );\n\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n\n    super(pointerOptions);\n\n    /**\n     * @private\n     * @type {import(\"../coordinate.js\").Coordinate}\n     */\n    this.anchor_ = null;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.lastAngle_ = undefined;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.rotating_ = false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.rotationDelta_ = 0.0;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.threshold_ = options.threshold !== undefined ? options.threshold : 0.3;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 250;\n  }\n\n  /**\n   * Handle pointer drag events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   */\n  handleDragEvent(mapBrowserEvent) {\n    let rotationDelta = 0.0;\n\n    const touch0 = this.targetPointers[0];\n    const touch1 = this.targetPointers[1];\n\n    // angle between touches\n    const angle = Math.atan2(\n      touch1.clientY - touch0.clientY,\n      touch1.clientX - touch0.clientX\n    );\n\n    if (this.lastAngle_ !== undefined) {\n      const delta = angle - this.lastAngle_;\n      this.rotationDelta_ += delta;\n      if (!this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_) {\n        this.rotating_ = true;\n      }\n      rotationDelta = delta;\n    }\n    this.lastAngle_ = angle;\n\n    const map = mapBrowserEvent.map;\n    const view = map.getView();\n    if (view.getConstraints().rotation === disable) {\n      return;\n    }\n\n    // rotate anchor point.\n    // FIXME: should be the intersection point between the lines:\n    //     touch0,touch1 and previousTouch0,previousTouch1\n    this.anchor_ = map.getCoordinateFromPixelInternal(\n      map.getEventPixel(centroidFromPointers(this.targetPointers))\n    );\n\n    // rotate\n    if (this.rotating_) {\n      map.render();\n      view.adjustRotationInternal(rotationDelta, this.anchor_);\n    }\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleUpEvent(mapBrowserEvent) {\n    if (this.targetPointers.length < 2) {\n      const map = mapBrowserEvent.map;\n      const view = map.getView();\n      view.endInteraction(this.duration_);\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Handle pointer down events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleDownEvent(mapBrowserEvent) {\n    if (this.targetPointers.length >= 2) {\n      const map = mapBrowserEvent.map;\n      this.anchor_ = null;\n      this.lastAngle_ = undefined;\n      this.rotating_ = false;\n      this.rotationDelta_ = 0.0;\n      if (!this.handlingDownUpSequence) {\n        map.getView().beginInteraction();\n      }\n      return true;\n    }\n    return false;\n  }\n}\n\nexport default PinchRotate;\n","/**\n * @module ol/interaction/PinchZoom\n */\nimport PointerInteraction, {\n  centroid as centroidFromPointers,\n} from './Pointer.js';\nimport {FALSE} from '../functions.js';\n\n/**\n * @typedef {Object} Options\n * @property {number} [duration=400] Animation duration in milliseconds.\n */\n\n/**\n * @classdesc\n * Allows the user to zoom the map by pinching with two fingers\n * on a touch screen.\n * @api\n */\nclass PinchZoom extends PointerInteraction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const pointerOptions = /** @type {import(\"./Pointer.js\").Options} */ (\n      options\n    );\n\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n\n    super(pointerOptions);\n\n    /**\n     * @private\n     * @type {import(\"../coordinate.js\").Coordinate}\n     */\n    this.anchor_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 400;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.lastDistance_ = undefined;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.lastScaleDelta_ = 1;\n  }\n\n  /**\n   * Handle pointer drag events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   */\n  handleDragEvent(mapBrowserEvent) {\n    let scaleDelta = 1.0;\n\n    const touch0 = this.targetPointers[0];\n    const touch1 = this.targetPointers[1];\n    const dx = touch0.clientX - touch1.clientX;\n    const dy = touch0.clientY - touch1.clientY;\n\n    // distance between touches\n    const distance = Math.sqrt(dx * dx + dy * dy);\n\n    if (this.lastDistance_ !== undefined) {\n      scaleDelta = this.lastDistance_ / distance;\n    }\n    this.lastDistance_ = distance;\n\n    const map = mapBrowserEvent.map;\n    const view = map.getView();\n\n    if (scaleDelta != 1.0) {\n      this.lastScaleDelta_ = scaleDelta;\n    }\n\n    // scale anchor point.\n    this.anchor_ = map.getCoordinateFromPixelInternal(\n      map.getEventPixel(centroidFromPointers(this.targetPointers))\n    );\n\n    // scale, bypass the resolution constraint\n    map.render();\n    view.adjustResolutionInternal(scaleDelta, this.anchor_);\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleUpEvent(mapBrowserEvent) {\n    if (this.targetPointers.length < 2) {\n      const map = mapBrowserEvent.map;\n      const view = map.getView();\n      const direction = this.lastScaleDelta_ > 1 ? 1 : -1;\n      view.endInteraction(this.duration_, direction);\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Handle pointer down events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleDownEvent(mapBrowserEvent) {\n    if (this.targetPointers.length >= 2) {\n      const map = mapBrowserEvent.map;\n      this.anchor_ = null;\n      this.lastDistance_ = undefined;\n      this.lastScaleDelta_ = 1;\n      if (!this.handlingDownUpSequence) {\n        map.getView().beginInteraction();\n      }\n      return true;\n    }\n    return false;\n  }\n}\n\nexport default PinchZoom;\n","/**\n * @module ol/interaction/defaults\n */\nimport Collection from '../Collection.js';\nimport DoubleClickZoom from './DoubleClickZoom.js';\nimport DragPan from './DragPan.js';\nimport DragRotate from './DragRotate.js';\nimport DragZoom from './DragZoom.js';\nimport KeyboardPan from './KeyboardPan.js';\nimport KeyboardZoom from './KeyboardZoom.js';\nimport Kinetic from '../Kinetic.js';\nimport MouseWheelZoom from './MouseWheelZoom.js';\nimport PinchRotate from './PinchRotate.js';\nimport PinchZoom from './PinchZoom.js';\n\n/**\n * @typedef {Object} DefaultsOptions\n * @property {boolean} [altShiftDragRotate=true] Whether Alt-Shift-drag rotate is\n * desired.\n * @property {boolean} [onFocusOnly=false] Interact only when the map has the\n * focus. This affects the `MouseWheelZoom` and `DragPan` interactions and is\n * useful when page scroll is desired for maps that do not have the browser's\n * focus.\n * @property {boolean} [doubleClickZoom=true] Whether double click zoom is\n * desired.\n * @property {boolean} [keyboard=true] Whether keyboard interaction is desired.\n * @property {boolean} [mouseWheelZoom=true] Whether mousewheel zoom is desired.\n * @property {boolean} [shiftDragZoom=true] Whether Shift-drag zoom is desired.\n * @property {boolean} [dragPan=true] Whether drag pan is desired.\n * @property {boolean} [pinchRotate=true] Whether pinch rotate is desired.\n * @property {boolean} [pinchZoom=true] Whether pinch zoom is desired.\n * @property {number} [zoomDelta] Zoom level delta when using keyboard or double click zoom.\n * @property {number} [zoomDuration] Duration of the zoom animation in\n * milliseconds.\n */\n\n/**\n * Set of interactions included in maps by default. Specific interactions can be\n * excluded by setting the appropriate option to false in the constructor\n * options, but the order of the interactions is fixed.  If you want to specify\n * a different order for interactions, you will need to create your own\n * {@link module:ol/interaction/Interaction~Interaction} instances and insert\n * them into a {@link module:ol/Collection~Collection} in the order you want\n * before creating your {@link module:ol/Map~Map} instance. Changing the order can\n * be of interest if the event propagation needs to be stopped at a point.\n * The default set of interactions, in sequence, is:\n * * {@link module:ol/interaction/DragRotate~DragRotate}\n * * {@link module:ol/interaction/DoubleClickZoom~DoubleClickZoom}\n * * {@link module:ol/interaction/DragPan~DragPan}\n * * {@link module:ol/interaction/PinchRotate~PinchRotate}\n * * {@link module:ol/interaction/PinchZoom~PinchZoom}\n * * {@link module:ol/interaction/KeyboardPan~KeyboardPan}\n * * {@link module:ol/interaction/KeyboardZoom~KeyboardZoom}\n * * {@link module:ol/interaction/MouseWheelZoom~MouseWheelZoom}\n * * {@link module:ol/interaction/DragZoom~DragZoom}\n *\n * @param {DefaultsOptions} [options] Defaults options.\n * @return {Collection<import(\"./Interaction.js\").default>}\n * A collection of interactions to be used with the {@link module:ol/Map~Map}\n * constructor's `interactions` option.\n * @api\n */\nexport function defaults(options) {\n  options = options ? options : {};\n\n  /** @type {Collection<import(\"./Interaction.js\").default>} */\n  const interactions = new Collection();\n\n  const kinetic = new Kinetic(-0.005, 0.05, 100);\n\n  const altShiftDragRotate =\n    options.altShiftDragRotate !== undefined\n      ? options.altShiftDragRotate\n      : true;\n  if (altShiftDragRotate) {\n    interactions.push(new DragRotate());\n  }\n\n  const doubleClickZoom =\n    options.doubleClickZoom !== undefined ? options.doubleClickZoom : true;\n  if (doubleClickZoom) {\n    interactions.push(\n      new DoubleClickZoom({\n        delta: options.zoomDelta,\n        duration: options.zoomDuration,\n      })\n    );\n  }\n\n  const dragPan = options.dragPan !== undefined ? options.dragPan : true;\n  if (dragPan) {\n    interactions.push(\n      new DragPan({\n        onFocusOnly: options.onFocusOnly,\n        kinetic: kinetic,\n      })\n    );\n  }\n\n  const pinchRotate =\n    options.pinchRotate !== undefined ? options.pinchRotate : true;\n  if (pinchRotate) {\n    interactions.push(new PinchRotate());\n  }\n\n  const pinchZoom = options.pinchZoom !== undefined ? options.pinchZoom : true;\n  if (pinchZoom) {\n    interactions.push(\n      new PinchZoom({\n        duration: options.zoomDuration,\n      })\n    );\n  }\n\n  const keyboard = options.keyboard !== undefined ? options.keyboard : true;\n  if (keyboard) {\n    interactions.push(new KeyboardPan());\n    interactions.push(\n      new KeyboardZoom({\n        delta: options.zoomDelta,\n        duration: options.zoomDuration,\n      })\n    );\n  }\n\n  const mouseWheelZoom =\n    options.mouseWheelZoom !== undefined ? options.mouseWheelZoom : true;\n  if (mouseWheelZoom) {\n    interactions.push(\n      new MouseWheelZoom({\n        onFocusOnly: options.onFocusOnly,\n        duration: options.zoomDuration,\n      })\n    );\n  }\n\n  const shiftDragZoom =\n    options.shiftDragZoom !== undefined ? options.shiftDragZoom : true;\n  if (shiftDragZoom) {\n    interactions.push(\n      new DragZoom({\n        duration: options.zoomDuration,\n      })\n    );\n  }\n\n  return interactions;\n}\n","/**\n * @module ol/layer/Base\n */\nimport BaseObject from '../Object.js';\nimport LayerProperty from './Property.js';\nimport {abstract} from '../util.js';\nimport {assert} from '../asserts.js';\nimport {clamp} from '../math.js';\n\n/**\n * A css color, or a function called with a view resolution returning a css color.\n *\n * @typedef {string|function(number):string} BackgroundColor\n * @api\n */\n\n/**\n * @typedef {import(\"../ObjectEventType\").Types|'change:extent'|'change:maxResolution'|'change:maxZoom'|\n *    'change:minResolution'|'change:minZoom'|'change:opacity'|'change:visible'|'change:zIndex'} BaseLayerObjectEventTypes\n */\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<BaseLayerObjectEventTypes, import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|BaseLayerObjectEventTypes, Return>} BaseLayerOnSignature\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {BackgroundColor} [background] Background color for the layer. If not specified, no background\n * will be rendered.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Note that with {@link module:ol/layer/Base~BaseLayer} and all its subclasses, any property set in\n * the options is set as a {@link module:ol/Object~BaseObject} property on the layer object, so\n * is observable, and has get/set accessors.\n *\n * @api\n */\nclass BaseLayer extends BaseObject {\n  /**\n   * @param {Options} options Layer options.\n   */\n  constructor(options) {\n    super();\n\n    /***\n     * @type {BaseLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {BaseLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {BaseLayerOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @type {BackgroundColor|false}\n     * @private\n     */\n    this.background_ = options.background;\n\n    /**\n     * @type {Object<string, *>}\n     */\n    const properties = Object.assign({}, options);\n    if (typeof options.properties === 'object') {\n      delete properties.properties;\n      Object.assign(properties, options.properties);\n    }\n\n    properties[LayerProperty.OPACITY] =\n      options.opacity !== undefined ? options.opacity : 1;\n    assert(typeof properties[LayerProperty.OPACITY] === 'number', 64); // Layer opacity must be a number\n\n    properties[LayerProperty.VISIBLE] =\n      options.visible !== undefined ? options.visible : true;\n    properties[LayerProperty.Z_INDEX] = options.zIndex;\n    properties[LayerProperty.MAX_RESOLUTION] =\n      options.maxResolution !== undefined ? options.maxResolution : Infinity;\n    properties[LayerProperty.MIN_RESOLUTION] =\n      options.minResolution !== undefined ? options.minResolution : 0;\n    properties[LayerProperty.MIN_ZOOM] =\n      options.minZoom !== undefined ? options.minZoom : -Infinity;\n    properties[LayerProperty.MAX_ZOOM] =\n      options.maxZoom !== undefined ? options.maxZoom : Infinity;\n\n    /**\n     * @type {string}\n     * @private\n     */\n    this.className_ =\n      properties.className !== undefined ? properties.className : 'ol-layer';\n    delete properties.className;\n\n    this.setProperties(properties);\n\n    /**\n     * @type {import(\"./Layer.js\").State}\n     * @private\n     */\n    this.state_ = null;\n  }\n\n  /**\n   * Get the background for this layer.\n   * @return {BackgroundColor|false} Layer background.\n   */\n  getBackground() {\n    return this.background_;\n  }\n\n  /**\n   * @return {string} CSS class name.\n   */\n  getClassName() {\n    return this.className_;\n  }\n\n  /**\n   * This method is not meant to be called by layers or layer renderers because the state\n   * is incorrect if the layer is included in a layer group.\n   *\n   * @param {boolean} [managed] Layer is managed.\n   * @return {import(\"./Layer.js\").State} Layer state.\n   */\n  getLayerState(managed) {\n    /** @type {import(\"./Layer.js\").State} */\n    const state =\n      this.state_ ||\n      /** @type {?} */ ({\n        layer: this,\n        managed: managed === undefined ? true : managed,\n      });\n    const zIndex = this.getZIndex();\n    state.opacity = clamp(Math.round(this.getOpacity() * 100) / 100, 0, 1);\n    state.visible = this.getVisible();\n    state.extent = this.getExtent();\n    state.zIndex = zIndex === undefined && !state.managed ? Infinity : zIndex;\n    state.maxResolution = this.getMaxResolution();\n    state.minResolution = Math.max(this.getMinResolution(), 0);\n    state.minZoom = this.getMinZoom();\n    state.maxZoom = this.getMaxZoom();\n    this.state_ = state;\n\n    return state;\n  }\n\n  /**\n   * @abstract\n   * @param {Array<import(\"./Layer.js\").default>} [array] Array of layers (to be\n   *     modified in place).\n   * @return {Array<import(\"./Layer.js\").default>} Array of layers.\n   */\n  getLayersArray(array) {\n    return abstract();\n  }\n\n  /**\n   * @abstract\n   * @param {Array<import(\"./Layer.js\").State>} [states] Optional list of layer\n   *     states (to be modified in place).\n   * @return {Array<import(\"./Layer.js\").State>} List of layer states.\n   */\n  getLayerStatesArray(states) {\n    return abstract();\n  }\n\n  /**\n   * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it\n   * will be visible regardless of extent.\n   * @return {import(\"../extent.js\").Extent|undefined} The layer extent.\n   * @observable\n   * @api\n   */\n  getExtent() {\n    return /** @type {import(\"../extent.js\").Extent|undefined} */ (\n      this.get(LayerProperty.EXTENT)\n    );\n  }\n\n  /**\n   * Return the maximum resolution of the layer.\n   * @return {number} The maximum resolution of the layer.\n   * @observable\n   * @api\n   */\n  getMaxResolution() {\n    return /** @type {number} */ (this.get(LayerProperty.MAX_RESOLUTION));\n  }\n\n  /**\n   * Return the minimum resolution of the layer.\n   * @return {number} The minimum resolution of the layer.\n   * @observable\n   * @api\n   */\n  getMinResolution() {\n    return /** @type {number} */ (this.get(LayerProperty.MIN_RESOLUTION));\n  }\n\n  /**\n   * Return the minimum zoom level of the layer.\n   * @return {number} The minimum zoom level of the layer.\n   * @observable\n   * @api\n   */\n  getMinZoom() {\n    return /** @type {number} */ (this.get(LayerProperty.MIN_ZOOM));\n  }\n\n  /**\n   * Return the maximum zoom level of the layer.\n   * @return {number} The maximum zoom level of the layer.\n   * @observable\n   * @api\n   */\n  getMaxZoom() {\n    return /** @type {number} */ (this.get(LayerProperty.MAX_ZOOM));\n  }\n\n  /**\n   * Return the opacity of the layer (between 0 and 1).\n   * @return {number} The opacity of the layer.\n   * @observable\n   * @api\n   */\n  getOpacity() {\n    return /** @type {number} */ (this.get(LayerProperty.OPACITY));\n  }\n\n  /**\n   * @abstract\n   * @return {import(\"../source/Source.js\").State} Source state.\n   */\n  getSourceState() {\n    return abstract();\n  }\n\n  /**\n   * Return the visibility of the layer (`true` or `false`).\n   * @return {boolean} The visibility of the layer.\n   * @observable\n   * @api\n   */\n  getVisible() {\n    return /** @type {boolean} */ (this.get(LayerProperty.VISIBLE));\n  }\n\n  /**\n   * Return the Z-index of the layer, which is used to order layers before\n   * rendering. The default Z-index is 0.\n   * @return {number} The Z-index of the layer.\n   * @observable\n   * @api\n   */\n  getZIndex() {\n    return /** @type {number} */ (this.get(LayerProperty.Z_INDEX));\n  }\n\n  /**\n   * Sets the background color.\n   * @param {BackgroundColor} [background] Background color.\n   */\n  setBackground(background) {\n    this.background_ = background;\n    this.changed();\n  }\n\n  /**\n   * Set the extent at which the layer is visible.  If `undefined`, the layer\n   * will be visible at all extents.\n   * @param {import(\"../extent.js\").Extent|undefined} extent The extent of the layer.\n   * @observable\n   * @api\n   */\n  setExtent(extent) {\n    this.set(LayerProperty.EXTENT, extent);\n  }\n\n  /**\n   * Set the maximum resolution at which the layer is visible.\n   * @param {number} maxResolution The maximum resolution of the layer.\n   * @observable\n   * @api\n   */\n  setMaxResolution(maxResolution) {\n    this.set(LayerProperty.MAX_RESOLUTION, maxResolution);\n  }\n\n  /**\n   * Set the minimum resolution at which the layer is visible.\n   * @param {number} minResolution The minimum resolution of the layer.\n   * @observable\n   * @api\n   */\n  setMinResolution(minResolution) {\n    this.set(LayerProperty.MIN_RESOLUTION, minResolution);\n  }\n\n  /**\n   * Set the maximum zoom (exclusive) at which the layer is visible.\n   * Note that the zoom levels for layer visibility are based on the\n   * view zoom level, which may be different from a tile source zoom level.\n   * @param {number} maxZoom The maximum zoom of the layer.\n   * @observable\n   * @api\n   */\n  setMaxZoom(maxZoom) {\n    this.set(LayerProperty.MAX_ZOOM, maxZoom);\n  }\n\n  /**\n   * Set the minimum zoom (inclusive) at which the layer is visible.\n   * Note that the zoom levels for layer visibility are based on the\n   * view zoom level, which may be different from a tile source zoom level.\n   * @param {number} minZoom The minimum zoom of the layer.\n   * @observable\n   * @api\n   */\n  setMinZoom(minZoom) {\n    this.set(LayerProperty.MIN_ZOOM, minZoom);\n  }\n\n  /**\n   * Set the opacity of the layer, allowed values range from 0 to 1.\n   * @param {number} opacity The opacity of the layer.\n   * @observable\n   * @api\n   */\n  setOpacity(opacity) {\n    assert(typeof opacity === 'number', 64); // Layer opacity must be a number\n    this.set(LayerProperty.OPACITY, opacity);\n  }\n\n  /**\n   * Set the visibility of the layer (`true` or `false`).\n   * @param {boolean} visible The visibility of the layer.\n   * @observable\n   * @api\n   */\n  setVisible(visible) {\n    this.set(LayerProperty.VISIBLE, visible);\n  }\n\n  /**\n   * Set Z-index of the layer, which is used to order layers before rendering.\n   * The default Z-index is 0.\n   * @param {number} zindex The z-index of the layer.\n   * @observable\n   * @api\n   */\n  setZIndex(zindex) {\n    this.set(LayerProperty.Z_INDEX, zindex);\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    if (this.state_) {\n      this.state_.layer = null;\n      this.state_ = null;\n    }\n    super.disposeInternal();\n  }\n}\n\nexport default BaseLayer;\n","/**\n * @module ol/layer/BaseTile\n */\nimport Layer from './Layer.js';\nimport TileProperty from './TileProperty.js';\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./Base\").BaseLayerObjectEventTypes|\n *     import(\"./Layer.js\").LayerEventType|'change:preload'|'change:useInterimTilesOnError', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../render/EventType\").LayerRenderEventTypes, import(\"../render/Event\").default, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"./Base\").BaseLayerObjectEventTypes|\n *   import(\"./Layer.js\").LayerEventType|'change:preload'|'change:useInterimTilesOnError'|import(\"../render/EventType\").LayerRenderEventTypes, Return>} BaseTileLayerOnSignature\n */\n\n/**\n * @template {import(\"../source/Tile.js\").default} TileSourceType\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`\n * means no preloading.\n * @property {TileSourceType} [source] Source for this layer.\n * @property {import(\"../Map.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\n * use {@link import(\"../Map.js\").default#addLayer map.addLayer()}.\n * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n\n/**\n * @classdesc\n * For layer sources that provide pre-rendered, tiled images in grids that are\n * organized by zoom levels for specific resolutions.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/Tile.js\").default} TileSourceType\n * @template {import(\"../renderer/Layer.js\").default} RendererType\n * @extends {Layer<TileSourceType, RendererType>}\n * @api\n */\nclass BaseTileLayer extends Layer {\n  /**\n   * @param {Options<TileSourceType>} [options] Tile layer options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const baseOptions = Object.assign({}, options);\n\n    delete baseOptions.preload;\n    delete baseOptions.useInterimTilesOnError;\n    super(baseOptions);\n\n    /***\n     * @type {BaseTileLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {BaseTileLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {BaseTileLayerOnSignature<void>}\n     */\n    this.un;\n\n    this.setPreload(options.preload !== undefined ? options.preload : 0);\n    this.setUseInterimTilesOnError(\n      options.useInterimTilesOnError !== undefined\n        ? options.useInterimTilesOnError\n        : true\n    );\n  }\n\n  /**\n   * Return the level as number to which we will preload tiles up to.\n   * @return {number} The level to preload tiles up to.\n   * @observable\n   * @api\n   */\n  getPreload() {\n    return /** @type {number} */ (this.get(TileProperty.PRELOAD));\n  }\n\n  /**\n   * Set the level as number to which we will preload tiles up to.\n   * @param {number} preload The level to preload tiles up to.\n   * @observable\n   * @api\n   */\n  setPreload(preload) {\n    this.set(TileProperty.PRELOAD, preload);\n  }\n\n  /**\n   * Whether we use interim tiles on error.\n   * @return {boolean} Use interim tiles on error.\n   * @observable\n   * @api\n   */\n  getUseInterimTilesOnError() {\n    return /** @type {boolean} */ (\n      this.get(TileProperty.USE_INTERIM_TILES_ON_ERROR)\n    );\n  }\n\n  /**\n   * Set whether we use interim tiles on error.\n   * @param {boolean} useInterimTilesOnError Use interim tiles on error.\n   * @observable\n   * @api\n   */\n  setUseInterimTilesOnError(useInterimTilesOnError) {\n    this.set(TileProperty.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);\n  }\n\n  /**\n   * Get data for a pixel location.  The return type depends on the source data.  For image tiles,\n   * a four element RGBA array will be returned.  For data tiles, the array length will match the\n   * number of bands in the dataset.  For requests outside the layer extent, `null` will be returned.\n   * Data for a image tiles can only be retrieved if the source's `crossOrigin` property is set.\n   *\n   * ```js\n   * // display layer data on every pointer move\n   * map.on('pointermove', (event) => {\n   *   console.log(layer.getData(event.pixel));\n   * });\n   * ```\n   * @param {import(\"../pixel\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\n   * @api\n   */\n  getData(pixel) {\n    return super.getData(pixel);\n  }\n}\n\nexport default BaseTileLayer;\n","/**\n * @module ol/layer/BaseVector\n */\nimport Layer from './Layer.js';\nimport RBush from 'rbush';\nimport Style, {\n  createDefaultStyle,\n  toFunction as toStyleFunction,\n} from '../style/Style.js';\nimport {toStyle} from '../style/flat.js';\n\n/**\n * @template {import(\"../source/Vector.js\").default|import(\"../source/VectorTile.js\").default} VectorSourceType\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {import(\"../render.js\").OrderFunction} [renderOrder] Render order. Function to be used when sorting\n * features before rendering. By default features are drawn in the order that they are created. Use\n * `null` to avoid the sort, but get an undefined draw order.\n * @property {number} [renderBuffer=100] The buffer in pixels around the viewport extent used by the\n * renderer when getting features from the vector source for the rendering or hit-detection.\n * Recommended value: the size of the largest symbol, line width or label.\n * @property {VectorSourceType} [source] Source.\n * @property {import(\"../Map.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\n * use [map.addLayer()]{@link import(\"../Map.js\").default#addLayer}.\n * @property {boolean} [declutter=false] Declutter images and text. Decluttering is applied to all\n * image and text styles of all Vector and VectorTile layers that have set this to `true`. The priority\n * is defined by the z-index of the layer, the `zIndex` of the style and the render order of features.\n * Higher z-index means higher priority. Within the same z-index, a feature rendered before another has\n * higher priority.\n *\n * As an optimization decluttered features from layers with the same `className` are rendered above\n * the fill and stroke styles of all of those layers regardless of z-index.  To opt out of this\n * behavior and place declutterd features with their own layer configure the layer with a `className`\n * other than `ol-layer`.\n * @property {import(\"../style/Style.js\").StyleLike|import(\"../style/flat.js\").FlatStyleLike|null} [style] Layer style. When set to `null`, only\n * features that have their own style will be rendered. See {@link module:ol/style/Style~Style} for the default style\n * which will be used if this is not set.\n * @property {import(\"./Base.js\").BackgroundColor} [background] Background color for the layer. If not specified, no background\n * will be rendered.\n * @property {boolean} [updateWhileAnimating=false] When set to `true`, feature batches will\n * be recreated during animations. This means that no vectors will be shown clipped, but the\n * setting will have a performance impact for large amounts of vector data. When set to `false`,\n * batches will be recreated when no animation is active.\n * @property {boolean} [updateWhileInteracting=false] When set to `true`, feature batches will\n * be recreated during interactions. See also `updateWhileAnimating`.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n\n/**\n * @enum {string}\n * @private\n */\nconst Property = {\n  RENDER_ORDER: 'renderOrder',\n};\n\n/**\n * @classdesc\n * Vector data that is rendered client-side.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/Vector.js\").default|import(\"../source/VectorTile.js\").default} VectorSourceType\n * @template {import(\"../renderer/canvas/VectorLayer.js\").default|import(\"../renderer/canvas/VectorTileLayer.js\").default|import(\"../renderer/canvas/VectorImageLayer.js\").default|import(\"../renderer/webgl/PointsLayer.js\").default} RendererType\n * @extends {Layer<VectorSourceType, RendererType>}\n * @api\n */\nclass BaseVectorLayer extends Layer {\n  /**\n   * @param {Options<VectorSourceType>} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const baseOptions = Object.assign({}, options);\n\n    delete baseOptions.style;\n    delete baseOptions.renderBuffer;\n    delete baseOptions.updateWhileAnimating;\n    delete baseOptions.updateWhileInteracting;\n    super(baseOptions);\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.declutter_ =\n      options.declutter !== undefined ? options.declutter : false;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.renderBuffer_ =\n      options.renderBuffer !== undefined ? options.renderBuffer : 100;\n\n    /**\n     * User provided style.\n     * @type {import(\"../style/Style.js\").StyleLike}\n     * @private\n     */\n    this.style_ = null;\n\n    /**\n     * Style function for use within the library.\n     * @type {import(\"../style/Style.js\").StyleFunction|undefined}\n     * @private\n     */\n    this.styleFunction_ = undefined;\n\n    this.setStyle(options.style);\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.updateWhileAnimating_ =\n      options.updateWhileAnimating !== undefined\n        ? options.updateWhileAnimating\n        : false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.updateWhileInteracting_ =\n      options.updateWhileInteracting !== undefined\n        ? options.updateWhileInteracting\n        : false;\n  }\n\n  /**\n   * @return {boolean} Declutter.\n   */\n  getDeclutter() {\n    return this.declutter_;\n  }\n\n  /**\n   * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise\n   * that resolves with an array of features. The array will either contain the topmost feature\n   * when a hit was detected, or it will be empty.\n   *\n   * The hit detection algorithm used for this method is optimized for performance, but is less\n   * accurate than the one used in [map.getFeaturesAtPixel()]{@link import(\"../Map.js\").default#getFeaturesAtPixel}.\n   * Text is not considered, and icons are only represented by their bounding box instead of the exact\n   * image.\n   *\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../Feature\").FeatureLike>>} Promise that resolves with an array of features.\n   * @api\n   */\n  getFeatures(pixel) {\n    return super.getFeatures(pixel);\n  }\n\n  /**\n   * @return {number|undefined} Render buffer.\n   */\n  getRenderBuffer() {\n    return this.renderBuffer_;\n  }\n\n  /**\n   * @return {function(import(\"../Feature.js\").default, import(\"../Feature.js\").default): number|null|undefined} Render\n   *     order.\n   */\n  getRenderOrder() {\n    return /** @type {import(\"../render.js\").OrderFunction|null|undefined} */ (\n      this.get(Property.RENDER_ORDER)\n    );\n  }\n\n  /**\n   * Get the style for features.  This returns whatever was passed to the `style`\n   * option at construction or to the `setStyle` method.\n   * @return {import(\"../style/Style.js\").StyleLike|null|undefined} Layer style.\n   * @api\n   */\n  getStyle() {\n    return this.style_;\n  }\n\n  /**\n   * Get the style function.\n   * @return {import(\"../style/Style.js\").StyleFunction|undefined} Layer style function.\n   * @api\n   */\n  getStyleFunction() {\n    return this.styleFunction_;\n  }\n\n  /**\n   * @return {boolean} Whether the rendered layer should be updated while\n   *     animating.\n   */\n  getUpdateWhileAnimating() {\n    return this.updateWhileAnimating_;\n  }\n\n  /**\n   * @return {boolean} Whether the rendered layer should be updated while\n   *     interacting.\n   */\n  getUpdateWhileInteracting() {\n    return this.updateWhileInteracting_;\n  }\n\n  /**\n   * Render declutter items for this layer\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   */\n  renderDeclutter(frameState) {\n    if (!frameState.declutterTree) {\n      frameState.declutterTree = new RBush(9);\n    }\n    /** @type {*} */ (this.getRenderer()).renderDeclutter(frameState);\n  }\n\n  /**\n   * @param {import(\"../render.js\").OrderFunction|null|undefined} renderOrder\n   *     Render order.\n   */\n  setRenderOrder(renderOrder) {\n    this.set(Property.RENDER_ORDER, renderOrder);\n  }\n\n  /**\n   * Set the style for features.  This can be a single style object, an array\n   * of styles, or a function that takes a feature and resolution and returns\n   * an array of styles. If set to `null`, the layer has no style (a `null` style),\n   * so only features that have their own styles will be rendered in the layer. Call\n   * `setStyle()` without arguments to reset to the default style. See\n   * [the ol/style/Style module]{@link module:ol/style/Style~Style} for information on the default style.\n   *\n   * If your layer has a static style, you can use \"flat\" style object literals instead of\n   * using the `Style` and symbolizer constructors (`Fill`, `Stroke`, etc.).  See the documentation\n   * for the [flat style types]{@link module:ol/style/flat~FlatStyle} to see what properties are supported.\n   *\n   * @param {import(\"../style/Style.js\").StyleLike|import(\"../style/flat.js\").FlatStyleLike|null} [style] Layer style.\n   * @api\n   */\n  setStyle(style) {\n    /**\n     * @type {import(\"../style/Style.js\").StyleLike|null}\n     */\n    let styleLike;\n\n    if (style === undefined) {\n      styleLike = createDefaultStyle;\n    } else if (style === null) {\n      styleLike = null;\n    } else if (typeof style === 'function') {\n      styleLike = style;\n    } else if (style instanceof Style) {\n      styleLike = style;\n    } else if (Array.isArray(style)) {\n      const len = style.length;\n\n      /**\n       * @type {Array<Style>}\n       */\n      const styles = new Array(len);\n\n      for (let i = 0; i < len; ++i) {\n        const s = style[i];\n        if (s instanceof Style) {\n          styles[i] = s;\n        } else {\n          styles[i] = toStyle(s);\n        }\n      }\n      styleLike = styles;\n    } else {\n      styleLike = toStyle(style);\n    }\n\n    this.style_ = styleLike;\n    this.styleFunction_ =\n      style === null ? undefined : toStyleFunction(this.style_);\n    this.changed();\n  }\n}\n\nexport default BaseVectorLayer;\n","/**\n * @module ol/layer/Group\n */\nimport BaseLayer from './Base.js';\nimport Collection from '../Collection.js';\nimport CollectionEventType from '../CollectionEventType.js';\nimport Event from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport ObjectEventType from '../ObjectEventType.js';\nimport {assert} from '../asserts.js';\nimport {clear} from '../obj.js';\nimport {getIntersection} from '../extent.js';\nimport {getUid} from '../util.js';\nimport {listen, unlistenByKey} from '../events.js';\n\n/**\n * @typedef {'addlayer'|'removelayer'} EventType\n */\n\n/**\n * @classdesc\n * A layer group triggers 'addlayer' and 'removelayer' events when layers are added to or removed from\n * the group or one of its child groups.  When a layer group is added to or removed from another layer group,\n * a single event will be triggered (instead of one per layer in the group added or removed).\n */\nexport class GroupEvent extends Event {\n  /**\n   * @param {EventType} type The event type.\n   * @param {BaseLayer} layer The layer.\n   */\n  constructor(type, layer) {\n    super(type);\n\n    /**\n     * The added or removed layer.\n     * @type {BaseLayer}\n     * @api\n     */\n    this.layer = layer;\n  }\n}\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./Base\").BaseLayerObjectEventTypes|\n *     'change:layers', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"./Base\").BaseLayerObjectEventTypes|'change:layers', Return>} GroupOnSignature\n */\n\n/**\n * @typedef {Object} Options\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {Array<import(\"./Base.js\").default>|Collection<import(\"./Base.js\").default>} [layers] Child layers.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n\n/**\n * @enum {string}\n * @private\n */\nconst Property = {\n  LAYERS: 'layers',\n};\n\n/**\n * @classdesc\n * A {@link module:ol/Collection~Collection} of layers that are handled together.\n *\n * A generic `change` event is triggered when the group/Collection changes.\n *\n * @api\n */\nclass LayerGroup extends BaseLayer {\n  /**\n   * @param {Options} [options] Layer options.\n   */\n  constructor(options) {\n    options = options || {};\n    const baseOptions = /** @type {Options} */ (Object.assign({}, options));\n    delete baseOptions.layers;\n\n    let layers = options.layers;\n\n    super(baseOptions);\n\n    /***\n     * @type {GroupOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {GroupOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {GroupOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @private\n     * @type {Array<import(\"../events.js\").EventsKey>}\n     */\n    this.layersListenerKeys_ = [];\n\n    /**\n     * @private\n     * @type {Object<string, Array<import(\"../events.js\").EventsKey>>}\n     */\n    this.listenerKeys_ = {};\n\n    this.addChangeListener(Property.LAYERS, this.handleLayersChanged_);\n\n    if (layers) {\n      if (Array.isArray(layers)) {\n        layers = new Collection(layers.slice(), {unique: true});\n      } else {\n        assert(typeof (/** @type {?} */ (layers).getArray) === 'function', 43); // Expected `layers` to be an array or a `Collection`\n      }\n    } else {\n      layers = new Collection(undefined, {unique: true});\n    }\n\n    this.setLayers(layers);\n  }\n\n  /**\n   * @private\n   */\n  handleLayerChange_() {\n    this.changed();\n  }\n\n  /**\n   * @private\n   */\n  handleLayersChanged_() {\n    this.layersListenerKeys_.forEach(unlistenByKey);\n    this.layersListenerKeys_.length = 0;\n\n    const layers = this.getLayers();\n    this.layersListenerKeys_.push(\n      listen(layers, CollectionEventType.ADD, this.handleLayersAdd_, this),\n      listen(layers, CollectionEventType.REMOVE, this.handleLayersRemove_, this)\n    );\n\n    for (const id in this.listenerKeys_) {\n      this.listenerKeys_[id].forEach(unlistenByKey);\n    }\n    clear(this.listenerKeys_);\n\n    const layersArray = layers.getArray();\n    for (let i = 0, ii = layersArray.length; i < ii; i++) {\n      const layer = layersArray[i];\n      this.registerLayerListeners_(layer);\n      this.dispatchEvent(new GroupEvent('addlayer', layer));\n    }\n    this.changed();\n  }\n\n  /**\n   * @param {BaseLayer} layer The layer.\n   */\n  registerLayerListeners_(layer) {\n    const listenerKeys = [\n      listen(\n        layer,\n        ObjectEventType.PROPERTYCHANGE,\n        this.handleLayerChange_,\n        this\n      ),\n      listen(layer, EventType.CHANGE, this.handleLayerChange_, this),\n    ];\n\n    if (layer instanceof LayerGroup) {\n      listenerKeys.push(\n        listen(layer, 'addlayer', this.handleLayerGroupAdd_, this),\n        listen(layer, 'removelayer', this.handleLayerGroupRemove_, this)\n      );\n    }\n\n    this.listenerKeys_[getUid(layer)] = listenerKeys;\n  }\n\n  /**\n   * @param {GroupEvent} event The layer group event.\n   */\n  handleLayerGroupAdd_(event) {\n    this.dispatchEvent(new GroupEvent('addlayer', event.layer));\n  }\n\n  /**\n   * @param {GroupEvent} event The layer group event.\n   */\n  handleLayerGroupRemove_(event) {\n    this.dispatchEvent(new GroupEvent('removelayer', event.layer));\n  }\n\n  /**\n   * @param {import(\"../Collection.js\").CollectionEvent<import(\"./Base.js\").default>} collectionEvent CollectionEvent.\n   * @private\n   */\n  handleLayersAdd_(collectionEvent) {\n    const layer = collectionEvent.element;\n    this.registerLayerListeners_(layer);\n    this.dispatchEvent(new GroupEvent('addlayer', layer));\n    this.changed();\n  }\n\n  /**\n   * @param {import(\"../Collection.js\").CollectionEvent<import(\"./Base.js\").default>} collectionEvent CollectionEvent.\n   * @private\n   */\n  handleLayersRemove_(collectionEvent) {\n    const layer = collectionEvent.element;\n    const key = getUid(layer);\n    this.listenerKeys_[key].forEach(unlistenByKey);\n    delete this.listenerKeys_[key];\n    this.dispatchEvent(new GroupEvent('removelayer', layer));\n    this.changed();\n  }\n\n  /**\n   * Returns the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}\n   * in this group.\n   * @return {!Collection<import(\"./Base.js\").default>} Collection of\n   *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.\n   * @observable\n   * @api\n   */\n  getLayers() {\n    return /** @type {!Collection<import(\"./Base.js\").default>} */ (\n      this.get(Property.LAYERS)\n    );\n  }\n\n  /**\n   * Set the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}\n   * in this group.\n   * @param {!Collection<import(\"./Base.js\").default>} layers Collection of\n   *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.\n   * @observable\n   * @api\n   */\n  setLayers(layers) {\n    const collection = this.getLayers();\n    if (collection) {\n      const currentLayers = collection.getArray();\n      for (let i = 0, ii = currentLayers.length; i < ii; ++i) {\n        this.dispatchEvent(new GroupEvent('removelayer', currentLayers[i]));\n      }\n    }\n\n    this.set(Property.LAYERS, layers);\n  }\n\n  /**\n   * @param {Array<import(\"./Layer.js\").default>} [array] Array of layers (to be modified in place).\n   * @return {Array<import(\"./Layer.js\").default>} Array of layers.\n   */\n  getLayersArray(array) {\n    array = array !== undefined ? array : [];\n    this.getLayers().forEach(function (layer) {\n      layer.getLayersArray(array);\n    });\n    return array;\n  }\n\n  /**\n   * Get the layer states list and use this groups z-index as the default\n   * for all layers in this and nested groups, if it is unset at this point.\n   * If dest is not provided and this group's z-index is undefined\n   * 0 is used a the default z-index.\n   * @param {Array<import(\"./Layer.js\").State>} [dest] Optional list\n   * of layer states (to be modified in place).\n   * @return {Array<import(\"./Layer.js\").State>} List of layer states.\n   */\n  getLayerStatesArray(dest) {\n    const states = dest !== undefined ? dest : [];\n    const pos = states.length;\n\n    this.getLayers().forEach(function (layer) {\n      layer.getLayerStatesArray(states);\n    });\n\n    const ownLayerState = this.getLayerState();\n    let defaultZIndex = ownLayerState.zIndex;\n    if (!dest && ownLayerState.zIndex === undefined) {\n      defaultZIndex = 0;\n    }\n    for (let i = pos, ii = states.length; i < ii; i++) {\n      const layerState = states[i];\n      layerState.opacity *= ownLayerState.opacity;\n      layerState.visible = layerState.visible && ownLayerState.visible;\n      layerState.maxResolution = Math.min(\n        layerState.maxResolution,\n        ownLayerState.maxResolution\n      );\n      layerState.minResolution = Math.max(\n        layerState.minResolution,\n        ownLayerState.minResolution\n      );\n      layerState.minZoom = Math.max(layerState.minZoom, ownLayerState.minZoom);\n      layerState.maxZoom = Math.min(layerState.maxZoom, ownLayerState.maxZoom);\n      if (ownLayerState.extent !== undefined) {\n        if (layerState.extent !== undefined) {\n          layerState.extent = getIntersection(\n            layerState.extent,\n            ownLayerState.extent\n          );\n        } else {\n          layerState.extent = ownLayerState.extent;\n        }\n      }\n      if (layerState.zIndex === undefined) {\n        layerState.zIndex = defaultZIndex;\n      }\n    }\n\n    return states;\n  }\n\n  /**\n   * @return {import(\"../source/Source.js\").State} Source state.\n   */\n  getSourceState() {\n    return 'ready';\n  }\n}\n\nexport default LayerGroup;\n","/**\n * @module ol/layer/Heatmap\n */\nimport BaseVector from './BaseVector.js';\nimport WebGLPointsLayerRenderer from '../renderer/webgl/PointsLayer.js';\nimport {clamp} from '../math.js';\nimport {createCanvasContext2D} from '../dom.js';\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {Array<string>} [gradient=['#00f', '#0ff', '#0f0', '#ff0', '#f00']] The color gradient\n * of the heatmap, specified as an array of CSS color strings.\n * @property {number} [radius=8] Radius size in pixels.\n * @property {number} [blur=15] Blur size in pixels.\n * @property {string|function(import(\"../Feature.js\").default):number} [weight='weight'] The feature\n * attribute to use for the weight or a function that returns a weight from a feature. Weight values\n * should range from 0 to 1 (and values outside will be clamped to that range).\n * @property {import(\"../source/Vector.js\").default<import(\"../geom/Point.js\").default>} [source] Point source.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n\n/**\n * @enum {string}\n * @private\n */\nconst Property = {\n  BLUR: 'blur',\n  GRADIENT: 'gradient',\n  RADIUS: 'radius',\n};\n\n/**\n * @const\n * @type {Array<string>}\n */\nconst DEFAULT_GRADIENT = ['#00f', '#0ff', '#0f0', '#ff0', '#f00'];\n\n/**\n * @classdesc\n * Layer for rendering vector data as a heatmap.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @fires import(\"../render/Event.js\").RenderEvent\n * @extends {BaseVector<import(\"../source/Vector.js\").default, WebGLPointsLayerRenderer>}\n * @api\n */\nclass Heatmap extends BaseVector {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const baseOptions = Object.assign({}, options);\n\n    delete baseOptions.gradient;\n    delete baseOptions.radius;\n    delete baseOptions.blur;\n    delete baseOptions.weight;\n    super(baseOptions);\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.gradient_ = null;\n\n    this.addChangeListener(Property.GRADIENT, this.handleGradientChanged_);\n\n    this.setGradient(options.gradient ? options.gradient : DEFAULT_GRADIENT);\n\n    this.setBlur(options.blur !== undefined ? options.blur : 15);\n\n    this.setRadius(options.radius !== undefined ? options.radius : 8);\n\n    const weight = options.weight ? options.weight : 'weight';\n    if (typeof weight === 'string') {\n      this.weightFunction_ = function (feature) {\n        return feature.get(weight);\n      };\n    } else {\n      this.weightFunction_ = weight;\n    }\n\n    // For performance reasons, don't sort the features before rendering.\n    // The render order is not relevant for a heatmap representation.\n    this.setRenderOrder(null);\n  }\n\n  /**\n   * Return the blur size in pixels.\n   * @return {number} Blur size in pixels.\n   * @api\n   * @observable\n   */\n  getBlur() {\n    return /** @type {number} */ (this.get(Property.BLUR));\n  }\n\n  /**\n   * Return the gradient colors as array of strings.\n   * @return {Array<string>} Colors.\n   * @api\n   * @observable\n   */\n  getGradient() {\n    return /** @type {Array<string>} */ (this.get(Property.GRADIENT));\n  }\n\n  /**\n   * Return the size of the radius in pixels.\n   * @return {number} Radius size in pixel.\n   * @api\n   * @observable\n   */\n  getRadius() {\n    return /** @type {number} */ (this.get(Property.RADIUS));\n  }\n\n  /**\n   * @private\n   */\n  handleGradientChanged_() {\n    this.gradient_ = createGradient(this.getGradient());\n  }\n\n  /**\n   * Set the blur size in pixels.\n   * @param {number} blur Blur size in pixels.\n   * @api\n   * @observable\n   */\n  setBlur(blur) {\n    this.set(Property.BLUR, blur);\n  }\n\n  /**\n   * Set the gradient colors as array of strings.\n   * @param {Array<string>} colors Gradient.\n   * @api\n   * @observable\n   */\n  setGradient(colors) {\n    this.set(Property.GRADIENT, colors);\n  }\n\n  /**\n   * Set the size of the radius in pixels.\n   * @param {number} radius Radius size in pixel.\n   * @api\n   * @observable\n   */\n  setRadius(radius) {\n    this.set(Property.RADIUS, radius);\n  }\n\n  createRenderer() {\n    return new WebGLPointsLayerRenderer(this, {\n      className: this.getClassName(),\n      attributes: [\n        {\n          name: 'weight',\n          callback: (feature) => {\n            const weight = this.weightFunction_(feature);\n            return weight !== undefined ? clamp(weight, 0, 1) : 1;\n          },\n        },\n      ],\n      vertexShader: `\n        precision mediump float;\n        uniform mat4 u_projectionMatrix;\n        uniform mat4 u_offsetScaleMatrix;\n        uniform float u_size;\n        attribute vec2 a_position;\n        attribute float a_index;\n        attribute float a_weight;\n\n        varying vec2 v_texCoord;\n        varying float v_weight;\n\n        void main(void) {\n          mat4 offsetMatrix = u_offsetScaleMatrix;\n          float offsetX = a_index == 0.0 || a_index == 3.0 ? -u_size / 2.0 : u_size / 2.0;\n          float offsetY = a_index == 0.0 || a_index == 1.0 ? -u_size / 2.0 : u_size / 2.0;\n          vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\n          gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\n          float u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\n          float v = a_index == 0.0 || a_index == 1.0 ? 0.0 : 1.0;\n          v_texCoord = vec2(u, v);\n          v_weight = a_weight;\n        }`,\n      fragmentShader: `\n        precision mediump float;\n        uniform float u_blurSlope;\n\n        varying vec2 v_texCoord;\n        varying float v_weight;\n\n        void main(void) {\n          vec2 texCoord = v_texCoord * 2.0 - vec2(1.0, 1.0);\n          float sqRadius = texCoord.x * texCoord.x + texCoord.y * texCoord.y;\n          float value = (1.0 - sqrt(sqRadius)) * u_blurSlope;\n          float alpha = smoothstep(0.0, 1.0, value) * v_weight;\n          gl_FragColor = vec4(alpha, alpha, alpha, alpha);\n        }`,\n      hitVertexShader: `\n        precision mediump float;\n        uniform mat4 u_projectionMatrix;\n        uniform mat4 u_offsetScaleMatrix;\n        uniform float u_size;\n        attribute vec2 a_position;\n        attribute float a_index;\n        attribute float a_weight;\n        attribute vec4 a_hitColor;\n\n        varying vec2 v_texCoord;\n        varying float v_weight;\n        varying vec4 v_hitColor;\n\n        void main(void) {\n          mat4 offsetMatrix = u_offsetScaleMatrix;\n          float offsetX = a_index == 0.0 || a_index == 3.0 ? -u_size / 2.0 : u_size / 2.0;\n          float offsetY = a_index == 0.0 || a_index == 1.0 ? -u_size / 2.0 : u_size / 2.0;\n          vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\n          gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\n          float u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\n          float v = a_index == 0.0 || a_index == 1.0 ? 0.0 : 1.0;\n          v_texCoord = vec2(u, v);\n          v_hitColor = a_hitColor;\n          v_weight = a_weight;\n        }`,\n      hitFragmentShader: `\n        precision mediump float;\n        uniform float u_blurSlope;\n\n        varying vec2 v_texCoord;\n        varying float v_weight;\n        varying vec4 v_hitColor;\n\n        void main(void) {\n          vec2 texCoord = v_texCoord * 2.0 - vec2(1.0, 1.0);\n          float sqRadius = texCoord.x * texCoord.x + texCoord.y * texCoord.y;\n          float value = (1.0 - sqrt(sqRadius)) * u_blurSlope;\n          float alpha = smoothstep(0.0, 1.0, value) * v_weight;\n          if (alpha < 0.05) {\n            discard;\n          }\n\n          gl_FragColor = v_hitColor;\n        }`,\n      uniforms: {\n        u_size: () => {\n          return (this.get(Property.RADIUS) + this.get(Property.BLUR)) * 2;\n        },\n        u_blurSlope: () => {\n          return (\n            this.get(Property.RADIUS) / Math.max(1, this.get(Property.BLUR))\n          );\n        },\n      },\n      postProcesses: [\n        {\n          fragmentShader: `\n            precision mediump float;\n\n            uniform sampler2D u_image;\n            uniform sampler2D u_gradientTexture;\n            uniform float u_opacity;\n\n            varying vec2 v_texCoord;\n\n            void main() {\n              vec4 color = texture2D(u_image, v_texCoord);\n              gl_FragColor.a = color.a * u_opacity;\n              gl_FragColor.rgb = texture2D(u_gradientTexture, vec2(0.5, color.a)).rgb;\n              gl_FragColor.rgb *= gl_FragColor.a;\n            }`,\n          uniforms: {\n            u_gradientTexture: () => {\n              return this.gradient_;\n            },\n            u_opacity: () => {\n              return this.getOpacity();\n            },\n          },\n        },\n      ],\n    });\n  }\n\n  renderDeclutter() {}\n}\n\n/**\n * @param {Array<string>} colors A list of colored.\n * @return {HTMLCanvasElement} canvas with gradient texture.\n */\nfunction createGradient(colors) {\n  const width = 1;\n  const height = 256;\n  const context = createCanvasContext2D(width, height);\n\n  const gradient = context.createLinearGradient(0, 0, width, height);\n  const step = 1 / (colors.length - 1);\n  for (let i = 0, ii = colors.length; i < ii; ++i) {\n    gradient.addColorStop(i * step, colors[i]);\n  }\n\n  context.fillStyle = gradient;\n  context.fillRect(0, 0, width, height);\n\n  return context.canvas;\n}\n\nexport default Heatmap;\n","/**\n * @module ol/layer/BaseImage\n */\nimport Layer from './Layer.js';\n\n/**\n * @template {import(\"../source/Image.js\").default} ImageSourceType\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {import(\"../Map.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\n * use {@link import(\"../Map.js\").default#addLayer map.addLayer()}.\n * @property {ImageSourceType} [source] Source for this layer.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n\n/**\n * @classdesc\n * Server-rendered images that are available for arbitrary extents and\n * resolutions.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/Image.js\").default} ImageSourceType\n * @template {import(\"../renderer/Layer.js\").default} RendererType\n * @extends {Layer<ImageSourceType, RendererType>}\n * @api\n */\nclass BaseImageLayer extends Layer {\n  /**\n   * @param {Options<ImageSourceType>} [options] Layer options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n    super(options);\n  }\n}\n\nexport default BaseImageLayer;\n","/**\n * @module ol/layer/Image\n */\nimport BaseImageLayer from './BaseImage.js';\nimport CanvasImageLayerRenderer from '../renderer/canvas/ImageLayer.js';\n\n/**\n * @classdesc\n * Server-rendered images that are available for arbitrary extents and\n * resolutions.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/Image.js\").default} ImageSourceType\n * @extends {BaseImageLayer<ImageSourceType, CanvasImageLayerRenderer>}\n * @api\n */\nclass ImageLayer extends BaseImageLayer {\n  /**\n   * @param {import(\"./BaseImage.js\").Options<ImageSourceType>} [options] Layer options.\n   */\n  constructor(options) {\n    super(options);\n  }\n\n  createRenderer() {\n    return new CanvasImageLayerRenderer(this);\n  }\n\n  /**\n   * Get data for a pixel location.  A four element RGBA array will be returned.  For requests outside the\n   * layer extent, `null` will be returned.  Data for an image can only be retrieved if the\n   * source's `crossOrigin` property is set.\n   *\n   * ```js\n   * // display layer data on every pointer move\n   * map.on('pointermove', (event) => {\n   *   console.log(layer.getData(event.pixel));\n   * });\n   * ```\n   * @param {import(\"../pixel\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\n   * @api\n   */\n  getData(pixel) {\n    return super.getData(pixel);\n  }\n}\n\nexport default ImageLayer;\n","/**\n * @module ol/layer/Layer\n */\nimport BaseLayer from './Base.js';\nimport EventType from '../events/EventType.js';\nimport LayerProperty from './Property.js';\nimport RenderEventType from '../render/EventType.js';\nimport View from '../View.js';\nimport {assert} from '../asserts.js';\nimport {intersects} from '../extent.js';\nimport {listen, unlistenByKey} from '../events.js';\n\n/**\n * @typedef {function(import(\"../Map.js\").FrameState):HTMLElement} RenderFunction\n */\n\n/**\n * @typedef {'sourceready'|'change:source'} LayerEventType\n */\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./Base\").BaseLayerObjectEventTypes|\n *     LayerEventType, import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../render/EventType\").LayerRenderEventTypes, import(\"../render/Event\").default, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"./Base\").BaseLayerObjectEventTypes|LayerEventType|\n *     import(\"../render/EventType\").LayerRenderEventTypes, Return>} LayerOnSignature\n */\n\n/**\n * @template {import(\"../source/Source.js\").default} [SourceType=import(\"../source/Source.js\").default]\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {SourceType} [source] Source for this layer.  If not provided to the constructor,\n * the source can be set by calling {@link module:ol/layer/Layer~Layer#setSource layer.setSource(source)} after\n * construction.\n * @property {import(\"../Map.js\").default|null} [map] Map.\n * @property {RenderFunction} [render] Render function. Takes the frame state as input and is expected to return an\n * HTML element. Will overwrite the default rendering for the layer.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n\n/**\n * @typedef {Object} State\n * @property {import(\"./Layer.js\").default} layer Layer.\n * @property {number} opacity Opacity, the value is rounded to two digits to appear after the decimal point.\n * @property {boolean} visible Visible.\n * @property {boolean} managed Managed.\n * @property {import(\"../extent.js\").Extent} [extent] Extent.\n * @property {number} zIndex ZIndex.\n * @property {number} maxResolution Maximum resolution.\n * @property {number} minResolution Minimum resolution.\n * @property {number} minZoom Minimum zoom.\n * @property {number} maxZoom Maximum zoom.\n */\n\n/**\n * @classdesc\n * Base class from which all layer types are derived. This should only be instantiated\n * in the case where a custom layer is added to the map with a custom `render` function.\n * Such a function can be specified in the `options` object, and is expected to return an HTML element.\n *\n * A visual representation of raster or vector map data.\n * Layers group together those properties that pertain to how the data is to be\n * displayed, irrespective of the source of that data.\n *\n * Layers are usually added to a map with [map.addLayer()]{@link import(\"../Map.js\").default#addLayer}.\n * Components like {@link module:ol/interaction/Draw~Draw} use unmanaged layers\n * internally. These unmanaged layers are associated with the map using\n * [layer.setMap()]{@link module:ol/layer/Layer~Layer#setMap} instead.\n *\n * A generic `change` event is fired when the state of the source changes.\n * A `sourceready` event is fired when the layer's source is ready.\n *\n * @fires import(\"../render/Event.js\").RenderEvent#prerender\n * @fires import(\"../render/Event.js\").RenderEvent#postrender\n * @fires import(\"../events/Event.js\").BaseEvent#sourceready\n *\n * @template {import(\"../source/Source.js\").default} [SourceType=import(\"../source/Source.js\").default]\n * @template {import(\"../renderer/Layer.js\").default} [RendererType=import(\"../renderer/Layer.js\").default]\n * @api\n */\nclass Layer extends BaseLayer {\n  /**\n   * @param {Options<SourceType>} options Layer options.\n   */\n  constructor(options) {\n    const baseOptions = Object.assign({}, options);\n    delete baseOptions.source;\n\n    super(baseOptions);\n\n    /***\n     * @type {LayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {LayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {LayerOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @private\n     * @type {?import(\"../events.js\").EventsKey}\n     */\n    this.mapPrecomposeKey_ = null;\n\n    /**\n     * @private\n     * @type {?import(\"../events.js\").EventsKey}\n     */\n    this.mapRenderKey_ = null;\n\n    /**\n     * @private\n     * @type {?import(\"../events.js\").EventsKey}\n     */\n    this.sourceChangeKey_ = null;\n\n    /**\n     * @private\n     * @type {RendererType}\n     */\n    this.renderer_ = null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.sourceReady_ = false;\n\n    /**\n     * @protected\n     * @type {boolean}\n     */\n    this.rendered = false;\n\n    // Overwrite default render method with a custom one\n    if (options.render) {\n      this.render = options.render;\n    }\n\n    if (options.map) {\n      this.setMap(options.map);\n    }\n\n    this.addChangeListener(\n      LayerProperty.SOURCE,\n      this.handleSourcePropertyChange_\n    );\n\n    const source = options.source\n      ? /** @type {SourceType} */ (options.source)\n      : null;\n    this.setSource(source);\n  }\n\n  /**\n   * @param {Array<import(\"./Layer.js\").default>} [array] Array of layers (to be modified in place).\n   * @return {Array<import(\"./Layer.js\").default>} Array of layers.\n   */\n  getLayersArray(array) {\n    array = array ? array : [];\n    array.push(this);\n    return array;\n  }\n\n  /**\n   * @param {Array<import(\"./Layer.js\").State>} [states] Optional list of layer states (to be modified in place).\n   * @return {Array<import(\"./Layer.js\").State>} List of layer states.\n   */\n  getLayerStatesArray(states) {\n    states = states ? states : [];\n    states.push(this.getLayerState());\n    return states;\n  }\n\n  /**\n   * Get the layer source.\n   * @return {SourceType|null} The layer source (or `null` if not yet set).\n   * @observable\n   * @api\n   */\n  getSource() {\n    return /** @type {SourceType} */ (this.get(LayerProperty.SOURCE)) || null;\n  }\n\n  /**\n   * @return {SourceType|null} The source being rendered.\n   */\n  getRenderSource() {\n    return this.getSource();\n  }\n\n  /**\n   * @return {import(\"../source/Source.js\").State} Source state.\n   */\n  getSourceState() {\n    const source = this.getSource();\n    return !source ? 'undefined' : source.getState();\n  }\n\n  /**\n   * @private\n   */\n  handleSourceChange_() {\n    this.changed();\n    if (this.sourceReady_ || this.getSource().getState() !== 'ready') {\n      return;\n    }\n    this.sourceReady_ = true;\n    this.dispatchEvent('sourceready');\n  }\n\n  /**\n   * @private\n   */\n  handleSourcePropertyChange_() {\n    if (this.sourceChangeKey_) {\n      unlistenByKey(this.sourceChangeKey_);\n      this.sourceChangeKey_ = null;\n    }\n    this.sourceReady_ = false;\n    const source = this.getSource();\n    if (source) {\n      this.sourceChangeKey_ = listen(\n        source,\n        EventType.CHANGE,\n        this.handleSourceChange_,\n        this\n      );\n      if (source.getState() === 'ready') {\n        this.sourceReady_ = true;\n        setTimeout(() => {\n          this.dispatchEvent('sourceready');\n        }, 0);\n      }\n    }\n    this.changed();\n  }\n\n  /**\n   * @param {import(\"../pixel\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../Feature\").FeatureLike>>} Promise that resolves with\n   * an array of features.\n   */\n  getFeatures(pixel) {\n    if (!this.renderer_) {\n      return Promise.resolve([]);\n    }\n    return this.renderer_.getFeatures(pixel);\n  }\n\n  /**\n   * @param {import(\"../pixel\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\n   */\n  getData(pixel) {\n    if (!this.renderer_ || !this.rendered) {\n      return null;\n    }\n    return this.renderer_.getData(pixel);\n  }\n\n  /**\n   * The layer is visible in the given view, i.e. within its min/max resolution or zoom and\n   * extent, and `getVisible()` is `true`.\n   * @param {View|import(\"../View.js\").ViewStateAndExtent} view View or {@link import(\"../Map.js\").FrameState}.\n   * @return {boolean} The layer is visible in the current view.\n   * @api\n   */\n  isVisible(view) {\n    let frameState;\n    if (view instanceof View) {\n      frameState = {\n        viewState: view.getState(),\n        extent: view.calculateExtent(),\n      };\n    } else {\n      frameState = view;\n    }\n    const layerExtent = this.getExtent();\n    return (\n      this.getVisible() &&\n      inView(this.getLayerState(), frameState.viewState) &&\n      (!layerExtent || intersects(layerExtent, frameState.extent))\n    );\n  }\n\n  /**\n   * Get the attributions of the source of this layer for the given view.\n   * @param {View|import(\"../View.js\").ViewStateAndExtent} view View or  {@link import(\"../Map.js\").FrameState}.\n   * @return {Array<string>} Attributions for this layer at the given view.\n   * @api\n   */\n  getAttributions(view) {\n    if (!this.isVisible(view)) {\n      return [];\n    }\n    let getAttributions;\n    const source = this.getSource();\n    if (source) {\n      getAttributions = source.getAttributions();\n    }\n    if (!getAttributions) {\n      return [];\n    }\n    const frameState =\n      view instanceof View ? view.getViewStateAndExtent() : view;\n    let attributions = getAttributions(frameState);\n    if (!Array.isArray(attributions)) {\n      attributions = [attributions];\n    }\n    return attributions;\n  }\n\n  /**\n   * In charge to manage the rendering of the layer. One layer type is\n   * bounded with one layer renderer.\n   * @param {?import(\"../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target which the renderer may (but need not) use\n   * for rendering its content.\n   * @return {HTMLElement} The rendered element.\n   */\n  render(frameState, target) {\n    const layerRenderer = this.getRenderer();\n\n    if (layerRenderer.prepareFrame(frameState)) {\n      this.rendered = true;\n      return layerRenderer.renderFrame(frameState, target);\n    }\n  }\n\n  /**\n   * Called when a layer is not visible during a map render.\n   */\n  unrender() {\n    this.rendered = false;\n  }\n\n  /**\n   * For use inside the library only.\n   * @param {import(\"../Map.js\").default|null} map Map.\n   */\n  setMapInternal(map) {\n    if (!map) {\n      this.unrender();\n    }\n    this.set(LayerProperty.MAP, map);\n  }\n\n  /**\n   * For use inside the library only.\n   * @return {import(\"../Map.js\").default|null} Map.\n   */\n  getMapInternal() {\n    return this.get(LayerProperty.MAP);\n  }\n\n  /**\n   * Sets the layer to be rendered on top of other layers on a map. The map will\n   * not manage this layer in its layers collection. This\n   * is useful for temporary layers. To remove an unmanaged layer from the map,\n   * use `#setMap(null)`.\n   *\n   * To add the layer to a map and have it managed by the map, use\n   * {@link module:ol/Map~Map#addLayer} instead.\n   * @param {import(\"../Map.js\").default|null} map Map.\n   * @api\n   */\n  setMap(map) {\n    if (this.mapPrecomposeKey_) {\n      unlistenByKey(this.mapPrecomposeKey_);\n      this.mapPrecomposeKey_ = null;\n    }\n    if (!map) {\n      this.changed();\n    }\n    if (this.mapRenderKey_) {\n      unlistenByKey(this.mapRenderKey_);\n      this.mapRenderKey_ = null;\n    }\n    if (map) {\n      this.mapPrecomposeKey_ = listen(\n        map,\n        RenderEventType.PRECOMPOSE,\n        function (evt) {\n          const renderEvent =\n            /** @type {import(\"../render/Event.js\").default} */ (evt);\n          const layerStatesArray = renderEvent.frameState.layerStatesArray;\n          const layerState = this.getLayerState(false);\n          // A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both.\n          assert(\n            !layerStatesArray.some(function (arrayLayerState) {\n              return arrayLayerState.layer === layerState.layer;\n            }),\n            67\n          );\n          layerStatesArray.push(layerState);\n        },\n        this\n      );\n      this.mapRenderKey_ = listen(this, EventType.CHANGE, map.render, map);\n      this.changed();\n    }\n  }\n\n  /**\n   * Set the layer source.\n   * @param {SourceType|null} source The layer source.\n   * @observable\n   * @api\n   */\n  setSource(source) {\n    this.set(LayerProperty.SOURCE, source);\n  }\n\n  /**\n   * Get the renderer for this layer.\n   * @return {RendererType|null} The layer renderer.\n   */\n  getRenderer() {\n    if (!this.renderer_) {\n      this.renderer_ = this.createRenderer();\n    }\n    return this.renderer_;\n  }\n\n  /**\n   * @return {boolean} The layer has a renderer.\n   */\n  hasRenderer() {\n    return !!this.renderer_;\n  }\n\n  /**\n   * Create a renderer for this layer.\n   * @return {RendererType} A layer renderer.\n   * @protected\n   */\n  createRenderer() {\n    return null;\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    if (this.renderer_) {\n      this.renderer_.dispose();\n      delete this.renderer_;\n    }\n\n    this.setSource(null);\n    super.disposeInternal();\n  }\n}\n\n/**\n * Return `true` if the layer is visible and if the provided view state\n * has resolution and zoom levels that are in range of the layer's min/max.\n * @param {State} layerState Layer state.\n * @param {import(\"../View.js\").State} viewState View state.\n * @return {boolean} The layer is visible at the given view state.\n */\nexport function inView(layerState, viewState) {\n  if (!layerState.visible) {\n    return false;\n  }\n  const resolution = viewState.resolution;\n  if (\n    resolution < layerState.minResolution ||\n    resolution >= layerState.maxResolution\n  ) {\n    return false;\n  }\n  const zoom = viewState.zoom;\n  return zoom > layerState.minZoom && zoom <= layerState.maxZoom;\n}\n\nexport default Layer;\n","/**\n * @module ol/layer/Property\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  OPACITY: 'opacity',\n  VISIBLE: 'visible',\n  EXTENT: 'extent',\n  Z_INDEX: 'zIndex',\n  MAX_RESOLUTION: 'maxResolution',\n  MIN_RESOLUTION: 'minResolution',\n  MAX_ZOOM: 'maxZoom',\n  MIN_ZOOM: 'minZoom',\n  SOURCE: 'source',\n  MAP: 'map',\n};\n","/**\n * @module ol/layer/Tile\n */\nimport BaseTileLayer from './BaseTile.js';\nimport CanvasTileLayerRenderer from '../renderer/canvas/TileLayer.js';\n\n/**\n * @classdesc\n * For layer sources that provide pre-rendered, tiled images in grids that are\n * organized by zoom levels for specific resolutions.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/Tile.js\").default} TileSourceType\n * @extends BaseTileLayer<TileSourceType, CanvasTileLayerRenderer>\n * @api\n */\nclass TileLayer extends BaseTileLayer {\n  /**\n   * @param {import(\"./BaseTile.js\").Options<TileSourceType>} [options] Tile layer options.\n   */\n  constructor(options) {\n    super(options);\n  }\n\n  createRenderer() {\n    return new CanvasTileLayerRenderer(this);\n  }\n}\n\nexport default TileLayer;\n","/**\n * @module ol/layer/TileProperty\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  PRELOAD: 'preload',\n  USE_INTERIM_TILES_ON_ERROR: 'useInterimTilesOnError',\n};\n","/**\n * @module ol/layer/Vector\n */\nimport BaseVectorLayer from './BaseVector.js';\nimport CanvasVectorLayerRenderer from '../renderer/canvas/VectorLayer.js';\n\n/**\n * @classdesc\n * Vector data is rendered client-side, as vectors. This layer type provides most accurate rendering\n * even during animations. Points and labels stay upright on rotated views. For very large\n * amounts of vector data, performance may suffer during pan and zoom animations. In this case,\n * try {@link module:ol/layer/VectorImage~VectorImageLayer}.\n *\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/Vector.js\").default} VectorSourceType\n * @extends {BaseVectorLayer<VectorSourceType, CanvasVectorLayerRenderer>}\n * @api\n */\nclass VectorLayer extends BaseVectorLayer {\n  /**\n   * @param {import(\"./BaseVector.js\").Options<VectorSourceType>} [options] Options.\n   */\n  constructor(options) {\n    super(options);\n  }\n\n  createRenderer() {\n    return new CanvasVectorLayerRenderer(this);\n  }\n}\n\nexport default VectorLayer;\n","/**\n * @module ol/layer/VectorTile\n */\nimport BaseVectorLayer from './BaseVector.js';\nimport CanvasVectorTileLayerRenderer from '../renderer/canvas/VectorTileLayer.js';\nimport TileProperty from './TileProperty.js';\nimport {assert} from '../asserts.js';\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./Base\").BaseLayerObjectEventTypes|\n *     import(\"./Layer.js\").LayerEventType|'change:preload'|'change:useInterimTilesOnError', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../render/EventType\").LayerRenderEventTypes, import(\"../render/Event\").default, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"./Base\").BaseLayerObjectEventTypes|\n *     import(\"./Layer.js\").LayerEventType|'change:preload'|'change:useInterimTilesOnError'|import(\"../render/EventType\").LayerRenderEventTypes, Return>} VectorTileLayerOnSignature\n */\n\n/**\n * @typedef {'hybrid' | 'vector'} VectorTileRenderType\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {import(\"../render.js\").OrderFunction} [renderOrder] Render order. Function to be used when sorting\n * features before rendering. By default features are drawn in the order that they are created. Use\n * `null` to avoid the sort, but get an undefined draw order.\n * @property {number} [renderBuffer=100] The buffer in pixels around the tile extent used by the\n * renderer when getting features from the vector tile for the rendering or hit-detection.\n * Recommended value: Vector tiles are usually generated with a buffer, so this value should match\n * the largest possible buffer of the used tiles. It should be at least the size of the largest\n * point symbol or line width.\n * @property {VectorTileRenderType} [renderMode='hybrid'] Render mode for vector tiles:\n *  * `'hybrid'`: Polygon and line elements are rendered as images, so pixels are scaled during zoom\n *    animations. Point symbols and texts are accurately rendered as vectors and can stay upright on\n *    rotated views.\n *  * `'vector'`: Everything is rendered as vectors. Use this mode for improved performance on vector\n *    tile layers with only a few rendered features (e.g. for highlighting a subset of features of\n *    another layer with the same source).\n * @property {import(\"../source/VectorTile.js\").default} [source] Source.\n * @property {import(\"../Map.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\n * use [map.addLayer()]{@link import(\"../Map.js\").default#addLayer}.\n * @property {boolean} [declutter=false] Declutter images and text. Decluttering is applied to all\n * image and text styles of all Vector and VectorTile layers that have set this to `true`. The priority\n * is defined by the z-index of the layer, the `zIndex` of the style and the render order of features.\n * Higher z-index means higher priority. Within the same z-index, a feature rendered before another has\n * higher priority.\n *\n * As an optimization decluttered features from layers with the same `className` are rendered above\n * the fill and stroke styles of all of those layers regardless of z-index.  To opt out of this\n * behavior and place declutterd features with their own layer configure the layer with a `className`\n * other than `ol-layer`.\n * @property {import(\"../style/Style.js\").StyleLike|null} [style] Layer style. When set to `null`, only\n * features that have their own style will be rendered. See {@link module:ol/style/Style~Style} for the default style\n * which will be used if this is not set.\n * @property {import(\"./Base.js\").BackgroundColor|false} [background] Background color for the layer. If not specified, no\n * background will be rendered.\n * @property {boolean} [updateWhileAnimating=false] When set to `true`, feature batches will be\n * recreated during animations. This means that no vectors will be shown clipped, but the setting\n * will have a performance impact for large amounts of vector data. When set to `false`, batches\n * will be recreated when no animation is active.\n * @property {boolean} [updateWhileInteracting=false] When set to `true`, feature batches will be\n * recreated during interactions. See also `updateWhileAnimating`.\n * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`\n * means no preloading.\n * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n\n/**\n * @classdesc\n * Layer for vector tile data that is rendered client-side.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @param {Options} [options] Options.\n * @extends {BaseVectorLayer<import(\"../source/VectorTile.js\").default, CanvasVectorTileLayerRenderer>}\n * @api\n */\nclass VectorTileLayer extends BaseVectorLayer {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const baseOptions = /** @type {Object} */ (Object.assign({}, options));\n    delete baseOptions.preload;\n    delete baseOptions.useInterimTilesOnError;\n\n    super(\n      /** @type {import(\"./BaseVector.js\").Options<import(\"../source/VectorTile.js\").default>} */ (\n        baseOptions\n      )\n    );\n\n    /***\n     * @type {VectorTileLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {VectorTileLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {VectorTileLayerOnSignature<void>}\n     */\n    this.un;\n\n    const renderMode = options.renderMode || 'hybrid';\n    // `renderMode` must be `'hybrid'` or `'vector'`.\n    assert(renderMode == 'hybrid' || renderMode == 'vector', 28);\n\n    /**\n     * @private\n     * @type {VectorTileRenderType}\n     */\n    this.renderMode_ = renderMode;\n\n    this.setPreload(options.preload ? options.preload : 0);\n    this.setUseInterimTilesOnError(\n      options.useInterimTilesOnError !== undefined\n        ? options.useInterimTilesOnError\n        : true\n    );\n\n    /**\n     * @return {import(\"./Base.js\").BackgroundColor} Background color.\n     * @function\n     * @api\n     */\n    this.getBackground;\n\n    /**\n     * @param {import(\"./Base.js\").BackgroundColor} background Background color.\n     * @function\n     * @api\n     */\n    this.setBackground;\n  }\n\n  createRenderer() {\n    return new CanvasVectorTileLayerRenderer(this);\n  }\n\n  /**\n   * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise\n   * that resolves with an array of features. The array will either contain the topmost feature\n   * when a hit was detected, or it will be empty.\n   *\n   * The hit detection algorithm used for this method is optimized for performance, but is less\n   * accurate than the one used in [map.getFeaturesAtPixel()]{@link import(\"../Map.js\").default#getFeaturesAtPixel}.\n   * Text is not considered, and icons are only represented by their bounding box instead of the exact\n   * image.\n   *\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../Feature\").FeatureLike>>} Promise that resolves with an array of features.\n   * @api\n   */\n  getFeatures(pixel) {\n    return super.getFeatures(pixel);\n  }\n\n  /**\n   * @return {VectorTileRenderType} The render mode.\n   */\n  getRenderMode() {\n    return this.renderMode_;\n  }\n\n  /**\n   * Return the level as number to which we will preload tiles up to.\n   * @return {number} The level to preload tiles up to.\n   * @observable\n   * @api\n   */\n  getPreload() {\n    return /** @type {number} */ (this.get(TileProperty.PRELOAD));\n  }\n\n  /**\n   * Whether we use interim tiles on error.\n   * @return {boolean} Use interim tiles on error.\n   * @observable\n   * @api\n   */\n  getUseInterimTilesOnError() {\n    return /** @type {boolean} */ (\n      this.get(TileProperty.USE_INTERIM_TILES_ON_ERROR)\n    );\n  }\n\n  /**\n   * Set the level as number to which we will preload tiles up to.\n   * @param {number} preload The level to preload tiles up to.\n   * @observable\n   * @api\n   */\n  setPreload(preload) {\n    this.set(TileProperty.PRELOAD, preload);\n  }\n\n  /**\n   * Set whether we use interim tiles on error.\n   * @param {boolean} useInterimTilesOnError Use interim tiles on error.\n   * @observable\n   * @api\n   */\n  setUseInterimTilesOnError(useInterimTilesOnError) {\n    this.set(TileProperty.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);\n  }\n}\n\nexport default VectorTileLayer;\n","/**\n * @module ol/loadingstrategy\n */\n\nimport {fromUserExtent, fromUserResolution, toUserExtent} from './proj.js';\n\n/**\n * Strategy function for loading all features with a single request.\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number} resolution Resolution.\n * @return {Array<import(\"./extent.js\").Extent>} Extents.\n * @api\n */\nexport function all(extent, resolution) {\n  return [[-Infinity, -Infinity, Infinity, Infinity]];\n}\n\n/**\n * Strategy function for loading features based on the view's extent and\n * resolution.\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number} resolution Resolution.\n * @return {Array<import(\"./extent.js\").Extent>} Extents.\n * @api\n */\nexport function bbox(extent, resolution) {\n  return [extent];\n}\n\n/**\n * Creates a strategy function for loading features based on a tile grid.\n * @param {import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {function(import(\"./extent.js\").Extent, number, import(\"./proj.js\").Projection): Array<import(\"./extent.js\").Extent>} Loading strategy.\n * @api\n */\nexport function tile(tileGrid) {\n  return (\n    /**\n     * @param {import(\"./extent.js\").Extent} extent Extent.\n     * @param {number} resolution Resolution.\n     * @param {import(\"./proj.js\").Projection} projection Projection.\n     * @return {Array<import(\"./extent.js\").Extent>} Extents.\n     */\n    function (extent, resolution, projection) {\n      const z = tileGrid.getZForResolution(\n        fromUserResolution(resolution, projection)\n      );\n      const tileRange = tileGrid.getTileRangeForExtentAndZ(\n        fromUserExtent(extent, projection),\n        z\n      );\n      /** @type {Array<import(\"./extent.js\").Extent>} */\n      const extents = [];\n      /** @type {import(\"./tilecoord.js\").TileCoord} */\n      const tileCoord = [z, 0, 0];\n      for (\n        tileCoord[1] = tileRange.minX;\n        tileCoord[1] <= tileRange.maxX;\n        ++tileCoord[1]\n      ) {\n        for (\n          tileCoord[2] = tileRange.minY;\n          tileCoord[2] <= tileRange.maxY;\n          ++tileCoord[2]\n        ) {\n          extents.push(\n            toUserExtent(tileGrid.getTileCoordExtent(tileCoord), projection)\n          );\n        }\n      }\n      return extents;\n    }\n  );\n}\n","/**\n * @module ol/obj\n */\n\n/**\n * Removes all properties from an object.\n * @param {Object} object The object to clear.\n */\nexport function clear(object) {\n  for (const property in object) {\n    delete object[property];\n  }\n}\n\n/**\n * Determine if an object has any properties.\n * @param {Object} object The object to check.\n * @return {boolean} The object is empty.\n */\nexport function isEmpty(object) {\n  let property;\n  for (property in object) {\n    return false;\n  }\n  return !property;\n}\n"],"names":["ua","navigator","userAgent","toLowerCase","FIREFOX","includes","SAFARI","SAFARI_BUG_237906","test","WEBKIT","MAC","DEVICE_PIXEL_RATIO","devicePixelRatio","WORKER_OFFSCREEN_CANVAS","WorkerGlobalScope","OffscreenCanvas","self","IMAGE_DECODE","Image","prototype","decode","PASSIVE_EVENT_LISTENERS","passive","options","Object","defineProperty","get","window","addEventListener","removeEventListener","error","Interaction","constructor","super","this","on","once","un","handleEvent","map_","setActive","getActive","getMap","mapBrowserEvent","active","set","setMap","map","pan","view","delta","duration","currentCenter","getCenterInternal","center","animateInternal","undefined","easing","getConstrainedCenter","zoomByDelta","anchor","currentZoom","getZoom","newZoom","getConstrainedZoom","newResolution","getResolutionForZoom","getAnimating","cancelAnimations","animate","resolution","PointerInteraction","handleDownEvent","handleDragEvent","handleMoveEvent","handleUpEvent","stopDown","handlingDownUpSequence","targetPointers","getPointerCount","length","originalEvent","stopEvent","updateTrackedPointers_","type","preventDefault","handledUp","handled","activePointers","centroid","pointerEvents","clientX","clientY","i","ACTIVE","SelectEventType","SELECT","SelectEvent","selected","deselected","originalFeatureStyles","Select","layerFilter","boundAddFeature_","addFeature_","bind","boundRemoveFeature_","removeFeature_","condition_","condition","addCondition_","addCondition","removeCondition_","removeCondition","toggleCondition_","toggleCondition","multi_","multi","filter_","filter","hitTolerance_","hitTolerance","style_","style","getDefaultStyleFunction","features_","features","layers","layer","layerFilter_","featureLayerAssociation_","addFeatureLayerAssociation_","feature","getFeatures","getHitTolerance","getLayer","setHitTolerance","currentMap","forEach","restorePreviousStyle_","applySelectedStyle_","evt","element","getAllLayers","find","getSource","hasFeature","getStyle","key","setStyle","interactions","getInteractions","getArray","interaction","lastIndexOf","removeFeatureLayerAssociation_","add","remove","toggle","forEachFeatureAtPixel","pixel","push","getLength","item","index","indexOf","splice","extend","j","dispatchEvent","styles","createEditingStyle","getGeometry","getType","DoubleClickZoom","delta_","duration_","MapBrowserEventType","browserEvent","coordinate","shiftKey","getView","DragPan","Pointer","kinetic_","kinetic","lastCentroid","lastPointersCount_","panning_","onFocusOnly","noKinetic_","beginInteraction","getEventPixel","update","getResolution","getRotation","adjustCenterInternal","begin","end","distance","getDistance","angle","getAngle","centerpx","getPixelFromCoordinateInternal","dest","getCoordinateFromPixelInternal","Math","cos","sin","endInteraction","DragRotate","lastAngle_","getConstraints","rotation","size","getSize","offset","theta","atan2","adjustRotationInternal","DragBoxEventType","BOXSTART","BOXDRAG","BOXEND","BOXCANCEL","DragBoxEvent","Event","DragBox","box_","className","minArea_","minArea","onBoxEnd","startPixel_","boxEndCondition_","boxEndCondition","defaultBoxEndCondition","startPixel","endPixel","width","height","setPixels","completeBox","event","DragZoom","out_","out","geometry","rotatedExtent","rotatedExtentForGeometry","getResolutionForExtentInternal","factor","clone","scale","fitInternal","KeyboardPan","defaultCondition_","pixelDelta_","pixelDelta","EventType","keyEvent","keyCode","KeyCode","mapUnitsDelta","deltaX","deltaY","KeyboardZoom","MouseWheelZoom","totalDelta_","lastDelta_","maxDelta_","maxDelta","timeout_","timeout","useAnchor_","useAnchor","constrainResolution_","constrainResolution","lastAnchor_","startTime_","timeoutId_","mode_","trackpadEventGap_","trackpadTimeoutId_","deltaPerZoom_","endInteraction_","wheelEvent","deltaMode","WheelEvent","DOM_DELTA_PIXEL","DOM_DELTA_LINE","now","Date","abs","getConstrainResolution","clearTimeout","setTimeout","adjustZoom","timeLeft","max","handleWheelZoom_","setMouseAnchor","PinchRotate","pointerOptions","anchor_","rotating_","rotationDelta_","threshold_","threshold","rotationDelta","touch0","touch1","render","PinchZoom","lastDistance_","lastScaleDelta_","scaleDelta","dx","dy","sqrt","adjustResolutionInternal","direction","defaults","Collection","Kinetic","altShiftDragRotate","doubleClickZoom","zoomDelta","zoomDuration","dragPan","pinchRotate","pinchZoom","keyboard","mouseWheelZoom","shiftDragZoom","BaseLayer","background_","background","properties","assign","opacity","visible","zIndex","maxResolution","Infinity","minResolution","minZoom","maxZoom","className_","setProperties","state_","getBackground","getClassName","getLayerState","managed","state","getZIndex","round","getOpacity","getVisible","extent","getExtent","getMaxResolution","getMinResolution","getMinZoom","getMaxZoom","getLayersArray","array","getLayerStatesArray","states","getSourceState","setBackground","changed","setExtent","setMaxResolution","setMinResolution","setMaxZoom","setMinZoom","setOpacity","setVisible","setZIndex","zindex","disposeInternal","BaseTileLayer","baseOptions","preload","useInterimTilesOnError","setPreload","setUseInterimTilesOnError","getPreload","getUseInterimTilesOnError","getData","Property","RENDER_ORDER","BaseVectorLayer","renderBuffer","updateWhileAnimating","updateWhileInteracting","declutter_","declutter","renderBuffer_","styleFunction_","updateWhileAnimating_","updateWhileInteracting_","getDeclutter","getRenderBuffer","getRenderOrder","getStyleFunction","getUpdateWhileAnimating","getUpdateWhileInteracting","renderDeclutter","frameState","declutterTree","getRenderer","setRenderOrder","renderOrder","styleLike","createDefaultStyle","Array","isArray","len","s","GroupEvent","LAYERS","LayerGroup","layersListenerKeys_","listenerKeys_","addChangeListener","handleLayersChanged_","slice","unique","setLayers","handleLayerChange_","getLayers","handleLayersAdd_","handleLayersRemove_","id","layersArray","ii","registerLayerListeners_","listenerKeys","handleLayerGroupAdd_","handleLayerGroupRemove_","collectionEvent","collection","currentLayers","pos","ownLayerState","defaultZIndex","layerState","min","BLUR","GRADIENT","RADIUS","DEFAULT_GRADIENT","Heatmap","gradient","radius","blur","weight","gradient_","handleGradientChanged_","setGradient","setBlur","setRadius","weightFunction_","getBlur","getGradient","getRadius","createGradient","colors","createRenderer","attributes","name","callback","vertexShader","fragmentShader","hitVertexShader","hitFragmentShader","uniforms","u_size","u_blurSlope","postProcesses","u_gradientTexture","u_opacity","context","createLinearGradient","step","addColorStop","fillStyle","fillRect","canvas","BaseImageLayer","Layer","ImageLayer","BaseImage","source","mapPrecomposeKey_","mapRenderKey_","sourceChangeKey_","renderer_","sourceReady_","rendered","handleSourcePropertyChange_","setSource","getRenderSource","getState","handleSourceChange_","Promise","resolve","isVisible","viewState","calculateExtent","layerExtent","inView","getAttributions","getViewStateAndExtent","attributions","target","layerRenderer","prepareFrame","renderFrame","unrender","setMapInternal","getMapInternal","renderEvent","layerStatesArray","some","arrayLayerState","hasRenderer","dispose","zoom","OPACITY","VISIBLE","EXTENT","Z_INDEX","MAX_RESOLUTION","MIN_RESOLUTION","MAX_ZOOM","MIN_ZOOM","SOURCE","MAP","TileLayer","PRELOAD","USE_INTERIM_TILES_ON_ERROR","VectorLayer","VectorTileLayer","renderMode","renderMode_","getRenderMode","all","clear","object","property","isEmpty"],"sourceRoot":""}
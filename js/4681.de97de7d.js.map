{"version":3,"file":"js/4681.de97de7d.js","mappings":"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","sources":["webpack://@openeo/web-editor/./node_modules/mgrs/mgrs.js","webpack://@openeo/web-editor/./node_modules/ol/AssertionError.js","webpack://@openeo/web-editor/./node_modules/ol/asserts.js","webpack://@openeo/web-editor/./node_modules/ol/console.js","webpack://@openeo/web-editor/./node_modules/ol/coordinate.js","webpack://@openeo/web-editor/./node_modules/ol/extent.js","webpack://@openeo/web-editor/./node_modules/ol/extent/Relationship.js","webpack://@openeo/web-editor/./node_modules/ol/math.js","webpack://@openeo/web-editor/./node_modules/ol/proj/epsg3857.js","webpack://@openeo/web-editor/./node_modules/ol/proj/epsg4326.js","webpack://@openeo/web-editor/./node_modules/ol/proj/projections.js","webpack://@openeo/web-editor/./node_modules/ol/sphere.js","webpack://@openeo/web-editor/./node_modules/ol/proj.js","webpack://@openeo/web-editor/./node_modules/ol/proj/Projection.js","webpack://@openeo/web-editor/./node_modules/ol/proj/Units.js","webpack://@openeo/web-editor/./node_modules/ol/proj/proj4.js","webpack://@openeo/web-editor/./node_modules/ol/proj/transforms.js"],"sourcesContent":["\n\n\n/**\n * UTM zones are grouped, and assigned to one of a group of 6\n * sets.\n *\n * {int} @private\n */\nvar NUM_100K_SETS = 6;\n\n/**\n * The column letters (for easting) of the lower left value, per\n * set.\n *\n * {string} @private\n */\nvar SET_ORIGIN_COLUMN_LETTERS = 'AJSAJS';\n\n/**\n * The row letters (for northing) of the lower left value, per\n * set.\n *\n * {string} @private\n */\nvar SET_ORIGIN_ROW_LETTERS = 'AFAFAF';\n\nvar A = 65; // A\nvar I = 73; // I\nvar O = 79; // O\nvar V = 86; // V\nvar Z = 90; // Z\nexport default {\n  forward: forward,\n  inverse: inverse,\n  toPoint: toPoint\n};\n/**\n * Conversion of lat/lon to MGRS.\n *\n * @param {object} ll Object literal with lat and lon properties on a\n *     WGS84 ellipsoid.\n * @param {int} accuracy Accuracy in digits (5 for 1 m, 4 for 10 m, 3 for\n *      100 m, 2 for 1000 m or 1 for 10000 m). Optional, default is 5.\n * @return {string} the MGRS string for the given location and accuracy.\n */\nexport function forward(ll, accuracy) {\n  accuracy = accuracy || 5; // default accuracy 1m\n  return encode(LLtoUTM({\n    lat: ll[1],\n    lon: ll[0]\n  }), accuracy);\n};\n\n/**\n * Conversion of MGRS to lat/lon.\n *\n * @param {string} mgrs MGRS string.\n * @return {array} An array with left (longitude), bottom (latitude), right\n *     (longitude) and top (latitude) values in WGS84, representing the\n *     bounding box for the provided MGRS reference.\n */\nexport function inverse(mgrs) {\n  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));\n  if (bbox.lat && bbox.lon) {\n    return [bbox.lon, bbox.lat, bbox.lon, bbox.lat];\n  }\n  return [bbox.left, bbox.bottom, bbox.right, bbox.top];\n};\n\nexport function toPoint(mgrs) {\n  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));\n  if (bbox.lat && bbox.lon) {\n    return [bbox.lon, bbox.lat];\n  }\n  return [(bbox.left + bbox.right) / 2, (bbox.top + bbox.bottom) / 2];\n};\n/**\n * Conversion from degrees to radians.\n *\n * @private\n * @param {number} deg the angle in degrees.\n * @return {number} the angle in radians.\n */\nfunction degToRad(deg) {\n  return (deg * (Math.PI / 180.0));\n}\n\n/**\n * Conversion from radians to degrees.\n *\n * @private\n * @param {number} rad the angle in radians.\n * @return {number} the angle in degrees.\n */\nfunction radToDeg(rad) {\n  return (180.0 * (rad / Math.PI));\n}\n\n/**\n * Converts a set of Longitude and Latitude co-ordinates to UTM\n * using the WGS84 ellipsoid.\n *\n * @private\n * @param {object} ll Object literal with lat and lon properties\n *     representing the WGS84 coordinate to be converted.\n * @return {object} Object literal containing the UTM value with easting,\n *     northing, zoneNumber and zoneLetter properties, and an optional\n *     accuracy property in digits. Returns null if the conversion failed.\n */\nfunction LLtoUTM(ll) {\n  var Lat = ll.lat;\n  var Long = ll.lon;\n  var a = 6378137.0; //ellip.radius;\n  var eccSquared = 0.00669438; //ellip.eccsq;\n  var k0 = 0.9996;\n  var LongOrigin;\n  var eccPrimeSquared;\n  var N, T, C, A, M;\n  var LatRad = degToRad(Lat);\n  var LongRad = degToRad(Long);\n  var LongOriginRad;\n  var ZoneNumber;\n  // (int)\n  ZoneNumber = Math.floor((Long + 180) / 6) + 1;\n\n  //Make sure the longitude 180.00 is in Zone 60\n  if (Long === 180) {\n    ZoneNumber = 60;\n  }\n\n  // Special zone for Norway\n  if (Lat >= 56.0 && Lat < 64.0 && Long >= 3.0 && Long < 12.0) {\n    ZoneNumber = 32;\n  }\n\n  // Special zones for Svalbard\n  if (Lat >= 72.0 && Lat < 84.0) {\n    if (Long >= 0.0 && Long < 9.0) {\n      ZoneNumber = 31;\n    }\n    else if (Long >= 9.0 && Long < 21.0) {\n      ZoneNumber = 33;\n    }\n    else if (Long >= 21.0 && Long < 33.0) {\n      ZoneNumber = 35;\n    }\n    else if (Long >= 33.0 && Long < 42.0) {\n      ZoneNumber = 37;\n    }\n  }\n\n  LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3; //+3 puts origin\n  // in middle of\n  // zone\n  LongOriginRad = degToRad(LongOrigin);\n\n  eccPrimeSquared = (eccSquared) / (1 - eccSquared);\n\n  N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));\n  T = Math.tan(LatRad) * Math.tan(LatRad);\n  C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);\n  A = Math.cos(LatRad) * (LongRad - LongOriginRad);\n\n  M = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - (35 * eccSquared * eccSquared * eccSquared / 3072) * Math.sin(6 * LatRad));\n\n  var UTMEasting = (k0 * N * (A + (1 - T + C) * A * A * A / 6.0 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A * A * A * A * A / 120.0) + 500000.0);\n\n  var UTMNorthing = (k0 * (M + N * Math.tan(LatRad) * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * A * A * A * A / 24.0 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A * A * A * A * A * A / 720.0)));\n  if (Lat < 0.0) {\n    UTMNorthing += 10000000.0; //10000000 meter offset for\n    // southern hemisphere\n  }\n\n  return {\n    northing: Math.round(UTMNorthing),\n    easting: Math.round(UTMEasting),\n    zoneNumber: ZoneNumber,\n    zoneLetter: getLetterDesignator(Lat)\n  };\n}\n\n/**\n * Converts UTM coords to lat/long, using the WGS84 ellipsoid. This is a convenience\n * class where the Zone can be specified as a single string eg.\"60N\" which\n * is then broken down into the ZoneNumber and ZoneLetter.\n *\n * @private\n * @param {object} utm An object literal with northing, easting, zoneNumber\n *     and zoneLetter properties. If an optional accuracy property is\n *     provided (in meters), a bounding box will be returned instead of\n *     latitude and longitude.\n * @return {object} An object literal containing either lat and lon values\n *     (if no accuracy was provided), or top, right, bottom and left values\n *     for the bounding box calculated according to the provided accuracy.\n *     Returns null if the conversion failed.\n */\nfunction UTMtoLL(utm) {\n\n  var UTMNorthing = utm.northing;\n  var UTMEasting = utm.easting;\n  var zoneLetter = utm.zoneLetter;\n  var zoneNumber = utm.zoneNumber;\n  // check the ZoneNummber is valid\n  if (zoneNumber < 0 || zoneNumber > 60) {\n    return null;\n  }\n\n  var k0 = 0.9996;\n  var a = 6378137.0; //ellip.radius;\n  var eccSquared = 0.00669438; //ellip.eccsq;\n  var eccPrimeSquared;\n  var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));\n  var N1, T1, C1, R1, D, M;\n  var LongOrigin;\n  var mu, phi1Rad;\n\n  // remove 500,000 meter offset for longitude\n  var x = UTMEasting - 500000.0;\n  var y = UTMNorthing;\n\n  // We must know somehow if we are in the Northern or Southern\n  // hemisphere, this is the only time we use the letter So even\n  // if the Zone letter isn't exactly correct it should indicate\n  // the hemisphere correctly\n  if (zoneLetter < 'N') {\n    y -= 10000000.0; // remove 10,000,000 meter offset used\n    // for southern hemisphere\n  }\n\n  // There are 60 zones with zone 1 being at West -180 to -174\n  LongOrigin = (zoneNumber - 1) * 6 - 180 + 3; // +3 puts origin\n  // in middle of\n  // zone\n\n  eccPrimeSquared = (eccSquared) / (1 - eccSquared);\n\n  M = y / k0;\n  mu = M / (a * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));\n\n  phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + (151 * e1 * e1 * e1 / 96) * Math.sin(6 * mu);\n  // double phi1 = ProjMath.radToDeg(phi1Rad);\n\n  N1 = a / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));\n  T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);\n  C1 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);\n  R1 = a * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);\n  D = x / (N1 * k0);\n\n  var lat = phi1Rad - (N1 * Math.tan(phi1Rad) / R1) * (D * D / 2 - (5 + 3 * T1 + 10 * C1 - 4 * C1 * C1 - 9 * eccPrimeSquared) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C1 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C1 * C1) * D * D * D * D * D * D / 720);\n  lat = radToDeg(lat);\n\n  var lon = (D - (1 + 2 * T1 + C1) * D * D * D / 6 + (5 - 2 * C1 + 28 * T1 - 3 * C1 * C1 + 8 * eccPrimeSquared + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad);\n  lon = LongOrigin + radToDeg(lon);\n\n  var result;\n  if (utm.accuracy) {\n    var topRight = UTMtoLL({\n      northing: utm.northing + utm.accuracy,\n      easting: utm.easting + utm.accuracy,\n      zoneLetter: utm.zoneLetter,\n      zoneNumber: utm.zoneNumber\n    });\n    result = {\n      top: topRight.lat,\n      right: topRight.lon,\n      bottom: lat,\n      left: lon\n    };\n  }\n  else {\n    result = {\n      lat: lat,\n      lon: lon\n    };\n  }\n  return result;\n}\n\n/**\n * Calculates the MGRS letter designator for the given latitude.\n *\n * @private\n * @param {number} lat The latitude in WGS84 to get the letter designator\n *     for.\n * @return {char} The letter designator.\n */\nfunction getLetterDesignator(lat) {\n  //This is here as an error flag to show that the Latitude is\n  //outside MGRS limits\n  var LetterDesignator = 'Z';\n\n  if ((84 >= lat) && (lat >= 72)) {\n    LetterDesignator = 'X';\n  }\n  else if ((72 > lat) && (lat >= 64)) {\n    LetterDesignator = 'W';\n  }\n  else if ((64 > lat) && (lat >= 56)) {\n    LetterDesignator = 'V';\n  }\n  else if ((56 > lat) && (lat >= 48)) {\n    LetterDesignator = 'U';\n  }\n  else if ((48 > lat) && (lat >= 40)) {\n    LetterDesignator = 'T';\n  }\n  else if ((40 > lat) && (lat >= 32)) {\n    LetterDesignator = 'S';\n  }\n  else if ((32 > lat) && (lat >= 24)) {\n    LetterDesignator = 'R';\n  }\n  else if ((24 > lat) && (lat >= 16)) {\n    LetterDesignator = 'Q';\n  }\n  else if ((16 > lat) && (lat >= 8)) {\n    LetterDesignator = 'P';\n  }\n  else if ((8 > lat) && (lat >= 0)) {\n    LetterDesignator = 'N';\n  }\n  else if ((0 > lat) && (lat >= -8)) {\n    LetterDesignator = 'M';\n  }\n  else if ((-8 > lat) && (lat >= -16)) {\n    LetterDesignator = 'L';\n  }\n  else if ((-16 > lat) && (lat >= -24)) {\n    LetterDesignator = 'K';\n  }\n  else if ((-24 > lat) && (lat >= -32)) {\n    LetterDesignator = 'J';\n  }\n  else if ((-32 > lat) && (lat >= -40)) {\n    LetterDesignator = 'H';\n  }\n  else if ((-40 > lat) && (lat >= -48)) {\n    LetterDesignator = 'G';\n  }\n  else if ((-48 > lat) && (lat >= -56)) {\n    LetterDesignator = 'F';\n  }\n  else if ((-56 > lat) && (lat >= -64)) {\n    LetterDesignator = 'E';\n  }\n  else if ((-64 > lat) && (lat >= -72)) {\n    LetterDesignator = 'D';\n  }\n  else if ((-72 > lat) && (lat >= -80)) {\n    LetterDesignator = 'C';\n  }\n  return LetterDesignator;\n}\n\n/**\n * Encodes a UTM location as MGRS string.\n *\n * @private\n * @param {object} utm An object literal with easting, northing,\n *     zoneLetter, zoneNumber\n * @param {number} accuracy Accuracy in digits (1-5).\n * @return {string} MGRS string for the given UTM location.\n */\nfunction encode(utm, accuracy) {\n  // prepend with leading zeroes\n  var seasting = \"00000\" + utm.easting,\n    snorthing = \"00000\" + utm.northing;\n\n  return utm.zoneNumber + utm.zoneLetter + get100kID(utm.easting, utm.northing, utm.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);\n}\n\n/**\n * Get the two letter 100k designator for a given UTM easting,\n * northing and zone number value.\n *\n * @private\n * @param {number} easting\n * @param {number} northing\n * @param {number} zoneNumber\n * @return the two letter 100k designator for the given UTM location.\n */\nfunction get100kID(easting, northing, zoneNumber) {\n  var setParm = get100kSetForZone(zoneNumber);\n  var setColumn = Math.floor(easting / 100000);\n  var setRow = Math.floor(northing / 100000) % 20;\n  return getLetter100kID(setColumn, setRow, setParm);\n}\n\n/**\n * Given a UTM zone number, figure out the MGRS 100K set it is in.\n *\n * @private\n * @param {number} i An UTM zone number.\n * @return {number} the 100k set the UTM zone is in.\n */\nfunction get100kSetForZone(i) {\n  var setParm = i % NUM_100K_SETS;\n  if (setParm === 0) {\n    setParm = NUM_100K_SETS;\n  }\n\n  return setParm;\n}\n\n/**\n * Get the two-letter MGRS 100k designator given information\n * translated from the UTM northing, easting and zone number.\n *\n * @private\n * @param {number} column the column index as it relates to the MGRS\n *        100k set spreadsheet, created from the UTM easting.\n *        Values are 1-8.\n * @param {number} row the row index as it relates to the MGRS 100k set\n *        spreadsheet, created from the UTM northing value. Values\n *        are from 0-19.\n * @param {number} parm the set block, as it relates to the MGRS 100k set\n *        spreadsheet, created from the UTM zone. Values are from\n *        1-60.\n * @return two letter MGRS 100k code.\n */\nfunction getLetter100kID(column, row, parm) {\n  // colOrigin and rowOrigin are the letters at the origin of the set\n  var index = parm - 1;\n  var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index);\n  var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index);\n\n  // colInt and rowInt are the letters to build to return\n  var colInt = colOrigin + column - 1;\n  var rowInt = rowOrigin + row;\n  var rollover = false;\n\n  if (colInt > Z) {\n    colInt = colInt - Z + A - 1;\n    rollover = true;\n  }\n\n  if (colInt === I || (colOrigin < I && colInt > I) || ((colInt > I || colOrigin < I) && rollover)) {\n    colInt++;\n  }\n\n  if (colInt === O || (colOrigin < O && colInt > O) || ((colInt > O || colOrigin < O) && rollover)) {\n    colInt++;\n\n    if (colInt === I) {\n      colInt++;\n    }\n  }\n\n  if (colInt > Z) {\n    colInt = colInt - Z + A - 1;\n  }\n\n  if (rowInt > V) {\n    rowInt = rowInt - V + A - 1;\n    rollover = true;\n  }\n  else {\n    rollover = false;\n  }\n\n  if (((rowInt === I) || ((rowOrigin < I) && (rowInt > I))) || (((rowInt > I) || (rowOrigin < I)) && rollover)) {\n    rowInt++;\n  }\n\n  if (((rowInt === O) || ((rowOrigin < O) && (rowInt > O))) || (((rowInt > O) || (rowOrigin < O)) && rollover)) {\n    rowInt++;\n\n    if (rowInt === I) {\n      rowInt++;\n    }\n  }\n\n  if (rowInt > V) {\n    rowInt = rowInt - V + A - 1;\n  }\n\n  var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);\n  return twoLetter;\n}\n\n/**\n * Decode the UTM parameters from a MGRS string.\n *\n * @private\n * @param {string} mgrsString an UPPERCASE coordinate string is expected.\n * @return {object} An object literal with easting, northing, zoneLetter,\n *     zoneNumber and accuracy (in meters) properties.\n */\nfunction decode(mgrsString) {\n\n  if (mgrsString && mgrsString.length === 0) {\n    throw (\"MGRSPoint coverting from nothing\");\n  }\n\n  var length = mgrsString.length;\n\n  var hunK = null;\n  var sb = \"\";\n  var testChar;\n  var i = 0;\n\n  // get Zone number\n  while (!(/[A-Z]/).test(testChar = mgrsString.charAt(i))) {\n    if (i >= 2) {\n      throw (\"MGRSPoint bad conversion from: \" + mgrsString);\n    }\n    sb += testChar;\n    i++;\n  }\n\n  var zoneNumber = parseInt(sb, 10);\n\n  if (i === 0 || i + 3 > length) {\n    // A good MGRS string has to be 4-5 digits long,\n    // ##AAA/#AAA at least.\n    throw (\"MGRSPoint bad conversion from: \" + mgrsString);\n  }\n\n  var zoneLetter = mgrsString.charAt(i++);\n\n  // Should we check the zone letter here? Why not.\n  if (zoneLetter <= 'A' || zoneLetter === 'B' || zoneLetter === 'Y' || zoneLetter >= 'Z' || zoneLetter === 'I' || zoneLetter === 'O') {\n    throw (\"MGRSPoint zone letter \" + zoneLetter + \" not handled: \" + mgrsString);\n  }\n\n  hunK = mgrsString.substring(i, i += 2);\n\n  var set = get100kSetForZone(zoneNumber);\n\n  var east100k = getEastingFromChar(hunK.charAt(0), set);\n  var north100k = getNorthingFromChar(hunK.charAt(1), set);\n\n  // We have a bug where the northing may be 2000000 too low.\n  // How\n  // do we know when to roll over?\n\n  while (north100k < getMinNorthing(zoneLetter)) {\n    north100k += 2000000;\n  }\n\n  // calculate the char index for easting/northing separator\n  var remainder = length - i;\n\n  if (remainder % 2 !== 0) {\n    throw (\"MGRSPoint has to have an even number \\nof digits after the zone letter and two 100km letters - front \\nhalf for easting meters, second half for \\nnorthing meters\" + mgrsString);\n  }\n\n  var sep = remainder / 2;\n\n  var sepEasting = 0.0;\n  var sepNorthing = 0.0;\n  var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;\n  if (sep > 0) {\n    accuracyBonus = 100000.0 / Math.pow(10, sep);\n    sepEastingString = mgrsString.substring(i, i + sep);\n    sepEasting = parseFloat(sepEastingString) * accuracyBonus;\n    sepNorthingString = mgrsString.substring(i + sep);\n    sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;\n  }\n\n  easting = sepEasting + east100k;\n  northing = sepNorthing + north100k;\n\n  return {\n    easting: easting,\n    northing: northing,\n    zoneLetter: zoneLetter,\n    zoneNumber: zoneNumber,\n    accuracy: accuracyBonus\n  };\n}\n\n/**\n * Given the first letter from a two-letter MGRS 100k zone, and given the\n * MGRS table set for the zone number, figure out the easting value that\n * should be added to the other, secondary easting value.\n *\n * @private\n * @param {char} e The first letter from a two-letter MGRS 100´k zone.\n * @param {number} set The MGRS table set for the zone number.\n * @return {number} The easting value for the given letter and set.\n */\nfunction getEastingFromChar(e, set) {\n  // colOrigin is the letter at the origin of the set for the\n  // column\n  var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1);\n  var eastingValue = 100000.0;\n  var rewindMarker = false;\n\n  while (curCol !== e.charCodeAt(0)) {\n    curCol++;\n    if (curCol === I) {\n      curCol++;\n    }\n    if (curCol === O) {\n      curCol++;\n    }\n    if (curCol > Z) {\n      if (rewindMarker) {\n        throw (\"Bad character: \" + e);\n      }\n      curCol = A;\n      rewindMarker = true;\n    }\n    eastingValue += 100000.0;\n  }\n\n  return eastingValue;\n}\n\n/**\n * Given the second letter from a two-letter MGRS 100k zone, and given the\n * MGRS table set for the zone number, figure out the northing value that\n * should be added to the other, secondary northing value. You have to\n * remember that Northings are determined from the equator, and the vertical\n * cycle of letters mean a 2000000 additional northing meters. This happens\n * approx. every 18 degrees of latitude. This method does *NOT* count any\n * additional northings. You have to figure out how many 2000000 meters need\n * to be added for the zone letter of the MGRS coordinate.\n *\n * @private\n * @param {char} n Second letter of the MGRS 100k zone\n * @param {number} set The MGRS table set number, which is dependent on the\n *     UTM zone number.\n * @return {number} The northing value for the given letter and set.\n */\nfunction getNorthingFromChar(n, set) {\n\n  if (n > 'V') {\n    throw (\"MGRSPoint given invalid Northing \" + n);\n  }\n\n  // rowOrigin is the letter at the origin of the set for the\n  // column\n  var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1);\n  var northingValue = 0.0;\n  var rewindMarker = false;\n\n  while (curRow !== n.charCodeAt(0)) {\n    curRow++;\n    if (curRow === I) {\n      curRow++;\n    }\n    if (curRow === O) {\n      curRow++;\n    }\n    // fixing a bug making whole application hang in this loop\n    // when 'n' is a wrong character\n    if (curRow > V) {\n      if (rewindMarker) { // making sure that this loop ends\n        throw (\"Bad character: \" + n);\n      }\n      curRow = A;\n      rewindMarker = true;\n    }\n    northingValue += 100000.0;\n  }\n\n  return northingValue;\n}\n\n/**\n * The function getMinNorthing returns the minimum northing value of a MGRS\n * zone.\n *\n * Ported from Geotrans' c Lattitude_Band_Value structure table.\n *\n * @private\n * @param {char} zoneLetter The MGRS zone to get the min northing for.\n * @return {number}\n */\nfunction getMinNorthing(zoneLetter) {\n  var northing;\n  switch (zoneLetter) {\n  case 'C':\n    northing = 1100000.0;\n    break;\n  case 'D':\n    northing = 2000000.0;\n    break;\n  case 'E':\n    northing = 2800000.0;\n    break;\n  case 'F':\n    northing = 3700000.0;\n    break;\n  case 'G':\n    northing = 4600000.0;\n    break;\n  case 'H':\n    northing = 5500000.0;\n    break;\n  case 'J':\n    northing = 6400000.0;\n    break;\n  case 'K':\n    northing = 7300000.0;\n    break;\n  case 'L':\n    northing = 8200000.0;\n    break;\n  case 'M':\n    northing = 9100000.0;\n    break;\n  case 'N':\n    northing = 0.0;\n    break;\n  case 'P':\n    northing = 800000.0;\n    break;\n  case 'Q':\n    northing = 1700000.0;\n    break;\n  case 'R':\n    northing = 2600000.0;\n    break;\n  case 'S':\n    northing = 3500000.0;\n    break;\n  case 'T':\n    northing = 4400000.0;\n    break;\n  case 'U':\n    northing = 5300000.0;\n    break;\n  case 'V':\n    northing = 6200000.0;\n    break;\n  case 'W':\n    northing = 7000000.0;\n    break;\n  case 'X':\n    northing = 7900000.0;\n    break;\n  default:\n    northing = -1.0;\n  }\n  if (northing >= 0.0) {\n    return northing;\n  }\n  else {\n    throw (\"Invalid zone letter: \" + zoneLetter);\n  }\n\n}\n","/**\n * @module ol/AssertionError\n */\n\n/** @type {Object<number, string>} */\nconst messages = {\n  1: 'The view center is not defined',\n  2: 'The view resolution is not defined',\n  3: 'The view rotation is not defined',\n  4: '`image` and `src` cannot be provided at the same time',\n  5: '`imgSize` must be set when `image` is provided',\n  7: '`format` must be set when `url` is set',\n  8: 'Unknown `serverType` configured',\n  9: '`url` must be configured or set using `#setUrl()`',\n  10: 'The default `geometryFunction` can only handle `Point` geometries',\n  11: '`options.featureTypes` must be an Array',\n  12: '`options.geometryName` must also be provided when `options.bbox` is set',\n  13: 'Invalid corner',\n  14: 'Invalid color',\n  15: 'Tried to get a value for a key that does not exist in the cache',\n  16: 'Tried to set a value for a key that is used already',\n  17: '`resolutions` must be sorted in descending order',\n  18: 'Either `origin` or `origins` must be configured, never both',\n  19: 'Number of `tileSizes` and `resolutions` must be equal',\n  20: 'Number of `origins` and `resolutions` must be equal',\n  22: 'Either `tileSize` or `tileSizes` must be configured, never both',\n  24: 'Invalid extent or geometry provided as `geometry`',\n  25: 'Cannot fit empty extent provided as `geometry`',\n  26: 'Features must have an id set',\n  27: 'Features must have an id set',\n  28: '`renderMode` must be `\"hybrid\"` or `\"vector\"`',\n  30: 'The passed `feature` was already added to the source',\n  31: 'Tried to enqueue an `element` that was already added to the queue',\n  32: 'Transformation matrix cannot be inverted',\n  33: 'Invalid units',\n  34: 'Invalid geometry layout',\n  36: 'Unknown SRS type',\n  37: 'Unknown geometry type found',\n  38: '`styleMapValue` has an unknown type',\n  39: 'Unknown geometry type',\n  40: 'Expected `feature` to have a geometry',\n  41: 'Expected an `ol/style/Style` or an array of `ol/style/Style.js`',\n  42: 'Question unknown, the answer is 42',\n  43: 'Expected `layers` to be an array or a `Collection`',\n  47: 'Expected `controls` to be an array or an `ol/Collection`',\n  48: 'Expected `interactions` to be an array or an `ol/Collection`',\n  49: 'Expected `overlays` to be an array or an `ol/Collection`',\n  50: '`options.featureTypes` should be an Array',\n  51: 'Either `url` or `tileJSON` options must be provided',\n  52: 'Unknown `serverType` configured',\n  53: 'Unknown `tierSizeCalculation` configured',\n  55: 'The {-y} placeholder requires a tile grid with extent',\n  56: 'mapBrowserEvent must originate from a pointer event',\n  57: 'At least 2 conditions are required',\n  59: 'Invalid command found in the PBF',\n  60: 'Missing or invalid `size`',\n  61: 'Cannot determine IIIF Image API version from provided image information JSON',\n  62: 'A `WebGLArrayBuffer` must either be of type `ELEMENT_ARRAY_BUFFER` or `ARRAY_BUFFER`',\n  64: 'Layer opacity must be a number',\n  66: '`forEachFeatureAtCoordinate` cannot be used on a WebGL layer if the hit detection logic has not been enabled. This is done by providing adequate shaders using the `hitVertexShader` and `hitFragmentShader` properties of `WebGLPointsLayerRenderer`',\n  67: 'A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both',\n  68: 'A VectorTile source can only be rendered if it has a projection compatible with the view projection',\n  69: '`width` or `height` cannot be provided together with `scale`',\n};\n\n/**\n * Error object thrown when an assertion failed. This is an ECMA-262 Error,\n * extended with a `code` property.\n * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error.\n */\nclass AssertionError extends Error {\n  /**\n   * @param {number} code Error code.\n   */\n  constructor(code) {\n    const message = messages[code];\n\n    super(message);\n\n    /**\n     * Error code. The meaning of the code can be found on\n     * https://openlayers.org/en/latest/doc/errors/ (replace `latest` with\n     * the version found in the OpenLayers script's header comment if a version\n     * other than the latest is used).\n     * @type {number}\n     * @deprecated ol/AssertionError and error codes will be removed in v8.0\n     * @api\n     */\n    this.code = code;\n\n    /**\n     * @type {string}\n     */\n    this.name = 'AssertionError';\n\n    // Re-assign message, see https://github.com/Rich-Harris/buble/issues/40\n    this.message = message;\n  }\n}\n\nexport default AssertionError;\n","/**\n * @module ol/asserts\n */\nimport AssertionError from './AssertionError.js';\n\n/**\n * @param {*} assertion Assertion we expected to be truthy.\n * @param {number} errorCode Error code.\n */\nexport function assert(assertion, errorCode) {\n  if (!assertion) {\n    throw new AssertionError(errorCode);\n  }\n}\n","/**\n * @module ol/console\n */\n\n/**\n * @typedef {'info'|'warn'|'error'|'none'} Level\n */\n\n/**\n * @type {Object<Level, number>}\n */\nconst levels = {\n  info: 1,\n  warn: 2,\n  error: 3,\n  none: 4,\n};\n\n/**\n * @type {number}\n */\nlet level = levels.info;\n\n/**\n * Set the logging level.  By default, the level is set to 'info' and all\n * messages will be logged.  Set to 'warn' to only display warnings and errors.\n * Set to 'error' to only display errors.  Set to 'none' to silence all messages.\n *\n * @param {Level} l The new level.\n */\nexport function setLevel(l) {\n  level = levels[l];\n}\n\nexport function log(...args) {\n  if (level > levels.info) {\n    return;\n  }\n  console.log(...args); // eslint-disable-line no-console\n}\n\nexport function warn(...args) {\n  if (level > levels.warn) {\n    return;\n  }\n  console.warn(...args); // eslint-disable-line no-console\n}\n\nexport function error(...args) {\n  if (level > levels.error) {\n    return;\n  }\n  console.error(...args); // eslint-disable-line no-console\n}\n","/**\n * @module ol/coordinate\n */\nimport {getWidth} from './extent.js';\nimport {modulo, toFixed} from './math.js';\nimport {padNumber} from './string.js';\n\n/**\n * An array of numbers representing an xy coordinate. Example: `[16, 48]`.\n * @typedef {Array<number>} Coordinate\n * @api\n */\n\n/**\n * A function that takes a {@link module:ol/coordinate~Coordinate} and\n * transforms it into a `{string}`.\n *\n * @typedef {function((Coordinate|undefined)): string} CoordinateFormat\n * @api\n */\n\n/**\n * Add `delta` to `coordinate`. `coordinate` is modified in place and returned\n * by the function.\n *\n * Example:\n *\n *     import {add} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     add(coord, [-2, 4]);\n *     // coord is now [5.85, 51.983333]\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {Coordinate} delta Delta.\n * @return {Coordinate} The input coordinate adjusted by\n * the given delta.\n * @api\n */\nexport function add(coordinate, delta) {\n  coordinate[0] += +delta[0];\n  coordinate[1] += +delta[1];\n  return coordinate;\n}\n\n/**\n * Calculates the point closest to the passed coordinate on the passed circle.\n *\n * @param {Coordinate} coordinate The coordinate.\n * @param {import(\"./geom/Circle.js\").default} circle The circle.\n * @return {Coordinate} Closest point on the circumference.\n */\nexport function closestOnCircle(coordinate, circle) {\n  const r = circle.getRadius();\n  const center = circle.getCenter();\n  const x0 = center[0];\n  const y0 = center[1];\n  const x1 = coordinate[0];\n  const y1 = coordinate[1];\n\n  let dx = x1 - x0;\n  const dy = y1 - y0;\n  if (dx === 0 && dy === 0) {\n    dx = 1;\n  }\n  const d = Math.sqrt(dx * dx + dy * dy);\n\n  const x = x0 + (r * dx) / d;\n  const y = y0 + (r * dy) / d;\n\n  return [x, y];\n}\n\n/**\n * Calculates the point closest to the passed coordinate on the passed segment.\n * This is the foot of the perpendicular of the coordinate to the segment when\n * the foot is on the segment, or the closest segment coordinate when the foot\n * is outside the segment.\n *\n * @param {Coordinate} coordinate The coordinate.\n * @param {Array<Coordinate>} segment The two coordinates\n * of the segment.\n * @return {Coordinate} The foot of the perpendicular of\n * the coordinate to the segment.\n */\nexport function closestOnSegment(coordinate, segment) {\n  const x0 = coordinate[0];\n  const y0 = coordinate[1];\n  const start = segment[0];\n  const end = segment[1];\n  const x1 = start[0];\n  const y1 = start[1];\n  const x2 = end[0];\n  const y2 = end[1];\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  const along =\n    dx === 0 && dy === 0\n      ? 0\n      : (dx * (x0 - x1) + dy * (y0 - y1)) / (dx * dx + dy * dy || 0);\n  let x, y;\n  if (along <= 0) {\n    x = x1;\n    y = y1;\n  } else if (along >= 1) {\n    x = x2;\n    y = y2;\n  } else {\n    x = x1 + along * dx;\n    y = y1 + along * dy;\n  }\n  return [x, y];\n}\n\n/**\n * Returns a {@link module:ol/coordinate~CoordinateFormat} function that can be\n * used to format\n * a {Coordinate} to a string.\n *\n * Example without specifying the fractional digits:\n *\n *     import {createStringXY} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const stringifyFunc = createStringXY();\n *     const out = stringifyFunc(coord);\n *     // out is now '8, 48'\n *\n * Example with explicitly specifying 2 fractional digits:\n *\n *     import {createStringXY} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const stringifyFunc = createStringXY(2);\n *     const out = stringifyFunc(coord);\n *     // out is now '7.85, 47.98'\n *\n * @param {number} [fractionDigits] The number of digits to include\n *    after the decimal point. Default is `0`.\n * @return {CoordinateFormat} Coordinate format.\n * @api\n */\nexport function createStringXY(fractionDigits) {\n  return (\n    /**\n     * @param {Coordinate} coordinate Coordinate.\n     * @return {string} String XY.\n     */\n    function (coordinate) {\n      return toStringXY(coordinate, fractionDigits);\n    }\n  );\n}\n\n/**\n * @param {string} hemispheres Hemispheres.\n * @param {number} degrees Degrees.\n * @param {number} [fractionDigits] The number of digits to include\n *    after the decimal point. Default is `0`.\n * @return {string} String.\n */\nexport function degreesToStringHDMS(hemispheres, degrees, fractionDigits) {\n  const normalizedDegrees = modulo(degrees + 180, 360) - 180;\n  const x = Math.abs(3600 * normalizedDegrees);\n  const decimals = fractionDigits || 0;\n\n  let deg = Math.floor(x / 3600);\n  let min = Math.floor((x - deg * 3600) / 60);\n  let sec = toFixed(x - deg * 3600 - min * 60, decimals);\n\n  if (sec >= 60) {\n    sec = 0;\n    min += 1;\n  }\n\n  if (min >= 60) {\n    min = 0;\n    deg += 1;\n  }\n\n  let hdms = deg + '\\u00b0';\n  if (min !== 0 || sec !== 0) {\n    hdms += ' ' + padNumber(min, 2) + '\\u2032';\n  }\n  if (sec !== 0) {\n    hdms += ' ' + padNumber(sec, 2, decimals) + '\\u2033';\n  }\n  if (normalizedDegrees !== 0) {\n    hdms += ' ' + hemispheres.charAt(normalizedDegrees < 0 ? 1 : 0);\n  }\n\n  return hdms;\n}\n\n/**\n * Transforms the given {@link module:ol/coordinate~Coordinate} to a string\n * using the given string template. The strings `{x}` and `{y}` in the template\n * will be replaced with the first and second coordinate values respectively.\n *\n * Example without specifying the fractional digits:\n *\n *     import {format} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const template = 'Coordinate is ({x}|{y}).';\n *     const out = format(coord, template);\n *     // out is now 'Coordinate is (8|48).'\n *\n * Example explicitly specifying the fractional digits:\n *\n *     import {format} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const template = 'Coordinate is ({x}|{y}).';\n *     const out = format(coord, template, 2);\n *     // out is now 'Coordinate is (7.85|47.98).'\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {string} template A template string with `{x}` and `{y}` placeholders\n *     that will be replaced by first and second coordinate values.\n * @param {number} [fractionDigits] The number of digits to include\n *    after the decimal point. Default is `0`.\n * @return {string} Formatted coordinate.\n * @api\n */\nexport function format(coordinate, template, fractionDigits) {\n  if (coordinate) {\n    return template\n      .replace('{x}', coordinate[0].toFixed(fractionDigits))\n      .replace('{y}', coordinate[1].toFixed(fractionDigits));\n  }\n  return '';\n}\n\n/**\n * @param {Coordinate} coordinate1 First coordinate.\n * @param {Coordinate} coordinate2 Second coordinate.\n * @return {boolean} The two coordinates are equal.\n */\nexport function equals(coordinate1, coordinate2) {\n  let equals = true;\n  for (let i = coordinate1.length - 1; i >= 0; --i) {\n    if (coordinate1[i] != coordinate2[i]) {\n      equals = false;\n      break;\n    }\n  }\n  return equals;\n}\n\n/**\n * Rotate `coordinate` by `angle`. `coordinate` is modified in place and\n * returned by the function.\n *\n * Example:\n *\n *     import {rotate} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const rotateRadians = Math.PI / 2; // 90 degrees\n *     rotate(coord, rotateRadians);\n *     // coord is now [-47.983333, 7.85]\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {number} angle Angle in radian.\n * @return {Coordinate} Coordinate.\n * @api\n */\nexport function rotate(coordinate, angle) {\n  const cosAngle = Math.cos(angle);\n  const sinAngle = Math.sin(angle);\n  const x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;\n  const y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;\n  coordinate[0] = x;\n  coordinate[1] = y;\n  return coordinate;\n}\n\n/**\n * Scale `coordinate` by `scale`. `coordinate` is modified in place and returned\n * by the function.\n *\n * Example:\n *\n *     import {scale as scaleCoordinate} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const scale = 1.2;\n *     scaleCoordinate(coord, scale);\n *     // coord is now [9.42, 57.5799996]\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {number} scale Scale factor.\n * @return {Coordinate} Coordinate.\n */\nexport function scale(coordinate, scale) {\n  coordinate[0] *= scale;\n  coordinate[1] *= scale;\n  return coordinate;\n}\n\n/**\n * @param {Coordinate} coord1 First coordinate.\n * @param {Coordinate} coord2 Second coordinate.\n * @return {number} Squared distance between coord1 and coord2.\n */\nexport function squaredDistance(coord1, coord2) {\n  const dx = coord1[0] - coord2[0];\n  const dy = coord1[1] - coord2[1];\n  return dx * dx + dy * dy;\n}\n\n/**\n * @param {Coordinate} coord1 First coordinate.\n * @param {Coordinate} coord2 Second coordinate.\n * @return {number} Distance between coord1 and coord2.\n */\nexport function distance(coord1, coord2) {\n  return Math.sqrt(squaredDistance(coord1, coord2));\n}\n\n/**\n * Calculate the squared distance from a coordinate to a line segment.\n *\n * @param {Coordinate} coordinate Coordinate of the point.\n * @param {Array<Coordinate>} segment Line segment (2\n * coordinates).\n * @return {number} Squared distance from the point to the line segment.\n */\nexport function squaredDistanceToSegment(coordinate, segment) {\n  return squaredDistance(coordinate, closestOnSegment(coordinate, segment));\n}\n\n/**\n * Format a geographic coordinate with the hemisphere, degrees, minutes, and\n * seconds.\n *\n * Example without specifying fractional digits:\n *\n *     import {toStringHDMS} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const out = toStringHDMS(coord);\n *     // out is now '47° 58′ 60″ N 7° 50′ 60″ E'\n *\n * Example explicitly specifying 1 fractional digit:\n *\n *     import {toStringHDMS} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const out = toStringHDMS(coord, 1);\n *     // out is now '47° 58′ 60.0″ N 7° 50′ 60.0″ E'\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {number} [fractionDigits] The number of digits to include\n *    after the decimal point. Default is `0`.\n * @return {string} Hemisphere, degrees, minutes and seconds.\n * @api\n */\nexport function toStringHDMS(coordinate, fractionDigits) {\n  if (coordinate) {\n    return (\n      degreesToStringHDMS('NS', coordinate[1], fractionDigits) +\n      ' ' +\n      degreesToStringHDMS('EW', coordinate[0], fractionDigits)\n    );\n  }\n  return '';\n}\n\n/**\n * Format a coordinate as a comma delimited string.\n *\n * Example without specifying fractional digits:\n *\n *     import {toStringXY} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const out = toStringXY(coord);\n *     // out is now '8, 48'\n *\n * Example explicitly specifying 1 fractional digit:\n *\n *     import {toStringXY} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const out = toStringXY(coord, 1);\n *     // out is now '7.8, 48.0'\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {number} [fractionDigits] The number of digits to include\n *    after the decimal point. Default is `0`.\n * @return {string} XY.\n * @api\n */\nexport function toStringXY(coordinate, fractionDigits) {\n  return format(coordinate, '{x}, {y}', fractionDigits);\n}\n\n/**\n * Modifies the provided coordinate in-place to be within the real world\n * extent. The lower projection extent boundary is inclusive, the upper one\n * exclusive.\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {Coordinate} The coordinate within the real world extent.\n */\nexport function wrapX(coordinate, projection) {\n  if (projection.canWrapX()) {\n    const worldWidth = getWidth(projection.getExtent());\n    const worldsAway = getWorldsAway(coordinate, projection, worldWidth);\n    if (worldsAway) {\n      coordinate[0] -= worldsAway * worldWidth;\n    }\n  }\n  return coordinate;\n}\n/**\n * @param {Coordinate} coordinate Coordinate.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @param {number} [sourceExtentWidth] Width of the source extent.\n * @return {number} Offset in world widths.\n */\nexport function getWorldsAway(coordinate, projection, sourceExtentWidth) {\n  const projectionExtent = projection.getExtent();\n  let worldsAway = 0;\n  if (\n    projection.canWrapX() &&\n    (coordinate[0] < projectionExtent[0] || coordinate[0] > projectionExtent[2])\n  ) {\n    sourceExtentWidth = sourceExtentWidth || getWidth(projectionExtent);\n    worldsAway = Math.floor(\n      (coordinate[0] - projectionExtent[0]) / sourceExtentWidth\n    );\n  }\n  return worldsAway;\n}\n","/**\n * @module ol/extent\n */\nimport Relationship from './extent/Relationship.js';\nimport {assert} from './asserts.js';\n\n/**\n * An array of numbers representing an extent: `[minx, miny, maxx, maxy]`.\n * @typedef {Array<number>} Extent\n * @api\n */\n\n/**\n * Extent corner.\n * @typedef {'bottom-left' | 'bottom-right' | 'top-left' | 'top-right'} Corner\n */\n\n/**\n * Build an extent that includes all given coordinates.\n *\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates Coordinates.\n * @return {Extent} Bounding extent.\n * @api\n */\nexport function boundingExtent(coordinates) {\n  const extent = createEmpty();\n  for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n    extendCoordinate(extent, coordinates[i]);\n  }\n  return extent;\n}\n\n/**\n * @param {Array<number>} xs Xs.\n * @param {Array<number>} ys Ys.\n * @param {Extent} [dest] Destination extent.\n * @private\n * @return {Extent} Extent.\n */\nfunction _boundingExtentXYs(xs, ys, dest) {\n  const minX = Math.min.apply(null, xs);\n  const minY = Math.min.apply(null, ys);\n  const maxX = Math.max.apply(null, xs);\n  const maxY = Math.max.apply(null, ys);\n  return createOrUpdate(minX, minY, maxX, maxY, dest);\n}\n\n/**\n * Return extent increased by the provided value.\n * @param {Extent} extent Extent.\n * @param {number} value The amount by which the extent should be buffered.\n * @param {Extent} [dest] Extent.\n * @return {Extent} Extent.\n * @api\n */\nexport function buffer(extent, value, dest) {\n  if (dest) {\n    dest[0] = extent[0] - value;\n    dest[1] = extent[1] - value;\n    dest[2] = extent[2] + value;\n    dest[3] = extent[3] + value;\n    return dest;\n  }\n  return [\n    extent[0] - value,\n    extent[1] - value,\n    extent[2] + value,\n    extent[3] + value,\n  ];\n}\n\n/**\n * Creates a clone of an extent.\n *\n * @param {Extent} extent Extent to clone.\n * @param {Extent} [dest] Extent.\n * @return {Extent} The clone.\n */\nexport function clone(extent, dest) {\n  if (dest) {\n    dest[0] = extent[0];\n    dest[1] = extent[1];\n    dest[2] = extent[2];\n    dest[3] = extent[3];\n    return dest;\n  }\n  return extent.slice();\n}\n\n/**\n * @param {Extent} extent Extent.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {number} Closest squared distance.\n */\nexport function closestSquaredDistanceXY(extent, x, y) {\n  let dx, dy;\n  if (x < extent[0]) {\n    dx = extent[0] - x;\n  } else if (extent[2] < x) {\n    dx = x - extent[2];\n  } else {\n    dx = 0;\n  }\n  if (y < extent[1]) {\n    dy = extent[1] - y;\n  } else if (extent[3] < y) {\n    dy = y - extent[3];\n  } else {\n    dy = 0;\n  }\n  return dx * dx + dy * dy;\n}\n\n/**\n * Check if the passed coordinate is contained or on the edge of the extent.\n *\n * @param {Extent} extent Extent.\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n * @return {boolean} The coordinate is contained in the extent.\n * @api\n */\nexport function containsCoordinate(extent, coordinate) {\n  return containsXY(extent, coordinate[0], coordinate[1]);\n}\n\n/**\n * Check if one extent contains another.\n *\n * An extent is deemed contained if it lies completely within the other extent,\n * including if they share one or more edges.\n *\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @return {boolean} The second extent is contained by or on the edge of the\n *     first.\n * @api\n */\nexport function containsExtent(extent1, extent2) {\n  return (\n    extent1[0] <= extent2[0] &&\n    extent2[2] <= extent1[2] &&\n    extent1[1] <= extent2[1] &&\n    extent2[3] <= extent1[3]\n  );\n}\n\n/**\n * Check if the passed coordinate is contained or on the edge of the extent.\n *\n * @param {Extent} extent Extent.\n * @param {number} x X coordinate.\n * @param {number} y Y coordinate.\n * @return {boolean} The x, y values are contained in the extent.\n * @api\n */\nexport function containsXY(extent, x, y) {\n  return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];\n}\n\n/**\n * Get the relationship between a coordinate and extent.\n * @param {Extent} extent The extent.\n * @param {import(\"./coordinate.js\").Coordinate} coordinate The coordinate.\n * @return {import(\"./extent/Relationship.js\").default} The relationship (bitwise compare with\n *     import(\"./extent/Relationship.js\").Relationship).\n */\nexport function coordinateRelationship(extent, coordinate) {\n  const minX = extent[0];\n  const minY = extent[1];\n  const maxX = extent[2];\n  const maxY = extent[3];\n  const x = coordinate[0];\n  const y = coordinate[1];\n  let relationship = Relationship.UNKNOWN;\n  if (x < minX) {\n    relationship = relationship | Relationship.LEFT;\n  } else if (x > maxX) {\n    relationship = relationship | Relationship.RIGHT;\n  }\n  if (y < minY) {\n    relationship = relationship | Relationship.BELOW;\n  } else if (y > maxY) {\n    relationship = relationship | Relationship.ABOVE;\n  }\n  if (relationship === Relationship.UNKNOWN) {\n    relationship = Relationship.INTERSECTING;\n  }\n  return relationship;\n}\n\n/**\n * Create an empty extent.\n * @return {Extent} Empty extent.\n * @api\n */\nexport function createEmpty() {\n  return [Infinity, Infinity, -Infinity, -Infinity];\n}\n\n/**\n * Create a new extent or update the provided extent.\n * @param {number} minX Minimum X.\n * @param {number} minY Minimum Y.\n * @param {number} maxX Maximum X.\n * @param {number} maxY Maximum Y.\n * @param {Extent} [dest] Destination extent.\n * @return {Extent} Extent.\n */\nexport function createOrUpdate(minX, minY, maxX, maxY, dest) {\n  if (dest) {\n    dest[0] = minX;\n    dest[1] = minY;\n    dest[2] = maxX;\n    dest[3] = maxY;\n    return dest;\n  }\n  return [minX, minY, maxX, maxY];\n}\n\n/**\n * Create a new empty extent or make the provided one empty.\n * @param {Extent} [dest] Extent.\n * @return {Extent} Extent.\n */\nexport function createOrUpdateEmpty(dest) {\n  return createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, dest);\n}\n\n/**\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n * @param {Extent} [dest] Extent.\n * @return {Extent} Extent.\n */\nexport function createOrUpdateFromCoordinate(coordinate, dest) {\n  const x = coordinate[0];\n  const y = coordinate[1];\n  return createOrUpdate(x, y, x, y, dest);\n}\n\n/**\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates Coordinates.\n * @param {Extent} [dest] Extent.\n * @return {Extent} Extent.\n */\nexport function createOrUpdateFromCoordinates(coordinates, dest) {\n  const extent = createOrUpdateEmpty(dest);\n  return extendCoordinates(extent, coordinates);\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {Extent} [dest] Extent.\n * @return {Extent} Extent.\n */\nexport function createOrUpdateFromFlatCoordinates(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  dest\n) {\n  const extent = createOrUpdateEmpty(dest);\n  return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);\n}\n\n/**\n * @param {Array<Array<import(\"./coordinate.js\").Coordinate>>} rings Rings.\n * @param {Extent} [dest] Extent.\n * @return {Extent} Extent.\n */\nexport function createOrUpdateFromRings(rings, dest) {\n  const extent = createOrUpdateEmpty(dest);\n  return extendRings(extent, rings);\n}\n\n/**\n * Determine if two extents are equivalent.\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @return {boolean} The two extents are equivalent.\n * @api\n */\nexport function equals(extent1, extent2) {\n  return (\n    extent1[0] == extent2[0] &&\n    extent1[2] == extent2[2] &&\n    extent1[1] == extent2[1] &&\n    extent1[3] == extent2[3]\n  );\n}\n\n/**\n * Determine if two extents are approximately equivalent.\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @param {number} tolerance Tolerance in extent coordinate units.\n * @return {boolean} The two extents differ by less than the tolerance.\n */\nexport function approximatelyEquals(extent1, extent2, tolerance) {\n  return (\n    Math.abs(extent1[0] - extent2[0]) < tolerance &&\n    Math.abs(extent1[2] - extent2[2]) < tolerance &&\n    Math.abs(extent1[1] - extent2[1]) < tolerance &&\n    Math.abs(extent1[3] - extent2[3]) < tolerance\n  );\n}\n\n/**\n * Modify an extent to include another extent.\n * @param {Extent} extent1 The extent to be modified.\n * @param {Extent} extent2 The extent that will be included in the first.\n * @return {Extent} A reference to the first (extended) extent.\n * @api\n */\nexport function extend(extent1, extent2) {\n  if (extent2[0] < extent1[0]) {\n    extent1[0] = extent2[0];\n  }\n  if (extent2[2] > extent1[2]) {\n    extent1[2] = extent2[2];\n  }\n  if (extent2[1] < extent1[1]) {\n    extent1[1] = extent2[1];\n  }\n  if (extent2[3] > extent1[3]) {\n    extent1[3] = extent2[3];\n  }\n  return extent1;\n}\n\n/**\n * @param {Extent} extent Extent.\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n */\nexport function extendCoordinate(extent, coordinate) {\n  if (coordinate[0] < extent[0]) {\n    extent[0] = coordinate[0];\n  }\n  if (coordinate[0] > extent[2]) {\n    extent[2] = coordinate[0];\n  }\n  if (coordinate[1] < extent[1]) {\n    extent[1] = coordinate[1];\n  }\n  if (coordinate[1] > extent[3]) {\n    extent[3] = coordinate[1];\n  }\n}\n\n/**\n * @param {Extent} extent Extent.\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates Coordinates.\n * @return {Extent} Extent.\n */\nexport function extendCoordinates(extent, coordinates) {\n  for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n    extendCoordinate(extent, coordinates[i]);\n  }\n  return extent;\n}\n\n/**\n * @param {Extent} extent Extent.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {Extent} Extent.\n */\nexport function extendFlatCoordinates(\n  extent,\n  flatCoordinates,\n  offset,\n  end,\n  stride\n) {\n  for (; offset < end; offset += stride) {\n    extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);\n  }\n  return extent;\n}\n\n/**\n * @param {Extent} extent Extent.\n * @param {Array<Array<import(\"./coordinate.js\").Coordinate>>} rings Rings.\n * @return {Extent} Extent.\n */\nexport function extendRings(extent, rings) {\n  for (let i = 0, ii = rings.length; i < ii; ++i) {\n    extendCoordinates(extent, rings[i]);\n  }\n  return extent;\n}\n\n/**\n * @param {Extent} extent Extent.\n * @param {number} x X.\n * @param {number} y Y.\n */\nexport function extendXY(extent, x, y) {\n  extent[0] = Math.min(extent[0], x);\n  extent[1] = Math.min(extent[1], y);\n  extent[2] = Math.max(extent[2], x);\n  extent[3] = Math.max(extent[3], y);\n}\n\n/**\n * This function calls `callback` for each corner of the extent. If the\n * callback returns a truthy value the function returns that value\n * immediately. Otherwise the function returns `false`.\n * @param {Extent} extent Extent.\n * @param {function(import(\"./coordinate.js\").Coordinate): S} callback Callback.\n * @return {S|boolean} Value.\n * @template S\n */\nexport function forEachCorner(extent, callback) {\n  let val;\n  val = callback(getBottomLeft(extent));\n  if (val) {\n    return val;\n  }\n  val = callback(getBottomRight(extent));\n  if (val) {\n    return val;\n  }\n  val = callback(getTopRight(extent));\n  if (val) {\n    return val;\n  }\n  val = callback(getTopLeft(extent));\n  if (val) {\n    return val;\n  }\n  return false;\n}\n\n/**\n * Get the size of an extent.\n * @param {Extent} extent Extent.\n * @return {number} Area.\n * @api\n */\nexport function getArea(extent) {\n  let area = 0;\n  if (!isEmpty(extent)) {\n    area = getWidth(extent) * getHeight(extent);\n  }\n  return area;\n}\n\n/**\n * Get the bottom left coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import(\"./coordinate.js\").Coordinate} Bottom left coordinate.\n * @api\n */\nexport function getBottomLeft(extent) {\n  return [extent[0], extent[1]];\n}\n\n/**\n * Get the bottom right coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import(\"./coordinate.js\").Coordinate} Bottom right coordinate.\n * @api\n */\nexport function getBottomRight(extent) {\n  return [extent[2], extent[1]];\n}\n\n/**\n * Get the center coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import(\"./coordinate.js\").Coordinate} Center.\n * @api\n */\nexport function getCenter(extent) {\n  return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];\n}\n\n/**\n * Get a corner coordinate of an extent.\n * @param {Extent} extent Extent.\n * @param {Corner} corner Corner.\n * @return {import(\"./coordinate.js\").Coordinate} Corner coordinate.\n */\nexport function getCorner(extent, corner) {\n  let coordinate;\n  if (corner === 'bottom-left') {\n    coordinate = getBottomLeft(extent);\n  } else if (corner === 'bottom-right') {\n    coordinate = getBottomRight(extent);\n  } else if (corner === 'top-left') {\n    coordinate = getTopLeft(extent);\n  } else if (corner === 'top-right') {\n    coordinate = getTopRight(extent);\n  } else {\n    assert(false, 13); // Invalid corner\n  }\n  return coordinate;\n}\n\n/**\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @return {number} Enlarged area.\n */\nexport function getEnlargedArea(extent1, extent2) {\n  const minX = Math.min(extent1[0], extent2[0]);\n  const minY = Math.min(extent1[1], extent2[1]);\n  const maxX = Math.max(extent1[2], extent2[2]);\n  const maxY = Math.max(extent1[3], extent2[3]);\n  return (maxX - minX) * (maxY - minY);\n}\n\n/**\n * @param {import(\"./coordinate.js\").Coordinate} center Center.\n * @param {number} resolution Resolution.\n * @param {number} rotation Rotation.\n * @param {import(\"./size.js\").Size} size Size.\n * @param {Extent} [dest] Destination extent.\n * @return {Extent} Extent.\n */\nexport function getForViewAndSize(center, resolution, rotation, size, dest) {\n  const [x0, y0, x1, y1, x2, y2, x3, y3] = getRotatedViewport(\n    center,\n    resolution,\n    rotation,\n    size\n  );\n  return createOrUpdate(\n    Math.min(x0, x1, x2, x3),\n    Math.min(y0, y1, y2, y3),\n    Math.max(x0, x1, x2, x3),\n    Math.max(y0, y1, y2, y3),\n    dest\n  );\n}\n\n/**\n * @param {import(\"./coordinate.js\").Coordinate} center Center.\n * @param {number} resolution Resolution.\n * @param {number} rotation Rotation.\n * @param {import(\"./size.js\").Size} size Size.\n * @return {Array<number>} Linear ring representing the viewport.\n */\nexport function getRotatedViewport(center, resolution, rotation, size) {\n  const dx = (resolution * size[0]) / 2;\n  const dy = (resolution * size[1]) / 2;\n  const cosRotation = Math.cos(rotation);\n  const sinRotation = Math.sin(rotation);\n  const xCos = dx * cosRotation;\n  const xSin = dx * sinRotation;\n  const yCos = dy * cosRotation;\n  const ySin = dy * sinRotation;\n  const x = center[0];\n  const y = center[1];\n  return [\n    x - xCos + ySin,\n    y - xSin - yCos,\n    x - xCos - ySin,\n    y - xSin + yCos,\n    x + xCos - ySin,\n    y + xSin + yCos,\n    x + xCos + ySin,\n    y + xSin - yCos,\n    x - xCos + ySin,\n    y - xSin - yCos,\n  ];\n}\n\n/**\n * Get the height of an extent.\n * @param {Extent} extent Extent.\n * @return {number} Height.\n * @api\n */\nexport function getHeight(extent) {\n  return extent[3] - extent[1];\n}\n\n/**\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @return {number} Intersection area.\n */\nexport function getIntersectionArea(extent1, extent2) {\n  const intersection = getIntersection(extent1, extent2);\n  return getArea(intersection);\n}\n\n/**\n * Get the intersection of two extents.\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @param {Extent} [dest] Optional extent to populate with intersection.\n * @return {Extent} Intersecting extent.\n * @api\n */\nexport function getIntersection(extent1, extent2, dest) {\n  const intersection = dest ? dest : createEmpty();\n  if (intersects(extent1, extent2)) {\n    if (extent1[0] > extent2[0]) {\n      intersection[0] = extent1[0];\n    } else {\n      intersection[0] = extent2[0];\n    }\n    if (extent1[1] > extent2[1]) {\n      intersection[1] = extent1[1];\n    } else {\n      intersection[1] = extent2[1];\n    }\n    if (extent1[2] < extent2[2]) {\n      intersection[2] = extent1[2];\n    } else {\n      intersection[2] = extent2[2];\n    }\n    if (extent1[3] < extent2[3]) {\n      intersection[3] = extent1[3];\n    } else {\n      intersection[3] = extent2[3];\n    }\n  } else {\n    createOrUpdateEmpty(intersection);\n  }\n  return intersection;\n}\n\n/**\n * @param {Extent} extent Extent.\n * @return {number} Margin.\n */\nexport function getMargin(extent) {\n  return getWidth(extent) + getHeight(extent);\n}\n\n/**\n * Get the size (width, height) of an extent.\n * @param {Extent} extent The extent.\n * @return {import(\"./size.js\").Size} The extent size.\n * @api\n */\nexport function getSize(extent) {\n  return [extent[2] - extent[0], extent[3] - extent[1]];\n}\n\n/**\n * Get the top left coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import(\"./coordinate.js\").Coordinate} Top left coordinate.\n * @api\n */\nexport function getTopLeft(extent) {\n  return [extent[0], extent[3]];\n}\n\n/**\n * Get the top right coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import(\"./coordinate.js\").Coordinate} Top right coordinate.\n * @api\n */\nexport function getTopRight(extent) {\n  return [extent[2], extent[3]];\n}\n\n/**\n * Get the width of an extent.\n * @param {Extent} extent Extent.\n * @return {number} Width.\n * @api\n */\nexport function getWidth(extent) {\n  return extent[2] - extent[0];\n}\n\n/**\n * Determine if one extent intersects another.\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent.\n * @return {boolean} The two extents intersect.\n * @api\n */\nexport function intersects(extent1, extent2) {\n  return (\n    extent1[0] <= extent2[2] &&\n    extent1[2] >= extent2[0] &&\n    extent1[1] <= extent2[3] &&\n    extent1[3] >= extent2[1]\n  );\n}\n\n/**\n * Determine if an extent is empty.\n * @param {Extent} extent Extent.\n * @return {boolean} Is empty.\n * @api\n */\nexport function isEmpty(extent) {\n  return extent[2] < extent[0] || extent[3] < extent[1];\n}\n\n/**\n * @param {Extent} extent Extent.\n * @param {Extent} [dest] Extent.\n * @return {Extent} Extent.\n */\nexport function returnOrUpdate(extent, dest) {\n  if (dest) {\n    dest[0] = extent[0];\n    dest[1] = extent[1];\n    dest[2] = extent[2];\n    dest[3] = extent[3];\n    return dest;\n  }\n  return extent;\n}\n\n/**\n * @param {Extent} extent Extent.\n * @param {number} value Value.\n */\nexport function scaleFromCenter(extent, value) {\n  const deltaX = ((extent[2] - extent[0]) / 2) * (value - 1);\n  const deltaY = ((extent[3] - extent[1]) / 2) * (value - 1);\n  extent[0] -= deltaX;\n  extent[2] += deltaX;\n  extent[1] -= deltaY;\n  extent[3] += deltaY;\n}\n\n/**\n * Determine if the segment between two coordinates intersects (crosses,\n * touches, or is contained by) the provided extent.\n * @param {Extent} extent The extent.\n * @param {import(\"./coordinate.js\").Coordinate} start Segment start coordinate.\n * @param {import(\"./coordinate.js\").Coordinate} end Segment end coordinate.\n * @return {boolean} The segment intersects the extent.\n */\nexport function intersectsSegment(extent, start, end) {\n  let intersects = false;\n  const startRel = coordinateRelationship(extent, start);\n  const endRel = coordinateRelationship(extent, end);\n  if (\n    startRel === Relationship.INTERSECTING ||\n    endRel === Relationship.INTERSECTING\n  ) {\n    intersects = true;\n  } else {\n    const minX = extent[0];\n    const minY = extent[1];\n    const maxX = extent[2];\n    const maxY = extent[3];\n    const startX = start[0];\n    const startY = start[1];\n    const endX = end[0];\n    const endY = end[1];\n    const slope = (endY - startY) / (endX - startX);\n    let x, y;\n    if (!!(endRel & Relationship.ABOVE) && !(startRel & Relationship.ABOVE)) {\n      // potentially intersects top\n      x = endX - (endY - maxY) / slope;\n      intersects = x >= minX && x <= maxX;\n    }\n    if (\n      !intersects &&\n      !!(endRel & Relationship.RIGHT) &&\n      !(startRel & Relationship.RIGHT)\n    ) {\n      // potentially intersects right\n      y = endY - (endX - maxX) * slope;\n      intersects = y >= minY && y <= maxY;\n    }\n    if (\n      !intersects &&\n      !!(endRel & Relationship.BELOW) &&\n      !(startRel & Relationship.BELOW)\n    ) {\n      // potentially intersects bottom\n      x = endX - (endY - minY) / slope;\n      intersects = x >= minX && x <= maxX;\n    }\n    if (\n      !intersects &&\n      !!(endRel & Relationship.LEFT) &&\n      !(startRel & Relationship.LEFT)\n    ) {\n      // potentially intersects left\n      y = endY - (endX - minX) * slope;\n      intersects = y >= minY && y <= maxY;\n    }\n  }\n  return intersects;\n}\n\n/**\n * Apply a transform function to the extent.\n * @param {Extent} extent Extent.\n * @param {import(\"./proj.js\").TransformFunction} transformFn Transform function.\n * Called with `[minX, minY, maxX, maxY]` extent coordinates.\n * @param {Extent} [dest] Destination extent.\n * @param {number} [stops] Number of stops per side used for the transform.\n * By default only the corners are used.\n * @return {Extent} Extent.\n * @api\n */\nexport function applyTransform(extent, transformFn, dest, stops) {\n  let coordinates = [];\n  if (stops > 1) {\n    const width = extent[2] - extent[0];\n    const height = extent[3] - extent[1];\n    for (let i = 0; i < stops; ++i) {\n      coordinates.push(\n        extent[0] + (width * i) / stops,\n        extent[1],\n        extent[2],\n        extent[1] + (height * i) / stops,\n        extent[2] - (width * i) / stops,\n        extent[3],\n        extent[0],\n        extent[3] - (height * i) / stops\n      );\n    }\n  } else {\n    coordinates = [\n      extent[0],\n      extent[1],\n      extent[2],\n      extent[1],\n      extent[2],\n      extent[3],\n      extent[0],\n      extent[3],\n    ];\n  }\n  transformFn(coordinates, coordinates, 2);\n  const xs = [];\n  const ys = [];\n  for (let i = 0, l = coordinates.length; i < l; i += 2) {\n    xs.push(coordinates[i]);\n    ys.push(coordinates[i + 1]);\n  }\n  return _boundingExtentXYs(xs, ys, dest);\n}\n\n/**\n * Modifies the provided extent in-place to be within the real world\n * extent.\n *\n * @param {Extent} extent Extent.\n * @param {import(\"./proj/Projection.js\").default} projection Projection\n * @return {Extent} The extent within the real world extent.\n */\nexport function wrapX(extent, projection) {\n  const projectionExtent = projection.getExtent();\n  const center = getCenter(extent);\n  if (\n    projection.canWrapX() &&\n    (center[0] < projectionExtent[0] || center[0] >= projectionExtent[2])\n  ) {\n    const worldWidth = getWidth(projectionExtent);\n    const worldsAway = Math.floor(\n      (center[0] - projectionExtent[0]) / worldWidth\n    );\n    const offset = worldsAway * worldWidth;\n    extent[0] -= offset;\n    extent[2] -= offset;\n  }\n  return extent;\n}\n\n/**\n * Fits the extent to the real world\n *\n * If the extent does not cross the anti meridian, this will return the extent in an array\n * If the extent crosses the anti meridian, the extent will be sliced, so each part fits within the\n * real world\n *\n *\n * @param {Extent} extent Extent.\n * @param {import(\"./proj/Projection.js\").default} projection Projection\n * @return {Array<Extent>} The extent within the real world extent.\n */\nexport function wrapAndSliceX(extent, projection) {\n  if (projection.canWrapX()) {\n    const projectionExtent = projection.getExtent();\n\n    if (!isFinite(extent[0]) || !isFinite(extent[2])) {\n      return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];\n    }\n\n    wrapX(extent, projection);\n    const worldWidth = getWidth(projectionExtent);\n\n    if (getWidth(extent) > worldWidth) {\n      // the extent wraps around on itself\n      return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];\n    } else if (extent[0] < projectionExtent[0]) {\n      // the extent crosses the anti meridian, so it needs to be sliced\n      return [\n        [extent[0] + worldWidth, extent[1], projectionExtent[2], extent[3]],\n        [projectionExtent[0], extent[1], extent[2], extent[3]],\n      ];\n    } else if (extent[2] > projectionExtent[2]) {\n      // the extent crosses the anti meridian, so it needs to be sliced\n      return [\n        [extent[0], extent[1], projectionExtent[2], extent[3]],\n        [projectionExtent[0], extent[1], extent[2] - worldWidth, extent[3]],\n      ];\n    }\n  }\n\n  return [extent];\n}\n","/**\n * @module ol/extent/Relationship\n */\n\n/**\n * Relationship to an extent.\n * @enum {number}\n */\nexport default {\n  UNKNOWN: 0,\n  INTERSECTING: 1,\n  ABOVE: 2,\n  RIGHT: 4,\n  BELOW: 8,\n  LEFT: 16,\n};\n","/**\n * @module ol/math\n */\n\n/**\n * Takes a number and clamps it to within the provided bounds.\n * @param {number} value The input number.\n * @param {number} min The minimum value to return.\n * @param {number} max The maximum value to return.\n * @return {number} The input number if it is within bounds, or the nearest\n *     number within the bounds.\n */\nexport function clamp(value, min, max) {\n  return Math.min(Math.max(value, min), max);\n}\n\n/**\n * Returns the square of the closest distance between the point (x, y) and the\n * line segment (x1, y1) to (x2, y2).\n * @param {number} x X.\n * @param {number} y Y.\n * @param {number} x1 X1.\n * @param {number} y1 Y1.\n * @param {number} x2 X2.\n * @param {number} y2 Y2.\n * @return {number} Squared distance.\n */\nexport function squaredSegmentDistance(x, y, x1, y1, x2, y2) {\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  if (dx !== 0 || dy !== 0) {\n    const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\n    if (t > 1) {\n      x1 = x2;\n      y1 = y2;\n    } else if (t > 0) {\n      x1 += dx * t;\n      y1 += dy * t;\n    }\n  }\n  return squaredDistance(x, y, x1, y1);\n}\n\n/**\n * Returns the square of the distance between the points (x1, y1) and (x2, y2).\n * @param {number} x1 X1.\n * @param {number} y1 Y1.\n * @param {number} x2 X2.\n * @param {number} y2 Y2.\n * @return {number} Squared distance.\n */\nexport function squaredDistance(x1, y1, x2, y2) {\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  return dx * dx + dy * dy;\n}\n\n/**\n * Solves system of linear equations using Gaussian elimination method.\n *\n * @param {Array<Array<number>>} mat Augmented matrix (n x n + 1 column)\n *                                     in row-major order.\n * @return {Array<number>} The resulting vector.\n */\nexport function solveLinearSystem(mat) {\n  const n = mat.length;\n\n  for (let i = 0; i < n; i++) {\n    // Find max in the i-th column (ignoring i - 1 first rows)\n    let maxRow = i;\n    let maxEl = Math.abs(mat[i][i]);\n    for (let r = i + 1; r < n; r++) {\n      const absValue = Math.abs(mat[r][i]);\n      if (absValue > maxEl) {\n        maxEl = absValue;\n        maxRow = r;\n      }\n    }\n\n    if (maxEl === 0) {\n      return null; // matrix is singular\n    }\n\n    // Swap max row with i-th (current) row\n    const tmp = mat[maxRow];\n    mat[maxRow] = mat[i];\n    mat[i] = tmp;\n\n    // Subtract the i-th row to make all the remaining rows 0 in the i-th column\n    for (let j = i + 1; j < n; j++) {\n      const coef = -mat[j][i] / mat[i][i];\n      for (let k = i; k < n + 1; k++) {\n        if (i == k) {\n          mat[j][k] = 0;\n        } else {\n          mat[j][k] += coef * mat[i][k];\n        }\n      }\n    }\n  }\n\n  // Solve Ax=b for upper triangular matrix A (mat)\n  const x = new Array(n);\n  for (let l = n - 1; l >= 0; l--) {\n    x[l] = mat[l][n] / mat[l][l];\n    for (let m = l - 1; m >= 0; m--) {\n      mat[m][n] -= mat[m][l] * x[l];\n    }\n  }\n  return x;\n}\n\n/**\n * Converts radians to to degrees.\n *\n * @param {number} angleInRadians Angle in radians.\n * @return {number} Angle in degrees.\n */\nexport function toDegrees(angleInRadians) {\n  return (angleInRadians * 180) / Math.PI;\n}\n\n/**\n * Converts degrees to radians.\n *\n * @param {number} angleInDegrees Angle in degrees.\n * @return {number} Angle in radians.\n */\nexport function toRadians(angleInDegrees) {\n  return (angleInDegrees * Math.PI) / 180;\n}\n\n/**\n * Returns the modulo of a / b, depending on the sign of b.\n *\n * @param {number} a Dividend.\n * @param {number} b Divisor.\n * @return {number} Modulo.\n */\nexport function modulo(a, b) {\n  const r = a % b;\n  return r * b < 0 ? r + b : r;\n}\n\n/**\n * Calculates the linearly interpolated value of x between a and b.\n *\n * @param {number} a Number\n * @param {number} b Number\n * @param {number} x Value to be interpolated.\n * @return {number} Interpolated value.\n */\nexport function lerp(a, b, x) {\n  return a + x * (b - a);\n}\n\n/**\n * Returns a number with a limited number of decimal digits.\n * @param {number} n The input number.\n * @param {number} decimals The maximum number of decimal digits.\n * @return {number} The input number with a limited number of decimal digits.\n */\nexport function toFixed(n, decimals) {\n  const factor = Math.pow(10, decimals);\n  return Math.round(n * factor) / factor;\n}\n\n/**\n * Rounds a number to the nearest integer value considering only the given number\n * of decimal digits (with rounding on the final digit).\n * @param {number} n The input number.\n * @param {number} decimals The maximum number of decimal digits.\n * @return {number} The nearest integer.\n */\nexport function round(n, decimals) {\n  return Math.round(toFixed(n, decimals));\n}\n\n/**\n * Rounds a number to the next smaller integer considering only the given number\n * of decimal digits (with rounding on the final digit).\n * @param {number} n The input number.\n * @param {number} decimals The maximum number of decimal digits.\n * @return {number} The next smaller integer.\n */\nexport function floor(n, decimals) {\n  return Math.floor(toFixed(n, decimals));\n}\n\n/**\n * Rounds a number to the next bigger integer considering only the given number\n * of decimal digits (with rounding on the final digit).\n * @param {number} n The input number.\n * @param {number} decimals The maximum number of decimal digits.\n * @return {number} The next bigger integer.\n */\nexport function ceil(n, decimals) {\n  return Math.ceil(toFixed(n, decimals));\n}\n","/**\n * @module ol/proj/epsg3857\n */\nimport Projection from './Projection.js';\n\n/**\n * Radius of WGS84 sphere\n *\n * @const\n * @type {number}\n */\nexport const RADIUS = 6378137;\n\n/**\n * @const\n * @type {number}\n */\nexport const HALF_SIZE = Math.PI * RADIUS;\n\n/**\n * @const\n * @type {import(\"../extent.js\").Extent}\n */\nexport const EXTENT = [-HALF_SIZE, -HALF_SIZE, HALF_SIZE, HALF_SIZE];\n\n/**\n * @const\n * @type {import(\"../extent.js\").Extent}\n */\nexport const WORLD_EXTENT = [-180, -85, 180, 85];\n\n/**\n * Maximum safe value in y direction\n * @const\n * @type {number}\n */\nexport const MAX_SAFE_Y = RADIUS * Math.log(Math.tan(Math.PI / 2));\n\n/**\n * @classdesc\n * Projection object for web/spherical Mercator (EPSG:3857).\n */\nclass EPSG3857Projection extends Projection {\n  /**\n   * @param {string} code Code.\n   */\n  constructor(code) {\n    super({\n      code: code,\n      units: 'm',\n      extent: EXTENT,\n      global: true,\n      worldExtent: WORLD_EXTENT,\n      getPointResolution: function (resolution, point) {\n        return resolution / Math.cosh(point[1] / RADIUS);\n      },\n    });\n  }\n}\n\n/**\n * Projections equal to EPSG:3857.\n *\n * @const\n * @type {Array<import(\"./Projection.js\").default>}\n */\nexport const PROJECTIONS = [\n  new EPSG3857Projection('EPSG:3857'),\n  new EPSG3857Projection('EPSG:102100'),\n  new EPSG3857Projection('EPSG:102113'),\n  new EPSG3857Projection('EPSG:900913'),\n  new EPSG3857Projection('http://www.opengis.net/def/crs/EPSG/0/3857'),\n  new EPSG3857Projection('http://www.opengis.net/gml/srs/epsg.xml#3857'),\n];\n\n/**\n * Transformation from EPSG:4326 to EPSG:3857.\n *\n * @param {Array<number>} input Input array of coordinate values.\n * @param {Array<number>} [output] Output array of coordinate values.\n * @param {number} [dimension] Dimension (default is `2`).\n * @return {Array<number>} Output array of coordinate values.\n */\nexport function fromEPSG4326(input, output, dimension) {\n  const length = input.length;\n  dimension = dimension > 1 ? dimension : 2;\n  if (output === undefined) {\n    if (dimension > 2) {\n      // preserve values beyond second dimension\n      output = input.slice();\n    } else {\n      output = new Array(length);\n    }\n  }\n  for (let i = 0; i < length; i += dimension) {\n    output[i] = (HALF_SIZE * input[i]) / 180;\n    let y = RADIUS * Math.log(Math.tan((Math.PI * (+input[i + 1] + 90)) / 360));\n    if (y > MAX_SAFE_Y) {\n      y = MAX_SAFE_Y;\n    } else if (y < -MAX_SAFE_Y) {\n      y = -MAX_SAFE_Y;\n    }\n    output[i + 1] = y;\n  }\n  return output;\n}\n\n/**\n * Transformation from EPSG:3857 to EPSG:4326.\n *\n * @param {Array<number>} input Input array of coordinate values.\n * @param {Array<number>} [output] Output array of coordinate values.\n * @param {number} [dimension] Dimension (default is `2`).\n * @return {Array<number>} Output array of coordinate values.\n */\nexport function toEPSG4326(input, output, dimension) {\n  const length = input.length;\n  dimension = dimension > 1 ? dimension : 2;\n  if (output === undefined) {\n    if (dimension > 2) {\n      // preserve values beyond second dimension\n      output = input.slice();\n    } else {\n      output = new Array(length);\n    }\n  }\n  for (let i = 0; i < length; i += dimension) {\n    output[i] = (180 * input[i]) / HALF_SIZE;\n    output[i + 1] =\n      (360 * Math.atan(Math.exp(input[i + 1] / RADIUS))) / Math.PI - 90;\n  }\n  return output;\n}\n","/**\n * @module ol/proj/epsg4326\n */\nimport Projection from './Projection.js';\n\n/**\n * Semi-major radius of the WGS84 ellipsoid.\n *\n * @const\n * @type {number}\n */\nexport const RADIUS = 6378137;\n\n/**\n * Extent of the EPSG:4326 projection which is the whole world.\n *\n * @const\n * @type {import(\"../extent.js\").Extent}\n */\nexport const EXTENT = [-180, -90, 180, 90];\n\n/**\n * @const\n * @type {number}\n */\nexport const METERS_PER_UNIT = (Math.PI * RADIUS) / 180;\n\n/**\n * @classdesc\n * Projection object for WGS84 geographic coordinates (EPSG:4326).\n *\n * Note that OpenLayers does not strictly comply with the EPSG definition.\n * The EPSG registry defines 4326 as a CRS for Latitude,Longitude (y,x).\n * OpenLayers treats EPSG:4326 as a pseudo-projection, with x,y coordinates.\n */\nclass EPSG4326Projection extends Projection {\n  /**\n   * @param {string} code Code.\n   * @param {string} [axisOrientation] Axis orientation.\n   */\n  constructor(code, axisOrientation) {\n    super({\n      code: code,\n      units: 'degrees',\n      extent: EXTENT,\n      axisOrientation: axisOrientation,\n      global: true,\n      metersPerUnit: METERS_PER_UNIT,\n      worldExtent: EXTENT,\n    });\n  }\n}\n\n/**\n * Projections equal to EPSG:4326.\n *\n * @const\n * @type {Array<import(\"./Projection.js\").default>}\n */\nexport const PROJECTIONS = [\n  new EPSG4326Projection('CRS:84'),\n  new EPSG4326Projection('EPSG:4326', 'neu'),\n  new EPSG4326Projection('urn:ogc:def:crs:OGC:1.3:CRS84'),\n  new EPSG4326Projection('urn:ogc:def:crs:OGC:2:84'),\n  new EPSG4326Projection('http://www.opengis.net/def/crs/OGC/1.3/CRS84'),\n  new EPSG4326Projection('http://www.opengis.net/gml/srs/epsg.xml#4326', 'neu'),\n  new EPSG4326Projection('http://www.opengis.net/def/crs/EPSG/0/4326', 'neu'),\n];\n","/**\n * @module ol/proj/projections\n */\n\n/**\n * @type {Object<string, import(\"./Projection.js\").default>}\n */\nlet cache = {};\n\n/**\n * Clear the projections cache.\n */\nexport function clear() {\n  cache = {};\n}\n\n/**\n * Get a cached projection by code.\n * @param {string} code The code for the projection.\n * @return {import(\"./Projection.js\").default} The projection (if cached).\n */\nexport function get(code) {\n  return (\n    cache[code] ||\n    cache[code.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\\w+)$/, 'EPSG:$3')] ||\n    null\n  );\n}\n\n/**\n * Add a projection to the cache.\n * @param {string} code The projection code.\n * @param {import(\"./Projection.js\").default} projection The projection to cache.\n */\nexport function add(code, projection) {\n  cache[code] = projection;\n}\n","/**\n * @module ol/sphere\n */\nimport {toDegrees, toRadians} from './math.js';\n\n/**\n * Object literal with options for the {@link getLength} or {@link getArea}\n * functions.\n * @typedef {Object} SphereMetricOptions\n * @property {import(\"./proj.js\").ProjectionLike} [projection='EPSG:3857']\n * Projection of the  geometry.  By default, the geometry is assumed to be in\n * Web Mercator.\n * @property {number} [radius=6371008.8] Sphere radius.  By default, the\n * [mean Earth radius](https://en.wikipedia.org/wiki/Earth_radius#Mean_radius)\n * for the WGS84 ellipsoid is used.\n */\n\n/**\n * The mean Earth radius (1/3 * (2a + b)) for the WGS84 ellipsoid.\n * https://en.wikipedia.org/wiki/Earth_radius#Mean_radius\n * @type {number}\n */\nexport const DEFAULT_RADIUS = 6371008.8;\n\n/**\n * Get the great circle distance (in meters) between two geographic coordinates.\n * @param {Array} c1 Starting coordinate.\n * @param {Array} c2 Ending coordinate.\n * @param {number} [radius] The sphere radius to use.  Defaults to the Earth's\n *     mean radius using the WGS84 ellipsoid.\n * @return {number} The great circle distance between the points (in meters).\n * @api\n */\nexport function getDistance(c1, c2, radius) {\n  radius = radius || DEFAULT_RADIUS;\n  const lat1 = toRadians(c1[1]);\n  const lat2 = toRadians(c2[1]);\n  const deltaLatBy2 = (lat2 - lat1) / 2;\n  const deltaLonBy2 = toRadians(c2[0] - c1[0]) / 2;\n  const a =\n    Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) +\n    Math.sin(deltaLonBy2) *\n      Math.sin(deltaLonBy2) *\n      Math.cos(lat1) *\n      Math.cos(lat2);\n  return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n}\n\n/**\n * Get the cumulative great circle length of linestring coordinates (geographic).\n * @param {Array} coordinates Linestring coordinates.\n * @param {number} radius The sphere radius to use.\n * @return {number} The length (in meters).\n */\nfunction getLengthInternal(coordinates, radius) {\n  let length = 0;\n  for (let i = 0, ii = coordinates.length; i < ii - 1; ++i) {\n    length += getDistance(coordinates[i], coordinates[i + 1], radius);\n  }\n  return length;\n}\n\n/**\n * Get the spherical length of a geometry.  This length is the sum of the\n * great circle distances between coordinates.  For polygons, the length is\n * the sum of all rings.  For points, the length is zero.  For multi-part\n * geometries, the length is the sum of the length of each part.\n * @param {import(\"./geom/Geometry.js\").default} geometry A geometry.\n * @param {SphereMetricOptions} [options] Options for the\n * length calculation.  By default, geometries are assumed to be in 'EPSG:3857'.\n * You can change this by providing a `projection` option.\n * @return {number} The spherical length (in meters).\n * @api\n */\nexport function getLength(geometry, options) {\n  options = options || {};\n  const radius = options.radius || DEFAULT_RADIUS;\n  const projection = options.projection || 'EPSG:3857';\n  const type = geometry.getType();\n  if (type !== 'GeometryCollection') {\n    geometry = geometry.clone().transform(projection, 'EPSG:4326');\n  }\n  let length = 0;\n  let coordinates, coords, i, ii, j, jj;\n  switch (type) {\n    case 'Point':\n    case 'MultiPoint': {\n      break;\n    }\n    case 'LineString':\n    case 'LinearRing': {\n      coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (\n        geometry\n      ).getCoordinates();\n      length = getLengthInternal(coordinates, radius);\n      break;\n    }\n    case 'MultiLineString':\n    case 'Polygon': {\n      coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (\n        geometry\n      ).getCoordinates();\n      for (i = 0, ii = coordinates.length; i < ii; ++i) {\n        length += getLengthInternal(coordinates[i], radius);\n      }\n      break;\n    }\n    case 'MultiPolygon': {\n      coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (\n        geometry\n      ).getCoordinates();\n      for (i = 0, ii = coordinates.length; i < ii; ++i) {\n        coords = coordinates[i];\n        for (j = 0, jj = coords.length; j < jj; ++j) {\n          length += getLengthInternal(coords[j], radius);\n        }\n      }\n      break;\n    }\n    case 'GeometryCollection': {\n      const geometries =\n        /** @type {import(\"./geom/GeometryCollection.js\").default} */ (\n          geometry\n        ).getGeometries();\n      for (i = 0, ii = geometries.length; i < ii; ++i) {\n        length += getLength(geometries[i], options);\n      }\n      break;\n    }\n    default: {\n      throw new Error('Unsupported geometry type: ' + type);\n    }\n  }\n  return length;\n}\n\n/**\n * Returns the spherical area for a list of coordinates.\n *\n * [Reference](https://trs.jpl.nasa.gov/handle/2014/40409)\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for\n * Polygons on a Sphere\", JPL Publication 07-03, Jet Propulsion\n * Laboratory, Pasadena, CA, June 2007\n *\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates List of coordinates of a linear\n * ring. If the ring is oriented clockwise, the area will be positive,\n * otherwise it will be negative.\n * @param {number} radius The sphere radius.\n * @return {number} Area (in square meters).\n */\nfunction getAreaInternal(coordinates, radius) {\n  let area = 0;\n  const len = coordinates.length;\n  let x1 = coordinates[len - 1][0];\n  let y1 = coordinates[len - 1][1];\n  for (let i = 0; i < len; i++) {\n    const x2 = coordinates[i][0];\n    const y2 = coordinates[i][1];\n    area +=\n      toRadians(x2 - x1) *\n      (2 + Math.sin(toRadians(y1)) + Math.sin(toRadians(y2)));\n    x1 = x2;\n    y1 = y2;\n  }\n  return (area * radius * radius) / 2.0;\n}\n\n/**\n * Get the spherical area of a geometry.  This is the area (in meters) assuming\n * that polygon edges are segments of great circles on a sphere.\n * @param {import(\"./geom/Geometry.js\").default} geometry A geometry.\n * @param {SphereMetricOptions} [options] Options for the area\n *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.\n *     You can change this by providing a `projection` option.\n * @return {number} The spherical area (in square meters).\n * @api\n */\nexport function getArea(geometry, options) {\n  options = options || {};\n  const radius = options.radius || DEFAULT_RADIUS;\n  const projection = options.projection || 'EPSG:3857';\n  const type = geometry.getType();\n  if (type !== 'GeometryCollection') {\n    geometry = geometry.clone().transform(projection, 'EPSG:4326');\n  }\n  let area = 0;\n  let coordinates, coords, i, ii, j, jj;\n  switch (type) {\n    case 'Point':\n    case 'MultiPoint':\n    case 'LineString':\n    case 'MultiLineString':\n    case 'LinearRing': {\n      break;\n    }\n    case 'Polygon': {\n      coordinates = /** @type {import(\"./geom/Polygon.js\").default} */ (\n        geometry\n      ).getCoordinates();\n      area = Math.abs(getAreaInternal(coordinates[0], radius));\n      for (i = 1, ii = coordinates.length; i < ii; ++i) {\n        area -= Math.abs(getAreaInternal(coordinates[i], radius));\n      }\n      break;\n    }\n    case 'MultiPolygon': {\n      coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (\n        geometry\n      ).getCoordinates();\n      for (i = 0, ii = coordinates.length; i < ii; ++i) {\n        coords = coordinates[i];\n        area += Math.abs(getAreaInternal(coords[0], radius));\n        for (j = 1, jj = coords.length; j < jj; ++j) {\n          area -= Math.abs(getAreaInternal(coords[j], radius));\n        }\n      }\n      break;\n    }\n    case 'GeometryCollection': {\n      const geometries =\n        /** @type {import(\"./geom/GeometryCollection.js\").default} */ (\n          geometry\n        ).getGeometries();\n      for (i = 0, ii = geometries.length; i < ii; ++i) {\n        area += getArea(geometries[i], options);\n      }\n      break;\n    }\n    default: {\n      throw new Error('Unsupported geometry type: ' + type);\n    }\n  }\n  return area;\n}\n\n/**\n * Returns the coordinate at the given distance and bearing from `c1`.\n *\n * @param {import(\"./coordinate.js\").Coordinate} c1 The origin point (`[lon, lat]` in degrees).\n * @param {number} distance The great-circle distance between the origin\n *     point and the target point.\n * @param {number} bearing The bearing (in radians).\n * @param {number} [radius] The sphere radius to use.  Defaults to the Earth's\n *     mean radius using the WGS84 ellipsoid.\n * @return {import(\"./coordinate.js\").Coordinate} The target point.\n */\nexport function offset(c1, distance, bearing, radius) {\n  radius = radius || DEFAULT_RADIUS;\n  const lat1 = toRadians(c1[1]);\n  const lon1 = toRadians(c1[0]);\n  const dByR = distance / radius;\n  const lat = Math.asin(\n    Math.sin(lat1) * Math.cos(dByR) +\n      Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing)\n  );\n  const lon =\n    lon1 +\n    Math.atan2(\n      Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1),\n      Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat)\n    );\n  return [toDegrees(lon), toDegrees(lat)];\n}\n","/**\n * @module ol/proj\n */\n\n/**\n * The ol/proj module stores:\n * * a list of {@link module:ol/proj/Projection~Projection}\n * objects, one for each projection supported by the application\n * * a list of transform functions needed to convert coordinates in one projection\n * into another.\n *\n * The static functions are the methods used to maintain these.\n * Each transform function can handle not only simple coordinate pairs, but also\n * large arrays of coordinates such as vector geometries.\n *\n * When loaded, the library adds projection objects for EPSG:4326 (WGS84\n * geographic coordinates) and EPSG:3857 (Web or Spherical Mercator, as used\n * for example by Bing Maps or OpenStreetMap), together with the relevant\n * transform functions.\n *\n * Additional transforms may be added by using the http://proj4js.org/\n * library (version 2.2 or later). You can use the full build supplied by\n * Proj4js, or create a custom build to support those projections you need; see\n * the Proj4js website for how to do this. You also need the Proj4js definitions\n * for the required projections. These definitions can be obtained from\n * https://epsg.io/, and are a JS function, so can be loaded in a script\n * tag (as in the examples) or pasted into your application.\n *\n * After all required projection definitions are added to proj4's registry (by\n * using `proj4.defs()`), simply call `register(proj4)` from the `ol/proj/proj4`\n * package. Existing transforms are not changed by this function. See\n * examples/wms-image-custom-proj for an example of this.\n *\n * Additional projection definitions can be registered with `proj4.defs()` any\n * time. Just make sure to call `register(proj4)` again; for example, with user-supplied data where you don't\n * know in advance what projections are needed, you can initially load minimal\n * support and then load whichever are requested.\n *\n * Note that Proj4js does not support projection extents. If you want to add\n * one for creating default tile grids, you can add it after the Projection\n * object has been created with `setExtent`, for example,\n * `get('EPSG:1234').setExtent(extent)`.\n *\n * In addition to Proj4js support, any transform functions can be added with\n * {@link module:ol/proj.addCoordinateTransforms}. To use this, you must first create\n * a {@link module:ol/proj/Projection~Projection} object for the new projection and add it with\n * {@link module:ol/proj.addProjection}. You can then add the forward and inverse\n * functions with {@link module:ol/proj.addCoordinateTransforms}. See\n * examples/wms-custom-proj for an example of this.\n *\n * Note that if no transforms are needed and you only need to define the\n * projection, just add a {@link module:ol/proj/Projection~Projection} with\n * {@link module:ol/proj.addProjection}. See examples/wms-no-proj for an example of\n * this.\n */\nimport Projection from './proj/Projection.js';\nimport {\n  PROJECTIONS as EPSG3857_PROJECTIONS,\n  fromEPSG4326,\n  toEPSG4326,\n} from './proj/epsg3857.js';\nimport {PROJECTIONS as EPSG4326_PROJECTIONS} from './proj/epsg4326.js';\nimport {METERS_PER_UNIT} from './proj/Units.js';\nimport {\n  add as addProj,\n  clear as clearProj,\n  get as getProj,\n} from './proj/projections.js';\nimport {\n  add as addTransformFunc,\n  clear as clearTransformFuncs,\n  get as getTransformFunc,\n} from './proj/transforms.js';\nimport {applyTransform, getWidth} from './extent.js';\nimport {clamp, modulo} from './math.js';\nimport {equals, getWorldsAway} from './coordinate.js';\nimport {getDistance} from './sphere.js';\nimport {warn} from './console.js';\n\n/**\n * A projection as {@link module:ol/proj/Projection~Projection}, SRS identifier\n * string or undefined.\n * @typedef {Projection|string|undefined} ProjectionLike\n * @api\n */\n\n/**\n * A transform function accepts an array of input coordinate values, an optional\n * output array, and an optional dimension (default should be 2).  The function\n * transforms the input coordinate values, populates the output array, and\n * returns the output array.\n *\n * @typedef {function(Array<number>, Array<number>=, number=): Array<number>} TransformFunction\n * @api\n */\n\nexport {METERS_PER_UNIT};\n\nexport {Projection};\n\nlet showCoordinateWarning = true;\n\n/**\n * @param {boolean} [disable = true] Disable console info about `useGeographic()`\n */\nexport function disableCoordinateWarning(disable) {\n  const hide = disable === undefined ? true : disable;\n  showCoordinateWarning = !hide;\n}\n\n/**\n * @param {Array<number>} input Input coordinate array.\n * @param {Array<number>} [output] Output array of coordinate values.\n * @return {Array<number>} Output coordinate array (new array, same coordinate\n *     values).\n */\nexport function cloneTransform(input, output) {\n  if (output !== undefined) {\n    for (let i = 0, ii = input.length; i < ii; ++i) {\n      output[i] = input[i];\n    }\n    output = output;\n  } else {\n    output = input.slice();\n  }\n  return output;\n}\n\n/**\n * @param {Array<number>} input Input coordinate array.\n * @param {Array<number>} [output] Output array of coordinate values.\n * @return {Array<number>} Input coordinate array (same array as input).\n */\nexport function identityTransform(input, output) {\n  if (output !== undefined && input !== output) {\n    for (let i = 0, ii = input.length; i < ii; ++i) {\n      output[i] = input[i];\n    }\n    input = output;\n  }\n  return input;\n}\n\n/**\n * Add a Projection object to the list of supported projections that can be\n * looked up by their code.\n *\n * @param {Projection} projection Projection instance.\n * @api\n */\nexport function addProjection(projection) {\n  addProj(projection.getCode(), projection);\n  addTransformFunc(projection, projection, cloneTransform);\n}\n\n/**\n * @param {Array<Projection>} projections Projections.\n */\nexport function addProjections(projections) {\n  projections.forEach(addProjection);\n}\n\n/**\n * Fetches a Projection object for the code specified.\n *\n * @param {ProjectionLike} projectionLike Either a code string which is\n *     a combination of authority and identifier such as \"EPSG:4326\", or an\n *     existing projection object, or undefined.\n * @return {Projection|null} Projection object, or null if not in list.\n * @api\n */\nexport function get(projectionLike) {\n  return typeof projectionLike === 'string'\n    ? getProj(/** @type {string} */ (projectionLike))\n    : /** @type {Projection} */ (projectionLike) || null;\n}\n\n/**\n * Get the resolution of the point in degrees or distance units.\n * For projections with degrees as the unit this will simply return the\n * provided resolution. For other projections the point resolution is\n * by default estimated by transforming the `point` pixel to EPSG:4326,\n * measuring its width and height on the normal sphere,\n * and taking the average of the width and height.\n * A custom function can be provided for a specific projection, either\n * by setting the `getPointResolution` option in the\n * {@link module:ol/proj/Projection~Projection} constructor or by using\n * {@link module:ol/proj/Projection~Projection#setGetPointResolution} to change an existing\n * projection object.\n * @param {ProjectionLike} projection The projection.\n * @param {number} resolution Nominal resolution in projection units.\n * @param {import(\"./coordinate.js\").Coordinate} point Point to find adjusted resolution at.\n * @param {import(\"./proj/Units.js\").Units} [units] Units to get the point resolution in.\n * Default is the projection's units.\n * @return {number} Point resolution.\n * @api\n */\nexport function getPointResolution(projection, resolution, point, units) {\n  projection = get(projection);\n  let pointResolution;\n  const getter = projection.getPointResolutionFunc();\n  if (getter) {\n    pointResolution = getter(resolution, point);\n    if (units && units !== projection.getUnits()) {\n      const metersPerUnit = projection.getMetersPerUnit();\n      if (metersPerUnit) {\n        pointResolution =\n          (pointResolution * metersPerUnit) / METERS_PER_UNIT[units];\n      }\n    }\n  } else {\n    const projUnits = projection.getUnits();\n    if ((projUnits == 'degrees' && !units) || units == 'degrees') {\n      pointResolution = resolution;\n    } else {\n      // Estimate point resolution by transforming the center pixel to EPSG:4326,\n      // measuring its width and height on the normal sphere, and taking the\n      // average of the width and height.\n      const toEPSG4326 = getTransformFromProjections(\n        projection,\n        get('EPSG:4326')\n      );\n      if (toEPSG4326 === identityTransform && projUnits !== 'degrees') {\n        // no transform is available\n        pointResolution = resolution * projection.getMetersPerUnit();\n      } else {\n        let vertices = [\n          point[0] - resolution / 2,\n          point[1],\n          point[0] + resolution / 2,\n          point[1],\n          point[0],\n          point[1] - resolution / 2,\n          point[0],\n          point[1] + resolution / 2,\n        ];\n        vertices = toEPSG4326(vertices, vertices, 2);\n        const width = getDistance(vertices.slice(0, 2), vertices.slice(2, 4));\n        const height = getDistance(vertices.slice(4, 6), vertices.slice(6, 8));\n        pointResolution = (width + height) / 2;\n      }\n      const metersPerUnit = units\n        ? METERS_PER_UNIT[units]\n        : projection.getMetersPerUnit();\n      if (metersPerUnit !== undefined) {\n        pointResolution /= metersPerUnit;\n      }\n    }\n  }\n  return pointResolution;\n}\n\n/**\n * Registers transformation functions that don't alter coordinates. Those allow\n * to transform between projections with equal meaning.\n *\n * @param {Array<Projection>} projections Projections.\n * @api\n */\nexport function addEquivalentProjections(projections) {\n  addProjections(projections);\n  projections.forEach(function (source) {\n    projections.forEach(function (destination) {\n      if (source !== destination) {\n        addTransformFunc(source, destination, cloneTransform);\n      }\n    });\n  });\n}\n\n/**\n * Registers transformation functions to convert coordinates in any projection\n * in projection1 to any projection in projection2.\n *\n * @param {Array<Projection>} projections1 Projections with equal\n *     meaning.\n * @param {Array<Projection>} projections2 Projections with equal\n *     meaning.\n * @param {TransformFunction} forwardTransform Transformation from any\n *   projection in projection1 to any projection in projection2.\n * @param {TransformFunction} inverseTransform Transform from any projection\n *   in projection2 to any projection in projection1..\n */\nexport function addEquivalentTransforms(\n  projections1,\n  projections2,\n  forwardTransform,\n  inverseTransform\n) {\n  projections1.forEach(function (projection1) {\n    projections2.forEach(function (projection2) {\n      addTransformFunc(projection1, projection2, forwardTransform);\n      addTransformFunc(projection2, projection1, inverseTransform);\n    });\n  });\n}\n\n/**\n * Clear all cached projections and transforms.\n */\nexport function clearAllProjections() {\n  clearProj();\n  clearTransformFuncs();\n}\n\n/**\n * @param {Projection|string|undefined} projection Projection.\n * @param {string} defaultCode Default code.\n * @return {Projection} Projection.\n */\nexport function createProjection(projection, defaultCode) {\n  if (!projection) {\n    return get(defaultCode);\n  } else if (typeof projection === 'string') {\n    return get(projection);\n  }\n  return /** @type {Projection} */ (projection);\n}\n\n/**\n * Creates a {@link module:ol/proj~TransformFunction} from a simple 2D coordinate transform\n * function.\n * @param {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} coordTransform Coordinate\n *     transform.\n * @return {TransformFunction} Transform function.\n */\nexport function createTransformFromCoordinateTransform(coordTransform) {\n  return (\n    /**\n     * @param {Array<number>} input Input.\n     * @param {Array<number>} [output] Output.\n     * @param {number} [dimension] Dimension.\n     * @return {Array<number>} Output.\n     */\n    function (input, output, dimension) {\n      const length = input.length;\n      dimension = dimension !== undefined ? dimension : 2;\n      output = output !== undefined ? output : new Array(length);\n      for (let i = 0; i < length; i += dimension) {\n        const point = coordTransform(input.slice(i, i + dimension));\n        const pointLength = point.length;\n        for (let j = 0, jj = dimension; j < jj; ++j) {\n          output[i + j] = j >= pointLength ? input[i + j] : point[j];\n        }\n      }\n      return output;\n    }\n  );\n}\n\n/**\n * Registers coordinate transform functions to convert coordinates between the\n * source projection and the destination projection.\n * The forward and inverse functions convert coordinate pairs; this function\n * converts these into the functions used internally which also handle\n * extents and coordinate arrays.\n *\n * @param {ProjectionLike} source Source projection.\n * @param {ProjectionLike} destination Destination projection.\n * @param {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} forward The forward transform\n *     function (that is, from the source projection to the destination\n *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns\n *     the transformed {@link module:ol/coordinate~Coordinate}.\n * @param {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} inverse The inverse transform\n *     function (that is, from the destination projection to the source\n *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns\n *     the transformed {@link module:ol/coordinate~Coordinate}. If the transform function can only\n *     transform less dimensions than the input coordinate, it is supposeed to return a coordinate\n *     with only the length it can transform. The other dimensions will be taken unchanged from the\n *     source.\n * @api\n */\nexport function addCoordinateTransforms(source, destination, forward, inverse) {\n  const sourceProj = get(source);\n  const destProj = get(destination);\n  addTransformFunc(\n    sourceProj,\n    destProj,\n    createTransformFromCoordinateTransform(forward)\n  );\n  addTransformFunc(\n    destProj,\n    sourceProj,\n    createTransformFromCoordinateTransform(inverse)\n  );\n}\n\n/**\n * Transforms a coordinate from longitude/latitude to a different projection.\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate as longitude and latitude, i.e.\n *     an array with longitude as 1st and latitude as 2nd element.\n * @param {ProjectionLike} [projection] Target projection. The\n *     default is Web Mercator, i.e. 'EPSG:3857'.\n * @return {import(\"./coordinate.js\").Coordinate} Coordinate projected to the target projection.\n * @api\n */\nexport function fromLonLat(coordinate, projection) {\n  disableCoordinateWarning();\n  return transform(\n    coordinate,\n    'EPSG:4326',\n    projection !== undefined ? projection : 'EPSG:3857'\n  );\n}\n\n/**\n * Transforms a coordinate to longitude/latitude.\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Projected coordinate.\n * @param {ProjectionLike} [projection] Projection of the coordinate.\n *     The default is Web Mercator, i.e. 'EPSG:3857'.\n * @return {import(\"./coordinate.js\").Coordinate} Coordinate as longitude and latitude, i.e. an array\n *     with longitude as 1st and latitude as 2nd element.\n * @api\n */\nexport function toLonLat(coordinate, projection) {\n  const lonLat = transform(\n    coordinate,\n    projection !== undefined ? projection : 'EPSG:3857',\n    'EPSG:4326'\n  );\n  const lon = lonLat[0];\n  if (lon < -180 || lon > 180) {\n    lonLat[0] = modulo(lon + 180, 360) - 180;\n  }\n  return lonLat;\n}\n\n/**\n * Checks if two projections are the same, that is every coordinate in one\n * projection does represent the same geographic point as the same coordinate in\n * the other projection.\n *\n * @param {Projection} projection1 Projection 1.\n * @param {Projection} projection2 Projection 2.\n * @return {boolean} Equivalent.\n * @api\n */\nexport function equivalent(projection1, projection2) {\n  if (projection1 === projection2) {\n    return true;\n  }\n  const equalUnits = projection1.getUnits() === projection2.getUnits();\n  if (projection1.getCode() === projection2.getCode()) {\n    return equalUnits;\n  }\n  const transformFunc = getTransformFromProjections(projection1, projection2);\n  return transformFunc === cloneTransform && equalUnits;\n}\n\n/**\n * Searches in the list of transform functions for the function for converting\n * coordinates from the source projection to the destination projection.\n *\n * @param {Projection} sourceProjection Source Projection object.\n * @param {Projection} destinationProjection Destination Projection\n *     object.\n * @return {TransformFunction} Transform function.\n */\nexport function getTransformFromProjections(\n  sourceProjection,\n  destinationProjection\n) {\n  const sourceCode = sourceProjection.getCode();\n  const destinationCode = destinationProjection.getCode();\n  let transformFunc = getTransformFunc(sourceCode, destinationCode);\n  if (!transformFunc) {\n    transformFunc = identityTransform;\n  }\n  return transformFunc;\n}\n\n/**\n * Given the projection-like objects, searches for a transformation\n * function to convert a coordinates array from the source projection to the\n * destination projection.\n *\n * @param {ProjectionLike} source Source.\n * @param {ProjectionLike} destination Destination.\n * @return {TransformFunction} Transform function.\n * @api\n */\nexport function getTransform(source, destination) {\n  const sourceProjection = get(source);\n  const destinationProjection = get(destination);\n  return getTransformFromProjections(sourceProjection, destinationProjection);\n}\n\n/**\n * Transforms a coordinate from source projection to destination projection.\n * This returns a new coordinate (and does not modify the original).\n *\n * See {@link module:ol/proj.transformExtent} for extent transformation.\n * See the transform method of {@link module:ol/geom/Geometry~Geometry} and its\n * subclasses for geometry transforms.\n *\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n * @param {ProjectionLike} source Source projection-like.\n * @param {ProjectionLike} destination Destination projection-like.\n * @return {import(\"./coordinate.js\").Coordinate} Coordinate.\n * @api\n */\nexport function transform(coordinate, source, destination) {\n  const transformFunc = getTransform(source, destination);\n  return transformFunc(coordinate, undefined, coordinate.length);\n}\n\n/**\n * Transforms an extent from source projection to destination projection.  This\n * returns a new extent (and does not modify the original).\n *\n * @param {import(\"./extent.js\").Extent} extent The extent to transform.\n * @param {ProjectionLike} source Source projection-like.\n * @param {ProjectionLike} destination Destination projection-like.\n * @param {number} [stops] Number of stops per side used for the transform.\n * By default only the corners are used.\n * @return {import(\"./extent.js\").Extent} The transformed extent.\n * @api\n */\nexport function transformExtent(extent, source, destination, stops) {\n  const transformFunc = getTransform(source, destination);\n  return applyTransform(extent, transformFunc, undefined, stops);\n}\n\n/**\n * Transforms the given point to the destination projection.\n *\n * @param {import(\"./coordinate.js\").Coordinate} point Point.\n * @param {Projection} sourceProjection Source projection.\n * @param {Projection} destinationProjection Destination projection.\n * @return {import(\"./coordinate.js\").Coordinate} Point.\n */\nexport function transformWithProjections(\n  point,\n  sourceProjection,\n  destinationProjection\n) {\n  const transformFunc = getTransformFromProjections(\n    sourceProjection,\n    destinationProjection\n  );\n  return transformFunc(point);\n}\n\n/**\n * @type {Projection|null}\n */\nlet userProjection = null;\n\n/**\n * Set the projection for coordinates supplied from and returned by API methods.\n * This includes all API methods except for those interacting with tile grids.\n * @param {ProjectionLike} projection The user projection.\n * @api\n */\nexport function setUserProjection(projection) {\n  userProjection = get(projection);\n}\n\n/**\n * Clear the user projection if set.\n * @api\n */\nexport function clearUserProjection() {\n  userProjection = null;\n}\n\n/**\n * Get the projection for coordinates supplied from and returned by API methods.\n * Note that this method is not yet a part of the stable API.  Support for user\n * projections is not yet complete and should be considered experimental.\n * @return {Projection|null} The user projection (or null if not set).\n * @api\n */\nexport function getUserProjection() {\n  return userProjection;\n}\n\n/**\n * Use geographic coordinates (WGS-84 datum) in API methods.  This includes all API\n * methods except for those interacting with tile grids.\n * @api\n */\nexport function useGeographic() {\n  setUserProjection('EPSG:4326');\n}\n\n/**\n * Return a coordinate transformed into the user projection.  If no user projection\n * is set, the original coordinate is returned.\n * @param {Array<number>} coordinate Input coordinate.\n * @param {ProjectionLike} sourceProjection The input coordinate projection.\n * @return {Array<number>} The input coordinate in the user projection.\n */\nexport function toUserCoordinate(coordinate, sourceProjection) {\n  if (!userProjection) {\n    return coordinate;\n  }\n  return transform(coordinate, sourceProjection, userProjection);\n}\n\n/**\n * Return a coordinate transformed from the user projection.  If no user projection\n * is set, the original coordinate is returned.\n * @param {Array<number>} coordinate Input coordinate.\n * @param {ProjectionLike} destProjection The destination projection.\n * @return {Array<number>} The input coordinate transformed.\n */\nexport function fromUserCoordinate(coordinate, destProjection) {\n  if (!userProjection) {\n    if (\n      showCoordinateWarning &&\n      !equals(coordinate, [0, 0]) &&\n      coordinate[0] >= -180 &&\n      coordinate[0] <= 180 &&\n      coordinate[1] >= -90 &&\n      coordinate[1] <= 90\n    ) {\n      showCoordinateWarning = false;\n      warn(\n        'Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates.'\n      );\n    }\n    return coordinate;\n  }\n  return transform(coordinate, userProjection, destProjection);\n}\n\n/**\n * Return an extent transformed into the user projection.  If no user projection\n * is set, the original extent is returned.\n * @param {import(\"./extent.js\").Extent} extent Input extent.\n * @param {ProjectionLike} sourceProjection The input extent projection.\n * @return {import(\"./extent.js\").Extent} The input extent in the user projection.\n */\nexport function toUserExtent(extent, sourceProjection) {\n  if (!userProjection) {\n    return extent;\n  }\n  return transformExtent(extent, sourceProjection, userProjection);\n}\n\n/**\n * Return an extent transformed from the user projection.  If no user projection\n * is set, the original extent is returned.\n * @param {import(\"./extent.js\").Extent} extent Input extent.\n * @param {ProjectionLike} destProjection The destination projection.\n * @return {import(\"./extent.js\").Extent} The input extent transformed.\n */\nexport function fromUserExtent(extent, destProjection) {\n  if (!userProjection) {\n    return extent;\n  }\n  return transformExtent(extent, userProjection, destProjection);\n}\n\n/**\n * Return the resolution in user projection units per pixel. If no user projection\n * is set, or source or user projection are missing units, the original resolution\n * is returned.\n * @param {number} resolution Resolution in input projection units per pixel.\n * @param {ProjectionLike} sourceProjection The input projection.\n * @return {number} Resolution in user projection units per pixel.\n */\nexport function toUserResolution(resolution, sourceProjection) {\n  if (!userProjection) {\n    return resolution;\n  }\n  const sourceUnits = get(sourceProjection).getUnits();\n  const userUnits = userProjection.getUnits();\n  return sourceUnits && userUnits\n    ? (resolution * METERS_PER_UNIT[sourceUnits]) / METERS_PER_UNIT[userUnits]\n    : resolution;\n}\n\n/**\n * Return the resolution in user projection units per pixel. If no user projection\n * is set, or source or user projection are missing units, the original resolution\n * is returned.\n * @param {number} resolution Resolution in user projection units per pixel.\n * @param {ProjectionLike} destProjection The destination projection.\n * @return {number} Resolution in destination projection units per pixel.\n */\nexport function fromUserResolution(resolution, destProjection) {\n  if (!userProjection) {\n    return resolution;\n  }\n  const sourceUnits = get(destProjection).getUnits();\n  const userUnits = userProjection.getUnits();\n  return sourceUnits && userUnits\n    ? (resolution * METERS_PER_UNIT[userUnits]) / METERS_PER_UNIT[sourceUnits]\n    : resolution;\n}\n\n/**\n * Creates a safe coordinate transform function from a coordinate transform function.\n * \"Safe\" means that it can handle wrapping of x-coordinates for global projections,\n * and that coordinates exceeding the source projection validity extent's range will be\n * clamped to the validity range.\n * @param {Projection} sourceProj Source projection.\n * @param {Projection} destProj Destination projection.\n * @param {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} transform Transform function (source to destiation).\n * @return {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} Safe transform function (source to destiation).\n */\nexport function createSafeCoordinateTransform(sourceProj, destProj, transform) {\n  return function (coord) {\n    let transformed, worldsAway;\n    if (sourceProj.canWrapX()) {\n      const sourceExtent = sourceProj.getExtent();\n      const sourceExtentWidth = getWidth(sourceExtent);\n      coord = coord.slice(0);\n      worldsAway = getWorldsAway(coord, sourceProj, sourceExtentWidth);\n      if (worldsAway) {\n        // Move x to the real world\n        coord[0] = coord[0] - worldsAway * sourceExtentWidth;\n      }\n      coord[0] = clamp(coord[0], sourceExtent[0], sourceExtent[2]);\n      coord[1] = clamp(coord[1], sourceExtent[1], sourceExtent[3]);\n      transformed = transform(coord);\n    } else {\n      transformed = transform(coord);\n    }\n    if (worldsAway && destProj.canWrapX()) {\n      // Move transformed coordinate back to the offset world\n      transformed[0] += worldsAway * getWidth(destProj.getExtent());\n    }\n    return transformed;\n  };\n}\n\n/**\n * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called\n * by when this module is executed and should only need to be called again after\n * `clearAllProjections()` is called (e.g. in tests).\n */\nexport function addCommon() {\n  // Add transformations that don't alter coordinates to convert within set of\n  // projections with equal meaning.\n  addEquivalentProjections(EPSG3857_PROJECTIONS);\n  addEquivalentProjections(EPSG4326_PROJECTIONS);\n  // Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like\n  // coordinates and back.\n  addEquivalentTransforms(\n    EPSG4326_PROJECTIONS,\n    EPSG3857_PROJECTIONS,\n    fromEPSG4326,\n    toEPSG4326\n  );\n}\n\naddCommon();\n","/**\n * @module ol/proj/Projection\n */\nimport {METERS_PER_UNIT} from './Units.js';\n\n/**\n * @typedef {Object} Options\n * @property {string} code The SRS identifier code, e.g. `EPSG:4326`.\n * @property {import(\"./Units.js\").Units} [units] Units. Required unless a\n * proj4 projection is defined for `code`.\n * @property {import(\"../extent.js\").Extent} [extent] The validity extent for the SRS.\n * @property {string} [axisOrientation='enu'] The axis orientation as specified in Proj4.\n * @property {boolean} [global=false] Whether the projection is valid for the whole globe.\n * @property {number} [metersPerUnit] The meters per unit for the SRS.\n * If not provided, the `units` are used to get the meters per unit from the {@link METERS_PER_UNIT}\n * lookup table.\n * @property {import(\"../extent.js\").Extent} [worldExtent] The world extent for the SRS.\n * @property {function(number, import(\"../coordinate.js\").Coordinate):number} [getPointResolution]\n * Function to determine resolution at a point. The function is called with a\n * `number` view resolution and a {@link module:ol/coordinate~Coordinate} as arguments, and returns\n * the `number` resolution in projection units at the passed coordinate. If this is `undefined`,\n * the default {@link module:ol/proj.getPointResolution} function will be used.\n */\n\n/**\n * @classdesc\n * Projection definition class. One of these is created for each projection\n * supported in the application and stored in the {@link module:ol/proj} namespace.\n * You can use these in applications, but this is not required, as API params\n * and options use {@link module:ol/proj~ProjectionLike} which means the simple string\n * code will suffice.\n *\n * You can use {@link module:ol/proj.get} to retrieve the object for a particular\n * projection.\n *\n * The library includes definitions for `EPSG:4326` and `EPSG:3857`, together\n * with the following aliases:\n * * `EPSG:4326`: CRS:84, urn:ogc:def:crs:EPSG:6.6:4326,\n *     urn:ogc:def:crs:OGC:1.3:CRS84, urn:ogc:def:crs:OGC:2:84,\n *     http://www.opengis.net/gml/srs/epsg.xml#4326,\n *     urn:x-ogc:def:crs:EPSG:4326\n * * `EPSG:3857`: EPSG:102100, EPSG:102113, EPSG:900913,\n *     urn:ogc:def:crs:EPSG:6.18:3:3857,\n *     http://www.opengis.net/gml/srs/epsg.xml#3857\n *\n * If you use [proj4js](https://github.com/proj4js/proj4js), aliases can\n * be added using `proj4.defs()`. After all required projection definitions are\n * added, call the {@link module:ol/proj/proj4.register} function.\n *\n * @api\n */\nclass Projection {\n  /**\n   * @param {Options} options Projection options.\n   */\n  constructor(options) {\n    /**\n     * @private\n     * @type {string}\n     */\n    this.code_ = options.code;\n\n    /**\n     * Units of projected coordinates. When set to `TILE_PIXELS`, a\n     * `this.extent_` and `this.worldExtent_` must be configured properly for each\n     * tile.\n     * @private\n     * @type {import(\"./Units.js\").Units}\n     */\n    this.units_ = /** @type {import(\"./Units.js\").Units} */ (options.units);\n\n    /**\n     * Validity extent of the projection in projected coordinates. For projections\n     * with `TILE_PIXELS` units, this is the extent of the tile in\n     * tile pixel space.\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.extent_ = options.extent !== undefined ? options.extent : null;\n\n    /**\n     * Extent of the world in EPSG:4326. For projections with\n     * `TILE_PIXELS` units, this is the extent of the tile in\n     * projected coordinate space.\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.worldExtent_ =\n      options.worldExtent !== undefined ? options.worldExtent : null;\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.axisOrientation_ =\n      options.axisOrientation !== undefined ? options.axisOrientation : 'enu';\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.global_ = options.global !== undefined ? options.global : false;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.canWrapX_ = !!(this.global_ && this.extent_);\n\n    /**\n     * @private\n     * @type {function(number, import(\"../coordinate.js\").Coordinate):number|undefined}\n     */\n    this.getPointResolutionFunc_ = options.getPointResolution;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.defaultTileGrid_ = null;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.metersPerUnit_ = options.metersPerUnit;\n  }\n\n  /**\n   * @return {boolean} The projection is suitable for wrapping the x-axis\n   */\n  canWrapX() {\n    return this.canWrapX_;\n  }\n\n  /**\n   * Get the code for this projection, e.g. 'EPSG:4326'.\n   * @return {string} Code.\n   * @api\n   */\n  getCode() {\n    return this.code_;\n  }\n\n  /**\n   * Get the validity extent for this projection.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   * @api\n   */\n  getExtent() {\n    return this.extent_;\n  }\n\n  /**\n   * Get the units of this projection.\n   * @return {import(\"./Units.js\").Units} Units.\n   * @api\n   */\n  getUnits() {\n    return this.units_;\n  }\n\n  /**\n   * Get the amount of meters per unit of this projection.  If the projection is\n   * not configured with `metersPerUnit` or a units identifier, the return is\n   * `undefined`.\n   * @return {number|undefined} Meters.\n   * @api\n   */\n  getMetersPerUnit() {\n    return this.metersPerUnit_ || METERS_PER_UNIT[this.units_];\n  }\n\n  /**\n   * Get the world extent for this projection.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   * @api\n   */\n  getWorldExtent() {\n    return this.worldExtent_;\n  }\n\n  /**\n   * Get the axis orientation of this projection.\n   * Example values are:\n   * enu - the default easting, northing, elevation.\n   * neu - northing, easting, up - useful for \"lat/long\" geographic coordinates,\n   *     or south orientated transverse mercator.\n   * wnu - westing, northing, up - some planetary coordinate systems have\n   *     \"west positive\" coordinate systems\n   * @return {string} Axis orientation.\n   * @api\n   */\n  getAxisOrientation() {\n    return this.axisOrientation_;\n  }\n\n  /**\n   * Is this projection a global projection which spans the whole world?\n   * @return {boolean} Whether the projection is global.\n   * @api\n   */\n  isGlobal() {\n    return this.global_;\n  }\n\n  /**\n   * Set if the projection is a global projection which spans the whole world\n   * @param {boolean} global Whether the projection is global.\n   * @api\n   */\n  setGlobal(global) {\n    this.global_ = global;\n    this.canWrapX_ = !!(global && this.extent_);\n  }\n\n  /**\n   * @return {import(\"../tilegrid/TileGrid.js\").default} The default tile grid.\n   */\n  getDefaultTileGrid() {\n    return this.defaultTileGrid_;\n  }\n\n  /**\n   * @param {import(\"../tilegrid/TileGrid.js\").default} tileGrid The default tile grid.\n   */\n  setDefaultTileGrid(tileGrid) {\n    this.defaultTileGrid_ = tileGrid;\n  }\n\n  /**\n   * Set the validity extent for this projection.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @api\n   */\n  setExtent(extent) {\n    this.extent_ = extent;\n    this.canWrapX_ = !!(this.global_ && extent);\n  }\n\n  /**\n   * Set the world extent for this projection.\n   * @param {import(\"../extent.js\").Extent} worldExtent World extent\n   *     [minlon, minlat, maxlon, maxlat].\n   * @api\n   */\n  setWorldExtent(worldExtent) {\n    this.worldExtent_ = worldExtent;\n  }\n\n  /**\n   * Set the getPointResolution function (see {@link module:ol/proj.getPointResolution}\n   * for this projection.\n   * @param {function(number, import(\"../coordinate.js\").Coordinate):number} func Function\n   * @api\n   */\n  setGetPointResolution(func) {\n    this.getPointResolutionFunc_ = func;\n  }\n\n  /**\n   * Get the custom point resolution function for this projection (if set).\n   * @return {function(number, import(\"../coordinate.js\").Coordinate):number|undefined} The custom point\n   * resolution function (if set).\n   */\n  getPointResolutionFunc() {\n    return this.getPointResolutionFunc_;\n  }\n}\n\nexport default Projection;\n","/**\n * @module ol/proj/Units\n */\n\n/**\n * @typedef {'radians' | 'degrees' | 'ft' | 'm' | 'pixels' | 'tile-pixels' | 'us-ft'} Units\n * Projection units.\n */\n\n/**\n * See http://duff.ess.washington.edu/data/raster/drg/docs/geotiff.txt\n * @type {Object<number, Units>}\n */\nconst unitByCode = {\n  '9001': 'm',\n  '9002': 'ft',\n  '9003': 'us-ft',\n  '9101': 'radians',\n  '9102': 'degrees',\n};\n\n/**\n * @param {number} code Unit code.\n * @return {Units} Units.\n */\nexport function fromCode(code) {\n  return unitByCode[code];\n}\n\n/**\n * @typedef {Object} MetersPerUnitLookup\n * @property {number} radians Radians\n * @property {number} degrees Degrees\n * @property {number} ft  Feet\n * @property {number} m Meters\n * @property {number} us-ft US feet\n */\n\n/**\n * Meters per unit lookup table.\n * @const\n * @type {MetersPerUnitLookup}\n * @api\n */\nexport const METERS_PER_UNIT = {\n  // use the radius of the Normal sphere\n  'radians': 6370997 / (2 * Math.PI),\n  'degrees': (2 * Math.PI * 6370997) / 360,\n  'ft': 0.3048,\n  'm': 1,\n  'us-ft': 1200 / 3937,\n};\n","/**\n * @module ol/proj/proj4\n */\nimport Projection from './Projection.js';\nimport {\n  addCoordinateTransforms,\n  addEquivalentProjections,\n  addProjection,\n  createSafeCoordinateTransform,\n  get,\n} from '../proj.js';\nimport {get as getTransform} from './transforms.js';\n\n/**\n * @type {import(\"proj4\")|null}\n */\nlet registered = null;\n\n/**\n * @return {boolean} Proj4 has been registered.\n */\nexport function isRegistered() {\n  return !!registered;\n}\n\n/**\n * Unsets the shared proj4 previsouly set with register.\n */\nexport function unregister() {\n  registered = null;\n}\n\n/**\n * Make projections defined in proj4 (with `proj4.defs()`) available in\n * OpenLayers. Requires proj4 >= 2.8.0.\n *\n * This function should be called whenever changes are made to the proj4\n * registry, e.g. after calling `proj4.defs()`. Existing transforms will not be\n * modified by this function.\n *\n * @param {import(\"proj4\")} proj4 Proj4.\n * @api\n */\nexport function register(proj4) {\n  registered = proj4;\n\n  const projCodes = Object.keys(proj4.defs);\n  const len = projCodes.length;\n  let i, j;\n  for (i = 0; i < len; ++i) {\n    const code = projCodes[i];\n    if (!get(code)) {\n      const def = proj4.defs(code);\n      let units = /** @type {import(\"./Units.js\").Units} */ (def.units);\n      if (!units && def.projName === 'longlat') {\n        units = 'degrees';\n      }\n      addProjection(\n        new Projection({\n          code: code,\n          axisOrientation: def.axis,\n          metersPerUnit: def.to_meter,\n          units,\n        })\n      );\n    }\n  }\n  for (i = 0; i < len; ++i) {\n    const code1 = projCodes[i];\n    const proj1 = get(code1);\n    for (j = 0; j < len; ++j) {\n      const code2 = projCodes[j];\n      const proj2 = get(code2);\n      if (!getTransform(code1, code2)) {\n        if (proj4.defs[code1] === proj4.defs[code2]) {\n          addEquivalentProjections([proj1, proj2]);\n        } else {\n          const transform = proj4(code1, code2);\n          addCoordinateTransforms(\n            proj1,\n            proj2,\n            createSafeCoordinateTransform(proj1, proj2, transform.forward),\n            createSafeCoordinateTransform(proj2, proj1, transform.inverse)\n          );\n        }\n      }\n    }\n  }\n}\n\n/**\n * @param {number} code The EPSG code.\n * @return {Promise<string>} The proj4 definition.\n */\nlet epsgLookup = async function (code) {\n  const response = await fetch(`https://epsg.io/${code}.proj4`);\n  if (!response.ok) {\n    throw new Error(`Unexpected response from epsg.io: ${response.status}`);\n  }\n  return response.text();\n};\n\n/**\n * Set the lookup function for getting proj4 definitions given an EPSG code.\n * By default, the {@link module:ol/proj/proj4.fromEPSGCode} function uses the\n * epsg.io website for proj4 definitions.  This can be changed by providing a\n * different lookup function.\n *\n * @param {function(number):Promise<string>} func The lookup function.\n * @api\n */\nexport function setEPSGLookup(func) {\n  epsgLookup = func;\n}\n\n/**\n * Get the current EPSG lookup function.\n *\n * @return {function(number):Promise<string>} The EPSG lookup function.\n */\nexport function getEPSGLookup() {\n  return epsgLookup;\n}\n\n/**\n * Get a projection from an EPSG code.  This function fetches the projection\n * definition from the epsg.io website, registers this definition for use with\n * proj4, and returns a configured projection.  You must call import proj4 and\n * call {@link module:ol/proj/proj4.register} before using this function.\n *\n * If the projection definition is already registered with proj4, it will not\n * be fetched again (so it is ok to call this function multiple times with the\n * same code).\n *\n * @param {number|string} code The EPSG code (e.g. 4326 or 'EPSG:4326').\n * @return {Promise<Projection>} The projection.\n * @api\n */\nexport async function fromEPSGCode(code) {\n  if (typeof code === 'string') {\n    code = parseInt(code.split(':').pop(), 10);\n  }\n\n  const proj4 = registered;\n  if (!proj4) {\n    throw new Error('Proj4 must be registered first with register(proj4)');\n  }\n\n  const epsgCode = 'EPSG:' + code;\n  if (proj4.defs(epsgCode)) {\n    return get(epsgCode);\n  }\n\n  proj4.defs(epsgCode, await epsgLookup(code));\n  register(proj4);\n\n  return get(epsgCode);\n}\n","/**\n * @module ol/proj/transforms\n */\nimport {isEmpty} from '../obj.js';\n\n/**\n * @private\n * @type {!Object<string, Object<string, import(\"../proj.js\").TransformFunction>>}\n */\nlet transforms = {};\n\n/**\n * Clear the transform cache.\n */\nexport function clear() {\n  transforms = {};\n}\n\n/**\n * Registers a conversion function to convert coordinates from the source\n * projection to the destination projection.\n *\n * @param {import(\"./Projection.js\").default} source Source.\n * @param {import(\"./Projection.js\").default} destination Destination.\n * @param {import(\"../proj.js\").TransformFunction} transformFn Transform.\n */\nexport function add(source, destination, transformFn) {\n  const sourceCode = source.getCode();\n  const destinationCode = destination.getCode();\n  if (!(sourceCode in transforms)) {\n    transforms[sourceCode] = {};\n  }\n  transforms[sourceCode][destinationCode] = transformFn;\n}\n\n/**\n * Unregisters the conversion function to convert coordinates from the source\n * projection to the destination projection.  This method is used to clean up\n * cached transforms during testing.\n *\n * @param {import(\"./Projection.js\").default} source Source projection.\n * @param {import(\"./Projection.js\").default} destination Destination projection.\n * @return {import(\"../proj.js\").TransformFunction} transformFn The unregistered transform.\n */\nexport function remove(source, destination) {\n  const sourceCode = source.getCode();\n  const destinationCode = destination.getCode();\n  const transform = transforms[sourceCode][destinationCode];\n  delete transforms[sourceCode][destinationCode];\n  if (isEmpty(transforms[sourceCode])) {\n    delete transforms[sourceCode];\n  }\n  return transform;\n}\n\n/**\n * Get a transform given a source code and a destination code.\n * @param {string} sourceCode The code for the source projection.\n * @param {string} destinationCode The code for the destination projection.\n * @return {import(\"../proj.js\").TransformFunction|undefined} The transform function (if found).\n */\nexport function get(sourceCode, destinationCode) {\n  let transform;\n  if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {\n    transform = transforms[sourceCode][destinationCode];\n  }\n  return transform;\n}\n"],"names":["NUM_100K_SETS","SET_ORIGIN_COLUMN_LETTERS","SET_ORIGIN_ROW_LETTERS","A","I","O","V","Z","forward","inverse","toPoint","ll","accuracy","encode","LLtoUTM","lat","lon","mgrs","bbox","UTMtoLL","decode","toUpperCase","left","bottom","right","top","degToRad","deg","Math","PI","radToDeg","rad","LongOrigin","eccPrimeSquared","N","T","C","M","LongOriginRad","ZoneNumber","Lat","Long","a","eccSquared","k0","LatRad","LongRad","floor","sqrt","sin","tan","cos","UTMEasting","UTMNorthing","northing","round","easting","zoneNumber","zoneLetter","getLetterDesignator","utm","N1","T1","C1","R1","D","mu","phi1Rad","e1","x","y","pow","result","topRight","LetterDesignator","seasting","snorthing","get100kID","substr","length","setParm","get100kSetForZone","setColumn","setRow","getLetter100kID","i","column","row","parm","index","colOrigin","charCodeAt","rowOrigin","colInt","rowInt","rollover","twoLetter","String","fromCharCode","mgrsString","testChar","hunK","sb","test","charAt","parseInt","substring","set","east100k","getEastingFromChar","north100k","getNorthingFromChar","getMinNorthing","remainder","accuracyBonus","sepEastingString","sepNorthingString","sep","sepEasting","sepNorthing","parseFloat","e","curCol","eastingValue","rewindMarker","n","curRow","northingValue","messages","AssertionError","Error","constructor","code","message","super","this","name","assert","assertion","errorCode","levels","info","warn","error","none","level","args","console","add","coordinate","delta","closestOnCircle","circle","r","getRadius","center","getCenter","x0","y0","x1","y1","dx","dy","d","closestOnSegment","segment","start","end","x2","y2","along","equals","coordinate1","coordinate2","rotate","angle","cosAngle","sinAngle","scale","squaredDistance","coord1","coord2","distance","squaredDistanceToSegment","wrapX","projection","canWrapX","worldWidth","getExtent","worldsAway","getWorldsAway","sourceExtentWidth","projectionExtent","boundingExtent","coordinates","extent","createEmpty","ii","extendCoordinate","_boundingExtentXYs","xs","ys","dest","minX","min","apply","minY","maxX","max","maxY","createOrUpdate","buffer","value","clone","slice","closestSquaredDistanceXY","containsCoordinate","containsXY","containsExtent","extent1","extent2","coordinateRelationship","relationship","Infinity","createOrUpdateEmpty","createOrUpdateFromCoordinate","createOrUpdateFromFlatCoordinates","flatCoordinates","offset","stride","extendFlatCoordinates","extend","extendXY","forEachCorner","callback","val","getBottomLeft","getBottomRight","getTopRight","getTopLeft","getArea","area","isEmpty","getWidth","getHeight","getCorner","corner","getForViewAndSize","resolution","rotation","size","x3","y3","getRotatedViewport","cosRotation","sinRotation","xCos","xSin","yCos","ySin","getIntersection","intersection","intersects","returnOrUpdate","intersectsSegment","startRel","endRel","startX","startY","endX","endY","slope","applyTransform","transformFn","stops","width","height","push","l","wrapAndSliceX","isFinite","UNKNOWN","INTERSECTING","ABOVE","RIGHT","BELOW","LEFT","clamp","squaredSegmentDistance","t","solveLinearSystem","mat","maxRow","maxEl","abs","absValue","tmp","j","coef","k","Array","m","toRadians","angleInDegrees","modulo","b","lerp","toFixed","decimals","factor","ceil","RADIUS","HALF_SIZE","EXTENT","WORLD_EXTENT","MAX_SAFE_Y","log","EPSG3857Projection","Projection","units","global","worldExtent","getPointResolution","point","cosh","PROJECTIONS","fromEPSG4326","input","output","dimension","undefined","toEPSG4326","atan","exp","METERS_PER_UNIT","EPSG4326Projection","axisOrientation","metersPerUnit","cache","clear","get","replace","DEFAULT_RADIUS","getDistance","c1","c2","radius","lat1","lat2","deltaLatBy2","deltaLonBy2","atan2","showCoordinateWarning","disableCoordinateWarning","disable","hide","cloneTransform","identityTransform","addProjection","getCode","addProjections","projections","forEach","projectionLike","pointResolution","getter","getPointResolutionFunc","getUnits","getMetersPerUnit","projUnits","getTransformFromProjections","vertices","addEquivalentProjections","source","destination","addEquivalentTransforms","projections1","projections2","forwardTransform","inverseTransform","projection1","projection2","clearAllProjections","createProjection","defaultCode","createTransformFromCoordinateTransform","coordTransform","pointLength","jj","addCoordinateTransforms","sourceProj","destProj","fromLonLat","transform","toLonLat","lonLat","equivalent","equalUnits","transformFunc","sourceProjection","destinationProjection","sourceCode","destinationCode","getTransform","transformExtent","transformWithProjections","userProjection","setUserProjection","clearUserProjection","getUserProjection","useGeographic","toUserCoordinate","fromUserCoordinate","destProjection","toUserExtent","fromUserExtent","toUserResolution","sourceUnits","userUnits","fromUserResolution","createSafeCoordinateTransform","coord","transformed","sourceExtent","addCommon","options","code_","units_","extent_","worldExtent_","axisOrientation_","global_","canWrapX_","getPointResolutionFunc_","defaultTileGrid_","metersPerUnit_","getWorldExtent","getAxisOrientation","isGlobal","setGlobal","getDefaultTileGrid","setDefaultTileGrid","tileGrid","setExtent","setWorldExtent","setGetPointResolution","func","unitByCode","fromCode","registered","register","proj4","projCodes","Object","keys","defs","len","def","projName","axis","to_meter","code1","proj1","code2","proj2","transforms"],"sourceRoot":""}
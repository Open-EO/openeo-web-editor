{"version":3,"sources":["webpack:///./node_modules/ol/tilegrid/common.js","webpack:///./node_modules/ol/tilegrid.js","webpack:///./node_modules/ol/tilecoord.js","webpack:///./node_modules/ol/tilegrid/WMTS.js","webpack:///./node_modules/ol/tilegrid/TileGrid.js","webpack:///./node_modules/ol/tileurlfunction.js","webpack:///./node_modules/ol/transform.js","webpack:///./node_modules/ol/uri.js"],"names":["DEFAULT_MAX_ZOOM","DEFAULT_TILE_SIZE","getForProjection","projection","tileGrid","getDefaultTileGrid","createForProjection","setDefaultTileGrid","wrapX","tileCoord","z","center","getTileCoordCenter","projectionExtent","extentFromProjection","worldWidth","worldsAway","Math","ceil","getTileCoordForCoordAndZ","createForExtent","extent","opt_maxZoom","opt_tileSize","opt_corner","corner","undefined","TOP_LEFT","resolutions","resolutionsFromExtent","origin","tileSize","createXYZ","opt_options","xyzOptions","getExtent","gridOptions","minZoom","maxZoom","maxResolution","opt_maxResolution","height","width","max","length","Array","pow","half","DEGREES","getMetersPerUnit","createOrUpdate","x","y","opt_tileCoord","getKeyZXY","getKey","fromKey","key","split","map","Number","hash","withinExtentAndZ","getMinZoom","getMaxZoom","tileRange","getFullTileRange","containsXY","__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","p","prototype","hasOwnProperty","call","TypeError","String","__","this","constructor","create","WMTSTileGrid","_super","options","_this","origins","tileSizes","sizes","matrixIds_","matrixIds","getMatrixId","getMatrixIds","createFromCapabilitiesMatrixSet","matrixSet","opt_extent","opt_matrixLimits","matrixLimits","supportedCRSPropName","matrixIdsPropName","identifierPropName","scaleDenominatorPropName","topLeftCornerPropName","tileWidthPropName","tileHeightPropName","code","metersPerUnit","switchOriginXY","getAxisOrientation","substr","sort","a","forEach","elt","matrixAvailable","elt_ml","indexOf","push","resolution","tileWidth","tileHeight","tmpTileCoord","DECIMALS","TileGrid","zoomFactor","resolutions_","i","ii","zoomFactor_","origin_","origins_","tileSizes_","tileSize_","extent_","fullTileRanges_","tmpSize_","tmpExtent_","size","min","restrictedTileRange","getTileRangeForExtentAndZ","minX","maxX","minY","maxY","calculateTileRanges_","forEachTileCoord","zoom","callback","j","jj","forEachTileCoordParentTileRange","opt_tileRange","tileCoordExtent","getTileCoordExtent","floor","getOrigin","getResolution","getResolutions","getTileCoordChildTileRange","getTileRangeForTileCoordAndZ","tileCoordZ","tileCoordX","tileCoordY","factor","getTileRangeExtent","getTileSize","getTileCoordForXYAndZ_","getTileCoordForCoordAndResolution","coordinate","getTileCoordForXYAndResolution_","reverseIntersectionPolicy","getZForResolution","scale","getTileCoordResolution","opt_direction","fullTileRanges","createFromTemplate","template","zRegEx","xRegEx","yRegEx","dashYRegEx","pixelRatio","replace","toString","range","getHeight","createFromTemplates","templates","len","tileUrlFunctions","createFromTileUrlFunctions","h","index","expandUrl","url","urls","match","exec","startCharCode","charCodeAt","stopCharCode","charCode","fromCharCode","stop_1","parseInt","transformStringDiv","tmp_","reset","transform","set","multiply","transform1","transform2","a1","b1","c1","d1","e1","f1","a2","b2","c2","d2","e2","f2","c","e","f","setFromArray","apply","rotate","angle","cos","sin","makeScale","target","translate","dx","dy","compose","dx1","dy1","sx","sy","dx2","dy2","makeInverse","source","det","determinant","mat","transformString","join","node","document","createElement","style","appendParams","uri","params","keyParams","keys","k","encodeURIComponent","qs"],"mappings":"kHAAA,oEAOO,IAAIA,EAAmB,GAKnBC,EAAoB,K,oCCZ/B,gOAeO,SAASC,EAAiBC,GAC7B,IAAIC,EAAWD,EAAWE,qBAK1B,OAJKD,IACDA,EAAWE,EAAoBH,GAC/BA,EAAWI,mBAAmBH,IAE3BA,EAQJ,SAASI,EAAMJ,EAAUK,EAAWN,GACvC,IAAIO,EAAID,EAAU,GACdE,EAASP,EAASQ,mBAAmBH,GACrCI,EAAmBC,EAAqBX,GAC5C,GAAK,eAAmBU,EAAkBF,GAOtC,OAAOF,EANP,IAAIM,EAAa,eAASF,GACtBG,EAAaC,KAAKC,MAAML,EAAiB,GAAKF,EAAO,IAAMI,GAE/D,OADAJ,EAAO,IAAMI,EAAaC,EACnBZ,EAASe,yBAAyBR,EAAQD,GAelD,SAASU,EAAgBC,EAAQC,EAAaC,EAAcC,GAC/D,IAAIC,OAAwBC,IAAfF,EAA2BA,EAAa,OAAOG,SACxDC,EAAcC,EAAsBR,EAAQC,EAAaC,GAC7D,OAAO,IAAI,OAAS,CAChBF,OAAQA,EACRS,OAAQ,eAAUT,EAAQI,GAC1BG,YAAaA,EACbG,SAAUR,IAoBX,SAASS,EAAUC,GACtB,IAAIC,EAAaD,GAAe,GAC5BZ,EAASa,EAAWb,QAAU,eAAc,aAAac,YACzDC,EAAc,CACdf,OAAQA,EACRgB,QAASH,EAAWG,QACpBN,SAAUG,EAAWH,SACrBH,YAAaC,EAAsBR,EAAQa,EAAWI,QAASJ,EAAWH,SAAUG,EAAWK,gBAEnG,OAAO,IAAI,OAASH,GAYxB,SAASP,EAAsBR,EAAQC,EAAaC,EAAciB,GAU9D,IATA,IAAIF,OAA0BZ,IAAhBJ,EAA4BA,EAAc,OACpDmB,EAAS,eAAUpB,GACnBqB,EAAQ,eAASrB,GACjBU,EAAW,oBAAwBL,IAAjBH,EAA6BA,EAAe,QAC9DgB,EAAgBC,EAAoB,EAClCA,EACAvB,KAAK0B,IAAID,EAAQX,EAAS,GAAIU,EAASV,EAAS,IAClDa,EAASN,EAAU,EACnBV,EAAc,IAAIiB,MAAMD,GACnBlC,EAAI,EAAGA,EAAIkC,IAAUlC,EAC1BkB,EAAYlB,GAAK6B,EAAgBtB,KAAK6B,IAAI,EAAGpC,GAEjD,OAAOkB,EAWJ,SAAStB,EAAoBH,EAAYmB,EAAaC,EAAcC,GACvE,IAAIH,EAASP,EAAqBX,GAClC,OAAOiB,EAAgBC,EAAQC,EAAaC,EAAcC,GAQvD,SAASV,EAAqBX,GACjCA,EAAa,eAAcA,GAC3B,IAAIkB,EAASlB,EAAWgC,YACxB,IAAKd,EAAQ,CACT,IAAI0B,EAAQ,IAAM,OAAgB,OAAMC,SAAY7C,EAAW8C,mBAC/D5B,EAAS,gBAAgB0B,GAAOA,EAAMA,EAAMA,GAEhD,OAAO1B,I,oCC7HJ,SAAS6B,EAAexC,EAAGyC,EAAGC,EAAGC,GACpC,YAAsB3B,IAAlB2B,GACAA,EAAc,GAAK3C,EACnB2C,EAAc,GAAKF,EACnBE,EAAc,GAAKD,EACZC,GAGA,CAAC3C,EAAGyC,EAAGC,GASf,SAASE,EAAU5C,EAAGyC,EAAGC,GAC5B,OAAO1C,EAAI,IAAMyC,EAAI,IAAMC,EAOxB,SAASG,EAAO9C,GACnB,OAAO6C,EAAU7C,EAAU,GAAIA,EAAU,GAAIA,EAAU,IAmBpD,SAAS+C,EAAQC,GACpB,OAAOA,EAAIC,MAAM,KAAKC,IAAIC,QAMvB,SAASC,EAAKpD,GACjB,OAAQA,EAAU,IAAMA,EAAU,IAAMA,EAAU,GAO/C,SAASqD,EAAiBrD,EAAWL,GACxC,IAAIM,EAAID,EAAU,GACd0C,EAAI1C,EAAU,GACd2C,EAAI3C,EAAU,GAClB,GAAIL,EAAS2D,aAAerD,GAAKA,EAAIN,EAAS4D,aAC1C,OAAO,EAEX,IAAIC,EAAY7D,EAAS8D,iBAAiBxD,GAC1C,OAAKuD,GAIMA,EAAUE,WAAWhB,EAAGC,GAxFvC,6M,oCCAA,0EAGIgB,EAAwC,WACxC,IAAIC,EAAgB,SAAUC,EAAGC,GAI7B,OAHAF,EAAgBG,OAAOC,gBAClB,CAAEC,UAAW,cAAgB7B,OAAS,SAAUyB,EAAGC,GAAKD,EAAEI,UAAYH,IACvE,SAAUD,EAAGC,GAAK,IAAK,IAAII,KAAKJ,EAAOC,OAAOI,UAAUC,eAAeC,KAAKP,EAAGI,KAAIL,EAAEK,GAAKJ,EAAEI,KACzFN,EAAcC,EAAGC,IAE5B,OAAO,SAAUD,EAAGC,GAChB,GAAiB,oBAANA,GAA0B,OAANA,EAC3B,MAAM,IAAIQ,UAAU,uBAAyBC,OAAOT,GAAK,iCAE7D,SAASU,IAAOC,KAAKC,YAAcb,EADnCD,EAAcC,EAAGC,GAEjBD,EAAEM,UAAkB,OAANL,EAAaC,OAAOY,OAAOb,IAAMU,EAAGL,UAAYL,EAAEK,UAAW,IAAIK,IAZ3C,GAsDxCI,EAA8B,SAAUC,GAKxC,SAASD,EAAaE,GAClB,IAAIC,EAAQF,EAAOR,KAAKI,KAAM,CAC1B7D,OAAQkE,EAAQlE,OAChBS,OAAQyD,EAAQzD,OAChB2D,QAASF,EAAQE,QACjB7D,YAAa2D,EAAQ3D,YACrBG,SAAUwD,EAAQxD,SAClB2D,UAAWH,EAAQG,UACnBC,MAAOJ,EAAQI,SACbT,KAMN,OADAM,EAAMI,WAAaL,EAAQM,UACpBL,EAiBX,OApCApB,EAAUiB,EAAcC,GAyBxBD,EAAaT,UAAUkB,YAAc,SAAUpF,GAC3C,OAAOwE,KAAKU,WAAWlF,IAO3B2E,EAAaT,UAAUmB,aAAe,WAClC,OAAOb,KAAKU,YAETP,EArCsB,CAsC/B,QAcK,SAASW,EAAgCC,EAAWC,EAAYC,GAEnE,IAAIvE,EAAc,GAEdiE,EAAY,GAEZJ,EAAU,GAEVC,EAAY,GAEZC,EAAQ,GACRS,OAAoC1E,IAArByE,EAAiCA,EAAmB,GACnEE,EAAuB,eACvBC,EAAoB,aACpBC,EAAqB,aACrBC,EAA2B,mBAC3BC,EAAwB,gBACxBC,EAAoB,YACpBC,EAAqB,aACrBC,EAAOX,EAAUI,GACjBlG,EAAa,eAAcyG,GAC3BC,EAAgB1G,EAAW8C,mBAE3B6D,EAAiE,MAAhD3G,EAAW4G,qBAAqBC,OAAO,EAAG,GA4C/D,OA3CAf,EAAUK,GAAmBW,MAAK,SAAUC,EAAG3C,GAC3C,OAAOA,EAAEiC,GAA4BU,EAAEV,MAE3CP,EAAUK,GAAmBa,SAAQ,SAAUC,GAC3C,IAAIC,EAoBJ,GAhBIA,IADAjB,EAAaxD,OAAS,IACJ,eAAKwD,GAAc,SAAUkB,GAC3C,OAAIF,EAAIb,IAAuBe,EAAOhB,KAKQ,IAA1Cc,EAAIb,GAAoBgB,QAAQ,MACxBtB,EAAUM,GAAsB,IAAMa,EAAIb,KAC9Ce,EAAOhB,MAQnBe,EAAiB,CACjBxB,EAAU2B,KAAKJ,EAAIb,IACnB,IAAIkB,EAA8C,MAAhCL,EAAIZ,GAAuCK,EACzDa,EAAYN,EAAIV,GAChBiB,EAAaP,EAAIT,GACjBG,EACArB,EAAQ+B,KAAK,CACTJ,EAAIX,GAAuB,GAC3BW,EAAIX,GAAuB,KAI/BhB,EAAQ+B,KAAKJ,EAAIX,IAErB7E,EAAY4F,KAAKC,GACjB/B,EAAU8B,KAAKE,GAAaC,EAAaD,EAAY,CAACA,EAAWC,IACjEhC,EAAM6B,KAAK,CAACJ,EAAI,eAAgBA,EAAI,sBAGrC,IAAI/B,EAAa,CACpBhE,OAAQ6E,EACRT,QAASA,EACT7D,YAAaA,EACbiE,UAAWA,EACXH,UAAWA,EACXC,MAAOA,M,oCCtLf,oGAeIiC,EAAe,CAAC,EAAG,EAAG,GAKtBC,EAAW,EAqCXC,EAA0B,WAI1B,SAASA,EAASvC,GAed,IAAIwC,EACJ,GAXA7C,KAAK7C,aAA8BX,IAApB6D,EAAQlD,QAAwBkD,EAAQlD,QAAU,EAKjE6C,KAAK8C,aAAezC,EAAQ3D,YAC5B,eAAO,eAASsD,KAAK8C,cAAc,SAAUd,EAAG3C,GAC5C,OAAOA,EAAI2C,KACZ,GAAO,KAGL3B,EAAQE,QACT,IAAK,IAAIwC,EAAI,EAAGC,EAAKhD,KAAK8C,aAAapF,OAAS,EAAGqF,EAAIC,IAAMD,EACzD,GAAKF,GAID,GAAI7C,KAAK8C,aAAaC,GAAK/C,KAAK8C,aAAaC,EAAI,KAAOF,EAAY,CAChEA,OAAarG,EACb,YALJqG,EAAa7C,KAAK8C,aAAaC,GAAK/C,KAAK8C,aAAaC,EAAI,GActE/C,KAAKiD,YAAcJ,EAKnB7C,KAAK5C,QAAU4C,KAAK8C,aAAapF,OAAS,EAK1CsC,KAAKkD,aAA6B1G,IAAnB6D,EAAQzD,OAAuByD,EAAQzD,OAAS,KAK/DoD,KAAKmD,SAAW,UACQ3G,IAApB6D,EAAQE,UACRP,KAAKmD,SAAW9C,EAAQE,QACxB,eAAOP,KAAKmD,SAASzF,QAAUsC,KAAK8C,aAAapF,OAAQ,KAE7D,IAAIvB,EAASkE,EAAQlE,YACNK,IAAXL,GAAyB6D,KAAKkD,SAAYlD,KAAKmD,WAC/CnD,KAAKkD,QAAU,eAAW/G,IAE9B,gBAAS6D,KAAKkD,SAAWlD,KAAKmD,UAAcnD,KAAKkD,UAAYlD,KAAKmD,SAAW,IAK7EnD,KAAKoD,WAAa,UACQ5G,IAAtB6D,EAAQG,YACRR,KAAKoD,WAAa/C,EAAQG,UAC1B,eAAOR,KAAKoD,WAAW1F,QAAUsC,KAAK8C,aAAapF,OAAQ,KAM/DsC,KAAKqD,eACoB7G,IAArB6D,EAAQxD,SACFwD,EAAQxD,SACPmD,KAAKoD,WAEF,KADA,OAEd,gBAASpD,KAAKqD,WAAarD,KAAKoD,YAC3BpD,KAAKqD,YAAcrD,KAAKoD,WAAa,IAK1CpD,KAAKsD,aAAqB9G,IAAXL,EAAuBA,EAAS,KAK/C6D,KAAKuD,gBAAkB,KAKvBvD,KAAKwD,SAAW,CAAC,EAAG,GAKpBxD,KAAKyD,WAAa,CAAC,EAAG,EAAG,EAAG,QACNjH,IAAlB6D,EAAQI,MACRT,KAAKuD,gBAAkBlD,EAAQI,MAAMhC,KAAI,SAAUiF,EAAMlI,GACrD,IAAIuD,EAAY,IAAI,OAAUhD,KAAK4H,IAAI,EAAGD,EAAK,IAAK3H,KAAK0B,IAAIiG,EAAK,GAAK,GAAI,GAAI3H,KAAK4H,IAAI,EAAGD,EAAK,IAAK3H,KAAK0B,IAAIiG,EAAK,GAAK,GAAI,IAC5H,GAAIvH,EAAQ,CACR,IAAIyH,EAAsB5D,KAAK6D,0BAA0B1H,EAAQX,GACjEuD,EAAU+E,KAAO/H,KAAK0B,IAAImG,EAAoBE,KAAM/E,EAAU+E,MAC9D/E,EAAUgF,KAAOhI,KAAK4H,IAAIC,EAAoBG,KAAMhF,EAAUgF,MAC9DhF,EAAUiF,KAAOjI,KAAK0B,IAAImG,EAAoBI,KAAMjF,EAAUiF,MAC9DjF,EAAUkF,KAAOlI,KAAK4H,IAAIC,EAAoBK,KAAMlF,EAAUkF,MAElE,OAAOlF,IACRiB,MAEE7D,GACL6D,KAAKkE,qBAAqB/H,GAuXlC,OA5WAyG,EAASlD,UAAUyE,iBAAmB,SAAUhI,EAAQiI,EAAMC,GAE1D,IADA,IAAItF,EAAYiB,KAAK6D,0BAA0B1H,EAAQiI,GAC9CrB,EAAIhE,EAAU+E,KAAMd,EAAKjE,EAAUgF,KAAMhB,GAAKC,IAAMD,EACzD,IAAK,IAAIuB,EAAIvF,EAAUiF,KAAMO,EAAKxF,EAAUkF,KAAMK,GAAKC,IAAMD,EACzDD,EAAS,CAACD,EAAMrB,EAAGuB,KAW/B1B,EAASlD,UAAU8E,gCAAkC,SAAUjJ,EAAW8I,EAAUI,EAAezD,GAC/F,IAAIjC,EAAWd,EAAGC,EACdwG,EAAkB,KAClBlJ,EAAID,EAAU,GAAK,EACE,IAArByE,KAAKiD,aACLhF,EAAI1C,EAAU,GACd2C,EAAI3C,EAAU,IAGdmJ,EAAkB1E,KAAK2E,mBAAmBpJ,EAAWyF,GAEzD,MAAOxF,GAAKwE,KAAK7C,QAAS,CAStB,GARyB,IAArB6C,KAAKiD,aACLhF,EAAIlC,KAAK6I,MAAM3G,EAAI,GACnBC,EAAInC,KAAK6I,MAAM1G,EAAI,GACnBa,EAAY,eAAwBd,EAAGA,EAAGC,EAAGA,EAAGuG,IAGhD1F,EAAYiB,KAAK6D,0BAA0Ba,EAAiBlJ,EAAGiJ,GAE/DJ,EAAS7I,EAAGuD,GACZ,OAAO,IAETvD,EAEN,OAAO,GAOXoH,EAASlD,UAAUzC,UAAY,WAC3B,OAAO+C,KAAKsD,SAOhBV,EAASlD,UAAUZ,WAAa,WAC5B,OAAOkB,KAAK5C,SAOhBwF,EAASlD,UAAUb,WAAa,WAC5B,OAAOmB,KAAK7C,SAQhByF,EAASlD,UAAUmF,UAAY,SAAUrJ,GACrC,OAAIwE,KAAKkD,QACElD,KAAKkD,QAGLlD,KAAKmD,SAAS3H,IAS7BoH,EAASlD,UAAUoF,cAAgB,SAAUtJ,GACzC,OAAOwE,KAAK8C,aAAatH,IAO7BoH,EAASlD,UAAUqF,eAAiB,WAChC,OAAO/E,KAAK8C,cAQhBF,EAASlD,UAAUsF,2BAA6B,SAAUzJ,EAAWkJ,EAAezD,GAChF,GAAIzF,EAAU,GAAKyE,KAAK5C,QAAS,CAC7B,GAAyB,IAArB4C,KAAKiD,YAAmB,CACxB,IAAIa,EAAsB,EAAfvI,EAAU,GACjByI,EAAsB,EAAfzI,EAAU,GACrB,OAAO,eAAwBuI,EAAMA,EAAO,EAAGE,EAAMA,EAAO,EAAGS,GAEnE,IAAIC,EAAkB1E,KAAK2E,mBAAmBpJ,EAAWyF,GAAchB,KAAKyD,YAC5E,OAAOzD,KAAK6D,0BAA0Ba,EAAiBnJ,EAAU,GAAK,EAAGkJ,GAE7E,OAAO,MAQX7B,EAASlD,UAAUuF,6BAA+B,SAAU1J,EAAWC,EAAGiJ,GACtE,GAAIjJ,EAAIwE,KAAK5C,SAAW5B,EAAIwE,KAAK7C,QAC7B,OAAO,KAEX,IAAI+H,EAAa3J,EAAU,GACvB4J,EAAa5J,EAAU,GACvB6J,EAAa7J,EAAU,GAC3B,GAAIC,IAAM0J,EACN,OAAO,eAAwBC,EAAYC,EAAYD,EAAYC,EAAYX,GAEnF,GAAIzE,KAAKiD,YAAa,CAClB,IAAIoC,EAAStJ,KAAK6B,IAAIoC,KAAKiD,YAAazH,EAAI0J,GACxCpB,EAAO/H,KAAK6I,MAAMO,EAAaE,GAC/BrB,EAAOjI,KAAK6I,MAAMQ,EAAaC,GACnC,GAAI7J,EAAI0J,EACJ,OAAO,eAAwBpB,EAAMA,EAAME,EAAMA,EAAMS,GAE3D,IAAIV,EAAOhI,KAAK6I,MAAMS,GAAUF,EAAa,IAAM,EAC/ClB,EAAOlI,KAAK6I,MAAMS,GAAUD,EAAa,IAAM,EACnD,OAAO,eAAwBtB,EAAMC,EAAMC,EAAMC,EAAMQ,GAE3D,IAAIC,EAAkB1E,KAAK2E,mBAAmBpJ,EAAWyE,KAAKyD,YAC9D,OAAOzD,KAAK6D,0BAA0Ba,EAAiBlJ,EAAGiJ,IAS9D7B,EAASlD,UAAU4F,mBAAqB,SAAU9J,EAAGuD,EAAWiC,GAC5D,IAAIpE,EAASoD,KAAK6E,UAAUrJ,GACxB+G,EAAavC,KAAK8E,cAActJ,GAChCqB,EAAW,eAAOmD,KAAKuF,YAAY/J,GAAIwE,KAAKwD,UAC5CM,EAAOlH,EAAO,GAAKmC,EAAU+E,KAAOjH,EAAS,GAAK0F,EAClDwB,EAAOnH,EAAO,IAAMmC,EAAUgF,KAAO,GAAKlH,EAAS,GAAK0F,EACxDyB,EAAOpH,EAAO,GAAKmC,EAAUiF,KAAOnH,EAAS,GAAK0F,EAClD0B,EAAOrH,EAAO,IAAMmC,EAAUkF,KAAO,GAAKpH,EAAS,GAAK0F,EAC5D,OAAO,eAAeuB,EAAME,EAAMD,EAAME,EAAMjD,IASlD4B,EAASlD,UAAUmE,0BAA4B,SAAU1H,EAAQX,EAAGiJ,GAChE,IAAIlJ,EAAYmH,EAChB1C,KAAKwF,uBAAuBrJ,EAAO,GAAIA,EAAO,GAAIX,GAAG,EAAOD,GAC5D,IAAIuI,EAAOvI,EAAU,GACjByI,EAAOzI,EAAU,GAErB,OADAyE,KAAKwF,uBAAuBrJ,EAAO,GAAIA,EAAO,GAAIX,GAAG,EAAMD,GACpD,eAAwBuI,EAAMvI,EAAU,GAAIyI,EAAMzI,EAAU,GAAIkJ,IAM3E7B,EAASlD,UAAUhE,mBAAqB,SAAUH,GAC9C,IAAIqB,EAASoD,KAAK6E,UAAUtJ,EAAU,IAClCgH,EAAavC,KAAK8E,cAAcvJ,EAAU,IAC1CsB,EAAW,eAAOmD,KAAKuF,YAAYhK,EAAU,IAAKyE,KAAKwD,UAC3D,MAAO,CACH5G,EAAO,IAAMrB,EAAU,GAAK,IAAOsB,EAAS,GAAK0F,EACjD3F,EAAO,IAAMrB,EAAU,GAAK,IAAOsB,EAAS,GAAK0F,IAWzDK,EAASlD,UAAUiF,mBAAqB,SAAUpJ,EAAWyF,GACzD,IAAIpE,EAASoD,KAAK6E,UAAUtJ,EAAU,IAClCgH,EAAavC,KAAK8E,cAAcvJ,EAAU,IAC1CsB,EAAW,eAAOmD,KAAKuF,YAAYhK,EAAU,IAAKyE,KAAKwD,UACvDM,EAAOlH,EAAO,GAAKrB,EAAU,GAAKsB,EAAS,GAAK0F,EAChDyB,EAAOpH,EAAO,IAAMrB,EAAU,GAAK,GAAKsB,EAAS,GAAK0F,EACtDwB,EAAOD,EAAOjH,EAAS,GAAK0F,EAC5B0B,EAAOD,EAAOnH,EAAS,GAAK0F,EAChC,OAAO,eAAeuB,EAAME,EAAMD,EAAME,EAAMjD,IAalD4B,EAASlD,UAAU+F,kCAAoC,SAAUC,EAAYnD,EAAYpE,GACrF,OAAO6B,KAAK2F,gCAAgCD,EAAW,GAAIA,EAAW,GAAInD,GAAY,EAAOpE,IAejGyE,EAASlD,UAAUiG,gCAAkC,SAAU1H,EAAGC,EAAGqE,EAAYqD,EAA2BzH,GACxG,IAAI3C,EAAIwE,KAAK6F,kBAAkBtD,GAC3BuD,EAAQvD,EAAavC,KAAK8E,cAActJ,GACxCoB,EAASoD,KAAK6E,UAAUrJ,GACxBqB,EAAW,eAAOmD,KAAKuF,YAAY/J,GAAIwE,KAAKwD,UAC5C2B,EAAcW,GAAS7H,EAAIrB,EAAO,IAAO2F,EAAa1F,EAAS,GAC/DuI,EAAcU,GAASlJ,EAAO,GAAKsB,GAAMqE,EAAa1F,EAAS,GASnE,OARI+I,GACAT,EAAa,eAAKA,EAAYxC,GAAY,EAC1CyC,EAAa,eAAKA,EAAYzC,GAAY,IAG1CwC,EAAa,eAAMA,EAAYxC,GAC/ByC,EAAa,eAAMA,EAAYzC,IAE5B,eAAwBnH,EAAG2J,EAAYC,EAAYjH,IAiB9DyE,EAASlD,UAAU8F,uBAAyB,SAAUvH,EAAGC,EAAG1C,EAAGoK,EAA2BzH,GACtF,IAAIvB,EAASoD,KAAK6E,UAAUrJ,GACxB+G,EAAavC,KAAK8E,cAActJ,GAChCqB,EAAW,eAAOmD,KAAKuF,YAAY/J,GAAIwE,KAAKwD,UAC5C2B,GAAclH,EAAIrB,EAAO,IAAM2F,EAAa1F,EAAS,GACrDuI,GAAcxI,EAAO,GAAKsB,GAAKqE,EAAa1F,EAAS,GASzD,OARI+I,GACAT,EAAa,eAAKA,EAAYxC,GAAY,EAC1CyC,EAAa,eAAKA,EAAYzC,GAAY,IAG1CwC,EAAa,eAAMA,EAAYxC,GAC/ByC,EAAa,eAAMA,EAAYzC,IAE5B,eAAwBnH,EAAG2J,EAAYC,EAAYjH,IAU9DyE,EAASlD,UAAUzD,yBAA2B,SAAUyJ,EAAYlK,EAAG2C,GACnE,OAAO6B,KAAKwF,uBAAuBE,EAAW,GAAIA,EAAW,GAAIlK,GAAG,EAAO2C,IAM/EyE,EAASlD,UAAUqG,uBAAyB,SAAUxK,GAClD,OAAOyE,KAAK8C,aAAavH,EAAU,KAUvCqH,EAASlD,UAAU6F,YAAc,SAAU/J,GACvC,OAAIwE,KAAKqD,UACErD,KAAKqD,UAGLrD,KAAKoD,WAAW5H,IAO/BoH,EAASlD,UAAUV,iBAAmB,SAAUxD,GAC5C,OAAKwE,KAAKuD,gBAMCvD,KAAKuD,gBAAgB/H,GALrBwE,KAAKsD,QACNtD,KAAK6D,0BAA0B7D,KAAKsD,QAAS9H,GAC7C,MAuBdoH,EAASlD,UAAUmG,kBAAoB,SAAUtD,EAAYyD,GACzD,IAAIxK,EAAI,eAAkBwE,KAAK8C,aAAcP,EAAYyD,GAAiB,GAC1E,OAAO,eAAMxK,EAAGwE,KAAK7C,QAAS6C,KAAK5C,UAMvCwF,EAASlD,UAAUwE,qBAAuB,SAAU/H,GAGhD,IAFA,IAAIuB,EAASsC,KAAK8C,aAAapF,OAC3BuI,EAAiB,IAAItI,MAAMD,GACtBlC,EAAIwE,KAAK7C,QAAS3B,EAAIkC,IAAUlC,EACrCyK,EAAezK,GAAKwE,KAAK6D,0BAA0B1H,EAAQX,GAE/DwE,KAAKuD,gBAAkB0C,GAEpBrD,EA5ekB,GA8ed,U,oCCviBf,8IAWO,SAASsD,EAAmBC,EAAUjL,GACzC,IAAIkL,EAAS,SACTC,EAAS,SACTC,EAAS,SACTC,EAAa,UACjB,OAAO,SAOGhL,EAAWiL,EAAYvL,GAC7B,OAAKM,EAIM4K,EACFM,QAAQL,EAAQ7K,EAAU,GAAGmL,YAC7BD,QAAQJ,EAAQ9K,EAAU,GAAGmL,YAC7BD,QAAQH,EAAQ/K,EAAU,GAAGmL,YAC7BD,QAAQF,GAAY,WACrB,IAAI/K,EAAID,EAAU,GACdoL,EAAQzL,EAAS8D,iBAAiBxD,GACtC,eAAOmL,EAAO,IACd,IAAIzI,EAAIyI,EAAMC,YAAcrL,EAAU,GAAK,EAC3C,OAAO2C,EAAEwI,mBAZb,GAsBL,SAASG,EAAoBC,EAAW5L,GAG3C,IAFA,IAAI6L,EAAMD,EAAUpJ,OAChBsJ,EAAmB,IAAIrJ,MAAMoJ,GACxBhE,EAAI,EAAGA,EAAIgE,IAAOhE,EACvBiE,EAAiBjE,GAAKmD,EAAmBY,EAAU/D,GAAI7H,GAE3D,OAAO+L,EAA2BD,GAM/B,SAASC,EAA2BD,GACvC,OAAgC,IAA5BA,EAAiBtJ,OACVsJ,EAAiB,GAErB,SAOGzL,EAAWiL,EAAYvL,GAC7B,GAAKM,EAGA,CACD,IAAI2L,EAAI,eAAc3L,GAClB4L,EAAQ,eAAOD,EAAGF,EAAiBtJ,QACvC,OAAOsJ,EAAiBG,GAAO5L,EAAWiL,EAAYvL,KAiB3D,SAASmM,EAAUC,GACtB,IAAIC,EAAO,GACPC,EAAQ,sBAAsBC,KAAKH,GACvC,GAAIE,EAAO,CAEP,IAAIE,EAAgBF,EAAM,GAAGG,WAAW,GACpCC,EAAeJ,EAAM,GAAGG,WAAW,GACnCE,OAAW,EACf,IAAKA,EAAWH,EAAeG,GAAYD,IAAgBC,EACvDN,EAAKhF,KAAK+E,EAAIZ,QAAQc,EAAM,GAAIzH,OAAO+H,aAAaD,KAExD,OAAON,EAGX,GADAC,EAAQ,kBAAkBC,KAAKH,GAC3BE,EAAO,CAGP,IADA,IAAIO,EAASC,SAASR,EAAM,GAAI,IACvBxE,EAAIgF,SAASR,EAAM,GAAI,IAAKxE,GAAK+E,EAAQ/E,IAC9CuE,EAAKhF,KAAK+E,EAAIZ,QAAQc,EAAM,GAAIxE,EAAE2D,aAEtC,OAAOY,EAGX,OADAA,EAAKhF,KAAK+E,GACHC,I,kCCrHX,4ZAuPIU,EAvPJ,wBA0BIC,EAAO,IAAItK,MAAM,GAKd,SAASuC,IACZ,MAAO,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,GAOpB,SAASgI,EAAMC,GAClB,OAAOC,EAAID,EAAW,EAAG,EAAG,EAAG,EAAG,EAAG,GASlC,SAASE,EAASC,EAAYC,GACjC,IAAIC,EAAKF,EAAW,GAChBG,EAAKH,EAAW,GAChBI,EAAKJ,EAAW,GAChBK,EAAKL,EAAW,GAChBM,EAAKN,EAAW,GAChBO,EAAKP,EAAW,GAChBQ,EAAKP,EAAW,GAChBQ,EAAKR,EAAW,GAChBS,EAAKT,EAAW,GAChBU,EAAKV,EAAW,GAChBW,EAAKX,EAAW,GAChBY,EAAKZ,EAAW,GAOpB,OANAD,EAAW,GAAKE,EAAKM,EAAKJ,EAAKK,EAC/BT,EAAW,GAAKG,EAAKK,EAAKH,EAAKI,EAC/BT,EAAW,GAAKE,EAAKQ,EAAKN,EAAKO,EAC/BX,EAAW,GAAKG,EAAKO,EAAKL,EAAKM,EAC/BX,EAAW,GAAKE,EAAKU,EAAKR,EAAKS,EAAKP,EACpCN,EAAW,GAAKG,EAAKS,EAAKP,EAAKQ,EAAKN,EAC7BP,EAaJ,SAASF,EAAID,EAAWnG,EAAG3C,EAAG+J,EAAGhK,EAAGiK,EAAGC,GAO1C,OANAnB,EAAU,GAAKnG,EACfmG,EAAU,GAAK9I,EACf8I,EAAU,GAAKiB,EACfjB,EAAU,GAAK/I,EACf+I,EAAU,GAAKkB,EACflB,EAAU,GAAKmB,EACRnB,EAQJ,SAASoB,EAAajB,EAAYC,GAOrC,OANAD,EAAW,GAAKC,EAAW,GAC3BD,EAAW,GAAKC,EAAW,GAC3BD,EAAW,GAAKC,EAAW,GAC3BD,EAAW,GAAKC,EAAW,GAC3BD,EAAW,GAAKC,EAAW,GAC3BD,EAAW,GAAKC,EAAW,GACpBD,EAWJ,SAASkB,EAAMrB,EAAWzC,GAC7B,IAAIzH,EAAIyH,EAAW,GACfxH,EAAIwH,EAAW,GAGnB,OAFAA,EAAW,GAAKyC,EAAU,GAAKlK,EAAIkK,EAAU,GAAKjK,EAAIiK,EAAU,GAChEzC,EAAW,GAAKyC,EAAU,GAAKlK,EAAIkK,EAAU,GAAKjK,EAAIiK,EAAU,GACzDzC,EAQJ,SAAS+D,EAAOtB,EAAWuB,GAC9B,IAAIC,EAAM5N,KAAK4N,IAAID,GACfE,EAAM7N,KAAK6N,IAAIF,GACnB,OAAOrB,EAASF,EAAWC,EAAIH,EAAM0B,EAAKC,GAAMA,EAAKD,EAAK,EAAG,IAS1D,SAAS7D,EAAMqC,EAAWlK,EAAGC,GAChC,OAAOmK,EAASF,EAAWC,EAAIH,EAAMhK,EAAG,EAAG,EAAGC,EAAG,EAAG,IASjD,SAAS2L,EAAUC,EAAQ7L,EAAGC,GACjC,OAAOkK,EAAI0B,EAAQ7L,EAAG,EAAG,EAAGC,EAAG,EAAG,GAS/B,SAAS6L,EAAU5B,EAAW6B,EAAIC,GACrC,OAAO5B,EAASF,EAAWC,EAAIH,EAAM,EAAG,EAAG,EAAG,EAAG+B,EAAIC,IAelD,SAASC,EAAQ/B,EAAWgC,EAAKC,EAAKC,EAAIC,EAAIZ,EAAOa,EAAKC,GAC7D,IAAIZ,EAAM7N,KAAK6N,IAAIF,GACfC,EAAM5N,KAAK4N,IAAID,GAOnB,OANAvB,EAAU,GAAKkC,EAAKV,EACpBxB,EAAU,GAAKmC,EAAKV,EACpBzB,EAAU,IAAMkC,EAAKT,EACrBzB,EAAU,GAAKmC,EAAKX,EACpBxB,EAAU,GAAKoC,EAAMF,EAAKV,EAAMa,EAAMH,EAAKT,EAAMO,EACjDhC,EAAU,GAAKoC,EAAMD,EAAKV,EAAMY,EAAMF,EAAKX,EAAMS,EAC1CjC,EAkCJ,SAASsC,EAAYX,EAAQY,GAChC,IAAIC,EAAMC,EAAYF,GACtB,eAAe,IAARC,EAAW,IAClB,IAAI3I,EAAI0I,EAAO,GACXrL,EAAIqL,EAAO,GACXtB,EAAIsB,EAAO,GACXtL,EAAIsL,EAAO,GACXrB,EAAIqB,EAAO,GACXpB,EAAIoB,EAAO,GAOf,OANAZ,EAAO,GAAK1K,EAAIuL,EAChBb,EAAO,IAAMzK,EAAIsL,EACjBb,EAAO,IAAMV,EAAIuB,EACjBb,EAAO,GAAK9H,EAAI2I,EAChBb,EAAO,IAAMV,EAAIE,EAAIlK,EAAIiK,GAAKsB,EAC9Bb,EAAO,KAAO9H,EAAIsH,EAAIjK,EAAIgK,GAAKsB,EACxBb,EAOJ,SAASc,EAAYC,GACxB,OAAOA,EAAI,GAAKA,EAAI,GAAKA,EAAI,GAAKA,EAAI,GAanC,SAASnE,EAASmE,GACrB,IAAIC,EAAkB,UAAYD,EAAIE,KAAK,MAAQ,IACnD,GAAI,OACA,OAAOD,EAEX,IAAIE,EAAOhD,IAAuBA,EAAqBiD,SAASC,cAAc,QAE9E,OADAF,EAAKG,MAAMhD,UAAY2C,EAChBE,EAAKG,MAAMhD,Y,kCC1Pf,SAASiD,EAAaC,EAAKC,GAC9B,IAAIC,EAAY,GAEhBjM,OAAOkM,KAAKF,GAAQrJ,SAAQ,SAAUwJ,GAChB,OAAdH,EAAOG,SAA6BjP,IAAd8O,EAAOG,IAC7BF,EAAUjJ,KAAKmJ,EAAI,IAAMC,mBAAmBJ,EAAOG,QAG3D,IAAIE,EAAKJ,EAAUR,KAAK,KAKxB,OAHAM,EAAMA,EAAI5E,QAAQ,QAAS,IAE3B4E,GAA4B,IAAtBA,EAAIhJ,QAAQ,KAAcgJ,EAAM,IAAMA,EAAM,IAC3CA,EAAMM,EAxBjB","file":"js/chunk-f66f989c.201c0242.js","sourcesContent":["/**\n * @module ol/tilegrid/common\n */\n/**\n * Default maximum zoom for default tile grids.\n * @type {number}\n */\nexport var DEFAULT_MAX_ZOOM = 42;\n/**\n * Default tile size.\n * @type {number}\n */\nexport var DEFAULT_TILE_SIZE = 256;\n//# sourceMappingURL=common.js.map","/**\n * @module ol/tilegrid\n */\nimport Corner from './extent/Corner.js';\nimport TileGrid from './tilegrid/TileGrid.js';\nimport Units from './proj/Units.js';\nimport { DEFAULT_MAX_ZOOM, DEFAULT_TILE_SIZE } from './tilegrid/common.js';\nimport { METERS_PER_UNIT, get as getProjection } from './proj.js';\nimport { containsCoordinate, createOrUpdate, getCorner, getHeight, getWidth, } from './extent.js';\nimport { toSize } from './size.js';\n/**\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {!TileGrid} Default tile grid for the\n * passed projection.\n */\nexport function getForProjection(projection) {\n    var tileGrid = projection.getDefaultTileGrid();\n    if (!tileGrid) {\n        tileGrid = createForProjection(projection);\n        projection.setDefaultTileGrid(tileGrid);\n    }\n    return tileGrid;\n}\n/**\n * @param {TileGrid} tileGrid Tile grid.\n * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {import(\"./tilecoord.js\").TileCoord} Tile coordinate.\n */\nexport function wrapX(tileGrid, tileCoord, projection) {\n    var z = tileCoord[0];\n    var center = tileGrid.getTileCoordCenter(tileCoord);\n    var projectionExtent = extentFromProjection(projection);\n    if (!containsCoordinate(projectionExtent, center)) {\n        var worldWidth = getWidth(projectionExtent);\n        var worldsAway = Math.ceil((projectionExtent[0] - center[0]) / worldWidth);\n        center[0] += worldWidth * worldsAway;\n        return tileGrid.getTileCoordForCoordAndZ(center, z);\n    }\n    else {\n        return tileCoord;\n    }\n}\n/**\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number} [opt_maxZoom] Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size} [opt_tileSize] Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {import(\"./extent/Corner.js\").default} [opt_corner] Extent corner (default is `'top-left'`).\n * @return {!TileGrid} TileGrid instance.\n */\nexport function createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner) {\n    var corner = opt_corner !== undefined ? opt_corner : Corner.TOP_LEFT;\n    var resolutions = resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize);\n    return new TileGrid({\n        extent: extent,\n        origin: getCorner(extent, corner),\n        resolutions: resolutions,\n        tileSize: opt_tileSize,\n    });\n}\n/**\n * @typedef {Object} XYZOptions\n * @property {import(\"./extent.js\").Extent} [extent] Extent for the tile grid. The origin for an XYZ tile grid is the\n * top-left corner of the extent. If `maxResolution` is not provided the zero level of the grid is defined by the resolution\n * at which one tile fits in the provided extent. If not provided, the extent of the EPSG:3857 projection is used.\n * @property {number} [maxResolution] Resolution at level zero.\n * @property {number} [maxZoom] Maximum zoom. The default is `42`. This determines the number of levels\n * in the grid set. For example, a `maxZoom` of 21 means there are 22 levels in the grid set.\n * @property {number} [minZoom=0] Minimum zoom.\n * @property {number|import(\"./size.js\").Size} [tileSize=[256, 256]] Tile size in pixels.\n */\n/**\n * Creates a tile grid with a standard XYZ tiling scheme.\n * @param {XYZOptions} [opt_options] Tile grid options.\n * @return {!TileGrid} Tile grid instance.\n * @api\n */\nexport function createXYZ(opt_options) {\n    var xyzOptions = opt_options || {};\n    var extent = xyzOptions.extent || getProjection('EPSG:3857').getExtent();\n    var gridOptions = {\n        extent: extent,\n        minZoom: xyzOptions.minZoom,\n        tileSize: xyzOptions.tileSize,\n        resolutions: resolutionsFromExtent(extent, xyzOptions.maxZoom, xyzOptions.tileSize, xyzOptions.maxResolution),\n    };\n    return new TileGrid(gridOptions);\n}\n/**\n * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number} [opt_maxZoom] Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size} [opt_tileSize] Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {number} [opt_maxResolution] Resolution at level zero.\n * @return {!Array<number>} Resolutions array.\n */\nfunction resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize, opt_maxResolution) {\n    var maxZoom = opt_maxZoom !== undefined ? opt_maxZoom : DEFAULT_MAX_ZOOM;\n    var height = getHeight(extent);\n    var width = getWidth(extent);\n    var tileSize = toSize(opt_tileSize !== undefined ? opt_tileSize : DEFAULT_TILE_SIZE);\n    var maxResolution = opt_maxResolution > 0\n        ? opt_maxResolution\n        : Math.max(width / tileSize[0], height / tileSize[1]);\n    var length = maxZoom + 1;\n    var resolutions = new Array(length);\n    for (var z = 0; z < length; ++z) {\n        resolutions[z] = maxResolution / Math.pow(2, z);\n    }\n    return resolutions;\n}\n/**\n * @param {import(\"./proj.js\").ProjectionLike} projection Projection.\n * @param {number} [opt_maxZoom] Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size} [opt_tileSize] Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {import(\"./extent/Corner.js\").default} [opt_corner] Extent corner (default is `'top-left'`).\n * @return {!TileGrid} TileGrid instance.\n */\nexport function createForProjection(projection, opt_maxZoom, opt_tileSize, opt_corner) {\n    var extent = extentFromProjection(projection);\n    return createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner);\n}\n/**\n * Generate a tile grid extent from a projection.  If the projection has an\n * extent, it is used.  If not, a global extent is assumed.\n * @param {import(\"./proj.js\").ProjectionLike} projection Projection.\n * @return {import(\"./extent.js\").Extent} Extent.\n */\nexport function extentFromProjection(projection) {\n    projection = getProjection(projection);\n    var extent = projection.getExtent();\n    if (!extent) {\n        var half = (180 * METERS_PER_UNIT[Units.DEGREES]) / projection.getMetersPerUnit();\n        extent = createOrUpdate(-half, -half, half, half);\n    }\n    return extent;\n}\n//# sourceMappingURL=tilegrid.js.map","/**\n * @module ol/tilecoord\n */\n/**\n * An array of three numbers representing the location of a tile in a tile\n * grid. The order is `z` (zoom level), `x` (column), and `y` (row).\n * @typedef {Array<number>} TileCoord\n * @api\n */\n/**\n * @param {number} z Z.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {TileCoord} [opt_tileCoord] Tile coordinate.\n * @return {TileCoord} Tile coordinate.\n */\nexport function createOrUpdate(z, x, y, opt_tileCoord) {\n    if (opt_tileCoord !== undefined) {\n        opt_tileCoord[0] = z;\n        opt_tileCoord[1] = x;\n        opt_tileCoord[2] = y;\n        return opt_tileCoord;\n    }\n    else {\n        return [z, x, y];\n    }\n}\n/**\n * @param {number} z Z.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {string} Key.\n */\nexport function getKeyZXY(z, x, y) {\n    return z + '/' + x + '/' + y;\n}\n/**\n * Get the key for a tile coord.\n * @param {TileCoord} tileCoord The tile coord.\n * @return {string} Key.\n */\nexport function getKey(tileCoord) {\n    return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);\n}\n/**\n * Get the tile cache key for a tile key obtained through `tile.getKey()`.\n * @param {string} tileKey The tile key.\n * @return {string} The cache key.\n */\nexport function getCacheKeyForTileKey(tileKey) {\n    var _a = tileKey\n        .substring(tileKey.lastIndexOf('/') + 1, tileKey.length)\n        .split(',')\n        .map(Number), z = _a[0], x = _a[1], y = _a[2];\n    return getKeyZXY(z, x, y);\n}\n/**\n * Get a tile coord given a key.\n * @param {string} key The tile coord key.\n * @return {TileCoord} The tile coord.\n */\nexport function fromKey(key) {\n    return key.split('/').map(Number);\n}\n/**\n * @param {TileCoord} tileCoord Tile coord.\n * @return {number} Hash.\n */\nexport function hash(tileCoord) {\n    return (tileCoord[1] << tileCoord[0]) + tileCoord[2];\n}\n/**\n * @param {TileCoord} tileCoord Tile coordinate.\n * @param {!import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {boolean} Tile coordinate is within extent and zoom level range.\n */\nexport function withinExtentAndZ(tileCoord, tileGrid) {\n    var z = tileCoord[0];\n    var x = tileCoord[1];\n    var y = tileCoord[2];\n    if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {\n        return false;\n    }\n    var tileRange = tileGrid.getFullTileRange(z);\n    if (!tileRange) {\n        return true;\n    }\n    else {\n        return tileRange.containsXY(x, y);\n    }\n}\n//# sourceMappingURL=tilecoord.js.map","/**\n * @module ol/tilegrid/WMTS\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport TileGrid from './TileGrid.js';\nimport { find } from '../array.js';\nimport { get as getProjection } from '../proj.js';\n/**\n * @typedef {Object} Options\n * @property {import(\"../extent.js\").Extent} [extent] Extent for the tile grid. No tiles\n * outside this extent will be requested by {@link module:ol/source/Tile~TileSource} sources.\n * When no `origin` or `origins` are configured, the `origin` will be set to the\n * top-left corner of the extent.\n * @property {import(\"../coordinate.js\").Coordinate} [origin] The tile grid origin, i.e.\n * where the `x` and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left\n * to right and downwards. If not specified, `extent` or `origins` must be provided.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} [origins] Tile grid origins,\n * i.e. where the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If\n * given, the array length should match the length of the `resolutions` array, i.e.\n * each resolution can have a different origin. Tile coordinates increase left to\n * right and downwards. If not specified, `extent` or `origin` must be provided.\n * @property {!Array<number>} resolutions Resolutions. The array index of each\n * resolution needs to match the zoom level. This means that even if a `minZoom`\n * is configured, the resolutions array will have a length of `maxZoom + 1`\n * @property {!Array<string>} matrixIds matrix IDs. The length of this array needs\n * to match the length of the `resolutions` array.\n * @property {Array<import(\"../size.js\").Size>} [sizes] Number of tile rows and columns\n * of the grid for each zoom level. The values here are the `TileMatrixWidth` and\n * `TileMatrixHeight` advertised in the GetCapabilities response of the WMTS, and\n * define each zoom level's extent together with the `origin` or `origins`.\n * A grid `extent` can be configured in addition, and will further limit the extent for\n * which tile requests are made by sources. If the bottom-left corner of\n * an extent is used as `origin` or `origins`, then the `y` value must be\n * negative because OpenLayers tile coordinates use the top left as the origin.\n * @property {number|import(\"../size.js\").Size} [tileSize] Tile size.\n * @property {Array<import(\"../size.js\").Size>} [tileSizes] Tile sizes. The length of\n * this array needs to match the length of the `resolutions` array.\n */\n/**\n * @classdesc\n * Set the grid pattern for sources accessing WMTS tiled-image servers.\n * @api\n */\nvar WMTSTileGrid = /** @class */ (function (_super) {\n    __extends(WMTSTileGrid, _super);\n    /**\n     * @param {Options} options WMTS options.\n     */\n    function WMTSTileGrid(options) {\n        var _this = _super.call(this, {\n            extent: options.extent,\n            origin: options.origin,\n            origins: options.origins,\n            resolutions: options.resolutions,\n            tileSize: options.tileSize,\n            tileSizes: options.tileSizes,\n            sizes: options.sizes,\n        }) || this;\n        /**\n         * @private\n         * @type {!Array<string>}\n         */\n        _this.matrixIds_ = options.matrixIds;\n        return _this;\n    }\n    /**\n     * @param {number} z Z.\n     * @return {string} MatrixId..\n     */\n    WMTSTileGrid.prototype.getMatrixId = function (z) {\n        return this.matrixIds_[z];\n    };\n    /**\n     * Get the list of matrix identifiers.\n     * @return {Array<string>} MatrixIds.\n     * @api\n     */\n    WMTSTileGrid.prototype.getMatrixIds = function () {\n        return this.matrixIds_;\n    };\n    return WMTSTileGrid;\n}(TileGrid));\nexport default WMTSTileGrid;\n/**\n * Create a tile grid from a WMTS capabilities matrix set and an\n * optional TileMatrixSetLimits.\n * @param {Object} matrixSet An object representing a matrixSet in the\n *     capabilities document.\n * @param {import(\"../extent.js\").Extent} [opt_extent] An optional extent to restrict the tile\n *     ranges the server provides.\n * @param {Array<Object>} [opt_matrixLimits] An optional object representing\n *     the available matrices for tileGrid.\n * @return {WMTSTileGrid} WMTS tileGrid instance.\n * @api\n */\nexport function createFromCapabilitiesMatrixSet(matrixSet, opt_extent, opt_matrixLimits) {\n    /** @type {!Array<number>} */\n    var resolutions = [];\n    /** @type {!Array<string>} */\n    var matrixIds = [];\n    /** @type {!Array<import(\"../coordinate.js\").Coordinate>} */\n    var origins = [];\n    /** @type {!Array<import(\"../size.js\").Size>} */\n    var tileSizes = [];\n    /** @type {!Array<import(\"../size.js\").Size>} */\n    var sizes = [];\n    var matrixLimits = opt_matrixLimits !== undefined ? opt_matrixLimits : [];\n    var supportedCRSPropName = 'SupportedCRS';\n    var matrixIdsPropName = 'TileMatrix';\n    var identifierPropName = 'Identifier';\n    var scaleDenominatorPropName = 'ScaleDenominator';\n    var topLeftCornerPropName = 'TopLeftCorner';\n    var tileWidthPropName = 'TileWidth';\n    var tileHeightPropName = 'TileHeight';\n    var code = matrixSet[supportedCRSPropName];\n    var projection = getProjection(code);\n    var metersPerUnit = projection.getMetersPerUnit();\n    // swap origin x and y coordinates if axis orientation is lat/long\n    var switchOriginXY = projection.getAxisOrientation().substr(0, 2) == 'ne';\n    matrixSet[matrixIdsPropName].sort(function (a, b) {\n        return b[scaleDenominatorPropName] - a[scaleDenominatorPropName];\n    });\n    matrixSet[matrixIdsPropName].forEach(function (elt) {\n        var matrixAvailable;\n        // use of matrixLimits to filter TileMatrices from GetCapabilities\n        // TileMatrixSet from unavailable matrix levels.\n        if (matrixLimits.length > 0) {\n            matrixAvailable = find(matrixLimits, function (elt_ml) {\n                if (elt[identifierPropName] == elt_ml[matrixIdsPropName]) {\n                    return true;\n                }\n                // Fallback for tileMatrix identifiers that don't get prefixed\n                // by their tileMatrixSet identifiers.\n                if (elt[identifierPropName].indexOf(':') === -1) {\n                    return (matrixSet[identifierPropName] + ':' + elt[identifierPropName] ===\n                        elt_ml[matrixIdsPropName]);\n                }\n                return false;\n            });\n        }\n        else {\n            matrixAvailable = true;\n        }\n        if (matrixAvailable) {\n            matrixIds.push(elt[identifierPropName]);\n            var resolution = (elt[scaleDenominatorPropName] * 0.28e-3) / metersPerUnit;\n            var tileWidth = elt[tileWidthPropName];\n            var tileHeight = elt[tileHeightPropName];\n            if (switchOriginXY) {\n                origins.push([\n                    elt[topLeftCornerPropName][1],\n                    elt[topLeftCornerPropName][0],\n                ]);\n            }\n            else {\n                origins.push(elt[topLeftCornerPropName]);\n            }\n            resolutions.push(resolution);\n            tileSizes.push(tileWidth == tileHeight ? tileWidth : [tileWidth, tileHeight]);\n            sizes.push([elt['MatrixWidth'], elt['MatrixHeight']]);\n        }\n    });\n    return new WMTSTileGrid({\n        extent: opt_extent,\n        origins: origins,\n        resolutions: resolutions,\n        matrixIds: matrixIds,\n        tileSizes: tileSizes,\n        sizes: sizes,\n    });\n}\n//# sourceMappingURL=WMTS.js.map","/**\n * @module ol/tilegrid/TileGrid\n */\nimport TileRange, { createOrUpdate as createOrUpdateTileRange, } from '../TileRange.js';\nimport { DEFAULT_TILE_SIZE } from './common.js';\nimport { assert } from '../asserts.js';\nimport { ceil, clamp, floor } from '../math.js';\nimport { createOrUpdate, getTopLeft } from '../extent.js';\nimport { createOrUpdate as createOrUpdateTileCoord } from '../tilecoord.js';\nimport { isSorted, linearFindNearest } from '../array.js';\nimport { toSize } from '../size.js';\n/**\n * @private\n * @type {import(\"../tilecoord.js\").TileCoord}\n */\nvar tmpTileCoord = [0, 0, 0];\n/**\n * Number of decimal digits to consider in integer values when rounding.\n * @type {number}\n */\nvar DECIMALS = 5;\n/**\n * @typedef {Object} Options\n * @property {import(\"../extent.js\").Extent} [extent] Extent for the tile grid. No tiles outside this\n * extent will be requested by {@link module:ol/source/Tile~TileSource} sources. When no `origin` or\n * `origins` are configured, the `origin` will be set to the top-left corner of the extent.\n * @property {number} [minZoom=0] Minimum zoom.\n * @property {import(\"../coordinate.js\").Coordinate} [origin] The tile grid origin, i.e. where the `x`\n * and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left to right and downwards. If not\n * specified, `extent` or `origins` must be provided.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} [origins] Tile grid origins, i.e. where\n * the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If given, the array length\n * should match the length of the `resolutions` array, i.e. each resolution can have a different\n * origin. Tile coordinates increase left to right and downwards. If not specified, `extent` or\n * `origin` must be provided.\n * @property {!Array<number>} resolutions Resolutions. The array index of each resolution needs\n * to match the zoom level. This means that even if a `minZoom` is configured, the resolutions\n * array will have a length of `maxZoom + 1`.\n * @property {Array<import(\"../size.js\").Size>} [sizes] Number of tile rows and columns\n * of the grid for each zoom level. If specified the values\n * define each zoom level's extent together with the `origin` or `origins`.\n * A grid `extent` can be configured in addition, and will further limit the extent\n * for which tile requests are made by sources. If the bottom-left corner of\n * an extent is used as `origin` or `origins`, then the `y` value must be\n * negative because OpenLayers tile coordinates use the top left as the origin.\n * @property {number|import(\"../size.js\").Size} [tileSize] Tile size.\n * Default is `[256, 256]`.\n * @property {Array<import(\"../size.js\").Size>} [tileSizes] Tile sizes. If given, the array length\n * should match the length of the `resolutions` array, i.e. each resolution can have a different\n * tile size.\n */\n/**\n * @classdesc\n * Base class for setting the grid pattern for sources accessing tiled-image\n * servers.\n * @api\n */\nvar TileGrid = /** @class */ (function () {\n    /**\n     * @param {Options} options Tile grid options.\n     */\n    function TileGrid(options) {\n        /**\n         * @protected\n         * @type {number}\n         */\n        this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;\n        /**\n         * @private\n         * @type {!Array<number>}\n         */\n        this.resolutions_ = options.resolutions;\n        assert(isSorted(this.resolutions_, function (a, b) {\n            return b - a;\n        }, true), 17); // `resolutions` must be sorted in descending order\n        // check if we've got a consistent zoom factor and origin\n        var zoomFactor;\n        if (!options.origins) {\n            for (var i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {\n                if (!zoomFactor) {\n                    zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];\n                }\n                else {\n                    if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {\n                        zoomFactor = undefined;\n                        break;\n                    }\n                }\n            }\n        }\n        /**\n         * @private\n         * @type {number|undefined}\n         */\n        this.zoomFactor_ = zoomFactor;\n        /**\n         * @protected\n         * @type {number}\n         */\n        this.maxZoom = this.resolutions_.length - 1;\n        /**\n         * @private\n         * @type {import(\"../coordinate.js\").Coordinate|null}\n         */\n        this.origin_ = options.origin !== undefined ? options.origin : null;\n        /**\n         * @private\n         * @type {Array<import(\"../coordinate.js\").Coordinate>}\n         */\n        this.origins_ = null;\n        if (options.origins !== undefined) {\n            this.origins_ = options.origins;\n            assert(this.origins_.length == this.resolutions_.length, 20); // Number of `origins` and `resolutions` must be equal\n        }\n        var extent = options.extent;\n        if (extent !== undefined && !this.origin_ && !this.origins_) {\n            this.origin_ = getTopLeft(extent);\n        }\n        assert((!this.origin_ && this.origins_) || (this.origin_ && !this.origins_), 18); // Either `origin` or `origins` must be configured, never both\n        /**\n         * @private\n         * @type {Array<number|import(\"../size.js\").Size>}\n         */\n        this.tileSizes_ = null;\n        if (options.tileSizes !== undefined) {\n            this.tileSizes_ = options.tileSizes;\n            assert(this.tileSizes_.length == this.resolutions_.length, 19); // Number of `tileSizes` and `resolutions` must be equal\n        }\n        /**\n         * @private\n         * @type {number|import(\"../size.js\").Size}\n         */\n        this.tileSize_ =\n            options.tileSize !== undefined\n                ? options.tileSize\n                : !this.tileSizes_\n                    ? DEFAULT_TILE_SIZE\n                    : null;\n        assert((!this.tileSize_ && this.tileSizes_) ||\n            (this.tileSize_ && !this.tileSizes_), 22); // Either `tileSize` or `tileSizes` must be configured, never both\n        /**\n         * @private\n         * @type {import(\"../extent.js\").Extent}\n         */\n        this.extent_ = extent !== undefined ? extent : null;\n        /**\n         * @private\n         * @type {Array<import(\"../TileRange.js\").default>}\n         */\n        this.fullTileRanges_ = null;\n        /**\n         * @private\n         * @type {import(\"../size.js\").Size}\n         */\n        this.tmpSize_ = [0, 0];\n        /**\n         * @private\n         * @type {import(\"../extent.js\").Extent}\n         */\n        this.tmpExtent_ = [0, 0, 0, 0];\n        if (options.sizes !== undefined) {\n            this.fullTileRanges_ = options.sizes.map(function (size, z) {\n                var tileRange = new TileRange(Math.min(0, size[0]), Math.max(size[0] - 1, -1), Math.min(0, size[1]), Math.max(size[1] - 1, -1));\n                if (extent) {\n                    var restrictedTileRange = this.getTileRangeForExtentAndZ(extent, z);\n                    tileRange.minX = Math.max(restrictedTileRange.minX, tileRange.minX);\n                    tileRange.maxX = Math.min(restrictedTileRange.maxX, tileRange.maxX);\n                    tileRange.minY = Math.max(restrictedTileRange.minY, tileRange.minY);\n                    tileRange.maxY = Math.min(restrictedTileRange.maxY, tileRange.maxY);\n                }\n                return tileRange;\n            }, this);\n        }\n        else if (extent) {\n            this.calculateTileRanges_(extent);\n        }\n    }\n    /**\n     * Call a function with each tile coordinate for a given extent and zoom level.\n     *\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @param {number} zoom Integer zoom level.\n     * @param {function(import(\"../tilecoord.js\").TileCoord): void} callback Function called with each tile coordinate.\n     * @api\n     */\n    TileGrid.prototype.forEachTileCoord = function (extent, zoom, callback) {\n        var tileRange = this.getTileRangeForExtentAndZ(extent, zoom);\n        for (var i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {\n            for (var j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {\n                callback([zoom, i, j]);\n            }\n        }\n    };\n    /**\n     * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n     * @param {function(number, import(\"../TileRange.js\").default): boolean} callback Callback.\n     * @param {import(\"../TileRange.js\").default} [opt_tileRange] Temporary import(\"../TileRange.js\").default object.\n     * @param {import(\"../extent.js\").Extent} [opt_extent] Temporary import(\"../extent.js\").Extent object.\n     * @return {boolean} Callback succeeded.\n     */\n    TileGrid.prototype.forEachTileCoordParentTileRange = function (tileCoord, callback, opt_tileRange, opt_extent) {\n        var tileRange, x, y;\n        var tileCoordExtent = null;\n        var z = tileCoord[0] - 1;\n        if (this.zoomFactor_ === 2) {\n            x = tileCoord[1];\n            y = tileCoord[2];\n        }\n        else {\n            tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);\n        }\n        while (z >= this.minZoom) {\n            if (this.zoomFactor_ === 2) {\n                x = Math.floor(x / 2);\n                y = Math.floor(y / 2);\n                tileRange = createOrUpdateTileRange(x, x, y, y, opt_tileRange);\n            }\n            else {\n                tileRange = this.getTileRangeForExtentAndZ(tileCoordExtent, z, opt_tileRange);\n            }\n            if (callback(z, tileRange)) {\n                return true;\n            }\n            --z;\n        }\n        return false;\n    };\n    /**\n     * Get the extent for this tile grid, if it was configured.\n     * @return {import(\"../extent.js\").Extent} Extent.\n     * @api\n     */\n    TileGrid.prototype.getExtent = function () {\n        return this.extent_;\n    };\n    /**\n     * Get the maximum zoom level for the grid.\n     * @return {number} Max zoom.\n     * @api\n     */\n    TileGrid.prototype.getMaxZoom = function () {\n        return this.maxZoom;\n    };\n    /**\n     * Get the minimum zoom level for the grid.\n     * @return {number} Min zoom.\n     * @api\n     */\n    TileGrid.prototype.getMinZoom = function () {\n        return this.minZoom;\n    };\n    /**\n     * Get the origin for the grid at the given zoom level.\n     * @param {number} z Integer zoom level.\n     * @return {import(\"../coordinate.js\").Coordinate} Origin.\n     * @api\n     */\n    TileGrid.prototype.getOrigin = function (z) {\n        if (this.origin_) {\n            return this.origin_;\n        }\n        else {\n            return this.origins_[z];\n        }\n    };\n    /**\n     * Get the resolution for the given zoom level.\n     * @param {number} z Integer zoom level.\n     * @return {number} Resolution.\n     * @api\n     */\n    TileGrid.prototype.getResolution = function (z) {\n        return this.resolutions_[z];\n    };\n    /**\n     * Get the list of resolutions for the tile grid.\n     * @return {Array<number>} Resolutions.\n     * @api\n     */\n    TileGrid.prototype.getResolutions = function () {\n        return this.resolutions_;\n    };\n    /**\n     * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n     * @param {import(\"../TileRange.js\").default} [opt_tileRange] Temporary import(\"../TileRange.js\").default object.\n     * @param {import(\"../extent.js\").Extent} [opt_extent] Temporary import(\"../extent.js\").Extent object.\n     * @return {import(\"../TileRange.js\").default} Tile range.\n     */\n    TileGrid.prototype.getTileCoordChildTileRange = function (tileCoord, opt_tileRange, opt_extent) {\n        if (tileCoord[0] < this.maxZoom) {\n            if (this.zoomFactor_ === 2) {\n                var minX = tileCoord[1] * 2;\n                var minY = tileCoord[2] * 2;\n                return createOrUpdateTileRange(minX, minX + 1, minY, minY + 1, opt_tileRange);\n            }\n            var tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent || this.tmpExtent_);\n            return this.getTileRangeForExtentAndZ(tileCoordExtent, tileCoord[0] + 1, opt_tileRange);\n        }\n        return null;\n    };\n    /**\n     * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n     * @param {number} z Integer zoom level.\n     * @param {import(\"../TileRange.js\").default} [opt_tileRange] Temporary import(\"../TileRange.js\").default object.\n     * @return {import(\"../TileRange.js\").default} Tile range.\n     */\n    TileGrid.prototype.getTileRangeForTileCoordAndZ = function (tileCoord, z, opt_tileRange) {\n        if (z > this.maxZoom || z < this.minZoom) {\n            return null;\n        }\n        var tileCoordZ = tileCoord[0];\n        var tileCoordX = tileCoord[1];\n        var tileCoordY = tileCoord[2];\n        if (z === tileCoordZ) {\n            return createOrUpdateTileRange(tileCoordX, tileCoordY, tileCoordX, tileCoordY, opt_tileRange);\n        }\n        if (this.zoomFactor_) {\n            var factor = Math.pow(this.zoomFactor_, z - tileCoordZ);\n            var minX = Math.floor(tileCoordX * factor);\n            var minY = Math.floor(tileCoordY * factor);\n            if (z < tileCoordZ) {\n                return createOrUpdateTileRange(minX, minX, minY, minY, opt_tileRange);\n            }\n            var maxX = Math.floor(factor * (tileCoordX + 1)) - 1;\n            var maxY = Math.floor(factor * (tileCoordY + 1)) - 1;\n            return createOrUpdateTileRange(minX, maxX, minY, maxY, opt_tileRange);\n        }\n        var tileCoordExtent = this.getTileCoordExtent(tileCoord, this.tmpExtent_);\n        return this.getTileRangeForExtentAndZ(tileCoordExtent, z, opt_tileRange);\n    };\n    /**\n     * Get the extent for a tile range.\n     * @param {number} z Integer zoom level.\n     * @param {import(\"../TileRange.js\").default} tileRange Tile range.\n     * @param {import(\"../extent.js\").Extent} [opt_extent] Temporary import(\"../extent.js\").Extent object.\n     * @return {import(\"../extent.js\").Extent} Extent.\n     */\n    TileGrid.prototype.getTileRangeExtent = function (z, tileRange, opt_extent) {\n        var origin = this.getOrigin(z);\n        var resolution = this.getResolution(z);\n        var tileSize = toSize(this.getTileSize(z), this.tmpSize_);\n        var minX = origin[0] + tileRange.minX * tileSize[0] * resolution;\n        var maxX = origin[0] + (tileRange.maxX + 1) * tileSize[0] * resolution;\n        var minY = origin[1] + tileRange.minY * tileSize[1] * resolution;\n        var maxY = origin[1] + (tileRange.maxY + 1) * tileSize[1] * resolution;\n        return createOrUpdate(minX, minY, maxX, maxY, opt_extent);\n    };\n    /**\n     * Get a tile range for the given extent and integer zoom level.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @param {number} z Integer zoom level.\n     * @param {import(\"../TileRange.js\").default} [opt_tileRange] Temporary tile range object.\n     * @return {import(\"../TileRange.js\").default} Tile range.\n     */\n    TileGrid.prototype.getTileRangeForExtentAndZ = function (extent, z, opt_tileRange) {\n        var tileCoord = tmpTileCoord;\n        this.getTileCoordForXYAndZ_(extent[0], extent[3], z, false, tileCoord);\n        var minX = tileCoord[1];\n        var minY = tileCoord[2];\n        this.getTileCoordForXYAndZ_(extent[2], extent[1], z, true, tileCoord);\n        return createOrUpdateTileRange(minX, tileCoord[1], minY, tileCoord[2], opt_tileRange);\n    };\n    /**\n     * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n     * @return {import(\"../coordinate.js\").Coordinate} Tile center.\n     */\n    TileGrid.prototype.getTileCoordCenter = function (tileCoord) {\n        var origin = this.getOrigin(tileCoord[0]);\n        var resolution = this.getResolution(tileCoord[0]);\n        var tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\n        return [\n            origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution,\n            origin[1] - (tileCoord[2] + 0.5) * tileSize[1] * resolution,\n        ];\n    };\n    /**\n     * Get the extent of a tile coordinate.\n     *\n     * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n     * @param {import(\"../extent.js\").Extent} [opt_extent] Temporary extent object.\n     * @return {import(\"../extent.js\").Extent} Extent.\n     * @api\n     */\n    TileGrid.prototype.getTileCoordExtent = function (tileCoord, opt_extent) {\n        var origin = this.getOrigin(tileCoord[0]);\n        var resolution = this.getResolution(tileCoord[0]);\n        var tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\n        var minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;\n        var minY = origin[1] - (tileCoord[2] + 1) * tileSize[1] * resolution;\n        var maxX = minX + tileSize[0] * resolution;\n        var maxY = minY + tileSize[1] * resolution;\n        return createOrUpdate(minX, minY, maxX, maxY, opt_extent);\n    };\n    /**\n     * Get the tile coordinate for the given map coordinate and resolution.  This\n     * method considers that coordinates that intersect tile boundaries should be\n     * assigned the higher tile coordinate.\n     *\n     * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @param {number} resolution Resolution.\n     * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Destination import(\"../tilecoord.js\").TileCoord object.\n     * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n     * @api\n     */\n    TileGrid.prototype.getTileCoordForCoordAndResolution = function (coordinate, resolution, opt_tileCoord) {\n        return this.getTileCoordForXYAndResolution_(coordinate[0], coordinate[1], resolution, false, opt_tileCoord);\n    };\n    /**\n     * Note that this method should not be called for resolutions that correspond\n     * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {number} resolution Resolution (for a non-integer zoom level).\n     * @param {boolean} reverseIntersectionPolicy Instead of letting edge\n     *     intersections go to the higher tile coordinate, let edge intersections\n     *     go to the lower tile coordinate.\n     * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Temporary import(\"../tilecoord.js\").TileCoord object.\n     * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n     * @private\n     */\n    TileGrid.prototype.getTileCoordForXYAndResolution_ = function (x, y, resolution, reverseIntersectionPolicy, opt_tileCoord) {\n        var z = this.getZForResolution(resolution);\n        var scale = resolution / this.getResolution(z);\n        var origin = this.getOrigin(z);\n        var tileSize = toSize(this.getTileSize(z), this.tmpSize_);\n        var tileCoordX = (scale * (x - origin[0])) / resolution / tileSize[0];\n        var tileCoordY = (scale * (origin[1] - y)) / resolution / tileSize[1];\n        if (reverseIntersectionPolicy) {\n            tileCoordX = ceil(tileCoordX, DECIMALS) - 1;\n            tileCoordY = ceil(tileCoordY, DECIMALS) - 1;\n        }\n        else {\n            tileCoordX = floor(tileCoordX, DECIMALS);\n            tileCoordY = floor(tileCoordY, DECIMALS);\n        }\n        return createOrUpdateTileCoord(z, tileCoordX, tileCoordY, opt_tileCoord);\n    };\n    /**\n     * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,\n     * they should have separate implementations.  This method is for integer zoom\n     * levels.  The other method should only be called for resolutions corresponding\n     * to non-integer zoom levels.\n     * @param {number} x Map x coordinate.\n     * @param {number} y Map y coordinate.\n     * @param {number} z Integer zoom level.\n     * @param {boolean} reverseIntersectionPolicy Instead of letting edge\n     *     intersections go to the higher tile coordinate, let edge intersections\n     *     go to the lower tile coordinate.\n     * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Temporary import(\"../tilecoord.js\").TileCoord object.\n     * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n     * @private\n     */\n    TileGrid.prototype.getTileCoordForXYAndZ_ = function (x, y, z, reverseIntersectionPolicy, opt_tileCoord) {\n        var origin = this.getOrigin(z);\n        var resolution = this.getResolution(z);\n        var tileSize = toSize(this.getTileSize(z), this.tmpSize_);\n        var tileCoordX = (x - origin[0]) / resolution / tileSize[0];\n        var tileCoordY = (origin[1] - y) / resolution / tileSize[1];\n        if (reverseIntersectionPolicy) {\n            tileCoordX = ceil(tileCoordX, DECIMALS) - 1;\n            tileCoordY = ceil(tileCoordY, DECIMALS) - 1;\n        }\n        else {\n            tileCoordX = floor(tileCoordX, DECIMALS);\n            tileCoordY = floor(tileCoordY, DECIMALS);\n        }\n        return createOrUpdateTileCoord(z, tileCoordX, tileCoordY, opt_tileCoord);\n    };\n    /**\n     * Get a tile coordinate given a map coordinate and zoom level.\n     * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @param {number} z Zoom level.\n     * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Destination import(\"../tilecoord.js\").TileCoord object.\n     * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n     * @api\n     */\n    TileGrid.prototype.getTileCoordForCoordAndZ = function (coordinate, z, opt_tileCoord) {\n        return this.getTileCoordForXYAndZ_(coordinate[0], coordinate[1], z, false, opt_tileCoord);\n    };\n    /**\n     * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n     * @return {number} Tile resolution.\n     */\n    TileGrid.prototype.getTileCoordResolution = function (tileCoord) {\n        return this.resolutions_[tileCoord[0]];\n    };\n    /**\n     * Get the tile size for a zoom level. The type of the return value matches the\n     * `tileSize` or `tileSizes` that the tile grid was configured with. To always\n     * get an {@link import(\"../size.js\").Size}, run the result through {@link module:ol/size.toSize}.\n     * @param {number} z Z.\n     * @return {number|import(\"../size.js\").Size} Tile size.\n     * @api\n     */\n    TileGrid.prototype.getTileSize = function (z) {\n        if (this.tileSize_) {\n            return this.tileSize_;\n        }\n        else {\n            return this.tileSizes_[z];\n        }\n    };\n    /**\n     * @param {number} z Zoom level.\n     * @return {import(\"../TileRange.js\").default} Extent tile range for the specified zoom level.\n     */\n    TileGrid.prototype.getFullTileRange = function (z) {\n        if (!this.fullTileRanges_) {\n            return this.extent_\n                ? this.getTileRangeForExtentAndZ(this.extent_, z)\n                : null;\n        }\n        else {\n            return this.fullTileRanges_[z];\n        }\n    };\n    /**\n     * @param {number} resolution Resolution.\n     * @param {number|import(\"../array.js\").NearestDirectionFunction} [opt_direction]\n     *     If 0, the nearest resolution will be used.\n     *     If 1, the nearest higher resolution (lower Z) will be used. If -1, the\n     *     nearest lower resolution (higher Z) will be used. Default is 0.\n     *     Use a {@link module:ol/array~NearestDirectionFunction} for more precise control.\n     *\n     * For example to change tile Z at the midpoint of zoom levels\n     * ```js\n     * function(value, high, low) {\n     *   return value - low * Math.sqrt(high / low);\n     * }\n     * ```\n     * @return {number} Z.\n     * @api\n     */\n    TileGrid.prototype.getZForResolution = function (resolution, opt_direction) {\n        var z = linearFindNearest(this.resolutions_, resolution, opt_direction || 0);\n        return clamp(z, this.minZoom, this.maxZoom);\n    };\n    /**\n     * @param {!import(\"../extent.js\").Extent} extent Extent for this tile grid.\n     * @private\n     */\n    TileGrid.prototype.calculateTileRanges_ = function (extent) {\n        var length = this.resolutions_.length;\n        var fullTileRanges = new Array(length);\n        for (var z = this.minZoom; z < length; ++z) {\n            fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);\n        }\n        this.fullTileRanges_ = fullTileRanges;\n    };\n    return TileGrid;\n}());\nexport default TileGrid;\n//# sourceMappingURL=TileGrid.js.map","/**\n * @module ol/tileurlfunction\n */\nimport { assert } from './asserts.js';\nimport { modulo } from './math.js';\nimport { hash as tileCoordHash } from './tilecoord.js';\n/**\n * @param {string} template Template.\n * @param {import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {import(\"./Tile.js\").UrlFunction} Tile URL function.\n */\nexport function createFromTemplate(template, tileGrid) {\n    var zRegEx = /\\{z\\}/g;\n    var xRegEx = /\\{x\\}/g;\n    var yRegEx = /\\{y\\}/g;\n    var dashYRegEx = /\\{-y\\}/g;\n    return (\n    /**\n     * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile Coordinate.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"./proj/Projection.js\").default} projection Projection.\n     * @return {string|undefined} Tile URL.\n     */\n    function (tileCoord, pixelRatio, projection) {\n        if (!tileCoord) {\n            return undefined;\n        }\n        else {\n            return template\n                .replace(zRegEx, tileCoord[0].toString())\n                .replace(xRegEx, tileCoord[1].toString())\n                .replace(yRegEx, tileCoord[2].toString())\n                .replace(dashYRegEx, function () {\n                var z = tileCoord[0];\n                var range = tileGrid.getFullTileRange(z);\n                assert(range, 55); // The {-y} placeholder requires a tile grid with extent\n                var y = range.getHeight() - tileCoord[2] - 1;\n                return y.toString();\n            });\n        }\n    });\n}\n/**\n * @param {Array<string>} templates Templates.\n * @param {import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {import(\"./Tile.js\").UrlFunction} Tile URL function.\n */\nexport function createFromTemplates(templates, tileGrid) {\n    var len = templates.length;\n    var tileUrlFunctions = new Array(len);\n    for (var i = 0; i < len; ++i) {\n        tileUrlFunctions[i] = createFromTemplate(templates[i], tileGrid);\n    }\n    return createFromTileUrlFunctions(tileUrlFunctions);\n}\n/**\n * @param {Array<import(\"./Tile.js\").UrlFunction>} tileUrlFunctions Tile URL Functions.\n * @return {import(\"./Tile.js\").UrlFunction} Tile URL function.\n */\nexport function createFromTileUrlFunctions(tileUrlFunctions) {\n    if (tileUrlFunctions.length === 1) {\n        return tileUrlFunctions[0];\n    }\n    return (\n    /**\n     * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile Coordinate.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"./proj/Projection.js\").default} projection Projection.\n     * @return {string|undefined} Tile URL.\n     */\n    function (tileCoord, pixelRatio, projection) {\n        if (!tileCoord) {\n            return undefined;\n        }\n        else {\n            var h = tileCoordHash(tileCoord);\n            var index = modulo(h, tileUrlFunctions.length);\n            return tileUrlFunctions[index](tileCoord, pixelRatio, projection);\n        }\n    });\n}\n/**\n * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @param {number} pixelRatio Pixel ratio.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {string|undefined} Tile URL.\n */\nexport function nullTileUrlFunction(tileCoord, pixelRatio, projection) {\n    return undefined;\n}\n/**\n * @param {string} url URL.\n * @return {Array<string>} Array of urls.\n */\nexport function expandUrl(url) {\n    var urls = [];\n    var match = /\\{([a-z])-([a-z])\\}/.exec(url);\n    if (match) {\n        // char range\n        var startCharCode = match[1].charCodeAt(0);\n        var stopCharCode = match[2].charCodeAt(0);\n        var charCode = void 0;\n        for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {\n            urls.push(url.replace(match[0], String.fromCharCode(charCode)));\n        }\n        return urls;\n    }\n    match = /\\{(\\d+)-(\\d+)\\}/.exec(url);\n    if (match) {\n        // number range\n        var stop_1 = parseInt(match[2], 10);\n        for (var i = parseInt(match[1], 10); i <= stop_1; i++) {\n            urls.push(url.replace(match[0], i.toString()));\n        }\n        return urls;\n    }\n    urls.push(url);\n    return urls;\n}\n//# sourceMappingURL=tileurlfunction.js.map","/**\n * @module ol/transform\n */\nimport { WORKER_OFFSCREEN_CANVAS } from './has.js';\nimport { assert } from './asserts.js';\n/**\n * An array representing an affine 2d transformation for use with\n * {@link module:ol/transform} functions. The array has 6 elements.\n * @typedef {!Array<number>} Transform\n * @api\n */\n/**\n * Collection of affine 2d transformation functions. The functions work on an\n * array of 6 elements. The element order is compatible with the [SVGMatrix\n * interface](https://developer.mozilla.org/en-US/docs/Web/API/SVGMatrix) and is\n * a subset (elements a to f) of a 33 matrix:\n * ```\n * [ a c e ]\n * [ b d f ]\n * [ 0 0 1 ]\n * ```\n */\n/**\n * @private\n * @type {Transform}\n */\nvar tmp_ = new Array(6);\n/**\n * Create an identity transform.\n * @return {!Transform} Identity transform.\n */\nexport function create() {\n    return [1, 0, 0, 1, 0, 0];\n}\n/**\n * Resets the given transform to an identity transform.\n * @param {!Transform} transform Transform.\n * @return {!Transform} Transform.\n */\nexport function reset(transform) {\n    return set(transform, 1, 0, 0, 1, 0, 0);\n}\n/**\n * Multiply the underlying matrices of two transforms and return the result in\n * the first transform.\n * @param {!Transform} transform1 Transform parameters of matrix 1.\n * @param {!Transform} transform2 Transform parameters of matrix 2.\n * @return {!Transform} transform1 multiplied with transform2.\n */\nexport function multiply(transform1, transform2) {\n    var a1 = transform1[0];\n    var b1 = transform1[1];\n    var c1 = transform1[2];\n    var d1 = transform1[3];\n    var e1 = transform1[4];\n    var f1 = transform1[5];\n    var a2 = transform2[0];\n    var b2 = transform2[1];\n    var c2 = transform2[2];\n    var d2 = transform2[3];\n    var e2 = transform2[4];\n    var f2 = transform2[5];\n    transform1[0] = a1 * a2 + c1 * b2;\n    transform1[1] = b1 * a2 + d1 * b2;\n    transform1[2] = a1 * c2 + c1 * d2;\n    transform1[3] = b1 * c2 + d1 * d2;\n    transform1[4] = a1 * e2 + c1 * f2 + e1;\n    transform1[5] = b1 * e2 + d1 * f2 + f1;\n    return transform1;\n}\n/**\n * Set the transform components a-f on a given transform.\n * @param {!Transform} transform Transform.\n * @param {number} a The a component of the transform.\n * @param {number} b The b component of the transform.\n * @param {number} c The c component of the transform.\n * @param {number} d The d component of the transform.\n * @param {number} e The e component of the transform.\n * @param {number} f The f component of the transform.\n * @return {!Transform} Matrix with transform applied.\n */\nexport function set(transform, a, b, c, d, e, f) {\n    transform[0] = a;\n    transform[1] = b;\n    transform[2] = c;\n    transform[3] = d;\n    transform[4] = e;\n    transform[5] = f;\n    return transform;\n}\n/**\n * Set transform on one matrix from another matrix.\n * @param {!Transform} transform1 Matrix to set transform to.\n * @param {!Transform} transform2 Matrix to set transform from.\n * @return {!Transform} transform1 with transform from transform2 applied.\n */\nexport function setFromArray(transform1, transform2) {\n    transform1[0] = transform2[0];\n    transform1[1] = transform2[1];\n    transform1[2] = transform2[2];\n    transform1[3] = transform2[3];\n    transform1[4] = transform2[4];\n    transform1[5] = transform2[5];\n    return transform1;\n}\n/**\n * Transforms the given coordinate with the given transform returning the\n * resulting, transformed coordinate. The coordinate will be modified in-place.\n *\n * @param {Transform} transform The transformation.\n * @param {import(\"./coordinate.js\").Coordinate|import(\"./pixel.js\").Pixel} coordinate The coordinate to transform.\n * @return {import(\"./coordinate.js\").Coordinate|import(\"./pixel.js\").Pixel} return coordinate so that operations can be\n *     chained together.\n */\nexport function apply(transform, coordinate) {\n    var x = coordinate[0];\n    var y = coordinate[1];\n    coordinate[0] = transform[0] * x + transform[2] * y + transform[4];\n    coordinate[1] = transform[1] * x + transform[3] * y + transform[5];\n    return coordinate;\n}\n/**\n * Applies rotation to the given transform.\n * @param {!Transform} transform Transform.\n * @param {number} angle Angle in radians.\n * @return {!Transform} The rotated transform.\n */\nexport function rotate(transform, angle) {\n    var cos = Math.cos(angle);\n    var sin = Math.sin(angle);\n    return multiply(transform, set(tmp_, cos, sin, -sin, cos, 0, 0));\n}\n/**\n * Applies scale to a given transform.\n * @param {!Transform} transform Transform.\n * @param {number} x Scale factor x.\n * @param {number} y Scale factor y.\n * @return {!Transform} The scaled transform.\n */\nexport function scale(transform, x, y) {\n    return multiply(transform, set(tmp_, x, 0, 0, y, 0, 0));\n}\n/**\n * Creates a scale transform.\n * @param {!Transform} target Transform to overwrite.\n * @param {number} x Scale factor x.\n * @param {number} y Scale factor y.\n * @return {!Transform} The scale transform.\n */\nexport function makeScale(target, x, y) {\n    return set(target, x, 0, 0, y, 0, 0);\n}\n/**\n * Applies translation to the given transform.\n * @param {!Transform} transform Transform.\n * @param {number} dx Translation x.\n * @param {number} dy Translation y.\n * @return {!Transform} The translated transform.\n */\nexport function translate(transform, dx, dy) {\n    return multiply(transform, set(tmp_, 1, 0, 0, 1, dx, dy));\n}\n/**\n * Creates a composite transform given an initial translation, scale, rotation, and\n * final translation (in that order only, not commutative).\n * @param {!Transform} transform The transform (will be modified in place).\n * @param {number} dx1 Initial translation x.\n * @param {number} dy1 Initial translation y.\n * @param {number} sx Scale factor x.\n * @param {number} sy Scale factor y.\n * @param {number} angle Rotation (in counter-clockwise radians).\n * @param {number} dx2 Final translation x.\n * @param {number} dy2 Final translation y.\n * @return {!Transform} The composite transform.\n */\nexport function compose(transform, dx1, dy1, sx, sy, angle, dx2, dy2) {\n    var sin = Math.sin(angle);\n    var cos = Math.cos(angle);\n    transform[0] = sx * cos;\n    transform[1] = sy * sin;\n    transform[2] = -sx * sin;\n    transform[3] = sy * cos;\n    transform[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;\n    transform[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;\n    return transform;\n}\n/**\n * Creates a composite transform given an initial translation, scale, rotation, and\n * final translation (in that order only, not commutative). The resulting transform\n * string can be applied as `transform` property of an HTMLElement's style.\n * @param {number} dx1 Initial translation x.\n * @param {number} dy1 Initial translation y.\n * @param {number} sx Scale factor x.\n * @param {number} sy Scale factor y.\n * @param {number} angle Rotation (in counter-clockwise radians).\n * @param {number} dx2 Final translation x.\n * @param {number} dy2 Final translation y.\n * @return {string} The composite css transform.\n * @api\n */\nexport function composeCssTransform(dx1, dy1, sx, sy, angle, dx2, dy2) {\n    return toString(compose(create(), dx1, dy1, sx, sy, angle, dx2, dy2));\n}\n/**\n * Invert the given transform.\n * @param {!Transform} source The source transform to invert.\n * @return {!Transform} The inverted (source) transform.\n */\nexport function invert(source) {\n    return makeInverse(source, source);\n}\n/**\n * Invert the given transform.\n * @param {!Transform} target Transform to be set as the inverse of\n *     the source transform.\n * @param {!Transform} source The source transform to invert.\n * @return {!Transform} The inverted (target) transform.\n */\nexport function makeInverse(target, source) {\n    var det = determinant(source);\n    assert(det !== 0, 32); // Transformation matrix cannot be inverted\n    var a = source[0];\n    var b = source[1];\n    var c = source[2];\n    var d = source[3];\n    var e = source[4];\n    var f = source[5];\n    target[0] = d / det;\n    target[1] = -b / det;\n    target[2] = -c / det;\n    target[3] = a / det;\n    target[4] = (c * f - d * e) / det;\n    target[5] = -(a * f - b * e) / det;\n    return target;\n}\n/**\n * Returns the determinant of the given matrix.\n * @param {!Transform} mat Matrix.\n * @return {number} Determinant.\n */\nexport function determinant(mat) {\n    return mat[0] * mat[3] - mat[1] * mat[2];\n}\n/**\n * @type {HTMLElement}\n * @private\n */\nvar transformStringDiv;\n/**\n * A rounded string version of the transform.  This can be used\n * for CSS transforms.\n * @param {!Transform} mat Matrix.\n * @return {string} The transform as a string.\n */\nexport function toString(mat) {\n    var transformString = 'matrix(' + mat.join(', ') + ')';\n    if (WORKER_OFFSCREEN_CANVAS) {\n        return transformString;\n    }\n    var node = transformStringDiv || (transformStringDiv = document.createElement('div'));\n    node.style.transform = transformString;\n    return node.style.transform;\n}\n//# sourceMappingURL=transform.js.map","/**\n * @module ol/uri\n */\n/**\n * Appends query parameters to a URI.\n *\n * @param {string} uri The original URI, which may already have query data.\n * @param {!Object} params An object where keys are URI-encoded parameter keys,\n *     and the values are arbitrary types or arrays.\n * @return {string} The new URI.\n */\nexport function appendParams(uri, params) {\n    var keyParams = [];\n    // Skip any null or undefined parameter values\n    Object.keys(params).forEach(function (k) {\n        if (params[k] !== null && params[k] !== undefined) {\n            keyParams.push(k + '=' + encodeURIComponent(params[k]));\n        }\n    });\n    var qs = keyParams.join('&');\n    // remove any trailing ? or &\n    uri = uri.replace(/[?&]$/, '');\n    // append ? or & depending on whether uri has existing parameters\n    uri = uri.indexOf('?') === -1 ? uri + '?' : uri + '&';\n    return uri + qs;\n}\n//# sourceMappingURL=uri.js.map"],"sourceRoot":""}
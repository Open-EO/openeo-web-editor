{"version":3,"file":"js/4394.f147b645.js","mappings":"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","sources":["webpack://@openeo/web-editor/./node_modules/ol-ext/control/TextButton.js","webpack://@openeo/web-editor/./node_modules/ol-ext/control/Toggle.js","webpack://@openeo/web-editor/./node_modules/ol-ext/geom/GeomUtils.js","webpack://@openeo/web-editor/./node_modules/ol-ext/geom/LineStringSplitAt.js","webpack://@openeo/web-editor/./node_modules/ol-ext/interaction/Delete.js","webpack://@openeo/web-editor/./node_modules/ol-ext/interaction/DrawHole.js","webpack://@openeo/web-editor/./node_modules/ol-ext/interaction/DrawRegular.js","webpack://@openeo/web-editor/./node_modules/ol-ext/interaction/ModifyFeature.js","webpack://@openeo/web-editor/./node_modules/ol-ext/interaction/Offset.js","webpack://@openeo/web-editor/./node_modules/ol-ext/interaction/Split.js","webpack://@openeo/web-editor/./node_modules/ol-ext/interaction/Transform.js","webpack://@openeo/web-editor/./node_modules/ol-ext/source/Vector.js","webpack://@openeo/web-editor/./node_modules/ol-ext/interaction/UndoRedo.js","webpack://@openeo/web-editor/./node_modules/ol-ext/style/defaultStyle.js","webpack://@openeo/web-editor/./node_modules/ol/geom/Circle.js","webpack://@openeo/web-editor/./node_modules/ol/interaction/Draw.js","webpack://@openeo/web-editor/./node_modules/ol/interaction/Extent.js","webpack://@openeo/web-editor/./node_modules/ol/events/SnapEvent.js","webpack://@openeo/web-editor/./node_modules/ol/interaction/Snap.js"],"sourcesContent":["/*\tCopyright (c) 2016 Jean-Marc VIGLINO,\r\nreleased under the CeCILL-B license (French BSD license)\r\n(http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).\r\n*/\r\n\r\nimport ol_control_Button from \"./Button.js\";\r\n\r\n/** A simple push button control drawn as text\r\n * @constructor\r\n * @extends {ol_control_Button}\r\n * @param {Object=} options Control options.\r\n *\t@param {String} options.className class of the control\r\n*\t@param {String} options.title title of the control\r\n*\t@param {String} options.html html to insert in the control\r\n*\t@param {function} options.handleClick callback when control is clicked (or use change:active event)\r\n*/\r\nvar ol_control_TextButton = class olcontrolTextButton extends ol_control_Button {\r\n  constructor(options) {\r\n    options = options || {};\r\n    options.className = (options.className || '') + ' ol-text-button';\r\n    super(options);\r\n  }\r\n}\r\n\r\nexport default ol_control_TextButton\r\n","/*\tCopyright (c) 2016 Jean-Marc VIGLINO,\r\n  released under the CeCILL-B license (French BSD license)\r\n  (http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).\r\n*/\r\n\r\nimport ol_control_Button from './Button.js'\r\n\r\n/** A simple toggle control\r\n * The control can be created with an interaction to control its activation.\r\n *\r\n * @constructor\r\n * @extends {ol_control_Button}\r\n * @fires change:active, change:disable\r\n * @param {Object=} options Control options.\r\n *  @param {String} options.className class of the control\r\n *  @param {String} options.title title of the control\r\n *  @param {String} options.html html to insert in the control\r\n *  @param {ol.interaction} options.interaction interaction associated with the control\r\n *  @param {bool} options.active the control is created active, default false\r\n *  @param {bool} options.disable the control is created disabled, default false\r\n *  @param {ol.control.Bar} options.bar a subbar associated with the control (drawn when active if control is nested in a ol.control.Bar)\r\n *  @param {bool} options.autoActive the control will activate when shown in an ol.control.Bar, default false\r\n *  @param {function} options.onToggle callback when control is clicked (or use change:active event)\r\n */\r\nvar ol_control_Toggle = class olcontrolToggle extends ol_control_Button {\r\n  constructor(options) {\r\n    options = options || {};\r\n\r\n    if (options.toggleFn) {\r\n      options.onToggle = options.toggleFn; // compat old version\r\n    }\r\n    options.handleClick = function () {\r\n      self.toggle();\r\n      if (options.onToggle) {\r\n        options.onToggle.call(self, self.getActive());\r\n      }\r\n    };\r\n    options.className = (options.className || '') + ' ol-toggle';\r\n    super(options);\r\n\r\n    var self = this;\r\n\r\n    this.interaction_ = options.interaction;\r\n    if (this.interaction_) {\r\n      this.interaction_.setActive(options.active);\r\n      this.interaction_.on(\"change:active\", function () {\r\n        self.setActive(self.interaction_.getActive());\r\n      });\r\n    }\r\n\r\n    this.set(\"title\", options.title);\r\n\r\n    this.set(\"autoActivate\", options.autoActivate);\r\n    if (options.bar)\r\n      this.setSubBar(options.bar);\r\n\r\n    this.setActive(options.active);\r\n    this.setDisable(options.disable);\r\n  }\r\n  /**\r\n   * Set the map instance the control is associated with\r\n   * and add interaction attached to it to this map.\r\n   * @param {_ol_Map_} map The map instance.\r\n   */\r\n  setMap(map) {\r\n    if (!map && this.getMap()) {\r\n      if (this.interaction_) {\r\n        this.getMap().removeInteraction(this.interaction_);\r\n      }\r\n      if (this.subbar_)\r\n        this.getMap().removeControl(this.subbar_);\r\n    }\r\n\r\n    super.setMap(map);\r\n\r\n    if (map) {\r\n      if (this.interaction_)\r\n        map.addInteraction(this.interaction_);\r\n      if (this.subbar_)\r\n        map.addControl(this.subbar_);\r\n    }\r\n  }\r\n  /** Get the subbar associated with a control\r\n   * @return {ol_control_Bar}\r\n   */\r\n  getSubBar() {\r\n    return this.subbar_;\r\n  }\r\n  /** Set the subbar associated with a control\r\n   * @param {ol_control_Bar} [bar] a subbar if none remove the current subbar\r\n   */\r\n  setSubBar(bar) {\r\n    var map = this.getMap();\r\n    if (map && this.subbar_)\r\n      map.removeControl(this.subbar_);\r\n    this.subbar_ = bar;\r\n    if (bar) {\r\n      this.subbar_.setTarget(this.element);\r\n      this.subbar_.element.classList.add(\"ol-option-bar\");\r\n      if (map)\r\n        map.addControl(this.subbar_);\r\n    }\r\n  }\r\n  /**\r\n   * Test if the control is disabled.\r\n   * @return {bool}\r\n   * @api stable\r\n   */\r\n  getDisable() {\r\n    var button = this.element.querySelector('button');\r\n    return button && button.disabled;\r\n  }\r\n  /** Disable the control. If disable, the control will be deactivated too.\r\n  * @param {bool} b disable (or enable) the control, default false (enable)\r\n  */\r\n  setDisable(b) {\r\n    if (this.getDisable() == b) return;\r\n    this.element.querySelector('button').disabled = b;\r\n    if (b && this.getActive()) this.setActive(false);\r\n\r\n    this.dispatchEvent({ type: 'change:disable', key: 'disable', oldValue: !b, disable: b });\r\n  }\r\n  /**\r\n   * Test if the control is active.\r\n   * @return {bool}.\r\n   * @api stable\r\n   */\r\n  getActive() {\r\n    return this.element.classList.contains(\"ol-active\");\r\n  }\r\n  /** Toggle control state active/deactive\r\n   */\r\n  toggle() {\r\n    if (this.getActive())\r\n      this.setActive(false);\r\n    else\r\n      this.setActive(true);\r\n  }\r\n  /** Change control state\r\n   * @param {bool} b activate or deactivate the control, default false\r\n   */\r\n  setActive(b) {\r\n    if (this.interaction_)\r\n      this.interaction_.setActive(b);\r\n    if (this.subbar_)\r\n      this.subbar_.setActive(b);\r\n    if (this.getActive() === b)\r\n      return;\r\n    if (b)\r\n      this.element.classList.add(\"ol-active\");\r\n    else\r\n      this.element.classList.remove(\"ol-active\");\r\n\r\n    this.dispatchEvent({ type: 'change:active', key: 'active', oldValue: !b, active: b });\r\n  }\r\n  /** Set the control interaction\r\n  * @param {_ol_interaction_} i interaction to associate with the control\r\n  */\r\n  setInteraction(i) {\r\n    this.interaction_ = i;\r\n  }\r\n  /** Get the control interaction\r\n  * @return {_ol_interaction_} interaction associated with the control\r\n  */\r\n  getInteraction() {\r\n    return this.interaction_;\r\n  }\r\n}\r\n\r\nexport default ol_control_Toggle\r\n","/*\tCopyright (c) 2016 Jean-Marc VIGLINO, \r\n  released under the CeCILL-B license (French BSD license)\r\n  (http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).\r\n\r\n  Usefull function to handle geometric operations\r\n*/\r\n\r\nimport ol_geom_LineString from 'ol/geom/LineString.js'\r\nimport ol_geom_LinearRing from 'ol/geom/LinearRing.js'\r\nimport ol_geom_MultiLineString from 'ol/geom/MultiLineString.js'\r\nimport ol_geom_MultiPoint from 'ol/geom/MultiPoint.js'\r\nimport ol_geom_MultiPolygon from 'ol/geom/MultiPolygon.js'\r\nimport ol_geom_Point from 'ol/geom/Point.js'\r\nimport ol_geom_Polygon from 'ol/geom/Polygon.js'\r\nimport ol_geom_Circle from 'ol/geom/Circle.js'\r\nimport {getCenter as ol_extent_getCenter} from 'ol/extent.js'\r\nimport {buffer as ol_extent_buffer} from 'ol/extent.js'\r\n\r\n/** Distance beetween 2 points\r\n *\tUsefull geometric functions\r\n * @param {ol.Coordinate} p1 first point\r\n * @param {ol.Coordinate} p2 second point\r\n * @return {number} distance\r\n */\r\nvar ol_coordinate_dist2d = function(p1, p2) {\r\n  var dx = p1[0]-p2[0];\r\n  var dy = p1[1]-p2[1];\r\n  return Math.sqrt(dx*dx+dy*dy);\r\n}\r\n\r\n/** 2 points are equal\r\n *\tUsefull geometric functions\r\n * @param {ol.Coordinate} p1 first point\r\n * @param {ol.Coordinate} p2 second point\r\n * @return {boolean}\r\n */\r\nvar ol_coordinate_equal = function(p1, p2) {\r\n  return (p1[0]==p2[0] && p1[1]==p2[1]);\r\n}\r\n\r\n/** Get center coordinate of a feature\r\n * @param {ol.Feature} f\r\n * @return {ol.coordinate} the center\r\n */\r\nvar ol_coordinate_getFeatureCenter = function(f) {\r\n  return ol_coordinate_getGeomCenter (f.getGeometry());\r\n};\r\n\r\n/** Get center coordinate of a geometry\r\n* @param {ol.geom.Geometry} geom\r\n* @return {ol.Coordinate} the center\r\n*/\r\nvar ol_coordinate_getGeomCenter = function(geom) {\r\n  switch (geom.getType()) {\r\n    case 'Point': \r\n      return geom.getCoordinates();\r\n    case \"MultiPolygon\":\r\n      geom = geom.getPolygon(0);\r\n      // fallthrough\r\n    case \"Polygon\":\r\n      return geom.getInteriorPoint().getCoordinates();\r\n    default:\r\n      return geom.getClosestPoint(ol_extent_getCenter(geom.getExtent()));\r\n  }\r\n};\r\n\r\n/** Offset a polyline\r\n * @param {Array<ol.Coordinate>} coords\r\n * @param {number} offset\r\n * @return {Array<ol.Coordinate>} resulting coord\r\n * @see http://stackoverflow.com/a/11970006/796832\r\n * @see https://drive.google.com/viewerng/viewer?a=v&pid=sites&srcid=ZGVmYXVsdGRvbWFpbnxqa2dhZGdldHN0b3JlfGd4OjQ4MzI5M2Y0MjNmNzI2MjY\r\n */\r\nvar ol_coordinate_offsetCoords = function (coords, offset) {\r\n  var path = [];\r\n  var N = coords.length-1;\r\n  var max = N;\r\n  var mi, mi1, li, li1, ri, ri1, si, si1, Xi1, Yi1;\r\n  var p0, p1, p2;\r\n  var isClosed = ol_coordinate_equal(coords[0],coords[N]);\r\n  if (!isClosed) {\r\n    p0 = coords[0];\r\n    p1 = coords[1];\r\n    p2 = [\r\n      p0[0] + (p1[1] - p0[1]) / ol_coordinate_dist2d(p0,p1) *offset,\r\n      p0[1] - (p1[0] - p0[0]) / ol_coordinate_dist2d(p0,p1) *offset\r\n    ];\r\n    path.push(p2);\r\n    coords.push(coords[N])\r\n    N++;\r\n    max--;\r\n  }\r\n  for (var i = 0; i < max; i++) {\r\n    p0 = coords[i];\r\n    p1 = coords[(i+1) % N];\r\n    p2 = coords[(i+2) % N];\r\n\r\n    mi = (p1[1] - p0[1])/(p1[0] - p0[0]);\r\n    mi1 = (p2[1] - p1[1])/(p2[0] - p1[0]);\r\n    // Prevent alignements\r\n    if (Math.abs(mi-mi1) > 1e-10) {\r\n      li = Math.sqrt((p1[0] - p0[0])*(p1[0] - p0[0])+(p1[1] - p0[1])*(p1[1] - p0[1]));\r\n      li1 = Math.sqrt((p2[0] - p1[0])*(p2[0] - p1[0])+(p2[1] - p1[1])*(p2[1] - p1[1]));\r\n      ri = p0[0] + offset*(p1[1] - p0[1])/li;\r\n      ri1 = p1[0] + offset*(p2[1] - p1[1])/li1;\r\n      si = p0[1] - offset*(p1[0] - p0[0])/li;\r\n      si1 = p1[1] - offset*(p2[0] - p1[0])/li1;\r\n      Xi1 = (mi1*ri1-mi*ri+si-si1) / (mi1-mi);\r\n      Yi1 = (mi*mi1*(ri1-ri)+mi1*si-mi*si1) / (mi1-mi);\r\n\r\n      // Correction for vertical lines\r\n      if(p1[0] - p0[0] == 0) {\r\n        Xi1 = p1[0] + offset*(p1[1] - p0[1])/Math.abs(p1[1] - p0[1]);\r\n        Yi1 = mi1*Xi1 - mi1*ri1 + si1;\r\n      }\r\n      if (p2[0] - p1[0] == 0 ) {\r\n        Xi1 = p2[0] + offset*(p2[1] - p1[1])/Math.abs(p2[1] - p1[1]);\r\n        Yi1 = mi*Xi1 - mi*ri + si;\r\n      }\r\n\r\n      path.push([Xi1, Yi1]);\r\n    }\r\n  }\r\n  if (isClosed) {\r\n    path.push(path[0]);\r\n  } else {\r\n    coords.pop();\r\n    p0 = coords[coords.length-1];\r\n    p1 = coords[coords.length-2];\r\n    p2 = [\r\n      p0[0] - (p1[1] - p0[1]) / ol_coordinate_dist2d(p0,p1) *offset,\r\n      p0[1] + (p1[0] - p0[0]) / ol_coordinate_dist2d(p0,p1) *offset\r\n    ];\r\n    path.push(p2);\r\n  }\r\n  return path;\r\n}\r\n\r\n/** Find the segment a point belongs to\r\n * @param {ol.Coordinate} pt\r\n * @param {Array<ol.Coordinate>} coords\r\n * @return {} the index (-1 if not found) and the segment\r\n */\r\nvar ol_coordinate_findSegment = function (pt, coords) {\r\n  for (var i=0; i<coords.length-1; i++) {\r\n    var p0 = coords[i];\r\n    var p1 = coords[i+1];\r\n    if (ol_coordinate_equal(pt, p0) || ol_coordinate_equal(pt, p1)) {\r\n      return { index:1, segment: [p0,p1] };\r\n    } else {\r\n      var d0 = ol_coordinate_dist2d(p0,p1);\r\n      var v0 = [ (p1[0] - p0[0]) / d0, (p1[1] - p0[1]) / d0 ];\r\n      var d1 = ol_coordinate_dist2d(p0,pt);\r\n      var v1 = [ (pt[0] - p0[0]) / d1, (pt[1] - p0[1]) / d1 ];\r\n      if (Math.abs(v0[0]*v1[1] - v0[1]*v1[0]) < 1e-10) {\r\n        return { index:1, segment: [p0,p1] };\r\n      }\r\n    }\r\n  }\r\n  return { index: -1 };\r\n};\r\n\r\n/**\r\n * Split a Polygon geom with horizontal lines\r\n * @param {Array<ol.Coordinate>} geom\r\n * @param {number} y the y to split\r\n * @param {number} n contour index\r\n * @return {Array<Array<ol.Coordinate>>}\r\n */\r\nvar ol_coordinate_splitH = function (geom, y, n) {\r\n  var x, abs;\r\n  var list = [];\r\n  for (var i=0; i<geom.length-1; i++) {\r\n    // Hole separator?\r\n    if (!geom[i].length || !geom[i+1].length) continue;\r\n    // Intersect\r\n    if (geom[i][1]<=y && geom[i+1][1]>y || geom[i][1]>=y && geom[i+1][1]<y) {\r\n      abs = (y-geom[i][1]) / (geom[i+1][1]-geom[i][1]);\r\n      x = abs * (geom[i+1][0]-geom[i][0]) + geom[i][0];\r\n      list.push ({ contour: n, index: i, pt: [x,y], abs: abs });\r\n    }\r\n  }\r\n  // Sort x\r\n  list.sort(function(a,b) { return a.pt[0] - b.pt[0] });\r\n  // Horizontal segment\r\n  var result = [];\r\n  for (var j=0; j<list.length-1; j += 2) {\r\n    result.push([list[j], list[j+1]])\r\n  }\r\n  return result;\r\n};\r\n\r\n/** Create a geometry given a type and coordinates */\r\nvar ol_geom_createFromType = function (type, coordinates) {\r\n  switch (type) {\r\n    case 'LineString': return new ol_geom_LineString(coordinates);\r\n    case 'LinearRing': return new ol_geom_LinearRing(coordinates);\r\n    case 'MultiLineString': return new ol_geom_MultiLineString(coordinates);\r\n    case 'MultiPoint': return new ol_geom_MultiPoint(coordinates);\r\n    case 'MultiPolygon': return new ol_geom_MultiPolygon(coordinates);\r\n    case 'Point': return new ol_geom_Point(coordinates);\r\n    case 'Polygon': return new ol_geom_Polygon(coordinates);\r\n    default:\r\n      console.error('[createFromType] Unsupported type: '+type);\r\n      return null;\r\n  }\r\n};\r\n\r\nexport {ol_geom_createFromType}\r\nexport {ol_coordinate_dist2d, ol_coordinate_equal, ol_coordinate_findSegment, ol_coordinate_getFeatureCenter, ol_coordinate_getGeomCenter, ol_coordinate_offsetCoords, ol_coordinate_splitH}\r\n\r\n/** Intersect 2 lines\r\n * @param {Arrar<ol.coordinate>} d1\r\n * @param {Arrar<ol.coordinate>} d2\r\n */\r\nvar ol_coordinate_getIntersectionPoint = function (d1, d2) {\r\n  var d1x = d1[1][0] - d1[0][0];\r\n  var d1y = d1[1][1] - d1[0][1];\r\n  var d2x = d2[1][0] - d2[0][0];\r\n  var d2y = d2[1][1] - d2[0][1];\r\n  var det = d1x * d2y - d1y * d2x;\r\n  if (det != 0) {\r\n    var k = (d1x * d1[0][1] - d1x * d2[0][1] - d1y * d1[0][0] + d1y * d2[0][0]) / det;\r\n    return [d2[0][0] + k*d2x, d2[0][1] + k*d2y];\r\n  } else {\r\n    return false;\r\n  }\r\n};\r\n\r\nexport { ol_coordinate_getIntersectionPoint }\r\n\r\nvar ol_extent_intersection;\r\n\r\n(function() {\r\n// Split at x\r\nfunction splitX(pts, x) {\r\n  var pt;\r\n  for (let i=pts.length-1; i>0; i--) {\r\n    if ((pts[i][0]>x && pts[i-1][0]<x) || (pts[i][0]<x && pts[i-1][0]>x)) {\r\n      pt = [ x, (x - pts[i][0]) / (pts[i-1][0]-pts[i][0]) * (pts[i-1][1]-pts[i][1]) + pts[i][1]];\r\n      pts.splice(i, 0, pt);\r\n    }\r\n  }\r\n}\r\n// Split at y\r\nfunction splitY(pts, y) {\r\n  var pt;\r\n  for (let i=pts.length-1; i>0; i--) {\r\n    if ((pts[i][1]>y && pts[i-1][1]<y) || (pts[i][1]<y && pts[i-1][1]>y)) {\r\n      pt = [ (y - pts[i][1]) / (pts[i-1][1]-pts[i][1]) * (pts[i-1][0]-pts[i][0]) + pts[i][0], y];\r\n      pts.splice(i, 0, pt);\r\n    }\r\n  }\r\n}\r\n\r\n/** Fast polygon intersection with an extent (used for area calculation)\r\n * @param {ol_extent_Extent} extent\r\n * @param {ol_geom_Polygon|ol_geom_MultiPolygon} polygon\r\n * @returns {ol_geom_Polygon|ol_geom_MultiPolygon|null} return null if not a polygon geometry\r\n */\r\nol_extent_intersection = function(extent, polygon) {\r\n  var poly = (polygon.getType() === 'Polygon');\r\n  if (!poly && polygon.getType() !== 'MultiPolygon') return null;\r\n  var geom = polygon.getCoordinates();\r\n  if (poly) geom = [geom];\r\n  geom.forEach(function(g) {\r\n    g.forEach(function(c) {\r\n      splitX(c, extent[0]);\r\n      splitX(c, extent[2]);\r\n      splitY(c, extent[1]);\r\n      splitY(c, extent[3]);\r\n    });\r\n  })\r\n  // Snap geom to the extent \r\n  geom.forEach(function(g) {\r\n    g.forEach(function(c) {\r\n      c.forEach(function(p) {\r\n        if (p[0]<extent[0]) p[0] = extent[0];\r\n        else if (p[0]>extent[2]) p[0] = extent[2];\r\n        if (p[1]<extent[1]) p[1] = extent[1];\r\n        else if (p[1]>extent[3]) p[1] = extent[3];\r\n      })\r\n    })\r\n  })\r\n  if (poly) {\r\n    return new ol_geom_Polygon(geom[0]);\r\n  } else {\r\n    return new ol_geom_MultiPolygon(geom);\r\n  }\r\n};\r\n})();\r\n\r\nexport { ol_extent_intersection }\r\nexport { ol_extent_intersection as extentIntersection }\r\n\r\n/** Add points along a segment\r\n * @param {ol_Coordinate} p1 \r\n * @param {ol_Coordinate} p2 \r\n * @param {number} d \r\n * @param {boolean} start include starting point, default true\r\n * @returns {Array<ol_Coordinate>}\r\n */\r\nvar ol_coordinate_sampleAt = function(p1, p2, d, start) {\r\n  var pts = [];\r\n  if (start!==false) pts.push(p1);\r\n  var dl = ol_coordinate_dist2d(p1,p2);\r\n  if (dl) {\r\n    var nb = Math.round(dl/d);\r\n    if (nb>1) {\r\n      var dx = (p2[0]-p1[0]) / nb;\r\n      var dy = (p2[1]-p1[1]) / nb;\r\n      for (var i=1; i<nb; i++) {\r\n        pts.push([p1[0] + dx*i, p1[1] + dy*i])\r\n      }\r\n    }\r\n  }\r\n  pts.push(p2);\r\n  return pts;\r\n};\r\nexport { ol_coordinate_sampleAt }\r\n\r\n/** Sample a LineString at a distance\r\n * @param {number} d\r\n * @returns {ol_geom_LineString}\r\n */\r\nol_geom_LineString.prototype.sampleAt = function(d) {\r\n  var line = this.getCoordinates();\r\n  var result = [];\r\n  for (var i=1; i<line.length; i++) {\r\n    result = result.concat(ol_coordinate_sampleAt(line[i-1], line[i], d, i===1));\r\n  }\r\n  return new ol_geom_LineString(result);\r\n};\r\n\r\n/** Sample a MultiLineString at a distance\r\n * @param {number} d\r\n * @returns {ol_geom_MultiLineString}\r\n */\r\nol_geom_MultiLineString.prototype.sampleAt = function(d) {\r\n  var lines = this.getCoordinates();\r\n  var result = [];\r\n  lines.forEach(function(p) {\r\n    var l = [];\r\n    for (var i=1; i<p.length; i++) {\r\n      l = l.concat(ol_coordinate_sampleAt(p[i-1], p[i], d, i===1));\r\n    }\r\n    result.push(l);\r\n  })\r\n  return new ol_geom_MultiLineString(result);\r\n};\r\n\r\n/** Sample a Polygon at a distance\r\n * @param {number} d\r\n * @returns {ol_geom_Polygon}\r\n */\r\nol_geom_Polygon.prototype.sampleAt = function(res) {\r\n  var poly = this.getCoordinates();\r\n  var result = [];\r\n  poly.forEach(function(p) {\r\n    var l = [];\r\n    for (var i=1; i<p.length; i++) {\r\n      l = l.concat(ol_coordinate_sampleAt(p[i-1], p[i], res, i===1));\r\n    }\r\n    result.push(l);\r\n  })\r\n  return new ol_geom_Polygon(result);\r\n};\r\n\r\n/** Sample a MultiPolygon at a distance\r\n * @param {number} res\r\n * @returns {ol_geom_MultiPolygon}\r\n */\r\nol_geom_MultiPolygon.prototype.sampleAt = function(res) {\r\n  var mpoly = this.getCoordinates();\r\n  var result = [];\r\n  mpoly.forEach(function(poly) {\r\n    var a = [];\r\n    result.push(a);\r\n    poly.forEach(function(p) {\r\n      var l = [];\r\n      for (var i=1; i<p.length; i++) {\r\n        l = l.concat(ol_coordinate_sampleAt(p[i-1], p[i], res, i===1));\r\n      }\r\n      a.push(l);\r\n    })\r\n  });\r\n  return new ol_geom_MultiPolygon(result);\r\n};\r\n\r\n/** Intersect a geometry using a circle\r\n * @param {ol_geom_Geometry} geom\r\n * @param {number} resolution circle resolution to sample the polygon on the circle, default 1\r\n * @returns {ol_geom_Geometry}\r\n */\r\nol_geom_Circle.prototype.intersection = function(geom, resolution) {\r\n  if (geom.sampleAt) {\r\n    var ext = ol_extent_buffer(this.getCenter().concat(this.getCenter()), this.getRadius());\r\n    geom = ol_extent_intersection(ext, geom);\r\n    geom = geom.simplify(resolution);\r\n    var c = this.getCenter();\r\n    var r = this.getRadius();\r\n    //var res = (resolution||1) * r / 100;\r\n    var g = geom.sampleAt(resolution).getCoordinates();\r\n    switch (geom.getType()) {\r\n      case 'Polygon': g = [g];\r\n        // fallthrough\r\n      case 'MultiPolygon': {\r\n        var hasout = false;\r\n        // var hasin = false;\r\n        var result = [];\r\n        g.forEach(function(poly) {\r\n          var a = [];\r\n          result.push(a);\r\n          poly.forEach(function(ring) {\r\n            var l = [];\r\n            a.push(l);\r\n            ring.forEach(function(p) {\r\n              var d = ol_coordinate_dist2d(c, p);\r\n              if (d > r) {\r\n                hasout = true;\r\n                l.push([\r\n                  c[0] + r / d * (p[0]-c[0]),\r\n                  c[1] + r / d * (p[1]-c[1])\r\n                ]);\r\n              } else {\r\n                // hasin = true;\r\n                l.push(p);\r\n              }\r\n            });\r\n          })\r\n        });\r\n        if (!hasout) return geom;\r\n        if (geom.getType() === 'Polygon') {\r\n          return new ol_geom_Polygon(result[0]);\r\n        } else {\r\n          return new ol_geom_MultiPolygon(result);\r\n        }\r\n      }\r\n    }\r\n  } else {\r\n    console.warn('[ol/geom/Circle~intersection] Unsupported geometry type: '+geom.getType());\r\n  }\r\n  return geom;\r\n};\r\n","import {ol_coordinate_equal} from \"./GeomUtils.js\";\r\nimport ol_geom_LineString from \"ol/geom/LineString.js\";\r\n\r\n/** Split a lineString by a point or a list of points\r\n *\tNB: points must be on the line, use getClosestPoint() to get one\r\n * @param {ol.Coordinate | Array<ol.Coordinate>} pt points to split the line\r\n * @param {Number} tol distance tolerance for 2 points to be equal\r\n */\r\nol_geom_LineString.prototype.splitAt = function(pt, tol) {\r\n  var i;\r\n  if (!pt) return [this];\r\n    if (!tol) tol = 1e-10;\r\n    // Test if list of points\r\n    if (pt.length && pt[0].length) {\r\n      var result = [this];\r\n      for (i=0; i<pt.length; i++) {\r\n        var r = [];\r\n        for (var k=0; k<result.length; k++) {\r\n          var ri = result[k].splitAt(pt[i], tol);\r\n          r = r.concat(ri);\r\n        }\r\n        result = r;\r\n      }\r\n      return result;\r\n    }\r\n    // Nothing to do\r\n    if (ol_coordinate_equal(pt,this.getFirstCoordinate())\r\n    || ol_coordinate_equal(pt,this.getLastCoordinate())) {\r\n      return [this];\r\n    }\r\n    // Get\r\n    var c0 = this.getCoordinates();\r\n    var ci=[c0[0]];\r\n    var c = [];\r\n    for (i=0; i<c0.length-1; i++) {\r\n      // Filter equal points\r\n      if (ol_coordinate_equal(c0[i],c0[i+1])) continue;\r\n      // Extremity found\r\n      if (ol_coordinate_equal(pt,c0[i+1])) {\r\n        ci.push(c0[i+1]);\r\n        c.push(new ol_geom_LineString(ci));\r\n        ci = [];\r\n      }\r\n      // Test alignement\r\n      else if (!ol_coordinate_equal(pt,c0[i])) {\r\n        var d1, d2, split=false;\r\n        if (c0[i][0] == c0[i+1][0]) {\r\n          d1 = (c0[i][1]-pt[1]) / (c0[i][1]-c0[i+1][1]);\r\n          split = (c0[i][0] == pt[0]) && (0 < d1 && d1 <= 1)\r\n        } else if (c0[i][1] == c0[i+1][1]) {\r\n          d1 = (c0[i][0]-pt[0]) / (c0[i][0]-c0[i+1][0]);\r\n          split = (c0[i][1] == pt[1]) && (0 < d1 && d1 <= 1)\r\n        } else {\r\n          d1 = (c0[i][0]-pt[0]) / (c0[i][0]-c0[i+1][0]);\r\n          d2 = (c0[i][1]-pt[1]) / (c0[i][1]-c0[i+1][1]);\r\n          split = (Math.abs(d1-d2) <= tol && 0 < d1 && d1 <= 1)\r\n        }\r\n        // pt is inside the segment > split\r\n        if (split) {\r\n          ci.push(pt);\r\n          c.push (new ol_geom_LineString(ci));\r\n          ci = [pt];\r\n        }\r\n      }\r\n      ci.push(c0[i+1]);\r\n    }\r\n    if (ci.length>1) c.push (new ol_geom_LineString(ci));\r\n    if (c.length) return c;\r\n    else return [this];\r\n}\r\n\r\n// import('ol-ext/geom/LineStringSplitAt')","/*\tCopyright (c) 2018 Jean-Marc VIGLINO, \r\n\treleased under the CeCILL-B license (French BSD license)\r\n\t(http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).\r\n*/\r\n\r\nimport ol_interaction_Select from 'ol/interaction/Select.js'\r\nimport ol_source_Vector from 'ol/source/Vector.js'\r\n\r\n/** A Select interaction to delete features on click.\r\n * @constructor\r\n * @extends {ol_interaction_Interaction}\r\n * @fires deletestart\r\n * @fires deleteend\r\n * @param {Object} options ol.interaction.Select options\r\n */\r\nvar ol_interaction_Delete = class olinteractionDelete extends ol_interaction_Select {\r\n  constructor(options) {\r\n    super(options);\r\n    this.on('select', function (e) {\r\n      this.getFeatures().clear();\r\n      this.delete(e.selected);\r\n    }.bind(this));\r\n  }\r\n  /** Get vector source of the map\r\n   * @return {Array<ol.source.Vector>}\r\n   */\r\n  _getSources(layers) {\r\n    if (!this.getMap())\r\n      return [];\r\n    if (!layers)\r\n      layers = this.getMap().getLayers();\r\n    var sources = [];\r\n    layers.forEach(function (l) {\r\n      // LayerGroup\r\n      if (l.getLayers) {\r\n        sources = sources.concat(this._getSources(l.getLayers()));\r\n      } else {\r\n        if (l.getSource && l.getSource() instanceof ol_source_Vector) {\r\n          sources.push(l.getSource());\r\n        }\r\n      }\r\n    }.bind(this));\r\n    return sources;\r\n  }\r\n  /** Delete features: remove the features from the map (from all layers in the map)\r\n   * @param {ol.Collection<ol.Feature>|Array<ol.Feature>} features The features to delete\r\n   * @api\r\n   */\r\n  delete(features) {\r\n    if (features && (features.length || features.getLength())) {\r\n      this.dispatchEvent({ type: 'deletestart', features: features });\r\n      var delFeatures = [];\r\n      // Get the sources concerned\r\n      this._getSources().forEach(function (source) {\r\n        try {\r\n          // Try to delete features in the source\r\n          features.forEach(function (f) {\r\n            source.removeFeature(f);\r\n            delFeatures.push(f);\r\n          });\r\n        } catch (e) { /* ok */ }\r\n      });\r\n      this.dispatchEvent({ type: 'deleteend', features: delFeatures });\r\n    }\r\n  }\r\n}\r\n\r\nexport default ol_interaction_Delete","/*\tCopyright (c) 2017 Jean-Marc VIGLINO, \r\n  released under the CeCILL-B license (French BSD license)\r\n  (http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).\r\n*/\r\n\r\nimport ol_geom_Polygon from 'ol/geom/Polygon.js'\r\nimport ol_geom_MultiPolygon from 'ol/geom/MultiPolygon.js'\r\nimport ol_geom_LinearRing from 'ol/geom/LinearRing.js'\r\nimport ol_interaction_Draw from 'ol/interaction/Draw.js'\r\nimport ol_interaction_Select from 'ol/interaction/Select.js'\r\n\r\n/** Interaction to draw holes in a polygon.\r\n * It fires a drawstart, drawend event when drawing the hole\r\n * and a modifystart, modifyend event before and after inserting the hole in the feature geometry.\r\n * @constructor\r\n * @extends {ol_interaction_Interaction}\r\n * @fires drawstart\r\n * @fires drawend\r\n * @fires modifystart\r\n * @fires modifyend\r\n * @param {olx.interaction.DrawHoleOptions} options extend olx.interaction.DrawOptions\r\n * \t@param {Array<ol.layer.Vector> | function | undefined} options.layers A list of layers from which polygons should be selected. Alternatively, a filter function can be provided. default: all visible layers\r\n * \t@param {Array<ol.Feature> | ol.Collection<ol.Feature> | function | undefined} options.featureFilter An array or a collection of features the interaction applies on or a function that takes a feature and a layer and returns true if the feature is a candidate\r\n * \t@param { ol.style.Style | Array<ol.style.Style> | StyleFunction | undefined }\tStyle for the selected features, default: default edit style\r\n * \t@param {function | undefined}\toptions.geometryFunction Draw interaction geometry function to customize the hole\r\n */\r\nvar ol_interaction_DrawHole = class olinteractionDrawHole extends ol_interaction_Draw {\r\n  constructor(options) {\r\n    options = options || {}\r\n    // Geometry function that test points inside the current selection\r\n    var _geometryFn = function(coordinates, geometry) {\r\n      var coord = coordinates[0].pop()\r\n      if (!this.getPolygon() || this.getPolygon().intersectsCoordinate(coord)) {\r\n        this.lastOKCoord = [coord[0], coord[1]]\r\n      }\r\n      coordinates[0].push([this.lastOKCoord[0], this.lastOKCoord[1]])\r\n  \r\n      if (geometry) {\r\n        geometry.setCoordinates([coordinates[0].concat([coordinates[0][0]])])\r\n      } else {\r\n        geometry = new ol_geom_Polygon(coordinates)\r\n      }\r\n      return geometry\r\n    }\r\n    var geomFn = options.geometryFunction\r\n    if (geomFn) {\r\n      options.geometryFunction = function (c, g, p) {\r\n        g = _geometryFn.bind(this)(c, g)\r\n        return geomFn.bind(this)(c, g, p)\r\n      }\r\n    } else {\r\n      options.geometryFunction = _geometryFn\r\n    }\r\n\r\n    // Create draw interaction\r\n    options.type = 'Polygon';\r\n    super(options)\r\n    \r\n    // Select interaction for the current feature\r\n    this._select = new ol_interaction_Select({ style: options.style })\r\n    this._select.setActive(false)\r\n\r\n    // Layer filter function\r\n    if (options.layers) {\r\n      if (typeof (options.layers) === 'function') {\r\n        this.layers_ = options.layers\r\n      } else if (options.layers.indexOf) {\r\n        this.layers_ = function (l) {\r\n          return (options.layers.indexOf(l) >= 0)\r\n        }\r\n      }\r\n    }\r\n\r\n    // Features to apply on \r\n    if (typeof (options.featureFilter) === 'function') {\r\n      this._features = options.featureFilter\r\n    } else if (options.featureFilter) {\r\n      var features = options.featureFilter\r\n      this._features = function (f) {\r\n        if (features.indexOf) {\r\n          return !!features[features.indexOf(f)]\r\n        } else {\r\n          return !!features.item(features.getArray().indexOf(f))\r\n        }\r\n      }\r\n    } else {\r\n      this._features = function () { return true }\r\n    }\r\n\r\n    // Start drawing if inside a feature\r\n    this.on('drawstart', this._startDrawing.bind(this))\r\n    // End drawing add the hole to the current Polygon\r\n    this.on('drawend', this._finishDrawing.bind(this))\r\n  }\r\n\r\n  /**\r\n   * Remove the interaction from its current map, if any,  and attach it to a new\r\n   * map, if any. Pass `null` to just remove the interaction from the current map.\r\n   * @param {ol.Map} map Map.\r\n   * @api stable\r\n   */\r\n  setMap(map) {\r\n    // Remove previous selection\r\n    if (this.getMap()) this.getMap().removeInteraction(this._select)\r\n    // Add new one\r\n    if (map) map.addInteraction(this._select)\r\n    super.setMap.call(this, map)\r\n  }\r\n  /**\r\n   * Activate/deactivate the interaction\r\n   * @param {boolean}\r\n   * @api stable\r\n   */\r\n  setActive(b) {\r\n    if (this._select) this._select.getFeatures().clear()\r\n    super.setActive.call(this, b)\r\n  }\r\n  /**\r\n   * Remove last point of the feature currently being drawn\r\n   * (test if points to remove before).\r\n   */\r\n  removeLastPoint() {\r\n    if (this._feature && this._feature.getGeometry().getCoordinates()[0].length > 2) {\r\n      super.removeLastPoint.call(this)\r\n    }\r\n  }\r\n  /**\r\n   * Get the current polygon to hole\r\n   * @return {ol.Feature}\r\n   */\r\n  getPolygon() {\r\n    return this._polygon\r\n    // return this._select.getFeatures().item(0).getGeometry();\r\n  }\r\n  /**\r\n   * Get current feature to add a hole and start drawing\r\n   * @param {ol_interaction_Draw.Event} e\r\n   * @private\r\n   */\r\n  _startDrawing(e) {\r\n    var map = this.getMap()\r\n    this._feature = e.feature\r\n    var coord = e.feature.getGeometry().getCoordinates()[0][0]\r\n    this._current = null\r\n    // Check object under the pointer\r\n    map.forEachFeatureAtPixel(\r\n      map.getPixelFromCoordinate(coord),\r\n      function (feature, layer) {\r\n        // Not yet found?\r\n        if (!this._current && this._features(feature, layer)) {\r\n          var poly = feature.getGeometry()\r\n          if (poly.getType() === \"Polygon\"\r\n            && poly.intersectsCoordinate(coord)) {\r\n            this._polygonIndex = false\r\n            this._polygon = poly\r\n            this._current = feature\r\n          } else if (poly.getType() === \"MultiPolygon\"\r\n            && poly.intersectsCoordinate(coord)) {\r\n            for (var i = 0, p; p = poly.getPolygon(i); i++) {\r\n              if (p.intersectsCoordinate(coord)) {\r\n                this._polygonIndex = i\r\n                this._polygon = p\r\n                this._current = feature\r\n                break\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }.bind(this), {\r\n      layerFilter: this.layers_\r\n    }\r\n    )\r\n    this._select.getFeatures().clear()\r\n    if (!this._current) {\r\n      this.setActive(false)\r\n      this.setActive(true)\r\n    } else {\r\n      this._select.getFeatures().push(this._current)\r\n    }\r\n  }\r\n  /**\r\n   * Stop drawing and add the sketch feature to the target feature.\r\n   * @param {ol_interaction_Draw.Event} e\r\n   * @private\r\n   */\r\n  _finishDrawing(e) {\r\n    // The feature is the hole\r\n    e.hole = e.feature\r\n    // Get the current feature\r\n    e.feature = this._select.getFeatures().item(0)\r\n    this.dispatchEvent({ type: 'modifystart', features: [this._current] })\r\n    // Create the hole\r\n    var c = e.hole.getGeometry().getCoordinates()[0]\r\n    if (c.length > 3) {\r\n      if (this._polygonIndex !== false) {\r\n        var geom = e.feature.getGeometry()\r\n        var newGeom = new ol_geom_MultiPolygon([])\r\n        for (var i = 0, pi; pi = geom.getPolygon(i); i++) {\r\n          if (i === this._polygonIndex) {\r\n            pi.appendLinearRing(new ol_geom_LinearRing(c))\r\n            newGeom.appendPolygon(pi)\r\n          } else {\r\n            newGeom.appendPolygon(pi)\r\n          }\r\n        }\r\n        e.feature.setGeometry(newGeom)\r\n      } else {\r\n        this.getPolygon().appendLinearRing(new ol_geom_LinearRing(c))\r\n      }\r\n    }\r\n    this.dispatchEvent({ type: 'modifyend', features: [this._current] })\r\n    // reset\r\n    this._feature = null\r\n    this._select.getFeatures().clear()\r\n  }\r\n  /**\r\n   * Function that is called when a geometry's coordinates are updated.\r\n   * @param {Array<ol.coordinate>} coordinates\r\n   * @param {ol_geom_Polygon} geometry\r\n   * @return {ol_geom_Polygon}\r\n   * @private\r\n   */\r\n  _geometryFn(coordinates, geometry) {\r\n    var coord = coordinates[0].pop()\r\n    if (!this.getPolygon() || this.getPolygon().intersectsCoordinate(coord)) {\r\n      this.lastOKCoord = [coord[0], coord[1]]\r\n    }\r\n    coordinates[0].push([this.lastOKCoord[0], this.lastOKCoord[1]])\r\n\r\n    if (geometry) {\r\n      geometry.setCoordinates([coordinates[0].concat([coordinates[0][0]])])\r\n    } else {\r\n      geometry = new ol_geom_Polygon(coordinates)\r\n    }\r\n    return geometry\r\n  }\r\n}\r\n\r\nexport default ol_interaction_DrawHole\r\n","/*\tCopyright (c) 2016 Jean-Marc VIGLINO, \r\n  released under the CeCILL-B license (French BSD license)\r\n  (http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).\r\n*/\r\n\r\nimport ol_interaction_Interaction from 'ol/interaction/Interaction.js'\r\nimport ol_style_Style_defaultStyle from '../style/defaultStyle.js'\r\nimport ol_Collection from 'ol/Collection.js'\r\nimport ol_layer_Vector from 'ol/layer/Vector.js'\r\nimport ol_source_Vector from 'ol/source/Vector.js'\r\nimport ol_geom_Circle from 'ol/geom/Circle.js'\r\nimport {fromCircle as ol_geom_Polygon_fromCircle} from 'ol/geom/Polygon.js'\r\nimport ol_geom_Point from 'ol/geom/Point.js'\r\nimport ol_geom_LineString from 'ol/geom/LineString.js'\r\nimport ol_geom_Polygon from 'ol/geom/Polygon.js'\r\nimport ol_Feature from 'ol/Feature.js'\r\n\r\n/** Interaction rotate\r\n * @constructor\r\n * @extends {ol_interaction_Interaction}\r\n * @fires drawstart, drawing, drawend, drawcancel\r\n * @param {olx.interaction.TransformOptions} options\r\n *  @param {Array<ol.Layer>} options.source Destination source for the drawn features\r\n *  @param {ol.Collection<ol.Feature>} options.features Destination collection for the drawn features \r\n *  @param {ol.style.Style | Array.<ol.style.Style> | ol.style.StyleFunction | undefined} options.style style for the sketch\r\n *  @param {integer} options.sides number of sides, default 0 = circle\r\n *  @param { ol.events.ConditionType | undefined } options.condition A function that takes an ol.MapBrowserEvent and returns a boolean that event should be handled. By default module:ol/events/condition.always.\r\n *  @param { ol.events.ConditionType | undefined } options.squareCondition A function that takes an ol.MapBrowserEvent and returns a boolean to draw square features. Default test shift key\r\n *  @param { ol.events.ConditionType | undefined } options.centerCondition A function that takes an ol.MapBrowserEvent and returns a boolean to draw centered features. Default check Ctrl key\r\n *  @param { bool } options.canRotate Allow rotation when centered + square, default: true\r\n *  @param { string } [options.geometryName=geometry] \r\n *  @param { number } options.clickTolerance click tolerance on touch devices, default: 6\r\n *  @param { number } options.maxCircleCoordinates Maximum number of point on a circle, default: 100\r\n */\r\nvar ol_interaction_DrawRegular = class olinteractionDrawRegular extends ol_interaction_Interaction {\r\n  constructor(options) {\r\n    options = options || {}\r\n    \r\n    super({\r\n      handleEvent: function(e) { return self.handleEvent_(e) }\r\n    })\r\n\r\n    var self = this;\r\n\r\n    this.squaredClickTolerance_ = options.clickTolerance ? options.clickTolerance * options.clickTolerance : 36\r\n    this.maxCircleCoordinates_ = options.maxCircleCoordinates || 100\r\n\r\n    // Collection of feature to transform \r\n    this.features_ = options.features\r\n    // List of layers to transform \r\n    this.source_ = options.source\r\n    // Square condition\r\n    this.conditionFn_ = options.condition\r\n    // Square condition\r\n    this.squareFn_ = options.squareCondition\r\n    // Centered condition\r\n    this.centeredFn_ = options.centerCondition\r\n    // Allow rotation when centered + square\r\n    this.canRotate_ = (options.canRotate !== false)\r\n    // Specify custom geometry name\r\n    this.geometryName_ = options.geometryName || 'geometry'\r\n\r\n    // Number of sides (default=0: circle)\r\n    this.setSides(options.sides)\r\n\r\n    // Style\r\n    var defaultStyle = ol_style_Style_defaultStyle(true)\r\n\r\n    // Create a new overlay layer for the sketch\r\n    this.sketch_ = new ol_Collection()\r\n    this.overlayLayer_ = new ol_layer_Vector({\r\n      source: new ol_source_Vector({\r\n        features: this.sketch_,\r\n        useSpatialIndex: false\r\n      }),\r\n      name: 'DrawRegular overlay',\r\n      displayInLayerSwitcher: false,\r\n      style: options.style || defaultStyle\r\n    })\r\n  }\r\n  /**\r\n   * Remove the interaction from its current map, if any,  and attach it to a new\r\n   * map, if any. Pass `null` to just remove the interaction from the current map.\r\n   * @param {ol.Map} map Map.\r\n   * @api stable\r\n   */\r\n  setMap(map) {\r\n    if (this.getMap()) this.getMap().removeLayer(this.overlayLayer_)\r\n    super.setMap(map)\r\n    this.overlayLayer_.setMap(map)\r\n  }\r\n  /**\r\n   * Activate/deactivate the interaction\r\n   * @param {boolean}\r\n   * @api stable\r\n   */\r\n  setActive(b) {\r\n    this.reset()\r\n    super.setActive(b)\r\n  }\r\n  /**\r\n   * Reset the interaction\r\n   * @api stable\r\n   */\r\n  reset() {\r\n    if (this.overlayLayer_) this.overlayLayer_.getSource().clear()\r\n    this.started_ = false\r\n  }\r\n  /**\r\n   * Set the number of sides.\r\n   * @param {int} number of sides.\r\n   * @api stable\r\n   */\r\n  setSides(nb) {\r\n    nb = parseInt(nb)\r\n    this.sides_ = nb > 2 ? nb : 0\r\n  }\r\n  /**\r\n   * Allow rotation when centered + square\r\n   * @param {bool}\r\n   * @api stable\r\n   */\r\n  canRotate(b) {\r\n    if (b === true || b === false)\r\n      this.canRotate_ = b\r\n    return this.canRotate_\r\n  }\r\n  /**\r\n   * Get the number of sides.\r\n   * @return {int} number of sides.\r\n   * @api stable\r\n   */\r\n  getSides() {\r\n    return this.sides_\r\n  }\r\n  /** Get geom of the current drawing\r\n  * @return {ol.geom.Polygon | ol.geom.Point}\r\n  */\r\n  getGeom_() {\r\n    this.overlayLayer_.getSource().clear()\r\n    if (!this.center_)\r\n      return false\r\n\r\n    var g\r\n    if (this.coord_) {\r\n      var center = this.center_\r\n      var coord = this.coord_\r\n\r\n      // Specific case: circle\r\n      var d, dmax, r, circle, centerPx\r\n      if (!this.sides_ && this.square_ && !this.centered_) {\r\n        center = [(coord[0] + center[0]) / 2, (coord[1] + center[1]) / 2]\r\n        d = [coord[0] - center[0], coord[1] - center[1]]\r\n        r = Math.sqrt(d[0] * d[0] + d[1] * d[1])\r\n        circle = new ol_geom_Circle(center, r, 'XY')\r\n        // Optimize points on the circle\r\n        centerPx = this.getMap().getPixelFromCoordinate(center)\r\n        dmax = Math.max(100, Math.abs(centerPx[0] - this.coordPx_[0]), Math.abs(centerPx[1] - this.coordPx_[1]))\r\n        dmax = Math.min(this.maxCircleCoordinates_, Math.round(dmax / 3))\r\n        return ol_geom_Polygon_fromCircle(circle, dmax, 0)\r\n      } else {\r\n        var hasrotation = this.canRotate_ && this.centered_ && this.square_\r\n        d = [coord[0] - center[0], coord[1] - center[1]]\r\n        if (this.square_ && !hasrotation) {\r\n          //var d = [coord[0] - center[0], coord[1] - center[1]];\r\n          var dm = Math.max(Math.abs(d[0]), Math.abs(d[1]))\r\n          coord = [\r\n            center[0] + (d[0] > 0 ? dm : -dm),\r\n            center[1] + (d[1] > 0 ? dm : -dm)\r\n          ]\r\n        }\r\n        r = Math.sqrt(d[0] * d[0] + d[1] * d[1])\r\n        if (r > 0) {\r\n          circle = new ol_geom_Circle(center, r, 'XY')\r\n          var a\r\n          if (hasrotation)\r\n            a = Math.atan2(d[1], d[0])\r\n          else\r\n            a = this.startAngle[this.sides_] || this.startAngle['default']\r\n\r\n          if (this.sides_) {\r\n            g = ol_geom_Polygon_fromCircle(circle, this.sides_, a)\r\n          } else {\r\n            // Optimize points on the circle\r\n            centerPx = this.getMap().getPixelFromCoordinate(this.center_)\r\n            dmax = Math.max(100, Math.abs(centerPx[0] - this.coordPx_[0]), Math.abs(centerPx[1] - this.coordPx_[1]))\r\n            dmax = Math.min(this.maxCircleCoordinates_, Math.round(dmax / (this.centered_ ? 3 : 5)))\r\n            g = ol_geom_Polygon_fromCircle(circle, dmax, 0)\r\n          }\r\n\r\n          if (hasrotation)\r\n            return g\r\n\r\n          // Scale polygon to fit extent\r\n          var ext = g.getExtent()\r\n          if (!this.centered_)\r\n            center = this.center_\r\n          else\r\n            center = [2 * this.center_[0] - this.coord_[0], 2 * this.center_[1] - this.coord_[1]]\r\n          var scx = (center[0] - coord[0]) / (ext[0] - ext[2])\r\n          var scy = (center[1] - coord[1]) / (ext[1] - ext[3])\r\n          if (this.square_) {\r\n            var sc = Math.min(Math.abs(scx), Math.abs(scy))\r\n            scx = Math.sign(scx) * sc\r\n            scy = Math.sign(scy) * sc\r\n          }\r\n          var t = [center[0] - ext[0] * scx, center[1] - ext[1] * scy]\r\n\r\n          g.applyTransform(function (g1, g2, dim) {\r\n            for (var i = 0; i < g1.length; i += dim) {\r\n              g2[i] = g1[i] * scx + t[0]\r\n              g2[i + 1] = g1[i + 1] * scy + t[1]\r\n            }\r\n            return g2\r\n          })\r\n          return g\r\n        }\r\n      }\r\n    }\r\n\r\n    // No geom => return a point\r\n    return new ol_geom_Point(this.center_)\r\n  }\r\n  /** Draw sketch\r\n  * @return {ol.Feature} The feature being drawn.\r\n  */\r\n  drawSketch_(evt) {\r\n    this.overlayLayer_.getSource().clear()\r\n    if (evt) {\r\n      this.square_ = this.squareFn_ ? this.squareFn_(evt) : evt.originalEvent.shiftKey\r\n      this.centered_ = this.centeredFn_ ? this.centeredFn_(evt) : evt.originalEvent.metaKey || evt.originalEvent.ctrlKey\r\n      var g = this.getGeom_()\r\n      if (g) {\r\n        var f = this.feature_\r\n\r\n        //f.setGeometry (g);\r\n        if (g.getType() === 'Polygon')\r\n          f.getGeometry().setCoordinates(g.getCoordinates())\r\n        this.overlayLayer_.getSource().addFeature(f)\r\n        if (this.coord_\r\n          && this.square_\r\n          && ((this.canRotate_ && this.centered_ && this.coord_) || (!this.sides_ && !this.centered_))) {\r\n          this.overlayLayer_.getSource().addFeature(new ol_Feature(new ol_geom_LineString([this.center_, this.coord_])))\r\n        }\r\n        return f\r\n      }\r\n    }\r\n  }\r\n  /** Draw sketch (Point)\r\n  */\r\n  drawPoint_(pt, noclear) {\r\n    if (!noclear)\r\n      this.overlayLayer_.getSource().clear()\r\n    this.overlayLayer_.getSource().addFeature(new ol_Feature(new ol_geom_Point(pt)))\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} evt Map browser event.\r\n   */\r\n  handleEvent_(evt) {\r\n    var dx, dy\r\n    // Event date time\r\n    this._eventTime = new Date()\r\n    switch (evt.type) {\r\n      case \"pointerdown\": {\r\n        if (this.conditionFn_ && !this.conditionFn_(evt))\r\n          break\r\n        this.downPx_ = evt.pixel\r\n        this.start_(evt)\r\n        // Test long touch\r\n        var dt = 500\r\n        this._longTouch = false\r\n        setTimeout(function () {\r\n          this._longTouch = (new Date() - this._eventTime > .9 * dt)\r\n          if (this._longTouch)\r\n            this.handleMoveEvent_(evt)\r\n        }.bind(this), dt)\r\n        break\r\n      }\r\n      case \"pointerup\": {\r\n        // Started and fisrt move\r\n        if (this.started_ && this.coord_) {\r\n          dx = this.downPx_[0] - evt.pixel[0]\r\n          dy = this.downPx_[1] - evt.pixel[1]\r\n          if (dx * dx + dy * dy <= this.squaredClickTolerance_) {\r\n            // The pointer has moved\r\n            if (this.lastEvent == \"pointermove\" || this.lastEvent == \"keydown\") {\r\n              this.end_(evt)\r\n            }\r\n\r\n            // On touch device there is no move event : terminate = click on the same point\r\n            else {\r\n              dx = this.upPx_[0] - evt.pixel[0]\r\n              dy = this.upPx_[1] - evt.pixel[1]\r\n              if (dx * dx + dy * dy <= this.squaredClickTolerance_) {\r\n                this.end_(evt)\r\n              } else {\r\n                this.handleMoveEvent_(evt)\r\n                this.drawPoint_(evt.coordinate, true)\r\n              }\r\n            }\r\n          }\r\n        }\r\n        this.upPx_ = evt.pixel\r\n        break\r\n      }\r\n      case \"pointerdrag\": {\r\n        if (this.started_) {\r\n          var centerPx = this.getMap().getPixelFromCoordinate(this.center_)\r\n          dx = centerPx[0] - evt.pixel[0]\r\n          dy = centerPx[1] - evt.pixel[1]\r\n          if (dx * dx + dy * dy <= this.squaredClickTolerance_) {\r\n            this.reset()\r\n          }\r\n        }\r\n        return !this._longTouch\r\n        // break;\r\n      }\r\n      case \"pointermove\": {\r\n        if (this.started_) {\r\n          dx = this.downPx_[0] - evt.pixel[0]\r\n          dy = this.downPx_[1] - evt.pixel[1]\r\n          if (dx * dx + dy * dy > this.squaredClickTolerance_) {\r\n            this.handleMoveEvent_(evt)\r\n            this.lastEvent = evt.type\r\n          }\r\n        }\r\n        break\r\n      }\r\n      default: {\r\n        this.lastEvent = evt.type\r\n        // Prevent zoom in on dblclick\r\n        if (this.started_ && evt.type === 'dblclick') {\r\n          //evt.stopPropagation();\r\n          return false\r\n        }\r\n        break\r\n      }\r\n    }\r\n    return true\r\n  }\r\n  /** Stop drawing.\r\n   */\r\n  finishDrawing() {\r\n    if (this.started_ && this.coord_) {\r\n      this.end_({ pixel: this.upPx_, coordinate: this.coord_ })\r\n    }\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} evt Event.\r\n   */\r\n  handleMoveEvent_(evt) {\r\n    if (this.started_) {\r\n      this.coord_ = evt.coordinate\r\n      this.coordPx_ = evt.pixel\r\n      var f = this.drawSketch_(evt)\r\n      this.dispatchEvent({\r\n        type: 'drawing',\r\n        feature: f,\r\n        pixel: evt.pixel,\r\n        startCoordinate: this.center_,\r\n        coordinate: evt.coordinate,\r\n        square: this.square_,\r\n        centered: this.centered_\r\n      })\r\n    } else {\r\n      this.drawPoint_(evt.coordinate)\r\n    }\r\n  }\r\n  /** Start an new draw\r\n   * @param {ol.MapBrowserEvent} evt Map browser event.\r\n   * @return {boolean} `false` to stop the drag sequence.\r\n   */\r\n  start_(evt) {\r\n    if (!this.started_) {\r\n      this.started_ = true\r\n      this.center_ = evt.coordinate\r\n      this.coord_ = null\r\n      var f = this.feature_ = new ol_Feature({})\r\n      f.setGeometryName(this.geometryName_ || 'geometry')\r\n      f.setGeometry(new ol_geom_Polygon([[evt.coordinate, evt.coordinate, evt.coordinate]]))\r\n      this.drawSketch_(evt)\r\n      this.dispatchEvent({ type: 'drawstart', feature: f, pixel: evt.pixel, coordinate: evt.coordinate })\r\n    } else {\r\n      this.coord_ = evt.coordinate\r\n    }\r\n  }\r\n  /** End drawing\r\n   * @param {ol.MapBrowserEvent} evt Map browser event.\r\n   * @return {boolean} `false` to stop the drag sequence.\r\n   */\r\n  end_(evt) {\r\n    this.coord_ = evt.coordinate\r\n    this.started_ = false\r\n    if (this.coord_ && (this.center_[0] !== this.coord_[0] || this.center_[1] !== this.coord_[1])) {\r\n      var f = this.feature_\r\n\r\n      f.setGeometry(this.getGeom_())\r\n      if (this.source_)\r\n        this.source_.addFeature(f)\r\n      else if (this.features_)\r\n        this.features_.push(f)\r\n      this.dispatchEvent({ type: 'drawend', feature: f, pixel: evt.pixel, coordinate: evt.coordinate, square: this.square_, centered: this.centered_ })\r\n    } else {\r\n      this.dispatchEvent({ type: 'drawcancel', feature: null, pixel: evt.pixel, coordinate: evt.coordinate, square: this.square_, centered: this.centered_ })\r\n    }\r\n\r\n    this.center_ = this.coord_ = null\r\n    this.drawSketch_()\r\n  }\r\n}\r\n\r\n/** Default start angle array for each sides\r\n*/\r\nol_interaction_DrawRegular.prototype.startAngle = {\r\n  'default':Math.PI/2,\r\n  3: -Math.PI/2,\r\n  4: Math.PI/4\r\n};\r\n\r\nexport default ol_interaction_DrawRegular\r\n","/*\tCopyright (c) 2016 Jean-Marc VIGLINO, \r\n  released under the CeCILL-B license (French BSD license)\r\n  (http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).\r\n*/\r\n\r\nimport ol_style_Style from 'ol/style/Style.js'\r\nimport ol_style_Stroke from 'ol/style/Stroke.js'\r\nimport ol_source_Vector from 'ol/source/Vector.js'\r\nimport ol_style_Fill from 'ol/style/Fill.js'\r\nimport ol_style_Circle from 'ol/style/Circle.js'\r\nimport ol_layer_Vector from 'ol/layer/Vector.js'\r\nimport ol_geom_Point from 'ol/geom/Point.js'\r\nimport ol_Feature from 'ol/Feature.js'\r\nimport ol_geom_LineString from 'ol/geom/LineString.js'\r\nimport ol_interaction_Interaction from 'ol/interaction/Interaction.js'\r\nimport {ol_coordinate_dist2d, ol_coordinate_equal} from \"../geom/GeomUtils.js\";\r\nimport {boundingExtent as ol_extent_boundingExtent} from 'ol/extent.js'\r\nimport {buffer as ol_extent_buffer} from 'ol/extent.js'\r\nimport {altKeyOnly as ol_events_condition_altKeyOnly} from 'ol/events/condition.js'\r\nimport {primaryAction as ol_events_condition_primaryAction} from 'ol/events/condition.js'\r\nimport {always as ol_events_condition_always} from 'ol/events/condition.js'\r\n\r\nimport ol_ext_element from '../util/element.js'\r\nimport '../geom/LineStringSplitAt.js'\r\n\r\n/** Interaction for modifying feature geometries. Similar to the core ol/interaction/Modify.\r\n * The interaction is more suitable to use to handle feature modification: only features concerned \r\n * by the modification are passed to the events (instead of all feature with ol/interaction/Modify)\r\n * - the modifystart event is fired before the feature is modified (no points still inserted)\r\n * - the modifyend event is fired after the modification\r\n * - it fires a modifying event\r\n * @constructor\r\n * @extends {ol_interaction_Interaction}\r\n * @fires modifystart\r\n * @fires modifying\r\n * @fires modifyend\r\n * @fires select\r\n * @param {*} options\r\n *\t@param {ol.source.Vector} options.source a source to modify (configured with useSpatialIndex set to true)\r\n *\t@param {ol.source.Vector|Array<ol.source.Vector>} options.sources a list of source to modify (configured with useSpatialIndex set to true)\r\n *  @param {ol.Collection.<ol.Feature>} options.features collection of feature to modify\r\n *  @param {integer} options.pixelTolerance Pixel tolerance for considering the pointer close enough to a segment or vertex for editing. Default is 10.\r\n *  @param {function|undefined} options.filter a filter that takes a feature and return true if it can be modified, default always true.\r\n *  @param {ol.style.Style | Array<ol.style.Style> | undefined} options.style Style for the sketch features.\r\n *  @param {ol.EventsConditionType | undefined} options.condition A function that takes an ol.MapBrowserEvent and returns a boolean to indicate whether that event will be considered to add or move a vertex to the sketch. Default is ol.events.condition.primaryAction.\r\n *  @param {ol.EventsConditionType | undefined} options.deleteCondition A function that takes an ol.MapBrowserEvent and returns a boolean to indicate whether that event should be handled. By default, ol.events.condition.singleClick with ol.events.condition.altKeyOnly results in a vertex deletion.\r\n *  @param {ol.EventsConditionType | undefined} options.insertVertexCondition A function that takes an ol.MapBrowserEvent and returns a boolean to indicate whether a new vertex can be added to the sketch features. Default is ol.events.condition.always\r\n *  @param {boolean} options.wrapX Wrap the world horizontally on the sketch overlay, default false\r\n */\r\nvar ol_interaction_ModifyFeature = class olinteractionModifyFeature extends ol_interaction_Interaction {\r\n  constructor(options) {\r\n    options = options || {}\r\n\r\n    var dragging, modifying\r\n    super({\r\n      handleEvent: function (e) {\r\n        switch (e.type) {\r\n          case 'pointerdown': {\r\n            dragging = this.handleDownEvent(e)\r\n            modifying = dragging || this._deleteCondition(e)\r\n            return !dragging\r\n          }\r\n          case 'pointerup': {\r\n            dragging = false\r\n            return this.handleUpEvent(e)\r\n          }\r\n          case 'pointerdrag': {\r\n            if (dragging)\r\n              return this.handleDragEvent(e)\r\n            else\r\n              return true\r\n          }\r\n          case 'pointermove': {\r\n            if (!dragging){\r\n              return this.handleMoveEvent(e)\r\n            } else {\r\n              return false\r\n            }\r\n          }\r\n          case 'singleclick':\r\n          case 'click': {\r\n            // Prevent click when modifying\r\n            return !modifying\r\n          }\r\n          default: return true\r\n        }\r\n      }\r\n    })\r\n\r\n    // Snap distance (in px)\r\n    this.snapDistance_ = options.pixelTolerance || 10\r\n    // Split tolerance between the calculated intersection and the geometry\r\n    this.tolerance_ = 1e-10\r\n    // Cursor\r\n    this.cursor_ = options.cursor\r\n\r\n    // List of source to split\r\n    this.sources_ = options.sources ? (options.sources instanceof Array) ? options.sources : [options.sources] : []\r\n    if (options.source) {\r\n      this.sources_.push(options.source)\r\n    }\r\n    if (options.features) {\r\n      this.sources_.push(new ol_source_Vector({ features: options.features }))\r\n    }\r\n    // Get all features candidate\r\n    this.filterSplit_ = options.filter || function () { return true }\r\n\r\n    this._condition = options.condition || ol_events_condition_primaryAction\r\n    this._deleteCondition = options.deleteCondition || ol_events_condition_altKeyOnly\r\n    this._insertVertexCondition = options.insertVertexCondition || ol_events_condition_always\r\n\r\n    // Default style\r\n    var sketchStyle = function () {\r\n      return [new ol_style_Style({\r\n        image: new ol_style_Circle({\r\n          radius: 6,\r\n          fill: new ol_style_Fill({ color: [0, 153, 255, 1] }),\r\n          stroke: new ol_style_Stroke({ color: '#FFF', width: 1.25 })\r\n        })\r\n      })\r\n      ]\r\n    }\r\n\r\n    // Custom style\r\n    if (options.style) {\r\n      if (typeof (options.style) === 'function') {\r\n        sketchStyle = options.style\r\n      } else {\r\n        sketchStyle = function () { return options.style }\r\n      }\r\n    }\r\n\r\n    // Create a new overlay for the sketch\r\n    this.overlayLayer_ = new ol_layer_Vector({\r\n      source: new ol_source_Vector({\r\n        useSpatialIndex: false\r\n      }),\r\n      name: 'Modify overlay',\r\n      displayInLayerSwitcher: false,\r\n      style: sketchStyle,\r\n      wrapX: options.wrapX\r\n    })\r\n\r\n  }\r\n  /**\r\n   * Remove the interaction from its current map, if any,  and attach it to a new\r\n   * map, if any. Pass `null` to just remove the interaction from the current map.\r\n   * @param {ol.Map} map Map.\r\n   * @api stable\r\n   */\r\n  setMap(map) {\r\n    if (this.getMap()) this.getMap().removeLayer(this.overlayLayer_)\r\n    super.setMap(map)\r\n    this.overlayLayer_.setMap(map)\r\n  }\r\n  /**\r\n   * Activate or deactivate the interaction + remove the sketch.\r\n   * @param {boolean} active.\r\n   * @api stable\r\n   */\r\n  setActive(active) {\r\n    super.setActive(active)\r\n    if (this.overlayLayer_) this.overlayLayer_.getSource().clear()\r\n  }\r\n  /** Change the filter function\r\n   * @param {function|undefined} options.filter a filter that takes a feature and return true if it can be modified, default always true.\r\n   */\r\n  setFilter(filter) {\r\n    if (typeof (filter) === 'function')\r\n      this.filterSplit_ = filter\r\n    else if (filter === undefined)\r\n      this.filterSplit_ = function () { return true }\r\n  }\r\n  /** Get closest feature at pixel\r\n   * @param {ol.Pixel}\r\n   * @return {*}\r\n   * @private\r\n   */\r\n  getClosestFeature(e) {\r\n    var f, c, d = this.snapDistance_ + 1\r\n    for (var i = 0; i < this.sources_.length; i++) {\r\n      var source = this.sources_[i]\r\n      f = source.getClosestFeatureToCoordinate(e.coordinate)\r\n      if (f && this.filterSplit_(f)) {\r\n        var ci = f.getGeometry().getClosestPoint(e.coordinate)\r\n        var di = ol_coordinate_dist2d(e.coordinate, ci) / e.frameState.viewState.resolution\r\n        if (di < d) {\r\n          d = di\r\n          c = ci\r\n        }\r\n        break\r\n      }\r\n    }\r\n    if (d > this.snapDistance_) {\r\n      if (this.currentFeature)\r\n        this.dispatchEvent({ type: 'select', selected: [], deselected: [this.currentFeature] })\r\n      this.currentFeature = null\r\n      return false\r\n    } else {\r\n      // Snap to node\r\n      var coord = this.getNearestCoord(c, f.getGeometry())\r\n      if (coord) {\r\n        coord = coord.coord\r\n        var p = this.getMap().getPixelFromCoordinate(coord)\r\n        if (ol_coordinate_dist2d(e.pixel, p) < this.snapDistance_) {\r\n          c = coord\r\n        }\r\n        //\r\n        if (this.currentFeature !== f)\r\n          this.dispatchEvent({ type: 'select', selected: [f], deselected: [this.currentFeature] })\r\n        this.currentFeature = f\r\n        return { source: source, feature: f, coord: c }\r\n      }\r\n    }\r\n  }\r\n  /** Get nearest coordinate in a list\r\n  * @param {ol.coordinate} pt the point to find nearest\r\n  * @param {ol.geom} coords list of coordinates\r\n  * @return {*} the nearest point with a coord (projected point), dist (distance to the geom), ring (if Polygon)\r\n  */\r\n  getNearestCoord(pt, geom) {\r\n    var i, l, p, p0, dm\r\n    switch (geom.getType()) {\r\n      case 'Point': {\r\n        return { coord: geom.getCoordinates(), dist: ol_coordinate_dist2d(geom.getCoordinates(), pt) }\r\n      }\r\n      case 'MultiPoint': {\r\n        return this.getNearestCoord(pt, new ol_geom_LineString(geom.getCoordinates()))\r\n      }\r\n      case 'LineString':\r\n      case 'LinearRing': {\r\n        var d\r\n        dm = Number.MAX_VALUE\r\n        var coords = geom.getCoordinates()\r\n        for (i = 0; i < coords.length; i++) {\r\n          d = ol_coordinate_dist2d(pt, coords[i])\r\n          if (d < dm) {\r\n            dm = d\r\n            p0 = coords[i]\r\n          }\r\n        }\r\n        return { coord: p0, dist: dm }\r\n      }\r\n      case 'MultiLineString': {\r\n        var lstring = geom.getLineStrings()\r\n        p0 = false, dm = Number.MAX_VALUE\r\n        for (i = 0; l = lstring[i]; i++) {\r\n          p = this.getNearestCoord(pt, l)\r\n          if (p && p.dist < dm) {\r\n            p0 = p\r\n            dm = p.dist\r\n            p0.ring = i\r\n          }\r\n        }\r\n        return p0\r\n      }\r\n      case 'Polygon': {\r\n        var lring = geom.getLinearRings()\r\n        p0 = false\r\n        dm = Number.MAX_VALUE\r\n        for (i = 0; l = lring[i]; i++) {\r\n          p = this.getNearestCoord(pt, l)\r\n          if (p && p.dist < dm) {\r\n            p0 = p\r\n            dm = p.dist\r\n            p0.ring = i\r\n          }\r\n        }\r\n        return p0\r\n      }\r\n      case 'MultiPolygon': {\r\n        var poly = geom.getPolygons()\r\n        p0 = false\r\n        dm = Number.MAX_VALUE\r\n        for (i = 0; l = poly[i]; i++) {\r\n          p = this.getNearestCoord(pt, l)\r\n          if (p && p.dist < dm) {\r\n            p0 = p\r\n            dm = p.dist\r\n            p0.poly = i\r\n          }\r\n        }\r\n        return p0\r\n      }\r\n      case 'GeometryCollection': {\r\n        var g = geom.getGeometries()\r\n        p0 = false\r\n        dm = Number.MAX_VALUE\r\n        for (i = 0; l = g[i]; i++) {\r\n          p = this.getNearestCoord(pt, l)\r\n          if (p && p.dist < dm) {\r\n            p0 = p\r\n            dm = p.dist\r\n            p0.geom = i\r\n          }\r\n        }\r\n        return p0\r\n      }\r\n      default: return false\r\n    }\r\n  }\r\n  /** Get arcs concerned by a modification\r\n   * @param {ol.geom} geom the geometry concerned\r\n   * @param {ol.coordinate} coord pointed coordinates\r\n   */\r\n  getArcs(geom, coord) {\r\n    var arcs = false\r\n    var coords, i, s, l, g\r\n    switch (geom.getType()) {\r\n      case 'Point': {\r\n        if (ol_coordinate_equal(coord, geom.getCoordinates())) {\r\n          arcs = {\r\n            geom: geom,\r\n            type: geom.getType(),\r\n            coord1: [],\r\n            coord2: [],\r\n            node: true\r\n          }\r\n        }\r\n        break\r\n      }\r\n      case 'MultiPoint': {\r\n        coords = geom.getCoordinates()\r\n        for (i = 0; i < coords.length; i++) {\r\n          if (ol_coordinate_equal(coord, coords[i])) {\r\n            arcs = {\r\n              geom: geom,\r\n              type: geom.getType(),\r\n              index: i,\r\n              coord1: [],\r\n              coord2: [],\r\n              node: true\r\n            }\r\n            break\r\n          }\r\n        }\r\n        break\r\n      }\r\n      case 'LinearRing':\r\n      case 'LineString': {\r\n        var p = geom.getClosestPoint(coord)\r\n        if (ol_coordinate_dist2d(p, coord) < 1.5 * this.tolerance_) {\r\n          var split\r\n          // Split the line in two\r\n          if (geom.getType() === 'LinearRing') {\r\n            g = new ol_geom_LineString(geom.getCoordinates())\r\n            split = g.splitAt(coord, this.tolerance_)\r\n          } else {\r\n            split = geom.splitAt(coord, this.tolerance_)\r\n          }\r\n          // If more than 2\r\n          if (split.length > 2) {\r\n            coords = split[1].getCoordinates()\r\n            for (i = 2; s = split[i]; i++) {\r\n              var c = s.getCoordinates()\r\n              c.shift()\r\n              coords = coords.concat(c)\r\n            }\r\n            split = [split[0], new ol_geom_LineString(coords)]\r\n          }\r\n          // Split in two\r\n          if (split.length === 2) {\r\n            var c0 = split[0].getCoordinates()\r\n            var c1 = split[1].getCoordinates()\r\n            var nbpt = c0.length + c1.length - 1\r\n            c0.pop()\r\n            c1.shift()\r\n            arcs = {\r\n              geom: geom,\r\n              type: geom.getType(),\r\n              coord1: c0,\r\n              coord2: c1,\r\n              node: (geom.getCoordinates().length === nbpt),\r\n              closed: false\r\n            }\r\n          } else if (split.length === 1) {\r\n            s = split[0].getCoordinates()\r\n            var start = ol_coordinate_equal(s[0], coord)\r\n            var end = ol_coordinate_equal(s[s.length - 1], coord)\r\n            // Move first point\r\n            if (start) {\r\n              s.shift()\r\n              if (end)\r\n                s.pop()\r\n              arcs = {\r\n                geom: geom,\r\n                type: geom.getType(),\r\n                coord1: [],\r\n                coord2: s,\r\n                node: true,\r\n                closed: end\r\n              }\r\n            } else if (end) {\r\n              // Move last point\r\n              s.pop()\r\n              arcs = {\r\n                geom: geom,\r\n                type: geom.getType(),\r\n                coord1: s,\r\n                coord2: [],\r\n                node: true,\r\n                closed: false\r\n              }\r\n            }\r\n          }\r\n        }\r\n        break\r\n      }\r\n      case 'MultiLineString': {\r\n        var lstring = geom.getLineStrings()\r\n        for (i = 0; l = lstring[i]; i++) {\r\n          arcs = this.getArcs(l, coord)\r\n          if (arcs) {\r\n            arcs.geom = geom\r\n            arcs.type = geom.getType()\r\n            arcs.lstring = i\r\n            break\r\n          }\r\n        }\r\n        break\r\n      }\r\n      case 'Polygon': {\r\n        var lring = geom.getLinearRings()\r\n        for (i = 0; l = lring[i]; i++) {\r\n          arcs = this.getArcs(l, coord)\r\n          if (arcs) {\r\n            arcs.geom = geom\r\n            arcs.type = geom.getType()\r\n            arcs.index = i\r\n            break\r\n          }\r\n        }\r\n        break\r\n      }\r\n      case 'MultiPolygon': {\r\n        var poly = geom.getPolygons()\r\n        for (i = 0; l = poly[i]; i++) {\r\n          arcs = this.getArcs(l, coord)\r\n          if (arcs) {\r\n            arcs.geom = geom\r\n            arcs.type = geom.getType()\r\n            arcs.poly = i\r\n            break\r\n          }\r\n        }\r\n        break\r\n      }\r\n      case 'GeometryCollection': {\r\n        g = geom.getGeometries()\r\n        for (i = 0; l = g[i]; i++) {\r\n          arcs = this.getArcs(l, coord)\r\n          if (arcs) {\r\n            arcs.geom = geom\r\n            arcs.g = i\r\n            arcs.typeg = arcs.type\r\n            arcs.type = geom.getType()\r\n            break\r\n          }\r\n        }\r\n        break\r\n      }\r\n      default: {\r\n        console.error('ol/interaction/ModifyFeature ' + geom.getType() + ' not supported!')\r\n        break\r\n      }\r\n    }\r\n    return arcs\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} evt Map browser event.\r\n   * @return {boolean} `true` to start the drag sequence.\r\n   */\r\n  handleDownEvent(evt) {\r\n    if (!this.getActive())\r\n      return false\r\n\r\n    // Something to move ?\r\n    var current = this.getClosestFeature(evt)\r\n\r\n    if (current && (this._condition(evt) || this._deleteCondition(evt))) {\r\n      var features = []\r\n      this.arcs = []\r\n\r\n      // Get features concerned\r\n      this.sources_.forEach(function (s) {\r\n        var extent = ol_extent_buffer(ol_extent_boundingExtent([current.coord]), this.tolerance_)\r\n        features = features.concat(features, s.getFeaturesInExtent(extent))\r\n      }.bind(this))\r\n\r\n      // Get arcs concerned\r\n      this._modifiedFeatures = []\r\n      features.forEach(function (f) {\r\n        var a = this.getArcs(f.getGeometry(), current.coord)\r\n        if (a) {\r\n          if (this._insertVertexCondition(evt) || a.node) {\r\n            a.feature = f\r\n            this._modifiedFeatures.push(f)\r\n            this.arcs.push(a)\r\n          }\r\n        }\r\n      }.bind(this))\r\n\r\n      if (this._modifiedFeatures.length) {\r\n        if (this._deleteCondition(evt)) {\r\n          return !this._removePoint(current, evt)\r\n        } else {\r\n          this.dispatchEvent({\r\n            type: 'modifystart',\r\n            coordinate: current.coord,\r\n            originalEvent: evt.originalEvent,\r\n            features: this._modifiedFeatures\r\n          })\r\n          this.handleDragEvent({\r\n            coordinate: current.coord,\r\n            originalEvent: evt.originalEvent\r\n          })\r\n          return true\r\n        }\r\n      } else {\r\n        return true\r\n      }\r\n    } else {\r\n      return false\r\n    }\r\n  }\r\n  /** Get modified features\r\n   * @return {Array<ol.Feature>} list of modified features\r\n   */\r\n  getModifiedFeatures() {\r\n    return this._modifiedFeatures || []\r\n  }\r\n  /** Removes the vertex currently being pointed.\r\n   */\r\n  removePoint() {\r\n    this._removePoint({}, {})\r\n  }\r\n  /**\r\n   * @private\r\n   */\r\n  _getModification(a) {\r\n    var coords = a.coord1.concat(a.coord2)\r\n    switch (a.type) {\r\n      case 'LineString': {\r\n        if (a.closed)\r\n          coords.push(coords[0])\r\n        if (coords.length > 1) {\r\n          if (a.geom.getCoordinates().length != coords.length) {\r\n            a.coords = coords\r\n            return true\r\n          }\r\n        }\r\n        break\r\n      }\r\n      case 'MultiLineString': {\r\n        if (a.closed)\r\n          coords.push(coords[0])\r\n        if (coords.length > 1) {\r\n          var c = a.geom.getCoordinates()\r\n          if (c[a.lstring].length != coords.length) {\r\n            c[a.lstring] = coords\r\n            a.coords = c\r\n            return true\r\n          }\r\n        }\r\n        break\r\n      }\r\n      case 'Polygon': {\r\n        if (a.closed)\r\n          coords.push(coords[0])\r\n        if (coords.length > 3) {\r\n          c = a.geom.getCoordinates()\r\n          if (c[a.index].length != coords.length) {\r\n            c[a.index] = coords\r\n            a.coords = c\r\n            return true\r\n          }\r\n        }\r\n        break\r\n      }\r\n      case 'MultiPolygon': {\r\n        if (a.closed)\r\n          coords.push(coords[0])\r\n        if (coords.length > 3) {\r\n          c = a.geom.getCoordinates()\r\n          if (c[a.poly][a.index].length != coords.length) {\r\n            c[a.poly][a.index] = coords\r\n            a.coords = c\r\n            return true\r\n          }\r\n        }\r\n        break\r\n      }\r\n      case 'GeometryCollection': {\r\n        a.type = a.typeg\r\n        var geom = a.geom\r\n        var geoms = geom.getGeometries()\r\n        a.geom = geoms[a.g]\r\n        var found = this._getModification(a)\r\n        // Restore current arc\r\n        geom.setGeometries(geoms)\r\n        a.geom = geom\r\n        a.type = 'GeometryCollection'\r\n        return found\r\n      }\r\n      default: {\r\n        //console.error('ol/interaction/ModifyFeature '+a.type+' not supported!');\r\n        break\r\n      }\r\n    }\r\n    return false\r\n  }\r\n  /** Removes the vertex currently being pointed.\r\n   * @private\r\n   */\r\n  _removePoint(current, evt) {\r\n    if (!this.arcs)\r\n      return false\r\n\r\n    this.overlayLayer_.getSource().clear()\r\n\r\n    var found = false\r\n    // Get all modifications\r\n    this.arcs.forEach(function (a) {\r\n      found = found || this._getModification(a)\r\n    }.bind(this))\r\n\r\n    // Almost one point is removed\r\n    if (found) {\r\n      this.dispatchEvent({\r\n        type: 'modifystart',\r\n        coordinate: current.coord,\r\n        originalEvent: evt.originalEvent,\r\n        features: this._modifiedFeatures\r\n      })\r\n      this.arcs.forEach(function (a) {\r\n        if (a.geom.getType() === 'GeometryCollection') {\r\n          if (a.coords) {\r\n            var geoms = a.geom.getGeometries()\r\n            geoms[a.g].setCoordinates(a.coords)\r\n            a.geom.setGeometries(geoms)\r\n          }\r\n        } else {\r\n          if (a.coords)\r\n            a.geom.setCoordinates(a.coords)\r\n        }\r\n      }.bind(this))\r\n      this.dispatchEvent({\r\n        type: 'modifyend',\r\n        coordinate: current.coord,\r\n        originalEvent: evt.originalEvent,\r\n        features: this._modifiedFeatures\r\n      })\r\n    }\r\n\r\n    this.arcs = []\r\n    return found\r\n  }\r\n  /**\r\n   * @private\r\n   */\r\n  handleUpEvent(e) {\r\n    if (!this.getActive())\r\n      return false\r\n    if (!this.arcs || !this.arcs.length)\r\n      return true\r\n\r\n    this.overlayLayer_.getSource().clear()\r\n    this.dispatchEvent({\r\n      type: 'modifyend',\r\n      coordinate: e.coordinate,\r\n      originalEvent: e.originalEvent,\r\n      features: this._modifiedFeatures\r\n    })\r\n\r\n    this.arcs = []\r\n    return true\r\n  }\r\n  /**\r\n   * @private\r\n   */\r\n  setArcCoordinates(a, coords) {\r\n    var c\r\n    switch (a.type) {\r\n      case 'Point': {\r\n        a.geom.setCoordinates(coords[0])\r\n        break\r\n      }\r\n      case 'MultiPoint': {\r\n        c = a.geom.getCoordinates()\r\n        c[a.index] = coords[0]\r\n        a.geom.setCoordinates(c)\r\n        break\r\n      }\r\n      case 'LineString': {\r\n        a.geom.setCoordinates(coords)\r\n        break\r\n      }\r\n      case 'MultiLineString': {\r\n        c = a.geom.getCoordinates()\r\n        c[a.lstring] = coords\r\n        a.geom.setCoordinates(c)\r\n        break\r\n      }\r\n      case 'Polygon': {\r\n        c = a.geom.getCoordinates()\r\n        c[a.index] = coords\r\n        a.geom.setCoordinates(c)\r\n        break\r\n      }\r\n      case 'MultiPolygon': {\r\n        c = a.geom.getCoordinates()\r\n        c[a.poly][a.index] = coords\r\n        a.geom.setCoordinates(c)\r\n        break\r\n      }\r\n      case 'GeometryCollection': {\r\n        a.type = a.typeg\r\n        var geom = a.geom\r\n        var geoms = geom.getGeometries()\r\n        a.geom = geoms[a.g]\r\n        this.setArcCoordinates(a, coords)\r\n        geom.setGeometries(geoms)\r\n        a.geom = geom\r\n        a.type = 'GeometryCollection'\r\n        break\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * @private\r\n   */\r\n  handleDragEvent(e) {\r\n    if (!this.getActive()) return false\r\n    if (!this.arcs) return true\r\n\r\n    // Show sketch\r\n    this.overlayLayer_.getSource().clear()\r\n    var p = new ol_Feature(new ol_geom_Point(e.coordinate))\r\n    this.overlayLayer_.getSource().addFeature(p)\r\n\r\n    // Nothing to do\r\n    if (!this.arcs.length) return true\r\n\r\n    // Move arcs\r\n    this.arcs.forEach(function (a) {\r\n      var coords = a.coord1.concat([e.coordinate], a.coord2)\r\n      if (a.closed) coords.push(e.coordinate)\r\n      this.setArcCoordinates(a, coords)\r\n    }.bind(this))\r\n\r\n    this.dispatchEvent({\r\n      type: 'modifying',\r\n      coordinate: e.coordinate,\r\n      originalEvent: e.originalEvent,\r\n      features: this._modifiedFeatures\r\n    })\r\n\r\n    return true\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} evt Event.\r\n   * @private\r\n   */\r\n  handleMoveEvent(e) {\r\n    if (!this.getActive()) return true\r\n\r\n    this.overlayLayer_.getSource().clear()\r\n    var current = this.getClosestFeature(e)\r\n\r\n    // Draw sketch\r\n    if (current) {\r\n      var p = new ol_Feature(new ol_geom_Point(current.coord))\r\n      this.overlayLayer_.getSource().addFeature(p)\r\n    }\r\n\r\n    // Show cursor\r\n    var element = e.map.getTargetElement()\r\n    if (this.cursor_) {\r\n      if (current) {\r\n        if (element.style.cursor != this.cursor_) {\r\n          this.previousCursor_ = element.style.cursor\r\n          ol_ext_element.setCursor(element, this.cursor_)\r\n        }\r\n      } else if (this.previousCursor_ !== undefined) {\r\n        ol_ext_element.setCursor(element, this.previousCursor_)\r\n        this.previousCursor_ = undefined\r\n      }\r\n    }\r\n    return true\r\n  }\r\n  /** Get the current feature to modify\r\n   * @return {ol.Feature}\r\n   */\r\n  getCurrentFeature() {\r\n    return this.currentFeature\r\n  }\r\n}\r\n\r\nexport default ol_interaction_ModifyFeature","/*\tCopyright (c) 2016 Jean-Marc VIGLINO, \r\n\treleased under the CeCILL-B license (French BSD license)\r\n\t(http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).\r\n*/\r\nimport ol_interaction_Pointer from 'ol/interaction/Pointer.js'\r\nimport ol_geom_LineString from 'ol/geom/LineString.js'\r\nimport ol_geom_Polygon from 'ol/geom/Polygon.js'\r\nimport {ol_coordinate_dist2d, ol_coordinate_findSegment, ol_coordinate_offsetCoords} from \"../geom/GeomUtils.js\";\r\n\r\nimport ol_style_Style_defaultStyle from '../style/defaultStyle.js'\r\nimport ol_ext_element from '../util/element.js';\r\n\r\n/** Offset interaction for offseting feature geometry\r\n * @constructor\r\n * @extends {ol_interaction_Pointer}\r\n * @fires offsetstart\r\n * @fires offsetting\r\n * @fires offsetend\r\n * @param {any} options\r\n *\t@param {function} [options.filter] a function that takes a feature and a layer and return true if the feature can be modified\r\n *\t@param {ol.layer.Vector | Array<ol.layer.Vector>} options.layers list of feature to transform \r\n *\t@param {ol.Collection.<ol.Feature>} options.features collection of feature to transform\r\n *\t@param {ol.source.Vector | undefined} options.source source to duplicate feature when ctrl key is down\r\n *\t@param {boolean} options.duplicate force feature to duplicate (source must be set)\r\n *  @param {ol.style.Style | Array.<ol.style.Style> | ol.style.StyleFunction | undefined} style style for the sketch\r\n */\r\nvar ol_interaction_Offset = class olinteractionOffset extends ol_interaction_Pointer {\r\n  constructor(options) {\r\n    options = options || {};\r\n\r\n    // Extend pointer\r\n    super({\r\n      handleDownEvent: function(e) { return self.handleDownEvent_(e) },\r\n      handleDragEvent: function(e) { return self.handleDragEvent_(e) },\r\n      handleMoveEvent: function(e) { return self.handleMoveEvent_(e) },\r\n      handleUpEvent: function(e) { return self.handleUpEvent_(e) },\r\n    });\r\n    var self = this;\r\n\r\n    this._filter = options.filter;\r\n    // Collection of feature to transform\r\n    this.features_ = options.features;\r\n    // List of layers to transform\r\n    this.layers_ = options.layers ? (options.layers instanceof Array) ? options.layers : [options.layers] : null;\r\n    // duplicate\r\n    this.set('duplicate', options.duplicate);\r\n    this.source_ = options.source;\r\n    // Style\r\n    this._style = (typeof (options.style) === 'function') ? options.style : function () {\r\n      if (options.style)\r\n        return options.style;\r\n      else\r\n        return ol_style_Style_defaultStyle(true);\r\n    };\r\n\r\n    // init\r\n    this.previousCursor_ = false;\r\n  }\r\n  /** Get Feature at pixel\r\n   * @param {ol.MapBrowserEvent} evt Map browser event.\r\n   * @return {any} a feature and the hit point\r\n   * @private\r\n   */\r\n  getFeatureAtPixel_(e) {\r\n    var self = this;\r\n    return this.getMap().forEachFeatureAtPixel(e.pixel,\r\n      function (feature, layer) {\r\n        var current;\r\n        if (self._filter && !self._filter(feature, layer))\r\n          return false;\r\n        // feature belong to a layer\r\n        if (self.layers_) {\r\n          for (var i = 0; i < self.layers_.length; i++) {\r\n            if (self.layers_[i] === layer) {\r\n              current = feature;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n\r\n        // feature in the collection\r\n        else if (self.features_) {\r\n          self.features_.forEach(function (f) {\r\n            if (f === feature) {\r\n              current = feature;\r\n            }\r\n          });\r\n        }\r\n\r\n        // Others\r\n        else {\r\n          current = feature;\r\n        }\r\n\r\n        // Only poygon or linestring\r\n        var typeGeom = current.getGeometry().getType();\r\n        if (current && /Polygon|LineString/.test(typeGeom)) {\r\n          if (typeGeom === 'Polygon' && current.getGeometry().getCoordinates().length > 1)\r\n            return false;\r\n          // test distance\r\n          var p = current.getGeometry().getClosestPoint(e.coordinate);\r\n          var dx = p[0] - e.coordinate[0];\r\n          var dy = p[1] - e.coordinate[1];\r\n          var d = Math.sqrt(dx * dx + dy * dy) / e.frameState.viewState.resolution;\r\n\r\n          if (d < 5) {\r\n            return {\r\n              feature: current,\r\n              hit: p,\r\n              coordinates: current.getGeometry().getCoordinates(),\r\n              geom: current.getGeometry().clone(),\r\n              geomType: typeGeom\r\n            };\r\n          } else {\r\n            return false;\r\n          }\r\n        } else {\r\n          return false;\r\n        }\r\n      }, { hitTolerance: 5 });\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} e Map browser event.\r\n   * @return {boolean} `true` to start the drag sequence.\r\n   * @private\r\n   */\r\n  handleDownEvent_(e) {\r\n    this.current_ = this.getFeatureAtPixel_(e);\r\n    if (this.current_) {\r\n      this.currentStyle_ = this.current_.feature.getStyle();\r\n      if (this.source_ && (this.get('duplicate') || e.originalEvent.ctrlKey)) {\r\n        this.current_.feature = this.current_.feature.clone();\r\n        this.current_.feature.setStyle(this._style(this.current_.feature));\r\n        this.source_.addFeature(this.current_.feature);\r\n      } else {\r\n        // Modify the current feature\r\n        this.current_.feature.setStyle(this._style(this.current_.feature));\r\n        this._modifystart = true;\r\n      }\r\n      this.dispatchEvent({ type: 'offsetstart', feature: this.current_.feature, offset: 0 });\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} e Map browser event.\r\n   * @private\r\n   */\r\n  handleDragEvent_(e) {\r\n    if (this._modifystart) {\r\n      this.dispatchEvent({ type: 'modifystart', features: [this.current_.feature] });\r\n      this._modifystart = false;\r\n    }\r\n    var p = this.current_.geom.getClosestPoint(e.coordinate);\r\n    var d = ol_coordinate_dist2d(p, e.coordinate);\r\n    var seg, v1, v2, offset;\r\n    switch (this.current_.geomType) {\r\n      case 'Polygon': {\r\n        seg = ol_coordinate_findSegment(p, this.current_.coordinates[0]).segment;\r\n        if (seg) {\r\n          v1 = [seg[1][0] - seg[0][0], seg[1][1] - seg[0][1]];\r\n          v2 = [e.coordinate[0] - p[0], e.coordinate[1] - p[1]];\r\n          if (v1[0] * v2[1] - v1[1] * v2[0] > 0) {\r\n            d = -d;\r\n          }\r\n\r\n          offset = [];\r\n          for (var i = 0; i < this.current_.coordinates.length; i++) {\r\n            offset.push(ol_coordinate_offsetCoords(this.current_.coordinates[i], i == 0 ? d : -d));\r\n          }\r\n          this.current_.feature.setGeometry(new ol_geom_Polygon(offset));\r\n        }\r\n        break;\r\n      }\r\n      case 'LineString': {\r\n        seg = ol_coordinate_findSegment(p, this.current_.coordinates).segment;\r\n        if (seg) {\r\n          v1 = [seg[1][0] - seg[0][0], seg[1][1] - seg[0][1]];\r\n          v2 = [e.coordinate[0] - p[0], e.coordinate[1] - p[1]];\r\n          if (v1[0] * v2[1] - v1[1] * v2[0] > 0) {\r\n            d = -d;\r\n          }\r\n          offset = ol_coordinate_offsetCoords(this.current_.coordinates, d);\r\n          this.current_.feature.setGeometry(new ol_geom_LineString(offset));\r\n        }\r\n        break;\r\n      }\r\n      default: {\r\n        break;\r\n      }\r\n    }\r\n    this.dispatchEvent({ type: 'offsetting', feature: this.current_.feature, offset: d, segment: [p, e.coordinate], coordinate: e.coordinate });\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} e Map browser event.\r\n   * @private\r\n   */\r\n  handleUpEvent_(e) {\r\n    if (!this._modifystart) {\r\n      this.dispatchEvent({ type: 'offsetend', feature: this.current_.feature, coordinate: e.coordinate });\r\n    }\r\n    this.current_.feature.setStyle(this.currentStyle_);\r\n    this.current_ = false;\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} e Event.\r\n   * @private\r\n   */\r\n  handleMoveEvent_(e) {\r\n    var f = this.getFeatureAtPixel_(e);\r\n    if (f) {\r\n      if (this.previousCursor_ === false) {\r\n        this.previousCursor_ = e.map.getTargetElement().style.cursor;\r\n      }\r\n      ol_ext_element.setCursor(e.map, 'pointer');\r\n    } else {\r\n      ol_ext_element.setCursor(e.map, this.previousCursor_);\r\n      this.previousCursor_ = false;\r\n    }\r\n  }\r\n}\r\n\r\nexport default ol_interaction_Offset\r\n","/*\tCopyright (c) 2016 Jean-Marc VIGLINO, \r\n  released under the CeCILL-B license (French BSD license)\r\n  (http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).\r\n*/\r\n\r\nimport ol_interaction_Interaction from 'ol/interaction/Interaction.js'\r\nimport ol_style_Style from 'ol/style/Style.js'\r\nimport ol_style_Stroke from 'ol/style/Stroke.js'\r\nimport ol_source_Vector from 'ol/source/Vector.js'\r\nimport ol_style_Fill from 'ol/style/Fill.js'\r\nimport ol_style_Circle from 'ol/style/Circle.js'\r\nimport ol_layer_Vector from 'ol/layer/Vector.js'\r\nimport ol_geom_Point from 'ol/geom/Point.js'\r\nimport ol_Feature from 'ol/Feature.js'\r\nimport ol_geom_LineString from 'ol/geom/LineString.js'\r\nimport {ol_coordinate_dist2d} from \"../geom/GeomUtils.js\";\r\nimport '../geom/LineStringSplitAt.js'\r\nimport ol_ext_element from '../util/element.js'\r\n\r\n/** Interaction split interaction for splitting feature geometry\r\n * @constructor\r\n * @extends {ol_interaction_Interaction}\r\n * @fires  beforesplit, aftersplit, pointermove\r\n * @param {*} \r\n *  @param {ol.source.Vector|Array<ol.source.Vector>} [options.sources] a list of source to split (configured with useSpatialIndex set to true), if none use map visible layers.\r\n *  @param {ol.Collection.<ol.Feature>} options.features collection of feature to split (instead of a list of sources)\r\n *  @param {integer} options.snapDistance distance (in px) to snap to an object, default 25px\r\n *\t@param {string|undefined} options.cursor cursor name to display when hovering an objet\r\n *  @param {function|undefined} options.filter a filter that takes a feature and return true if it can be clipped, default always split.\r\n *  @param ol_style_Style | Array<ol_style_Style> | false | undefined} options.featureStyle Style for the selected features, choose false if you don't want feature selection. By default the default edit style is used.\r\n *  @param {ol_style_Style | Array<ol_style_Style> | undefined} options.sketchStyle Style for the sektch features. \r\n *  @param {function|undefined} options.tolerance Distance between the calculated intersection and a vertex on the source geometry below which the existing vertex will be used for the split.  Default is 1e-10.\r\n */\r\nvar ol_interaction_Split = class olinteractionSplit extends ol_interaction_Interaction {\r\n  constructor(options) {\r\n    if (!options)\r\n      options = {}\r\n\r\n    super({\r\n      handleEvent: function (e) {\r\n        switch (e.type) {\r\n          case \"singleclick\":\r\n            return this.handleDownEvent(e)\r\n          case \"pointermove\":\r\n            return this.handleMoveEvent(e)\r\n          default:\r\n            return true\r\n        }\r\n        //return true;\r\n      }\r\n    })\r\n\r\n    // Snap distance (in px)\r\n    this.snapDistance_ = options.snapDistance || 25\r\n    // Split tolerance between the calculated intersection and the geometry\r\n    this.tolerance_ = options.tolerance || 1e-10\r\n    // Cursor\r\n    this.cursor_ = options.cursor\r\n\r\n    // List of source to split\r\n    this.setSources(options.sources)\r\n\r\n    if (options.features) {\r\n      if (!this.sources_) this.sources_ = [];\r\n      this.sources_.push(new ol_source_Vector({ features: options.features }))\r\n    }\r\n\r\n    // Get all features candidate\r\n    this.filterSplit_ = options.filter || function () { return true }\r\n\r\n    // Default style\r\n    var white = [255, 255, 255, 1]\r\n    var blue = [0, 153, 255, 1]\r\n    var width = 3\r\n    var fill = new ol_style_Fill({ color: 'rgba(255,255,255,0.4)' })\r\n    var stroke = new ol_style_Stroke({\r\n      color: '#3399CC',\r\n      width: 1.25\r\n    })\r\n    var sketchStyle = [\r\n      new ol_style_Style({\r\n        image: new ol_style_Circle({\r\n          fill: fill,\r\n          stroke: stroke,\r\n          radius: 5\r\n        }),\r\n        fill: fill,\r\n        stroke: stroke\r\n      })\r\n    ]\r\n    var featureStyle = [\r\n      new ol_style_Style({\r\n        stroke: new ol_style_Stroke({\r\n          color: white,\r\n          width: width + 2\r\n        })\r\n      }),\r\n      new ol_style_Style({\r\n        image: new ol_style_Circle({\r\n          radius: 2 * width,\r\n          fill: new ol_style_Fill({\r\n            color: blue\r\n          }),\r\n          stroke: new ol_style_Stroke({\r\n            color: white,\r\n            width: width / 2\r\n          })\r\n        }),\r\n        stroke: new ol_style_Stroke({\r\n          color: blue,\r\n          width: width\r\n        })\r\n      }),\r\n    ]\r\n\r\n    // Custom style\r\n    if (options.sketchStyle)\r\n      sketchStyle = options.sketchStyle instanceof Array ? options.sketchStyle : [options.sketchStyle]\r\n    if (options.featureStyle)\r\n      featureStyle = options.featureStyle instanceof Array ? options.featureStyle : [options.featureStyle]\r\n\r\n    // Create a new overlay for the sketch\r\n    this.overlayLayer_ = new ol_layer_Vector({\r\n      source: new ol_source_Vector({\r\n        useSpatialIndex: false\r\n      }),\r\n      name: 'Split overlay',\r\n      displayInLayerSwitcher: false,\r\n      style: function (f) {\r\n        if (f._sketch_)\r\n          return sketchStyle\r\n        else\r\n          return featureStyle\r\n      }\r\n    })\r\n\r\n  }\r\n  /**\r\n   * Remove the interaction from its current map, if any,  and attach it to a new\r\n   * map, if any. Pass `null` to just remove the interaction from the current map.\r\n   * @param {ol.Map} map Map.\r\n   * @api stable\r\n   */\r\n  setMap(map) {\r\n    if (this.getMap()) {\r\n      this.getMap().removeLayer(this.overlayLayer_)\r\n    }\r\n    super.setMap(map)\r\n    this.overlayLayer_.setMap(map)\r\n  }\r\n  /** Get sources to split features in\r\n   * @return {Array<ol.source.Vector>}\r\n   */\r\n  getSources() {\r\n    if (!this.sources_ && this.getMap()) {\r\n      var sources = []\r\n      var getSources = function (layers) {\r\n        layers.forEach(function (layer) {\r\n          if (layer.getVisible()) {\r\n            if (layer.getSource && layer.getSource() instanceof ol_source_Vector) {\r\n              sources.unshift(layer.getSource())\r\n            } else if (layer.getLayers) {\r\n              getSources(layer.getLayers())\r\n            }\r\n          }\r\n        })\r\n      }\r\n      getSources(this.getMap().getLayers())\r\n      return sources\r\n    }\r\n    return this.sources_ || []\r\n  }\r\n  /** Set sources to split features in\r\n   * @param {ol.source.Vector|Array<ol.source.Vector>|boolean} [sources] if not defined get all map vector sources\r\n   */\r\n  setSources(sources) {\r\n    this.sources_ = sources ? (sources instanceof Array ? sources || false : [sources]) : false\r\n  }\r\n  /** Get closest feature at pixel\r\n   * @param {ol.Pixel}\r\n   * @return {ol.feature}\r\n   * @private\r\n   */\r\n  getClosestFeature(e) {\r\n    var source, f, c, g, d = this.snapDistance_ + 1\r\n    // Look for closest point in the sources\r\n    this.getSources().forEach(function (si) {\r\n      var fi = si.getClosestFeatureToCoordinate(e.coordinate)\r\n      if (fi && fi.getGeometry().splitAt) {\r\n        var ci = fi.getGeometry().getClosestPoint(e.coordinate)\r\n        var gi = new ol_geom_LineString([e.coordinate, ci])\r\n        var di = gi.getLength() / e.frameState.viewState.resolution\r\n        if (di < d) {\r\n          source = si\r\n          d = di\r\n          f = fi\r\n          g = gi\r\n          c = ci\r\n        }\r\n      }\r\n    })\r\n    // Snap ?\r\n    if (d > this.snapDistance_) {\r\n      return false\r\n    } else {\r\n      // Snap to node\r\n      var coord = this.getNearestCoord(c, f.getGeometry().getCoordinates())\r\n      var p = this.getMap().getPixelFromCoordinate(coord)\r\n      if (ol_coordinate_dist2d(e.pixel, p) < this.snapDistance_) {\r\n        c = coord\r\n      }\r\n      //\r\n      return { source: source, feature: f, coord: c, link: g }\r\n    }\r\n  }\r\n  /** Get nearest coordinate in a list\r\n  * @param {ol.coordinate} pt the point to find nearest\r\n  * @param {Array<ol.coordinate>} coords list of coordinates\r\n  * @return {ol.coordinate} the nearest coordinate in the list\r\n  */\r\n  getNearestCoord(pt, coords) {\r\n    var d, dm = Number.MAX_VALUE, p0\r\n    for (var i = 0; i < coords.length; i++) {\r\n      d = ol_coordinate_dist2d(pt, coords[i])\r\n      if (d < dm) {\r\n        dm = d\r\n        p0 = coords[i]\r\n      }\r\n    }\r\n    return p0\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} evt Map browser event.\r\n   * @return {boolean} `true` to start the drag sequence.\r\n   */\r\n  handleDownEvent(evt) {\r\n    // Something to split ?\r\n    var current = this.getClosestFeature(evt)\r\n\r\n    if (current) {\r\n      var self = this\r\n      self.overlayLayer_.getSource().clear()\r\n      var split = current.feature.getGeometry().splitAt(current.coord, this.tolerance_)\r\n      var i\r\n      if (split.length > 1) {\r\n        var tosplit = []\r\n        for (i = 0; i < split.length; i++) {\r\n          var f = current.feature.clone()\r\n          f.setGeometry(split[i])\r\n          tosplit.push(f)\r\n        }\r\n        self.dispatchEvent({ type: 'beforesplit', original: current.feature, features: tosplit })\r\n        current.source.dispatchEvent({ type: 'beforesplit', original: current.feature, features: tosplit })\r\n        current.source.removeFeature(current.feature)\r\n        for (i = 0; i < tosplit.length; i++) {\r\n          current.source.addFeature(tosplit[i])\r\n        }\r\n        self.dispatchEvent({ type: 'aftersplit', original: current.feature, features: tosplit })\r\n        current.source.dispatchEvent({ type: 'aftersplit', original: current.feature, features: tosplit })\r\n      }\r\n    }\r\n    return false\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} evt Event.\r\n   */\r\n  handleMoveEvent(e) {\r\n    var map = e.map\r\n    this.overlayLayer_.getSource().clear()\r\n    var current = this.getClosestFeature(e)\r\n\r\n    if (current && this.filterSplit_(current.feature)) {\r\n      var p, l\r\n      // Draw sketch\r\n      this.overlayLayer_.getSource().addFeature(current.feature)\r\n      p = new ol_Feature(new ol_geom_Point(current.coord))\r\n      p._sketch_ = true\r\n      this.overlayLayer_.getSource().addFeature(p)\r\n      //\r\n      l = new ol_Feature(current.link)\r\n      l._sketch_ = true\r\n      this.overlayLayer_.getSource().addFeature(l)\r\n      // move event\r\n      this.dispatchEvent({\r\n        type: 'pointermove',\r\n        coordinate: e.coordinate,\r\n        frameState: e.frameState,\r\n        originalEvent: e.originalEvent,\r\n        map: e.map,\r\n        pixel: e.pixel,\r\n        feature: current.feature,\r\n        linkGeometry: current.link\r\n      })\r\n    } else {\r\n      this.dispatchEvent(e)\r\n    }\r\n\r\n    var element = map.getTargetElement()\r\n    if (this.cursor_) {\r\n      if (current) {\r\n        if (element.style.cursor != this.cursor_) {\r\n          this.previousCursor_ = element.style.cursor\r\n          ol_ext_element.setCursor(element, this.cursor_)\r\n        }\r\n      } else if (this.previousCursor_ !== undefined) {\r\n        ol_ext_element.setCursor(element, this.previousCursor_)\r\n        this.previousCursor_ = undefined\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport default ol_interaction_Split\r\n","import ol_style_Style from 'ol/style/Style.js'\r\nimport ol_style_Stroke from 'ol/style/Stroke.js'\r\nimport ol_source_Vector from 'ol/source/Vector.js'\r\nimport ol_style_Fill from 'ol/style/Fill.js'\r\nimport ol_layer_Vector from 'ol/layer/Vector.js'\r\nimport ol_geom_Point from 'ol/geom/Point.js'\r\nimport ol_Feature from 'ol/Feature.js'\r\nimport ol_Collection from 'ol/Collection.js'\r\nimport ol_interaction_Pointer from 'ol/interaction/Pointer.js'\r\nimport ol_style_RegularShape from 'ol/style/RegularShape.js'\r\nimport {fromExtent as ol_geom_Polygon_fromExtent} from 'ol/geom/Polygon.js'\r\nimport {boundingExtent as ol_extent_boundingExtent, buffer as ol_extent_buffer, createEmpty as ol_extent_createEmpty, extend as ol_extent_extend, getCenter as ol_extent_getCenter} from 'ol/extent.js'\r\nimport {unByKey as ol_Observable_unByKey} from 'ol/Observable.js'\r\nimport ol_geom_Polygon from 'ol/geom/Polygon.js'\r\nimport ol_ext_element from '../util/element.js'\r\n\r\n/** Interaction rotate\r\n * @constructor\r\n * @extends {ol_interaction_Pointer}\r\n * @fires select | rotatestart | rotating | rotateend | translatestart | translating | translateend | scalestart | scaling | scaleend\r\n * @param {any} options\r\n *  @param {function} options.filter A function that takes a Feature and a Layer and returns true if the feature may be transformed or false otherwise.\r\n *  @param {Array<ol.Layer>} options.layers array of layers to transform,\r\n *  @param {ol.Collection<ol.Feature>} options.features collection of feature to transform,\r\n *\t@param {ol.EventsConditionType|undefined} options.condition A function that takes an ol.MapBrowserEvent and a feature collection and returns a boolean to indicate whether that event should be handled. default: ol.events.condition.always.\r\n *\t@param {ol.EventsConditionType|undefined} options.addCondition A function that takes an ol.MapBrowserEvent and returns a boolean to indicate whether that event should be handled ie. the feature will be added to the transforms features. default: ol.events.condition.never.\r\n *\t@param {number | undefined} options.hitTolerance Tolerance to select feature in pixel, default 0\r\n *\t@param {bool} options.translateFeature Translate when click on feature\r\n *\t@param {bool} options.translate Can translate the feature\r\n *  @param {bool} options.translateBBox Enable translate when the user drags inside the bounding box\r\n *\t@param {bool} options.stretch can stretch the feature\r\n *\t@param {bool} options.scale can scale the feature\r\n *\t@param {bool} options.rotate can rotate the feature\r\n *\t@param {bool} options.noFlip prevent the feature geometry to flip, default false\r\n *\t@param {bool} options.selection the intraction handle selection/deselection, if not use the select prototype to add features to transform, default true\r\n *\t@param {ol.events.ConditionType | undefined} options.keepAspectRatio A function that takes an ol.MapBrowserEvent and returns a boolean to keep aspect ratio, default ol.events.condition.shiftKeyOnly.\r\n *\t@param {ol.events.ConditionType | undefined} options.modifyCenter A function that takes an ol.MapBrowserEvent and returns a boolean to apply scale & strech from the center, default ol.events.condition.metaKey or ol.events.condition.ctrlKey.\r\n *\t@param {boolean} options.enableRotatedTransform Enable transform when map is rotated\r\n *\t@param {boolean} [options.keepRectangle=false] keep rectangle when possible\r\n *  @param {number} [options.buffer] Increase the extent used as bounding box, default 0\r\n *\t@param {*} options.style list of ol.style for handles\r\n *  @param {number|Array<number>|function} [options.pointRadius=0] radius for points or a function that takes a feature and returns the radius (or [radiusX, radiusY]). If not null show handles to transform the points\r\n */\r\nvar ol_interaction_Transform = class olinteractionTransform extends ol_interaction_Pointer {\r\n  constructor(options) {\r\n    options = options || {}\r\n    // Extend pointer\r\n    super({\r\n      handleDownEvent: function(e) { return self.handleDownEvent_(e) },\r\n      handleDragEvent: function(e) { return this.handleDragEvent_(e) },\r\n      handleMoveEvent: function(e) { return this.handleMoveEvent_(e) },\r\n      handleUpEvent: function(e) { return this.handleUpEvent_(e) },\r\n    })\r\n    \r\n    var self = this\r\n    this.selection_ = new ol_Collection()\r\n\r\n    // Create a new overlay layer for the sketch\r\n    this.handles_ = new ol_Collection()\r\n    this.overlayLayer_ = new ol_layer_Vector({\r\n      source: new ol_source_Vector({\r\n        features: this.handles_,\r\n        useSpatialIndex: false,\r\n        wrapX: false // For vector editing across the -180° and 180° meridians to work properly, this should be set to false\r\n      }),\r\n      name: 'Transform overlay',\r\n      displayInLayerSwitcher: false,\r\n      // Return the style according to the handle type\r\n      style: function (feature) {\r\n        return (self.style[(feature.get('handle') || 'default') + (feature.get('constraint') || '') + (feature.get('option') || '')])\r\n      },\r\n      updateWhileAnimating: true,\r\n      updateWhileInteracting: true,\r\n    })\r\n\r\n    // Collection of feature to transform\r\n    this.features_ = options.features\r\n    // Filter or list of layers to transform\r\n    if (typeof (options.filter) === 'function')\r\n      this._filter = options.filter\r\n    this.layers_ = options.layers ? (options.layers instanceof Array) ? options.layers : [options.layers] : null\r\n\r\n    this._handleEvent = options.condition || function () { return true }\r\n    this.addFn_ = options.addCondition || function () { return false }\r\n    this.setPointRadius(options.pointRadius)\r\n    /* Translate when click on feature */\r\n    this.set('translateFeature', (options.translateFeature !== false))\r\n    /* Can translate the feature */\r\n    this.set('translate', (options.translate !== false))\r\n    /* Translate when click on the bounding box */\r\n    this.set('translateBBox', (options.translateBBox === true))\r\n    /* Can stretch the feature */\r\n    this.set('stretch', (options.stretch !== false))\r\n    /* Can scale the feature */\r\n    this.set('scale', (options.scale !== false))\r\n    /* Can rotate the feature */\r\n    this.set('rotate', (options.rotate !== false))\r\n    /* Keep aspect ratio */\r\n    this.set('keepAspectRatio', (options.keepAspectRatio || function (e) { return e.originalEvent.shiftKey }))\r\n    /* Modify center */\r\n    this.set('modifyCenter', (options.modifyCenter || function (e) { return e.originalEvent.metaKey || e.originalEvent.ctrlKey }))\r\n    /* Prevent flip */\r\n    this.set('noFlip', (options.noFlip || false))\r\n    /* Handle selection */\r\n    this.set('selection', (options.selection !== false))\r\n    /*  */\r\n    this.set('hitTolerance', (options.hitTolerance || 0))\r\n    /* Enable view rotated transforms */\r\n    this.set('enableRotatedTransform', (options.enableRotatedTransform || false))\r\n    /* Keep rectangle angles 90 degrees */\r\n    this.set('keepRectangle', (options.keepRectangle || false))\r\n    /* Add buffer to the feature's extent */\r\n    this.set('buffer', (options.buffer || 0))\r\n\r\n    // Force redraw when changed\r\n    this.on('propertychange', function () {\r\n      this.drawSketch_()\r\n    })\r\n\r\n    // setstyle\r\n    this.setDefaultStyle()\r\n  }\r\n  /**\r\n   * Remove the interaction from its current map, if any,  and attach it to a new\r\n   * map, if any. Pass `null` to just remove the interaction from the current map.\r\n   * @param {ol.Map} map Map.\r\n   * @api stable\r\n   */\r\n  setMap(map) {\r\n    var oldMap = this.getMap()\r\n    if (oldMap) {\r\n      oldMap.removeLayer(this.overlayLayer_)\r\n      if (this.previousCursor_) {\r\n        ol_ext_element.setCursor(oldMap, this.previousCursor_)\r\n      }\r\n      this.previousCursor_ = undefined\r\n    }\r\n    super.setMap(map)\r\n    this.overlayLayer_.setMap(map)\r\n    if (map === null) {\r\n      this.select(null)\r\n    }\r\n    if (map !== null) {\r\n      this.isTouch = /touch/.test(map.getViewport().className)\r\n      this.setDefaultStyle()\r\n    }\r\n  }\r\n  /**\r\n   * Activate/deactivate interaction\r\n   * @param {bool}\r\n   * @api stable\r\n   */\r\n  setActive(b) {\r\n    this.select(null)\r\n    if (this.overlayLayer_) this.overlayLayer_.setVisible(b)\r\n    super.setActive(b)\r\n  }\r\n  /** Set default sketch style\r\n   * @param {Object} [options]\r\n   *  @param {ol_style_Stroke} [stroke] stroke style for selection rectangle, default red dash\r\n   *  @param {ol_style_Fill} [fill] fill style for selection rectangle, default red\r\n   *  @param {ol_style_Stroke} [pointStroke] stroke style for handles, default red\r\n   *  @param {ol_style_Fill} [pointFill] fill style for handles, default white\r\n   */\r\n  setDefaultStyle(options) {\r\n    options = options || {}\r\n    // Style\r\n    var stroke = options.pointStroke || new ol_style_Stroke({ color: [255, 0, 0, 1], width: 1 })\r\n    var strokedash = options.stroke || new ol_style_Stroke({ color: [255, 0, 0, 1], width: 1, lineDash: [4, 4] })\r\n    var fill0 = options.fill || new ol_style_Fill({ color: [255, 0, 0, 0.01] })\r\n    var fill = options.pointFill || new ol_style_Fill({ color: [255, 255, 255, 0.8] })\r\n    var circle = new ol_style_RegularShape({\r\n      fill: fill,\r\n      stroke: stroke,\r\n      radius: this.isTouch ? 12 : 6,\r\n      displacement: this.isTouch ? [24, -24] : [12, -12],\r\n      points: 15\r\n    })\r\n    // Old version with no displacement\r\n    if (!circle.setDisplacement)\r\n      circle.getAnchor()[0] = this.isTouch ? -10 : -5\r\n    var bigpt = new ol_style_RegularShape({\r\n      fill: fill,\r\n      stroke: stroke,\r\n      radius: this.isTouch ? 16 : 8,\r\n      points: 4,\r\n      angle: Math.PI / 4\r\n    })\r\n    var smallpt = new ol_style_RegularShape({\r\n      fill: fill,\r\n      stroke: stroke,\r\n      radius: this.isTouch ? 12 : 6,\r\n      points: 4,\r\n      angle: Math.PI / 4\r\n    })\r\n    function createStyle(img, stroke, fill) {\r\n      return [new ol_style_Style({ image: img, stroke: stroke, fill: fill })]\r\n    }\r\n    /** Style for handles */\r\n    this.style = {\r\n      'default': createStyle(bigpt, strokedash, fill0),\r\n      'translate': createStyle(bigpt, stroke, fill),\r\n      'rotate': createStyle(circle, stroke, fill),\r\n      'rotate0': createStyle(bigpt, stroke, fill),\r\n      'scale': createStyle(bigpt, stroke, fill),\r\n      'scale1': createStyle(bigpt, stroke, fill),\r\n      'scale2': createStyle(bigpt, stroke, fill),\r\n      'scale3': createStyle(bigpt, stroke, fill),\r\n      'scalev': createStyle(smallpt, stroke, fill),\r\n      'scaleh1': createStyle(smallpt, stroke, fill),\r\n      'scalev2': createStyle(smallpt, stroke, fill),\r\n      'scaleh3': createStyle(smallpt, stroke, fill),\r\n    }\r\n    this.drawSketch_()\r\n  }\r\n  /**\r\n   * Set sketch style.\r\n   * @param {style} style Style name: 'default','translate','rotate','rotate0','scale','scale1','scale2','scale3','scalev','scaleh1','scalev2','scaleh3'\r\n   * @param {ol.style.Style|Array<ol.style.Style>} olstyle\r\n   * @api stable\r\n   */\r\n  setStyle(style, olstyle) {\r\n    if (!olstyle)\r\n      return\r\n    if (olstyle instanceof Array)\r\n      this.style[style] = olstyle\r\n    else\r\n      this.style[style] = [olstyle]\r\n    for (var i = 0; i < this.style[style].length; i++) {\r\n      var im = this.style[style][i].getImage()\r\n      if (im) {\r\n        if (style == 'rotate') {\r\n          im.getAnchor()[0] = -5\r\n        }\r\n        if (this.isTouch)\r\n          im.setScale(1.8)\r\n      }\r\n      var tx = this.style[style][i].getText()\r\n      if (tx) {\r\n        if (style == 'rotate')\r\n          tx.setOffsetX(this.isTouch ? 14 : 7)\r\n        if (this.isTouch)\r\n          tx.setScale(1.8)\r\n      }\r\n    }\r\n    this.drawSketch_()\r\n  }\r\n  /** Get Feature at pixel\r\n   * @param {ol.Pixel}\r\n   * @return {ol.feature}\r\n   * @private\r\n   */\r\n  getFeatureAtPixel_(pixel) {\r\n    var self = this\r\n    return this.getMap().forEachFeatureAtPixel(pixel,\r\n      function (feature, layer) {\r\n        var found = false\r\n        // Overlay ?\r\n        if (!layer) {\r\n          if (feature === self.bbox_) {\r\n            if (self.get('translateBBox')) {\r\n              return { feature: feature, handle: 'translate', constraint: '', option: '' }\r\n            } else {\r\n              return false\r\n            }\r\n          }\r\n          self.handles_.forEach(function (f) {\r\n            if (f === feature)\r\n              found = true\r\n          })\r\n          if (found)\r\n            return { feature: feature, handle: feature.get('handle'), constraint: feature.get('constraint'), option: feature.get('option') }\r\n        }\r\n        // No seletion\r\n        if (!self.get('selection')) {\r\n          // Return the currently selected feature the user is interacting with.\r\n          if (self.selection_.getArray().some(function (f) { return feature === f })) {\r\n            return { feature: feature }\r\n          }\r\n          return null\r\n        }\r\n        // filter condition\r\n        if (self._filter) {\r\n          if (self._filter(feature, layer))\r\n            return { feature: feature }\r\n          else\r\n            return null\r\n        }\r\n\r\n        // feature belong to a layer\r\n        else if (self.layers_) {\r\n          for (var i = 0; i < self.layers_.length; i++) {\r\n            if (self.layers_[i] === layer)\r\n              return { feature: feature }\r\n          }\r\n          return null\r\n        }\r\n\r\n        // feature in the collection\r\n        else if (self.features_) {\r\n          self.features_.forEach(function (f) {\r\n            if (f === feature)\r\n              found = true\r\n          })\r\n          if (found)\r\n            return { feature: feature }\r\n          else\r\n            return null\r\n        }\r\n\r\n        // Others\r\n        else\r\n          return { feature: feature }\r\n      },\r\n      { hitTolerance: this.get('hitTolerance') }\r\n    ) || {}\r\n  }\r\n  /** Rotate feature from map view rotation\r\n   * @param {ol.Feature} f the feature\r\n   * @param {boolean} clone clone resulting geom\r\n   * @param {ol.geom.Geometry} rotated geometry\r\n   */\r\n  getGeometryRotateToZero_(f, clone) {\r\n    var origGeom = f.getGeometry()\r\n    var viewRotation = this.getMap().getView().getRotation()\r\n    if (viewRotation === 0 || !this.get('enableRotatedTransform')) {\r\n      return (clone) ? origGeom.clone() : origGeom\r\n    }\r\n    var rotGeom = origGeom.clone()\r\n    rotGeom.rotate(viewRotation * -1, this.getMap().getView().getCenter())\r\n    return rotGeom\r\n  }\r\n  /** Test if rectangle\r\n   * @param {ol.Geometry} geom\r\n   * @returns {boolean}\r\n   * @private\r\n   */\r\n  _isRectangle(geom) {\r\n    if (this.get('keepRectangle') && geom.getType() === 'Polygon') {\r\n      var coords = geom.getCoordinates()[0]\r\n      return coords.length === 5\r\n    }\r\n    return false\r\n  }\r\n  /** Draw transform sketch\r\n  * @param {boolean} draw only the center\r\n  */\r\n  drawSketch_(center) {\r\n    var i, f, geom\r\n    var keepRectangle = this.selection_.item(0) && this._isRectangle(this.selection_.item(0).getGeometry())\r\n    this.overlayLayer_.getSource().clear()\r\n    if (!this.selection_.getLength())\r\n      return\r\n    var viewRotation = this.getMap().getView().getRotation()\r\n    var ext = this.getGeometryRotateToZero_(this.selection_.item(0)).getExtent()\r\n    var coords\r\n    if (keepRectangle) {\r\n      coords = this.getGeometryRotateToZero_(this.selection_.item(0)).getCoordinates()[0].slice(0, 4)\r\n      coords.unshift(coords[3])\r\n    }\r\n    // Clone and extend\r\n    ext = ol_extent_buffer(ext, this.get('buffer'))\r\n    this.selection_.forEach(function (f) {\r\n      var extendExt = this.getGeometryRotateToZero_(f).getExtent()\r\n      ol_extent_extend(ext, extendExt)\r\n    }.bind(this))\r\n\r\n    var ptRadius = (this.selection_.getLength() === 1 ? this._pointRadius(this.selection_.item(0)) : 0)\r\n    if (ptRadius && !(ptRadius instanceof Array))\r\n      ptRadius = [ptRadius, ptRadius]\r\n\r\n    if (center === true) {\r\n      if (!this.ispt_) {\r\n        this.overlayLayer_.getSource().addFeature(new ol_Feature({ geometry: new ol_geom_Point(this.center_), handle: 'rotate0' }))\r\n        geom = ol_geom_Polygon_fromExtent(ext)\r\n        if (this.get('enableRotatedTransform') && viewRotation !== 0) {\r\n          geom.rotate(viewRotation, this.getMap().getView().getCenter())\r\n        }\r\n        f = this.bbox_ = new ol_Feature(geom)\r\n        this.overlayLayer_.getSource().addFeature(f)\r\n      }\r\n    } else {\r\n      if (this.ispt_) {\r\n        // Calculate extent arround the point\r\n        var p = this.getMap().getPixelFromCoordinate(ol_extent_getCenter(ext))\r\n        if (p) {\r\n          var dx = ptRadius ? ptRadius[0] || 10 : 10\r\n          var dy = ptRadius ? ptRadius[1] || 10 : 10\r\n          ext = ol_extent_boundingExtent([\r\n            this.getMap().getCoordinateFromPixel([p[0] - dx, p[1] - dy]),\r\n            this.getMap().getCoordinateFromPixel([p[0] + dx, p[1] + dy])\r\n          ])\r\n        }\r\n      }\r\n      geom = keepRectangle ? new ol_geom_Polygon([coords]) : ol_geom_Polygon_fromExtent(ext)\r\n      if (this.get('enableRotatedTransform') && viewRotation !== 0) {\r\n        geom.rotate(viewRotation, this.getMap().getView().getCenter())\r\n      }\r\n      f = this.bbox_ = new ol_Feature(geom)\r\n      var features = []\r\n      var g = geom.getCoordinates()[0]\r\n      if (!this.ispt_ || ptRadius) {\r\n        features.push(f)\r\n        // Middle\r\n        if (!this.iscircle_ && !this.ispt_ && this.get('stretch') && this.get('scale'))\r\n          for (i = 0; i < g.length - 1; i++) {\r\n            f = new ol_Feature({ geometry: new ol_geom_Point([(g[i][0] + g[i + 1][0]) / 2, (g[i][1] + g[i + 1][1]) / 2]), handle: 'scale', constraint: i % 2 ? \"h\" : \"v\", option: i })\r\n            features.push(f)\r\n          }\r\n        // Handles\r\n        if (this.get('scale'))\r\n          for (i = 0; i < g.length - 1; i++) {\r\n            f = new ol_Feature({ geometry: new ol_geom_Point(g[i]), handle: 'scale', option: i })\r\n            features.push(f)\r\n          }\r\n        // Center\r\n        if (this.get('translate') && !this.get('translateFeature')) {\r\n          f = new ol_Feature({ geometry: new ol_geom_Point([(g[0][0] + g[2][0]) / 2, (g[0][1] + g[2][1]) / 2]), handle: 'translate' })\r\n          features.push(f)\r\n        }\r\n      }\r\n      // Rotate\r\n      if (!this.iscircle_ && this.get('rotate')) {\r\n        f = new ol_Feature({ geometry: new ol_geom_Point(g[3]), handle: 'rotate' })\r\n        features.push(f)\r\n      }\r\n      // Add sketch\r\n      this.overlayLayer_.getSource().addFeatures(features)\r\n    }\r\n\r\n  }\r\n  /** Select a feature to transform\r\n  * @param {ol.Feature} feature the feature to transform\r\n  * @param {boolean} add true to add the feature to the selection, default false\r\n  */\r\n  select(feature, add) {\r\n    if (!feature) {\r\n      if (this.selection_) {\r\n        this.selection_.clear()\r\n        this.drawSketch_()\r\n      }\r\n      return\r\n    }\r\n    if (!feature.getGeometry || !feature.getGeometry()) return\r\n    // Add to selection\r\n    if (add) {\r\n      this.selection_.push(feature)\r\n    } else {\r\n      var index = this.selection_.getArray().indexOf(feature)\r\n      this.selection_.removeAt(index)\r\n    }\r\n    this.ispt_ = (this.selection_.getLength() === 1 ? (this.selection_.item(0).getGeometry().getType() == \"Point\") : false)\r\n    this.iscircle_ = (this.selection_.getLength() === 1 ? (this.selection_.item(0).getGeometry().getType() == \"Circle\") : false)\r\n    this.drawSketch_()\r\n    this.watchFeatures_()\r\n    // select event\r\n    this.dispatchEvent({ type: 'select', feature: feature, features: this.selection_ })\r\n  }\r\n  /** Update the selection collection.\r\n  * @param {ol.Collection<ol.Feature>} features the features to transform\r\n  */\r\n  setSelection(features) {\r\n    this.selection_.clear()\r\n    features.forEach(function (feature) {\r\n      this.selection_.push(feature)\r\n    }.bind(this))\r\n\r\n    this.ispt_ = (this.selection_.getLength() === 1 ? (this.selection_.item(0).getGeometry().getType() == \"Point\") : false)\r\n    this.iscircle_ = (this.selection_.getLength() === 1 ? (this.selection_.item(0).getGeometry().getType() == \"Circle\") : false)\r\n    this.drawSketch_()\r\n    this.watchFeatures_()\r\n    // select event\r\n    this.dispatchEvent({ type: 'select', features: this.selection_ })\r\n  }\r\n  /** Watch selected features\r\n   * @private\r\n   */\r\n  watchFeatures_() {\r\n    // Listen to feature modification\r\n    if (this._featureListeners) {\r\n      this._featureListeners.forEach(function (l) {\r\n        ol_Observable_unByKey(l)\r\n      })\r\n    }\r\n    this._featureListeners = []\r\n    this.selection_.forEach(function (f) {\r\n      this._featureListeners.push(\r\n        f.on('change', function () {\r\n          if (!this.isUpdating_) {\r\n            this.drawSketch_()\r\n          }\r\n        }.bind(this))\r\n      )\r\n    }.bind(this))\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} evt Map browser event.\r\n   * @return {boolean} `true` to start the drag sequence.\r\n   * @private\r\n   */\r\n  handleDownEvent_(evt) {\r\n    if (!this._handleEvent(evt, this.selection_))\r\n      return\r\n    var sel = this.getFeatureAtPixel_(evt.pixel)\r\n    var feature = sel.feature\r\n    if (this.selection_.getLength()\r\n      && this.selection_.getArray().indexOf(feature) >= 0\r\n      && ((this.ispt_ && this.get('translate')) || this.get('translateFeature'))) {\r\n      sel.handle = 'translate'\r\n    }\r\n    if (sel.handle) {\r\n      this.mode_ = sel.handle\r\n      this.opt_ = sel.option\r\n      this.constraint_ = sel.constraint\r\n      // Save info\r\n      var viewRotation = this.getMap().getView().getRotation()\r\n      // Get coordinate of the handle (for snapping)\r\n      this.coordinate_ = feature.get('handle') ? feature.getGeometry().getCoordinates() : evt.coordinate;\r\n      this.pixel_ = this.getMap().getCoordinateFromPixel(this.coordinate_) // evt.pixel;\r\n      this.geoms_ = []\r\n      this.rotatedGeoms_ = []\r\n      var extent = ol_extent_createEmpty()\r\n      var rotExtent = ol_extent_createEmpty()\r\n      for (var i = 0, f; f = this.selection_.item(i); i++) {\r\n        this.geoms_.push(f.getGeometry().clone())\r\n        extent = ol_extent_extend(extent, f.getGeometry().getExtent())\r\n        if (this.get('enableRotatedTransform') && viewRotation !== 0) {\r\n          var rotGeom = this.getGeometryRotateToZero_(f, true)\r\n          this.rotatedGeoms_.push(rotGeom)\r\n          rotExtent = ol_extent_extend(rotExtent, rotGeom.getExtent())\r\n        }\r\n      }\r\n      this.extent_ = (ol_geom_Polygon_fromExtent(extent)).getCoordinates()[0]\r\n      if (this.get('enableRotatedTransform') && viewRotation !== 0) {\r\n        this.rotatedExtent_ = (ol_geom_Polygon_fromExtent(rotExtent)).getCoordinates()[0]\r\n      }\r\n      if (this.mode_ === 'rotate') {\r\n        this.center_ = this.getCenter() || ol_extent_getCenter(extent)\r\n        // we are now rotating (cursor down on rotate mode), so apply the grabbing cursor\r\n        var element = evt.map.getTargetElement()\r\n        ol_ext_element.setCursor(element, this.Cursors.rotate0)\r\n        this.previousCursor_ = element.style.cursor\r\n      } else {\r\n        this.center_ = ol_extent_getCenter(extent)\r\n      }\r\n      this.angle_ = Math.atan2(this.center_[1] - evt.coordinate[1], this.center_[0] - evt.coordinate[0])\r\n\r\n      this.dispatchEvent({\r\n        type: this.mode_ + 'start',\r\n        feature: this.selection_.item(0),\r\n        features: this.selection_,\r\n        pixel: evt.pixel,\r\n        coordinate: evt.coordinate\r\n      })\r\n      return true\r\n    }\r\n    else if (this.get('selection')) {\r\n      if (feature) {\r\n        if (!this.addFn_(evt))\r\n          this.selection_.clear()\r\n        var index = this.selection_.getArray().indexOf(feature)\r\n        if (index < 0)\r\n          this.selection_.push(feature)\r\n        else\r\n          this.selection_.removeAt(index)\r\n      } else {\r\n        this.selection_.clear()\r\n      }\r\n      this.ispt_ = this.selection_.getLength() === 1 ? (this.selection_.item(0).getGeometry().getType() == \"Point\") : false\r\n      this.iscircle_ = (this.selection_.getLength() === 1 ? (this.selection_.item(0).getGeometry().getType() == \"Circle\") : false)\r\n      this.drawSketch_()\r\n      this.watchFeatures_()\r\n      this.dispatchEvent({ type: 'select', feature: feature, features: this.selection_, pixel: evt.pixel, coordinate: evt.coordinate })\r\n      return false\r\n    }\r\n  }\r\n  /**\r\n   * Get the rotation center\r\n   * @return {ol.coordinate|undefined}\r\n   */\r\n  getCenter() {\r\n    return this.get('center')\r\n  }\r\n  /**\r\n   * Set the rotation center\r\n   * @param {ol.coordinate|undefined} c the center point, default center on the objet\r\n   */\r\n  setCenter(c) {\r\n    return this.set('center', c)\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} evt Map browser event.\r\n   * @private\r\n   */\r\n  handleDragEvent_(evt) {\r\n    if (!this._handleEvent(evt, this.features_))\r\n      return\r\n    var viewRotation = this.getMap().getView().getRotation()\r\n    var i, j, f, geometry\r\n    var pt0 = [this.coordinate_[0], this.coordinate_[1]]\r\n    var pt = [evt.coordinate[0], evt.coordinate[1]]\r\n    this.isUpdating_ = true\r\n    switch (this.mode_) {\r\n      case 'rotate': {\r\n        var a = Math.atan2(this.center_[1] - pt[1], this.center_[0] - pt[0])\r\n        if (!this.ispt) {\r\n          // var geometry = this.geom_.clone();\r\n          // geometry.rotate(a-this.angle_, this.center_);\r\n          // this.feature_.setGeometry(geometry);\r\n          for (i = 0, f; f = this.selection_.item(i); i++) {\r\n            geometry = this.geoms_[i].clone()\r\n            geometry.rotate(a - this.angle_, this.center_)\r\n            // bug: ol, bad calculation circle geom extent\r\n            if (geometry.getType() == 'Circle')\r\n              geometry.setCenterAndRadius(geometry.getCenter(), geometry.getRadius())\r\n            f.setGeometry(geometry)\r\n          }\r\n        }\r\n        this.drawSketch_(true)\r\n        this.dispatchEvent({\r\n          type: 'rotating',\r\n          feature: this.selection_.item(0),\r\n          features: this.selection_,\r\n          angle: a - this.angle_,\r\n          pixel: evt.pixel,\r\n          coordinate: evt.coordinate\r\n        })\r\n        break\r\n      }\r\n      case 'translate': {\r\n        var deltaX = pt[0] - pt0[0]\r\n        var deltaY = pt[1] - pt0[1]\r\n\r\n        //this.feature_.getGeometry().translate(deltaX, deltaY);\r\n        for (i = 0, f; f = this.selection_.item(i); i++) {\r\n          f.getGeometry().translate(deltaX, deltaY)\r\n        }\r\n        this.handles_.forEach(function (f) {\r\n          f.getGeometry().translate(deltaX, deltaY)\r\n        })\r\n\r\n        this.coordinate_ = evt.coordinate\r\n        this.dispatchEvent({\r\n          type: 'translating',\r\n          feature: this.selection_.item(0),\r\n          features: this.selection_,\r\n          delta: [deltaX, deltaY],\r\n          pixel: evt.pixel,\r\n          coordinate: evt.coordinate\r\n        })\r\n        break\r\n      }\r\n      case 'scale': {\r\n        var center = this.center_\r\n        if (this.get('modifyCenter')(evt)) {\r\n          var extentCoordinates = this.extent_\r\n          if (this.get('enableRotatedTransform') && viewRotation !== 0) {\r\n            extentCoordinates = this.rotatedExtent_\r\n          }\r\n          center = extentCoordinates[(Number(this.opt_) + 2) % 4]\r\n        }\r\n        var keepRectangle = (this.geoms_.length == 1 && this._isRectangle(this.geoms_[0]))\r\n        var stretch = this.constraint_\r\n        var opt = this.opt_\r\n\r\n        var downCoordinate = this.coordinate_\r\n        var dragCoordinate = evt.coordinate\r\n        if (this.get('enableRotatedTransform') && viewRotation !== 0) {\r\n          var downPoint = new ol_geom_Point(this.coordinate_)\r\n          downPoint.rotate(viewRotation * -1, center)\r\n          downCoordinate = downPoint.getCoordinates()\r\n\r\n          var dragPoint = new ol_geom_Point(evt.coordinate)\r\n          dragPoint.rotate(viewRotation * -1, center)\r\n          dragCoordinate = dragPoint.getCoordinates()\r\n        }\r\n\r\n        var scx = ((dragCoordinate)[0] - (center)[0]) / (downCoordinate[0] - (center)[0])\r\n        var scy = ((dragCoordinate)[1] - (center)[1]) / (downCoordinate[1] - (center)[1])\r\n        var displacementVector = [dragCoordinate[0] - downCoordinate[0], (dragCoordinate)[1] - downCoordinate[1]]\r\n\r\n        if (this.get('enableRotatedTransform') && viewRotation !== 0) {\r\n          var centerPoint = new ol_geom_Point(center)\r\n          centerPoint.rotate(viewRotation * -1, this.getMap().getView().getCenter())\r\n          center = centerPoint.getCoordinates()\r\n        }\r\n\r\n        if (this.get('noFlip')) {\r\n          if (scx < 0)\r\n            scx = -scx\r\n          if (scy < 0)\r\n            scy = -scy\r\n        }\r\n\r\n        if (this.constraint_) {\r\n          if (this.constraint_ == \"h\")\r\n            scx = 1\r\n          else\r\n            scy = 1\r\n        } else {\r\n          if (this.get('keepAspectRatio')(evt)) {\r\n            scx = scy = Math.min(scx, scy)\r\n          }\r\n        }\r\n\r\n        for (i = 0, f; f = this.selection_.item(i); i++) {\r\n          geometry = (viewRotation === 0 || !this.get('enableRotatedTransform')) ? this.geoms_[i].clone() : this.rotatedGeoms_[i].clone()\r\n          geometry.applyTransform(function (g1, g2, dim) {\r\n            if (dim < 2) return g2\r\n\r\n            if (!keepRectangle) {\r\n              for (j = 0; j < g1.length; j += dim) {\r\n                if (scx != 1)\r\n                  g2[j] = center[0] + (g1[j] - center[0]) * scx\r\n                if (scy != 1)\r\n                  g2[j + 1] = center[1] + (g1[j + 1] - center[1]) * scy\r\n              }\r\n            } else {\r\n              var pointArray = [[6], [0, 8], [2], [4]]\r\n              var pointA = [g1[0], g1[1]]\r\n              var pointB = [g1[2], g1[3]]\r\n              var pointC = [g1[4], g1[5]]\r\n              var pointD = [g1[6], g1[7]]\r\n              var pointA1 = [g1[8], g1[9]]\r\n\r\n              if (stretch) {\r\n                var base = (opt % 2 === 0) ? this._countVector(pointA, pointB) : this._countVector(pointD, pointA)\r\n                var projectedVector = this._projectVectorOnVector(displacementVector, base)\r\n                var nextIndex = opt + 1 < pointArray.length ? opt + 1 : 0\r\n                var coordsToChange = [...pointArray[opt], ...pointArray[nextIndex]]\r\n\r\n                for (j = 0; j < g1.length; j += dim) {\r\n                  g2[j] = coordsToChange.includes(j) ? g1[j] + projectedVector[0] : g1[j]\r\n                  g2[j + 1] = coordsToChange.includes(j) ? g1[j + 1] + projectedVector[1] : g1[j + 1]\r\n                }\r\n              } else {\r\n                var projectedLeft, projectedRight\r\n                switch (opt) {\r\n                  case 0:\r\n                    displacementVector = this._countVector(pointD, dragCoordinate)\r\n                    projectedLeft = this._projectVectorOnVector(displacementVector, this._countVector(pointC, pointD))\r\n                    projectedRight = this._projectVectorOnVector(displacementVector, this._countVector(pointA, pointD));\r\n                    [g2[0], g2[1]] = this._movePoint(pointA, projectedLeft);\r\n                    [g2[4], g2[5]] = this._movePoint(pointC, projectedRight);\r\n                    [g2[6], g2[7]] = this._movePoint(pointD, displacementVector);\r\n                    [g2[8], g2[9]] = this._movePoint(pointA1, projectedLeft)\r\n                    break\r\n                  case 1:\r\n                    displacementVector = this._countVector(pointA, dragCoordinate)\r\n                    projectedLeft = this._projectVectorOnVector(displacementVector, this._countVector(pointD, pointA))\r\n                    projectedRight = this._projectVectorOnVector(displacementVector, this._countVector(pointB, pointA));\r\n                    [g2[0], g2[1]] = this._movePoint(pointA, displacementVector);\r\n                    [g2[2], g2[3]] = this._movePoint(pointB, projectedLeft);\r\n                    [g2[6], g2[7]] = this._movePoint(pointD, projectedRight);\r\n                    [g2[8], g2[9]] = this._movePoint(pointA1, displacementVector)\r\n                    break\r\n                  case 2:\r\n                    displacementVector = this._countVector(pointB, dragCoordinate)\r\n                    projectedLeft = this._projectVectorOnVector(displacementVector, this._countVector(pointA, pointB))\r\n                    projectedRight = this._projectVectorOnVector(displacementVector, this._countVector(pointC, pointB));\r\n                    [g2[0], g2[1]] = this._movePoint(pointA, projectedRight);\r\n                    [g2[2], g2[3]] = this._movePoint(pointB, displacementVector);\r\n                    [g2[4], g2[5]] = this._movePoint(pointC, projectedLeft);\r\n                    [g2[8], g2[9]] = this._movePoint(pointA1, projectedRight)\r\n                    break\r\n                  case 3:\r\n                    displacementVector = this._countVector(pointC, dragCoordinate)\r\n                    projectedLeft = this._projectVectorOnVector(displacementVector, this._countVector(pointB, pointC))\r\n                    projectedRight = this._projectVectorOnVector(displacementVector, this._countVector(pointD, pointC));\r\n                    [g2[2], g2[3]] = this._movePoint(pointB, projectedRight);\r\n                    [g2[4], g2[5]] = this._movePoint(pointC, displacementVector);\r\n                    [g2[6], g2[7]] = this._movePoint(pointD, projectedLeft)\r\n                    break\r\n                }\r\n              }\r\n            }\r\n\r\n            // bug: ol, bad calculation circle geom extent\r\n            if (geometry.getType() == 'Circle') geometry.setCenterAndRadius(geometry.getCenter(), geometry.getRadius())\r\n            return g2\r\n          }.bind(this))\r\n          if (this.get('enableRotatedTransform') && viewRotation !== 0) {\r\n            //geometry.rotate(viewRotation, rotationCenter);\r\n            geometry.rotate(viewRotation, this.getMap().getView().getCenter())\r\n          }\r\n          f.setGeometry(geometry)\r\n        }\r\n        this.drawSketch_()\r\n        this.dispatchEvent({\r\n          type: 'scaling',\r\n          feature: this.selection_.item(0),\r\n          features: this.selection_,\r\n          scale: [scx, scy],\r\n          pixel: evt.pixel,\r\n          coordinate: evt.coordinate\r\n        })\r\n        break\r\n      }\r\n      default: break\r\n    }\r\n    this.isUpdating_ = false\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} evt Event.\r\n   * @private\r\n   */\r\n  handleMoveEvent_(evt) {\r\n    if (!this._handleEvent(evt, this.features_))\r\n      return\r\n    // console.log(\"handleMoveEvent\");\r\n    if (!this.mode_) {\r\n      var sel = this.getFeatureAtPixel_(evt.pixel)\r\n      var element = evt.map.getTargetElement()\r\n      if (sel.feature) {\r\n        var c = sel.handle ? this.Cursors[(sel.handle || 'default') + (sel.constraint || '') + (sel.option || '')] : this.Cursors.select\r\n\r\n        if (this.previousCursor_ === undefined) {\r\n          this.previousCursor_ = element.style.cursor\r\n        }\r\n        ol_ext_element.setCursor(element, c);\r\n      } else {\r\n        if (this.previousCursor_ !== undefined) {\r\n          ol_ext_element.setCursor(element, this.previousCursor_)\r\n        }\r\n        this.previousCursor_ = undefined\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * @param {ol.MapBrowserEvent} evt Map browser event.\r\n   * @return {boolean} `false` to stop the drag sequence.\r\n   */\r\n  handleUpEvent_(evt) {\r\n    // remove rotate0 cursor on Up event, otherwise it's stuck on grab/grabbing\r\n    if (this.mode_ === 'rotate') {\r\n      var element = evt.map.getTargetElement()\r\n      ol_ext_element.setCursor(element, this.Cursors.default)\r\n      this.previousCursor_ = undefined\r\n    }\r\n\r\n    //dispatchEvent\r\n    this.dispatchEvent({\r\n      type: this.mode_ + 'end',\r\n      feature: this.selection_.item(0),\r\n      features: this.selection_,\r\n      oldgeom: this.geoms_[0],\r\n      oldgeoms: this.geoms_\r\n    })\r\n\r\n    this.drawSketch_()\r\n    this.mode_ = null\r\n    return false\r\n  }\r\n  /** Set the point radius to calculate handles on points\r\n   *  @param {number|Array<number>|function} [pointRadius=0] radius for points or a function that takes a feature and returns the radius (or [radiusX, radiusY]). If not null show handles to transform the points\r\n   */\r\n  setPointRadius(pointRadius) {\r\n    if (typeof (pointRadius) === 'function') {\r\n      this._pointRadius = pointRadius\r\n    } else {\r\n      this._pointRadius = function () { return pointRadius }\r\n    }\r\n  }\r\n  /** Get the features that are selected for transform\r\n   * @return ol.Collection\r\n   */\r\n  getFeatures() {\r\n    return this.selection_;\r\n  }\r\n  /**\r\n   * @private\r\n   */\r\n  _projectVectorOnVector(displacement_vector, base) {\r\n    var k = (displacement_vector[0] * base[0] + displacement_vector[1] * base[1]) / (base[0] * base[0] + base[1] * base[1]);\r\n    return [base[0] * k, base[1] * k];\r\n  }\r\n  /**\r\n   * @private\r\n   */\r\n  _countVector(start, end) {\r\n    return [end[0] - start[0], end[1] - start[1]];\r\n  }\r\n  /**\r\n   * @private\r\n   */\r\n  _movePoint(point, displacementVector) {\r\n    return [point[0]+displacementVector[0], point[1]+displacementVector[1]];\r\n  }\r\n  \r\n  \r\n}\r\n\r\n/** Cursors for transform\r\n*/\r\nol_interaction_Transform.prototype.Cursors = {\r\n  'default': 'auto',\r\n  'select': 'pointer',\r\n  'translate': 'move',\r\n  'rotate': 'move',\r\n  'rotate0': 'move',\r\n  'scale': 'nesw-resize',\r\n  'scale1': 'nwse-resize',\r\n  'scale2': 'nesw-resize',\r\n  'scale3': 'nwse-resize',\r\n  'scalev': 'ew-resize',\r\n  'scaleh1': 'ns-resize',\r\n  'scalev2': 'ew-resize',\r\n  'scaleh3': 'ns-resize'\r\n};\r\n\r\nexport default ol_interaction_Transform\r\n","import ol_source_Vector from 'ol/source/Vector.js'\r\n\r\n;(function () {\r\n  var clear = ol_source_Vector.prototype.clear;\r\n\r\n  /** Overwrite ol/source/Vector clear to fire clearstart / clearend event\r\n   */\r\n  ol_source_Vector.prototype.clear = function(opt_fast) {\r\n    this.dispatchEvent({ type: 'clearstart' });\r\n    clear.call(this, opt_fast)\r\n    this.dispatchEvent({ type: 'clearend' });\r\n  };\r\n})();\r\n","import ol_Collection from 'ol/Collection.js'\r\nimport ol_interaction_Interaction from 'ol/interaction/Interaction.js'\r\nimport ol_source_Vector from 'ol/source/Vector.js'\r\nimport {unByKey as ol_Observable_unByKey} from 'ol/Observable.js'\r\nimport '../source/Vector.js'\r\n\r\n/** Undo/redo interaction\r\n * @constructor\r\n * @extends {ol_interaction_Interaction}\r\n * @fires undo\r\n * @fires redo\r\n * @fires change:add\r\n * @fires change:remove\r\n * @fires change:clear\r\n * @param {Object} options\r\n *  @param {number=} options.maxLength max undo stack length (0=Infinity), default Infinity\r\n *  @param {Array<ol.Layer>} options.layers array of layers to undo/redo\r\n */\r\nvar ol_interaction_UndoRedo = class olinteractionUndoRedo extends ol_interaction_Interaction {\r\n  constructor(options) {\r\n    options = options || {}\r\n\r\n    super({\r\n      handleEvent: function () {\r\n        return true\r\n      }\r\n    })\r\n\r\n    //array of layers to undo/redo\r\n    this._layers = options.layers\r\n\r\n    this._undoStack = new ol_Collection()\r\n    this._redoStack = new ol_Collection()\r\n    // Zero level stack\r\n    this._undo = []\r\n    this._redo = []\r\n    this._undoStack.on('add', function (e) {\r\n      if (e.element.level === undefined) {\r\n        e.element.level = this._level\r\n        if (!e.element.level) {\r\n          e.element.view = {\r\n            center: this.getMap().getView().getCenter(),\r\n            zoom: this.getMap().getView().getZoom()\r\n          }\r\n          this._undo.push(e.element)\r\n        }\r\n      } else {\r\n        if (!e.element.level)\r\n          this._undo.push(this._redo.shift())\r\n      }\r\n      if (!e.element.level) {\r\n        this.dispatchEvent({\r\n          type: 'stack:add',\r\n          action: e.element\r\n        })\r\n      }\r\n      this._reduce()\r\n    }.bind(this))\r\n    this._undoStack.on('remove', function (e) {\r\n      if (!e.element.level) {\r\n        if (this._doShift) {\r\n          this._undo.shift()\r\n        } else {\r\n          if (this._undo.length)\r\n            this._redo.push(this._undo.pop())\r\n        }\r\n        if (!this._doClear) {\r\n          this.dispatchEvent({\r\n            type: 'stack:remove',\r\n            action: e.element,\r\n            shift: this._doShift\r\n          })\r\n        }\r\n      }\r\n    }.bind(this))\r\n    // Block counter\r\n    this._block = 0\r\n    this._level = 0\r\n    // Shift an undo action ?\r\n    this._doShift = false\r\n    // Start recording\r\n    this._record = true\r\n    // Custom definitions\r\n    this._defs = {}\r\n  }\r\n  /** Add a custom undo/redo\r\n   * @param {string} action the action key name\r\n   * @param {function} undoFn function called when undoing\r\n   * @param {function} redoFn function called when redoing\r\n   * @api\r\n   */\r\n  define(action, undoFn, redoFn) {\r\n    this._defs[action] = { undo: undoFn, redo: redoFn }\r\n  }\r\n  /** Get first level undo / redo length\r\n   * @param {string} [type] get redo stack length, default get undo\r\n   * @return {number}\r\n   */\r\n  length(type) {\r\n    return (type === 'redo') ? this._redo.length : this._undo.length\r\n  }\r\n  /** Set undo stack max length\r\n   * @param {number} length\r\n   */\r\n  setMaxLength(length) {\r\n    length = parseInt(length)\r\n    if (length && length < 0)\r\n      length = 0\r\n    this.set('maxLength', length)\r\n    this._reduce()\r\n  }\r\n  /** Get undo / redo size (includes all block levels)\r\n   * @param {string} [type] get redo stack length, default get undo\r\n   * @return {number}\r\n   */\r\n  size(type) {\r\n    return (type === 'redo') ? this._redoStack.getLength() : this._undoStack.getLength()\r\n  }\r\n  /** Set undo stack max size\r\n   * @param {number} size\r\n   */\r\n  setMaxSize(size) {\r\n    size = parseInt(size)\r\n    if (size && size < 0)\r\n      size = 0\r\n    this.set('maxSize', size)\r\n    this._reduce()\r\n  }\r\n  /** Reduce stack: shift undo to set size\r\n   * @private\r\n   */\r\n  _reduce() {\r\n    if (this.get('maxLength')) {\r\n      while (this.length() > this.get('maxLength')) {\r\n        this.shift()\r\n      }\r\n    }\r\n    if (this.get('maxSize')) {\r\n      while (this.length() > 1 && this.size() > this.get('maxSize')) {\r\n        this.shift()\r\n      }\r\n    }\r\n  }\r\n  /** Get first level undo / redo first level stack\r\n   * @param {string} [type] get redo stack, default get undo\r\n   * @return {Array<*>}\r\n   */\r\n  getStack(type) {\r\n    return (type === 'redo') ? this._redo : this._undo\r\n  }\r\n  /** Add a new custom undo/redo\r\n   * @param {string} action the action key name\r\n   * @param {any} prop an object that will be passed in the undo/redo functions of the action\r\n   * @param {string} name action name\r\n   * @return {boolean} true if the action is defined\r\n   */\r\n  push(action, prop, name) {\r\n    if (this._defs[action]) {\r\n      this._undoStack.push({\r\n        type: action,\r\n        name: name,\r\n        custom: true,\r\n        prop: prop\r\n      })\r\n      return true\r\n    } else {\r\n      console.warn('[UndoRedoInteraction]: \"' + action + '\" is not defined.')\r\n      return false\r\n    }\r\n  }\r\n  /** Remove undo action from the beginning of the stack.\r\n   * The action is not returned.\r\n   */\r\n  shift() {\r\n    this._doShift = true\r\n    var a = this._undoStack.removeAt(0)\r\n    this._doShift = false\r\n    // Remove all block\r\n    if (a.type === 'blockstart') {\r\n      a = this._undoStack.item(0)\r\n      while (this._undoStack.getLength() && a.level > 0) {\r\n        this._undoStack.removeAt(0)\r\n        a = this._undoStack.item(0)\r\n      }\r\n    }\r\n  }\r\n  /** Activate or deactivate the interaction, ie. records or not events on the map.\r\n   * @param {boolean} active\r\n   * @api stable\r\n   */\r\n  setActive(active) {\r\n    super.setActive(active)\r\n    this._record = active\r\n  }\r\n  /**\r\n   * Remove the interaction from its current map, if any, and attach it to a new\r\n   * map, if any. Pass `null` to just remove the interaction from the current map.\r\n   * @param {ol.Map} map Map.\r\n   * @api stable\r\n   */\r\n  setMap(map) {\r\n    if (this._mapListener) {\r\n      this._mapListener.forEach(function (l) { ol_Observable_unByKey(l) })\r\n    }\r\n    this._mapListener = []\r\n    super.setMap(map)\r\n    // Watch blocks\r\n    if (map) {\r\n      this._mapListener.push(map.on('undoblockstart', this.blockStart.bind(this)))\r\n      this._mapListener.push(map.on('undoblockend', this.blockEnd.bind(this)))\r\n    }\r\n    // Watch sources\r\n    this._watchSources()\r\n    this._watchInteractions()\r\n  }\r\n  /** Watch for changes in the map sources\r\n   * @private\r\n   */\r\n  _watchSources() {\r\n    var map = this.getMap()\r\n    // Clear listeners\r\n    if (this._sourceListener) {\r\n      this._sourceListener.forEach(function (l) { ol_Observable_unByKey(l) })\r\n    }\r\n    this._sourceListener = []\r\n\r\n    var self = this\r\n\r\n    // Ges vector layers \r\n    function getVectorLayers(layers, init) {\r\n      if (!init) {\r\n        init = []\r\n      }\r\n      layers.forEach(function (l) {\r\n        if (l.getSource && l.getSource() instanceof ol_source_Vector) {\r\n          if (!self._layers || self._layers.indexOf(l) >= 0) {\r\n            init.push(l)\r\n          }\r\n        } else if (l.getLayers) {\r\n          getVectorLayers(l.getLayers(), init)\r\n        }\r\n      })\r\n      return init\r\n    }\r\n\r\n    if (map) {\r\n      // Watch the vector sources in the map \r\n      var vectors = getVectorLayers(map.getLayers())\r\n      vectors.forEach((function (l) {\r\n        var s = l.getSource()\r\n        this._sourceListener.push(s.on(['addfeature', 'removefeature'], this._onAddRemove.bind(this)))\r\n        this._sourceListener.push(s.on('clearstart', function () {\r\n          this.blockStart('clear')\r\n        }.bind(this)))\r\n        this._sourceListener.push(s.on('clearend', this.blockEnd.bind(this)))\r\n      }).bind(this))\r\n\r\n      // Watch new inserted/removed\r\n      this._sourceListener.push(map.getLayers().on(['add', 'remove'], this._watchSources.bind(this)))\r\n    }\r\n  }\r\n  /** Watch for interactions\r\n   * @private\r\n   */\r\n  _watchInteractions() {\r\n    var map = this.getMap()\r\n    // Clear listeners\r\n    if (this._interactionListener) {\r\n      this._interactionListener.forEach(function (l) { ol_Observable_unByKey(l) })\r\n    }\r\n    this._interactionListener = []\r\n\r\n    if (map) {\r\n      // Watch the interactions in the map \r\n      map.getInteractions().forEach((function (i) {\r\n        this._interactionListener.push(i.on(\r\n          ['setattributestart', 'modifystart', 'rotatestart', 'translatestart', 'scalestart', 'deletestart', 'deleteend', 'beforesplit', 'aftersplit'],\r\n          this._onInteraction.bind(this)\r\n        ))\r\n      }).bind(this))\r\n\r\n      // Watch new inserted / unwatch removed\r\n      this._interactionListener.push(map.getInteractions().on(\r\n        ['add', 'remove'],\r\n        this._watchInteractions.bind(this)\r\n      ))\r\n    }\r\n  }\r\n  /** A feature is added / removed\r\n   */\r\n  _onAddRemove(e) {\r\n    if (this._record) {\r\n      this._redoStack.clear()\r\n      this._redo.length = 0\r\n      this._undoStack.push({\r\n        type: e.type,\r\n        source: e.target,\r\n        feature: e.feature\r\n      })\r\n    }\r\n  }\r\n  /** Perform an interaction\r\n   * @private\r\n   */\r\n  _onInteraction(e) {\r\n    var fn = this._onInteraction[e.type]\r\n    if (fn)\r\n      fn.call(this, e)\r\n  }\r\n  /** Start an undo block\r\n   * @param {string} [name] name f the action\r\n   * @api\r\n   */\r\n  blockStart(name) {\r\n    this._redoStack.clear()\r\n    this._redo.length = 0\r\n    this._undoStack.push({\r\n      type: 'blockstart',\r\n      name: name\r\n    })\r\n    this._level++\r\n  }\r\n  /** End an undo block\r\n   * @api\r\n   */\r\n  blockEnd() {\r\n    this._undoStack.push({ type: 'blockend' })\r\n    this._level--\r\n  }\r\n  /** handle undo/redo\r\n   * @private\r\n   */\r\n  _handleDo(e, undo) {\r\n    // Not active\r\n    if (!this.getActive())\r\n      return\r\n\r\n    // Stop recording while undoing\r\n    this._record = false\r\n    if (e.custom) {\r\n      if (this._defs[e.type]) {\r\n        if (undo)\r\n          this._defs[e.type].undo(e.prop)\r\n        else\r\n          this._defs[e.type].redo(e.prop)\r\n      } else {\r\n        console.warn('[UndoRedoInteraction]: \"' + e.type + '\" is not defined.')\r\n      }\r\n    } else {\r\n      switch (e.type) {\r\n        case 'addfeature': {\r\n          if (undo)\r\n            e.source.removeFeature(e.feature)\r\n          else\r\n            e.source.addFeature(e.feature)\r\n          break\r\n        }\r\n        case 'removefeature': {\r\n          if (undo)\r\n            e.source.addFeature(e.feature)\r\n          else\r\n            e.source.removeFeature(e.feature)\r\n          break\r\n        }\r\n        case 'changegeometry': {\r\n          var geom = e.feature.getGeometry()\r\n          e.feature.setGeometry(e.oldGeom)\r\n          e.oldGeom = geom\r\n          break\r\n        }\r\n        case 'changeattribute': {\r\n          var newp = e.newProperties\r\n          var oldp = e.oldProperties\r\n          for (var p in oldp) {\r\n            if (oldp === undefined)\r\n              e.feature.unset(p)\r\n            else\r\n              e.feature.set(p, oldp[p])\r\n          }\r\n          e.oldProperties = newp\r\n          e.newProperties = oldp\r\n          break\r\n        }\r\n        case 'blockstart': {\r\n          this._block += undo ? -1 : 1\r\n          break\r\n        }\r\n        case 'blockend': {\r\n          this._block += undo ? 1 : -1\r\n          break\r\n        }\r\n        default: {\r\n          console.warn('[UndoRedoInteraction]: \"' + e.type + '\" is not defined.')\r\n        }\r\n      }\r\n    }\r\n\r\n    // Handle block\r\n    if (this._block < 0)\r\n      this._block = 0\r\n    if (this._block) {\r\n      if (undo)\r\n        this.undo()\r\n      else\r\n        this.redo()\r\n    }\r\n    this._record = true\r\n\r\n    // Dispatch event\r\n    this.dispatchEvent({\r\n      type: undo ? 'undo' : 'redo',\r\n      action: e\r\n    })\r\n  }\r\n  /** Undo last operation\r\n   * @api\r\n   */\r\n  undo() {\r\n    var e = this._undoStack.item(this._undoStack.getLength() - 1)\r\n    if (!e)\r\n      return\r\n    this._redoStack.push(e)\r\n    this._undoStack.pop()\r\n    this._handleDo(e, true)\r\n  }\r\n  /** Redo last operation\r\n   * @api\r\n   */\r\n  redo() {\r\n    var e = this._redoStack.item(this._redoStack.getLength() - 1)\r\n    if (!e)\r\n      return\r\n    this._undoStack.push(e)\r\n    this._redoStack.pop()\r\n    this._handleDo(e, false)\r\n  }\r\n  /** Clear undo stack\r\n   * @api\r\n   */\r\n  clear() {\r\n    this._doClear = true\r\n    this._undo.length = this._redo.length = 0\r\n    this._undoStack.clear()\r\n    this._redoStack.clear()\r\n    this._doClear = false\r\n    this.dispatchEvent({ type: 'stack:clear' })\r\n  }\r\n  /** Check if undo is avaliable\r\n   * @return {number} the number of undo\r\n   * @api\r\n   */\r\n  hasUndo() {\r\n    return this._undoStack.getLength()\r\n  }\r\n  /** Check if redo is avaliable\r\n   * @return {number} the number of redo\r\n   * @api\r\n   */\r\n  hasRedo() {\r\n    return this._redoStack.getLength()\r\n  }\r\n}\r\n\r\n/** Set attribute\r\n * @private\r\n */\r\nol_interaction_UndoRedo.prototype._onInteraction.setattributestart = function(e) {\r\n  this.blockStart(e.target.get('name') || 'setattribute');\r\n  var newp = Object.assign({}, e.properties);\r\n  e.features.forEach(function(f) {\r\n    var oldp = {};\r\n    for (var p in newp) {\r\n      oldp[p] = f.get(p);\r\n    }\r\n    this._undoStack.push({\r\n      type: 'changeattribute', \r\n      feature: f,\r\n      newProperties: newp,\r\n      oldProperties: oldp\r\n    });\r\n  }.bind(this));\r\n  this.blockEnd();\r\n};\r\n\r\nol_interaction_UndoRedo.prototype._onInteraction.rotatestart = \r\nol_interaction_UndoRedo.prototype._onInteraction.translatestart = \r\nol_interaction_UndoRedo.prototype._onInteraction.scalestart = \r\nol_interaction_UndoRedo.prototype._onInteraction.modifystart = function (e) {\r\n  this.blockStart(e.type.replace(/start$/,''));\r\n  e.features.forEach(function(m) {\r\n    this._undoStack.push({ \r\n      type: 'changegeometry', \r\n      feature: m, \r\n      oldGeom: m.getGeometry().clone() \r\n    });\r\n  }.bind(this));\r\n  this.blockEnd();\r\n};\r\n\r\n\r\n/** @private\r\n */\r\nol_interaction_UndoRedo.prototype._onInteraction.beforesplit = function() {\r\n  // Check modify before split\r\n  var l = this._undoStack.getLength();\r\n  if (l>2 \r\n    && this._undoStack.item(l-1).type === 'blockend'\r\n    && this._undoStack.item(l-2).type === 'changegeometry') {\r\n    this._undoStack.pop();\r\n  } else {\r\n    this.blockStart('split');\r\n  }\r\n};\r\nol_interaction_UndoRedo.prototype._onInteraction.deletestart = function() {\r\n  this.blockStart('delete');\r\n}\r\n\r\n\r\n/** @private\r\n */\r\nol_interaction_UndoRedo.prototype._onInteraction.aftersplit =\r\nol_interaction_UndoRedo.prototype._onInteraction.deleteend =\r\nol_interaction_UndoRedo.prototype.blockEnd;\r\n\r\nexport default ol_interaction_UndoRedo\r\n","import ol_style_Style from 'ol/style/Style.js'\r\nimport ol_style_Circle from 'ol/style/Circle.js'\r\nimport ol_style_Stroke from 'ol/style/Stroke.js'\r\nimport ol_style_Fill from 'ol/style/Fill.js'\r\n\r\nvar ol_style_Style_defaultStyle;\r\n\r\n(function() {\r\n\r\n// Style\r\nvar white = [255, 255, 255, 1];\r\nvar blue = [0, 153, 255, 1];\r\nvar width = 3;\r\n\r\nvar defaultEditStyle = [\r\n  new ol_style_Style({\r\n    stroke: new ol_style_Stroke({ color: white, width: width + 2 })\r\n  }),\r\n  new ol_style_Style({\r\n    image: new ol_style_Circle({\r\n      radius: width * 2,\r\n      fill: new ol_style_Fill({ color: blue }),\r\n      stroke: new ol_style_Stroke({ color: white, width: width / 2 })\r\n    }),\r\n    stroke: new ol_style_Stroke({ color: blue, width: width }),\r\n    fill: new ol_style_Fill({\r\n      color: [255, 255, 255, 0.5]\r\n    })\r\n  })\r\n];\r\n\r\n/**\r\n * Get the default style\r\n * @param {boolean|*} [edit] true to get editing style or a { color, fillColor } object, default get default blue style\r\n * @return {Array<ol.style.Style>}\r\n */\r\nol_style_Style_defaultStyle = function(edit) {\r\n  if (edit===true) {\r\n    return defaultEditStyle;\r\n  } else {\r\n    edit = edit || {};\r\n    var fill = new ol_style_Fill({\r\n      color: edit.fillColor || 'rgba(255,255,255,0.4)'\r\n    });\r\n    var stroke = new ol_style_Stroke({\r\n      color: edit.color || '#3399CC',\r\n      width: 1.25\r\n    });\r\n    var style = new ol_style_Style({\r\n      image: new ol_style_Circle({\r\n        fill: fill,\r\n        stroke: stroke,\r\n        radius: 5\r\n      }),\r\n      fill: fill,\r\n      stroke: stroke\r\n    });\r\n    return [ style ];\r\n  }\r\n};\r\n\r\n})();\r\n\r\nexport default ol_style_Style_defaultStyle\r\n","/**\n * @module ol/geom/Circle\n */\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {createOrUpdate, forEachCorner, intersects} from '../extent.js';\nimport {deflateCoordinate} from './flat/deflate.js';\nimport {rotate} from './flat/transform.js';\n\n/**\n * @classdesc\n * Circle geometry.\n *\n * @api\n */\nclass Circle extends SimpleGeometry {\n  /**\n   * @param {!import(\"../coordinate.js\").Coordinate} center Center.\n   *     For internal use, flat coordinates in combination with `layout` and no\n   *     `radius` are also accepted.\n   * @param {number} [radius] Radius in units of the projection.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   */\n  constructor(center, radius, layout) {\n    super();\n    if (layout !== undefined && radius === undefined) {\n      this.setFlatCoordinates(layout, center);\n    } else {\n      radius = radius ? radius : 0;\n      this.setCenterAndRadius(center, radius, layout);\n    }\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!Circle} Clone.\n   * @api\n   */\n  clone() {\n    const circle = new Circle(\n      this.flatCoordinates.slice(),\n      undefined,\n      this.layout,\n    );\n    circle.applyProperties(this);\n    return circle;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    const flatCoordinates = this.flatCoordinates;\n    const dx = x - flatCoordinates[0];\n    const dy = y - flatCoordinates[1];\n    const squaredDistance = dx * dx + dy * dy;\n    if (squaredDistance < minSquaredDistance) {\n      if (squaredDistance === 0) {\n        for (let i = 0; i < this.stride; ++i) {\n          closestPoint[i] = flatCoordinates[i];\n        }\n      } else {\n        const delta = this.getRadius() / Math.sqrt(squaredDistance);\n        closestPoint[0] = flatCoordinates[0] + delta * dx;\n        closestPoint[1] = flatCoordinates[1] + delta * dy;\n        for (let i = 2; i < this.stride; ++i) {\n          closestPoint[i] = flatCoordinates[i];\n        }\n      }\n      closestPoint.length = this.stride;\n      return squaredDistance;\n    }\n    return minSquaredDistance;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @return {boolean} Contains (x, y).\n   */\n  containsXY(x, y) {\n    const flatCoordinates = this.flatCoordinates;\n    const dx = x - flatCoordinates[0];\n    const dy = y - flatCoordinates[1];\n    return dx * dx + dy * dy <= this.getRadiusSquared_();\n  }\n\n  /**\n   * Return the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.\n   * @return {import(\"../coordinate.js\").Coordinate} Center.\n   * @api\n   */\n  getCenter() {\n    return this.flatCoordinates.slice(0, this.stride);\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @protected\n   * @return {import(\"../extent.js\").Extent} extent Extent.\n   */\n  computeExtent(extent) {\n    const flatCoordinates = this.flatCoordinates;\n    const radius = flatCoordinates[this.stride] - flatCoordinates[0];\n    return createOrUpdate(\n      flatCoordinates[0] - radius,\n      flatCoordinates[1] - radius,\n      flatCoordinates[0] + radius,\n      flatCoordinates[1] + radius,\n      extent,\n    );\n  }\n\n  /**\n   * Return the radius of the circle.\n   * @return {number} Radius.\n   * @api\n   */\n  getRadius() {\n    return Math.sqrt(this.getRadiusSquared_());\n  }\n\n  /**\n   * @private\n   * @return {number} Radius squared.\n   */\n  getRadiusSquared_() {\n    const dx = this.flatCoordinates[this.stride] - this.flatCoordinates[0];\n    const dy = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];\n    return dx * dx + dy * dy;\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   */\n  getType() {\n    return 'Circle';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   */\n  intersectsExtent(extent) {\n    const circleExtent = this.getExtent();\n    if (intersects(extent, circleExtent)) {\n      const center = this.getCenter();\n\n      if (extent[0] <= center[0] && extent[2] >= center[0]) {\n        return true;\n      }\n      if (extent[1] <= center[1] && extent[3] >= center[1]) {\n        return true;\n      }\n\n      return forEachCorner(extent, this.intersectsCoordinate.bind(this));\n    }\n    return false;\n  }\n\n  /**\n   * Set the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.\n   * @param {import(\"../coordinate.js\").Coordinate} center Center.\n   * @api\n   */\n  setCenter(center) {\n    const stride = this.stride;\n    const radius = this.flatCoordinates[stride] - this.flatCoordinates[0];\n    const flatCoordinates = center.slice();\n    flatCoordinates[stride] = flatCoordinates[0] + radius;\n    for (let i = 1; i < stride; ++i) {\n      flatCoordinates[stride + i] = center[i];\n    }\n    this.setFlatCoordinates(this.layout, flatCoordinates);\n    this.changed();\n  }\n\n  /**\n   * Set the center (as {@link module:ol/coordinate~Coordinate coordinate}) and the radius (as\n   * number) of the circle.\n   * @param {!import(\"../coordinate.js\").Coordinate} center Center.\n   * @param {number} radius Radius.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @api\n   */\n  setCenterAndRadius(center, radius, layout) {\n    this.setLayout(layout, center, 0);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    /** @type {Array<number>} */\n    const flatCoordinates = this.flatCoordinates;\n    let offset = deflateCoordinate(flatCoordinates, 0, center, this.stride);\n    flatCoordinates[offset++] = flatCoordinates[0] + radius;\n    for (let i = 1, ii = this.stride; i < ii; ++i) {\n      flatCoordinates[offset++] = flatCoordinates[i];\n    }\n    flatCoordinates.length = offset;\n    this.changed();\n  }\n\n  getCoordinates() {\n    return null;\n  }\n\n  setCoordinates(coordinates, layout) {}\n\n  /**\n   * Set the radius of the circle. The radius is in the units of the projection.\n   * @param {number} radius Radius.\n   * @api\n   */\n  setRadius(radius) {\n    this.flatCoordinates[this.stride] = this.flatCoordinates[0] + radius;\n    this.changed();\n  }\n\n  /**\n   * Rotate the geometry around a given coordinate. This modifies the geometry\n   * coordinates in place.\n   * @param {number} angle Rotation angle in counter-clockwise radians.\n   * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\n   * @api\n   */\n  rotate(angle, anchor) {\n    const center = this.getCenter();\n    const stride = this.getStride();\n    this.setCenter(\n      rotate(center, 0, center.length, stride, angle, anchor, center),\n    );\n    this.changed();\n  }\n}\n\n/**\n * Transform each coordinate of the circle from one coordinate reference system\n * to another. The geometry is modified in place.\n * If you do not want the geometry modified in place, first clone() it and\n * then use this function on the clone.\n *\n * Internally a circle is currently represented by two points: the center of\n * the circle `[cx, cy]`, and the point to the right of the circle\n * `[cx + r, cy]`. This `transform` function just transforms these two points.\n * So the resulting geometry is also a circle, and that circle does not\n * correspond to the shape that would be obtained by transforming every point\n * of the original circle.\n *\n * @param {import(\"../proj.js\").ProjectionLike} source The current projection.  Can be a\n *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n * @param {import(\"../proj.js\").ProjectionLike} destination The desired projection.  Can be a\n *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n * @return {Circle} This geometry.  Note that original geometry is\n *     modified in place.\n * @function\n * @api\n */\nCircle.prototype.transform;\nexport default Circle;\n","/**\n * @module ol/interaction/Draw\n */\nimport Circle from '../geom/Circle.js';\nimport Event from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport Feature from '../Feature.js';\nimport GeometryCollection from '../geom/GeometryCollection.js';\nimport InteractionProperty from './Property.js';\nimport LineString from '../geom/LineString.js';\nimport MapBrowserEvent from '../MapBrowserEvent.js';\nimport MapBrowserEventType from '../MapBrowserEventType.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport PointerInteraction from './Pointer.js';\nimport Polygon, {fromCircle, makeRegular} from '../geom/Polygon.js';\nimport VectorLayer from '../layer/Vector.js';\nimport VectorSource from '../source/Vector.js';\nimport {FALSE, TRUE} from '../functions.js';\nimport {\n  always,\n  never,\n  noModifierKeys,\n  shiftKeyOnly,\n} from '../events/condition.js';\nimport {\n  boundingExtent,\n  getBottomLeft,\n  getBottomRight,\n  getTopLeft,\n  getTopRight,\n} from '../extent.js';\nimport {clamp, squaredDistance, toFixed} from '../math.js';\nimport {createEditingStyle} from '../style/Style.js';\nimport {\n  distance,\n  squaredDistance as squaredCoordinateDistance,\n} from '../coordinate.js';\nimport {fromUserCoordinate, getUserProjection} from '../proj.js';\nimport {getStrideForLayout} from '../geom/SimpleGeometry.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../geom/Geometry.js\").Type} type Geometry type of\n * the geometries being drawn with this instance.\n * @property {number} [clickTolerance=6] The maximum distance in pixels between\n * \"down\" and \"up\" for a \"up\" event to be considered a \"click\" event and\n * actually add a point/vertex to the geometry being drawn.  The default of `6`\n * was chosen for the draw interaction to behave correctly on mouse as well as\n * on touch devices.\n * @property {import(\"../Collection.js\").default<Feature>} [features]\n * Destination collection for the drawn features.\n * @property {VectorSource} [source] Destination source for\n * the drawn features.\n * @property {number} [dragVertexDelay=500] Delay in milliseconds after pointerdown\n * before the current vertex can be dragged to its exact position.\n * @property {number} [snapTolerance=12] Pixel distance for snapping to the\n * drawing finish. Must be greater than `0`.\n * @property {boolean} [stopClick=false] Stop click, singleclick, and\n * doubleclick events from firing during drawing.\n * @property {number} [maxPoints] The number of points that can be drawn before\n * a polygon ring or line string is finished. By default there is no\n * restriction.\n * @property {number} [minPoints] The number of points that must be drawn\n * before a polygon ring or line string can be finished. Default is `3` for\n * polygon rings and `2` for line strings.\n * @property {import(\"../events/condition.js\").Condition} [finishCondition] A function\n * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether the drawing can be finished. Not used when drawing\n * POINT or MULTI_POINT geometries.\n * @property {import(\"../style/Style.js\").StyleLike|import(\"../style/flat.js\").FlatStyleLike} [style]\n * Style for sketch features. The draw interaction can have up to three sketch features, depending on the mode.\n * It will always contain a feature with a `Point` geometry that corresponds to the current cursor position.\n * If the mode is `LineString` or `Polygon`, and there is at least one drawn point, it will also contain a feature with\n * a `LineString` geometry that corresponds to the line between the already drawn points and the current cursor position.\n * If the mode is `Polygon`, and there is at least one drawn point, it will also contain a feature with a `Polygon`\n * geometry that corresponds to the polygon between the already drawn points and the current cursor position\n * (note that this polygon has only two points if only one point is drawn).\n * If the mode is `Circle`, and there is one point drawn, it will also contain a feature with a `Circle` geometry whose\n * center is the drawn point and the radius is determined by the distance between the drawn point and the cursor.\n * @property {GeometryFunction} [geometryFunction]\n * Function that is called when a geometry's coordinates are updated.\n * @property {string} [geometryName] Geometry name to use for features created\n * by the draw interaction.\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * By default {@link module:ol/events/condition.noModifierKeys}, i.e. a click,\n * adds a vertex or deactivates freehand drawing.\n * @property {boolean} [freehand=false] Operate in freehand mode for lines,\n * polygons, and circles.  This makes the interaction always operate in freehand\n * mode and takes precedence over any `freehandCondition` option.\n * @property {import(\"../events/condition.js\").Condition} [freehandCondition]\n * Condition that activates freehand drawing for lines and polygons. This\n * function takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and\n * returns a boolean to indicate whether that event should be handled. The\n * default is {@link module:ol/events/condition.shiftKeyOnly}, meaning that the\n * Shift key activates freehand drawing.\n * @property {boolean|import(\"../events/condition.js\").Condition} [trace=false] Trace a portion of another geometry.\n * Ignored when in freehand mode.\n * @property {VectorSource} [traceSource] Source for features to trace.  If tracing is active and a `traceSource` is\n * not provided, the interaction's `source` will be used.  Tracing requires that the interaction is configured with\n * either a `traceSource` or a `source`.\n * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch\n * overlay.\n * @property {import(\"../geom/Geometry.js\").GeometryLayout} [geometryLayout='XY'] Layout of the\n * feature geometries created by the draw interaction.\n */\n\n/**\n * Coordinate type when drawing points.\n * @typedef {import(\"../coordinate.js\").Coordinate} PointCoordType\n */\n\n/**\n * Coordinate type when drawing lines.\n * @typedef {Array<import(\"../coordinate.js\").Coordinate>} LineCoordType\n */\n\n/**\n * Coordinate type when drawing polygons.\n * @typedef {Array<Array<import(\"../coordinate.js\").Coordinate>>} PolyCoordType\n */\n\n/**\n * Types used for drawing coordinates.\n * @typedef {PointCoordType|LineCoordType|PolyCoordType} SketchCoordType\n */\n\n/**\n * @typedef {Object} TraceState\n * @property {boolean} active Tracing active.\n * @property {import(\"../pixel.js\").Pixel} [startPx] The initially clicked pixel location.\n * @property {Array<TraceTarget>} [targets] Targets available for tracing.\n * @property {number} [targetIndex] The index of the currently traced target.  A value of -1 indicates\n * that no trace target is active.\n */\n\n/**\n * @typedef {Object} TraceTarget\n * @property {Array<import(\"../coordinate.js\").Coordinate>} coordinates Target coordinates.\n * @property {boolean} ring The target coordinates are a linear ring.\n * @property {number} startIndex The index of first traced coordinate.  A fractional index represents an\n * edge intersection.  Index values for rings will wrap (may be negative or larger than coordinates length).\n * @property {number} endIndex The index of last traced coordinate.  Details from startIndex also apply here.\n */\n\n/**\n * Function that takes an array of coordinates and an optional existing geometry\n * and a projection as arguments, and returns a geometry. The optional existing\n * geometry is the geometry that is returned when the function is called without\n * a second argument.\n * @typedef {function(!SketchCoordType, import(\"../geom/SimpleGeometry.js\").default,\n *     import(\"../proj/Projection.js\").default):\n *     import(\"../geom/SimpleGeometry.js\").default} GeometryFunction\n */\n\n/**\n * @typedef {'Point' | 'LineString' | 'Polygon' | 'Circle'} Mode\n * Draw mode.  This collapses multi-part geometry types with their single-part\n * cousins.\n */\n\n/**\n * @enum {string}\n */\nconst DrawEventType = {\n  /**\n   * Triggered upon feature draw start\n   * @event DrawEvent#drawstart\n   * @api\n   */\n  DRAWSTART: 'drawstart',\n  /**\n   * Triggered upon feature draw end\n   * @event DrawEvent#drawend\n   * @api\n   */\n  DRAWEND: 'drawend',\n  /**\n   * Triggered upon feature draw abortion\n   * @event DrawEvent#drawabort\n   * @api\n   */\n  DRAWABORT: 'drawabort',\n};\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/Draw~Draw} instances are\n * instances of this type.\n */\nexport class DrawEvent extends Event {\n  /**\n   * @param {DrawEventType} type Type.\n   * @param {Feature} feature The feature drawn.\n   */\n  constructor(type, feature) {\n    super(type);\n\n    /**\n     * The feature being drawn.\n     * @type {Feature}\n     * @api\n     */\n    this.feature = feature;\n  }\n}\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} coordinate The coordinate.\n * @param {Array<Feature>} features The candidate features.\n * @return {Array<TraceTarget>} The trace targets.\n */\nfunction getTraceTargets(coordinate, features) {\n  /**\n   * @type {Array<TraceTarget>}\n   */\n  const targets = [];\n\n  for (let i = 0; i < features.length; ++i) {\n    const feature = features[i];\n    const geometry = feature.getGeometry();\n    appendGeometryTraceTargets(coordinate, geometry, targets);\n  }\n\n  return targets;\n}\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} a One coordinate.\n * @param {import(\"../coordinate.js\").Coordinate} b Another coordinate.\n * @return {number} The squared distance between the two coordinates.\n */\nfunction getSquaredDistance(a, b) {\n  return squaredDistance(a[0], a[1], b[0], b[1]);\n}\n\n/**\n * @param {LineCoordType} coordinates The ring coordinates.\n * @param {number} index The index.  May be wrapped.\n * @return {import(\"../coordinate.js\").Coordinate} The coordinate.\n */\nfunction getCoordinate(coordinates, index) {\n  const count = coordinates.length;\n  if (index < 0) {\n    return coordinates[index + count];\n  }\n  if (index >= count) {\n    return coordinates[index - count];\n  }\n  return coordinates[index];\n}\n\n/**\n * Get the cumulative squared distance along a ring path.  The end index index may be \"wrapped\" and it may\n * be less than the start index to indicate the direction of travel.  The start and end index may have\n * a fractional part to indicate a point between two coordinates.\n * @param {LineCoordType} coordinates Ring coordinates.\n * @param {number} startIndex The start index.\n * @param {number} endIndex The end index.\n * @return {number} The cumulative squared distance along the ring path.\n */\nfunction getCumulativeSquaredDistance(coordinates, startIndex, endIndex) {\n  let lowIndex, highIndex;\n  if (startIndex < endIndex) {\n    lowIndex = startIndex;\n    highIndex = endIndex;\n  } else {\n    lowIndex = endIndex;\n    highIndex = startIndex;\n  }\n  const lowWholeIndex = Math.ceil(lowIndex);\n  const highWholeIndex = Math.floor(highIndex);\n\n  if (lowWholeIndex > highWholeIndex) {\n    // both start and end are on the same segment\n    const start = interpolateCoordinate(coordinates, lowIndex);\n    const end = interpolateCoordinate(coordinates, highIndex);\n    return getSquaredDistance(start, end);\n  }\n\n  let sd = 0;\n\n  if (lowIndex < lowWholeIndex) {\n    const start = interpolateCoordinate(coordinates, lowIndex);\n    const end = getCoordinate(coordinates, lowWholeIndex);\n    sd += getSquaredDistance(start, end);\n  }\n\n  if (highWholeIndex < highIndex) {\n    const start = getCoordinate(coordinates, highWholeIndex);\n    const end = interpolateCoordinate(coordinates, highIndex);\n    sd += getSquaredDistance(start, end);\n  }\n\n  for (let i = lowWholeIndex; i < highWholeIndex - 1; ++i) {\n    const start = getCoordinate(coordinates, i);\n    const end = getCoordinate(coordinates, i + 1);\n    sd += getSquaredDistance(start, end);\n  }\n\n  return sd;\n}\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} coordinate The coordinate.\n * @param {import(\"../geom/Geometry.js\").default} geometry The candidate geometry.\n * @param {Array<TraceTarget>} targets The trace targets.\n */\nfunction appendGeometryTraceTargets(coordinate, geometry, targets) {\n  if (geometry instanceof LineString) {\n    appendTraceTarget(coordinate, geometry.getCoordinates(), false, targets);\n    return;\n  }\n  if (geometry instanceof MultiLineString) {\n    const coordinates = geometry.getCoordinates();\n    for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n      appendTraceTarget(coordinate, coordinates[i], false, targets);\n    }\n    return;\n  }\n  if (geometry instanceof Polygon) {\n    const coordinates = geometry.getCoordinates();\n    for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n      appendTraceTarget(coordinate, coordinates[i], true, targets);\n    }\n    return;\n  }\n  if (geometry instanceof MultiPolygon) {\n    const polys = geometry.getCoordinates();\n    for (let i = 0, ii = polys.length; i < ii; ++i) {\n      const coordinates = polys[i];\n      for (let j = 0, jj = coordinates.length; j < jj; ++j) {\n        appendTraceTarget(coordinate, coordinates[j], true, targets);\n      }\n    }\n    return;\n  }\n  if (geometry instanceof GeometryCollection) {\n    const geometries = geometry.getGeometries();\n    for (let i = 0; i < geometries.length; ++i) {\n      appendGeometryTraceTargets(coordinate, geometries[i], targets);\n    }\n    return;\n  }\n  // other types cannot be traced\n}\n\n/**\n * @typedef {Object} TraceTargetUpdateInfo\n * @property {number} index The new target index.\n * @property {number} endIndex The new segment end index.\n */\n\n/**\n * @type {TraceTargetUpdateInfo}\n */\nconst sharedUpdateInfo = {index: -1, endIndex: NaN};\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} coordinate The coordinate.\n * @param {TraceState} traceState The trace state.\n * @param {import(\"../Map.js\").default} map The map.\n * @param {number} snapTolerance The snap tolerance.\n * @return {TraceTargetUpdateInfo} Information about the new trace target.  The returned\n * object is reused between calls and must not be modified by the caller.\n */\nfunction getTraceTargetUpdate(coordinate, traceState, map, snapTolerance) {\n  const x = coordinate[0];\n  const y = coordinate[1];\n\n  let closestTargetDistance = Infinity;\n\n  let newTargetIndex = -1;\n  let newEndIndex = NaN;\n\n  for (\n    let targetIndex = 0;\n    targetIndex < traceState.targets.length;\n    ++targetIndex\n  ) {\n    const target = traceState.targets[targetIndex];\n    const coordinates = target.coordinates;\n\n    let minSegmentDistance = Infinity;\n    let endIndex;\n    for (\n      let coordinateIndex = 0;\n      coordinateIndex < coordinates.length - 1;\n      ++coordinateIndex\n    ) {\n      const start = coordinates[coordinateIndex];\n      const end = coordinates[coordinateIndex + 1];\n      const rel = getPointSegmentRelationship(x, y, start, end);\n      if (rel.squaredDistance < minSegmentDistance) {\n        minSegmentDistance = rel.squaredDistance;\n        endIndex = coordinateIndex + rel.along;\n      }\n    }\n\n    if (minSegmentDistance < closestTargetDistance) {\n      closestTargetDistance = minSegmentDistance;\n      if (target.ring && traceState.targetIndex === targetIndex) {\n        // same target, maintain the same trace direction\n        if (target.endIndex > target.startIndex) {\n          // forward trace\n          if (endIndex < target.startIndex) {\n            endIndex += coordinates.length;\n          }\n        } else if (target.endIndex < target.startIndex) {\n          // reverse trace\n          if (endIndex > target.startIndex) {\n            endIndex -= coordinates.length;\n          }\n        }\n      }\n      newEndIndex = endIndex;\n      newTargetIndex = targetIndex;\n    }\n  }\n\n  const newTarget = traceState.targets[newTargetIndex];\n  let considerBothDirections = newTarget.ring;\n  if (traceState.targetIndex === newTargetIndex && considerBothDirections) {\n    // only consider switching trace direction if close to the start\n    const newCoordinate = interpolateCoordinate(\n      newTarget.coordinates,\n      newEndIndex,\n    );\n    const pixel = map.getPixelFromCoordinate(newCoordinate);\n    if (distance(pixel, traceState.startPx) > snapTolerance) {\n      considerBothDirections = false;\n    }\n  }\n\n  if (considerBothDirections) {\n    const coordinates = newTarget.coordinates;\n    const count = coordinates.length;\n    const startIndex = newTarget.startIndex;\n    const endIndex = newEndIndex;\n    if (startIndex < endIndex) {\n      const forwardDistance = getCumulativeSquaredDistance(\n        coordinates,\n        startIndex,\n        endIndex,\n      );\n      const reverseDistance = getCumulativeSquaredDistance(\n        coordinates,\n        startIndex,\n        endIndex - count,\n      );\n      if (reverseDistance < forwardDistance) {\n        newEndIndex -= count;\n      }\n    } else {\n      const reverseDistance = getCumulativeSquaredDistance(\n        coordinates,\n        startIndex,\n        endIndex,\n      );\n      const forwardDistance = getCumulativeSquaredDistance(\n        coordinates,\n        startIndex,\n        endIndex + count,\n      );\n      if (forwardDistance < reverseDistance) {\n        newEndIndex += count;\n      }\n    }\n  }\n\n  sharedUpdateInfo.index = newTargetIndex;\n  sharedUpdateInfo.endIndex = newEndIndex;\n  return sharedUpdateInfo;\n}\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} coordinate The clicked coordinate.\n * @param {Array<import(\"../coordinate.js\").Coordinate>} coordinates The geometry component coordinates.\n * @param {boolean} ring The coordinates represent a linear ring.\n * @param {Array<TraceTarget>} targets The trace targets.\n */\nfunction appendTraceTarget(coordinate, coordinates, ring, targets) {\n  const x = coordinate[0];\n  const y = coordinate[1];\n  for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n    const start = coordinates[i];\n    const end = coordinates[i + 1];\n    const rel = getPointSegmentRelationship(x, y, start, end);\n    if (rel.squaredDistance === 0) {\n      const index = i + rel.along;\n      targets.push({\n        coordinates: coordinates,\n        ring: ring,\n        startIndex: index,\n        endIndex: index,\n      });\n      return;\n    }\n  }\n}\n\n/**\n * @typedef {Object} PointSegmentRelationship\n * @property {number} along The closest point expressed as a fraction along the segment length.\n * @property {number} squaredDistance The squared distance of the point to the segment.\n */\n\n/**\n * @type {PointSegmentRelationship}\n */\nconst sharedRel = {along: 0, squaredDistance: 0};\n\n/**\n * @param {number} x The point x.\n * @param {number} y The point y.\n * @param {import(\"../coordinate.js\").Coordinate} start The segment start.\n * @param {import(\"../coordinate.js\").Coordinate} end The segment end.\n * @return {PointSegmentRelationship} The point segment relationship.  The returned object is\n * shared between calls and must not be modified by the caller.\n */\nfunction getPointSegmentRelationship(x, y, start, end) {\n  const x1 = start[0];\n  const y1 = start[1];\n  const x2 = end[0];\n  const y2 = end[1];\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  let along = 0;\n  let px = x1;\n  let py = y1;\n  if (dx !== 0 || dy !== 0) {\n    along = clamp(((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy), 0, 1);\n    px += dx * along;\n    py += dy * along;\n  }\n\n  sharedRel.along = along;\n  sharedRel.squaredDistance = toFixed(squaredDistance(x, y, px, py), 10);\n  return sharedRel;\n}\n\n/**\n * @param {LineCoordType} coordinates The coordinates.\n * @param {number} index The index.  May be fractional and may wrap.\n * @return {import(\"../coordinate.js\").Coordinate} The interpolated coordinate.\n */\nfunction interpolateCoordinate(coordinates, index) {\n  const count = coordinates.length;\n\n  let startIndex = Math.floor(index);\n  const along = index - startIndex;\n  if (startIndex >= count) {\n    startIndex -= count;\n  } else if (startIndex < 0) {\n    startIndex += count;\n  }\n\n  let endIndex = startIndex + 1;\n  if (endIndex >= count) {\n    endIndex -= count;\n  }\n\n  const start = coordinates[startIndex];\n  const x0 = start[0];\n  const y0 = start[1];\n  const end = coordinates[endIndex];\n  const dx = end[0] - x0;\n  const dy = end[1] - y0;\n\n  return [x0 + dx * along, y0 + dy * along];\n}\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'drawabort'|'drawend'|'drawstart', DrawEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'drawabort'|'drawend'|'drawstart', Return>} DrawOnSignature\n */\n\n/**\n * @classdesc\n * Interaction for drawing feature geometries.\n *\n * @fires DrawEvent\n * @api\n */\nclass Draw extends PointerInteraction {\n  /**\n   * @param {Options} options Options.\n   */\n  constructor(options) {\n    const pointerOptions = /** @type {import(\"./Pointer.js\").Options} */ (\n      options\n    );\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n\n    super(pointerOptions);\n\n    /***\n     * @type {DrawOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {DrawOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {DrawOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.shouldHandle_ = false;\n\n    /**\n     * @type {import(\"../pixel.js\").Pixel}\n     * @private\n     */\n    this.downPx_ = null;\n\n    /**\n     * @type {ReturnType<typeof setTimeout>}\n     * @private\n     */\n    this.downTimeout_;\n\n    /**\n     * @type {number|undefined}\n     * @private\n     */\n    this.lastDragTime_;\n\n    /**\n     * Pointer type of the last pointermove event\n     * @type {string}\n     * @private\n     */\n    this.pointerType_;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.freehand_ = false;\n\n    /**\n     * Target source for drawn features.\n     * @type {VectorSource|null}\n     * @private\n     */\n    this.source_ = options.source ? options.source : null;\n\n    /**\n     * Target collection for drawn features.\n     * @type {import(\"../Collection.js\").default<Feature>|null}\n     * @private\n     */\n    this.features_ = options.features ? options.features : null;\n\n    /**\n     * Pixel distance for snapping.\n     * @type {number}\n     * @private\n     */\n    this.snapTolerance_ = options.snapTolerance ? options.snapTolerance : 12;\n\n    /**\n     * Geometry type.\n     * @type {import(\"../geom/Geometry.js\").Type}\n     * @private\n     */\n    this.type_ = /** @type {import(\"../geom/Geometry.js\").Type} */ (\n      options.type\n    );\n\n    /**\n     * Drawing mode (derived from geometry type.\n     * @type {Mode}\n     * @private\n     */\n    this.mode_ = getMode(this.type_);\n\n    /**\n     * Stop click, singleclick, and doubleclick events from firing during drawing.\n     * Default is `false`.\n     * @type {boolean}\n     * @private\n     */\n    this.stopClick_ = !!options.stopClick;\n\n    /**\n     * The number of points that must be drawn before a polygon ring or line\n     * string can be finished.  The default is 3 for polygon rings and 2 for\n     * line strings.\n     * @type {number}\n     * @private\n     */\n    this.minPoints_ = options.minPoints\n      ? options.minPoints\n      : this.mode_ === 'Polygon'\n        ? 3\n        : 2;\n\n    /**\n     * The number of points that can be drawn before a polygon ring or line string\n     * is finished. The default is no restriction.\n     * @type {number}\n     * @private\n     */\n    this.maxPoints_ =\n      this.mode_ === 'Circle'\n        ? 2\n        : options.maxPoints\n          ? options.maxPoints\n          : Infinity;\n\n    /**\n     * A function to decide if a potential finish coordinate is permissible\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.finishCondition_ = options.finishCondition\n      ? options.finishCondition\n      : TRUE;\n\n    /**\n     * @private\n     * @type {import(\"../geom/Geometry.js\").GeometryLayout}\n     */\n    this.geometryLayout_ = options.geometryLayout\n      ? options.geometryLayout\n      : 'XY';\n\n    let geometryFunction = options.geometryFunction;\n    if (!geometryFunction) {\n      const mode = this.mode_;\n      if (mode === 'Circle') {\n        /**\n         * @param {!LineCoordType} coordinates The coordinates.\n         * @param {import(\"../geom/SimpleGeometry.js\").default|undefined} geometry Optional geometry.\n         * @param {import(\"../proj/Projection.js\").default} projection The view projection.\n         * @return {import(\"../geom/SimpleGeometry.js\").default} A geometry.\n         */\n        geometryFunction = function (coordinates, geometry, projection) {\n          const circle = geometry\n            ? /** @type {Circle} */ (geometry)\n            : new Circle([NaN, NaN]);\n          const center = fromUserCoordinate(coordinates[0], projection);\n          const squaredLength = squaredCoordinateDistance(\n            center,\n            fromUserCoordinate(coordinates[coordinates.length - 1], projection),\n          );\n          circle.setCenterAndRadius(\n            center,\n            Math.sqrt(squaredLength),\n            this.geometryLayout_,\n          );\n          const userProjection = getUserProjection();\n          if (userProjection) {\n            circle.transform(projection, userProjection);\n          }\n          return circle;\n        };\n      } else {\n        let Constructor;\n        if (mode === 'Point') {\n          Constructor = Point;\n        } else if (mode === 'LineString') {\n          Constructor = LineString;\n        } else if (mode === 'Polygon') {\n          Constructor = Polygon;\n        }\n        /**\n         * @param {!LineCoordType} coordinates The coordinates.\n         * @param {import(\"../geom/SimpleGeometry.js\").default|undefined} geometry Optional geometry.\n         * @param {import(\"../proj/Projection.js\").default} projection The view projection.\n         * @return {import(\"../geom/SimpleGeometry.js\").default} A geometry.\n         */\n        geometryFunction = function (coordinates, geometry, projection) {\n          if (geometry) {\n            if (mode === 'Polygon') {\n              if (coordinates[0].length) {\n                // Add a closing coordinate to match the first\n                geometry.setCoordinates(\n                  [coordinates[0].concat([coordinates[0][0]])],\n                  this.geometryLayout_,\n                );\n              } else {\n                geometry.setCoordinates([], this.geometryLayout_);\n              }\n            } else {\n              geometry.setCoordinates(coordinates, this.geometryLayout_);\n            }\n          } else {\n            geometry = new Constructor(coordinates, this.geometryLayout_);\n          }\n          return geometry;\n        };\n      }\n    }\n\n    /**\n     * @type {GeometryFunction}\n     * @private\n     */\n    this.geometryFunction_ = geometryFunction;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.dragVertexDelay_ =\n      options.dragVertexDelay !== undefined ? options.dragVertexDelay : 500;\n\n    /**\n     * Finish coordinate for the feature (first point for polygons, last point for\n     * linestrings).\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    this.finishCoordinate_ = null;\n\n    /**\n     * Sketch feature.\n     * @type {Feature<import('../geom/SimpleGeometry.js').default>}\n     * @private\n     */\n    this.sketchFeature_ = null;\n\n    /**\n     * Sketch point.\n     * @type {Feature<Point>}\n     * @private\n     */\n    this.sketchPoint_ = null;\n\n    /**\n     * Sketch coordinates. Used when drawing a line or polygon.\n     * @type {SketchCoordType}\n     * @private\n     */\n    this.sketchCoords_ = null;\n\n    /**\n     * Sketch line. Used when drawing polygon.\n     * @type {Feature<LineString>}\n     * @private\n     */\n    this.sketchLine_ = null;\n\n    /**\n     * Sketch line coordinates. Used when drawing a polygon or circle.\n     * @type {LineCoordType}\n     * @private\n     */\n    this.sketchLineCoords_ = null;\n\n    /**\n     * Squared tolerance for handling up events.  If the squared distance\n     * between a down and up event is greater than this tolerance, up events\n     * will not be handled.\n     * @type {number}\n     * @private\n     */\n    this.squaredClickTolerance_ = options.clickTolerance\n      ? options.clickTolerance * options.clickTolerance\n      : 36;\n\n    /**\n     * Draw overlay where our sketch features are drawn.\n     * @type {VectorLayer}\n     * @private\n     */\n    this.overlay_ = new VectorLayer({\n      source: new VectorSource({\n        useSpatialIndex: false,\n        wrapX: options.wrapX ? options.wrapX : false,\n      }),\n      style: options.style ? options.style : getDefaultStyleFunction(),\n      updateWhileInteracting: true,\n    });\n\n    /**\n     * Name of the geometry attribute for newly created features.\n     * @type {string|undefined}\n     * @private\n     */\n    this.geometryName_ = options.geometryName;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.condition_ = options.condition ? options.condition : noModifierKeys;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.freehandCondition_;\n    if (options.freehand) {\n      this.freehandCondition_ = always;\n    } else {\n      this.freehandCondition_ = options.freehandCondition\n        ? options.freehandCondition\n        : shiftKeyOnly;\n    }\n\n    /**\n     * @type {import(\"../events/condition.js\").Condition}\n     * @private\n     */\n    this.traceCondition_;\n    this.setTrace(options.trace || false);\n\n    /**\n     * @type {TraceState}\n     * @private\n     */\n    this.traceState_ = {active: false};\n\n    /**\n     * @type {VectorSource|null}\n     * @private\n     */\n    this.traceSource_ = options.traceSource || options.source || null;\n\n    this.addChangeListener(InteractionProperty.ACTIVE, this.updateState_);\n  }\n\n  /**\n   * Toggle tracing mode or set a tracing condition.\n   *\n   * @param {boolean|import(\"../events/condition.js\").Condition} trace A boolean to toggle tracing mode or an event\n   *     condition that will be checked when a feature is clicked to determine if tracing should be active.\n   */\n  setTrace(trace) {\n    let condition;\n    if (!trace) {\n      condition = never;\n    } else if (trace === true) {\n      condition = always;\n    } else {\n      condition = trace;\n    }\n    this.traceCondition_ = condition;\n  }\n\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../Map.js\").default} map Map.\n   */\n  setMap(map) {\n    super.setMap(map);\n    this.updateState_();\n  }\n\n  /**\n   * Get the overlay layer that this interaction renders sketch features to.\n   * @return {VectorLayer} Overlay layer.\n   * @api\n   */\n  getOverlay() {\n    return this.overlay_;\n  }\n\n  /**\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may actually draw or finish the drawing.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   * @api\n   */\n  handleEvent(event) {\n    if (event.originalEvent.type === EventType.CONTEXTMENU) {\n      // Avoid context menu for long taps when drawing on mobile\n      event.originalEvent.preventDefault();\n    }\n    this.freehand_ = this.mode_ !== 'Point' && this.freehandCondition_(event);\n    let move = event.type === MapBrowserEventType.POINTERMOVE;\n    let pass = true;\n    if (\n      !this.freehand_ &&\n      this.lastDragTime_ &&\n      event.type === MapBrowserEventType.POINTERDRAG\n    ) {\n      const now = Date.now();\n      if (now - this.lastDragTime_ >= this.dragVertexDelay_) {\n        this.downPx_ = event.pixel;\n        this.shouldHandle_ = !this.freehand_;\n        move = true;\n      } else {\n        this.lastDragTime_ = undefined;\n      }\n      if (this.shouldHandle_ && this.downTimeout_ !== undefined) {\n        clearTimeout(this.downTimeout_);\n        this.downTimeout_ = undefined;\n      }\n    }\n    if (\n      this.freehand_ &&\n      event.type === MapBrowserEventType.POINTERDRAG &&\n      this.sketchFeature_ !== null\n    ) {\n      this.addToDrawing_(event.coordinate);\n      pass = false;\n    } else if (\n      this.freehand_ &&\n      event.type === MapBrowserEventType.POINTERDOWN\n    ) {\n      pass = false;\n    } else if (move && this.getPointerCount() < 2) {\n      pass = event.type === MapBrowserEventType.POINTERMOVE;\n      if (pass && this.freehand_) {\n        this.handlePointerMove_(event);\n        if (this.shouldHandle_) {\n          // Avoid page scrolling when freehand drawing on mobile\n          event.originalEvent.preventDefault();\n        }\n      } else if (\n        event.originalEvent.pointerType === 'mouse' ||\n        (event.type === MapBrowserEventType.POINTERDRAG &&\n          this.downTimeout_ === undefined)\n      ) {\n        this.handlePointerMove_(event);\n      }\n    } else if (event.type === MapBrowserEventType.DBLCLICK) {\n      pass = false;\n    }\n\n    return super.handleEvent(event) && pass;\n  }\n\n  /**\n   * Handle pointer down events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleDownEvent(event) {\n    this.shouldHandle_ = !this.freehand_;\n\n    if (this.freehand_) {\n      this.downPx_ = event.pixel;\n      if (!this.finishCoordinate_) {\n        this.startDrawing_(event.coordinate);\n      }\n      return true;\n    }\n\n    if (!this.condition_(event)) {\n      this.lastDragTime_ = undefined;\n      return false;\n    }\n\n    this.lastDragTime_ = Date.now();\n    this.downTimeout_ = setTimeout(() => {\n      this.handlePointerMove_(\n        new MapBrowserEvent(\n          MapBrowserEventType.POINTERMOVE,\n          event.map,\n          event.originalEvent,\n          false,\n          event.frameState,\n        ),\n      );\n    }, this.dragVertexDelay_);\n    this.downPx_ = event.pixel;\n    return true;\n  }\n\n  /**\n   * @private\n   */\n  deactivateTrace_() {\n    this.traceState_ = {active: false};\n  }\n\n  /**\n   * Activate or deactivate trace state based on a browser event.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @private\n   */\n  toggleTraceState_(event) {\n    if (!this.traceSource_ || !this.traceCondition_(event)) {\n      return;\n    }\n\n    if (this.traceState_.active) {\n      this.deactivateTrace_();\n      return;\n    }\n\n    const map = this.getMap();\n    const lowerLeft = map.getCoordinateFromPixel([\n      event.pixel[0] - this.snapTolerance_,\n      event.pixel[1] + this.snapTolerance_,\n    ]);\n    const upperRight = map.getCoordinateFromPixel([\n      event.pixel[0] + this.snapTolerance_,\n      event.pixel[1] - this.snapTolerance_,\n    ]);\n    const extent = boundingExtent([lowerLeft, upperRight]);\n    const features = this.traceSource_.getFeaturesInExtent(extent);\n    if (features.length === 0) {\n      return;\n    }\n\n    const targets = getTraceTargets(event.coordinate, features);\n    if (targets.length) {\n      this.traceState_ = {\n        active: true,\n        startPx: event.pixel.slice(),\n        targets: targets,\n        targetIndex: -1,\n      };\n    }\n  }\n\n  /**\n   * @param {TraceTarget} target The trace target.\n   * @param {number} endIndex The new end index of the trace.\n   * @private\n   */\n  addOrRemoveTracedCoordinates_(target, endIndex) {\n    // three cases to handle:\n    //  1. traced in the same direction and points need adding\n    //  2. traced in the same direction and points need removing\n    //  3. traced in a new direction\n    const previouslyForward = target.startIndex <= target.endIndex;\n    const currentlyForward = target.startIndex <= endIndex;\n    if (previouslyForward === currentlyForward) {\n      // same direction\n      if (\n        (previouslyForward && endIndex > target.endIndex) ||\n        (!previouslyForward && endIndex < target.endIndex)\n      ) {\n        // case 1 - add new points\n        this.addTracedCoordinates_(target, target.endIndex, endIndex);\n      } else if (\n        (previouslyForward && endIndex < target.endIndex) ||\n        (!previouslyForward && endIndex > target.endIndex)\n      ) {\n        // case 2 - remove old points\n        this.removeTracedCoordinates_(endIndex, target.endIndex);\n      }\n    } else {\n      // case 3 - remove old points, add new points\n      this.removeTracedCoordinates_(target.startIndex, target.endIndex);\n      this.addTracedCoordinates_(target, target.startIndex, endIndex);\n    }\n  }\n\n  /**\n   * @param {number} fromIndex The start index.\n   * @param {number} toIndex The end index.\n   * @private\n   */\n  removeTracedCoordinates_(fromIndex, toIndex) {\n    if (fromIndex === toIndex) {\n      return;\n    }\n\n    let remove = 0;\n    if (fromIndex < toIndex) {\n      const start = Math.ceil(fromIndex);\n      let end = Math.floor(toIndex);\n      if (end === toIndex) {\n        end -= 1;\n      }\n      remove = end - start + 1;\n    } else {\n      const start = Math.floor(fromIndex);\n      let end = Math.ceil(toIndex);\n      if (end === toIndex) {\n        end += 1;\n      }\n      remove = start - end + 1;\n    }\n\n    if (remove > 0) {\n      this.removeLastPoints_(remove);\n    }\n  }\n\n  /**\n   * @param {TraceTarget} target The trace target.\n   * @param {number} fromIndex The start index.\n   * @param {number} toIndex The end index.\n   * @private\n   */\n  addTracedCoordinates_(target, fromIndex, toIndex) {\n    if (fromIndex === toIndex) {\n      return;\n    }\n\n    const coordinates = [];\n    if (fromIndex < toIndex) {\n      // forward trace\n      const start = Math.ceil(fromIndex);\n      let end = Math.floor(toIndex);\n      if (end === toIndex) {\n        // if end is snapped to a vertex, it will be added later\n        end -= 1;\n      }\n      for (let i = start; i <= end; ++i) {\n        coordinates.push(getCoordinate(target.coordinates, i));\n      }\n    } else {\n      // reverse trace\n      const start = Math.floor(fromIndex);\n      let end = Math.ceil(toIndex);\n      if (end === toIndex) {\n        end += 1;\n      }\n      for (let i = start; i >= end; --i) {\n        coordinates.push(getCoordinate(target.coordinates, i));\n      }\n    }\n    if (coordinates.length) {\n      this.appendCoordinates(coordinates);\n    }\n  }\n\n  /**\n   * Update the trace.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @private\n   */\n  updateTrace_(event) {\n    const traceState = this.traceState_;\n    if (!traceState.active) {\n      return;\n    }\n\n    if (traceState.targetIndex === -1) {\n      // check if we are ready to pick a target\n      if (distance(traceState.startPx, event.pixel) < this.snapTolerance_) {\n        return;\n      }\n    }\n\n    const updatedTraceTarget = getTraceTargetUpdate(\n      event.coordinate,\n      traceState,\n      this.getMap(),\n      this.snapTolerance_,\n    );\n\n    if (traceState.targetIndex !== updatedTraceTarget.index) {\n      // target changed\n      if (traceState.targetIndex !== -1) {\n        // remove points added during previous trace\n        const oldTarget = traceState.targets[traceState.targetIndex];\n        this.removeTracedCoordinates_(oldTarget.startIndex, oldTarget.endIndex);\n      }\n      // add points for the new target\n      const newTarget = traceState.targets[updatedTraceTarget.index];\n      this.addTracedCoordinates_(\n        newTarget,\n        newTarget.startIndex,\n        updatedTraceTarget.endIndex,\n      );\n    } else {\n      // target stayed the same\n      const target = traceState.targets[traceState.targetIndex];\n      this.addOrRemoveTracedCoordinates_(target, updatedTraceTarget.endIndex);\n    }\n\n    // modify the state with updated info\n    traceState.targetIndex = updatedTraceTarget.index;\n    const target = traceState.targets[traceState.targetIndex];\n    target.endIndex = updatedTraceTarget.endIndex;\n\n    // update event coordinate and pixel to match end point of final segment\n    const coordinate = interpolateCoordinate(\n      target.coordinates,\n      target.endIndex,\n    );\n    const pixel = this.getMap().getPixelFromCoordinate(coordinate);\n    event.coordinate = coordinate;\n    event.pixel = [Math.round(pixel[0]), Math.round(pixel[1])];\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleUpEvent(event) {\n    let pass = true;\n\n    if (this.getPointerCount() === 0) {\n      if (this.downTimeout_) {\n        clearTimeout(this.downTimeout_);\n        this.downTimeout_ = undefined;\n      }\n\n      this.handlePointerMove_(event);\n      const tracing = this.traceState_.active;\n      this.toggleTraceState_(event);\n\n      if (this.shouldHandle_) {\n        const startingToDraw = !this.finishCoordinate_;\n        if (startingToDraw) {\n          this.startDrawing_(event.coordinate);\n        }\n        if (!startingToDraw && this.freehand_) {\n          this.finishDrawing();\n        } else if (\n          !this.freehand_ &&\n          (!startingToDraw || this.mode_ === 'Point')\n        ) {\n          if (this.atFinish_(event.pixel, tracing)) {\n            if (this.finishCondition_(event)) {\n              this.finishDrawing();\n            }\n          } else {\n            this.addToDrawing_(event.coordinate);\n          }\n        }\n        pass = false;\n      } else if (this.freehand_) {\n        this.abortDrawing();\n      }\n    }\n\n    if (!pass && this.stopClick_) {\n      event.preventDefault();\n    }\n    return pass;\n  }\n\n  /**\n   * Handle move events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event A move event.\n   * @private\n   */\n  handlePointerMove_(event) {\n    this.pointerType_ = event.originalEvent.pointerType;\n    if (\n      this.downPx_ &&\n      ((!this.freehand_ && this.shouldHandle_) ||\n        (this.freehand_ && !this.shouldHandle_))\n    ) {\n      const downPx = this.downPx_;\n      const clickPx = event.pixel;\n      const dx = downPx[0] - clickPx[0];\n      const dy = downPx[1] - clickPx[1];\n      const squaredDistance = dx * dx + dy * dy;\n      this.shouldHandle_ = this.freehand_\n        ? squaredDistance > this.squaredClickTolerance_\n        : squaredDistance <= this.squaredClickTolerance_;\n      if (!this.shouldHandle_) {\n        return;\n      }\n    }\n\n    if (!this.finishCoordinate_) {\n      this.createOrUpdateSketchPoint_(event.coordinate.slice());\n      return;\n    }\n\n    this.updateTrace_(event);\n    this.modifyDrawing_(event.coordinate);\n  }\n\n  /**\n   * Determine if an event is within the snapping tolerance of the start coord.\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @param {boolean} [tracing] Drawing in trace mode (only stop if at the starting point).\n   * @return {boolean} The event is within the snapping tolerance of the start.\n   * @private\n   */\n  atFinish_(pixel, tracing) {\n    let at = false;\n    if (this.sketchFeature_) {\n      let potentiallyDone = false;\n      let potentiallyFinishCoordinates = [this.finishCoordinate_];\n      const mode = this.mode_;\n      if (mode === 'Point') {\n        at = true;\n      } else if (mode === 'Circle') {\n        at = this.sketchCoords_.length === 2;\n      } else if (mode === 'LineString') {\n        potentiallyDone =\n          !tracing && this.sketchCoords_.length > this.minPoints_;\n      } else if (mode === 'Polygon') {\n        const sketchCoords = /** @type {PolyCoordType} */ (this.sketchCoords_);\n        potentiallyDone = sketchCoords[0].length > this.minPoints_;\n        potentiallyFinishCoordinates = [\n          sketchCoords[0][0],\n          sketchCoords[0][sketchCoords[0].length - 2],\n        ];\n        if (tracing) {\n          potentiallyFinishCoordinates = [sketchCoords[0][0]];\n        } else {\n          potentiallyFinishCoordinates = [\n            sketchCoords[0][0],\n            sketchCoords[0][sketchCoords[0].length - 2],\n          ];\n        }\n      }\n      if (potentiallyDone) {\n        const map = this.getMap();\n        for (let i = 0, ii = potentiallyFinishCoordinates.length; i < ii; i++) {\n          const finishCoordinate = potentiallyFinishCoordinates[i];\n          const finishPixel = map.getPixelFromCoordinate(finishCoordinate);\n          const dx = pixel[0] - finishPixel[0];\n          const dy = pixel[1] - finishPixel[1];\n          const snapTolerance = this.freehand_ ? 1 : this.snapTolerance_;\n          at = Math.sqrt(dx * dx + dy * dy) <= snapTolerance;\n          if (at) {\n            this.finishCoordinate_ = finishCoordinate;\n            break;\n          }\n        }\n      }\n    }\n    return at;\n  }\n\n  /**\n   * @param {import(\"../coordinate\").Coordinate} coordinates Coordinate.\n   * @private\n   */\n  createOrUpdateSketchPoint_(coordinates) {\n    if (!this.sketchPoint_) {\n      this.sketchPoint_ = new Feature(new Point(coordinates));\n      this.updateSketchFeatures_();\n    } else {\n      const sketchPointGeom = this.sketchPoint_.getGeometry();\n      sketchPointGeom.setCoordinates(coordinates);\n    }\n  }\n\n  /**\n   * @param {import(\"../geom/Polygon.js\").default} geometry Polygon geometry.\n   * @private\n   */\n  createOrUpdateCustomSketchLine_(geometry) {\n    if (!this.sketchLine_) {\n      this.sketchLine_ = new Feature();\n    }\n    const ring = geometry.getLinearRing(0);\n    let sketchLineGeom = this.sketchLine_.getGeometry();\n    if (!sketchLineGeom) {\n      sketchLineGeom = new LineString(\n        ring.getFlatCoordinates(),\n        ring.getLayout(),\n      );\n      this.sketchLine_.setGeometry(sketchLineGeom);\n    } else {\n      sketchLineGeom.setFlatCoordinates(\n        ring.getLayout(),\n        ring.getFlatCoordinates(),\n      );\n      sketchLineGeom.changed();\n    }\n  }\n\n  /**\n   * Start the drawing.\n   * @param {import(\"../coordinate.js\").Coordinate} start Start coordinate.\n   * @private\n   */\n  startDrawing_(start) {\n    const projection = this.getMap().getView().getProjection();\n    const stride = getStrideForLayout(this.geometryLayout_);\n    while (start.length < stride) {\n      start.push(0);\n    }\n    this.finishCoordinate_ = start;\n    if (this.mode_ === 'Point') {\n      this.sketchCoords_ = start.slice();\n    } else if (this.mode_ === 'Polygon') {\n      this.sketchCoords_ = [[start.slice(), start.slice()]];\n      this.sketchLineCoords_ = this.sketchCoords_[0];\n    } else {\n      this.sketchCoords_ = [start.slice(), start.slice()];\n    }\n    if (this.sketchLineCoords_) {\n      this.sketchLine_ = new Feature(new LineString(this.sketchLineCoords_));\n    }\n    const geometry = this.geometryFunction_(\n      this.sketchCoords_,\n      undefined,\n      projection,\n    );\n    this.sketchFeature_ = new Feature();\n    if (this.geometryName_) {\n      this.sketchFeature_.setGeometryName(this.geometryName_);\n    }\n    this.sketchFeature_.setGeometry(geometry);\n    this.updateSketchFeatures_();\n    this.dispatchEvent(\n      new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_),\n    );\n  }\n\n  /**\n   * Modify the drawing.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @private\n   */\n  modifyDrawing_(coordinate) {\n    const map = this.getMap();\n    const geometry = this.sketchFeature_.getGeometry();\n    const projection = map.getView().getProjection();\n    const stride = getStrideForLayout(this.geometryLayout_);\n    let coordinates, last;\n    while (coordinate.length < stride) {\n      coordinate.push(0);\n    }\n    if (this.mode_ === 'Point') {\n      last = this.sketchCoords_;\n    } else if (this.mode_ === 'Polygon') {\n      coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];\n      last = coordinates[coordinates.length - 1];\n      if (this.atFinish_(map.getPixelFromCoordinate(coordinate))) {\n        // snap to finish\n        coordinate = this.finishCoordinate_.slice();\n      }\n    } else {\n      coordinates = this.sketchCoords_;\n      last = coordinates[coordinates.length - 1];\n    }\n    last[0] = coordinate[0];\n    last[1] = coordinate[1];\n    this.geometryFunction_(\n      /** @type {!LineCoordType} */ (this.sketchCoords_),\n      geometry,\n      projection,\n    );\n    if (this.sketchPoint_) {\n      const sketchPointGeom = this.sketchPoint_.getGeometry();\n      sketchPointGeom.setCoordinates(coordinate);\n    }\n    if (geometry.getType() === 'Polygon' && this.mode_ !== 'Polygon') {\n      this.createOrUpdateCustomSketchLine_(/** @type {Polygon} */ (geometry));\n    } else if (this.sketchLineCoords_) {\n      const sketchLineGeom = this.sketchLine_.getGeometry();\n      sketchLineGeom.setCoordinates(this.sketchLineCoords_);\n    }\n    this.updateSketchFeatures_();\n  }\n\n  /**\n   * Add a new coordinate to the drawing.\n   * @param {!PointCoordType} coordinate Coordinate\n   * @return {Feature<import(\"../geom/SimpleGeometry.js\").default>} The sketch feature.\n   * @private\n   */\n  addToDrawing_(coordinate) {\n    const geometry = this.sketchFeature_.getGeometry();\n    const projection = this.getMap().getView().getProjection();\n    let done;\n    let coordinates;\n    const mode = this.mode_;\n    if (mode === 'LineString' || mode === 'Circle') {\n      this.finishCoordinate_ = coordinate.slice();\n      coordinates = /** @type {LineCoordType} */ (this.sketchCoords_);\n      if (coordinates.length >= this.maxPoints_) {\n        if (this.freehand_) {\n          coordinates.pop();\n        } else {\n          done = true;\n        }\n      }\n      coordinates.push(coordinate.slice());\n      this.geometryFunction_(coordinates, geometry, projection);\n    } else if (mode === 'Polygon') {\n      coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];\n      if (coordinates.length >= this.maxPoints_) {\n        if (this.freehand_) {\n          coordinates.pop();\n        } else {\n          done = true;\n        }\n      }\n      coordinates.push(coordinate.slice());\n      if (done) {\n        this.finishCoordinate_ = coordinates[0];\n      }\n      this.geometryFunction_(this.sketchCoords_, geometry, projection);\n    }\n    this.createOrUpdateSketchPoint_(coordinate.slice());\n    this.updateSketchFeatures_();\n    if (done) {\n      return this.finishDrawing();\n    }\n    return this.sketchFeature_;\n  }\n\n  /**\n   * @param {number} n The number of points to remove.\n   */\n  removeLastPoints_(n) {\n    if (!this.sketchFeature_) {\n      return;\n    }\n    const geometry = this.sketchFeature_.getGeometry();\n    const projection = this.getMap().getView().getProjection();\n    const mode = this.mode_;\n    for (let i = 0; i < n; ++i) {\n      let coordinates;\n      if (mode === 'LineString' || mode === 'Circle') {\n        coordinates = /** @type {LineCoordType} */ (this.sketchCoords_);\n        coordinates.splice(-2, 1);\n        if (coordinates.length >= 2) {\n          this.finishCoordinate_ = coordinates[coordinates.length - 2].slice();\n          const finishCoordinate = this.finishCoordinate_.slice();\n          coordinates[coordinates.length - 1] = finishCoordinate;\n          this.createOrUpdateSketchPoint_(finishCoordinate);\n        }\n        this.geometryFunction_(coordinates, geometry, projection);\n        if (geometry.getType() === 'Polygon' && this.sketchLine_) {\n          this.createOrUpdateCustomSketchLine_(\n            /** @type {Polygon} */ (geometry),\n          );\n        }\n      } else if (mode === 'Polygon') {\n        coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];\n        coordinates.splice(-2, 1);\n        const sketchLineGeom = this.sketchLine_.getGeometry();\n        if (coordinates.length >= 2) {\n          const finishCoordinate = coordinates[coordinates.length - 2].slice();\n          coordinates[coordinates.length - 1] = finishCoordinate;\n          this.createOrUpdateSketchPoint_(finishCoordinate);\n        }\n        sketchLineGeom.setCoordinates(coordinates);\n        this.geometryFunction_(this.sketchCoords_, geometry, projection);\n      }\n\n      if (coordinates.length === 1) {\n        this.abortDrawing();\n        break;\n      }\n    }\n\n    this.updateSketchFeatures_();\n  }\n\n  /**\n   * Remove last point of the feature currently being drawn. Does not do anything when\n   * drawing POINT or MULTI_POINT geometries.\n   * @api\n   */\n  removeLastPoint() {\n    this.removeLastPoints_(1);\n  }\n\n  /**\n   * Stop drawing and add the sketch feature to the target layer.\n   * The {@link module:ol/interaction/Draw~DrawEventType.DRAWEND} event is\n   * dispatched before inserting the feature.\n   * @return {Feature<import(\"../geom/SimpleGeometry.js\").default>|null} The drawn feature.\n   * @api\n   */\n  finishDrawing() {\n    const sketchFeature = this.abortDrawing_();\n    if (!sketchFeature) {\n      return null;\n    }\n    let coordinates = this.sketchCoords_;\n    const geometry = sketchFeature.getGeometry();\n    const projection = this.getMap().getView().getProjection();\n    if (this.mode_ === 'LineString') {\n      // remove the redundant last point\n      coordinates.pop();\n      this.geometryFunction_(coordinates, geometry, projection);\n    } else if (this.mode_ === 'Polygon') {\n      // remove the redundant last point in ring\n      /** @type {PolyCoordType} */ (coordinates)[0].pop();\n      this.geometryFunction_(coordinates, geometry, projection);\n      coordinates = geometry.getCoordinates();\n    }\n\n    // cast multi-part geometries\n    if (this.type_ === 'MultiPoint') {\n      sketchFeature.setGeometry(\n        new MultiPoint([/** @type {PointCoordType} */ (coordinates)]),\n      );\n    } else if (this.type_ === 'MultiLineString') {\n      sketchFeature.setGeometry(\n        new MultiLineString([/** @type {LineCoordType} */ (coordinates)]),\n      );\n    } else if (this.type_ === 'MultiPolygon') {\n      sketchFeature.setGeometry(\n        new MultiPolygon([/** @type {PolyCoordType} */ (coordinates)]),\n      );\n    }\n\n    // First dispatch event to allow full set up of feature\n    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWEND, sketchFeature));\n\n    // Then insert feature\n    if (this.features_) {\n      this.features_.push(sketchFeature);\n    }\n    if (this.source_) {\n      this.source_.addFeature(sketchFeature);\n    }\n    return sketchFeature;\n  }\n\n  /**\n   * Stop drawing without adding the sketch feature to the target layer.\n   * @return {Feature<import(\"../geom/SimpleGeometry.js\").default>|null} The sketch feature (or null if none).\n   * @private\n   */\n  abortDrawing_() {\n    this.finishCoordinate_ = null;\n    const sketchFeature = this.sketchFeature_;\n    this.sketchFeature_ = null;\n    this.sketchPoint_ = null;\n    this.sketchLine_ = null;\n    this.overlay_.getSource().clear(true);\n    this.deactivateTrace_();\n    return sketchFeature;\n  }\n\n  /**\n   * Stop drawing without adding the sketch feature to the target layer.\n   * @api\n   */\n  abortDrawing() {\n    const sketchFeature = this.abortDrawing_();\n    if (sketchFeature) {\n      this.dispatchEvent(new DrawEvent(DrawEventType.DRAWABORT, sketchFeature));\n    }\n  }\n\n  /**\n   * Append coordinates to the end of the geometry that is currently being drawn.\n   * This can be used when drawing LineStrings or Polygons. Coordinates will\n   * either be appended to the current LineString or the outer ring of the current\n   * Polygon. If no geometry is being drawn, a new one will be created.\n   * @param {!LineCoordType} coordinates Linear coordinates to be appended to\n   * the coordinate array.\n   * @api\n   */\n  appendCoordinates(coordinates) {\n    const mode = this.mode_;\n    const newDrawing = !this.sketchFeature_;\n    if (newDrawing) {\n      this.startDrawing_(coordinates[0]);\n    }\n    /** @type {LineCoordType} */\n    let sketchCoords;\n    if (mode === 'LineString' || mode === 'Circle') {\n      sketchCoords = /** @type {LineCoordType} */ (this.sketchCoords_);\n    } else if (mode === 'Polygon') {\n      sketchCoords =\n        this.sketchCoords_ && this.sketchCoords_.length\n          ? /** @type {PolyCoordType} */ (this.sketchCoords_)[0]\n          : [];\n    } else {\n      return;\n    }\n\n    if (newDrawing) {\n      sketchCoords.shift();\n    }\n\n    // Remove last coordinate from sketch drawing (this coordinate follows cursor position)\n    sketchCoords.pop();\n\n    // Append coordinate list\n    for (let i = 0; i < coordinates.length; i++) {\n      this.addToDrawing_(coordinates[i]);\n    }\n\n    const ending = coordinates[coordinates.length - 1];\n    // Duplicate last coordinate for sketch drawing (cursor position)\n    this.sketchFeature_ = this.addToDrawing_(ending);\n    this.modifyDrawing_(ending);\n  }\n\n  /**\n   * Initiate draw mode by starting from an existing geometry which will\n   * receive new additional points. This only works on features with\n   * `LineString` geometries, where the interaction will extend lines by adding\n   * points to the end of the coordinates array.\n   * This will change the original feature, instead of drawing a copy.\n   *\n   * The function will dispatch a `drawstart` event.\n   *\n   * @param {!Feature<LineString>} feature Feature to be extended.\n   * @api\n   */\n  extend(feature) {\n    const geometry = feature.getGeometry();\n    const lineString = geometry;\n    this.sketchFeature_ = feature;\n    this.sketchCoords_ = lineString.getCoordinates();\n    const last = this.sketchCoords_[this.sketchCoords_.length - 1];\n    this.finishCoordinate_ = last.slice();\n    this.sketchCoords_.push(last.slice());\n    this.sketchPoint_ = new Feature(new Point(last));\n    this.updateSketchFeatures_();\n    this.dispatchEvent(\n      new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_),\n    );\n  }\n\n  /**\n   * Redraw the sketch features.\n   * @private\n   */\n  updateSketchFeatures_() {\n    const sketchFeatures = [];\n    if (this.sketchFeature_) {\n      sketchFeatures.push(this.sketchFeature_);\n    }\n    if (this.sketchLine_) {\n      sketchFeatures.push(this.sketchLine_);\n    }\n    if (this.sketchPoint_) {\n      sketchFeatures.push(this.sketchPoint_);\n    }\n    const overlaySource = this.overlay_.getSource();\n    overlaySource.clear(true);\n    overlaySource.addFeatures(sketchFeatures);\n  }\n\n  /**\n   * @private\n   */\n  updateState_() {\n    const map = this.getMap();\n    const active = this.getActive();\n    if (!map || !active) {\n      this.abortDrawing();\n    }\n    this.overlay_.setMap(active ? map : null);\n  }\n}\n\n/**\n * @return {import(\"../style/Style.js\").StyleFunction} Styles.\n */\nfunction getDefaultStyleFunction() {\n  const styles = createEditingStyle();\n  return function (feature, resolution) {\n    return styles[feature.getGeometry().getType()];\n  };\n}\n\n/**\n * Create a `geometryFunction` for `type: 'Circle'` that will create a regular\n * polygon with a user specified number of sides and start angle instead of a\n * {@link import(\"../geom/Circle.js\").Circle} geometry.\n * @param {number} [sides] Number of sides of the regular polygon.\n *     Default is 32.\n * @param {number} [angle] Angle of the first point in counter-clockwise\n *     radians. 0 means East.\n *     Default is the angle defined by the heading from the center of the\n *     regular polygon to the current pointer position.\n * @return {GeometryFunction} Function that draws a polygon.\n * @api\n */\nexport function createRegularPolygon(sides, angle) {\n  return function (coordinates, geometry, projection) {\n    const center = fromUserCoordinate(\n      /** @type {LineCoordType} */ (coordinates)[0],\n      projection,\n    );\n    const end = fromUserCoordinate(\n      /** @type {LineCoordType} */ (coordinates)[coordinates.length - 1],\n      projection,\n    );\n    const radius = Math.sqrt(squaredCoordinateDistance(center, end));\n    geometry = geometry || fromCircle(new Circle(center), sides);\n\n    let internalAngle = angle;\n    if (!angle && angle !== 0) {\n      const x = end[0] - center[0];\n      const y = end[1] - center[1];\n      internalAngle = Math.atan2(y, x);\n    }\n    makeRegular(\n      /** @type {Polygon} */ (geometry),\n      center,\n      radius,\n      internalAngle,\n    );\n\n    const userProjection = getUserProjection();\n    if (userProjection) {\n      geometry.transform(projection, userProjection);\n    }\n    return geometry;\n  };\n}\n\n/**\n * Create a `geometryFunction` that will create a box-shaped polygon (aligned\n * with the coordinate system axes).  Use this with the draw interaction and\n * `type: 'Circle'` to return a box instead of a circle geometry.\n * @return {GeometryFunction} Function that draws a box-shaped polygon.\n * @api\n */\nexport function createBox() {\n  return function (coordinates, geometry, projection) {\n    const extent = boundingExtent(\n      /** @type {LineCoordType} */ ([\n        coordinates[0],\n        coordinates[coordinates.length - 1],\n      ]).map(function (coordinate) {\n        return fromUserCoordinate(coordinate, projection);\n      }),\n    );\n    const boxCoordinates = [\n      [\n        getBottomLeft(extent),\n        getBottomRight(extent),\n        getTopRight(extent),\n        getTopLeft(extent),\n        getBottomLeft(extent),\n      ],\n    ];\n    if (geometry) {\n      geometry.setCoordinates(boxCoordinates);\n    } else {\n      geometry = new Polygon(boxCoordinates);\n    }\n    const userProjection = getUserProjection();\n    if (userProjection) {\n      geometry.transform(projection, userProjection);\n    }\n    return geometry;\n  };\n}\n\n/**\n * Get the drawing mode.  The mode for multi-part geometries is the same as for\n * their single-part cousins.\n * @param {import(\"../geom/Geometry.js\").Type} type Geometry type.\n * @return {Mode} Drawing mode.\n */\nfunction getMode(type) {\n  switch (type) {\n    case 'Point':\n    case 'MultiPoint':\n      return 'Point';\n    case 'LineString':\n    case 'MultiLineString':\n      return 'LineString';\n    case 'Polygon':\n    case 'MultiPolygon':\n      return 'Polygon';\n    case 'Circle':\n      return 'Circle';\n    default:\n      throw new Error('Invalid type: ' + type);\n  }\n}\n\nexport default Draw;\n","/**\n * @module ol/interaction/Extent\n */\nimport Event from '../events/Event.js';\nimport Feature from '../Feature.js';\nimport MapBrowserEventType from '../MapBrowserEventType.js';\nimport Point from '../geom/Point.js';\nimport PointerInteraction from './Pointer.js';\nimport VectorLayer from '../layer/Vector.js';\nimport VectorSource from '../source/Vector.js';\nimport {always} from '../events/condition.js';\nimport {boundingExtent, getArea} from '../extent.js';\nimport {\n  closestOnSegment,\n  distance as coordinateDistance,\n  squaredDistance as squaredCoordinateDistance,\n  squaredDistanceToSegment,\n} from '../coordinate.js';\nimport {createEditingStyle} from '../style/Style.js';\nimport {fromExtent as polygonFromExtent} from '../geom/Polygon.js';\nimport {toUserExtent} from '../proj.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * Default is {@link module:ol/events/condition.always}.\n * @property {import(\"../extent.js\").Extent} [extent] Initial extent. Defaults to no\n * initial extent.\n * @property {import(\"../style/Style.js\").StyleLike} [boxStyle]\n * Style for the drawn extent box. Defaults to the `Polygon` editing style\n * documented in {@link module:ol/style/Style~Style}\n * @property {number} [pixelTolerance=10] Pixel tolerance for considering the\n * pointer close enough to a segment or vertex for editing.\n * @property {import(\"../style/Style.js\").StyleLike} [pointerStyle]\n * Style for the cursor used to draw the extent. Defaults to the `Point` editing style\n * documented in {@link module:ol/style/Style~Style}\n * @property {boolean} [wrapX=false] Wrap the drawn extent across multiple maps\n * in the X direction? Only affects visuals, not functionality.\n */\n\n/**\n * @enum {string}\n */\nconst ExtentEventType = {\n  /**\n   * Triggered after the extent is changed\n   * @event ExtentEvent#extentchanged\n   * @api\n   */\n  EXTENTCHANGED: 'extentchanged',\n};\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/Extent~Extent} instances are\n * instances of this type.\n */\nexport class ExtentEvent extends Event {\n  /**\n   * @param {import(\"../extent.js\").Extent} extent the new extent\n   */\n  constructor(extent) {\n    super(ExtentEventType.EXTENTCHANGED);\n\n    /**\n     * The current extent.\n     * @type {import(\"../extent.js\").Extent}\n     * @api\n     */\n    this.extent = extent;\n  }\n}\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'extentchanged', ExtentEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'extentchanged', Return>} ExtentOnSignature\n */\n\n/**\n * @classdesc\n * Allows the user to draw a vector box by clicking and dragging on the map.\n * Once drawn, the vector box can be modified by dragging its vertices or edges.\n * This interaction is only supported for mouse devices.\n *\n * @fires ExtentEvent\n * @api\n */\nclass Extent extends PointerInteraction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options || {};\n\n    super(/** @type {import(\"./Pointer.js\").Options} */ (options));\n\n    /***\n     * @type {ExtentOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {ExtentOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {ExtentOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * Condition\n     * @type {import(\"../events/condition.js\").Condition}\n     * @private\n     */\n    this.condition_ = options.condition ? options.condition : always;\n\n    /**\n     * Extent of the drawn box\n     * @type {import(\"../extent.js\").Extent}\n     * @private\n     */\n    this.extent_ = null;\n\n    /**\n     * Handler for pointer move events\n     * @type {function (import(\"../coordinate.js\").Coordinate): import(\"../extent.js\").Extent|null}\n     * @private\n     */\n    this.pointerHandler_ = null;\n\n    /**\n     * Pixel threshold to snap to extent\n     * @type {number}\n     * @private\n     */\n    this.pixelTolerance_ =\n      options.pixelTolerance !== undefined ? options.pixelTolerance : 10;\n\n    /**\n     * Is the pointer snapped to an extent vertex\n     * @type {boolean}\n     * @private\n     */\n    this.snappedToVertex_ = false;\n\n    /**\n     * Feature for displaying the visible extent\n     * @type {Feature}\n     * @private\n     */\n    this.extentFeature_ = null;\n\n    /**\n     * Feature for displaying the visible pointer\n     * @type {Feature<Point>}\n     * @private\n     */\n    this.vertexFeature_ = null;\n\n    if (!options) {\n      options = {};\n    }\n\n    /**\n     * Layer for the extentFeature\n     * @type {VectorLayer}\n     * @private\n     */\n    this.extentOverlay_ = new VectorLayer({\n      source: new VectorSource({\n        useSpatialIndex: false,\n        wrapX: !!options.wrapX,\n      }),\n      style: options.boxStyle\n        ? options.boxStyle\n        : getDefaultExtentStyleFunction(),\n      updateWhileAnimating: true,\n      updateWhileInteracting: true,\n    });\n\n    /**\n     * Layer for the vertexFeature\n     * @type {VectorLayer}\n     * @private\n     */\n    this.vertexOverlay_ = new VectorLayer({\n      source: new VectorSource({\n        useSpatialIndex: false,\n        wrapX: !!options.wrapX,\n      }),\n      style: options.pointerStyle\n        ? options.pointerStyle\n        : getDefaultPointerStyleFunction(),\n      updateWhileAnimating: true,\n      updateWhileInteracting: true,\n    });\n\n    if (options.extent) {\n      this.setExtent(options.extent);\n    }\n  }\n\n  /**\n   * @param {import(\"../pixel.js\").Pixel} pixel cursor location\n   * @param {import(\"../Map.js\").default} map map\n   * @return {import(\"../coordinate.js\").Coordinate|null} snapped vertex on extent\n   * @private\n   */\n  snapToVertex_(pixel, map) {\n    const pixelCoordinate = map.getCoordinateFromPixelInternal(pixel);\n    const sortByDistance = function (a, b) {\n      return (\n        squaredDistanceToSegment(pixelCoordinate, a) -\n        squaredDistanceToSegment(pixelCoordinate, b)\n      );\n    };\n    const extent = this.getExtentInternal();\n    if (extent) {\n      //convert extents to line segments and find the segment closest to pixelCoordinate\n      const segments = getSegments(extent);\n      segments.sort(sortByDistance);\n      const closestSegment = segments[0];\n\n      let vertex = closestOnSegment(pixelCoordinate, closestSegment);\n      const vertexPixel = map.getPixelFromCoordinateInternal(vertex);\n\n      //if the distance is within tolerance, snap to the segment\n      if (coordinateDistance(pixel, vertexPixel) <= this.pixelTolerance_) {\n        //test if we should further snap to a vertex\n        const pixel1 = map.getPixelFromCoordinateInternal(closestSegment[0]);\n        const pixel2 = map.getPixelFromCoordinateInternal(closestSegment[1]);\n        const squaredDist1 = squaredCoordinateDistance(vertexPixel, pixel1);\n        const squaredDist2 = squaredCoordinateDistance(vertexPixel, pixel2);\n        const dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));\n        this.snappedToVertex_ = dist <= this.pixelTolerance_;\n        if (this.snappedToVertex_) {\n          vertex =\n            squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];\n        }\n        return vertex;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent pointer move event\n   * @private\n   */\n  handlePointerMove_(mapBrowserEvent) {\n    const pixel = mapBrowserEvent.pixel;\n    const map = mapBrowserEvent.map;\n\n    let vertex = this.snapToVertex_(pixel, map);\n    if (!vertex) {\n      vertex = map.getCoordinateFromPixelInternal(pixel);\n    }\n    this.createOrUpdatePointerFeature_(vertex);\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent extent\n   * @return {Feature} extent as featrue\n   * @private\n   */\n  createOrUpdateExtentFeature_(extent) {\n    let extentFeature = this.extentFeature_;\n\n    if (!extentFeature) {\n      if (!extent) {\n        extentFeature = new Feature({});\n      } else {\n        extentFeature = new Feature(polygonFromExtent(extent));\n      }\n      this.extentFeature_ = extentFeature;\n      this.extentOverlay_.getSource().addFeature(extentFeature);\n    } else {\n      if (!extent) {\n        extentFeature.setGeometry(undefined);\n      } else {\n        extentFeature.setGeometry(polygonFromExtent(extent));\n      }\n    }\n    return extentFeature;\n  }\n\n  /**\n   * @param {import(\"../coordinate.js\").Coordinate} vertex location of feature\n   * @return {Feature} vertex as feature\n   * @private\n   */\n  createOrUpdatePointerFeature_(vertex) {\n    let vertexFeature = this.vertexFeature_;\n    if (!vertexFeature) {\n      vertexFeature = new Feature(new Point(vertex));\n      this.vertexFeature_ = vertexFeature;\n      this.vertexOverlay_.getSource().addFeature(vertexFeature);\n    } else {\n      const geometry = vertexFeature.getGeometry();\n      geometry.setCoordinates(vertex);\n    }\n    return vertexFeature;\n  }\n\n  /**\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   */\n  handleEvent(mapBrowserEvent) {\n    if (!mapBrowserEvent.originalEvent || !this.condition_(mapBrowserEvent)) {\n      return true;\n    }\n    //display pointer (if not dragging)\n    if (\n      mapBrowserEvent.type == MapBrowserEventType.POINTERMOVE &&\n      !this.handlingDownUpSequence\n    ) {\n      this.handlePointerMove_(mapBrowserEvent);\n    }\n    //call pointer to determine up/down/drag\n    super.handleEvent(mapBrowserEvent);\n    //return false to stop propagation\n    return false;\n  }\n\n  /**\n   * Handle pointer down events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleDownEvent(mapBrowserEvent) {\n    const pixel = mapBrowserEvent.pixel;\n    const map = mapBrowserEvent.map;\n\n    const extent = this.getExtentInternal();\n    let vertex = this.snapToVertex_(pixel, map);\n\n    //find the extent corner opposite the passed corner\n    const getOpposingPoint = function (point) {\n      let x_ = null;\n      let y_ = null;\n      if (point[0] == extent[0]) {\n        x_ = extent[2];\n      } else if (point[0] == extent[2]) {\n        x_ = extent[0];\n      }\n      if (point[1] == extent[1]) {\n        y_ = extent[3];\n      } else if (point[1] == extent[3]) {\n        y_ = extent[1];\n      }\n      if (x_ !== null && y_ !== null) {\n        return [x_, y_];\n      }\n      return null;\n    };\n    if (vertex && extent) {\n      const x =\n        vertex[0] == extent[0] || vertex[0] == extent[2] ? vertex[0] : null;\n      const y =\n        vertex[1] == extent[1] || vertex[1] == extent[3] ? vertex[1] : null;\n\n      //snap to point\n      if (x !== null && y !== null) {\n        this.pointerHandler_ = getPointHandler(getOpposingPoint(vertex));\n        //snap to edge\n      } else if (x !== null) {\n        this.pointerHandler_ = getEdgeHandler(\n          getOpposingPoint([x, extent[1]]),\n          getOpposingPoint([x, extent[3]]),\n        );\n      } else if (y !== null) {\n        this.pointerHandler_ = getEdgeHandler(\n          getOpposingPoint([extent[0], y]),\n          getOpposingPoint([extent[2], y]),\n        );\n      }\n      //no snap - new bbox\n    } else {\n      vertex = map.getCoordinateFromPixelInternal(pixel);\n      this.setExtent([vertex[0], vertex[1], vertex[0], vertex[1]]);\n      this.pointerHandler_ = getPointHandler(vertex);\n    }\n    return true; //event handled; start downup sequence\n  }\n\n  /**\n   * Handle pointer drag events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   */\n  handleDragEvent(mapBrowserEvent) {\n    if (this.pointerHandler_) {\n      const pixelCoordinate = mapBrowserEvent.coordinate;\n      this.setExtent(this.pointerHandler_(pixelCoordinate));\n      this.createOrUpdatePointerFeature_(pixelCoordinate);\n    }\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleUpEvent(mapBrowserEvent) {\n    this.pointerHandler_ = null;\n    //If bbox is zero area, set to null;\n    const extent = this.getExtentInternal();\n    if (!extent || getArea(extent) === 0) {\n      this.setExtent(null);\n    }\n    return false; //Stop handling downup sequence\n  }\n\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../Map.js\").default} map Map.\n   */\n  setMap(map) {\n    this.extentOverlay_.setMap(map);\n    this.vertexOverlay_.setMap(map);\n    super.setMap(map);\n  }\n\n  /**\n   * Returns the current drawn extent in the view projection (or user projection if set)\n   *\n   * @return {import(\"../extent.js\").Extent} Drawn extent in the view projection.\n   * @api\n   */\n  getExtent() {\n    return toUserExtent(\n      this.getExtentInternal(),\n      this.getMap().getView().getProjection(),\n    );\n  }\n\n  /**\n   * Returns the current drawn extent in the view projection\n   *\n   * @return {import(\"../extent.js\").Extent} Drawn extent in the view projection.\n   * @api\n   */\n  getExtentInternal() {\n    return this.extent_;\n  }\n\n  /**\n   * Manually sets the drawn extent, using the view projection.\n   *\n   * @param {import(\"../extent.js\").Extent} extent Extent\n   * @api\n   */\n  setExtent(extent) {\n    //Null extent means no bbox\n    this.extent_ = extent ? extent : null;\n    this.createOrUpdateExtentFeature_(extent);\n    this.dispatchEvent(new ExtentEvent(this.extent_));\n  }\n}\n\n/**\n * Returns the default style for the drawn bbox\n *\n * @return {import(\"../style/Style.js\").StyleFunction} Default Extent style\n */\nfunction getDefaultExtentStyleFunction() {\n  const style = createEditingStyle();\n  return function (feature, resolution) {\n    return style['Polygon'];\n  };\n}\n\n/**\n * Returns the default style for the pointer\n *\n * @return {import(\"../style/Style.js\").StyleFunction} Default pointer style\n */\nfunction getDefaultPointerStyleFunction() {\n  const style = createEditingStyle();\n  return function (feature, resolution) {\n    return style['Point'];\n  };\n}\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} fixedPoint corner that will be unchanged in the new extent\n * @return {function (import(\"../coordinate.js\").Coordinate): import(\"../extent.js\").Extent} event handler\n */\nfunction getPointHandler(fixedPoint) {\n  return function (point) {\n    return boundingExtent([fixedPoint, point]);\n  };\n}\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} fixedP1 first corner that will be unchanged in the new extent\n * @param {import(\"../coordinate.js\").Coordinate} fixedP2 second corner that will be unchanged in the new extent\n * @return {function (import(\"../coordinate.js\").Coordinate): import(\"../extent.js\").Extent|null} event handler\n */\nfunction getEdgeHandler(fixedP1, fixedP2) {\n  if (fixedP1[0] == fixedP2[0]) {\n    return function (point) {\n      return boundingExtent([fixedP1, [point[0], fixedP2[1]]]);\n    };\n  }\n  if (fixedP1[1] == fixedP2[1]) {\n    return function (point) {\n      return boundingExtent([fixedP1, [fixedP2[0], point[1]]]);\n    };\n  }\n  return null;\n}\n\n/**\n * @param {import(\"../extent.js\").Extent} extent extent\n * @return {Array<Array<import(\"../coordinate.js\").Coordinate>>} extent line segments\n */\nfunction getSegments(extent) {\n  return [\n    [\n      [extent[0], extent[1]],\n      [extent[0], extent[3]],\n    ],\n    [\n      [extent[0], extent[3]],\n      [extent[2], extent[3]],\n    ],\n    [\n      [extent[2], extent[3]],\n      [extent[2], extent[1]],\n    ],\n    [\n      [extent[2], extent[1]],\n      [extent[0], extent[1]],\n    ],\n  ];\n}\n\nexport default Extent;\n","/**\n * @module ol/events/SnapEvent\n */\nimport Event from './Event.js';\n\n/**\n * @enum {string}\n */\nexport const SnapEventType = {\n  /**\n   * Triggered upon snapping to vertex or edge\n   * @event SnapEvent#snap\n   * @api\n   */\n  SNAP: 'snap',\n};\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/Snap~Snap} instances are instances of this\n */\nexport class SnapEvent extends Event {\n  /**\n   * @param {SnapEventType} type Type.\n   * @param {Object} options Options.\n   * @param {import(\"../coordinate.js\").Coordinate} options.vertex The snapped vertex.\n   * @param {import(\"../coordinate.js\").Coordinate} options.vertexPixel The pixel of the snapped vertex.\n   * @param {import(\"../Feature.js\").default} options.feature The feature being snapped.\n   * @param {Array<import(\"../coordinate.js\").Coordinate>|null} options.segment Segment, or `null` if snapped to a vertex.\n   */\n  constructor(type, options) {\n    super(type);\n    /**\n     * The Map coordinate of the snapped point.\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @api\n     */\n    this.vertex = options.vertex;\n    /**\n     * The Map pixel of the snapped point.\n     * @type {Array<number>&Array<number>}\n     * @api\n     */\n    this.vertexPixel = options.vertexPixel;\n    /**\n     * The feature closest to the snapped point.\n     * @type {import(\"../Feature.js\").default<import(\"../geom/Geometry.js\").default>}\n     * @api\n     */\n    this.feature = options.feature;\n    /**\n     * The segment closest to the snapped point, if snapped to a segment.\n     * @type {Array<import(\"../coordinate.js\").Coordinate>|null}\n     * @api\n     */\n    this.segment = options.segment;\n  }\n}\n","/**\n * @module ol/interaction/Snap\n */\nimport CollectionEventType from '../CollectionEventType.js';\nimport EventType from '../events/EventType.js';\nimport PointerInteraction from './Pointer.js';\nimport RBush from '../structs/RBush.js';\nimport VectorEventType from '../source/VectorEventType.js';\nimport {FALSE, TRUE} from '../functions.js';\nimport {SnapEvent, SnapEventType} from '../events/SnapEvent.js';\nimport {boundingExtent, buffer, createEmpty} from '../extent.js';\nimport {\n  closestOnCircle,\n  closestOnSegment,\n  squaredDistance,\n} from '../coordinate.js';\nimport {fromCircle} from '../geom/Polygon.js';\nimport {\n  fromUserCoordinate,\n  getUserProjection,\n  toUserCoordinate,\n  toUserExtent,\n} from '../proj.js';\nimport {getUid} from '../util.js';\nimport {listen, unlistenByKey} from '../events.js';\n\n/**\n * @typedef {Object} Result\n * @property {import(\"../coordinate.js\").Coordinate|null} vertex Vertex.\n * @property {import(\"../pixel.js\").Pixel|null} vertexPixel VertexPixel.\n * @property {import(\"../Feature.js\").default|null} feature Feature.\n * @property {Array<import(\"../coordinate.js\").Coordinate>|null} segment Segment, or `null` if snapped to a vertex.\n */\n\n/**\n * @typedef {Object} SegmentData\n * @property {import(\"../Feature.js\").default} feature Feature.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} segment Segment.\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../Collection.js\").default<import(\"../Feature.js\").default>} [features] Snap to these features. Either this option or source should be provided.\n * @property {boolean} [edge=true] Snap to edges.\n * @property {boolean} [vertex=true] Snap to vertices.\n * @property {number} [pixelTolerance=10] Pixel tolerance for considering the pointer close enough to a segment or\n * vertex for snapping.\n * @property {import(\"../source/Vector.js\").default} [source] Snap to features from this source. Either this option or features should be provided\n */\n\n/**\n * @param  {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} evt Event.\n * @return {import(\"../Feature.js\").default|null} Feature.\n */\nfunction getFeatureFromEvent(evt) {\n  if (\n    /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */ (evt).feature\n  ) {\n    return /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */ (evt)\n      .feature;\n  }\n  if (\n    /** @type {import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} */ (\n      evt\n    ).element\n  ) {\n    return /** @type {import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} */ (\n      evt\n    ).element;\n  }\n  return null;\n}\n\nconst tempSegment = [];\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'snap', SnapEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'snap', Return>} SnapOnSignature\n */\n\n/**\n * @classdesc\n * Handles snapping of vector features while modifying or drawing them.  The\n * features can come from a {@link module:ol/source/Vector~VectorSource} or {@link module:ol/Collection~Collection}\n * Any interaction object that allows the user to interact\n * with the features using the mouse can benefit from the snapping, as long\n * as it is added before.\n *\n * The snap interaction modifies map browser event `coordinate` and `pixel`\n * properties to force the snap to occur to any interaction that them.\n *\n * Example:\n *\n *     import Snap from 'ol/interaction/Snap.js';\n *\n *     const snap = new Snap({\n *       source: source\n *     });\n *\n *     map.addInteraction(snap);\n *\n * @fires SnapEvent\n * @api\n */\nclass Snap extends PointerInteraction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const pointerOptions = /** @type {import(\"./Pointer.js\").Options} */ (\n      options\n    );\n\n    if (!pointerOptions.handleDownEvent) {\n      pointerOptions.handleDownEvent = TRUE;\n    }\n\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n\n    super(pointerOptions);\n\n    /***\n     * @type {SnapOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {SnapOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {SnapOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @type {import(\"../source/Vector.js\").default|null}\n     * @private\n     */\n    this.source_ = options.source ? options.source : null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.vertex_ = options.vertex !== undefined ? options.vertex : true;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.edge_ = options.edge !== undefined ? options.edge : true;\n\n    /**\n     * @type {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|null}\n     * @private\n     */\n    this.features_ = options.features ? options.features : null;\n\n    /**\n     * @type {Array<import(\"../events.js\").EventsKey>}\n     * @private\n     */\n    this.featuresListenerKeys_ = [];\n\n    /**\n     * @type {Object<string, import(\"../events.js\").EventsKey>}\n     * @private\n     */\n    this.featureChangeListenerKeys_ = {};\n\n    /**\n     * Extents are preserved so indexed segment can be quickly removed\n     * when its feature geometry changes\n     * @type {Object<string, import(\"../extent.js\").Extent>}\n     * @private\n     */\n    this.indexedFeaturesExtents_ = {};\n\n    /**\n     * If a feature geometry changes while a pointer drag|move event occurs, the\n     * feature doesn't get updated right away.  It will be at the next 'pointerup'\n     * event fired.\n     * @type {!Object<string, import(\"../Feature.js\").default>}\n     * @private\n     */\n    this.pendingFeatures_ = {};\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.pixelTolerance_ =\n      options.pixelTolerance !== undefined ? options.pixelTolerance : 10;\n\n    /**\n     * Segment RTree for each layer\n     * @type {import(\"../structs/RBush.js\").default<SegmentData>}\n     * @private\n     */\n    this.rBush_ = new RBush();\n\n    /**\n     * @const\n     * @private\n     * @type {Object<string, function(Array<Array<import('../coordinate.js').Coordinate>>, import(\"../geom/Geometry.js\").default): void>}\n     */\n    this.GEOMETRY_SEGMENTERS_ = {\n      'Point': this.segmentPointGeometry_.bind(this),\n      'LineString': this.segmentLineStringGeometry_.bind(this),\n      'LinearRing': this.segmentLineStringGeometry_.bind(this),\n      'Polygon': this.segmentPolygonGeometry_.bind(this),\n      'MultiPoint': this.segmentMultiPointGeometry_.bind(this),\n      'MultiLineString': this.segmentMultiLineStringGeometry_.bind(this),\n      'MultiPolygon': this.segmentMultiPolygonGeometry_.bind(this),\n      'GeometryCollection': this.segmentGeometryCollectionGeometry_.bind(this),\n      'Circle': this.segmentCircleGeometry_.bind(this),\n    };\n  }\n\n  /**\n   * Add a feature to the collection of features that we may snap to.\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {boolean} [register] Whether to listen to the feature change or not\n   *     Defaults to `true`.\n   * @api\n   */\n  addFeature(feature, register) {\n    register = register !== undefined ? register : true;\n    const feature_uid = getUid(feature);\n    const geometry = feature.getGeometry();\n    if (geometry) {\n      const segmenter = this.GEOMETRY_SEGMENTERS_[geometry.getType()];\n      if (segmenter) {\n        this.indexedFeaturesExtents_[feature_uid] =\n          geometry.getExtent(createEmpty());\n        const segments =\n          /** @type {Array<Array<import('../coordinate.js').Coordinate>>} */ ([]);\n        segmenter(segments, geometry);\n        if (segments.length === 1) {\n          this.rBush_.insert(boundingExtent(segments[0]), {\n            feature: feature,\n            segment: segments[0],\n          });\n        } else if (segments.length > 1) {\n          const extents = segments.map((s) => boundingExtent(s));\n          const segmentsData = segments.map((segment) => ({\n            feature: feature,\n            segment: segment,\n          }));\n          this.rBush_.load(extents, segmentsData);\n        }\n      }\n    }\n\n    if (register) {\n      this.featureChangeListenerKeys_[feature_uid] = listen(\n        feature,\n        EventType.CHANGE,\n        this.handleFeatureChange_,\n        this,\n      );\n    }\n  }\n\n  /**\n   * @return {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|Array<import(\"../Feature.js\").default>} Features.\n   * @private\n   */\n  getFeatures_() {\n    /** @type {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|Array<import(\"../Feature.js\").default>} */\n    let features;\n    if (this.features_) {\n      features = this.features_;\n    } else if (this.source_) {\n      features = this.source_.getFeatures();\n    }\n    return features;\n  }\n\n  /**\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   * @api\n   */\n  handleEvent(evt) {\n    const result = this.snapTo(evt.pixel, evt.coordinate, evt.map);\n    if (result) {\n      evt.coordinate = result.vertex.slice(0, 2);\n      evt.pixel = result.vertexPixel;\n      this.dispatchEvent(\n        new SnapEvent(SnapEventType.SNAP, {\n          vertex: evt.coordinate,\n          vertexPixel: evt.pixel,\n          feature: result.feature,\n          segment: result.segment,\n        }),\n      );\n    }\n    return super.handleEvent(evt);\n  }\n\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} evt Event.\n   * @private\n   */\n  handleFeatureAdd_(evt) {\n    const feature = getFeatureFromEvent(evt);\n    if (feature) {\n      this.addFeature(feature);\n    }\n  }\n\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} evt Event.\n   * @private\n   */\n  handleFeatureRemove_(evt) {\n    const feature = getFeatureFromEvent(evt);\n    if (feature) {\n      this.removeFeature(feature);\n    }\n  }\n\n  /**\n   * @param {import(\"../events/Event.js\").default} evt Event.\n   * @private\n   */\n  handleFeatureChange_(evt) {\n    const feature = /** @type {import(\"../Feature.js\").default} */ (evt.target);\n    if (this.handlingDownUpSequence) {\n      const uid = getUid(feature);\n      if (!(uid in this.pendingFeatures_)) {\n        this.pendingFeatures_[uid] = feature;\n      }\n    } else {\n      this.updateFeature_(feature);\n    }\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleUpEvent(evt) {\n    const featuresToUpdate = Object.values(this.pendingFeatures_);\n    if (featuresToUpdate.length) {\n      featuresToUpdate.forEach(this.updateFeature_.bind(this));\n      this.pendingFeatures_ = {};\n    }\n    return false;\n  }\n\n  /**\n   * Remove a feature from the collection of features that we may snap to.\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {boolean} [unlisten] Whether to unlisten to the feature change\n   *     or not. Defaults to `true`.\n   * @api\n   */\n  removeFeature(feature, unlisten) {\n    const unregister = unlisten !== undefined ? unlisten : true;\n    const feature_uid = getUid(feature);\n    const extent = this.indexedFeaturesExtents_[feature_uid];\n    if (extent) {\n      const rBush = this.rBush_;\n      const nodesToRemove = [];\n      rBush.forEachInExtent(extent, function (node) {\n        if (feature === node.feature) {\n          nodesToRemove.push(node);\n        }\n      });\n      for (let i = nodesToRemove.length - 1; i >= 0; --i) {\n        rBush.remove(nodesToRemove[i]);\n      }\n    }\n\n    if (unregister) {\n      unlistenByKey(this.featureChangeListenerKeys_[feature_uid]);\n      delete this.featureChangeListenerKeys_[feature_uid];\n    }\n  }\n\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../Map.js\").default} map Map.\n   */\n  setMap(map) {\n    const currentMap = this.getMap();\n    const keys = this.featuresListenerKeys_;\n    const features = /** @type {Array<import(\"../Feature.js\").default>} */ (\n      this.getFeatures_()\n    );\n\n    if (currentMap) {\n      keys.forEach(unlistenByKey);\n      keys.length = 0;\n      this.rBush_.clear();\n      Object.values(this.featureChangeListenerKeys_).forEach(unlistenByKey);\n      this.featureChangeListenerKeys_ = {};\n    }\n    super.setMap(map);\n\n    if (map) {\n      if (this.features_) {\n        keys.push(\n          listen(\n            this.features_,\n            CollectionEventType.ADD,\n            this.handleFeatureAdd_,\n            this,\n          ),\n          listen(\n            this.features_,\n            CollectionEventType.REMOVE,\n            this.handleFeatureRemove_,\n            this,\n          ),\n        );\n      } else if (this.source_) {\n        keys.push(\n          listen(\n            this.source_,\n            VectorEventType.ADDFEATURE,\n            this.handleFeatureAdd_,\n            this,\n          ),\n          listen(\n            this.source_,\n            VectorEventType.REMOVEFEATURE,\n            this.handleFeatureRemove_,\n            this,\n          ),\n        );\n      }\n      features.forEach((feature) => this.addFeature(feature));\n    }\n  }\n\n  /**\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel\n   * @param {import(\"../coordinate.js\").Coordinate} pixelCoordinate Coordinate\n   * @param {import(\"../Map.js\").default} map Map.\n   * @return {Result|null} Snap result\n   */\n  snapTo(pixel, pixelCoordinate, map) {\n    const projection = map.getView().getProjection();\n    const projectedCoordinate = fromUserCoordinate(pixelCoordinate, projection);\n\n    const box = toUserExtent(\n      buffer(\n        boundingExtent([projectedCoordinate]),\n        map.getView().getResolution() * this.pixelTolerance_,\n      ),\n      projection,\n    );\n\n    const segments = this.rBush_.getInExtent(box);\n    const segmentsLength = segments.length;\n    if (segmentsLength === 0) {\n      return null;\n    }\n\n    let closestVertex;\n    let minSquaredDistance = Infinity;\n    let closestFeature;\n    let closestSegment = null;\n\n    const squaredPixelTolerance = this.pixelTolerance_ * this.pixelTolerance_;\n    const getResult = () => {\n      if (closestVertex) {\n        const vertexPixel = map.getPixelFromCoordinate(closestVertex);\n        const squaredPixelDistance = squaredDistance(pixel, vertexPixel);\n        if (squaredPixelDistance <= squaredPixelTolerance) {\n          return {\n            vertex: closestVertex,\n            vertexPixel: [\n              Math.round(vertexPixel[0]),\n              Math.round(vertexPixel[1]),\n            ],\n            feature: closestFeature,\n            segment: closestSegment,\n          };\n        }\n      }\n      return null;\n    };\n\n    if (this.vertex_) {\n      for (let i = 0; i < segmentsLength; ++i) {\n        const segmentData = segments[i];\n        if (segmentData.feature.getGeometry().getType() !== 'Circle') {\n          segmentData.segment.forEach((vertex) => {\n            const tempVertexCoord = fromUserCoordinate(vertex, projection);\n            const delta = squaredDistance(projectedCoordinate, tempVertexCoord);\n            if (delta < minSquaredDistance) {\n              closestVertex = vertex;\n              minSquaredDistance = delta;\n              closestFeature = segmentData.feature;\n            }\n          });\n        }\n      }\n      const result = getResult();\n      if (result) {\n        return result;\n      }\n    }\n\n    if (this.edge_) {\n      for (let i = 0; i < segmentsLength; ++i) {\n        let vertex = null;\n        const segmentData = segments[i];\n        if (segmentData.feature.getGeometry().getType() === 'Circle') {\n          let circleGeometry = segmentData.feature.getGeometry();\n          const userProjection = getUserProjection();\n          if (userProjection) {\n            circleGeometry = circleGeometry\n              .clone()\n              .transform(userProjection, projection);\n          }\n          vertex = closestOnCircle(\n            projectedCoordinate,\n            /** @type {import(\"../geom/Circle.js\").default} */ (circleGeometry),\n          );\n        } else {\n          const [segmentStart, segmentEnd] = segmentData.segment;\n          // points have only one coordinate\n          if (segmentEnd) {\n            tempSegment[0] = fromUserCoordinate(segmentStart, projection);\n            tempSegment[1] = fromUserCoordinate(segmentEnd, projection);\n            vertex = closestOnSegment(projectedCoordinate, tempSegment);\n          }\n        }\n        if (vertex) {\n          const delta = squaredDistance(projectedCoordinate, vertex);\n          if (delta < minSquaredDistance) {\n            closestVertex = toUserCoordinate(vertex, projection);\n            closestSegment =\n              segmentData.feature.getGeometry().getType() === 'Circle'\n                ? null\n                : segmentData.segment;\n            minSquaredDistance = delta;\n            closestFeature = segmentData.feature;\n          }\n        }\n      }\n\n      const result = getResult();\n      if (result) {\n        return result;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @private\n   */\n  updateFeature_(feature) {\n    this.removeFeature(feature, false);\n    this.addFeature(feature, false);\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/Circle.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentCircleGeometry_(segments, geometry) {\n    const projection = this.getMap().getView().getProjection();\n    let circleGeometry = geometry;\n    const userProjection = getUserProjection();\n    if (userProjection) {\n      circleGeometry = circleGeometry\n        .clone()\n        .transform(userProjection, projection);\n    }\n    const polygon = fromCircle(circleGeometry);\n    if (userProjection) {\n      polygon.transform(projection, userProjection);\n    }\n    const coordinates = polygon.getCoordinates()[0];\n    for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      segments.push(coordinates.slice(i, i + 2));\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentGeometryCollectionGeometry_(segments, geometry) {\n    const geometries = geometry.getGeometriesArray();\n    for (let i = 0; i < geometries.length; ++i) {\n      const segmenter = this.GEOMETRY_SEGMENTERS_[geometries[i].getType()];\n      if (segmenter) {\n        segmenter(segments, geometries[i]);\n      }\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/LineString.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentLineStringGeometry_(segments, geometry) {\n    const coordinates = geometry.getCoordinates();\n    for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      segments.push(coordinates.slice(i, i + 2));\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/MultiLineString.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentMultiLineStringGeometry_(segments, geometry) {\n    const lines = geometry.getCoordinates();\n    for (let j = 0, jj = lines.length; j < jj; ++j) {\n      const coordinates = lines[j];\n      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        segments.push(coordinates.slice(i, i + 2));\n      }\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/MultiPoint.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentMultiPointGeometry_(segments, geometry) {\n    geometry.getCoordinates().forEach((point) => {\n      segments.push([point]);\n    });\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentMultiPolygonGeometry_(segments, geometry) {\n    const polygons = geometry.getCoordinates();\n    for (let k = 0, kk = polygons.length; k < kk; ++k) {\n      const rings = polygons[k];\n      for (let j = 0, jj = rings.length; j < jj; ++j) {\n        const coordinates = rings[j];\n        for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n          segments.push(coordinates.slice(i, i + 2));\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/Point.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentPointGeometry_(segments, geometry) {\n    segments.push([geometry.getCoordinates()]);\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/Polygon.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentPolygonGeometry_(segments, geometry) {\n    const rings = geometry.getCoordinates();\n    for (let j = 0, jj = rings.length; j < jj; ++j) {\n      const coordinates = rings[j];\n      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        segments.push(coordinates.slice(i, i + 2));\n      }\n    }\n  }\n}\n\nexport default Snap;\n"],"names":["ol_control_TextButton","constructor","options","className","super","ol_control_Toggle","toggleFn","onToggle","handleClick","self","toggle","call","getActive","this","interaction_","interaction","setActive","active","on","set","title","autoActivate","bar","setSubBar","setDisable","disable","setMap","map","getMap","removeInteraction","subbar_","removeControl","addInteraction","addControl","getSubBar","setTarget","element","classList","add","getDisable","button","querySelector","disabled","b","dispatchEvent","type","key","oldValue","contains","remove","setInteraction","i","getInteraction","ol_extent_intersection","ol_coordinate_dist2d","p1","p2","dx","dy","Math","sqrt","ol_coordinate_equal","ol_coordinate_offsetCoords","coords","offset","mi","mi1","li","li1","ri","ri1","si","si1","Xi1","Yi1","p0","path","N","length","max","isClosed","push","abs","pop","ol_coordinate_findSegment","pt","index","segment","d0","v0","d1","v1","splitX","pts","x","splice","splitY","y","extent","polygon","poly","getType","geom","getCoordinates","forEach","g","c","p","ol_coordinate_sampleAt","d","start","dl","nb","round","prototype","sampleAt","line","result","concat","lines","l","res","mpoly","a","intersection","resolution","ext","getCenter","getRadius","simplify","r","hasout","ring","console","warn","splitAt","tol","k","getFirstCoordinate","getLastCoordinate","c0","ci","d2","split","ol_interaction_Delete","e","getFeatures","clear","delete","selected","bind","_getSources","layers","getLayers","sources","getSource","features","getLength","delFeatures","source","f","removeFeature","ol_interaction_DrawHole","_geometryFn","coordinates","geometry","coord","getPolygon","intersectsCoordinate","lastOKCoord","setCoordinates","geomFn","geometryFunction","_select","style","layers_","indexOf","_features","featureFilter","item","getArray","_startDrawing","_finishDrawing","removeLastPoint","_feature","getGeometry","_polygon","feature","_current","forEachFeatureAtPixel","getPixelFromCoordinate","layer","_polygonIndex","layerFilter","hole","pi","newGeom","appendLinearRing","appendPolygon","setGeometry","ol_interaction_DrawRegular","handleEvent","handleEvent_","squaredClickTolerance_","clickTolerance","maxCircleCoordinates_","maxCircleCoordinates","features_","source_","conditionFn_","condition","squareFn_","squareCondition","centeredFn_","centerCondition","canRotate_","canRotate","geometryName_","geometryName","setSides","sides","defaultStyle","sketch_","overlayLayer_","useSpatialIndex","name","displayInLayerSwitcher","removeLayer","reset","started_","parseInt","sides_","getSides","getGeom_","center_","coord_","dmax","circle","centerPx","center","square_","centered_","coordPx_","min","hasrotation","dm","atan2","startAngle","getExtent","scx","scy","sc","sign","t","applyTransform","g1","g2","dim","drawSketch_","evt","originalEvent","shiftKey","metaKey","ctrlKey","feature_","addFeature","drawPoint_","noclear","_eventTime","Date","downPx_","pixel","start_","dt","_longTouch","setTimeout","handleMoveEvent_","lastEvent","end_","upPx_","coordinate","finishDrawing","startCoordinate","square","centered","setGeometryName","PI","ol_interaction_ModifyFeature","dragging","modifying","handleDownEvent","_deleteCondition","handleUpEvent","handleDragEvent","handleMoveEvent","snapDistance_","pixelTolerance","tolerance_","cursor_","cursor","sources_","Array","filterSplit_","filter","_condition","deleteCondition","_insertVertexCondition","insertVertexCondition","sketchStyle","image","radius","fill","color","stroke","width","wrapX","setFilter","undefined","getClosestFeature","getClosestFeatureToCoordinate","getClosestPoint","di","frameState","viewState","currentFeature","deselected","getNearestCoord","dist","Number","MAX_VALUE","lstring","getLineStrings","lring","getLinearRings","getPolygons","getGeometries","getArcs","s","arcs","coord1","coord2","node","shift","c1","nbpt","closed","end","typeg","error","current","getFeaturesInExtent","_modifiedFeatures","_removePoint","getModifiedFeatures","removePoint","_getModification","geoms","found","setGeometries","setArcCoordinates","getTargetElement","previousCursor_","setCursor","getCurrentFeature","ol_interaction_Offset","handleDownEvent_","handleDragEvent_","handleUpEvent_","_filter","duplicate","_style","getFeatureAtPixel_","typeGeom","test","hit","clone","geomType","hitTolerance","current_","currentStyle_","getStyle","get","setStyle","_modifystart","seg","v2","ol_interaction_Split","snapDistance","tolerance","setSources","white","blue","featureStyle","_sketch_","getSources","getVisible","unshift","fi","gi","link","tosplit","original","linkGeometry","ol_interaction_Transform","selection_","handles_","updateWhileAnimating","updateWhileInteracting","_handleEvent","addFn_","addCondition","setPointRadius","pointRadius","translateFeature","translate","translateBBox","stretch","scale","rotate","keepAspectRatio","modifyCenter","noFlip","selection","enableRotatedTransform","keepRectangle","buffer","setDefaultStyle","oldMap","select","isTouch","getViewport","setVisible","pointStroke","strokedash","lineDash","fill0","pointFill","displacement","points","setDisplacement","getAnchor","bigpt","angle","smallpt","createStyle","img","olstyle","im","getImage","setScale","tx","getText","setOffsetX","bbox_","handle","constraint","option","some","getGeometryRotateToZero_","origGeom","viewRotation","getView","getRotation","rotGeom","_isRectangle","slice","extendExt","ptRadius","_pointRadius","ispt_","getCoordinateFromPixel","iscircle_","addFeatures","removeAt","watchFeatures_","setSelection","_featureListeners","isUpdating_","sel","mode_","opt_","constraint_","coordinate_","pixel_","geoms_","rotatedGeoms_","rotExtent","extent_","rotatedExtent_","Cursors","rotate0","angle_","setCenter","j","pt0","ispt","setCenterAndRadius","deltaX","deltaY","delta","extentCoordinates","opt","downCoordinate","dragCoordinate","downPoint","dragPoint","displacementVector","centerPoint","pointArray","pointA","pointB","pointC","pointD","pointA1","base","_countVector","projectedVector","_projectVectorOnVector","nextIndex","coordsToChange","includes","projectedLeft","projectedRight","_movePoint","default","oldgeom","oldgeoms","displacement_vector","point","opt_fast","ol_interaction_UndoRedo","_layers","_undoStack","_redoStack","_undo","_redo","level","_level","view","zoom","getZoom","action","_reduce","_doShift","_doClear","_block","_record","_defs","define","undoFn","redoFn","undo","redo","setMaxLength","size","setMaxSize","getStack","prop","custom","_mapListener","blockStart","blockEnd","_watchSources","_watchInteractions","_sourceListener","getVectorLayers","init","vectors","_onAddRemove","_interactionListener","getInteractions","_onInteraction","target","fn","_handleDo","oldGeom","newp","newProperties","oldp","oldProperties","unset","hasUndo","hasRedo","setattributestart","Object","assign","properties","rotatestart","translatestart","scalestart","modifystart","replace","m","beforesplit","deletestart","aftersplit","deleteend","ol_style_Style_defaultStyle","defaultEditStyle","edit","fillColor","Circle","layout","setFlatCoordinates","flatCoordinates","applyProperties","closestPointXY","closestPoint","minSquaredDistance","squaredDistance","stride","containsXY","getRadiusSquared_","computeExtent","intersectsExtent","circleExtent","changed","setLayout","ii","setRadius","anchor","getStride","transform","DrawEventType","DRAWSTART","DRAWEND","DRAWABORT","DrawEvent","getTraceTargets","targets","appendGeometryTraceTargets","getSquaredDistance","getCoordinate","count","getCumulativeSquaredDistance","startIndex","endIndex","lowIndex","highIndex","lowWholeIndex","ceil","highWholeIndex","floor","interpolateCoordinate","sd","appendTraceTarget","polys","jj","geometries","sharedUpdateInfo","NaN","getTraceTargetUpdate","traceState","snapTolerance","closestTargetDistance","Infinity","newTargetIndex","newEndIndex","targetIndex","minSegmentDistance","coordinateIndex","rel","getPointSegmentRelationship","along","newTarget","considerBothDirections","newCoordinate","startPx","forwardDistance","reverseDistance","sharedRel","x1","y1","x2","y2","px","py","x0","y0","Draw","pointerOptions","stopDown","once","un","shouldHandle_","downTimeout_","lastDragTime_","pointerType_","freehand_","snapTolerance_","type_","getMode","stopClick_","stopClick","minPoints_","minPoints","maxPoints_","maxPoints","finishCondition_","finishCondition","geometryLayout_","geometryLayout","mode","projection","fromUserCoordinate","squaredLength","userProjection","getUserProjection","Constructor","geometryFunction_","dragVertexDelay_","dragVertexDelay","finishCoordinate_","sketchFeature_","sketchPoint_","sketchCoords_","sketchLine_","sketchLineCoords_","overlay_","getDefaultStyleFunction","condition_","freehandCondition_","freehand","freehandCondition","traceCondition_","setTrace","trace","traceState_","traceSource_","traceSource","addChangeListener","ACTIVE","updateState_","getOverlay","event","CONTEXTMENU","preventDefault","move","POINTERMOVE","pass","POINTERDRAG","now","clearTimeout","addToDrawing_","POINTERDOWN","getPointerCount","handlePointerMove_","pointerType","DBLCLICK","startDrawing_","deactivateTrace_","toggleTraceState_","lowerLeft","upperRight","addOrRemoveTracedCoordinates_","previouslyForward","currentlyForward","addTracedCoordinates_","removeTracedCoordinates_","fromIndex","toIndex","removeLastPoints_","appendCoordinates","updateTrace_","updatedTraceTarget","oldTarget","tracing","startingToDraw","atFinish_","abortDrawing","downPx","clickPx","modifyDrawing_","createOrUpdateSketchPoint_","at","potentiallyDone","potentiallyFinishCoordinates","sketchCoords","finishCoordinate","finishPixel","sketchPointGeom","updateSketchFeatures_","createOrUpdateCustomSketchLine_","getLinearRing","sketchLineGeom","getLayout","getFlatCoordinates","getProjection","last","done","n","sketchFeature","abortDrawing_","newDrawing","ending","extend","lineString","sketchFeatures","overlaySource","styles","createEditingStyle","Error","ExtentEventType","EXTENTCHANGED","ExtentEvent","Extent","pointerHandler_","pixelTolerance_","snappedToVertex_","extentFeature_","vertexFeature_","extentOverlay_","boxStyle","getDefaultExtentStyleFunction","vertexOverlay_","pointerStyle","getDefaultPointerStyleFunction","setExtent","snapToVertex_","pixelCoordinate","getCoordinateFromPixelInternal","sortByDistance","getExtentInternal","segments","getSegments","sort","closestSegment","vertex","vertexPixel","getPixelFromCoordinateInternal","pixel1","pixel2","squaredDist1","squaredDist2","mapBrowserEvent","createOrUpdatePointerFeature_","createOrUpdateExtentFeature_","extentFeature","vertexFeature","handlingDownUpSequence","getOpposingPoint","x_","y_","getPointHandler","getEdgeHandler","toUserExtent","fixedPoint","fixedP1","fixedP2","SnapEventType","SNAP","SnapEvent","Event","getFeatureFromEvent","tempSegment","Snap","Pointer","vertex_","edge_","edge","featuresListenerKeys_","featureChangeListenerKeys_","indexedFeaturesExtents_","pendingFeatures_","rBush_","RBush","GEOMETRY_SEGMENTERS_","segmentPointGeometry_","segmentLineStringGeometry_","segmentPolygonGeometry_","segmentMultiPointGeometry_","segmentMultiLineStringGeometry_","segmentMultiPolygonGeometry_","segmentGeometryCollectionGeometry_","segmentCircleGeometry_","register","feature_uid","segmenter","insert","extents","segmentsData","load","EventType","CHANGE","handleFeatureChange_","getFeatures_","snapTo","handleFeatureAdd_","handleFeatureRemove_","uid","updateFeature_","featuresToUpdate","values","unlisten","unregister","rBush","nodesToRemove","forEachInExtent","currentMap","keys","CollectionEventType","ADD","REMOVE","VectorEventType","ADDFEATURE","REMOVEFEATURE","projectedCoordinate","box","getResolution","getInExtent","segmentsLength","closestVertex","closestFeature","squaredPixelTolerance","getResult","squaredPixelDistance","segmentData","tempVertexCoord","circleGeometry","segmentStart","segmentEnd","toUserCoordinate","getGeometriesArray","polygons","kk","rings"],"sourceRoot":""}
{"version":3,"file":"js/5918.33297825.js","mappings":"sPAyBA,MAAMA,UAAoBC,EAAA,EAIxB,WAAAC,CAAYC,GACVC,QAMAC,KAAKC,KAAOH,CACd,CAOA,mBAAAI,CAAoBC,EAAMC,IACxB,SACF,CAMA,mBAAAC,CAAoBD,GAClB,MAAME,EAAYF,EAAWE,UACvBC,EAA6BH,EAAWG,2BACxCC,EAA6BJ,EAAWI,4BAE9C,QACED,EACAH,EAAWK,KAAK,GAAK,EACrBL,EAAWK,KAAK,GAAK,EACrB,EAAIH,EAAUI,YACb,EAAIJ,EAAUI,YACdJ,EAAUK,UACVL,EAAUM,OAAO,IACjBN,EAAUM,OAAO,KAGpB,QAAYJ,EAA4BD,EAC1C,CAiBA,0BAAAM,CACEC,EACAV,EACAW,EACAC,EACAC,EACAC,EACAC,EACAC,GAEA,IAAIC,EACJ,MAAMf,EAAYF,EAAWE,UAS7B,SAASO,EAA2BS,EAASC,EAASC,EAAOC,GAC3D,OAAOR,EAASS,KAAKR,EAASK,EAASD,EAAUE,EAAQ,KAAMC,EACjE,CAEA,MAAME,EAAarB,EAAUqB,WAEvBC,GAAuB,QAAMd,EAAWe,QAASF,GACjDG,EAAU,CAAC,CAAC,EAAG,IACrB,GAAIH,EAAWI,YAAcf,EAAc,CACzC,MAAMgB,EAAmBL,EAAWM,YAC9BC,GAAa,QAASF,GAC5BF,EAAQK,KAAK,EAAED,EAAY,GAAI,CAACA,EAAY,GAC9C,CAEA,MAAME,EAAchC,EAAWiC,iBACzBC,EAAYF,EAAYG,OAExBC,EAA4C,GAC5CC,EAAW,GACjB,IAAK,IAAIC,EAAI,EAAGA,EAAIZ,EAAQS,OAAQG,IAClC,IAAK,IAAIC,EAAIL,EAAY,EAAGK,GAAK,IAAKA,EAAG,CACvC,MAAMC,EAAaR,EAAYO,GACzBnB,EAAQoB,EAAWpB,MACzB,GACEA,EAAMqB,gBACN,OAAOD,EAAYtC,IACnBa,EAAYO,KAAKN,EAAUI,GAC3B,CACA,MAAMsB,EAAgBtB,EAAMuB,cACtBC,EAASxB,EAAMyB,YACrB,GAAIH,GAAiBE,EAAQ,CAC3B,MAAME,EAAcF,EAAOG,WACvBvB,EACAd,EACEG,EAAWJ,EAA2BuC,KAC1C,KACAR,EAAWtB,SAEbmB,EAAS,GAAKS,EAAY,GAAKpB,EAAQY,GAAG,GAC1CD,EAAS,GAAKS,EAAY,GAAKpB,EAAQY,GAAG,GAC1CrB,EAASyB,EAAcjC,2BACrB4B,EACArC,EACAW,EACAE,EACAuB,EAEJ,CACA,GAAInB,EACF,OAAOA,CAEX,CACF,CAEF,GAAuB,IAAnBmB,EAAQD,OACV,OAEF,MAAMc,EAAQ,EAAIb,EAAQD,OAM1B,OALAC,EAAQc,SAAQ,CAACC,EAAGb,IAAOa,EAAEC,YAAcd,EAAIW,IAC/Cb,EAAQiB,MAAK,CAACC,EAAGC,IAAMD,EAAEF,WAAaG,EAAEH,aACxChB,EAAQoB,MAAML,GACJlC,EAASkC,EAAEtC,SAASsC,EAAEhC,QAASgC,EAAE/B,MAAO+B,EAAE9B,YAE7CJ,CACT,CAeA,sBAAAwC,CACE/C,EACAV,EACAW,EACAC,EACAG,EACAD,GAEA,MAAM4C,EAAa9D,KAAKa,2BACtBC,EACAV,EACAW,EACAC,EACA,KACAhB,KACAmB,EACAD,GAGF,YAAsB6C,IAAfD,CACT,CAKA,MAAAE,GACE,OAAOhE,KAAKC,IACd,CAOA,WAAAgE,CAAY7D,IACV,SACF,CAKA,mBAAA8D,CAAoB9D,GAAa,CAMjC,uBAAA+D,CAAwB/D,GAClB,IAAegE,kBACjBhE,EAAWiE,oBAAoBlC,KAAKmC,EAExC,EAOF,SAASA,EAAgBxE,EAAKM,GAC5B,IAAemE,QACjB,CAEA,U,iFCrOA,MAAMC,UAA6BC,EAIjC,WAAA5E,CAAYC,GACVC,MAAMD,GAKNE,KAAK0E,wBAAyB,QAC5B,KACAC,EAAA,EAAgBC,eAChB9E,EAAI+E,WAAWzB,KAAKtD,IAOtBE,KAAK8E,SAAWC,SAASC,cAAc,OACvC,MAAMC,EAAQjF,KAAK8E,SAASG,MAC5BA,EAAMC,SAAW,WACjBD,EAAME,MAAQ,OACdF,EAAMG,OAAS,OACfH,EAAMI,OAAS,IAEfrF,KAAK8E,SAASQ,UAAY,KAAqB,aAE/C,MAAMC,EAAYzF,EAAI0F,cACtBD,EAAUE,aAAazF,KAAK8E,SAAUS,EAAUG,YAAc,MAM9D1F,KAAK2F,UAAY,GAMjB3F,KAAK4F,kBAAmB,EAKxB5F,KAAK6F,iBAAmB,EAC1B,CAMA,mBAAA3F,CAAoBC,EAAMC,GACxB,MAAMN,EAAME,KAAKgE,SACjB,GAAIlE,EAAIgG,YAAY3F,GAAO,CACzB,MAAM4F,EAAQ,IAAI,IAAY5F,OAAM4D,EAAW3D,GAC/CN,EAAIkG,cAAcD,EACpB,CACF,CAEA,eAAAE,IACE,QAAcjG,KAAK0E,wBACnB1E,KAAK8E,SAASoB,WAAWC,YAAYnG,KAAK8E,UAC1C/E,MAAMkG,iBACR,CAMA,WAAAhC,CAAY7D,GACV,IAAKA,EAKH,YAJIJ,KAAK4F,mBACP5F,KAAK8E,SAASG,MAAMmB,QAAU,OAC9BpG,KAAK4F,kBAAmB,IAK5B5F,KAAKK,oBAAoBD,GACzBJ,KAAKE,oBAAoB,IAAgBmG,WAAYjG,GAErD,MAAMiC,EAAmBjC,EAAWiC,iBAAiBoB,MAAK,SAAUC,EAAGC,GACrE,OAAOD,EAAE2B,OAAS1B,EAAE0B,MACtB,IACM/E,EAAYF,EAAWE,UAE7BN,KAAK2F,UAAUpD,OAAS,EAExB,MAAM+D,EAAkBtG,KAAK6F,iBAC7BS,EAAgB/D,OAAS,EAEzB,IAAIgE,EAAkB,KACtB,IAAK,IAAI7D,EAAI,EAAG8D,EAAKnE,EAAiBE,OAAQG,EAAI8D,IAAM9D,EAAG,CACzD,MAAME,EAAaP,EAAiBK,GACpCtC,EAAWqG,WAAa/D,EAExB,MAAMlB,EAAQoB,EAAWpB,MACnBkF,EAAclF,EAAMmF,iBAC1B,KACG,OAAO/D,EAAYtC,IACJ,SAAfoG,GAAyC,aAAfA,EAC3B,CACAlF,EAAMoF,WACN,QACF,CAEA,MAAMC,EAAUrF,EAAMsF,OAAO1G,EAAYmG,GACpCM,IAGDA,IAAYN,IACdvG,KAAK2F,UAAUxD,KAAK0E,GACpBN,EAAkBM,GAEhB,iBAAkBrF,GACpB8E,EAAgBnE,KAC0C,GAG9D,CACAnC,KAAKkE,oBAAoB9D,IAEzB,QAAgBJ,KAAK8E,SAAU9E,KAAK2F,WAEpC3F,KAAKE,oBAAoB,IAAgB6G,YAAa3G,GAEjDJ,KAAK4F,mBACR5F,KAAK8E,SAASG,MAAMmB,QAAU,GAC9BpG,KAAK4F,kBAAmB,GAG1B5F,KAAKmE,wBAAwB/D,EAC/B,CAKA,mBAAA8D,CAAoB9D,GAClB,MAAM4G,EAAShH,KAAK6F,iBACpB,IAAK,IAAInD,EAAIsE,EAAOzE,OAAS,EAAGG,GAAK,IAAKA,EACxCsE,EAAOtE,GAAGuE,gBAAgB7G,GAE5B4G,EAAOzE,OAAS,CAClB,EAGF,S,mFC5JA,MAAM2E,UAAsB,IAI1B,WAAArH,CAAY2B,GACVzB,QAMAC,KAAKmH,OAAQ,EAGbnH,KAAKoH,wBAA0BpH,KAAKqH,mBAAmBjE,KAAKpD,MAM5DA,KAAKsH,OAAS9F,EAKdxB,KAAKuH,uBAAyB,IAChC,CAQA,WAAAC,CAAYC,GACV,OAAO,SACT,CAMA,OAAAC,CAAQD,GACN,OAAO,IACT,CAQA,YAAAE,CAAavH,GACX,OAAO,SACT,CASA,WAAA6D,CAAY7D,EAAYwH,GACtB,OAAO,SACT,CAQA,kBAAAC,CAAmBC,EAAOC,EAAMC,GACzBF,EAAMC,KACTD,EAAMC,GAAQ,CAAC,GAEjBD,EAAMC,GAAMC,EAAKC,UAAUC,YAAcF,CAE3C,CAWA,sBAAAG,CAAuBnF,EAAQrB,EAAYmG,GACzC,MAAO,CAMJC,EAAMK,KACL,MAAMnH,EAAWjB,KAAK6H,mBAAmBzE,KAAKpD,KAAM8H,EAAOC,GAC3D,OAAO/E,EAAOqF,kBAAkB1G,EAAYoG,EAAMK,EAAWnH,EAEjE,CACF,CAWA,0BAAAJ,CACEC,EACAV,EACAW,EACAE,EACAuB,GAGF,CAKA,QAAA8F,GACE,OAAOtI,KAAKsH,MACd,CAMA,kBAAAiB,GAAsB,CAOtB,kBAAAlB,CAAmBtB,GACjB,MAAMyC,EAAsDzC,EAAY,OAEtEyC,EAAMC,aAAe,IAAWC,QAChCF,EAAMC,aAAe,IAAWE,OAEhC3I,KAAK4I,yBAET,CASA,SAAAC,CAAUL,GACR,IAAIM,EAAaN,EAAMC,WAQvB,OAPIK,GAAc,IAAWJ,QAAUI,GAAc,IAAWH,OAC9DH,EAAMO,iBAAiB,IAAUC,OAAQhJ,KAAKoH,yBAE5C0B,GAAc,IAAWG,OAC3BT,EAAMU,OACNJ,EAAaN,EAAMC,YAEdK,GAAc,IAAWJ,MAClC,CAKA,uBAAAE,GACE,MAAMpH,EAAQxB,KAAKsI,WACf9G,GAASA,EAAM2H,cAA2C,UAA3B3H,EAAMmF,kBACvCnF,EAAM4H,SAEV,CAKA,eAAAnD,UACSjG,KAAKsH,OACZvH,MAAMkG,iBACR,EAGF,S,wGC5KA,MAAMoD,UAAiC,IAIrC,WAAAxJ,CAAYyJ,GACVvJ,MAAMuJ,GAMNtJ,KAAKuJ,OAAS,IAChB,CAKA,QAAAC,GACE,OAAOxJ,KAAKuJ,OAASvJ,KAAKuJ,OAAOC,WAAa,IAChD,CAOA,YAAA7B,CAAavH,GACX,MAAMwC,EAAaxC,EAAWiC,iBAAiBjC,EAAWqG,YACpDgD,EAAarJ,EAAWqJ,WACxBnJ,EAAYF,EAAWE,UACvBoJ,EAAiBpJ,EAAUI,WAE3BiJ,EAAc3J,KAAKsI,WAAWrF,YAE9B2G,EAAQxJ,EAAWyJ,UAEzB,IAAIC,EAAiB1J,EAAW2J,OAQhC,QAP0BhG,IAAtBnB,EAAWmH,SACbD,GAAiB,QACfA,GACA,IAAAE,gBAAepH,EAAWmH,OAAQzJ,EAAUqB,eAK7CiI,EAAM,IAASK,aACfL,EAAM,IAASM,gBACf,QAAQJ,GAET,GAAIH,EAAa,CACf,MAAMhI,EAAarB,EAAUqB,WACvB6G,EAAQmB,EAAYH,SACxBM,EACAJ,EACAD,EACA9H,GAEE6G,IACExI,KAAK6I,UAAUL,GACjBxI,KAAKuJ,OAASf,EACLA,EAAMC,aAAe,IAAW0B,QACzCnK,KAAKuJ,OAAS,MAGpB,MACEvJ,KAAKuJ,OAAS,KAIlB,QAASvJ,KAAKuJ,MAChB,CAMA,OAAA7B,CAAQD,GACN,MAAMrH,EAAaJ,KAAKI,WACxB,IAAKA,EACH,OAAO,KAGT,MAAMoB,EAAQxB,KAAKsI,WACbxH,GAAa,QACjBV,EAAWI,2BACXiH,EAAM5F,SAGFuI,EAAc5I,EAAMS,YAC1B,GAAImI,KACG,QAAmBA,EAAatJ,GACnC,OAAO,KAIX,MAAMuJ,EAAcrK,KAAKuJ,OAAOtH,YAC1BqI,EAAMtK,KAAKwJ,WAEXe,GAAgB,QAASF,GACzBG,EAAMC,KAAKC,MACfJ,EAAInF,QAAUrE,EAAW,GAAKuJ,EAAY,IAAME,IAElD,GAAIC,EAAM,GAAKA,GAAOF,EAAInF,MACxB,OAAO,KAGT,MAAMwF,GAAiB,QAAUN,GAC3BO,EAAMH,KAAKC,MACfJ,EAAIlF,SAAWiF,EAAY,GAAKvJ,EAAW,IAAM6J,IAEnD,OAAIC,EAAM,GAAKA,GAAON,EAAIlF,OACjB,KAGFpF,KAAK6K,aAAaP,EAAKE,EAAKI,EACrC,CAQA,WAAA3G,CAAY7D,EAAYwH,GACtB,MAAMY,EAAQxI,KAAKuJ,OACbc,EAAc7B,EAAMvG,YACpB6I,EAAkBtC,EAAMuC,gBACxBC,EAAkBxC,EAAMyC,gBACxBrI,EAAaxC,EAAWiC,iBAAiBjC,EAAWqG,YACpDgD,EAAarJ,EAAWqJ,WACxBnJ,EAAYF,EAAWE,UACvB4K,EAAa5K,EAAUM,OACvB8I,EAAiBpJ,EAAUI,WAC3ByK,EACH1B,EAAaqB,GAAoBpB,EAAiBsB,GAE/CjB,EAAS3J,EAAW2J,OACpBrJ,EAAaJ,EAAUI,WACvBC,EAAWL,EAAUK,SAErBwE,EAAQsF,KAAKW,OAAO,QAASrB,GAAUrJ,EAAc+I,GACrDrE,EAASqF,KAAKW,OAAO,QAAUrB,GAAUrJ,EAAc+I,IAG7D,QACEzJ,KAAKqL,eACLjL,EAAWK,KAAK,GAAK,EACrBL,EAAWK,KAAK,GAAK,EACrB,EAAIgJ,EACJ,EAAIA,EACJ9I,GACCwE,EAAQ,GACRC,EAAS,IAEZ,QAAYpF,KAAKsL,sBAAuBtL,KAAKqL,gBAE7C,MAAME,GAAkB,QAAkBvL,KAAKqL,gBAE/CrL,KAAKwL,aAAa5D,EAAQ2D,EAAiBvL,KAAKyL,cAAcrL,IAE9D,MAAMsL,EAAU1L,KAAK0L,QACfC,EAASD,EAAQC,OAEnBA,EAAOxG,OAASA,GAASwG,EAAOvG,QAAUA,GAC5CuG,EAAOxG,MAAQA,EACfwG,EAAOvG,OAASA,GACNpF,KAAK4L,iBACfF,EAAQG,UAAU,EAAG,EAAG1G,EAAOC,GAIjC,IAAI0G,GAAU,EACVhF,GAAS,EACb,GAAIlE,EAAWmH,OAAQ,CACrB,MAAMK,GAAc,IAAAJ,gBAClBpH,EAAWmH,OACXzJ,EAAUqB,YAEZmF,GAAS,QAAiBsD,EAAahK,EAAW2J,QAClD+B,EAAUhF,KAAW,QAAesD,EAAahK,EAAW2J,QACxD+B,GACF9L,KAAK+L,cAAcL,EAAStL,EAAYgK,EAE5C,CAEA,MAAME,EAAMtK,KAAKwJ,WAEXwC,GAAY,QAChBhM,KAAKiM,cACL9G,EAAQ,EACRC,EAAS,EACT+F,EACAA,EACA,EACCH,GAAmBX,EAAY,GAAKa,EAAW,IAAOJ,EACtDE,GAAmBE,EAAW,GAAKb,EAAY,IAAOS,GAGzD9K,KAAKkM,mBAAsBpB,EAAkBrB,EAAcuB,EAE3D,MAAMmB,EAAK7B,EAAInF,MAAQ6G,EAAU,GAC3BI,EAAK9B,EAAIlF,OAAS4G,EAAU,GAOlC,GALKhM,KAAKsI,WAAWrF,YAAYoJ,mBAC/BX,EAAQY,uBAAwB,GAGlCtM,KAAKuM,UAAUb,EAAStL,GACpB0G,GAAUqF,GAAM,IAAOC,GAAM,GAAK,CACpC,MAAMI,EAAKR,EAAU,GACfS,EAAKT,EAAU,GACfU,EAAU9J,EAAW8J,QAC3B,IAAIC,EACY,IAAZD,IACFC,EAAgBjB,EAAQkB,YACxBlB,EAAQkB,YAAcF,GAExBhB,EAAQmB,UAAUvC,EAAK,EAAG,GAAIA,EAAInF,OAAQmF,EAAIlF,OAAQoH,EAAIC,EAAIN,EAAIC,GAClD,IAAZM,IACFhB,EAAQkB,YAAcD,EAE1B,CAYA,OAXA3M,KAAK8M,WAAWpB,EAAStL,GAErB0L,GACFJ,EAAQqB,UAEVrB,EAAQY,uBAAwB,EAE5Bf,IAAoBI,EAAO1G,MAAM+G,YACnCL,EAAO1G,MAAM+G,UAAYT,GAGpBvL,KAAKuF,SACd,EAGF,S,sICjPO,MAAMyH,EAAa,GAK1B,IAAIC,EAAe,KAEnB,SAASC,IACPD,GAAe,QAAsB,EAAG,OAAGlJ,EAAW,CACpDoJ,oBAAoB,GAExB,CAOA,MAAMC,UAA4B,IAIhC,WAAAvN,CAAY2B,GACVzB,MAAMyB,GAMNxB,KAAKuF,UAAY,KAMjBvF,KAAKkM,mBAQLlM,KAAKiM,eAAgB,UAQrBjM,KAAKqL,gBAAiB,UAQtBrL,KAAKsL,uBAAwB,UAK7BtL,KAAK0L,QAAU,KAKf1L,KAAK4L,iBAAkB,EAMvB5L,KAAKqN,cAAgB,KAMrBrN,KAAKI,WAAa,IACpB,CAQA,YAAAyK,CAAarC,EAAOgC,EAAKI,GAMvB,IAAI0C,EALCL,GACHC,IAEFD,EAAapB,UAAU,EAAG,EAAG,EAAG,GAGhC,IACEoB,EAAaJ,UAAUrE,EAAOgC,EAAKI,EAAK,EAAG,EAAG,EAAG,EAAG,EAAG,GACvD0C,EAAOL,EAAapC,aAAa,EAAG,EAAG,EAAG,GAAGyC,IAC/C,CAAE,MAAOC,GAEP,OADAN,EAAe,KACR,IACT,CACA,OAAOK,CACT,CAMA,aAAA7B,CAAcrL,GACZ,MAAMoB,EAAQxB,KAAKsI,WACnB,IAAIkF,EAAahM,EAAMiK,gBAIvB,MAH0B,oBAAf+B,IACTA,EAAaA,EAAWpN,EAAWE,UAAUI,aAExC8M,QAAczJ,CACvB,CAQA,YAAAyH,CAAa5D,EAAQoE,EAAWyB,GAC9B,MAAMC,EAAiB1N,KAAKsI,WAAWqF,eACvC,IAAIpI,EAAWmG,EACf,GACE9D,GACAA,EAAOtC,YAAcoI,KACnBD,GACC7F,GACCA,EAAO3C,MAAMwI,kBACb,SACE,QAAQ7F,EAAO3C,MAAMwI,kBACrB,QAAQA,KAEd,CACA,MAAM9B,EAAS/D,EAAOgG,kBAClBjC,aAAkBkC,oBACpBnC,EAAUC,EAAOmC,WAAW,MAEhC,CAcA,GAbIpC,GAAWA,EAAQC,OAAO1G,MAAM+G,YAAcA,GAEhDhM,KAAKuF,UAAYqC,EACjB5H,KAAK0L,QAAUA,EACf1L,KAAK4L,iBAAkB,GACd5L,KAAK4L,iBAEd5L,KAAKuF,UAAY,KACjBvF,KAAK0L,QAAU,KACf1L,KAAK4L,iBAAkB,GACd5L,KAAKuF,YACdvF,KAAKuF,UAAUN,MAAMwI,gBAAkB,OAEpCzN,KAAKuF,UAAW,CACnBA,EAAYR,SAASC,cAAc,OACnCO,EAAUD,UAAYoI,EACtB,IAAIzI,EAAQM,EAAUN,MACtBA,EAAMC,SAAW,WACjBD,EAAME,MAAQ,OACdF,EAAMG,OAAS,OACfsG,GAAU,UACV,MAAMC,EAASD,EAAQC,OACvBpG,EAAUwI,YAAYpC,GACtB1G,EAAQ0G,EAAO1G,MACfA,EAAMC,SAAW,WACjBD,EAAM+I,KAAO,IACb/I,EAAMgJ,gBAAkB,WACxBjO,KAAKuF,UAAYA,EACjBvF,KAAK0L,QAAUA,CACjB,CAEG1L,KAAK4L,kBACN6B,GACCzN,KAAKuF,UAAUN,MAAMwI,kBAEtBzN,KAAKuF,UAAUN,MAAMwI,gBAAkBA,EAE3C,CAQA,aAAA1B,CAAcL,EAAStL,EAAY2J,GACjC,MAAMmE,GAAU,QAAWnE,GACrBoE,GAAW,QAAYpE,GACvBqE,GAAc,QAAerE,GAC7BsE,GAAa,QAActE,IAEjC,QAAe3J,EAAWG,2BAA4B2N,IACtD,QAAe9N,EAAWG,2BAA4B4N,IACtD,QAAe/N,EAAWG,2BAA4B6N,IACtD,QAAehO,EAAWG,2BAA4B8N,GAEtD,MAAMC,EAAWtO,KAAKsL,uBACtB,QAAegD,EAAUJ,IACzB,QAAeI,EAAUH,IACzB,QAAeG,EAAUF,IACzB,QAAeE,EAAUD,GAEzB3C,EAAQ6C,OACR7C,EAAQ8C,YACR9C,EAAQ+C,OAAOhE,KAAKW,MAAM8C,EAAQ,IAAKzD,KAAKW,MAAM8C,EAAQ,KAC1DxC,EAAQgD,OAAOjE,KAAKW,MAAM+C,EAAS,IAAK1D,KAAKW,MAAM+C,EAAS,KAC5DzC,EAAQgD,OAAOjE,KAAKW,MAAMgD,EAAY,IAAK3D,KAAKW,MAAMgD,EAAY,KAClE1C,EAAQgD,OAAOjE,KAAKW,MAAMiD,EAAW,IAAK5D,KAAKW,MAAMiD,EAAW,KAChE3C,EAAQiD,MACV,CAQA,oBAAAC,CAAqBzO,EAAMuL,EAAStL,GAClC,MAAMoB,EAAQxB,KAAKsI,WACnB,GAAI9G,EAAMsE,YAAY3F,GAAO,CAC3B,MAAM4F,EAAQ,IAAI,IAChB5F,EACAH,KAAKsL,sBACLlL,EACAsL,GAEFlK,EAAMwE,cAAcD,EACtB,CACF,CAOA,SAAAwG,CAAUb,EAAStL,GACjBJ,KAAKI,WAAaA,EAClBJ,KAAK4O,qBAAqB,IAAgBC,UAAWnD,EAAStL,EAChE,CAOA,UAAA0M,CAAWpB,EAAStL,GAClBJ,KAAK4O,qBAAqB,IAAgBE,WAAYpD,EAAStL,EACjE,CAcA,kBAAA2O,CACEnO,EACAF,EACAC,EACA8I,EACAtE,EACAC,EACA4J,GAEA,MAAMC,EAAM9J,EAAQ,EACd+J,EAAM9J,EAAS,EACf+J,EAAK1F,EAAa/I,EAClB0O,GAAMD,EACNE,GAAOzO,EAAO,GAAKoO,EACnBM,GAAO1O,EAAO,GACpB,OAAO,QACLZ,KAAKiM,cACLgD,EACAC,EACAC,EACAC,GACCzO,EACD0O,EACAC,EAEJ,CAKA,eAAArJ,UACSjG,KAAKI,WACZL,MAAMkG,iBACR,EAGF,S,2JCjSA,MAAMsJ,UAAgC,IAIpC,WAAA1P,CAAY2P,GACVzP,MAAMyP,GAMNxP,KAAKyP,eAAgB,EAMrBzP,KAAK0P,gBAAkB,KAMvB1P,KAAK2P,mBAML3P,KAAK4P,mBAAqB,KAM1B5P,KAAK6P,iBAML7P,KAAK8P,cAAgB,GAMrB9P,KAAK+P,WAAY,EAMjB/P,KAAKgQ,WAAY,UAMjBhQ,KAAKiQ,cAAgB,IAAI,IAAU,EAAG,EAAG,EAAG,EAC9C,CAOA,cAAAC,CAAelI,GACb,MAAMwH,EAAYxP,KAAKsI,WACjB6H,EAAYnI,EAAKS,WACjB2H,EAAyBZ,EAAUa,4BACzC,OACEF,GAAa,IAAUzH,QACvByH,GAAa,IAAUhG,OACtBgG,GAAa,IAAUxH,QAAUyH,CAEtC,CASA,OAAAE,CAAQC,EAAGC,EAAGC,EAAGrQ,GACf,MAAMqJ,EAAarJ,EAAWqJ,WACxB9H,EAAavB,EAAWE,UAAUqB,WAClC6N,EAAYxP,KAAKsI,WACjBoI,EAAalB,EAAUvM,YAC7B,IAAI+E,EAAO0I,EAAWJ,QAAQC,EAAGC,EAAGC,EAAGhH,EAAY9H,GAUnD,OATIqG,EAAKS,YAAc,IAAUE,OAC3B6G,EAAUa,6BAA+Bb,EAAUmB,aAAe,IAEpE3Q,KAAK+P,WAAY,GAGhB/P,KAAKkQ,eAAelI,KACvBA,EAAOA,EAAK4I,kBAEP5I,CACT,CAMA,OAAAN,CAAQD,GACN,MAAMrH,EAAaJ,KAAKI,WACxB,IAAKA,EACH,OAAO,KAGT,MAAMoB,EAAQxB,KAAKsI,WACbxH,GAAa,QACjBV,EAAWI,2BACXiH,EAAM5F,SAGFuI,EAAc5I,EAAMS,YAC1B,GAAImI,KACG,QAAmBA,EAAatJ,GACnC,OAAO,KAIX,MAAM2I,EAAarJ,EAAWqJ,WACxB9H,EAAavB,EAAWE,UAAUqB,WAClCrB,EAAYF,EAAWE,UACvB0C,EAASxB,EAAMqP,kBACfC,EAAW9N,EAAO+N,yBAAyBzQ,EAAUqB,YACrDqP,EAAiBhO,EAAOiO,kBAAkB7Q,EAAWqJ,YAE3D,IACE,IAAI8G,EAAIO,EAASI,kBAAkB5Q,EAAUI,YAC7C6P,GAAKO,EAASK,eACZZ,EACF,CACA,MAAMtI,EAAY6I,EAASM,yBAAyBtQ,EAAYyP,GAC1DvI,EAAOhF,EAAOsN,QAClBC,EACAtI,EAAU,GACVA,EAAU,GACVwB,EACA9H,GAEF,KACIqG,aAAgB,KAAaA,aAAgB,MAC9CA,aAAgB,KAAcA,EAAKS,aAAe,IAAU0B,MAE7D,OAAO,KAGT,GAAInC,EAAKS,aAAe,IAAUC,OAChC,SAGF,MAAM2I,EAAaP,EAASQ,UAAUf,GAChCgB,GAAW,QAAOT,EAASU,YAAYjB,IACvCkB,EAAiBX,EAAS/F,cAAcwF,GAExC/F,EAAMC,KAAKC,MACfsG,IACIlQ,EAAW,GAAKuQ,EAAW,IAAMI,EACjCxJ,EAAU,GAAKsJ,EAAS,KAGxB3G,EAAMH,KAAKC,MACfsG,IACIK,EAAW,GAAKvQ,EAAW,IAAM2Q,EACjCxJ,EAAU,GAAKsJ,EAAS,KAGxBG,EAASjH,KAAKW,MAClB4F,EAAiBhO,EAAO2O,uBAAuBrR,EAAUqB,aAG3D,OAAO3B,KAAK6K,aAAa7C,EAAKwB,WAAYgB,EAAMkH,EAAQ9G,EAAM8G,EAChE,CAEA,OAAO,IACT,CAQA,kBAAA7J,CAAmBC,EAAOC,EAAMC,GAC9B,QAAIhI,KAAKkQ,eAAelI,IACfjI,MAAM8H,mBAAmBC,EAAOC,EAAMC,EAGjD,CAOA,YAAAL,CAAavH,GACX,QAASJ,KAAKsI,WAAWrF,WAC3B,CAQA,WAAAgB,CAAY7D,EAAYwH,GACtB,MAAMhF,EAAaxC,EAAWiC,iBAAiBjC,EAAWqG,YACpDnG,EAAYF,EAAWE,UACvBqB,EAAarB,EAAUqB,WACvB+H,EAAiBpJ,EAAUI,WAC3BwK,EAAa5K,EAAUM,OACvBD,EAAWL,EAAUK,SACrB8I,EAAarJ,EAAWqJ,WAExB+F,EAAYxP,KAAKsI,WACjBoI,EAAalB,EAAUvM,YACvB2O,EAAiBlB,EAAWmB,cAC5Bf,EAAWJ,EAAWK,yBAAyBpP,GAC/C4O,EAAIO,EAASI,kBAAkBxH,EAAgBgH,EAAWoB,YAC1DL,EAAiBX,EAAS/F,cAAcwF,GAE9C,IAAIxG,EAAS3J,EAAW2J,OACxB,MAAMrJ,EAAaN,EAAWE,UAAUI,WAClCsQ,EAAiBN,EAAWO,kBAAkBxH,GAE9CtE,EAAQsF,KAAKW,OAAO,QAASrB,GAAUrJ,EAAc+I,GACrDrE,EAASqF,KAAKW,OAAO,QAAUrB,GAAUrJ,EAAc+I,GAEvDW,EACJxH,EAAWmH,SAAU,IAAAC,gBAAepH,EAAWmH,OAAQpI,GACrDyI,IACFL,GAAS,QACPA,GACA,IAAAC,gBAAepH,EAAWmH,OAAQpI,KAItC,MAAM6K,EAAMiF,EAAiBtM,EAAS,EAAI6L,EACpCvE,EAAMgF,EAAiBrM,EAAU,EAAI4L,EACrCe,EAAe,CACnB7G,EAAW,GAAKsB,EAChBtB,EAAW,GAAKuB,EAChBvB,EAAW,GAAKsB,EAChBtB,EAAW,GAAKuB,GAGZrE,EAAY0I,EAASkB,0BAA0BjI,EAAQwG,GAKvD0B,EAAiB,CAAC,EACxBA,EAAe1B,GAAK,CAAC,EAErB,MAAM2B,EAAkBlS,KAAKmI,uBAC3BuI,EACA/O,EACAsQ,GAGIjC,EAAYhQ,KAAKgQ,UACjBmC,EAAenS,KAAKiQ,cAC1BjQ,KAAK+P,WAAY,EACjB,MAAMqC,EAAWzR,GACb,QACEL,EAAUM,OACVF,EACAC,EACAP,EAAWK,WAEbsD,EACJ,IAAK,IAAIyM,EAAIpI,EAAUiK,KAAM7B,GAAKpI,EAAUkK,OAAQ9B,EAClD,IAAK,IAAIC,EAAIrI,EAAUmK,KAAM9B,GAAKrI,EAAUoK,OAAQ/B,EAAG,CACrD,GACE9P,IACCmQ,EAAS2B,4BAA4B,CAAClC,EAAGC,EAAGC,GAAI2B,GAEjD,SAEF,MAAMpK,EAAOhI,KAAKsQ,QAAQC,EAAGC,EAAGC,EAAGrQ,GACnC,GAAIJ,KAAKkQ,eAAelI,GAAO,CAC7B,MAAM0K,GAAM,QAAO1S,MACnB,GAAIgI,EAAKS,YAAc,IAAUC,OAAQ,CACvCuJ,EAAe1B,GAAGvI,EAAKC,UAAUC,YAAcF,EAC/C,IAAI2K,EAAe3K,EAAK2K,aAAaD,GACjCC,GAAuC,IAAvB/P,EAAW8J,UAE7B1E,EAAK4K,cAAcF,GACnBC,GAAe,GAGd3S,KAAK+P,YACL4C,GAAiB3S,KAAK8P,cAAc+C,SAAS7K,KAE9ChI,KAAK+P,WAAY,EAErB,CACA,GAA4C,IAAxC/H,EAAK8K,SAASJ,EAAKtS,EAAW2S,MAEhC,QAEJ,CAEA,MAAMC,EAAiBlC,EAASmC,2BAC9BjL,EAAKC,UACLkK,EACAnC,GAGF,IAAIkD,GAAU,EACVF,IACFE,EAAUhB,EAAgB3B,EAAI,EAAGyC,IAE9BE,GACHpC,EAASqC,gCACPnL,EAAKC,UACLiK,EACAC,EACAnC,EAGN,CAGF,MAAMoD,EACF3B,EAAiB/H,EAAkBD,EAAcuH,GAGrD,QACEhR,KAAKqL,eACLjL,EAAWK,KAAK,GAAK,EACrBL,EAAWK,KAAK,GAAK,EACrB,EAAIgJ,EACJ,EAAIA,EACJ9I,GACCwE,EAAQ,GACRC,EAAS,GAGZ,MAAMmG,GAAkB,QAAkBvL,KAAKqL,gBAE/CrL,KAAKwL,aAAa5D,EAAQ2D,EAAiBvL,KAAKyL,cAAcrL,IAC9D,MAAMsL,EAAU1L,KAAK0L,QACfC,EAASD,EAAQC,QAEvB,QAAY3L,KAAKsL,sBAAuBtL,KAAKqL,iBAG7C,QACErL,KAAKiM,cACL9G,EAAQ,EACRC,EAAS,EACTgO,EACAA,EACA,GACCjO,EAAQ,GACRC,EAAS,GAGRuG,EAAOxG,OAASA,GAASwG,EAAOvG,QAAUA,GAC5CuG,EAAOxG,MAAQA,EACfwG,EAAOvG,OAASA,GACNpF,KAAK4L,iBACfF,EAAQG,UAAU,EAAG,EAAG1G,EAAOC,GAG7BgF,GACFpK,KAAK+L,cAAcL,EAAStL,EAAYgK,GAGrCsG,EAAWrE,mBACdX,EAAQY,uBAAwB,GAGlCtM,KAAKuM,UAAUb,EAAStL,GAExBJ,KAAK8P,cAAcvN,OAAS,EAE5B,IAGI8Q,EAAOC,EAAQC,EAHfC,EAAKC,OAAOC,KAAKzB,GAAgBnS,IAAI6T,QACzCH,EAAG/P,KAAK,MAIiB,IAAvBb,EAAW8J,SACT1M,KAAK4L,kBACL8E,EAAWkD,UAAUxT,EAAWE,UAAUqB,aAI5C0R,EAAQ,GACRC,EAAS,IAHTE,EAAKA,EAAGK,UAKV,IAAK,IAAInR,EAAI8Q,EAAGjR,OAAS,EAAGG,GAAK,IAAKA,EAAG,CACvC,MAAMoR,EAAWN,EAAG9Q,GACdqR,EAAuBrD,EAAWsD,iBACtCF,EACArK,EACA9H,GAEIsS,EAAoBnD,EAAS/F,cAAc+I,GAC3CI,EAAeD,EAAoBxC,EACnCjF,EAAKuH,EAAqB,GAAKG,EAAed,EAC9C3G,EAAKsH,EAAqB,GAAKG,EAAed,EAC9Ce,EAAkBrD,EAASM,0BAC/B,QAAWW,GACX+B,GAEIM,EAAmBtD,EAASuD,mBAAmBF,GAC/CG,GAAS,QAAetU,KAAKiM,cAAe,CAC/C+E,GAAkBoD,EAAiB,GAAKrC,EAAa,IACpDN,EACDT,GAAkBe,EAAa,GAAKqC,EAAiB,IACpD3C,IAEE8C,EACJvD,EAAiBN,EAAWiB,uBAAuBhQ,GAC/C6S,EAAcvC,EAAe6B,GACnC,IAAK,MAAMW,KAAgBD,EAAa,CACtC,MAAMxM,EACJwM,EAAYC,GAERxM,EAAYD,EAAKC,UAGjByM,EAASP,EAAgB,GAAKlM,EAAU,GACxC0M,EAAQlK,KAAKW,MAAMkJ,EAAO,IAAMI,EAAS,GAAKlI,GAC9CoI,EAAST,EAAgB,GAAKlM,EAAU,GACxC4M,EAAQpK,KAAKW,MAAMkJ,EAAO,IAAMM,EAAS,GAAKnI,GAC9C+D,EAAI/F,KAAKW,MAAMkJ,EAAO,GAAKI,EAASlI,GACpCiE,EAAIhG,KAAKW,MAAMkJ,EAAO,GAAKM,EAASnI,GACpCqI,EAAIH,EAAQnE,EACZuE,EAAIF,EAAQpE,EACZuE,EAAazE,IAAMuD,EAEnBnB,EACJqC,GAA+D,IAAjDhN,EAAK8K,UAAS,QAAO9S,MAAOI,EAAW2S,MACvD,IAAIkC,GAAe,EACnB,IAAKtC,EACH,GAAIU,EAAO,CAETE,EAAc,CAAC/C,EAAGC,EAAGD,EAAIsE,EAAGrE,EAAGD,EAAIsE,EAAGrE,EAAIsE,EAAGvE,EAAGC,EAAIsE,GACpD,IAAK,IAAIrS,EAAI,EAAG8D,EAAK6M,EAAM9Q,OAAQG,EAAI8D,IAAM9D,EAC3C,GAAI6N,IAAMuD,GAAYA,EAAWR,EAAO5Q,GAAI,CAC1C,MAAMiM,EAAO0E,EAAM3Q,IAEjB,QACE,CAAC8N,EAAGC,EAAGD,EAAIsE,EAAGrE,EAAIsE,GAClB,CAACpG,EAAK,GAAIA,EAAK,GAAIA,EAAK,GAAIA,EAAK,OAG9BsG,IACHvJ,EAAQ6C,OACR0G,GAAe,GAEjBvJ,EAAQ8C,YAER9C,EAAQ+C,OAAO8E,EAAY,GAAIA,EAAY,IAC3C7H,EAAQgD,OAAO6E,EAAY,GAAIA,EAAY,IAC3C7H,EAAQgD,OAAO6E,EAAY,GAAIA,EAAY,IAC3C7H,EAAQgD,OAAO6E,EAAY,GAAIA,EAAY,IAE3C7H,EAAQ+C,OAAOE,EAAK,GAAIA,EAAK,IAC7BjD,EAAQgD,OAAOC,EAAK,GAAIA,EAAK,IAC7BjD,EAAQgD,OAAOC,EAAK,GAAIA,EAAK,IAC7BjD,EAAQgD,OAAOC,EAAK,GAAIA,EAAK,IAC7BjD,EAAQiD,OAEZ,CAEF0E,EAAMlR,KAAKoR,GACXD,EAAOnR,KAAK2R,EACd,MACEpI,EAAQG,UAAU2E,EAAGC,EAAGqE,EAAGC,GAG/B/U,KAAKkV,cACHlN,EACA5H,EACAoQ,EACAC,EACAqE,EACAC,EACAR,EACAS,GAEE3B,IAAUV,GACRsC,GACFvJ,EAAQqB,UAEV/M,KAAK8P,cAAcqF,QAAQnN,IAE3BhI,KAAK8P,cAAc3N,KAAK6F,GAE1BhI,KAAKoV,gBAAgBhV,EAAWiV,UAAW3E,EAAY1I,EACzD,CACF,CAiCA,OA/BAhI,KAAK6P,iBAAmB+B,EACxB5R,KAAKkM,mBAAqBuF,EAC1BzR,KAAKyP,eACFzP,KAAK0P,mBAAoB,QAAO1P,KAAK0P,gBAAiBqC,GACzD/R,KAAK0P,gBAAkBqC,EACvB/R,KAAK2P,mBAAqBlG,EAC1BzJ,KAAK4P,mBAAqBjO,EAE1B3B,KAAKsV,kBACHlV,EACAsQ,EACAI,EACArH,EACA9H,EACAoI,EACAwG,EACAf,EAAUmB,cAEZ3Q,KAAKuV,oBAAoBnV,EAAYsQ,GAErC1Q,KAAK8M,WAAWpB,EAAStL,GAErBwC,EAAWmH,QACb2B,EAAQqB,UAEVrB,EAAQY,uBAAwB,EAE5Bf,IAAoBI,EAAO1G,MAAM+G,YACnCL,EAAO1G,MAAM+G,UAAYT,GAGpBvL,KAAKuF,SACd,CAYA,aAAA2P,CAAclN,EAAM5H,EAAYoQ,EAAGC,EAAGqE,EAAGC,EAAGrD,EAAQsD,GAClD,MAAMxM,EAAQxI,KAAKwV,aAAaxN,GAChC,IAAKQ,EACH,OAEF,MAAMkK,GAAM,QAAO1S,MACb4C,EAAaxC,EAAWiC,iBAAiBjC,EAAWqG,YACpDgP,EACJ7S,EAAW8J,SACVsI,EAAahN,EAAK8K,SAASJ,EAAKtS,EAAW2S,MAAQ,GAChD2C,EAAeD,IAAUzV,KAAK0L,QAAQkB,YACxC8I,IACF1V,KAAK0L,QAAQ6C,OACbvO,KAAK0L,QAAQkB,YAAc6I,GAE7BzV,KAAK0L,QAAQmB,UACXrE,EACAkJ,EACAA,EACAlJ,EAAMrD,MAAQ,EAAIuM,EAClBlJ,EAAMpD,OAAS,EAAIsM,EACnBlB,EACAC,EACAqE,EACAC,GAGEW,GACF1V,KAAK0L,QAAQqB,UAEX0I,IAAU7S,EAAW8J,QACvBtM,EAAWuV,SAAU,EACZX,GACThN,EAAK4K,cAAcF,EAEvB,CAKA,QAAAlJ,GACE,MAAMkC,EAAU1L,KAAK0L,QACrB,OAAOA,EAAUA,EAAQC,OAAS,IACpC,CAQA,YAAA6J,CAAaxN,GACX,OAAOA,EAAKwB,UACd,CAOA,mBAAA+L,CAAoBnV,EAAYsQ,GAC9B,GAAIA,EAAWtM,iBAAkB,CAM/B,MAAMwR,EAAqB,SAAUlF,EAAY5Q,EAAKM,GACpD,MAAMyV,GAAgB,QAAOnF,GACzBmF,KAAiBzV,EAAWiV,WAC9B3E,EAAWoF,YACT1V,EAAWE,UAAUqB,WACrBvB,EAAWiV,UAAUQ,GAG3B,EAAEzS,KAAK,KAAMsN,GAEbtQ,EAAWiE,oBAAoBlC,KAC4B,EAI7D,CACF,CAQA,eAAAiT,CAAgBC,EAAW3E,EAAY1I,GAErC,MAAM6N,GAAgB,QAAOnF,GACvBmF,KAAiBR,IACrBA,EAAUQ,GAAiB,CAAC,GAE9BR,EAAUQ,GAAe7N,EAAK+N,WAAY,CAC5C,CAoBA,iBAAAT,CACElV,EACAsQ,EACAI,EACArH,EACA9H,EACAoI,EACA+J,EACAkC,EACAC,GAEA,MAAMJ,GAAgB,QAAOnF,GACvBmF,KAAiBzV,EAAW8V,cAChC9V,EAAW8V,YAAYL,GAAiB,CAAC,GAE3C,MAAMK,EAAc9V,EAAW8V,YAAYL,GACrCM,EAAY/V,EAAW+V,UACvBC,EAAUtF,EAASK,aACnBxQ,EAAWP,EAAWE,UAAUK,SAChCyR,EAAWzR,GACb,QACEP,EAAWE,UAAUM,OACrBR,EAAWE,UAAUI,WACrBC,EACAP,EAAWK,WAEbsD,EACJ,IACIiE,EAAMI,EAAWqJ,EAAgBjB,EAAGC,EAAGF,EADvC8F,EAAY,EAEhB,IAAK9F,EAAI6F,EAAS7F,GAAKuD,IAAYvD,EAGjC,IAFAnI,EAAY0I,EAASkB,0BAA0BjI,EAAQwG,EAAGnI,GAC1DqJ,EAAiBX,EAAS/F,cAAcwF,GACnCC,EAAIpI,EAAUiK,KAAM7B,GAAKpI,EAAUkK,OAAQ9B,EAC9C,IAAKC,EAAIrI,EAAUmK,KAAM9B,GAAKrI,EAAUoK,OAAQ/B,EAE5C9P,IACCmQ,EAAS2B,4BAA4B,CAAClC,EAAGC,EAAGC,GAAI2B,KAI/C0B,EAAWvD,GAAKyF,KAChBK,EACFrO,EAAO0I,EAAWJ,QAAQC,EAAGC,EAAGC,EAAGhH,EAAY9H,GAC3CqG,EAAKS,YAAc,IAAUQ,OAC/BiN,EAAYlO,EAAK+N,WAAY,EACxBI,EAAUG,YAAYtO,EAAK+N,WAC9BI,EAAUI,QAAQ,CAChBvO,EACA6N,EACA/E,EAAS0F,mBAAmBxO,EAAKC,WACjCwJ,UAIe1N,IAAjBkS,GACFA,EAAajO,IAGf0I,EAAW+F,QAAQlG,EAAGC,EAAGC,EAAG9O,IAKpC+O,EAAWgG,gBAAgBL,EAAW1U,EACxC,EAGF,S,gMC/sBA,MAAMgV,UAAkC,IAItC,WAAA9W,CAAY+W,GACV7W,MAAM6W,GAGN5W,KAAK6W,6BAA+B7W,KAAK8W,wBAAwB1T,KAAKpD,MAKtEA,KAAK+W,wBAKL/W,KAAKgX,uBAAyB,KAK9BhX,KAAKiX,kBAAoB,KAMzBjX,KAAKkX,mBAAqB,EAM1BlX,KAAKmX,oBAAsBC,IAM3BpX,KAAK0P,iBAAkB,UAMvB1P,KAAKqX,wBAAyB,UAM9BrX,KAAKsX,kBAMLtX,KAAKuX,gBAAkB,KAMvBvX,KAAKwX,oBAAsB,KAM3BxX,KAAKyX,qBAAuB,KAM5BzX,KAAK0X,aAAe,KAMpB1X,KAAK2X,oBAAqB,EAK1B3X,KAAKuH,uBAAyB,KAM9BvH,KAAK4X,UAAW,EAMhB5X,KAAK6X,oBAAsB,KAM3B7X,KAAK8X,SAAW,CAClB,CAOA,YAAAC,CAAaC,EAAe5X,EAAY6X,GACtC,MAAMlO,EAAS3J,EAAW2J,OACpBzJ,EAAYF,EAAWE,UACvBM,EAASN,EAAUM,OACnBF,EAAaJ,EAAUI,WACvBiB,EAAarB,EAAUqB,WACvBhB,EAAWL,EAAUK,SACrBqB,EAAmBL,EAAWM,YAC9BiW,EAAelY,KAAKsI,WAAWrF,YAC/BwG,EAAarJ,EAAWqJ,WACxBI,EAAYzJ,EAAWyJ,UACvBsO,IACJtO,EAAU,IAASI,YAAcJ,EAAU,IAASK,cAEhDwB,EAAU1L,KAAK6X,oBACf1S,EAAQsF,KAAKW,MAAMhL,EAAWK,KAAK,GAAKgJ,GACxCrE,EAASqF,KAAKW,MAAMhL,EAAWK,KAAK,GAAKgJ,GAEzC2O,EAAaF,EAAa/U,YAAcxB,EAAWI,WACnDG,EAAakW,GAAa,QAASpW,GAAoB,KACvDqW,EAAWD,EACb3N,KAAK6N,MAAMvO,EAAO,GAAK/H,EAAiB,IAAME,GAAc,EAC5D,EACJ,IAAIqW,EAAQH,EACR3N,KAAKC,OAAOX,EAAO,GAAK/H,EAAiB,IAAME,GAC/C,EACJ,EAAG,CACD,MAAM8J,EAAYhM,KAAK+O,mBACrBnO,EACAF,EACAC,EACA8I,EACAtE,EACAC,EACAmT,EAAQrW,GAEV8V,EAAcQ,QACZ9M,EACA,EACAM,EACArL,EACAwX,OACApU,EACAkU,EAEJ,SAAWM,EAAQF,EACrB,CAEA,wBAAAI,GACE,GAAsB,IAAlBzY,KAAK8X,SAAgB,CACvB,MAAMY,GAAqB,QACzB1Y,KAAK0L,QAAQC,OAAOxG,MACpBnF,KAAK0L,QAAQC,OAAOvG,OACpB,KAEFpF,KAAK6X,oBAAsBa,CAC7B,MACE1Y,KAAK6X,oBAAsB7X,KAAK0L,OAEpC,CAEA,0BAAAiN,GACE,GAAsB,IAAlB3Y,KAAK8X,SAAgB,CACvB,MAAMrC,EAAQzV,KAAK0L,QAAQkB,YAC3B5M,KAAK0L,QAAQkB,YAAc5M,KAAK8X,SAChC9X,KAAK0L,QAAQmB,UAAU7M,KAAK6X,oBAAoBlM,OAAQ,EAAG,GAC3D3L,KAAK0L,QAAQkB,YAAc6I,GAC3B,QAAczV,KAAK6X,qBACnB,IAAW1V,KAAKnC,KAAK6X,oBAAoBlM,QACzC3L,KAAK6X,oBAAsB,IAC7B,CACF,CAMA,eAAA5Q,CAAgB7G,GACVJ,KAAKuH,yBACPvH,KAAKyY,2BACLzY,KAAK+X,aACH/X,KAAKuH,uBACLnH,EACAA,EAAW6X,eAEbjY,KAAK2Y,6BAET,CAQA,WAAA1U,CAAY7D,EAAYwH,GACtB,MAAM6B,EAAarJ,EAAWqJ,WACxB7G,EAAaxC,EAAWiC,iBAAiBjC,EAAWqG,aAG1D,QAAUzG,KAAKqL,eAAgB,EAAI5B,EAAY,EAAIA,IACnD,QAAYzJ,KAAKsL,sBAAuBtL,KAAKqL,gBAE7C,MAAME,GAAkB,QAAkBvL,KAAKqL,gBAE/CrL,KAAKwL,aAAa5D,EAAQ2D,EAAiBvL,KAAKyL,cAAcrL,IAC9D,MAAMsL,EAAU1L,KAAK0L,QACfC,EAASD,EAAQC,OAEjBiN,EAAc5Y,KAAK0X,aACnBnQ,EAAyBvH,KAAKuH,uBACpC,IAAIT,EACD8R,IAAgBA,EAAYC,WAC5BtR,IAA2BA,EAAuBsR,UACrD,IAAK/R,EAAQ,CACX,MAAMgS,EACJ9Y,KAAKsI,WAAWxC,YAAY,IAAgB+I,YAC5C7O,KAAKsI,WAAWxC,YAAY,IAAgBgJ,YAC9C,IAAKgK,EACH,OAAO,IAEX,CAGA,MAAM3T,EAAQsF,KAAKW,MAAMhL,EAAWK,KAAK,GAAKgJ,GACxCrE,EAASqF,KAAKW,MAAMhL,EAAWK,KAAK,GAAKgJ,GAC3CkC,EAAOxG,OAASA,GAASwG,EAAOvG,QAAUA,GAC5CuG,EAAOxG,MAAQA,EACfwG,EAAOvG,OAASA,EACZuG,EAAO1G,MAAM+G,YAAcT,IAC7BI,EAAO1G,MAAM+G,UAAYT,IAEjBvL,KAAK4L,iBACfF,EAAQG,UAAU,EAAG,EAAG1G,EAAOC,GAGjCpF,KAAKuM,UAAUb,EAAStL,GAExB,MAAME,EAAYF,EAAWE,UACvBqB,EAAarB,EAAUqB,WAE7B3B,KAAK8X,SAAWlV,EAAW8J,QAC3B1M,KAAKyY,2BAGL,IAAI3M,GAAU,EACd,GAAIhF,GAAUlE,EAAWmH,QAAU/J,KAAK4X,SAAU,CAChD,MAAMxN,GAAc,IAAAJ,gBAAepH,EAAWmH,OAAQpI,GACtDmF,GAAS,QAAiBsD,EAAahK,EAAW2J,QAClD+B,EAAUhF,KAAW,QAAesD,EAAahK,EAAW2J,QACxD+B,GACF9L,KAAK+L,cAAc/L,KAAK6X,oBAAqBzX,EAAYgK,EAE7D,CAkBA,OAhBItD,GACF9G,KAAK+X,aAAaa,EAAaxY,GAG7B0L,GACF9L,KAAK6X,oBAAoB9K,UAG3B/M,KAAK2Y,6BAEL3Y,KAAK8M,WAAWpB,EAAStL,GAErBJ,KAAKsX,oBAAsBhX,EAAUK,WACvCX,KAAKsX,kBAAoBhX,EAAUK,SACnCX,KAAKgX,uBAAyB,MAEzBhX,KAAKuF,SACd,CAQA,WAAAiC,CAAYC,GACV,OAAO,IAAIsR,SAASC,IAClB,IAAKhZ,KAAKgX,yBAA2BhX,KAAK+W,wBAAyB,CACjE,MAAMtW,EAAO,CAACT,KAAK0L,QAAQC,OAAOxG,MAAOnF,KAAK0L,QAAQC,OAAOvG,SAC7D,QAAMpF,KAAKqL,eAAgB5K,GAC3B,MAAMG,EAASZ,KAAKuX,gBACd7W,EAAaV,KAAKmX,oBAClBxW,EAAWX,KAAKsX,kBAChB3V,EAAa3B,KAAKwX,oBAClBzN,EAAS/J,KAAKqX,uBACd7V,EAAQxB,KAAKsI,WACb2Q,EAAa,GACb9T,EAAQ1E,EAAK,GAAK,KAClB2E,EAAS3E,EAAK,GAAK,KACzBwY,EAAW9W,KACTnC,KAAK+O,mBACHnO,EACAF,EACAC,EACA,KACAwE,EACAC,EACA,GACAvD,SAEJ,MAAMmB,EAASxB,EAAMyB,YACfjB,EAAmBL,EAAWM,YACpC,GACEe,EAAOG,YACPxB,EAAWI,cACV,QAAeC,EAAkB+H,GAClC,CACA,IAAImP,EAASnP,EAAO,GACpB,MAAM7H,GAAa,QAASF,GAC5B,IACIgN,EADAuJ,EAAQ,EAEZ,MAAOW,EAASlX,EAAiB,KAC7BuW,EACFvJ,EAAU9M,EAAaqW,EACvBU,EAAW9W,KACTnC,KAAK+O,mBACHnO,EACAF,EACAC,EACA,KACAwE,EACAC,EACA4J,GACAnN,SAEJqX,GAAUhX,EAEZqW,EAAQ,EACRW,EAASnP,EAAO,GAChB,MAAOmP,EAASlX,EAAiB,KAC7BuW,EACFvJ,EAAU9M,EAAaqW,EACvBU,EAAW9W,KACTnC,KAAK+O,mBACHnO,EACAF,EACAC,EACA,KACAwE,EACAC,EACA4J,GACAnN,SAEJqX,GAAUhX,CAEd,CAEAlC,KAAKgX,wBAAyB,QAC5BvW,EACAwY,EACAjZ,KAAKiX,kBACLzV,EAAM2X,mBACNpP,EACArJ,EACAC,EAEJ,CACAqY,GACE,QAAUvR,EAAOzH,KAAKiX,kBAAmBjX,KAAKgX,wBAC/C,GAEL,CAWA,0BAAAnW,CACEC,EACAV,EACAW,EACAE,EACAuB,GAEA,IAAKxC,KAAK0X,aACR,OAEF,MAAMhX,EAAaN,EAAWE,UAAUI,WAClCC,EAAWP,EAAWE,UAAUK,SAChCa,EAAQxB,KAAKsI,WAGb8Q,EAAW,CAAC,EAQZC,EAAkB,SAAU9X,EAASE,EAAU+B,GACnD,MAAM8V,GAAM,QAAO/X,GACbgY,EAAQH,EAASE,GACvB,GAAKC,GAcE,IAAc,IAAVA,GAAkB/V,EAAa+V,EAAM/V,WAAY,CAC1D,GAAmB,IAAfA,EAGF,OAFA4V,EAASE,IAAO,EAChB9W,EAAQgX,OAAOhX,EAAQiX,YAAYF,GAAQ,GACpCtY,EAASM,EAASC,EAAOC,GAElC8X,EAAM9X,SAAWA,EACjB8X,EAAM/V,WAAaA,CACrB,MAtBY,CACV,GAAmB,IAAfA,EAEF,OADA4V,EAASE,IAAO,EACTrY,EAASM,EAASC,EAAOC,GAElCe,EAAQL,KACLiX,EAASE,GAAO,CACf/X,QAASA,EACTC,MAAOA,EACPC,SAAUA,EACV+B,WAAYA,EACZvC,SAAUA,GAGhB,CAUF,EAEA,IAAII,EACJ,MAAMqY,EAAiB,CAAC1Z,KAAK0X,cAkB7B,OAjBI1X,KAAKuH,wBACPmS,EAAevX,KAAKnC,KAAKuH,wBAE3BmS,EAAe9V,MAAMoU,GACX3W,EAAS2W,EAAcnX,2BAC7BC,EACAJ,EACAC,EACAI,EACAsY,EACArB,IAAkBhY,KAAKuH,wBACrBnH,EAAW6X,cACT7X,EAAW6X,cAAc0B,MAAM7Z,KAAK8Z,GAASA,EAAKC,QAClD,QAIDxY,CACT,CAKA,kBAAAkH,GACE,MAAM/G,EAAQxB,KAAKsI,WACf9G,EAAM2H,cAAgBnJ,KAAK0X,cAC7BlW,EAAM4H,SAEV,CAOA,uBAAA0N,CAAwB/Q,GACtB/F,KAAK4I,yBACP,CAOA,YAAAjB,CAAavH,GACX,MAAMwW,EAAc5W,KAAKsI,WACnB4P,EAAetB,EAAY3T,YACjC,IAAKiV,EACH,OAAO,EAGT,MAAM4B,EAAY1Z,EAAWyJ,UAAU,IAASI,WAC1C8P,EAAc3Z,EAAWyJ,UAAU,IAASK,aAC5C8P,EAAuBpD,EAAYqD,0BACnCC,EAAyBtD,EAAYuD,4BAE3C,GACGna,KAAKmH,QAAU6S,GAAwBF,IACtCI,GAA0BH,EAG5B,OADA/Z,KAAK+W,yBAA0B,GACxB,EAET/W,KAAK+W,yBAA0B,EAE/B,MAAMqD,EAAmBha,EAAW2J,OAC9BzJ,EAAYF,EAAWE,UACvBqB,EAAarB,EAAUqB,WACvBjB,EAAaJ,EAAUI,WACvB+I,EAAarJ,EAAWqJ,WACxB4Q,EAAsBzD,EAAY/E,cAClCyI,EAA0B1D,EAAY2D,kBAC5C,IAAIC,EAAyB5D,EAAY6D,sBAEV1W,IAA3ByW,IACFA,EAAyB,MAG3B,MAAM5Z,EAASN,EAAUM,OAAOiB,QAC1BkI,GAAS,QACbqQ,EACAE,EAA0B5Z,GAEtBoJ,EAAiBC,EAAOlI,QACxB6Y,EAAc,CAAC3Q,EAAOlI,SACtBG,EAAmBL,EAAWM,YAEpC,GACEiW,EAAa/U,YACbxB,EAAWI,cACV,QAAeC,EAAkB5B,EAAW2J,QAC7C,CAMA,MAAM7H,GAAa,QAASF,GACtB0P,EAASjH,KAAKkQ,KAAI,QAAS5Q,GAAU,EAAG7H,GAC9C6H,EAAO,GAAK/H,EAAiB,GAAK0P,EAClC3H,EAAO,GAAK/H,EAAiB,GAAK0P,GAClC,QAAgB9Q,EAAQe,GACxB,MAAMiZ,GAAa,QAAYF,EAAY,GAAI/Y,GAG7CiZ,EAAW,GAAK5Y,EAAiB,IACjC4Y,EAAW,GAAK5Y,EAAiB,GAEjC0Y,EAAYvY,KAAK,CACfyY,EAAW,GAAK1Y,EAChB0Y,EAAW,GACXA,EAAW,GAAK1Y,EAChB0Y,EAAW,KAGbA,EAAW,GAAK5Y,EAAiB,IACjC4Y,EAAW,GAAK5Y,EAAiB,IAEjC0Y,EAAYvY,KAAK,CACfyY,EAAW,GAAK1Y,EAChB0Y,EAAW,GACXA,EAAW,GAAK1Y,EAChB0Y,EAAW,IAGjB,CAEA,GACE5a,KAAKmH,OACLnH,KAAKmX,qBAAuBzW,GAC5BV,KAAKkX,mBAAqBmD,GAC1Bra,KAAKyX,sBAAwB+C,IAC7B,QAAexa,KAAKqX,uBAAwBtN,GAQ5C,OANK,QAAO/J,KAAK0P,gBAAiB5F,KAChC9J,KAAKgX,uBAAyB,KAC9BhX,KAAK0P,gBAAkB5F,GAEzB9J,KAAKuX,gBAAkB3W,EACvBZ,KAAK2X,oBAAqB,GACnB,EAGT3X,KAAK0X,aAAe,KAEpB,MAAMkB,EAAc,IAAI,KACtB,QAAmBlY,EAAY+I,GAC/BM,EACArJ,EACA+I,GAGF,IAAIoR,EACA7a,KAAKsI,WAAWwS,iBAClBD,EAAwB,IAAI,KAC1B,QAAmBna,EAAY+I,GAC/BM,EACArJ,EACA+I,IAIJ,MAAMsR,GAAiB,IAAAC,qBACvB,IAAIC,EACJ,GAAIF,EAAgB,CAClB,IAAK,IAAIrY,EAAI,EAAG8D,EAAKkU,EAAYnY,OAAQG,EAAI8D,IAAM9D,EAAG,CACpD,MAAMqH,EAAS2Q,EAAYhY,GACrBwY,GAAa,IAAAC,cAAapR,EAAQpI,GACxCuW,EAAakD,aACXF,GACA,IAAAG,kBAAiB3a,EAAYiB,GAC7BoZ,EAEJ,CACAE,GAAgB,IAAAK,6BAA4BP,EAAgBpZ,EAC9D,MACE,IAAK,IAAIe,EAAI,EAAG8D,EAAKkU,EAAYnY,OAAQG,EAAI8D,IAAM9D,EACjDwV,EAAakD,aAAaV,EAAYhY,GAAIhC,EAAYiB,GAI1D,MAAM4Z,GAAmB,QAA0B7a,EAAY+I,GAC/D,IAAItC,GAAQ,EACZ,MAAML,EAIHvF,IACC,IAAIia,EACJ,MAAMC,EACJla,EAAQ4X,oBAAsBvC,EAAYuC,mBAI5C,GAHIsC,IACFD,EAASC,EAAcla,EAASb,IAE9B8a,EAAQ,CACV,MAAME,EAAQ1b,KAAK2b,cACjBpa,EACAga,EACAC,EACA5C,EACAqC,EACAJ,GAEF1T,EAAQA,IAAUuU,CACpB,GAGER,GAAa,IAAAC,cAAapR,EAAQpI,GAElCyX,EAAWlB,EAAa0D,oBAAoBV,GAC9CV,GACFpB,EAAS3V,KAAK+W,GAEhB,IAAK,IAAI9X,EAAI,EAAG8D,EAAK4S,EAAS7W,OAAQG,EAAI8D,IAAM9D,EAC9CoE,EAAOsS,EAAS1W,IAElB1C,KAAKiX,kBAAoBmC,EACzBpZ,KAAKmH,MAAQA,EAEb,MAAM0U,EAA0BjD,EAAYkD,SACtC9D,EAAgB,IAAI,IACxBjO,EACArJ,EACA+I,EACAyO,EAAa6D,cACbF,EACAjF,EAAY2D,mBAyBd,OAtBIM,IACF7a,KAAKuH,uBAAyB,IAAI,IAChCwC,EACArJ,EACA+I,EACAyO,EAAa6D,cACblB,EAAsBiB,SACtBlF,EAAY2D,oBAIhBva,KAAKmX,oBAAsBzW,EAC3BV,KAAKkX,kBAAoBmD,EACzBra,KAAKyX,qBAAuB+C,EAC5Bxa,KAAK0P,gBAAkB5F,EACvB9J,KAAKqX,uBAAyBtN,EAC9B/J,KAAKuX,gBAAkB3W,EACvBZ,KAAKwX,oBAAsB7V,EAC3B3B,KAAK0X,aAAeM,EACpBhY,KAAKgX,uBAAyB,KAE9BhX,KAAK2X,oBAAqB,GACnB,CACT,CAWA,aAAAgE,CACEpa,EACAga,EACAC,EACAQ,EACAhQ,EACA6O,GAEA,IAAKW,EACH,OAAO,EAET,IAAIS,GAAU,EACd,GAAIC,MAAMC,QAAQX,GAChB,IAAK,IAAI9Y,EAAI,EAAG8D,EAAKgV,EAAOjZ,OAAQG,EAAI8D,IAAM9D,EAC5CuZ,GACE,QACED,EACAza,EACAia,EAAO9Y,GACP6Y,EACAvb,KAAK6W,6BACL7K,EACA6O,IACGoB,OAGTA,GAAU,QACRD,EACAza,EACAia,EACAD,EACAvb,KAAK6W,6BACL7K,EACA6O,GAGJ,OAAOoB,CACT,EAGF,S,wKCpvBA,MAAMG,EAAgB,CACpB,MAAS,CAAC,UAAW,SAAU,aAAc,QAAS,QACtD,OAAU,CAAC,UAAW,cACtB,OAAU,IAMNC,EAAiB,CACrB,OAAU,CAAC,QAAS,OAAQ,WAC5B,OAAU,CAAC,UAAW,SAAU,aAAc,QAAS,OAAQ,YASjE,MAAMC,UAAsC,IAI1C,WAAAzc,CAAY2B,GACVzB,MAAMyB,GAGNxB,KAAK6W,6BAA+B7W,KAAK8W,wBAAwB1T,KAAKpD,MAMtEA,KAAKuc,uBAMLvc,KAAKwc,oCAAsC,KAM3Cxc,KAAKsX,kBAMLtX,KAAKyc,eAAgB,SACvB,CAQA,WAAAC,CAAY1U,EAAMyB,EAAY9H,GAC5B,IAAImF,EACJ,MAAM6V,EAAQ3U,EAAKS,WAOnB,OANIkU,IAAU,IAAUjU,QAAUiU,IAAU,IAAUhU,QACpD3I,KAAK4c,qBAAqB5U,EAAMyB,EAAY9H,GACxC3B,KAAK6c,sBAAsB7U,KAC7BlB,GAAS,IAGNA,CACT,CASA,OAAAwJ,CAAQC,EAAGC,EAAGC,EAAGrQ,GACf,MAAMqJ,EAAarJ,EAAWqJ,WACxBnJ,EAAYF,EAAWE,UACvBI,EAAaJ,EAAUI,WACvBiB,EAAarB,EAAUqB,WACvBH,EAAQxB,KAAKsI,WACbN,EAAOxG,EAAMyB,YAAYqN,QAAQC,EAAGC,EAAGC,EAAGhH,EAAY9H,GACtDkI,EAAYzJ,EAAWyJ,UACvBiT,IACJjT,EAAU,IAASI,YAAcJ,EAAU,IAASK,eAElD4S,GAAS9U,EAAK+U,mBAChB/U,EAAK+U,iBAAmBrc,GAE1B,MAAMoG,EAAS9G,KAAK0c,YAAY1U,EAAMyB,EAAY9H,GAQlD,OANEmF,IACCgW,GAAQE,KAAKC,MAAQ7c,EAAW2S,KAAO,IACd,WAA1BvR,EAAM0b,iBAENld,KAAKmd,iBAAiBnV,EAAM5H,GAEvBL,MAAMuQ,QAAQC,EAAGC,EAAGC,EAAGrQ,EAChC,CAMA,cAAA8P,CAAelI,GACb,MAAMxG,EAAQxB,KAAKsI,WACnB,OACEvI,MAAMmQ,eAAelI,KACM,WAA1BxG,EAAM0b,iBACH,QAAO1b,KAAUwG,EAAK0R,eACtB1R,EAAKoV,WAAW5b,GAExB,CAKA,YAAAgU,CAAaxN,GACX,OAAOA,EAAKwB,SAASxJ,KAAKsI,WAC5B,CAOA,YAAAX,CAAavH,GACX,MAAMid,EAAgBrd,KAAKsI,WAAWuJ,cAKtC,OAJI7R,KAAKuc,yBAA2Bc,IAClCrd,KAAKuc,uBAAyBc,EAC9Brd,KAAK8P,cAAcvN,OAAS,GAEvBxC,MAAM4H,aAAavH,EAC5B,CAQA,oBAAAwc,CAAqB5U,EAAMyB,EAAY9H,GACrC,MAAMH,EACJxB,KAAKsI,WAEDgV,EAAW9b,EAAMqQ,cACjB0L,EAAc/b,EAAMiZ,kBAAoB,KAExC/Z,EAAasH,EAAK+U,iBAClBS,EAAexV,EAAKyV,eAAejc,GACzC,IACGgc,EAAa9B,OACd8B,EAAatR,qBAAuBxL,GACpC8c,EAAa3N,kBAAoByN,GACjCE,EAAaE,qBAAuBH,EAEpC,OAGF,MAAMva,EAASxB,EAAMyB,YACf0a,EAAYnc,EAAMsZ,eAClB8C,EAAiB5a,EAAO6a,cACxB/M,EAAW9N,EAAO+N,yBAAyBpP,GAC3Cmc,EAAahN,EAASuD,mBAAmBrM,EAAK+V,kBAE9CC,EAAchb,EAAOib,eAAexU,EAAY9H,EAAYqG,GAC5DkW,GAAW,QAAO1c,UACjBwG,EAAKmW,sBAAsBD,GAClClW,EAAK0R,eAAewE,GAAY,GAC5BP,IACF3V,EAAKoW,wBAAwBF,GAAY,IAE3CV,EAAa9B,OAAQ,EACrB,IAAK,IAAI2C,EAAI,EAAGC,EAAKN,EAAYzb,OAAQ8b,EAAIC,IAAMD,EAAG,CACpD,MAAME,EAAaP,EAAYK,GAC/B,GAAIE,EAAW9V,YAAc,IAAUC,OACrC,SAEF,MAAM8V,EAAkBD,EAAWtW,UAC7BwW,EACJb,EAAevJ,mBAAmBmK,GAC9BE,GAAe,QAAgBZ,EAAYW,GAC3CE,GAAgB,QACpBD,EACAld,EAAM+Y,kBAAoB7Z,EAC1BV,KAAKgQ,WAED4O,GAAiB,QAAOH,EAAkBC,GAC5C,KACAC,EACE3C,EAAe,IAAI,IACvB,EACA2C,EACAje,EACA+I,GAEIoR,EAAwB8C,EAC1B,IAAI,IAAmB,EAAGe,EAAche,EAAY+I,QACpD1F,EACEwX,GAAmB,QACvB7a,EACA+I,GAOI3C,EAAS,SAAUvF,GACvB,IAAIia,EACJ,MAAMC,EACJla,EAAQ4X,oBAAsB3X,EAAM2X,mBAItC,GAHIsC,IACFD,EAASC,EAAcla,EAASb,IAE9B8a,EAAQ,CACV,MAAME,EAAQ1b,KAAK2b,cACjBpa,EACAga,EACAC,EACAQ,EACAnB,GAEF2C,EAAa9B,MAAQ8B,EAAa9B,OAASA,CAC7C,CACF,EAEMtC,EAAWmF,EAAW/W,cACxB+V,GAAeA,IAAgBC,EAAaE,qBAC9CtE,EAAS3V,KAAK8Z,GAEhB,IAAK,IAAI7a,EAAI,EAAG8D,EAAK4S,EAAS7W,OAAQG,EAAI8D,IAAM9D,EAAG,CACjD,MAAMnB,EAAU6X,EAAS1W,GAEtBkc,KACD,QAAWA,EAAgBrd,EAAQsd,cAAc5c,cAEjD6E,EAAOpF,KAAK1B,KAAMuB,EAEtB,CACA,MAAMud,EAA4B9C,EAAaF,SAEzCiD,EACsB,WAA1Bvd,EAAM0b,iBACNS,GACuB,IAAvBK,EAAYzb,OACR,KACAmc,EACAM,EAAuB,IAAI,IAC/BD,EACAre,EACA+I,EACAzG,EAAO+Y,cACP+C,EACAtd,EAAM+Y,mBAGR,GADAvS,EAAK0R,eAAewE,GAAU/b,KAAK6c,GAC/BnE,EAAuB,CACzB,MAAMtT,EAAyB,IAAI,IACjC,KACA7G,EACA+I,EACAzG,EAAO+Y,cACPlB,EAAsBiB,SACtBta,EAAM+Y,mBAERvS,EAAKoW,wBAAwBF,GAAU/b,KAAKoF,EAC9C,CACF,CACAiW,EAAa3N,iBAAmByN,EAChCE,EAAaE,oBAAsBH,EACnCC,EAAatR,mBAAqBxL,CACpC,CAWA,0BAAAG,CACEC,EACAV,EACAW,EACAE,EACAuB,GAEA,MAAM9B,EAAaN,EAAWE,UAAUI,WAClCC,EAAWP,EAAWE,UAAUK,SACtCI,OAA+BgD,GAAhBhD,EAA4B,EAAIA,EAC/C,MAAMS,EAAQxB,KAAKsI,WACbtF,EAASxB,EAAMyB,YACf6N,EAAW9N,EAAO+N,yBACtB3Q,EAAWE,UAAUqB,YAGjBsd,GAAY,QAAe,CAACne,KAClC,QAAOme,EAAWve,EAAaK,EAAcke,GAG7C,MAAM7F,EAAW,CAAC,EAQZC,EAAkB,SAAU9X,EAASE,EAAU+B,GACnD,IAAI8V,EAAM/X,EAAQ2d,aACNnb,IAARuV,IACFA,GAAM,QAAO/X,IAEf,MAAMgY,EAAQH,EAASE,GACvB,GAAKC,GAcE,IAAc,IAAVA,GAAkB/V,EAAa+V,EAAM/V,WAAY,CAC1D,GAAmB,IAAfA,EAGF,OAFA4V,EAASE,IAAO,EAChB9W,EAAQgX,OAAOhX,EAAQiX,YAAYF,GAAQ,GACpCtY,EAASM,EAASC,EAAOC,GAElC8X,EAAM9X,SAAWA,EACjB8X,EAAM/V,WAAaA,CACrB,MAtBY,CACV,GAAmB,IAAfA,EAEF,OADA4V,EAASE,IAAO,EACTrY,EAASM,EAASC,EAAOC,GAElCe,EAAQL,KACLiX,EAASE,GAAO,CACf/X,QAASA,EACTC,MAAOA,EACPC,SAAUA,EACV+B,WAAYA,EACZvC,SAAUA,GAGhB,CAUF,EAEM6O,EAEF9P,KACF,cAEF,IAAImf,EACJ,IAAK,IAAIzc,EAAI,EAAG8D,EAAKsJ,EAAcvN,QAAS4c,GAASzc,EAAI8D,IAAM9D,EAAG,CAChE,MAAMsF,EAAO8H,EAAcpN,GACrBob,EAAahN,EAASuD,mBAAmBrM,EAAK+V,kBACpD,KAAK,QAAWD,EAAYmB,GAC1B,SAGF,MAAMf,GAAW,QAAO1c,GAClBkY,EAAiB,CAAC1R,EAAK0R,eAAewE,IACtCE,EAA0BpW,EAAKoW,wBAAwBF,GACzDE,GACF1E,EAAevX,KAAKic,GAEtB1E,EAAe9V,MAAM8V,IACnB,MAAM0F,EACJ1F,IAAmB0E,EACfhe,EAAW6X,cAAc0B,MAAM7Z,KAAK8Z,GAASA,EAAKC,QAClD,KACN,IAAK,IAAIwE,EAAI,EAAGC,EAAK5E,EAAenX,OAAQ8b,EAAIC,IAAMD,EAAG,CACvD,MAAMrG,EAAgB0B,EAAe2E,GASrC,GARAc,EAAQnH,EAAcnX,2BACpBC,EACAJ,EACAC,EACAI,EACAsY,EACA+F,GAEED,EACF,OAAO,CAEX,IAEJ,CACA,OAAOA,CACT,CAOA,WAAA3X,CAAYC,GACV,OAAO,IAAIsR,SAAQ,CAACC,EAASqG,KAC3B,MAAM7d,EAAQxB,KAAKsI,WACb4V,GAAW,QAAO1c,GAClBwB,EAASxB,EAAMyB,YACftB,EAAa3B,KAAK4P,mBAClB5N,EAAmBL,EAAWM,YAC9BvB,EAAaV,KAAKkM,mBAClB4E,EAAW9N,EAAO+N,yBAAyBpP,GAC3Cb,GAAa,QACjBd,KAAKwc,oCACL/U,EAAM5F,SAEFoG,EAAY6I,EAASwO,kCACzBxe,EACAJ,GAGF,IAAIsH,EACJ,IAAK,IAAItF,EAAI,EAAG8D,EAAKxG,KAAK8P,cAAcvN,OAAQG,EAAI8D,IAAM9D,EACxD,GACEuF,EAAUC,aAAelI,KAAK8P,cAAcpN,GAAGuF,UAAUC,WACzD,CAIA,GAHAF,EACEhI,KAAK8P,cAAcpN,GAEjBsF,EAAKS,aAAe,IAAUC,OAAQ,CACxC,MAAMqB,EAAS+G,EAASuD,mBAAmBrM,EAAKC,WAE9CjF,EAAOG,YACPxB,EAAWI,cACV,QAAeC,EAAkB+H,KAElC,QAAMjJ,EAAYa,GAEpB,KACF,CACAqG,OAAOjE,CACT,CAEF,IAAKiE,GAAQA,EAAKuX,mBAAqB,EAErC,YADAvG,EAAQ,IAGV,MAAMjP,EAAS+G,EAASuD,mBAAmBrM,EAAK+V,kBAC1CyB,GAAS,QAAWzV,GACpB0V,EAAY,EACf3e,EAAW,GAAK0e,EAAO,IAAM9e,GAC7B8e,EAAO,GAAK1e,EAAW,IAAMJ,GAG1B0Y,EAAWpR,EACdiW,iBACAyB,QAAO,SAAUC,EAAapB,GAC7B,OAAOoB,EAAYC,OAAOrB,EAAW/W,cACvC,GAAG,IAEL,IAAI2W,EAAwBnW,EAAKmW,sBAAsBD,GACvD,IAAKC,EAAuB,CAC1B,MAAM5M,GAAW,QACfT,EAASU,YACPV,EAASI,kBAAkBxQ,EAAYsC,EAAO8O,cAG5CnR,EAAWX,KAAKsX,kBAChB2B,EAAa,CACjBjZ,KAAK+O,mBACH+B,EAAS0F,mBAAmBxO,EAAK+V,kBACjCrd,EACA,EACA,KACA6Q,EAAS,GAAK,KACdA,EAAS,GAAK,KACd,IAGJ4M,GAAwB,QACtB5M,EACA0H,EACAG,EACA5X,EAAM2X,mBACNrI,EAASuD,mBAAmBrM,EAAK+V,kBACjC/V,EAAKyV,eAAejc,GAAO0K,mBAC3BvL,GAEFqH,EAAKmW,sBAAsBD,GAAYC,CACzC,CACAnF,GAAQ,QAAUyG,EAAWrG,EAAU+E,GAAuB,GAElE,CAKA,kBAAA5V,GACE,MAAM/G,EAAQxB,KAAKsI,WACf9G,EAAM2H,mBAAgDpF,IAAhC/D,KAAKuc,wBAC7B/a,EAAM4H,SAEV,CAOA,uBAAA0N,CAAwB/Q,GACtB/F,KAAK4I,yBACP,CAMA,eAAA3B,CAAgB7G,GACd,MAAMsL,EAAU1L,KAAK0L,QACf+J,EAAQ/J,EAAQkB,YACtBlB,EAAQkB,YAAc5M,KAAKsI,WAAWuX,aACtC,MAAMhW,EAAYzJ,EAAWyJ,UACvBiT,IACJjT,EAAU,IAASI,YAAcJ,EAAU,IAASK,cAEhDpC,EAEF9H,KACF,cACF,IAAK,IAAI0C,EAAI,EAAG8D,EAAKsB,EAAMvF,OAAQG,EAAI8D,IAAM9D,EAAG,CAC9C,MAAMsF,EAAOF,EAAMpF,GACb0b,EACJpW,EAAKoW,yBAAwB,QAAOpe,KAAKsI,aAC3C,GAAI8V,EACF,IAAK,IAAIzb,EAAIyb,EAAwB7b,OAAS,EAAGI,GAAK,IAAKA,EACzDyb,EAAwBzb,GAAG6V,QACzBxY,KAAK0L,QACL,EACA1L,KAAK8f,uBAAuB9X,EAAM5H,GAClCA,EAAWE,UAAUK,SACrBmc,OACA/Y,EACA3D,EAAW6X,cAInB,CACAvM,EAAQkB,YAAc6I,CACxB,CAEA,sBAAAqK,CAAuB9X,EAAM5H,GAC3B,MAAMqJ,EAAarJ,EAAWqJ,WACxBnJ,EAAYF,EAAWE,UACvBM,EAASN,EAAUM,OACnBF,EAAaJ,EAAUI,WACvBC,EAAWL,EAAUK,SACrBF,EAAOL,EAAWK,KAClB0E,EAAQsF,KAAKW,MAAM3K,EAAK,GAAKgJ,GAC7BrE,EAASqF,KAAKW,MAAM3K,EAAK,GAAKgJ,GAE9BzG,EAAShD,KAAKsI,WAAWrF,YACzB6N,EAAW9N,EAAO+N,yBACtB3Q,EAAWE,UAAUqB,YAEjBsG,EAAYD,EAAKC,UACjB6V,EAAahN,EAASuD,mBAAmBrM,EAAK+V,kBAC9CgC,EACJjP,EAASuD,mBAAmBpM,EAAWjI,KAAKgQ,WAAW,GAAK8N,EAAW,GACnE9R,GAAY,SAChB,QAAMhM,KAAKsL,sBAAsBzJ,QAAS,EAAI4H,EAAY,EAAIA,GAC9DzJ,KAAK+O,mBACHnO,EACAF,EACAC,EACA8I,EACAtE,EACAC,EACA2a,IAGJ,OAAO/T,CACT,CAOA,UAAAc,CAAWpB,EAAStL,GAClB,MAAMyJ,EAAYzJ,EAAWyJ,UACvBiT,IACJjT,EAAU,IAASI,YAAcJ,EAAU,IAASK,cAGtDlK,KAAKwc,oCACHpc,EAAWI,2BAA2BqB,QACxC7B,KAAKsX,kBAAoBlX,EAAWE,UAAUK,SAE9C,MAAMa,EACJxB,KAAKsI,WAED0X,EAAaxe,EAAM0b,gBACnBzH,EAAQ/J,EAAQkB,YACtBlB,EAAQkB,YAAcpL,EAAMqe,aAC5B,MAAMI,EAAc5D,EAAe2D,GAC7B1f,EAAYF,EAAWE,UACvBK,EAAWL,EAAUK,SACrB+P,EAAalP,EAAMyB,YACnB6N,EAAWJ,EAAWK,yBAAyBzQ,EAAUqB,YACzD4O,EAAIO,EAASI,kBACjB5Q,EAAUI,WACVgQ,EAAWoB,YAGPhK,EAAQ9H,KAAK8P,cACbuD,EAAQ,GACRC,EAAS,GACf,IAAInM,GAAQ,EACZ,IAAK,IAAIzE,EAAIoF,EAAMvF,OAAS,EAAGG,GAAK,IAAKA,EAAG,CAC1C,MAAMsF,EACJF,EAAMpF,GAERyE,EAAQA,IAAUa,EAAKyV,eAAejc,GAAOka,MAC7C,MAAMhC,EAAiB1R,EAAK0R,gBAAe,QAAOlY,IAAQ0e,QACvDC,GAAUA,EAAMC,aAAaH,KAEhC,GAA8B,IAA1BvG,EAAenX,OACjB,SAEF,MAAMyJ,EAAYhM,KAAK8f,uBAAuB9X,EAAM5H,GAC9C0T,EAAW9L,EAAKC,UAAU,GAChC,IAAIgN,GAAe,EAEnB,MAAM1B,EAAcmG,EAAe,GAAG2G,cAAcrU,GACpD,GAAIuH,EAAa,CACf,IAAK,IAAI5Q,EAAI,EAAG2d,EAAKjN,EAAM9Q,OAAQI,EAAI2d,IAAM3d,EAC3C,GAAI4N,IAAMuD,GAAYA,EAAWR,EAAO3Q,GAAI,CAC1C,MAAMgM,EAAO0E,EAAM1Q,IAEjB,QACE,CACE4Q,EAAY,GACZA,EAAY,GACZA,EAAY,GACZA,EAAY,IAEd,CAAC5E,EAAK,GAAIA,EAAK,GAAIA,EAAK,GAAIA,EAAK,OAG9BsG,IACHvJ,EAAQ6C,OACR0G,GAAe,GAEjBvJ,EAAQ8C,YAER9C,EAAQ+C,OAAO8E,EAAY,GAAIA,EAAY,IAC3C7H,EAAQgD,OAAO6E,EAAY,GAAIA,EAAY,IAC3C7H,EAAQgD,OAAO6E,EAAY,GAAIA,EAAY,IAC3C7H,EAAQgD,OAAO6E,EAAY,GAAIA,EAAY,IAE3C7H,EAAQ+C,OAAOE,EAAK,GAAIA,EAAK,IAC7BjD,EAAQgD,OAAOC,EAAK,GAAIA,EAAK,IAC7BjD,EAAQgD,OAAOC,EAAK,GAAIA,EAAK,IAC7BjD,EAAQgD,OAAOC,EAAK,GAAIA,EAAK,IAC7BjD,EAAQiD,OAEZ,CAEF0E,EAAMlR,KAAKoR,GACXD,EAAOnR,KAAK2R,EACd,CACA,IAAK,IAAIuK,EAAI,EAAGC,EAAK5E,EAAenX,OAAQ8b,EAAIC,IAAMD,EAAG,CACvD,MAAMrG,EAAgB0B,EAAe2E,GACrCrG,EAAcQ,QACZ9M,EACA,EACAM,EACArL,EACAmc,EACAmD,EAEJ,CACIhL,GACFvJ,EAAQqB,SAEZ,CACArB,EAAQkB,YAAc6I,EACtBzV,KAAKmH,MAAQA,EAEbpH,MAAM+M,WAAWpB,EAAStL,EAC5B,CAUA,aAAAub,CACEpa,EACAga,EACAC,EACAQ,EACAnB,GAEA,IAAKW,EACH,OAAO,EAET,IAAIS,GAAU,EACd,GAAIC,MAAMC,QAAQX,GAChB,IAAK,IAAI9Y,EAAI,EAAG8D,EAAKgV,EAAOjZ,OAAQG,EAAI8D,IAAM9D,EAC5CuZ,GACE,QACED,EACAza,EACAia,EAAO9Y,GACP6Y,EACAvb,KAAK6W,kCACL9S,EACA8W,IACGoB,OAGTA,GAAU,QACRD,EACAza,EACAia,EACAD,EACAvb,KAAK6W,kCACL9S,EACA8W,GAGJ,OAAOoB,CACT,CAOA,qBAAAY,CAAsB7U,GACpB,MAAMxG,EACJxB,KAAKsI,WAEP,GAA8B,WAA1B9G,EAAM0b,gBACR,OAAO,EAET,MAAMqD,EAAcvY,EAAKyV,eAAejc,GAClC8b,EAAW9b,EAAMqQ,cACjBnR,EAAasH,EAAK+U,iBACxB,OACEwD,EAAYC,yBAA2B9f,GACvC6f,EAAYE,uBAAyBnD,CAEzC,CAOA,gBAAAH,CAAiBnV,EAAM5H,GACrB,MAAMoB,EACJxB,KAAKsI,WAEDiY,EAAcvY,EAAKyV,eAAejc,GAClC8b,EAAW9b,EAAMqQ,cACjB6H,EAAiB1R,EAAK0R,gBAAe,QAAOlY,IAClD+e,EAAYE,qBAAuBnD,EAEnC,MAAMrV,EAAYD,EAAK+V,iBACjBxN,EAAItI,EAAU,GACdjF,EAASxB,EAAMyB,YACrB,IAAIwG,EAAarJ,EAAWqJ,WAC5B,MAAMnJ,EAAYF,EAAWE,UACvBqB,EAAarB,EAAUqB,WACvBmP,EAAW9N,EAAO+N,yBAAyBpP,GAC3C8P,EAAiBX,EAAS/F,cAAc/C,EAAKC,UAAU,IACvDyY,EACHtgB,EAAWqJ,WAAazB,EAAK+U,iBAAoBtL,EAC9C/Q,EAAaoQ,EAAS/F,cAAcwF,GACpC7E,EAAU1D,EAAK8F,WAAWtM,GAGhCiI,EAAagB,KAAKW,MAChBX,KAAKkQ,IAAIlR,EAAYiX,EAAmBjX,IAE1C,MAAMhJ,EAAOuC,EAAOgR,iBAAiBzD,EAAG9G,EAAY9H,GACpD+J,EAAQC,OAAOxG,MAAQ1E,EAAK,GAC5BiL,EAAQC,OAAOvG,OAAS3E,EAAK,GAC7B,MAAMkgB,EAAclX,EAAaiX,EACjC,GAAoB,IAAhBC,EAAmB,CACrB,MAAMpV,GAAkB,QAAevL,KAAKyc,gBAC5C,QAAelR,EAAiBoV,EAAaA,GAC7CjV,EAAQkV,aAAaC,MAAMnV,EAASH,EACtC,CACA,MAAMuS,EAAahN,EAASuD,mBAAmBpM,EAAWjI,KAAKgQ,WACzD8Q,EAAaJ,EAAmBhgB,EAChCsL,GAAY,QAAehM,KAAKyc,gBACtC,QAAezQ,EAAW8U,GAAaA,IACvC,QAAmB9U,GAAY8R,EAAW,IAAKA,EAAW,IAC1D,IAAK,IAAIpb,EAAI,EAAG8D,EAAKkT,EAAenX,OAAQG,EAAI8D,IAAM9D,EAAG,CACvD,MAAMsV,EAAgB0B,EAAehX,GACrCsV,EAAcQ,QACZ9M,EACAiV,EACA3U,EACA,GACA,EACAoQ,EAAc5a,EAAM0b,iBAExB,CACAqD,EAAYC,uBAAyBxY,EAAK+U,gBAC5C,EAGF,S,yFCl0BA,MAAMgE,EAAqB,GAQrBC,EAAqB,CACzB,MAASC,EACT,WAAcC,EACd,QAAWC,EACX,WAAcC,EACd,gBAAmBC,EACnB,aAAgBC,EAChB,mBAAsBC,EACtB,OAAUC,GAQL,SAASC,EAAaC,EAAUC,GACrC,OAAOC,UAAS,QAAOF,GAAW,IAAME,UAAS,QAAOD,GAAW,GACrE,CAOO,SAASE,EAAoBnhB,EAAY+I,GAC9C,MAAMqY,EAAYC,EAAarhB,EAAY+I,GAC3C,OAAOqY,EAAYA,CACrB,CAOO,SAASC,EAAarhB,EAAY+I,GACvC,OAAQsX,EAAqBrgB,EAAc+I,CAC7C,CASA,SAAS+X,EACPxF,EACAva,EACAwD,EACA1D,EACAsZ,GAEA,MAAMmH,EAAY/c,EAAMgd,UAClBC,EAAcjd,EAAMkd,YAC1B,GAAIH,GAAaE,EAAa,CAC5B,MAAME,EAAepG,EAAaqG,WAAWpd,EAAMqd,YAAa,UAChEF,EAAaG,mBAAmBP,EAAWE,GAC3CE,EAAaI,WAAW/gB,EAAUF,EACpC,CACA,MAAMkhB,EAAYxd,EAAMyd,UACxB,GAAID,GAAaA,EAAUC,UAAW,CACpC,MAAMC,GAAc9H,GAAyBmB,GAAcqG,WACzDpd,EAAMqd,YACN,QAEFK,EAAWC,aAAaH,GACxBE,EAAWE,SAASphB,EAAUF,EAChC,CACF,CAYO,SAASoa,EACd/C,EACArX,EACA0D,EACAsW,EACAuH,EACA9W,EACA6O,GAEA,IAAIoB,GAAU,EACd,MAAM8G,EAAa9d,EAAMuE,WACzB,GAAIuZ,EAAY,CACd,MAAMja,EAAaia,EAAWC,gBAC1Bla,GAAc,IAAWJ,QAAUI,GAAc,IAAWH,MAC9Doa,EAAWE,oBAAoBH,IAE3Bha,GAAc,IAAWG,MAC3B8Z,EAAW7Z,OAEb6Z,EAAWG,kBAAkBJ,GAC7B7G,GAAU,EAEd,CAUA,OATAkH,EACEvK,EACArX,EACA0D,EACAsW,EACAvP,EACA6O,GAGKoB,CACT,CAUA,SAASkH,EACPvK,EACArX,EACA0D,EACAsW,EACAvP,EACA6O,GAEA,MAAMpZ,EAAWwD,EAAMme,qBAANne,CAA4B1D,GAC7C,IAAKE,EACH,OAEF,MAAM4hB,EAAqB5hB,EAAS6hB,oBAClC/H,EACAvP,GAEIuX,EAAWte,EAAMlC,cACvB,GAAIwgB,EACFC,EAAe5K,EAAayK,EAAoBpe,EAAO1D,OAClD,CACL,MAAMkiB,EAAmBzC,EAAmBqC,EAAmBK,WAC/DD,EACE7K,EACAyK,EACApe,EACA1D,EACAsZ,EAEJ,CACF,CAQA,SAAS2I,EAAe5K,EAAanX,EAAUwD,EAAO1D,GACpD,GAA0B,sBAAtBE,EAASiiB,UAAmC,CAC9C,MAAMC,EAC2D,EAE7DC,gBACJ,IAAK,IAAIlhB,EAAI,EAAG8D,EAAKmd,EAAWphB,OAAQG,EAAI8D,IAAM9D,EAChD8gB,EAAe5K,EAAa+K,EAAWjhB,GAAIuC,EAAO1D,GAEpD,MACF,CACA,MAAMsiB,EAASjL,EAAYyJ,WAAWpd,EAAMqd,YAAa,WACzDuB,EAAOC,WACsD,EAC3DviB,EACA0D,EAAMlC,cACNkC,EAAM8e,0BAEV,CASA,SAASxC,EACP3I,EACAnX,EACAwD,EACA1D,EACAsZ,GAEA,MAAM8I,EAAaliB,EAASuiB,qBAC5B,IAAIthB,EAAG8D,EACP,IAAK9D,EAAI,EAAG8D,EAAKmd,EAAWphB,OAAQG,EAAI8D,IAAM9D,EAAG,CAC/C,MAAM+gB,EAAmBzC,EAAmB2C,EAAWjhB,GAAGghB,WAC1DD,EACE7K,EACA+K,EAAWjhB,GACXuC,EACA1D,EACAsZ,EAEJ,CACF,CASA,SAASqG,EACPlF,EACAva,EACAwD,EACA1D,EACAsZ,GAEA,MAAMqH,EAAcjd,EAAMkd,YAC1B,GAAID,EAAa,CACf,MAAM+B,EAAmBjI,EAAaqG,WACpCpd,EAAMqd,YACN,cAEF2B,EAAiB1B,mBAAmB,KAAML,GAC1C+B,EAAiBC,eAAeziB,EAAUF,EAC5C,CACA,MAAMkhB,EAAYxd,EAAMyd,UACxB,GAAID,GAAaA,EAAUC,UAAW,CACpC,MAAMC,GAAc9H,GAAyBmB,GAAcqG,WACzDpd,EAAMqd,YACN,QAEFK,EAAWC,aAAaH,GACxBE,EAAWE,SAASphB,EAAUF,EAChC,CACF,CASA,SAAS8f,EACPrF,EACAva,EACAwD,EACA1D,EACAsZ,GAEA,MAAMqH,EAAcjd,EAAMkd,YAC1B,GAAID,EAAa,CACf,MAAM+B,EAAmBjI,EAAaqG,WACpCpd,EAAMqd,YACN,cAEF2B,EAAiB1B,mBAAmB,KAAML,GAC1C+B,EAAiBE,oBAAoB1iB,EAAUF,EACjD,CACA,MAAMkhB,EAAYxd,EAAMyd,UACxB,GAAID,GAAaA,EAAUC,UAAW,CACpC,MAAMC,GAAc9H,GAAyBmB,GAAcqG,WACzDpd,EAAMqd,YACN,QAEFK,EAAWC,aAAaH,GACxBE,EAAWE,SAASphB,EAAUF,EAChC,CACF,CASA,SAAS+f,EACPtF,EACAva,EACAwD,EACA1D,EACAsZ,GAEA,MAAMmH,EAAY/c,EAAMgd,UAClBC,EAAcjd,EAAMkd,YAC1B,GAAID,GAAeF,EAAW,CAC5B,MAAMoC,EAAgBpI,EAAaqG,WAAWpd,EAAMqd,YAAa,WACjE8B,EAAc7B,mBAAmBP,EAAWE,GAC5CkC,EAAcC,iBAAiB5iB,EAAUF,EAC3C,CACA,MAAMkhB,EAAYxd,EAAMyd,UACxB,GAAID,GAAaA,EAAUC,UAAW,CACpC,MAAMC,GAAc9H,GAAyBmB,GAAcqG,WACzDpd,EAAMqd,YACN,QAEFK,EAAWC,aAAaH,GACxBE,EAAWE,SAASphB,EAAUF,EAChC,CACF,CASA,SAAS0f,EACPjF,EACAva,EACAwD,EACA1D,EACAsZ,GAEA,MAAMkI,EAAa9d,EAAMuE,WACnBiZ,EAAYxd,EAAMyd,UAExB,IAAI4B,EACJ,GAAIvB,EAAY,CACd,GAAIA,EAAWC,iBAAmB,IAAWta,OAC3C,OAEF,IAAI6b,EAAoBvI,EACxB,GAAInB,EAAuB,CACzB,MAAM2J,EAAgBzB,EAAW0B,mBACjC,GAAsB,SAAlBD,EAEF,GADAD,EAAoB1J,EACE,aAAlB2J,EAA8B,CAEhC,MAAME,EAAc1I,EAAaqG,WAC/Bpd,EAAMqd,YACN,SAEFoC,EAAYC,cAAc5B,EAAYuB,GACtCI,EAAYE,UAAUnjB,EAAUF,EAClC,MAAWkhB,GAAaA,EAAUC,YAChC4B,EAAyB,CAAC,EAGhC,CACA,MAAMI,EAAcH,EAAkBlC,WACpCpd,EAAMqd,YACN,SAEFoC,EAAYC,cAAc5B,EAAYuB,GACtCI,EAAYE,UAAUnjB,EAAUF,EAClC,CACA,GAAIkhB,GAAaA,EAAUC,UAAW,CACpC,IAAImC,EAAmB7I,EACnBnB,IACFgK,EAAmBhK,GAErB,MAAM8H,EAAakC,EAAiBxC,WAAWpd,EAAMqd,YAAa,QAClEK,EAAWC,aAAaH,EAAW6B,GACnC3B,EAAWE,SAASphB,EAAUF,EAChC,CACF,CASA,SAAS6f,EACPpF,EACAva,EACAwD,EACA1D,EACAsZ,GAEA,MAAMkI,EAAa9d,EAAMuE,WACnBiZ,EAAYxd,EAAMyd,UAExB,IAAI4B,EACJ,GAAIvB,EAAY,CACd,GAAIA,EAAWC,iBAAmB,IAAWta,OAC3C,OAEF,IAAI6b,EAAoBvI,EACxB,GAAInB,EAAuB,CACzB,MAAM2J,EAAgBzB,EAAW0B,mBACjC,GAAsB,SAAlBD,EAEF,GADAD,EAAoB1J,EACE,aAAlB2J,EAA8B,CAEhC,MAAME,EAAc1I,EAAaqG,WAC/Bpd,EAAMqd,YACN,SAEFoC,EAAYC,cAAc5B,EAAYuB,GACtCI,EAAYI,eAAerjB,EAAUF,EACvC,MAAWkhB,GAAaA,EAAUC,YAChC4B,EAAyB,CAAC,EAGhC,CACA,MAAMI,EAAcH,EAAkBlC,WACpCpd,EAAMqd,YACN,SAEFoC,EAAYC,cAAc5B,EAAYuB,GACtCI,EAAYI,eAAerjB,EAAUF,EACvC,CACA,GAAIkhB,GAAaA,EAAUC,UAAW,CACpC,IAAImC,EAAmB7I,EACnBnB,IACFgK,EAAmBhK,GAErB,MAAM8H,EAAakC,EAAiBxC,WAAWpd,EAAMqd,YAAa,QAClEK,EAAWC,aAAaH,EAAW6B,GACnC3B,EAAWE,SAASphB,EAAUF,EAChC,CACF,CASA,SAAS4f,EACPnF,EACAva,EACAwD,EACA1D,EACAsZ,GAEA,MAAMmH,EAAY/c,EAAMgd,UAClBC,EAAcjd,EAAMkd,YAC1B,GAAIH,GAAaE,EAAa,CAC5B,MAAMkC,EAAgBpI,EAAaqG,WAAWpd,EAAMqd,YAAa,WACjE8B,EAAc7B,mBAAmBP,EAAWE,GAC5CkC,EAAcW,YAAYtjB,EAAUF,EACtC,CACA,MAAMkhB,EAAYxd,EAAMyd,UACxB,GAAID,GAAaA,EAAUC,UAAW,CACpC,MAAMC,GAAc9H,GAAyBmB,GAAcqG,WACzDpd,EAAMqd,YACN,QAEFK,EAAWC,aAAaH,GACxBE,EAAWE,SAASphB,EAAUF,EAChC,CACF,C,wGChcA,MAAMyjB,UAA2B,IAK/B,WAAAnlB,CAAY2B,EAAOyjB,GACjBllB,MAAMyB,GAENyjB,EAAUA,GAAW,CAAC,EAQtBjlB,KAAKklB,wBAAyB,UAM9BllB,KAAKqN,cAAgB,KAKrBrN,KAAKmlB,eAAiBF,EAAQG,cAK9BplB,KAAKqlB,UAAYJ,EAAQK,SAMzBtlB,KAAKulB,OAEL/jB,EAAMgkB,kBAAkB,IAAcC,IAAKzlB,KAAK0lB,aAAatiB,KAAKpD,OAElEA,KAAK2lB,wBAA0B3lB,KAAK2lB,wBAAwBviB,KAAKpD,MACjEA,KAAK4lB,yBAA2B5lB,KAAK4lB,yBAAyBxiB,KAAKpD,KACrE,CAOA,uBAAA2lB,CAAwBja,EAAStL,GAC/B,MAAMoB,EAAQxB,KAAKsI,WACnB,GAAI9G,EAAMsE,YAAY,IAAgBO,YAAa,CACjD,MAAMN,EAAQ,IAAI,IAChB,IAAgBM,gBAChBtC,EACA3D,EACAsL,GAEFlK,EAAMwE,cAAcD,EACtB,CACF,CAOA,wBAAA6f,CAAyBla,EAAStL,GAChC,MAAMoB,EAAQxB,KAAKsI,WACnB,GAAI9G,EAAMsE,YAAY,IAAgBiB,aAAc,CAClD,MAAMhB,EAAQ,IAAI,IAChB,IAAgBgB,iBAChBhD,EACA3D,EACAsL,GAEFlK,EAAMwE,cAAcD,EACtB,CACF,CAMA,KAAA8f,CAAMZ,GACJjlB,KAAKqlB,UAAYJ,EAAQK,SACrBtlB,KAAKulB,QACPvlB,KAAKulB,OAAOO,YAAY9lB,KAAKqlB,UAEjC,CAKA,YAAAK,GACM1lB,KAAKulB,SACPvlB,KAAKulB,OAAOQ,iBACL/lB,KAAKulB,OAEhB,CAOA,YAAA5d,CAAavH,GACX,GAAIJ,KAAKsI,WAAWuI,kBAAmB,CACrC,IAEIvL,EAFA0gB,GAAiB,EACjBC,GAAe,EAEnB,IAAK,IAAIvjB,EAAI,EAAG8D,EAAKpG,EAAWiC,iBAAiBE,OAAQG,EAAI8D,EAAI9D,IAAK,CACpE,MAAMlB,EAAQpB,EAAWiC,iBAAiBK,GAAGlB,MACvC+hB,EAAW/hB,EAAMuB,cACvB,KAAMwgB,aAAoByB,GAAqB,CAC7CgB,GAAiB,EACjB,QACF,CACA,MAAMtY,EAAiBlM,EAAMmM,eAM7B,IALIqY,GAAkBtY,IAAmBpI,KACvC2gB,GAAe,EACfD,GAAiB,GAEnB1gB,EAAYoI,EACR6V,IAAavjB,KACf,KAEJ,CAEA,MAAMkmB,EACJ,OAAS9lB,EAAW+lB,MAAQ,UAAYF,EAErCjmB,KAAKulB,QAAWvlB,KAAKulB,OAAOa,sBAAsBF,KACrDlmB,KAAK0lB,eAEL1lB,KAAKulB,OAAS,IAAI,KAAY,CAC5BH,cAAeplB,KAAKmlB,eACpBG,SAAUtlB,KAAKqlB,UACfa,eAAgBA,IAGd5gB,IACFtF,KAAKulB,OAAOc,YAAY/gB,UAAYA,GAGtCtF,KAAKsmB,qBAET,CAEA,OAAOtmB,KAAKumB,qBAAqBnmB,EACnC,CAKA,kBAAAkmB,GAAsB,CAQtB,oBAAAC,CAAqBnmB,GACnB,OAAO,CACT,CAKA,eAAA6F,GACEjG,KAAK0lB,eACL3lB,MAAMkG,iBACR,CAQA,oBAAA2I,CAAqBzO,EAAMuL,EAAStL,GAClC,MAAMoB,EAAQxB,KAAKsI,WACnB,GAAI9G,EAAMsE,YAAY3F,GAAO,EAC3B,QACEH,KAAKklB,uBACL,EACA,EACA9kB,EAAWqJ,YACVrJ,EAAWqJ,WACZ,EACA,GACCrJ,EAAWK,KAAK,IAGnB,MAAMsF,EAAQ,IAAI,IAChB5F,EACAH,KAAKklB,uBACL9kB,EACAsL,GAEFlK,EAAMwE,cAAcD,EACtB,CACF,CAOA,SAAAwG,CAAUb,EAAStL,GACjBJ,KAAK4O,qBAAqB,IAAgBC,UAAWnD,EAAStL,EAChE,CAOA,UAAA0M,CAAWpB,EAAStL,GAClBJ,KAAK4O,qBAAqB,IAAgBE,WAAYpD,EAAStL,EACjE,EAGF,S,+HC9PO,MAAMomB,EAAyB,CACpCC,yBAA0B,2BAC1BC,uBAAwB,yBACxBC,6BAA8B,gC,4CC0TzB,SAASC,EAAcC,EAAIC,GAChCA,EAAQA,GAAS,GACjB,MAAMC,EAAQ,IACRC,EAASD,EAAQ,EAKvB,OAJAD,EAAM,GAAKrc,KAAKC,MAAMmc,EAAKE,EAAQA,EAAQA,GAASC,EACpDF,EAAM,GAAMrc,KAAKC,MAAMmc,EAAKE,EAAQA,GAASA,EAASC,EACtDF,EAAM,GAAMrc,KAAKC,MAAMmc,EAAKE,GAASA,EAASC,EAC9CF,EAAM,GAAMD,EAAKE,EAASC,EACnBF,CACT,CAQO,SAASG,EAAcC,GAC5B,IAAIL,EAAK,EACT,MAAME,EAAQ,IACRI,EAAOJ,EAAQ,EAKrB,OAJAF,GAAMpc,KAAKW,MAAM8b,EAAM,GAAKH,EAAQA,EAAQA,EAAQI,GACpDN,GAAMpc,KAAKW,MAAM8b,EAAM,GAAKH,EAAQA,EAAQI,GAC5CN,GAAMpc,KAAKW,MAAM8b,EAAM,GAAKH,EAAQI,GACpCN,GAAMpc,KAAKW,MAAM8b,EAAM,GAAKC,GACrBN,CACT,C,qCCrOA,MAAMO,UAAiC,IAKrC,WAAAvnB,CAAY2B,EAAOyjB,GACjB,MAAMK,EAAWL,EAAQK,UAAY,CAAC,EAChC+B,GAA4B,UAClC/B,EAAS,KAAegC,mBAAqBD,EAE7CtnB,MAAMyB,EAAO,CACX8jB,SAAUA,EACVF,cAAeH,EAAQG,gBAGzBplB,KAAKunB,iBAAmB,EAExBvnB,KAAKwnB,gBAAkB,IAAI,KAAiB,KAAc,MAC1DxnB,KAAKynB,eAAiB,IAAI,KACxB,KACA,MAMFznB,KAAK0nB,cAAgBzC,EAAQ0C,aAK7B3nB,KAAK4nB,gBAAkB3C,EAAQ4C,eAM/B7nB,KAAK8nB,SAML9nB,KAAK+nB,qBAAuB9C,EAAQ+C,sBAAuB,EAE3D,MAAMC,EAAmBhD,EAAQiD,WAC7BjD,EAAQiD,WAAWpoB,KAAI,SAAUqoB,GAC/B,MAAO,CACLC,KAAM,KAAOD,EAAUC,KACvB3nB,KAAM,EACNN,KAAM,KAAckoB,MAExB,IACA,GAOJroB,KAAKkoB,WAAa,CAChB,CACEE,KAAM,aACN3nB,KAAM,EACNN,KAAM,KAAckoB,OAEtB,CACED,KAAM,UACN3nB,KAAM,EACNN,KAAM,KAAckoB,QAIpBroB,KAAK+nB,uBACP/nB,KAAKkoB,WAAW/lB,KAAK,CACnBimB,KAAM,aACN3nB,KAAM,EACNN,KAAM,KAAckoB,QAEtBroB,KAAKkoB,WAAW/lB,KAAK,CACnBimB,KAAM,eACN3nB,KAAM,EACNN,KAAM,KAAckoB,SAGxBroB,KAAKkoB,WAAW/lB,QAAQ8lB,GAExBjoB,KAAKioB,iBAAmBhD,EAAQiD,WAAajD,EAAQiD,WAAa,GAElEloB,KAAKsoB,iBAAkB,UASvBtoB,KAAKuoB,kBAAoBlB,EAOzBrnB,KAAKwoB,kBAAmB,UAMxBxoB,KAAKyoB,wBAAyB,UAM9BzoB,KAAK0oB,oBAAsB,IAAIC,aAAa,GAM5C3oB,KAAK4oB,iBAOL5oB,KAAK6oB,WAAa,EAKlB7oB,KAAK8oB,SAAU,SAEf9oB,KAAK8oB,QAAQ/f,iBACX,WAIChD,IACC,MAAMgjB,EAAWhjB,EAAMuH,KACvB,GAAIyb,EAAS5oB,OAASqmB,EAAuBE,uBAAwB,CACnE,MAAMsC,EAAsBD,EAASC,oBACrChpB,KAAKwnB,gBAAgByB,gBAAgBF,EAASG,cAC9ClpB,KAAKulB,OAAO4D,gBAAgBnpB,KAAKwnB,iBACjCxnB,KAAKynB,eAAewB,gBAAgBF,EAASK,aAC7CppB,KAAKulB,OAAO4D,gBAAgBnpB,KAAKynB,gBAEjCznB,KAAKwoB,iBAAmBQ,GACxB,QACEhpB,KAAKyoB,uBACLzoB,KAAKwoB,kBAEPxoB,KAAK0oB,oBAAsB,IAAIC,aAC7B5iB,EAAMuH,KAAK+b,oBAETN,EAASlC,KAAO7mB,KAAK6oB,aACvB7oB,KAAKmH,OAAQ,GAEfnH,KAAKsI,WAAWc,SAClB,KASJpJ,KAAKspB,cAAgB,CAAC,EAOtBtpB,KAAKupB,cAAgB,EAErB,MAAMvmB,EAAShD,KAAKsI,WAAWrF,YAC/BjD,KAAKwpB,kBAAoB,EACvB,QACExmB,EACAymB,EAAA,EAAgBC,WAChB1pB,KAAK2pB,0BACL3pB,OAEF,QACEgD,EACAymB,EAAA,EAAgBG,cAChB5pB,KAAK6pB,4BACL7pB,OAEF,QACEgD,EACAymB,EAAA,EAAgBK,cAChB9pB,KAAK+pB,2BACL/pB,OAEF,QACEgD,EACAymB,EAAA,EAAgBO,MAChBhqB,KAAKiqB,0BACLjqB,OAGJgD,EAAOknB,gBAAgB3oB,IACrBvB,KAAKspB,eAAc,QAAO/nB,IAAY,CACpCA,QAASA,EACT4oB,WAAY5oB,EAAQ6oB,gBACpB3oB,SAAUF,EAAQsd,eAEpB7e,KAAKupB,eAAe,GAExB,CAEA,kBAAAjD,GACEtmB,KAAK8nB,SAAW9nB,KAAKulB,OAAO8E,WAC1BrqB,KAAK4nB,gBACL5nB,KAAK0nB,eAGH1nB,KAAK+nB,uBACP/nB,KAAK4oB,iBAAmB,IAAI,IAAkB5oB,KAAKulB,QAEvD,CAMA,yBAAAoE,CAA0B5jB,GACxB,MAAMxE,EAAUwE,EAAMxE,QACtBvB,KAAKspB,eAAc,QAAO/nB,IAAY,CACpCA,QAASA,EACT4oB,WAAY5oB,EAAQ6oB,gBACpB3oB,SAAUF,EAAQsd,eAEpB7e,KAAKupB,eACP,CAMA,2BAAAM,CAA4B9jB,GAC1B,MAAMxE,EAAUwE,EAAMxE,QACtBvB,KAAKspB,eAAc,QAAO/nB,IAAY,CACpCA,QAASA,EACT4oB,WAAY5oB,EAAQ6oB,gBACpB3oB,SAAUF,EAAQsd,cAEtB,CAMA,0BAAAkL,CAA2BhkB,GACzB,MAAMxE,EAAUwE,EAAMxE,eACfvB,KAAKspB,eAAc,QAAO/nB,IACjCvB,KAAKupB,eACP,CAKA,yBAAAU,GACEjqB,KAAKspB,cAAgB,CAAC,EACtBtpB,KAAKupB,cAAgB,CACvB,CAOA,WAAAtlB,CAAY7D,GACV,MAAMkqB,EAAKtqB,KAAKulB,OAAOgF,QACvBvqB,KAAKuM,UAAU+d,EAAIlqB,GAEnB,MAAOoqB,EAAYnS,EAAUnW,GAC3BlC,KAAKyqB,oBAAoBrqB,GAG3BJ,KAAK+X,aAAa3X,GAAY,EAAOoqB,EAAYnS,EAAUnW,GAE3DlC,KAAKulB,OAAOmF,aACVtqB,EACAJ,KAAK2lB,wBACL3lB,KAAK4lB,0BAEP,MAAMja,EAAS3L,KAAKulB,OAAOc,YAS3B,OAPIrmB,KAAK+nB,uBACP/nB,KAAK+X,aAAa3X,GAAY,EAAMoqB,EAAYnS,EAAUnW,GAC1DlC,KAAK4oB,iBAAiB+B,mBAGxB3qB,KAAK8M,WAAWwd,EAAIlqB,GAEbuL,CACT,CAQA,mBAAA8e,CAAoBrqB,GAClB,MAAMuB,EAAavB,EAAWE,UAAUqB,WAClCH,EAAQxB,KAAKsI,WACb4P,EAAe1W,EAAMyB,YAErBmV,EAAaF,EAAa/U,YAAcxB,EAAWI,WACnDC,EAAmBL,EAAWM,YAE9B8H,EAAS3J,EAAW2J,OACpB7H,EAAakW,GAAa,QAASpW,GAAoB,KACvDqW,EAAWD,EACb3N,KAAK6N,MAAMvO,EAAO,GAAK/H,EAAiB,IAAME,GAAc,EAC5D,EAEEsoB,EAAapS,EACf3N,KAAKC,OAAOX,EAAO,GAAK/H,EAAiB,IAAME,GAC/C,EAEJ,MAAO,CAACsoB,EAAYnS,EAAUnW,EAChC,CAOA,oBAAAqkB,CAAqBnmB,GACnB,MAAMoB,EAAQxB,KAAKsI,WACb4P,EAAe1W,EAAMyB,YACrB3C,EAAYF,EAAWE,UACvBsqB,GACHxqB,EAAWyJ,UAAUghB,EAAA,EAAS5gB,aAC9B7J,EAAWyJ,UAAUghB,EAAA,EAAS3gB,aAC3BuF,IAAiB,QAAOzP,KAAKsoB,gBAAiBloB,EAAW2J,QACzD+gB,EAAgB9qB,KAAKunB,gBAAkBrP,EAAarG,cAM1D,GAJIiZ,IACF9qB,KAAKunB,gBAAkBrP,EAAarG,eAGlC+Y,IAAkBnb,GAAiBqb,GAAgB,CACrD,MAAMnpB,EAAarB,EAAUqB,WACvBjB,EAAaJ,EAAUI,WAEvBqqB,EACJvpB,aAAiBwpB,EAAA,EAAaxpB,EAAM+Y,kBAAoB,EACpDxQ,GAAS,QAAO3J,EAAW2J,OAAQghB,EAAerqB,GACxDwX,EAAakD,aAAarR,EAAQrJ,EAAYiB,GAE9C3B,KAAKirB,gBAAgB7qB,GACrBJ,KAAKsoB,gBAAkBloB,EAAW2J,OAAOlI,OAC3C,CAUA,OARA7B,KAAKulB,OAAO2F,WAAWlrB,KAAK8nB,SAAU1nB,GACtCJ,KAAKulB,OAAO4F,YAAY/qB,GAGxBJ,KAAKulB,OAAO6F,WAAWprB,KAAKwnB,iBAC5BxnB,KAAKulB,OAAO6F,WAAWprB,KAAKynB,gBAC5BznB,KAAKulB,OAAO8F,iBAAiBrrB,KAAKkoB,aAE3B,CACT,CAOA,eAAA+C,CAAgB7qB,GAEd,MAAM4oB,GAAsB,UAC5BhpB,KAAKulB,OAAO+F,wBAAwBlrB,EAAY4oB,GAEhD,MAAMuC,EAAwBvrB,KAAK+nB,qBAAuB,EAAI,EACxDyD,EACJD,EAAwBvrB,KAAKioB,iBAAiB1lB,OAC1CkpB,EAAYD,EAA0BxrB,KAAKupB,cASjD,IAAImC,EAAcjqB,EAPfzB,KAAK0oB,qBACN1oB,KAAK0oB,oBAAoBnmB,SAAWkpB,IAEpCzrB,KAAK0oB,oBAAsB,IAAIC,aAAa8C,IAK9C,MAAME,EAAY,GACZC,EAAW,GACjB,IAAIC,GAAO,EACX,IAAK,MAAMC,KAAc9rB,KAAKspB,cAK5B,GAJAoC,EAAe1rB,KAAKspB,cAAcwC,GAClCrqB,EACEiqB,EACF,SACKjqB,GAAmC,UAAvBA,EAASiiB,UAA1B,CAYA,GATAiI,EAAU,GAAKlqB,EAASsqB,qBAAqB,GAC7CJ,EAAU,GAAKlqB,EAASsqB,qBAAqB,IAC7C,QAAe/C,EAAqB2C,GAEpC3rB,KAAK0oB,sBAAsBmD,GAAOF,EAAU,GAC5C3rB,KAAK0oB,sBAAsBmD,GAAOF,EAAU,GAIxC3rB,KAAK+nB,qBAAsB,CAC7B,MAAMiE,EAAWpF,EAAciF,EAAM,EAAGD,GACxC5rB,KAAK0oB,sBAAsBmD,GAAOG,EAAS,GAC3ChsB,KAAK0oB,sBAAsBmD,GAAOG,EAAS,GAC3ChsB,KAAK0oB,sBAAsBmD,GAAOG,EAAS,GAC3ChsB,KAAK0oB,sBAAsBmD,GAAOG,EAAS,GAC3ChsB,KAAK0oB,sBAAsBmD,GAAOlY,OAAOmY,EAC3C,CAGA,IAAK,IAAInpB,EAAI,EAAGA,EAAI3C,KAAKioB,iBAAiB1lB,OAAQI,IAAK,CACrD,MAAMkX,EAAQ7Z,KAAKioB,iBAAiBtlB,GAAG1B,SACrCyqB,EAAanqB,QACbmqB,EAAavB,YAEfnqB,KAAK0oB,sBAAsBmD,GAAOhS,CACpC,CA1BA,CA8BF,MAAMoS,EAAU,CACdpF,KAAM7mB,KAAK6oB,WACX1oB,KAAMqmB,EAAuBE,uBAC7B2C,mBAAoBrpB,KAAK0oB,oBAAoBwD,OAC7CC,qBAAsBX,EAA0B,GAGlDS,EAAQ,uBAAyBjD,EACjChpB,KAAKmH,OAAQ,EACbnH,KAAK8oB,QAAQsD,YAAYH,EAAS,CAACjsB,KAAK0oB,oBAAoBwD,SAC5DlsB,KAAK0oB,oBAAsB,IAC7B,CAWA,0BAAA7nB,CACEC,EACAV,EACAW,EACAE,EACAuB,GAGA,IADA,OAAOxC,KAAK+nB,qBAAsB,KAC7B/nB,KAAK0oB,sBAAwB1oB,KAAK+nB,qBACrC,OAGF,MAAMtgB,GAAQ,QACZrH,EAAWG,2BACXO,EAAWe,SAGPyL,EAAOtN,KAAK4oB,iBAAiByD,UAAU5kB,EAAM,GAAK,EAAGA,EAAM,GAAK,GAChEyf,EAAQ,CAAC5Z,EAAK,GAAK,IAAKA,EAAK,GAAK,IAAKA,EAAK,GAAK,IAAKA,EAAK,GAAK,KAChEgf,EAAQrF,EAAcC,GACtBxa,EAAU1M,KAAK0oB,oBAAoB4D,GACnC5Z,EAAMjI,KAAKC,MAAMgC,GAASxE,WAE1BlF,EAAShD,KAAKsI,WAAWrF,YACzB1B,EAAUyB,EAAOupB,gBAAgB7Z,GACvC,OAAInR,EACKN,EAASM,EAASvB,KAAKsI,WAAY,WAD5C,CAIF,CAUA,YAAAyP,CAAa3X,EAAYosB,EAAiBhC,EAAYnS,EAAUnW,GAC9D,IAAIqW,EAAQiS,EAEZxqB,KAAKulB,OAAO2F,WAAWlrB,KAAK8nB,SAAU1nB,GAElCosB,IACFxsB,KAAK4oB,iBAAiB6D,QAAQ,CAC5BhiB,KAAKC,MAAMtK,EAAWK,KAAK,GAAK,GAChCgK,KAAKC,MAAMtK,EAAWK,KAAK,GAAK,KAElCT,KAAKulB,OAAOmH,0BACVtsB,EACAJ,KAAK4oB,kBACL,IAIJ5oB,KAAKulB,OAAO6F,WAAWprB,KAAKwnB,iBAC5BxnB,KAAKulB,OAAO6F,WAAWprB,KAAKynB,gBAC5BznB,KAAKulB,OAAO8F,iBAAiBrrB,KAAKkoB,YAElC,EAAG,CACDloB,KAAKulB,OAAO+F,wBAAwBlrB,EAAYJ,KAAKuoB,oBACrD,QAAmBvoB,KAAKuoB,kBAAmBhQ,EAAQrW,EAAY,IAC/D,QAAkBlC,KAAKuoB,kBAAmBvoB,KAAKyoB,wBAC/CzoB,KAAKulB,OAAOoH,cAAcvsB,GAC1BJ,KAAKulB,OAAOqH,yBAAyBJ,GACrC,MAAMK,EAAc7sB,KAAKynB,eAAeqF,UACxC9sB,KAAKulB,OAAOwH,aAAa,EAAGF,EAC9B,SAAWtU,EAAQF,EACrB,CAKA,eAAApS,GACEjG,KAAK8oB,QAAQkE,YACbhtB,KAAKsH,OAAS,KACdtH,KAAKwpB,kBAAkBlmB,SAAQ,SAAUgW,IACvC,QAAcA,EAChB,IACAtZ,KAAKwpB,kBAAoB,KACzBzpB,MAAMkG,iBACR,EAGF,S","sources":["webpack://@openeo/web-editor/./node_modules/ol/renderer/Map.js","webpack://@openeo/web-editor/./node_modules/ol/renderer/Composite.js","webpack://@openeo/web-editor/./node_modules/ol/renderer/Layer.js","webpack://@openeo/web-editor/./node_modules/ol/renderer/canvas/ImageLayer.js","webpack://@openeo/web-editor/./node_modules/ol/renderer/canvas/Layer.js","webpack://@openeo/web-editor/./node_modules/ol/renderer/canvas/TileLayer.js","webpack://@openeo/web-editor/./node_modules/ol/renderer/canvas/VectorLayer.js","webpack://@openeo/web-editor/./node_modules/ol/renderer/canvas/VectorTileLayer.js","webpack://@openeo/web-editor/./node_modules/ol/renderer/vector.js","webpack://@openeo/web-editor/./node_modules/ol/renderer/webgl/Layer.js","webpack://@openeo/web-editor/./node_modules/ol/render/webgl/constants.js","webpack://@openeo/web-editor/./node_modules/ol/render/webgl/utils.js","webpack://@openeo/web-editor/./node_modules/ol/renderer/webgl/PointsLayer.js"],"sourcesContent":["/**\n * @module ol/renderer/Map\n */\nimport Disposable from '../Disposable.js';\nimport {TRUE} from '../functions.js';\nimport {abstract} from '../util.js';\nimport {compose as composeTransform, makeInverse} from '../transform.js';\nimport {getWidth} from '../extent.js';\nimport {shared as iconImageCache} from '../style/IconImageCache.js';\nimport {inView} from '../layer/Layer.js';\nimport {wrapX} from '../coordinate.js';\n\n/**\n * @template T\n * @typedef HitMatch\n * @property {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @property {import(\"../layer/Layer.js\").default} layer Layer.\n * @property {import(\"../geom/SimpleGeometry.js\").default} geometry Geometry.\n * @property {number} distanceSq Squared distance.\n * @property {import(\"./vector.js\").FeatureCallback<T>} callback Callback.\n */\n\n/**\n * @abstract\n */\nclass MapRenderer extends Disposable {\n  /**\n   * @param {import(\"../Map.js\").default} map Map.\n   */\n  constructor(map) {\n    super();\n\n    /**\n     * @private\n     * @type {import(\"../Map.js\").default}\n     */\n    this.map_ = map;\n  }\n\n  /**\n   * @abstract\n   * @param {import(\"../render/EventType.js\").default} type Event type.\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   */\n  dispatchRenderEvent(type, frameState) {\n    abstract();\n  }\n\n  /**\n   * @param {import(\"../Map.js\").FrameState} frameState FrameState.\n   * @protected\n   */\n  calculateMatrices2D(frameState) {\n    const viewState = frameState.viewState;\n    const coordinateToPixelTransform = frameState.coordinateToPixelTransform;\n    const pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;\n\n    composeTransform(\n      coordinateToPixelTransform,\n      frameState.size[0] / 2,\n      frameState.size[1] / 2,\n      1 / viewState.resolution,\n      -1 / viewState.resolution,\n      -viewState.rotation,\n      -viewState.center[0],\n      -viewState.center[1]\n    );\n\n    makeInverse(pixelToCoordinateTransform, coordinateToPixelTransform);\n  }\n\n  /**\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../Map.js\").FrameState} frameState FrameState.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {boolean} checkWrapped Check for wrapped geometries.\n   * @param {import(\"./vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {S} thisArg Value to use as `this` when executing `callback`.\n   * @param {function(this: U, import(\"../layer/Layer.js\").default): boolean} layerFilter Layer filter\n   *     function, only layers which are visible and for which this function\n   *     returns `true` will be tested for features.  By default, all visible\n   *     layers will be tested.\n   * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.\n   * @return {T|undefined} Callback result.\n   * @template S,T,U\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    checkWrapped,\n    callback,\n    thisArg,\n    layerFilter,\n    thisArg2\n  ) {\n    let result;\n    const viewState = frameState.viewState;\n\n    /**\n     * @param {boolean} managed Managed layer.\n     * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n     * @param {import(\"../layer/Layer.js\").default} layer Layer.\n     * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n     * @return {T|undefined} Callback result.\n     */\n    function forEachFeatureAtCoordinate(managed, feature, layer, geometry) {\n      return callback.call(thisArg, feature, managed ? layer : null, geometry);\n    }\n\n    const projection = viewState.projection;\n\n    const translatedCoordinate = wrapX(coordinate.slice(), projection);\n    const offsets = [[0, 0]];\n    if (projection.canWrapX() && checkWrapped) {\n      const projectionExtent = projection.getExtent();\n      const worldWidth = getWidth(projectionExtent);\n      offsets.push([-worldWidth, 0], [worldWidth, 0]);\n    }\n\n    const layerStates = frameState.layerStatesArray;\n    const numLayers = layerStates.length;\n\n    const matches = /** @type {Array<HitMatch<T>>} */ ([]);\n    const tmpCoord = [];\n    for (let i = 0; i < offsets.length; i++) {\n      for (let j = numLayers - 1; j >= 0; --j) {\n        const layerState = layerStates[j];\n        const layer = layerState.layer;\n        if (\n          layer.hasRenderer() &&\n          inView(layerState, viewState) &&\n          layerFilter.call(thisArg2, layer)\n        ) {\n          const layerRenderer = layer.getRenderer();\n          const source = layer.getSource();\n          if (layerRenderer && source) {\n            const coordinates = source.getWrapX()\n              ? translatedCoordinate\n              : coordinate;\n            const callback = forEachFeatureAtCoordinate.bind(\n              null,\n              layerState.managed\n            );\n            tmpCoord[0] = coordinates[0] + offsets[i][0];\n            tmpCoord[1] = coordinates[1] + offsets[i][1];\n            result = layerRenderer.forEachFeatureAtCoordinate(\n              tmpCoord,\n              frameState,\n              hitTolerance,\n              callback,\n              matches\n            );\n          }\n          if (result) {\n            return result;\n          }\n        }\n      }\n    }\n    if (matches.length === 0) {\n      return undefined;\n    }\n    const order = 1 / matches.length;\n    matches.forEach((m, i) => (m.distanceSq += i * order));\n    matches.sort((a, b) => a.distanceSq - b.distanceSq);\n    matches.some((m) => {\n      return (result = m.callback(m.feature, m.layer, m.geometry));\n    });\n    return result;\n  }\n\n  /**\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../Map.js\").FrameState} frameState FrameState.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {boolean} checkWrapped Check for wrapped geometries.\n   * @param {function(this: U, import(\"../layer/Layer.js\").default): boolean} layerFilter Layer filter\n   *     function, only layers which are visible and for which this function\n   *     returns `true` will be tested for features.  By default, all visible\n   *     layers will be tested.\n   * @param {U} thisArg Value to use as `this` when executing `layerFilter`.\n   * @return {boolean} Is there a feature at the given coordinate?\n   * @template U\n   */\n  hasFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    checkWrapped,\n    layerFilter,\n    thisArg\n  ) {\n    const hasFeature = this.forEachFeatureAtCoordinate(\n      coordinate,\n      frameState,\n      hitTolerance,\n      checkWrapped,\n      TRUE,\n      this,\n      layerFilter,\n      thisArg\n    );\n\n    return hasFeature !== undefined;\n  }\n\n  /**\n   * @return {import(\"../Map.js\").default} Map.\n   */\n  getMap() {\n    return this.map_;\n  }\n\n  /**\n   * Render.\n   * @abstract\n   * @param {?import(\"../Map.js\").FrameState} frameState Frame state.\n   */\n  renderFrame(frameState) {\n    abstract();\n  }\n\n  /**\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   */\n  flushDeclutterItems(frameState) {}\n\n  /**\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  scheduleExpireIconCache(frameState) {\n    if (iconImageCache.canExpireCache()) {\n      frameState.postRenderFunctions.push(expireIconCache);\n    }\n  }\n}\n\n/**\n * @param {import(\"../Map.js\").default} map Map.\n * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n */\nfunction expireIconCache(map, frameState) {\n  iconImageCache.expire();\n}\n\nexport default MapRenderer;\n","/**\n * @module ol/renderer/Composite\n */\nimport MapRenderer from './Map.js';\nimport ObjectEventType from '../ObjectEventType.js';\nimport RenderEvent from '../render/Event.js';\nimport RenderEventType from '../render/EventType.js';\nimport {CLASS_UNSELECTABLE} from '../css.js';\nimport {checkedFonts} from '../render/canvas.js';\nimport {inView} from '../layer/Layer.js';\nimport {listen, unlistenByKey} from '../events.js';\nimport {replaceChildren} from '../dom.js';\n\n/**\n * @classdesc\n * Canvas map renderer.\n * @api\n */\nclass CompositeMapRenderer extends MapRenderer {\n  /**\n   * @param {import(\"../Map.js\").default} map Map.\n   */\n  constructor(map) {\n    super(map);\n\n    /**\n     * @type {import(\"../events.js\").EventsKey}\n     */\n    this.fontChangeListenerKey_ = listen(\n      checkedFonts,\n      ObjectEventType.PROPERTYCHANGE,\n      map.redrawText.bind(map)\n    );\n\n    /**\n     * @private\n     * @type {HTMLDivElement}\n     */\n    this.element_ = document.createElement('div');\n    const style = this.element_.style;\n    style.position = 'absolute';\n    style.width = '100%';\n    style.height = '100%';\n    style.zIndex = '0';\n\n    this.element_.className = CLASS_UNSELECTABLE + ' ol-layers';\n\n    const container = map.getViewport();\n    container.insertBefore(this.element_, container.firstChild || null);\n\n    /**\n     * @private\n     * @type {Array<HTMLElement>}\n     */\n    this.children_ = [];\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.renderedVisible_ = true;\n\n    /**\n     * @type {Array<import(\"../layer/BaseVector.js\").default>}\n     */\n    this.declutterLayers_ = [];\n  }\n\n  /**\n   * @param {import(\"../render/EventType.js\").default} type Event type.\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   */\n  dispatchRenderEvent(type, frameState) {\n    const map = this.getMap();\n    if (map.hasListener(type)) {\n      const event = new RenderEvent(type, undefined, frameState);\n      map.dispatchEvent(event);\n    }\n  }\n\n  disposeInternal() {\n    unlistenByKey(this.fontChangeListenerKey_);\n    this.element_.parentNode.removeChild(this.element_);\n    super.disposeInternal();\n  }\n\n  /**\n   * Render.\n   * @param {?import(\"../Map.js\").FrameState} frameState Frame state.\n   */\n  renderFrame(frameState) {\n    if (!frameState) {\n      if (this.renderedVisible_) {\n        this.element_.style.display = 'none';\n        this.renderedVisible_ = false;\n      }\n      return;\n    }\n\n    this.calculateMatrices2D(frameState);\n    this.dispatchRenderEvent(RenderEventType.PRECOMPOSE, frameState);\n\n    const layerStatesArray = frameState.layerStatesArray.sort(function (a, b) {\n      return a.zIndex - b.zIndex;\n    });\n    const viewState = frameState.viewState;\n\n    this.children_.length = 0;\n\n    const declutterLayers = this.declutterLayers_;\n    declutterLayers.length = 0;\n\n    let previousElement = null;\n    for (let i = 0, ii = layerStatesArray.length; i < ii; ++i) {\n      const layerState = layerStatesArray[i];\n      frameState.layerIndex = i;\n\n      const layer = layerState.layer;\n      const sourceState = layer.getSourceState();\n      if (\n        !inView(layerState, viewState) ||\n        (sourceState != 'ready' && sourceState != 'undefined')\n      ) {\n        layer.unrender();\n        continue;\n      }\n\n      const element = layer.render(frameState, previousElement);\n      if (!element) {\n        continue;\n      }\n      if (element !== previousElement) {\n        this.children_.push(element);\n        previousElement = element;\n      }\n      if ('getDeclutter' in layer) {\n        declutterLayers.push(\n          /** @type {import(\"../layer/BaseVector.js\").default} */ (layer)\n        );\n      }\n    }\n    this.flushDeclutterItems(frameState);\n\n    replaceChildren(this.element_, this.children_);\n\n    this.dispatchRenderEvent(RenderEventType.POSTCOMPOSE, frameState);\n\n    if (!this.renderedVisible_) {\n      this.element_.style.display = '';\n      this.renderedVisible_ = true;\n    }\n\n    this.scheduleExpireIconCache(frameState);\n  }\n\n  /**\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   */\n  flushDeclutterItems(frameState) {\n    const layers = this.declutterLayers_;\n    for (let i = layers.length - 1; i >= 0; --i) {\n      layers[i].renderDeclutter(frameState);\n    }\n    layers.length = 0;\n  }\n}\n\nexport default CompositeMapRenderer;\n","/**\n * @module ol/renderer/Layer\n */\nimport EventType from '../events/EventType.js';\nimport ImageState from '../ImageState.js';\nimport Observable from '../Observable.js';\nimport {abstract} from '../util.js';\n\n/**\n * @template {import(\"../layer/Layer.js\").default} LayerType\n */\nclass LayerRenderer extends Observable {\n  /**\n   * @param {LayerType} layer Layer.\n   */\n  constructor(layer) {\n    super();\n\n    /**\n     * The renderer is initialized and ready to render.\n     * @type {boolean}\n     */\n    this.ready = true;\n\n    /** @private */\n    this.boundHandleImageChange_ = this.handleImageChange_.bind(this);\n\n    /**\n     * @protected\n     * @type {LayerType}\n     */\n    this.layer_ = layer;\n\n    /**\n     * @type {import(\"../render/canvas/ExecutorGroup\").default}\n     */\n    this.declutterExecutorGroup = null;\n  }\n\n  /**\n   * Asynchronous layer level hit detection.\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../Feature\").FeatureLike>>} Promise that resolves with\n   * an array of features.\n   */\n  getFeatures(pixel) {\n    return abstract();\n  }\n\n  /**\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\n   */\n  getData(pixel) {\n    return null;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @abstract\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    return abstract();\n  }\n\n  /**\n   * Render the layer.\n   * @abstract\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement|null} target Target that may be used to render content to.\n   * @return {HTMLElement|null} The rendered element.\n   */\n  renderFrame(frameState, target) {\n    return abstract();\n  }\n\n  /**\n   * @param {Object<number, Object<string, import(\"../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n   * @param {number} zoom Zoom level.\n   * @param {import(\"../Tile.js\").default} tile Tile.\n   * @return {boolean|void} If `false`, the tile will not be considered loaded.\n   */\n  loadedTileCallback(tiles, zoom, tile) {\n    if (!tiles[zoom]) {\n      tiles[zoom] = {};\n    }\n    tiles[zoom][tile.tileCoord.toString()] = tile;\n    return undefined;\n  }\n\n  /**\n   * Create a function that adds loaded tiles to the tile lookup.\n   * @param {import(\"../source/Tile.js\").default} source Tile source.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection of the tiles.\n   * @param {Object<number, Object<string, import(\"../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n   * @return {function(number, import(\"../TileRange.js\").default):boolean} A function that can be\n   *     called with a zoom level and a tile range to add loaded tiles to the lookup.\n   * @protected\n   */\n  createLoadedTileFinder(source, projection, tiles) {\n    return (\n      /**\n       * @param {number} zoom Zoom level.\n       * @param {import(\"../TileRange.js\").default} tileRange Tile range.\n       * @return {boolean} The tile range is fully loaded.\n       */\n      (zoom, tileRange) => {\n        const callback = this.loadedTileCallback.bind(this, tiles, zoom);\n        return source.forEachLoadedTile(projection, zoom, tileRange, callback);\n      }\n    );\n  }\n  /**\n   * @abstract\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"./vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"./Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches\n  ) {\n    return undefined;\n  }\n\n  /**\n   * @return {LayerType} Layer.\n   */\n  getLayer() {\n    return this.layer_;\n  }\n\n  /**\n   * Perform action necessary to get the layer rendered after new fonts have loaded\n   * @abstract\n   */\n  handleFontsChanged() {}\n\n  /**\n   * Handle changes in image state.\n   * @param {import(\"../events/Event.js\").default} event Image change event.\n   * @private\n   */\n  handleImageChange_(event) {\n    const image = /** @type {import(\"../Image.js\").default} */ (event.target);\n    if (\n      image.getState() === ImageState.LOADED ||\n      image.getState() === ImageState.ERROR\n    ) {\n      this.renderIfReadyAndVisible();\n    }\n  }\n\n  /**\n   * Load the image if not already loaded, and register the image change\n   * listener if needed.\n   * @param {import(\"../ImageBase.js\").default} image Image.\n   * @return {boolean} `true` if the image is already loaded, `false` otherwise.\n   * @protected\n   */\n  loadImage(image) {\n    let imageState = image.getState();\n    if (imageState != ImageState.LOADED && imageState != ImageState.ERROR) {\n      image.addEventListener(EventType.CHANGE, this.boundHandleImageChange_);\n    }\n    if (imageState == ImageState.IDLE) {\n      image.load();\n      imageState = image.getState();\n    }\n    return imageState == ImageState.LOADED;\n  }\n\n  /**\n   * @protected\n   */\n  renderIfReadyAndVisible() {\n    const layer = this.getLayer();\n    if (layer && layer.getVisible() && layer.getSourceState() === 'ready') {\n      layer.changed();\n    }\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    delete this.layer_;\n    super.disposeInternal();\n  }\n}\n\nexport default LayerRenderer;\n","/**\n * @module ol/renderer/canvas/ImageLayer\n */\nimport CanvasLayerRenderer from './Layer.js';\nimport ImageState from '../../ImageState.js';\nimport ViewHint from '../../ViewHint.js';\nimport {\n  apply as applyTransform,\n  compose as composeTransform,\n  makeInverse,\n  toString as toTransformString,\n} from '../../transform.js';\nimport {\n  containsCoordinate,\n  containsExtent,\n  getHeight,\n  getIntersection,\n  getWidth,\n  intersects as intersectsExtent,\n  isEmpty,\n} from '../../extent.js';\nimport {fromUserExtent} from '../../proj.js';\n\n/**\n * @classdesc\n * Canvas renderer for image layers.\n * @api\n */\nclass CanvasImageLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {import(\"../../layer/Image.js\").default} imageLayer Image layer.\n   */\n  constructor(imageLayer) {\n    super(imageLayer);\n\n    /**\n     * @protected\n     * @type {?import(\"../../ImageBase.js\").default}\n     */\n    this.image_ = null;\n  }\n\n  /**\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   */\n  getImage() {\n    return this.image_ ? this.image_.getImage() : null;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const viewResolution = viewState.resolution;\n\n    const imageSource = this.getLayer().getSource();\n\n    const hints = frameState.viewHints;\n\n    let renderedExtent = frameState.extent;\n    if (layerState.extent !== undefined) {\n      renderedExtent = getIntersection(\n        renderedExtent,\n        fromUserExtent(layerState.extent, viewState.projection)\n      );\n    }\n\n    if (\n      !hints[ViewHint.ANIMATING] &&\n      !hints[ViewHint.INTERACTING] &&\n      !isEmpty(renderedExtent)\n    ) {\n      if (imageSource) {\n        const projection = viewState.projection;\n        const image = imageSource.getImage(\n          renderedExtent,\n          viewResolution,\n          pixelRatio,\n          projection\n        );\n        if (image) {\n          if (this.loadImage(image)) {\n            this.image_ = image;\n          } else if (image.getState() === ImageState.EMPTY) {\n            this.image_ = null;\n          }\n        }\n      } else {\n        this.image_ = null;\n      }\n    }\n\n    return !!this.image_;\n  }\n\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray} Data at the pixel location.\n   */\n  getData(pixel) {\n    const frameState = this.frameState;\n    if (!frameState) {\n      return null;\n    }\n\n    const layer = this.getLayer();\n    const coordinate = applyTransform(\n      frameState.pixelToCoordinateTransform,\n      pixel.slice()\n    );\n\n    const layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (!containsCoordinate(layerExtent, coordinate)) {\n        return null;\n      }\n    }\n\n    const imageExtent = this.image_.getExtent();\n    const img = this.getImage();\n\n    const imageMapWidth = getWidth(imageExtent);\n    const col = Math.floor(\n      img.width * ((coordinate[0] - imageExtent[0]) / imageMapWidth)\n    );\n    if (col < 0 || col >= img.width) {\n      return null;\n    }\n\n    const imageMapHeight = getHeight(imageExtent);\n    const row = Math.floor(\n      img.height * ((imageExtent[3] - coordinate[1]) / imageMapHeight)\n    );\n    if (row < 0 || row >= img.height) {\n      return null;\n    }\n\n    return this.getImageData(img, col, row);\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState, target) {\n    const image = this.image_;\n    const imageExtent = image.getExtent();\n    const imageResolution = image.getResolution();\n    const imagePixelRatio = image.getPixelRatio();\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const viewCenter = viewState.center;\n    const viewResolution = viewState.resolution;\n    const scale =\n      (pixelRatio * imageResolution) / (viewResolution * imagePixelRatio);\n\n    const extent = frameState.extent;\n    const resolution = viewState.resolution;\n    const rotation = viewState.rotation;\n    // desired dimensions of the canvas in pixels\n    const width = Math.round((getWidth(extent) / resolution) * pixelRatio);\n    const height = Math.round((getHeight(extent) / resolution) * pixelRatio);\n\n    // set forward and inverse pixel transforms\n    composeTransform(\n      this.pixelTransform,\n      frameState.size[0] / 2,\n      frameState.size[1] / 2,\n      1 / pixelRatio,\n      1 / pixelRatio,\n      rotation,\n      -width / 2,\n      -height / 2\n    );\n    makeInverse(this.inversePixelTransform, this.pixelTransform);\n\n    const canvasTransform = toTransformString(this.pixelTransform);\n\n    this.useContainer(target, canvasTransform, this.getBackground(frameState));\n\n    const context = this.context;\n    const canvas = context.canvas;\n\n    if (canvas.width != width || canvas.height != height) {\n      canvas.width = width;\n      canvas.height = height;\n    } else if (!this.containerReused) {\n      context.clearRect(0, 0, width, height);\n    }\n\n    // clipped rendering if layer extent is set\n    let clipped = false;\n    let render = true;\n    if (layerState.extent) {\n      const layerExtent = fromUserExtent(\n        layerState.extent,\n        viewState.projection\n      );\n      render = intersectsExtent(layerExtent, frameState.extent);\n      clipped = render && !containsExtent(layerExtent, frameState.extent);\n      if (clipped) {\n        this.clipUnrotated(context, frameState, layerExtent);\n      }\n    }\n\n    const img = this.getImage();\n\n    const transform = composeTransform(\n      this.tempTransform,\n      width / 2,\n      height / 2,\n      scale,\n      scale,\n      0,\n      (imagePixelRatio * (imageExtent[0] - viewCenter[0])) / imageResolution,\n      (imagePixelRatio * (viewCenter[1] - imageExtent[3])) / imageResolution\n    );\n\n    this.renderedResolution = (imageResolution * pixelRatio) / imagePixelRatio;\n\n    const dw = img.width * transform[0];\n    const dh = img.height * transform[3];\n\n    if (!this.getLayer().getSource().getInterpolate()) {\n      context.imageSmoothingEnabled = false;\n    }\n\n    this.preRender(context, frameState);\n    if (render && dw >= 0.5 && dh >= 0.5) {\n      const dx = transform[4];\n      const dy = transform[5];\n      const opacity = layerState.opacity;\n      let previousAlpha;\n      if (opacity !== 1) {\n        previousAlpha = context.globalAlpha;\n        context.globalAlpha = opacity;\n      }\n      context.drawImage(img, 0, 0, +img.width, +img.height, dx, dy, dw, dh);\n      if (opacity !== 1) {\n        context.globalAlpha = previousAlpha;\n      }\n    }\n    this.postRender(context, frameState);\n\n    if (clipped) {\n      context.restore();\n    }\n    context.imageSmoothingEnabled = true;\n\n    if (canvasTransform !== canvas.style.transform) {\n      canvas.style.transform = canvasTransform;\n    }\n\n    return this.container;\n  }\n}\n\nexport default CanvasImageLayerRenderer;\n","/**\n * @module ol/renderer/canvas/Layer\n */\nimport LayerRenderer from '../Layer.js';\nimport RenderEvent from '../../render/Event.js';\nimport RenderEventType from '../../render/EventType.js';\nimport {\n  apply as applyTransform,\n  compose as composeTransform,\n  create as createTransform,\n} from '../../transform.js';\nimport {asArray} from '../../color.js';\nimport {createCanvasContext2D} from '../../dom.js';\nimport {equals} from '../../array.js';\nimport {\n  getBottomLeft,\n  getBottomRight,\n  getTopLeft,\n  getTopRight,\n} from '../../extent.js';\n\n/**\n * @type {Array<HTMLCanvasElement>}\n */\nexport const canvasPool = [];\n\n/**\n * @type {CanvasRenderingContext2D}\n */\nlet pixelContext = null;\n\nfunction createPixelContext() {\n  pixelContext = createCanvasContext2D(1, 1, undefined, {\n    willReadFrequently: true,\n  });\n}\n\n/**\n * @abstract\n * @template {import(\"../../layer/Layer.js\").default} LayerType\n * @extends {LayerRenderer<LayerType>}\n */\nclass CanvasLayerRenderer extends LayerRenderer {\n  /**\n   * @param {LayerType} layer Layer.\n   */\n  constructor(layer) {\n    super(layer);\n\n    /**\n     * @protected\n     * @type {HTMLElement}\n     */\n    this.container = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedResolution;\n\n    /**\n     * A temporary transform.  The values in this transform should only be used in a\n     * function that sets the values.\n     * @protected\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.tempTransform = createTransform();\n\n    /**\n     * The transform for rendered pixels to viewport CSS pixels.  This transform must\n     * be set when rendering a frame and may be used by other functions after rendering.\n     * @protected\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.pixelTransform = createTransform();\n\n    /**\n     * The transform for viewport CSS pixels to rendered pixels.  This transform must\n     * be set when rendering a frame and may be used by other functions after rendering.\n     * @protected\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.inversePixelTransform = createTransform();\n\n    /**\n     * @type {CanvasRenderingContext2D}\n     */\n    this.context = null;\n\n    /**\n     * @type {boolean}\n     */\n    this.containerReused = false;\n\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n    this.pixelContext_ = null;\n\n    /**\n     * @protected\n     * @type {import(\"../../Map.js\").FrameState|null}\n     */\n    this.frameState = null;\n  }\n\n  /**\n   * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.\n   * @param {number} col The column index.\n   * @param {number} row The row index.\n   * @return {Uint8ClampedArray|null} The image data.\n   */\n  getImageData(image, col, row) {\n    if (!pixelContext) {\n      createPixelContext();\n    }\n    pixelContext.clearRect(0, 0, 1, 1);\n\n    let data;\n    try {\n      pixelContext.drawImage(image, col, row, 1, 1, 0, 0, 1, 1);\n      data = pixelContext.getImageData(0, 0, 1, 1).data;\n    } catch (err) {\n      pixelContext = null;\n      return null;\n    }\n    return data;\n  }\n\n  /**\n   * @param {import('../../Map.js').FrameState} frameState Frame state.\n   * @return {string} Background color.\n   */\n  getBackground(frameState) {\n    const layer = this.getLayer();\n    let background = layer.getBackground();\n    if (typeof background === 'function') {\n      background = background(frameState.viewState.resolution);\n    }\n    return background || undefined;\n  }\n\n  /**\n   * Get a rendering container from an existing target, if compatible.\n   * @param {HTMLElement} target Potential render target.\n   * @param {string} transform CSS Transform.\n   * @param {string} [backgroundColor] Background color.\n   */\n  useContainer(target, transform, backgroundColor) {\n    const layerClassName = this.getLayer().getClassName();\n    let container, context;\n    if (\n      target &&\n      target.className === layerClassName &&\n      (!backgroundColor ||\n        (target &&\n          target.style.backgroundColor &&\n          equals(\n            asArray(target.style.backgroundColor),\n            asArray(backgroundColor)\n          )))\n    ) {\n      const canvas = target.firstElementChild;\n      if (canvas instanceof HTMLCanvasElement) {\n        context = canvas.getContext('2d');\n      }\n    }\n    if (context && context.canvas.style.transform === transform) {\n      // Container of the previous layer renderer can be used.\n      this.container = target;\n      this.context = context;\n      this.containerReused = true;\n    } else if (this.containerReused) {\n      // Previously reused container cannot be used any more.\n      this.container = null;\n      this.context = null;\n      this.containerReused = false;\n    } else if (this.container) {\n      this.container.style.backgroundColor = null;\n    }\n    if (!this.container) {\n      container = document.createElement('div');\n      container.className = layerClassName;\n      let style = container.style;\n      style.position = 'absolute';\n      style.width = '100%';\n      style.height = '100%';\n      context = createCanvasContext2D();\n      const canvas = context.canvas;\n      container.appendChild(canvas);\n      style = canvas.style;\n      style.position = 'absolute';\n      style.left = '0';\n      style.transformOrigin = 'top left';\n      this.container = container;\n      this.context = context;\n    }\n    if (\n      !this.containerReused &&\n      backgroundColor &&\n      !this.container.style.backgroundColor\n    ) {\n      this.container.style.backgroundColor = backgroundColor;\n    }\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../extent.js\").Extent} extent Clip extent.\n   * @protected\n   */\n  clipUnrotated(context, frameState, extent) {\n    const topLeft = getTopLeft(extent);\n    const topRight = getTopRight(extent);\n    const bottomRight = getBottomRight(extent);\n    const bottomLeft = getBottomLeft(extent);\n\n    applyTransform(frameState.coordinateToPixelTransform, topLeft);\n    applyTransform(frameState.coordinateToPixelTransform, topRight);\n    applyTransform(frameState.coordinateToPixelTransform, bottomRight);\n    applyTransform(frameState.coordinateToPixelTransform, bottomLeft);\n\n    const inverted = this.inversePixelTransform;\n    applyTransform(inverted, topLeft);\n    applyTransform(inverted, topRight);\n    applyTransform(inverted, bottomRight);\n    applyTransform(inverted, bottomLeft);\n\n    context.save();\n    context.beginPath();\n    context.moveTo(Math.round(topLeft[0]), Math.round(topLeft[1]));\n    context.lineTo(Math.round(topRight[0]), Math.round(topRight[1]));\n    context.lineTo(Math.round(bottomRight[0]), Math.round(bottomRight[1]));\n    context.lineTo(Math.round(bottomLeft[0]), Math.round(bottomLeft[1]));\n    context.clip();\n  }\n\n  /**\n   * @param {import(\"../../render/EventType.js\").default} type Event type.\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @private\n   */\n  dispatchRenderEvent_(type, context, frameState) {\n    const layer = this.getLayer();\n    if (layer.hasListener(type)) {\n      const event = new RenderEvent(\n        type,\n        this.inversePixelTransform,\n        frameState,\n        context\n      );\n      layer.dispatchEvent(event);\n    }\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  preRender(context, frameState) {\n    this.frameState = frameState;\n    this.dispatchRenderEvent_(RenderEventType.PRERENDER, context, frameState);\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  postRender(context, frameState) {\n    this.dispatchRenderEvent_(RenderEventType.POSTRENDER, context, frameState);\n  }\n\n  /**\n   * Creates a transform for rendering to an element that will be rotated after rendering.\n   * @param {import(\"../../coordinate.js\").Coordinate} center Center.\n   * @param {number} resolution Resolution.\n   * @param {number} rotation Rotation.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {number} width Width of the rendered element (in pixels).\n   * @param {number} height Height of the rendered element (in pixels).\n   * @param {number} offsetX Offset on the x-axis in view coordinates.\n   * @protected\n   * @return {!import(\"../../transform.js\").Transform} Transform.\n   */\n  getRenderTransform(\n    center,\n    resolution,\n    rotation,\n    pixelRatio,\n    width,\n    height,\n    offsetX\n  ) {\n    const dx1 = width / 2;\n    const dy1 = height / 2;\n    const sx = pixelRatio / resolution;\n    const sy = -sx;\n    const dx2 = -center[0] + offsetX;\n    const dy2 = -center[1];\n    return composeTransform(\n      this.tempTransform,\n      dx1,\n      dy1,\n      sx,\n      sy,\n      -rotation,\n      dx2,\n      dy2\n    );\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    delete this.frameState;\n    super.disposeInternal();\n  }\n}\n\nexport default CanvasLayerRenderer;\n","/**\n * @module ol/renderer/canvas/TileLayer\n */\nimport CanvasLayerRenderer from './Layer.js';\nimport ImageTile from '../../ImageTile.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport {\n  apply as applyTransform,\n  compose as composeTransform,\n  makeInverse,\n  toString as toTransformString,\n} from '../../transform.js';\nimport {ascending} from '../../array.js';\nimport {\n  containsCoordinate,\n  createEmpty,\n  equals,\n  getHeight,\n  getIntersection,\n  getRotatedViewport,\n  getTopLeft,\n  getWidth,\n  intersects,\n} from '../../extent.js';\nimport {fromUserExtent} from '../../proj.js';\nimport {getUid} from '../../util.js';\nimport {toSize} from '../../size.js';\n\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n * @template {import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default} [LayerType=import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default]\n * @extends {CanvasLayerRenderer<LayerType>}\n */\nclass CanvasTileLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   */\n  constructor(tileLayer) {\n    super(tileLayer);\n\n    /**\n     * Rendered extent has changed since the previous `renderFrame()` call\n     * @type {boolean}\n     */\n    this.extentChanged = true;\n\n    /**\n     * @private\n     * @type {?import(\"../../extent.js\").Extent}\n     */\n    this.renderedExtent_ = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedPixelRatio;\n\n    /**\n     * @protected\n     * @type {import(\"../../proj/Projection.js\").default}\n     */\n    this.renderedProjection = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedRevision;\n\n    /**\n     * @protected\n     * @type {!Array<import(\"../../Tile.js\").default>}\n     */\n    this.renderedTiles = [];\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.newTiles_ = false;\n\n    /**\n     * @protected\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.tmpExtent = createEmpty();\n\n    /**\n     * @private\n     * @type {import(\"../../TileRange.js\").default}\n     */\n    this.tmpTileRange_ = new TileRange(0, 0, 0, 0);\n  }\n\n  /**\n   * @protected\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {boolean} Tile is drawable.\n   */\n  isDrawableTile(tile) {\n    const tileLayer = this.getLayer();\n    const tileState = tile.getState();\n    const useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();\n    return (\n      tileState == TileState.LOADED ||\n      tileState == TileState.EMPTY ||\n      (tileState == TileState.ERROR && !useInterimTilesOnError)\n    );\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {!import(\"../../Tile.js\").default} Tile.\n   */\n  getTile(z, x, y, frameState) {\n    const pixelRatio = frameState.pixelRatio;\n    const projection = frameState.viewState.projection;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    let tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n    if (tile.getState() == TileState.ERROR) {\n      if (tileLayer.getUseInterimTilesOnError() && tileLayer.getPreload() > 0) {\n        // Preloaded tiles for lower resolutions might have finished loading.\n        this.newTiles_ = true;\n      }\n    }\n    if (!this.isDrawableTile(tile)) {\n      tile = tile.getInterimTile();\n    }\n    return tile;\n  }\n\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray} Data at the pixel location.\n   */\n  getData(pixel) {\n    const frameState = this.frameState;\n    if (!frameState) {\n      return null;\n    }\n\n    const layer = this.getLayer();\n    const coordinate = applyTransform(\n      frameState.pixelToCoordinateTransform,\n      pixel.slice()\n    );\n\n    const layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (!containsCoordinate(layerExtent, coordinate)) {\n        return null;\n      }\n    }\n\n    const pixelRatio = frameState.pixelRatio;\n    const projection = frameState.viewState.projection;\n    const viewState = frameState.viewState;\n    const source = layer.getRenderSource();\n    const tileGrid = source.getTileGridForProjection(viewState.projection);\n    const tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);\n\n    for (\n      let z = tileGrid.getZForResolution(viewState.resolution);\n      z >= tileGrid.getMinZoom();\n      --z\n    ) {\n      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n      const tile = source.getTile(\n        z,\n        tileCoord[1],\n        tileCoord[2],\n        pixelRatio,\n        projection\n      );\n      if (\n        !(tile instanceof ImageTile || tile instanceof ReprojTile) ||\n        (tile instanceof ReprojTile && tile.getState() === TileState.EMPTY)\n      ) {\n        return null;\n      }\n\n      if (tile.getState() !== TileState.LOADED) {\n        continue;\n      }\n\n      const tileOrigin = tileGrid.getOrigin(z);\n      const tileSize = toSize(tileGrid.getTileSize(z));\n      const tileResolution = tileGrid.getResolution(z);\n\n      const col = Math.floor(\n        tilePixelRatio *\n          ((coordinate[0] - tileOrigin[0]) / tileResolution -\n            tileCoord[1] * tileSize[0])\n      );\n\n      const row = Math.floor(\n        tilePixelRatio *\n          ((tileOrigin[1] - coordinate[1]) / tileResolution -\n            tileCoord[2] * tileSize[1])\n      );\n\n      const gutter = Math.round(\n        tilePixelRatio * source.getGutterForProjection(viewState.projection)\n      );\n\n      return this.getImageData(tile.getImage(), col + gutter, row + gutter);\n    }\n\n    return null;\n  }\n\n  /**\n   * @param {Object<number, Object<string, import(\"../../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n   * @param {number} zoom Zoom level.\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {boolean|void} If `false`, the tile will not be considered loaded.\n   */\n  loadedTileCallback(tiles, zoom, tile) {\n    if (this.isDrawableTile(tile)) {\n      return super.loadedTileCallback(tiles, zoom, tile);\n    }\n    return false;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    return !!this.getLayer().getSource();\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState, target) {\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const viewResolution = viewState.resolution;\n    const viewCenter = viewState.center;\n    const rotation = viewState.rotation;\n    const pixelRatio = frameState.pixelRatio;\n\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const sourceRevision = tileSource.getRevision();\n    const tileGrid = tileSource.getTileGridForProjection(projection);\n    const z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);\n    const tileResolution = tileGrid.getResolution(z);\n\n    let extent = frameState.extent;\n    const resolution = frameState.viewState.resolution;\n    const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n    // desired dimensions of the canvas in pixels\n    const width = Math.round((getWidth(extent) / resolution) * pixelRatio);\n    const height = Math.round((getHeight(extent) / resolution) * pixelRatio);\n\n    const layerExtent =\n      layerState.extent && fromUserExtent(layerState.extent, projection);\n    if (layerExtent) {\n      extent = getIntersection(\n        extent,\n        fromUserExtent(layerState.extent, projection)\n      );\n    }\n\n    const dx = (tileResolution * width) / 2 / tilePixelRatio;\n    const dy = (tileResolution * height) / 2 / tilePixelRatio;\n    const canvasExtent = [\n      viewCenter[0] - dx,\n      viewCenter[1] - dy,\n      viewCenter[0] + dx,\n      viewCenter[1] + dy,\n    ];\n\n    const tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\n\n    /**\n     * @type {Object<number, Object<string, import(\"../../Tile.js\").default>>}\n     */\n    const tilesToDrawByZ = {};\n    tilesToDrawByZ[z] = {};\n\n    const findLoadedTiles = this.createLoadedTileFinder(\n      tileSource,\n      projection,\n      tilesToDrawByZ\n    );\n\n    const tmpExtent = this.tmpExtent;\n    const tmpTileRange = this.tmpTileRange_;\n    this.newTiles_ = false;\n    const viewport = rotation\n      ? getRotatedViewport(\n          viewState.center,\n          resolution,\n          rotation,\n          frameState.size\n        )\n      : undefined;\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        if (\n          rotation &&\n          !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)\n        ) {\n          continue;\n        }\n        const tile = this.getTile(z, x, y, frameState);\n        if (this.isDrawableTile(tile)) {\n          const uid = getUid(this);\n          if (tile.getState() == TileState.LOADED) {\n            tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;\n            let inTransition = tile.inTransition(uid);\n            if (inTransition && layerState.opacity !== 1) {\n              // Skipping transition when layer is not fully opaque avoids visual artifacts.\n              tile.endTransition(uid);\n              inTransition = false;\n            }\n            if (\n              !this.newTiles_ &&\n              (inTransition || !this.renderedTiles.includes(tile))\n            ) {\n              this.newTiles_ = true;\n            }\n          }\n          if (tile.getAlpha(uid, frameState.time) === 1) {\n            // don't look for alt tiles if alpha is 1\n            continue;\n          }\n        }\n\n        const childTileRange = tileGrid.getTileCoordChildTileRange(\n          tile.tileCoord,\n          tmpTileRange,\n          tmpExtent\n        );\n\n        let covered = false;\n        if (childTileRange) {\n          covered = findLoadedTiles(z + 1, childTileRange);\n        }\n        if (!covered) {\n          tileGrid.forEachTileCoordParentTileRange(\n            tile.tileCoord,\n            findLoadedTiles,\n            tmpTileRange,\n            tmpExtent\n          );\n        }\n      }\n    }\n\n    const canvasScale =\n      ((tileResolution / viewResolution) * pixelRatio) / tilePixelRatio;\n\n    // set forward and inverse pixel transforms\n    composeTransform(\n      this.pixelTransform,\n      frameState.size[0] / 2,\n      frameState.size[1] / 2,\n      1 / pixelRatio,\n      1 / pixelRatio,\n      rotation,\n      -width / 2,\n      -height / 2\n    );\n\n    const canvasTransform = toTransformString(this.pixelTransform);\n\n    this.useContainer(target, canvasTransform, this.getBackground(frameState));\n    const context = this.context;\n    const canvas = context.canvas;\n\n    makeInverse(this.inversePixelTransform, this.pixelTransform);\n\n    // set scale transform for calculating tile positions on the canvas\n    composeTransform(\n      this.tempTransform,\n      width / 2,\n      height / 2,\n      canvasScale,\n      canvasScale,\n      0,\n      -width / 2,\n      -height / 2\n    );\n\n    if (canvas.width != width || canvas.height != height) {\n      canvas.width = width;\n      canvas.height = height;\n    } else if (!this.containerReused) {\n      context.clearRect(0, 0, width, height);\n    }\n\n    if (layerExtent) {\n      this.clipUnrotated(context, frameState, layerExtent);\n    }\n\n    if (!tileSource.getInterpolate()) {\n      context.imageSmoothingEnabled = false;\n    }\n\n    this.preRender(context, frameState);\n\n    this.renderedTiles.length = 0;\n    /** @type {Array<number>} */\n    let zs = Object.keys(tilesToDrawByZ).map(Number);\n    zs.sort(ascending);\n\n    let clips, clipZs, currentClip;\n    if (\n      layerState.opacity === 1 &&\n      (!this.containerReused ||\n        tileSource.getOpaque(frameState.viewState.projection))\n    ) {\n      zs = zs.reverse();\n    } else {\n      clips = [];\n      clipZs = [];\n    }\n    for (let i = zs.length - 1; i >= 0; --i) {\n      const currentZ = zs[i];\n      const currentTilePixelSize = tileSource.getTilePixelSize(\n        currentZ,\n        pixelRatio,\n        projection\n      );\n      const currentResolution = tileGrid.getResolution(currentZ);\n      const currentScale = currentResolution / tileResolution;\n      const dx = currentTilePixelSize[0] * currentScale * canvasScale;\n      const dy = currentTilePixelSize[1] * currentScale * canvasScale;\n      const originTileCoord = tileGrid.getTileCoordForCoordAndZ(\n        getTopLeft(canvasExtent),\n        currentZ\n      );\n      const originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);\n      const origin = applyTransform(this.tempTransform, [\n        (tilePixelRatio * (originTileExtent[0] - canvasExtent[0])) /\n          tileResolution,\n        (tilePixelRatio * (canvasExtent[3] - originTileExtent[3])) /\n          tileResolution,\n      ]);\n      const tileGutter =\n        tilePixelRatio * tileSource.getGutterForProjection(projection);\n      const tilesToDraw = tilesToDrawByZ[currentZ];\n      for (const tileCoordKey in tilesToDraw) {\n        const tile = /** @type {import(\"../../ImageTile.js\").default} */ (\n          tilesToDraw[tileCoordKey]\n        );\n        const tileCoord = tile.tileCoord;\n\n        // Calculate integer positions and sizes so that tiles align\n        const xIndex = originTileCoord[1] - tileCoord[1];\n        const nextX = Math.round(origin[0] - (xIndex - 1) * dx);\n        const yIndex = originTileCoord[2] - tileCoord[2];\n        const nextY = Math.round(origin[1] - (yIndex - 1) * dy);\n        const x = Math.round(origin[0] - xIndex * dx);\n        const y = Math.round(origin[1] - yIndex * dy);\n        const w = nextX - x;\n        const h = nextY - y;\n        const transition = z === currentZ;\n\n        const inTransition =\n          transition && tile.getAlpha(getUid(this), frameState.time) !== 1;\n        let contextSaved = false;\n        if (!inTransition) {\n          if (clips) {\n            // Clip mask for regions in this tile that already filled by a higher z tile\n            currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];\n            for (let i = 0, ii = clips.length; i < ii; ++i) {\n              if (z !== currentZ && currentZ < clipZs[i]) {\n                const clip = clips[i];\n                if (\n                  intersects(\n                    [x, y, x + w, y + h],\n                    [clip[0], clip[3], clip[4], clip[7]]\n                  )\n                ) {\n                  if (!contextSaved) {\n                    context.save();\n                    contextSaved = true;\n                  }\n                  context.beginPath();\n                  // counter-clockwise (outer ring) for current tile\n                  context.moveTo(currentClip[0], currentClip[1]);\n                  context.lineTo(currentClip[2], currentClip[3]);\n                  context.lineTo(currentClip[4], currentClip[5]);\n                  context.lineTo(currentClip[6], currentClip[7]);\n                  // clockwise (inner ring) for higher z tile\n                  context.moveTo(clip[6], clip[7]);\n                  context.lineTo(clip[4], clip[5]);\n                  context.lineTo(clip[2], clip[3]);\n                  context.lineTo(clip[0], clip[1]);\n                  context.clip();\n                }\n              }\n            }\n            clips.push(currentClip);\n            clipZs.push(currentZ);\n          } else {\n            context.clearRect(x, y, w, h);\n          }\n        }\n        this.drawTileImage(\n          tile,\n          frameState,\n          x,\n          y,\n          w,\n          h,\n          tileGutter,\n          transition\n        );\n        if (clips && !inTransition) {\n          if (contextSaved) {\n            context.restore();\n          }\n          this.renderedTiles.unshift(tile);\n        } else {\n          this.renderedTiles.push(tile);\n        }\n        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);\n      }\n    }\n\n    this.renderedRevision = sourceRevision;\n    this.renderedResolution = tileResolution;\n    this.extentChanged =\n      !this.renderedExtent_ || !equals(this.renderedExtent_, canvasExtent);\n    this.renderedExtent_ = canvasExtent;\n    this.renderedPixelRatio = pixelRatio;\n    this.renderedProjection = projection;\n\n    this.manageTilePyramid(\n      frameState,\n      tileSource,\n      tileGrid,\n      pixelRatio,\n      projection,\n      extent,\n      z,\n      tileLayer.getPreload()\n    );\n    this.scheduleExpireCache(frameState, tileSource);\n\n    this.postRender(context, frameState);\n\n    if (layerState.extent) {\n      context.restore();\n    }\n    context.imageSmoothingEnabled = true;\n\n    if (canvasTransform !== canvas.style.transform) {\n      canvas.style.transform = canvasTransform;\n    }\n\n    return this.container;\n  }\n\n  /**\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   */\n  drawTileImage(tile, frameState, x, y, w, h, gutter, transition) {\n    const image = this.getTileImage(tile);\n    if (!image) {\n      return;\n    }\n    const uid = getUid(this);\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const alpha =\n      layerState.opacity *\n      (transition ? tile.getAlpha(uid, frameState.time) : 1);\n    const alphaChanged = alpha !== this.context.globalAlpha;\n    if (alphaChanged) {\n      this.context.save();\n      this.context.globalAlpha = alpha;\n    }\n    this.context.drawImage(\n      image,\n      gutter,\n      gutter,\n      image.width - 2 * gutter,\n      image.height - 2 * gutter,\n      x,\n      y,\n      w,\n      h\n    );\n\n    if (alphaChanged) {\n      this.context.restore();\n    }\n    if (alpha !== layerState.opacity) {\n      frameState.animate = true;\n    } else if (transition) {\n      tile.endTransition(uid);\n    }\n  }\n\n  /**\n   * @return {HTMLCanvasElement} Image\n   */\n  getImage() {\n    const context = this.context;\n    return context ? context.canvas : null;\n  }\n\n  /**\n   * Get the image from a tile.\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @protected\n   */\n  getTileImage(tile) {\n    return tile.getImage();\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @protected\n   */\n  scheduleExpireCache(frameState, tileSource) {\n    if (tileSource.canExpireCache()) {\n      /**\n       * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n       * @param {import(\"../../Map.js\").default} map Map.\n       * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n       */\n      const postRenderFunction = function (tileSource, map, frameState) {\n        const tileSourceKey = getUid(tileSource);\n        if (tileSourceKey in frameState.usedTiles) {\n          tileSource.expireCache(\n            frameState.viewState.projection,\n            frameState.usedTiles[tileSourceKey]\n          );\n        }\n      }.bind(null, tileSource);\n\n      frameState.postRenderFunctions.push(\n        /** @type {import(\"../../Map.js\").PostRenderFunction} */ (\n          postRenderFunction\n        )\n      );\n    }\n  }\n\n  /**\n   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import('../../Tile.js').default} tile Tile.\n   * @protected\n   */\n  updateUsedTiles(usedTiles, tileSource, tile) {\n    // FIXME should we use tilesToDrawByZ instead?\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in usedTiles)) {\n      usedTiles[tileSourceKey] = {};\n    }\n    usedTiles[tileSourceKey][tile.getKey()] = true;\n  }\n\n  /**\n   * Manage tile pyramid.\n   * This function performs a number of functions related to the tiles at the\n   * current zoom and lower zoom levels:\n   * - registers idle tiles in frameState.wantedTiles so that they are not\n   *   discarded by the tile queue\n   * - enqueues missing tiles\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @param {import(\"../../extent.js\").Extent} extent Extent.\n   * @param {number} currentZ Current Z.\n   * @param {number} preload Load low resolution tiles up to `preload` levels.\n   * @param {function(import(\"../../Tile.js\").default):void} [tileCallback] Tile callback.\n   * @protected\n   */\n  manageTilePyramid(\n    frameState,\n    tileSource,\n    tileGrid,\n    pixelRatio,\n    projection,\n    extent,\n    currentZ,\n    preload,\n    tileCallback\n  ) {\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n    const wantedTiles = frameState.wantedTiles[tileSourceKey];\n    const tileQueue = frameState.tileQueue;\n    const minZoom = tileGrid.getMinZoom();\n    const rotation = frameState.viewState.rotation;\n    const viewport = rotation\n      ? getRotatedViewport(\n          frameState.viewState.center,\n          frameState.viewState.resolution,\n          rotation,\n          frameState.size\n        )\n      : undefined;\n    let tileCount = 0;\n    let tile, tileRange, tileResolution, x, y, z;\n    for (z = minZoom; z <= currentZ; ++z) {\n      tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);\n      tileResolution = tileGrid.getResolution(z);\n      for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          if (\n            rotation &&\n            !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)\n          ) {\n            continue;\n          }\n          if (currentZ - z <= preload) {\n            ++tileCount;\n            tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n            if (tile.getState() == TileState.IDLE) {\n              wantedTiles[tile.getKey()] = true;\n              if (!tileQueue.isKeyQueued(tile.getKey())) {\n                tileQueue.enqueue([\n                  tile,\n                  tileSourceKey,\n                  tileGrid.getTileCoordCenter(tile.tileCoord),\n                  tileResolution,\n                ]);\n              }\n            }\n            if (tileCallback !== undefined) {\n              tileCallback(tile);\n            }\n          } else {\n            tileSource.useTile(z, x, y, projection);\n          }\n        }\n      }\n    }\n    tileSource.updateCacheSize(tileCount, projection);\n  }\n}\n\nexport default CanvasTileLayerRenderer;\n","/**\n * @module ol/renderer/canvas/VectorLayer\n */\nimport CanvasBuilderGroup from '../../render/canvas/BuilderGroup.js';\nimport CanvasLayerRenderer, {canvasPool} from './Layer.js';\nimport ExecutorGroup from '../../render/canvas/ExecutorGroup.js';\nimport RenderEventType from '../../render/EventType.js';\nimport ViewHint from '../../ViewHint.js';\nimport {\n  HIT_DETECT_RESOLUTION,\n  createHitDetectionImageData,\n  hitDetect,\n} from '../../render/canvas/hitdetect.js';\nimport {\n  apply,\n  makeInverse,\n  makeScale,\n  toString as transformToString,\n} from '../../transform.js';\nimport {\n  buffer,\n  containsExtent,\n  createEmpty,\n  getWidth,\n  intersects as intersectsExtent,\n  wrapX as wrapExtentX,\n} from '../../extent.js';\nimport {createCanvasContext2D, releaseCanvas} from '../../dom.js';\nimport {\n  defaultOrder as defaultRenderOrder,\n  getTolerance as getRenderTolerance,\n  getSquaredTolerance as getSquaredRenderTolerance,\n  renderFeature,\n} from '../vector.js';\nimport {equals} from '../../array.js';\nimport {\n  fromUserExtent,\n  getTransformFromProjections,\n  getUserProjection,\n  toUserExtent,\n  toUserResolution,\n} from '../../proj.js';\nimport {getUid} from '../../util.js';\nimport {wrapX as wrapCoordinateX} from '../../coordinate.js';\n\n/**\n * @classdesc\n * Canvas renderer for vector layers.\n * @api\n */\nclass CanvasVectorLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {import(\"../../layer/BaseVector.js\").default} vectorLayer Vector layer.\n   */\n  constructor(vectorLayer) {\n    super(vectorLayer);\n\n    /** @private */\n    this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this);\n\n    /**\n     * @type {boolean}\n     */\n    this.animatingOrInteracting_;\n\n    /**\n     * @type {ImageData|null}\n     */\n    this.hitDetectionImageData_ = null;\n\n    /**\n     * @type {Array<import(\"../../Feature.js\").default>}\n     */\n    this.renderedFeatures_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedRevision_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedResolution_ = NaN;\n\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.renderedExtent_ = createEmpty();\n\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.wrappedRenderedExtent_ = createEmpty();\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedRotation_;\n\n    /**\n     * @private\n     * @type {import(\"../../coordinate\").Coordinate}\n     */\n    this.renderedCenter_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../../proj/Projection\").default}\n     */\n    this.renderedProjection_ = null;\n\n    /**\n     * @private\n     * @type {function(import(\"../../Feature.js\").default, import(\"../../Feature.js\").default): number|null}\n     */\n    this.renderedRenderOrder_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../../render/canvas/ExecutorGroup\").default}\n     */\n    this.replayGroup_ = null;\n\n    /**\n     * A new replay group had to be created by `prepareFrame()`\n     * @type {boolean}\n     */\n    this.replayGroupChanged = true;\n\n    /**\n     * @type {import(\"../../render/canvas/ExecutorGroup\").default}\n     */\n    this.declutterExecutorGroup = null;\n\n    /**\n     * Clipping to be performed by `renderFrame()`\n     * @type {boolean}\n     */\n    this.clipping = true;\n\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n    this.compositionContext_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.opacity_ = 1;\n  }\n\n  /**\n   * @param {ExecutorGroup} executorGroup Executor group.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"rbush\").default} [declutterTree] Declutter tree.\n   */\n  renderWorlds(executorGroup, frameState, declutterTree) {\n    const extent = frameState.extent;\n    const viewState = frameState.viewState;\n    const center = viewState.center;\n    const resolution = viewState.resolution;\n    const projection = viewState.projection;\n    const rotation = viewState.rotation;\n    const projectionExtent = projection.getExtent();\n    const vectorSource = this.getLayer().getSource();\n    const pixelRatio = frameState.pixelRatio;\n    const viewHints = frameState.viewHints;\n    const snapToPixel = !(\n      viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]\n    );\n    const context = this.compositionContext_;\n    const width = Math.round(frameState.size[0] * pixelRatio);\n    const height = Math.round(frameState.size[1] * pixelRatio);\n\n    const multiWorld = vectorSource.getWrapX() && projection.canWrapX();\n    const worldWidth = multiWorld ? getWidth(projectionExtent) : null;\n    const endWorld = multiWorld\n      ? Math.ceil((extent[2] - projectionExtent[2]) / worldWidth) + 1\n      : 1;\n    let world = multiWorld\n      ? Math.floor((extent[0] - projectionExtent[0]) / worldWidth)\n      : 0;\n    do {\n      const transform = this.getRenderTransform(\n        center,\n        resolution,\n        rotation,\n        pixelRatio,\n        width,\n        height,\n        world * worldWidth\n      );\n      executorGroup.execute(\n        context,\n        1,\n        transform,\n        rotation,\n        snapToPixel,\n        undefined,\n        declutterTree\n      );\n    } while (++world < endWorld);\n  }\n\n  setupCompositionContext_() {\n    if (this.opacity_ !== 1) {\n      const compositionContext = createCanvasContext2D(\n        this.context.canvas.width,\n        this.context.canvas.height,\n        canvasPool\n      );\n      this.compositionContext_ = compositionContext;\n    } else {\n      this.compositionContext_ = this.context;\n    }\n  }\n\n  releaseCompositionContext_() {\n    if (this.opacity_ !== 1) {\n      const alpha = this.context.globalAlpha;\n      this.context.globalAlpha = this.opacity_;\n      this.context.drawImage(this.compositionContext_.canvas, 0, 0);\n      this.context.globalAlpha = alpha;\n      releaseCanvas(this.compositionContext_);\n      canvasPool.push(this.compositionContext_.canvas);\n      this.compositionContext_ = null;\n    }\n  }\n\n  /**\n   * Render declutter items for this layer\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   */\n  renderDeclutter(frameState) {\n    if (this.declutterExecutorGroup) {\n      this.setupCompositionContext_();\n      this.renderWorlds(\n        this.declutterExecutorGroup,\n        frameState,\n        frameState.declutterTree\n      );\n      this.releaseCompositionContext_();\n    }\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement|null} target Target that may be used to render content to.\n   * @return {HTMLElement|null} The rendered element.\n   */\n  renderFrame(frameState, target) {\n    const pixelRatio = frameState.pixelRatio;\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n\n    // set forward and inverse pixel transforms\n    makeScale(this.pixelTransform, 1 / pixelRatio, 1 / pixelRatio);\n    makeInverse(this.inversePixelTransform, this.pixelTransform);\n\n    const canvasTransform = transformToString(this.pixelTransform);\n\n    this.useContainer(target, canvasTransform, this.getBackground(frameState));\n    const context = this.context;\n    const canvas = context.canvas;\n\n    const replayGroup = this.replayGroup_;\n    const declutterExecutorGroup = this.declutterExecutorGroup;\n    let render =\n      (replayGroup && !replayGroup.isEmpty()) ||\n      (declutterExecutorGroup && !declutterExecutorGroup.isEmpty());\n    if (!render) {\n      const hasRenderListeners =\n        this.getLayer().hasListener(RenderEventType.PRERENDER) ||\n        this.getLayer().hasListener(RenderEventType.POSTRENDER);\n      if (!hasRenderListeners) {\n        return null;\n      }\n    }\n\n    // resize and clear\n    const width = Math.round(frameState.size[0] * pixelRatio);\n    const height = Math.round(frameState.size[1] * pixelRatio);\n    if (canvas.width != width || canvas.height != height) {\n      canvas.width = width;\n      canvas.height = height;\n      if (canvas.style.transform !== canvasTransform) {\n        canvas.style.transform = canvasTransform;\n      }\n    } else if (!this.containerReused) {\n      context.clearRect(0, 0, width, height);\n    }\n\n    this.preRender(context, frameState);\n\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n\n    this.opacity_ = layerState.opacity;\n    this.setupCompositionContext_();\n\n    // clipped rendering if layer extent is set\n    let clipped = false;\n    if (render && layerState.extent && this.clipping) {\n      const layerExtent = fromUserExtent(layerState.extent, projection);\n      render = intersectsExtent(layerExtent, frameState.extent);\n      clipped = render && !containsExtent(layerExtent, frameState.extent);\n      if (clipped) {\n        this.clipUnrotated(this.compositionContext_, frameState, layerExtent);\n      }\n    }\n\n    if (render) {\n      this.renderWorlds(replayGroup, frameState);\n    }\n\n    if (clipped) {\n      this.compositionContext_.restore();\n    }\n\n    this.releaseCompositionContext_();\n\n    this.postRender(context, frameState);\n\n    if (this.renderedRotation_ !== viewState.rotation) {\n      this.renderedRotation_ = viewState.rotation;\n      this.hitDetectionImageData_ = null;\n    }\n    return this.container;\n  }\n\n  /**\n   * Asynchronous layer level hit detection.\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../../Feature\").default>>} Promise\n   * that resolves with an array of features.\n   */\n  getFeatures(pixel) {\n    return new Promise((resolve) => {\n      if (!this.hitDetectionImageData_ && !this.animatingOrInteracting_) {\n        const size = [this.context.canvas.width, this.context.canvas.height];\n        apply(this.pixelTransform, size);\n        const center = this.renderedCenter_;\n        const resolution = this.renderedResolution_;\n        const rotation = this.renderedRotation_;\n        const projection = this.renderedProjection_;\n        const extent = this.wrappedRenderedExtent_;\n        const layer = this.getLayer();\n        const transforms = [];\n        const width = size[0] * HIT_DETECT_RESOLUTION;\n        const height = size[1] * HIT_DETECT_RESOLUTION;\n        transforms.push(\n          this.getRenderTransform(\n            center,\n            resolution,\n            rotation,\n            HIT_DETECT_RESOLUTION,\n            width,\n            height,\n            0\n          ).slice()\n        );\n        const source = layer.getSource();\n        const projectionExtent = projection.getExtent();\n        if (\n          source.getWrapX() &&\n          projection.canWrapX() &&\n          !containsExtent(projectionExtent, extent)\n        ) {\n          let startX = extent[0];\n          const worldWidth = getWidth(projectionExtent);\n          let world = 0;\n          let offsetX;\n          while (startX < projectionExtent[0]) {\n            --world;\n            offsetX = worldWidth * world;\n            transforms.push(\n              this.getRenderTransform(\n                center,\n                resolution,\n                rotation,\n                HIT_DETECT_RESOLUTION,\n                width,\n                height,\n                offsetX\n              ).slice()\n            );\n            startX += worldWidth;\n          }\n          world = 0;\n          startX = extent[2];\n          while (startX > projectionExtent[2]) {\n            ++world;\n            offsetX = worldWidth * world;\n            transforms.push(\n              this.getRenderTransform(\n                center,\n                resolution,\n                rotation,\n                HIT_DETECT_RESOLUTION,\n                width,\n                height,\n                offsetX\n              ).slice()\n            );\n            startX -= worldWidth;\n          }\n        }\n\n        this.hitDetectionImageData_ = createHitDetectionImageData(\n          size,\n          transforms,\n          this.renderedFeatures_,\n          layer.getStyleFunction(),\n          extent,\n          resolution,\n          rotation\n        );\n      }\n      resolve(\n        hitDetect(pixel, this.renderedFeatures_, this.hitDetectionImageData_)\n      );\n    });\n  }\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches\n  ) {\n    if (!this.replayGroup_) {\n      return undefined;\n    }\n    const resolution = frameState.viewState.resolution;\n    const rotation = frameState.viewState.rotation;\n    const layer = this.getLayer();\n\n    /** @type {!Object<string, import(\"../Map.js\").HitMatch<T>|true>} */\n    const features = {};\n\n    /**\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     * @param {import(\"../../geom/SimpleGeometry.js\").default} geometry Geometry.\n     * @param {number} distanceSq The squared distance to the click position\n     * @return {T|undefined} Callback result.\n     */\n    const featureCallback = function (feature, geometry, distanceSq) {\n      const key = getUid(feature);\n      const match = features[key];\n      if (!match) {\n        if (distanceSq === 0) {\n          features[key] = true;\n          return callback(feature, layer, geometry);\n        }\n        matches.push(\n          (features[key] = {\n            feature: feature,\n            layer: layer,\n            geometry: geometry,\n            distanceSq: distanceSq,\n            callback: callback,\n          })\n        );\n      } else if (match !== true && distanceSq < match.distanceSq) {\n        if (distanceSq === 0) {\n          features[key] = true;\n          matches.splice(matches.lastIndexOf(match), 1);\n          return callback(feature, layer, geometry);\n        }\n        match.geometry = geometry;\n        match.distanceSq = distanceSq;\n      }\n      return undefined;\n    };\n\n    let result;\n    const executorGroups = [this.replayGroup_];\n    if (this.declutterExecutorGroup) {\n      executorGroups.push(this.declutterExecutorGroup);\n    }\n    executorGroups.some((executorGroup) => {\n      return (result = executorGroup.forEachFeatureAtCoordinate(\n        coordinate,\n        resolution,\n        rotation,\n        hitTolerance,\n        featureCallback,\n        executorGroup === this.declutterExecutorGroup &&\n          frameState.declutterTree\n          ? frameState.declutterTree.all().map((item) => item.value)\n          : null\n      ));\n    });\n\n    return result;\n  }\n\n  /**\n   * Perform action necessary to get the layer rendered after new fonts have loaded\n   */\n  handleFontsChanged() {\n    const layer = this.getLayer();\n    if (layer.getVisible() && this.replayGroup_) {\n      layer.changed();\n    }\n  }\n\n  /**\n   * Handle changes in image style state.\n   * @param {import(\"../../events/Event.js\").default} event Image style change event.\n   * @private\n   */\n  handleStyleImageChange_(event) {\n    this.renderIfReadyAndVisible();\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    const vectorLayer = this.getLayer();\n    const vectorSource = vectorLayer.getSource();\n    if (!vectorSource) {\n      return false;\n    }\n\n    const animating = frameState.viewHints[ViewHint.ANIMATING];\n    const interacting = frameState.viewHints[ViewHint.INTERACTING];\n    const updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();\n    const updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();\n\n    if (\n      (this.ready && !updateWhileAnimating && animating) ||\n      (!updateWhileInteracting && interacting)\n    ) {\n      this.animatingOrInteracting_ = true;\n      return true;\n    }\n    this.animatingOrInteracting_ = false;\n\n    const frameStateExtent = frameState.extent;\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const resolution = viewState.resolution;\n    const pixelRatio = frameState.pixelRatio;\n    const vectorLayerRevision = vectorLayer.getRevision();\n    const vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();\n    let vectorLayerRenderOrder = vectorLayer.getRenderOrder();\n\n    if (vectorLayerRenderOrder === undefined) {\n      vectorLayerRenderOrder = defaultRenderOrder;\n    }\n\n    const center = viewState.center.slice();\n    const extent = buffer(\n      frameStateExtent,\n      vectorLayerRenderBuffer * resolution\n    );\n    const renderedExtent = extent.slice();\n    const loadExtents = [extent.slice()];\n    const projectionExtent = projection.getExtent();\n\n    if (\n      vectorSource.getWrapX() &&\n      projection.canWrapX() &&\n      !containsExtent(projectionExtent, frameState.extent)\n    ) {\n      // For the replay group, we need an extent that intersects the real world\n      // (-180° to +180°). To support geometries in a coordinate range from -540°\n      // to +540°, we add at least 1 world width on each side of the projection\n      // extent. If the viewport is wider than the world, we need to add half of\n      // the viewport width to make sure we cover the whole viewport.\n      const worldWidth = getWidth(projectionExtent);\n      const gutter = Math.max(getWidth(extent) / 2, worldWidth);\n      extent[0] = projectionExtent[0] - gutter;\n      extent[2] = projectionExtent[2] + gutter;\n      wrapCoordinateX(center, projection);\n      const loadExtent = wrapExtentX(loadExtents[0], projection);\n      // If the extent crosses the date line, we load data for both edges of the worlds\n      if (\n        loadExtent[0] < projectionExtent[0] &&\n        loadExtent[2] < projectionExtent[2]\n      ) {\n        loadExtents.push([\n          loadExtent[0] + worldWidth,\n          loadExtent[1],\n          loadExtent[2] + worldWidth,\n          loadExtent[3],\n        ]);\n      } else if (\n        loadExtent[0] > projectionExtent[0] &&\n        loadExtent[2] > projectionExtent[2]\n      ) {\n        loadExtents.push([\n          loadExtent[0] - worldWidth,\n          loadExtent[1],\n          loadExtent[2] - worldWidth,\n          loadExtent[3],\n        ]);\n      }\n    }\n\n    if (\n      this.ready &&\n      this.renderedResolution_ == resolution &&\n      this.renderedRevision_ == vectorLayerRevision &&\n      this.renderedRenderOrder_ == vectorLayerRenderOrder &&\n      containsExtent(this.wrappedRenderedExtent_, extent)\n    ) {\n      if (!equals(this.renderedExtent_, renderedExtent)) {\n        this.hitDetectionImageData_ = null;\n        this.renderedExtent_ = renderedExtent;\n      }\n      this.renderedCenter_ = center;\n      this.replayGroupChanged = false;\n      return true;\n    }\n\n    this.replayGroup_ = null;\n\n    const replayGroup = new CanvasBuilderGroup(\n      getRenderTolerance(resolution, pixelRatio),\n      extent,\n      resolution,\n      pixelRatio\n    );\n\n    let declutterBuilderGroup;\n    if (this.getLayer().getDeclutter()) {\n      declutterBuilderGroup = new CanvasBuilderGroup(\n        getRenderTolerance(resolution, pixelRatio),\n        extent,\n        resolution,\n        pixelRatio\n      );\n    }\n\n    const userProjection = getUserProjection();\n    let userTransform;\n    if (userProjection) {\n      for (let i = 0, ii = loadExtents.length; i < ii; ++i) {\n        const extent = loadExtents[i];\n        const userExtent = toUserExtent(extent, projection);\n        vectorSource.loadFeatures(\n          userExtent,\n          toUserResolution(resolution, projection),\n          userProjection\n        );\n      }\n      userTransform = getTransformFromProjections(userProjection, projection);\n    } else {\n      for (let i = 0, ii = loadExtents.length; i < ii; ++i) {\n        vectorSource.loadFeatures(loadExtents[i], resolution, projection);\n      }\n    }\n\n    const squaredTolerance = getSquaredRenderTolerance(resolution, pixelRatio);\n    let ready = true;\n    const render =\n      /**\n       * @param {import(\"../../Feature.js\").default} feature Feature.\n       */\n      (feature) => {\n        let styles;\n        const styleFunction =\n          feature.getStyleFunction() || vectorLayer.getStyleFunction();\n        if (styleFunction) {\n          styles = styleFunction(feature, resolution);\n        }\n        if (styles) {\n          const dirty = this.renderFeature(\n            feature,\n            squaredTolerance,\n            styles,\n            replayGroup,\n            userTransform,\n            declutterBuilderGroup\n          );\n          ready = ready && !dirty;\n        }\n      };\n\n    const userExtent = toUserExtent(extent, projection);\n    /** @type {Array<import(\"../../Feature.js\").default>} */\n    const features = vectorSource.getFeaturesInExtent(userExtent);\n    if (vectorLayerRenderOrder) {\n      features.sort(vectorLayerRenderOrder);\n    }\n    for (let i = 0, ii = features.length; i < ii; ++i) {\n      render(features[i]);\n    }\n    this.renderedFeatures_ = features;\n    this.ready = ready;\n\n    const replayGroupInstructions = replayGroup.finish();\n    const executorGroup = new ExecutorGroup(\n      extent,\n      resolution,\n      pixelRatio,\n      vectorSource.getOverlaps(),\n      replayGroupInstructions,\n      vectorLayer.getRenderBuffer()\n    );\n\n    if (declutterBuilderGroup) {\n      this.declutterExecutorGroup = new ExecutorGroup(\n        extent,\n        resolution,\n        pixelRatio,\n        vectorSource.getOverlaps(),\n        declutterBuilderGroup.finish(),\n        vectorLayer.getRenderBuffer()\n      );\n    }\n\n    this.renderedResolution_ = resolution;\n    this.renderedRevision_ = vectorLayerRevision;\n    this.renderedRenderOrder_ = vectorLayerRenderOrder;\n    this.renderedExtent_ = renderedExtent;\n    this.wrappedRenderedExtent_ = extent;\n    this.renderedCenter_ = center;\n    this.renderedProjection_ = projection;\n    this.replayGroup_ = executorGroup;\n    this.hitDetectionImageData_ = null;\n\n    this.replayGroupChanged = true;\n    return true;\n  }\n\n  /**\n   * @param {import(\"../../Feature.js\").default} feature Feature.\n   * @param {number} squaredTolerance Squared render tolerance.\n   * @param {import(\"../../style/Style.js\").default|Array<import(\"../../style/Style.js\").default>} styles The style or array of styles.\n   * @param {import(\"../../render/canvas/BuilderGroup.js\").default} builderGroup Builder group.\n   * @param {import(\"../../proj.js\").TransformFunction} [transform] Transform from user to view projection.\n   * @param {import(\"../../render/canvas/BuilderGroup.js\").default} [declutterBuilderGroup] Builder for decluttering.\n   * @return {boolean} `true` if an image is loading.\n   */\n  renderFeature(\n    feature,\n    squaredTolerance,\n    styles,\n    builderGroup,\n    transform,\n    declutterBuilderGroup\n  ) {\n    if (!styles) {\n      return false;\n    }\n    let loading = false;\n    if (Array.isArray(styles)) {\n      for (let i = 0, ii = styles.length; i < ii; ++i) {\n        loading =\n          renderFeature(\n            builderGroup,\n            feature,\n            styles[i],\n            squaredTolerance,\n            this.boundHandleStyleImageChange_,\n            transform,\n            declutterBuilderGroup\n          ) || loading;\n      }\n    } else {\n      loading = renderFeature(\n        builderGroup,\n        feature,\n        styles,\n        squaredTolerance,\n        this.boundHandleStyleImageChange_,\n        transform,\n        declutterBuilderGroup\n      );\n    }\n    return loading;\n  }\n}\n\nexport default CanvasVectorLayerRenderer;\n","/**\n * @module ol/renderer/canvas/VectorTileLayer\n */\nimport CanvasBuilderGroup from '../../render/canvas/BuilderGroup.js';\nimport CanvasExecutorGroup from '../../render/canvas/ExecutorGroup.js';\nimport CanvasTileLayerRenderer from './TileLayer.js';\nimport TileState from '../../TileState.js';\nimport ViewHint from '../../ViewHint.js';\nimport {\n  HIT_DETECT_RESOLUTION,\n  createHitDetectionImageData,\n  hitDetect,\n} from '../../render/canvas/hitdetect.js';\nimport {\n  apply as applyTransform,\n  create as createTransform,\n  multiply,\n  reset as resetTransform,\n  scale,\n  scale as scaleTransform,\n  translate as translateTransform,\n} from '../../transform.js';\nimport {\n  boundingExtent,\n  buffer,\n  containsExtent,\n  equals,\n  getIntersection,\n  getTopLeft,\n  intersects,\n} from '../../extent.js';\nimport {\n  getSquaredTolerance as getSquaredRenderTolerance,\n  renderFeature,\n} from '../vector.js';\nimport {getUid} from '../../util.js';\nimport {toSize} from '../../size.js';\nimport {wrapX} from '../../coordinate.js';\n\n/**\n * @type {!Object<string, Array<import(\"../../render/canvas.js\").BuilderType>>}\n */\nconst IMAGE_REPLAYS = {\n  'image': ['Polygon', 'Circle', 'LineString', 'Image', 'Text'],\n  'hybrid': ['Polygon', 'LineString'],\n  'vector': [],\n};\n\n/**\n * @type {!Object<string, Array<import(\"../../render/canvas.js\").BuilderType>>}\n */\nconst VECTOR_REPLAYS = {\n  'hybrid': ['Image', 'Text', 'Default'],\n  'vector': ['Polygon', 'Circle', 'LineString', 'Image', 'Text', 'Default'],\n};\n\n/**\n * @classdesc\n * Canvas renderer for vector tile layers.\n * @api\n * @extends {CanvasTileLayerRenderer<import(\"../../layer/VectorTile.js\").default>}\n */\nclass CanvasVectorTileLayerRenderer extends CanvasTileLayerRenderer {\n  /**\n   * @param {import(\"../../layer/VectorTile.js\").default} layer VectorTile layer.\n   */\n  constructor(layer) {\n    super(layer);\n\n    /** @private */\n    this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this);\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedLayerRevision_;\n\n    /**\n     * @private\n     * @type {import(\"../../transform\").Transform}\n     */\n    this.renderedPixelToCoordinateTransform_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedRotation_;\n\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.tmpTransform_ = createTransform();\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection\").default} projection Projection.\n   * @return {boolean|undefined} Tile needs to be rendered.\n   */\n  prepareTile(tile, pixelRatio, projection) {\n    let render;\n    const state = tile.getState();\n    if (state === TileState.LOADED || state === TileState.ERROR) {\n      this.updateExecutorGroup_(tile, pixelRatio, projection);\n      if (this.tileImageNeedsRender_(tile)) {\n        render = true;\n      }\n    }\n    return render;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {!import(\"../../Tile.js\").default} Tile.\n   */\n  getTile(z, x, y, frameState) {\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const resolution = viewState.resolution;\n    const projection = viewState.projection;\n    const layer = this.getLayer();\n    const tile = layer.getSource().getTile(z, x, y, pixelRatio, projection);\n    const viewHints = frameState.viewHints;\n    const hifi = !(\n      viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]\n    );\n    if (hifi || !tile.wantedResolution) {\n      tile.wantedResolution = resolution;\n    }\n    const render = this.prepareTile(tile, pixelRatio, projection);\n    if (\n      render &&\n      (hifi || Date.now() - frameState.time < 8) &&\n      layer.getRenderMode() !== 'vector'\n    ) {\n      this.renderTileImage_(tile, frameState);\n    }\n    return super.getTile(z, x, y, frameState);\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @return {boolean} Tile is drawable.\n   */\n  isDrawableTile(tile) {\n    const layer = this.getLayer();\n    return (\n      super.isDrawableTile(tile) &&\n      (layer.getRenderMode() === 'vector'\n        ? getUid(layer) in tile.executorGroups\n        : tile.hasContext(layer))\n    );\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getTileImage(tile) {\n    return tile.getImage(this.getLayer());\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    const layerRevision = this.getLayer().getRevision();\n    if (this.renderedLayerRevision_ !== layerRevision) {\n      this.renderedLayerRevision_ = layerRevision;\n      this.renderedTiles.length = 0;\n    }\n    return super.prepareFrame(frameState);\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @private\n   */\n  updateExecutorGroup_(tile, pixelRatio, projection) {\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    const revision = layer.getRevision();\n    const renderOrder = layer.getRenderOrder() || null;\n\n    const resolution = tile.wantedResolution;\n    const builderState = tile.getReplayState(layer);\n    if (\n      !builderState.dirty &&\n      builderState.renderedResolution === resolution &&\n      builderState.renderedRevision == revision &&\n      builderState.renderedRenderOrder == renderOrder\n    ) {\n      return;\n    }\n\n    const source = layer.getSource();\n    const declutter = layer.getDeclutter();\n    const sourceTileGrid = source.getTileGrid();\n    const tileGrid = source.getTileGridForProjection(projection);\n    const tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n\n    const sourceTiles = source.getSourceTiles(pixelRatio, projection, tile);\n    const layerUid = getUid(layer);\n    delete tile.hitDetectionImageData[layerUid];\n    tile.executorGroups[layerUid] = [];\n    if (declutter) {\n      tile.declutterExecutorGroups[layerUid] = [];\n    }\n    builderState.dirty = false;\n    for (let t = 0, tt = sourceTiles.length; t < tt; ++t) {\n      const sourceTile = sourceTiles[t];\n      if (sourceTile.getState() != TileState.LOADED) {\n        continue;\n      }\n      const sourceTileCoord = sourceTile.tileCoord;\n      const sourceTileExtent =\n        sourceTileGrid.getTileCoordExtent(sourceTileCoord);\n      const sharedExtent = getIntersection(tileExtent, sourceTileExtent);\n      const builderExtent = buffer(\n        sharedExtent,\n        layer.getRenderBuffer() * resolution,\n        this.tmpExtent\n      );\n      const bufferedExtent = equals(sourceTileExtent, sharedExtent)\n        ? null\n        : builderExtent;\n      const builderGroup = new CanvasBuilderGroup(\n        0,\n        builderExtent,\n        resolution,\n        pixelRatio\n      );\n      const declutterBuilderGroup = declutter\n        ? new CanvasBuilderGroup(0, sharedExtent, resolution, pixelRatio)\n        : undefined;\n      const squaredTolerance = getSquaredRenderTolerance(\n        resolution,\n        pixelRatio\n      );\n\n      /**\n       * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n       * @this {CanvasVectorTileLayerRenderer}\n       */\n      const render = function (feature) {\n        let styles;\n        const styleFunction =\n          feature.getStyleFunction() || layer.getStyleFunction();\n        if (styleFunction) {\n          styles = styleFunction(feature, resolution);\n        }\n        if (styles) {\n          const dirty = this.renderFeature(\n            feature,\n            squaredTolerance,\n            styles,\n            builderGroup,\n            declutterBuilderGroup\n          );\n          builderState.dirty = builderState.dirty || dirty;\n        }\n      };\n\n      const features = sourceTile.getFeatures();\n      if (renderOrder && renderOrder !== builderState.renderedRenderOrder) {\n        features.sort(renderOrder);\n      }\n      for (let i = 0, ii = features.length; i < ii; ++i) {\n        const feature = features[i];\n        if (\n          !bufferedExtent ||\n          intersects(bufferedExtent, feature.getGeometry().getExtent())\n        ) {\n          render.call(this, feature);\n        }\n      }\n      const executorGroupInstructions = builderGroup.finish();\n      // no need to clip when the render tile is covered by a single source tile\n      const replayExtent =\n        layer.getRenderMode() !== 'vector' &&\n        declutter &&\n        sourceTiles.length === 1\n          ? null\n          : sharedExtent;\n      const renderingReplayGroup = new CanvasExecutorGroup(\n        replayExtent,\n        resolution,\n        pixelRatio,\n        source.getOverlaps(),\n        executorGroupInstructions,\n        layer.getRenderBuffer()\n      );\n      tile.executorGroups[layerUid].push(renderingReplayGroup);\n      if (declutterBuilderGroup) {\n        const declutterExecutorGroup = new CanvasExecutorGroup(\n          null,\n          resolution,\n          pixelRatio,\n          source.getOverlaps(),\n          declutterBuilderGroup.finish(),\n          layer.getRenderBuffer()\n        );\n        tile.declutterExecutorGroups[layerUid].push(declutterExecutorGroup);\n      }\n    }\n    builderState.renderedRevision = revision;\n    builderState.renderedRenderOrder = renderOrder;\n    builderState.renderedResolution = resolution;\n  }\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches\n  ) {\n    const resolution = frameState.viewState.resolution;\n    const rotation = frameState.viewState.rotation;\n    hitTolerance = hitTolerance == undefined ? 0 : hitTolerance;\n    const layer = this.getLayer();\n    const source = layer.getSource();\n    const tileGrid = source.getTileGridForProjection(\n      frameState.viewState.projection\n    );\n\n    const hitExtent = boundingExtent([coordinate]);\n    buffer(hitExtent, resolution * hitTolerance, hitExtent);\n\n    /** @type {!Object<string, import(\"../Map.js\").HitMatch<T>|true>} */\n    const features = {};\n\n    /**\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     * @param {import(\"../../geom/SimpleGeometry.js\").default} geometry Geometry.\n     * @param {number} distanceSq The squared distance to the click position.\n     * @return {T|undefined} Callback result.\n     */\n    const featureCallback = function (feature, geometry, distanceSq) {\n      let key = feature.getId();\n      if (key === undefined) {\n        key = getUid(feature);\n      }\n      const match = features[key];\n      if (!match) {\n        if (distanceSq === 0) {\n          features[key] = true;\n          return callback(feature, layer, geometry);\n        }\n        matches.push(\n          (features[key] = {\n            feature: feature,\n            layer: layer,\n            geometry: geometry,\n            distanceSq: distanceSq,\n            callback: callback,\n          })\n        );\n      } else if (match !== true && distanceSq < match.distanceSq) {\n        if (distanceSq === 0) {\n          features[key] = true;\n          matches.splice(matches.lastIndexOf(match), 1);\n          return callback(feature, layer, geometry);\n        }\n        match.geometry = geometry;\n        match.distanceSq = distanceSq;\n      }\n      return undefined;\n    };\n\n    const renderedTiles =\n      /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */ (\n        this.renderedTiles\n      );\n\n    let found;\n    for (let i = 0, ii = renderedTiles.length; !found && i < ii; ++i) {\n      const tile = renderedTiles[i];\n      const tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n      if (!intersects(tileExtent, hitExtent)) {\n        continue;\n      }\n\n      const layerUid = getUid(layer);\n      const executorGroups = [tile.executorGroups[layerUid]];\n      const declutterExecutorGroups = tile.declutterExecutorGroups[layerUid];\n      if (declutterExecutorGroups) {\n        executorGroups.push(declutterExecutorGroups);\n      }\n      executorGroups.some((executorGroups) => {\n        const declutteredFeatures =\n          executorGroups === declutterExecutorGroups\n            ? frameState.declutterTree.all().map((item) => item.value)\n            : null;\n        for (let t = 0, tt = executorGroups.length; t < tt; ++t) {\n          const executorGroup = executorGroups[t];\n          found = executorGroup.forEachFeatureAtCoordinate(\n            coordinate,\n            resolution,\n            rotation,\n            hitTolerance,\n            featureCallback,\n            declutteredFeatures\n          );\n          if (found) {\n            return true;\n          }\n        }\n      });\n    }\n    return found;\n  }\n\n  /**\n   * Asynchronous layer level hit detection.\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../../Feature.js\").FeatureLike>>} Promise that resolves with an array of features.\n   */\n  getFeatures(pixel) {\n    return new Promise((resolve, reject) => {\n      const layer = this.getLayer();\n      const layerUid = getUid(layer);\n      const source = layer.getSource();\n      const projection = this.renderedProjection;\n      const projectionExtent = projection.getExtent();\n      const resolution = this.renderedResolution;\n      const tileGrid = source.getTileGridForProjection(projection);\n      const coordinate = applyTransform(\n        this.renderedPixelToCoordinateTransform_,\n        pixel.slice()\n      );\n      const tileCoord = tileGrid.getTileCoordForCoordAndResolution(\n        coordinate,\n        resolution\n      );\n      /** @type {import(\"../../VectorRenderTile.js\").default|undefined} */\n      let tile;\n      for (let i = 0, ii = this.renderedTiles.length; i < ii; ++i) {\n        if (\n          tileCoord.toString() === this.renderedTiles[i].tileCoord.toString()\n        ) {\n          tile = /** @type {import(\"../../VectorRenderTile.js\").default} */ (\n            this.renderedTiles[i]\n          );\n          if (tile.getState() === TileState.LOADED) {\n            const extent = tileGrid.getTileCoordExtent(tile.tileCoord);\n            if (\n              source.getWrapX() &&\n              projection.canWrapX() &&\n              !containsExtent(projectionExtent, extent)\n            ) {\n              wrapX(coordinate, projection);\n            }\n            break;\n          }\n          tile = undefined;\n        }\n      }\n      if (!tile || tile.loadingSourceTiles > 0) {\n        resolve([]);\n        return;\n      }\n      const extent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n      const corner = getTopLeft(extent);\n      const tilePixel = [\n        (coordinate[0] - corner[0]) / resolution,\n        (corner[1] - coordinate[1]) / resolution,\n      ];\n      /** @type {Array<import(\"../../Feature.js\").FeatureLike>} */\n      const features = tile\n        .getSourceTiles()\n        .reduce(function (accumulator, sourceTile) {\n          return accumulator.concat(sourceTile.getFeatures());\n        }, []);\n      /** @type {ImageData|undefined} */\n      let hitDetectionImageData = tile.hitDetectionImageData[layerUid];\n      if (!hitDetectionImageData) {\n        const tileSize = toSize(\n          tileGrid.getTileSize(\n            tileGrid.getZForResolution(resolution, source.zDirection)\n          )\n        );\n        const rotation = this.renderedRotation_;\n        const transforms = [\n          this.getRenderTransform(\n            tileGrid.getTileCoordCenter(tile.wrappedTileCoord),\n            resolution,\n            0,\n            HIT_DETECT_RESOLUTION,\n            tileSize[0] * HIT_DETECT_RESOLUTION,\n            tileSize[1] * HIT_DETECT_RESOLUTION,\n            0\n          ),\n        ];\n        hitDetectionImageData = createHitDetectionImageData(\n          tileSize,\n          transforms,\n          features,\n          layer.getStyleFunction(),\n          tileGrid.getTileCoordExtent(tile.wrappedTileCoord),\n          tile.getReplayState(layer).renderedResolution,\n          rotation\n        );\n        tile.hitDetectionImageData[layerUid] = hitDetectionImageData;\n      }\n      resolve(hitDetect(tilePixel, features, hitDetectionImageData));\n    });\n  }\n\n  /**\n   * Perform action necessary to get the layer rendered after new fonts have loaded\n   */\n  handleFontsChanged() {\n    const layer = this.getLayer();\n    if (layer.getVisible() && this.renderedLayerRevision_ !== undefined) {\n      layer.changed();\n    }\n  }\n\n  /**\n   * Handle changes in image style state.\n   * @param {import(\"../../events/Event.js\").default} event Image style change event.\n   * @private\n   */\n  handleStyleImageChange_(event) {\n    this.renderIfReadyAndVisible();\n  }\n\n  /**\n   * Render declutter items for this layer\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   */\n  renderDeclutter(frameState) {\n    const context = this.context;\n    const alpha = context.globalAlpha;\n    context.globalAlpha = this.getLayer().getOpacity();\n    const viewHints = frameState.viewHints;\n    const hifi = !(\n      viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]\n    );\n    const tiles =\n      /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */ (\n        this.renderedTiles\n      );\n    for (let i = 0, ii = tiles.length; i < ii; ++i) {\n      const tile = tiles[i];\n      const declutterExecutorGroups =\n        tile.declutterExecutorGroups[getUid(this.getLayer())];\n      if (declutterExecutorGroups) {\n        for (let j = declutterExecutorGroups.length - 1; j >= 0; --j) {\n          declutterExecutorGroups[j].execute(\n            this.context,\n            1,\n            this.getTileRenderTransform(tile, frameState),\n            frameState.viewState.rotation,\n            hifi,\n            undefined,\n            frameState.declutterTree\n          );\n        }\n      }\n    }\n    context.globalAlpha = alpha;\n  }\n\n  getTileRenderTransform(tile, frameState) {\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const center = viewState.center;\n    const resolution = viewState.resolution;\n    const rotation = viewState.rotation;\n    const size = frameState.size;\n    const width = Math.round(size[0] * pixelRatio);\n    const height = Math.round(size[1] * pixelRatio);\n\n    const source = this.getLayer().getSource();\n    const tileGrid = source.getTileGridForProjection(\n      frameState.viewState.projection\n    );\n    const tileCoord = tile.tileCoord;\n    const tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n    const worldOffset =\n      tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent)[0] - tileExtent[0];\n    const transform = multiply(\n      scale(this.inversePixelTransform.slice(), 1 / pixelRatio, 1 / pixelRatio),\n      this.getRenderTransform(\n        center,\n        resolution,\n        rotation,\n        pixelRatio,\n        width,\n        height,\n        worldOffset\n      )\n    );\n    return transform;\n  }\n\n  /**\n   * Render the vectors for this layer.\n   * @param {CanvasRenderingContext2D} context Target context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   */\n  postRender(context, frameState) {\n    const viewHints = frameState.viewHints;\n    const hifi = !(\n      viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]\n    );\n\n    this.renderedPixelToCoordinateTransform_ =\n      frameState.pixelToCoordinateTransform.slice();\n    this.renderedRotation_ = frameState.viewState.rotation;\n\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    const renderMode = layer.getRenderMode();\n    const alpha = context.globalAlpha;\n    context.globalAlpha = layer.getOpacity();\n    const replayTypes = VECTOR_REPLAYS[renderMode];\n    const viewState = frameState.viewState;\n    const rotation = viewState.rotation;\n    const tileSource = layer.getSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n    const z = tileGrid.getZForResolution(\n      viewState.resolution,\n      tileSource.zDirection\n    );\n\n    const tiles = this.renderedTiles;\n    const clips = [];\n    const clipZs = [];\n    let ready = true;\n    for (let i = tiles.length - 1; i >= 0; --i) {\n      const tile = /** @type {import(\"../../VectorRenderTile.js\").default} */ (\n        tiles[i]\n      );\n      ready = ready && !tile.getReplayState(layer).dirty;\n      const executorGroups = tile.executorGroups[getUid(layer)].filter(\n        (group) => group.hasExecutors(replayTypes)\n      );\n      if (executorGroups.length === 0) {\n        continue;\n      }\n      const transform = this.getTileRenderTransform(tile, frameState);\n      const currentZ = tile.tileCoord[0];\n      let contextSaved = false;\n      // Clip mask for regions in this tile that already filled by a higher z tile\n      const currentClip = executorGroups[0].getClipCoords(transform);\n      if (currentClip) {\n        for (let j = 0, jj = clips.length; j < jj; ++j) {\n          if (z !== currentZ && currentZ < clipZs[j]) {\n            const clip = clips[j];\n            if (\n              intersects(\n                [\n                  currentClip[0],\n                  currentClip[3],\n                  currentClip[4],\n                  currentClip[7],\n                ],\n                [clip[0], clip[3], clip[4], clip[7]]\n              )\n            ) {\n              if (!contextSaved) {\n                context.save();\n                contextSaved = true;\n              }\n              context.beginPath();\n              // counter-clockwise (outer ring) for current tile\n              context.moveTo(currentClip[0], currentClip[1]);\n              context.lineTo(currentClip[2], currentClip[3]);\n              context.lineTo(currentClip[4], currentClip[5]);\n              context.lineTo(currentClip[6], currentClip[7]);\n              // clockwise (inner ring) for higher z tile\n              context.moveTo(clip[6], clip[7]);\n              context.lineTo(clip[4], clip[5]);\n              context.lineTo(clip[2], clip[3]);\n              context.lineTo(clip[0], clip[1]);\n              context.clip();\n            }\n          }\n        }\n        clips.push(currentClip);\n        clipZs.push(currentZ);\n      }\n      for (let t = 0, tt = executorGroups.length; t < tt; ++t) {\n        const executorGroup = executorGroups[t];\n        executorGroup.execute(\n          context,\n          1,\n          transform,\n          rotation,\n          hifi,\n          replayTypes\n        );\n      }\n      if (contextSaved) {\n        context.restore();\n      }\n    }\n    context.globalAlpha = alpha;\n    this.ready = ready;\n\n    super.postRender(context, frameState);\n  }\n\n  /**\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../../style/Style.js\").default|Array<import(\"../../style/Style.js\").default>} styles The style or array of styles.\n   * @param {import(\"../../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n   * @param {import(\"../../render/canvas/BuilderGroup.js\").default} [declutterBuilderGroup] Builder group for decluttering.\n   * @return {boolean} `true` if an image is loading.\n   */\n  renderFeature(\n    feature,\n    squaredTolerance,\n    styles,\n    builderGroup,\n    declutterBuilderGroup\n  ) {\n    if (!styles) {\n      return false;\n    }\n    let loading = false;\n    if (Array.isArray(styles)) {\n      for (let i = 0, ii = styles.length; i < ii; ++i) {\n        loading =\n          renderFeature(\n            builderGroup,\n            feature,\n            styles[i],\n            squaredTolerance,\n            this.boundHandleStyleImageChange_,\n            undefined,\n            declutterBuilderGroup\n          ) || loading;\n      }\n    } else {\n      loading = renderFeature(\n        builderGroup,\n        feature,\n        styles,\n        squaredTolerance,\n        this.boundHandleStyleImageChange_,\n        undefined,\n        declutterBuilderGroup\n      );\n    }\n    return loading;\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @return {boolean} A new tile image was rendered.\n   * @private\n   */\n  tileImageNeedsRender_(tile) {\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    if (layer.getRenderMode() === 'vector') {\n      return false;\n    }\n    const replayState = tile.getReplayState(layer);\n    const revision = layer.getRevision();\n    const resolution = tile.wantedResolution;\n    return (\n      replayState.renderedTileResolution !== resolution ||\n      replayState.renderedTileRevision !== revision\n    );\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {import(\"../../Map\").FrameState} frameState Frame state.\n   * @private\n   */\n  renderTileImage_(tile, frameState) {\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    const replayState = tile.getReplayState(layer);\n    const revision = layer.getRevision();\n    const executorGroups = tile.executorGroups[getUid(layer)];\n    replayState.renderedTileRevision = revision;\n\n    const tileCoord = tile.wrappedTileCoord;\n    const z = tileCoord[0];\n    const source = layer.getSource();\n    let pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const tileGrid = source.getTileGridForProjection(projection);\n    const tileResolution = tileGrid.getResolution(tile.tileCoord[0]);\n    const renderPixelRatio =\n      (frameState.pixelRatio / tile.wantedResolution) * tileResolution;\n    const resolution = tileGrid.getResolution(z);\n    const context = tile.getContext(layer);\n\n    // Increase tile size when overzooming for low pixel ratio, to avoid blurry tiles\n    pixelRatio = Math.round(\n      Math.max(pixelRatio, renderPixelRatio / pixelRatio)\n    );\n    const size = source.getTilePixelSize(z, pixelRatio, projection);\n    context.canvas.width = size[0];\n    context.canvas.height = size[1];\n    const renderScale = pixelRatio / renderPixelRatio;\n    if (renderScale !== 1) {\n      const canvasTransform = resetTransform(this.tmpTransform_);\n      scaleTransform(canvasTransform, renderScale, renderScale);\n      context.setTransform.apply(context, canvasTransform);\n    }\n    const tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);\n    const pixelScale = renderPixelRatio / resolution;\n    const transform = resetTransform(this.tmpTransform_);\n    scaleTransform(transform, pixelScale, -pixelScale);\n    translateTransform(transform, -tileExtent[0], -tileExtent[3]);\n    for (let i = 0, ii = executorGroups.length; i < ii; ++i) {\n      const executorGroup = executorGroups[i];\n      executorGroup.execute(\n        context,\n        renderScale,\n        transform,\n        0,\n        true,\n        IMAGE_REPLAYS[layer.getRenderMode()]\n      );\n    }\n    replayState.renderedTileResolution = tile.wantedResolution;\n  }\n}\n\nexport default CanvasVectorTileLayerRenderer;\n","/**\n * @module ol/renderer/vector\n */\nimport ImageState from '../ImageState.js';\nimport {getUid} from '../util.js';\n\n/**\n * Feature callback. The callback will be called with three arguments. The first\n * argument is one {@link module:ol/Feature~Feature feature} or {@link module:ol/render/Feature~RenderFeature render feature}\n * at the pixel, the second is the {@link module:ol/layer/Layer~Layer layer} of the feature and will be null for\n * unmanaged layers. The third is the {@link module:ol/geom/SimpleGeometry~SimpleGeometry} of the feature. For features\n * with a GeometryCollection geometry, it will be the first detected geometry from the collection.\n * @template T\n * @typedef {function(import(\"../Feature.js\").FeatureLike, import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>, import(\"../geom/SimpleGeometry.js\").default): T} FeatureCallback\n */\n\n/**\n * Tolerance for geometry simplification in device pixels.\n * @type {number}\n */\nconst SIMPLIFY_TOLERANCE = 0.5;\n\n/**\n * @const\n * @type {Object<import(\"../geom/Geometry.js\").Type,\n *                function(import(\"../render/canvas/BuilderGroup.js\").default, import(\"../geom/Geometry.js\").default,\n *                         import(\"../style/Style.js\").default, Object): void>}\n */\nconst GEOMETRY_RENDERERS = {\n  'Point': renderPointGeometry,\n  'LineString': renderLineStringGeometry,\n  'Polygon': renderPolygonGeometry,\n  'MultiPoint': renderMultiPointGeometry,\n  'MultiLineString': renderMultiLineStringGeometry,\n  'MultiPolygon': renderMultiPolygonGeometry,\n  'GeometryCollection': renderGeometryCollectionGeometry,\n  'Circle': renderCircleGeometry,\n};\n\n/**\n * @param {import(\"../Feature.js\").FeatureLike} feature1 Feature 1.\n * @param {import(\"../Feature.js\").FeatureLike} feature2 Feature 2.\n * @return {number} Order.\n */\nexport function defaultOrder(feature1, feature2) {\n  return parseInt(getUid(feature1), 10) - parseInt(getUid(feature2), 10);\n}\n\n/**\n * @param {number} resolution Resolution.\n * @param {number} pixelRatio Pixel ratio.\n * @return {number} Squared pixel tolerance.\n */\nexport function getSquaredTolerance(resolution, pixelRatio) {\n  const tolerance = getTolerance(resolution, pixelRatio);\n  return tolerance * tolerance;\n}\n\n/**\n * @param {number} resolution Resolution.\n * @param {number} pixelRatio Pixel ratio.\n * @return {number} Pixel tolerance.\n */\nexport function getTolerance(resolution, pixelRatio) {\n  return (SIMPLIFY_TOLERANCE * resolution) / pixelRatio;\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Builder group.\n * @param {import(\"../geom/Circle.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderCircleGeometry(\n  builderGroup,\n  geometry,\n  style,\n  feature,\n  declutterBuilderGroup\n) {\n  const fillStyle = style.getFill();\n  const strokeStyle = style.getStroke();\n  if (fillStyle || strokeStyle) {\n    const circleReplay = builderGroup.getBuilder(style.getZIndex(), 'Circle');\n    circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);\n    circleReplay.drawCircle(geometry, feature);\n  }\n  const textStyle = style.getText();\n  if (textStyle && textStyle.getText()) {\n    const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(\n      style.getZIndex(),\n      'Text'\n    );\n    textReplay.setTextStyle(textStyle);\n    textReplay.drawText(geometry, feature);\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} replayGroup Replay group.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {function(import(\"../events/Event.js\").default): void} listener Listener function.\n * @param {import(\"../proj.js\").TransformFunction} [transform] Transform from user to view projection.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [declutterBuilderGroup] Builder for decluttering.\n * @return {boolean} `true` if style is loading.\n */\nexport function renderFeature(\n  replayGroup,\n  feature,\n  style,\n  squaredTolerance,\n  listener,\n  transform,\n  declutterBuilderGroup\n) {\n  let loading = false;\n  const imageStyle = style.getImage();\n  if (imageStyle) {\n    const imageState = imageStyle.getImageState();\n    if (imageState == ImageState.LOADED || imageState == ImageState.ERROR) {\n      imageStyle.unlistenImageChange(listener);\n    } else {\n      if (imageState == ImageState.IDLE) {\n        imageStyle.load();\n      }\n      imageStyle.listenImageChange(listener);\n      loading = true;\n    }\n  }\n  renderFeatureInternal(\n    replayGroup,\n    feature,\n    style,\n    squaredTolerance,\n    transform,\n    declutterBuilderGroup\n  );\n\n  return loading;\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} replayGroup Replay group.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {import(\"../proj.js\").TransformFunction} [transform] Optional transform function.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderFeatureInternal(\n  replayGroup,\n  feature,\n  style,\n  squaredTolerance,\n  transform,\n  declutterBuilderGroup\n) {\n  const geometry = style.getGeometryFunction()(feature);\n  if (!geometry) {\n    return;\n  }\n  const simplifiedGeometry = geometry.simplifyTransformed(\n    squaredTolerance,\n    transform\n  );\n  const renderer = style.getRenderer();\n  if (renderer) {\n    renderGeometry(replayGroup, simplifiedGeometry, style, feature);\n  } else {\n    const geometryRenderer = GEOMETRY_RENDERERS[simplifiedGeometry.getType()];\n    geometryRenderer(\n      replayGroup,\n      simplifiedGeometry,\n      style,\n      feature,\n      declutterBuilderGroup\n    );\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} replayGroup Replay group.\n * @param {import(\"../geom/Geometry.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n */\nfunction renderGeometry(replayGroup, geometry, style, feature) {\n  if (geometry.getType() == 'GeometryCollection') {\n    const geometries =\n      /** @type {import(\"../geom/GeometryCollection.js\").default} */ (\n        geometry\n      ).getGeometries();\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      renderGeometry(replayGroup, geometries[i], style, feature);\n    }\n    return;\n  }\n  const replay = replayGroup.getBuilder(style.getZIndex(), 'Default');\n  replay.drawCustom(\n    /** @type {import(\"../geom/SimpleGeometry.js\").default} */ (geometry),\n    feature,\n    style.getRenderer(),\n    style.getHitDetectionRenderer()\n  );\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} replayGroup Replay group.\n * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderGeometryCollectionGeometry(\n  replayGroup,\n  geometry,\n  style,\n  feature,\n  declutterBuilderGroup\n) {\n  const geometries = geometry.getGeometriesArray();\n  let i, ii;\n  for (i = 0, ii = geometries.length; i < ii; ++i) {\n    const geometryRenderer = GEOMETRY_RENDERERS[geometries[i].getType()];\n    geometryRenderer(\n      replayGroup,\n      geometries[i],\n      style,\n      feature,\n      declutterBuilderGroup\n    );\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/LineString.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderLineStringGeometry(\n  builderGroup,\n  geometry,\n  style,\n  feature,\n  declutterBuilderGroup\n) {\n  const strokeStyle = style.getStroke();\n  if (strokeStyle) {\n    const lineStringReplay = builderGroup.getBuilder(\n      style.getZIndex(),\n      'LineString'\n    );\n    lineStringReplay.setFillStrokeStyle(null, strokeStyle);\n    lineStringReplay.drawLineString(geometry, feature);\n  }\n  const textStyle = style.getText();\n  if (textStyle && textStyle.getText()) {\n    const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(\n      style.getZIndex(),\n      'Text'\n    );\n    textReplay.setTextStyle(textStyle);\n    textReplay.drawText(geometry, feature);\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/MultiLineString.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderMultiLineStringGeometry(\n  builderGroup,\n  geometry,\n  style,\n  feature,\n  declutterBuilderGroup\n) {\n  const strokeStyle = style.getStroke();\n  if (strokeStyle) {\n    const lineStringReplay = builderGroup.getBuilder(\n      style.getZIndex(),\n      'LineString'\n    );\n    lineStringReplay.setFillStrokeStyle(null, strokeStyle);\n    lineStringReplay.drawMultiLineString(geometry, feature);\n  }\n  const textStyle = style.getText();\n  if (textStyle && textStyle.getText()) {\n    const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(\n      style.getZIndex(),\n      'Text'\n    );\n    textReplay.setTextStyle(textStyle);\n    textReplay.drawText(geometry, feature);\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderMultiPolygonGeometry(\n  builderGroup,\n  geometry,\n  style,\n  feature,\n  declutterBuilderGroup\n) {\n  const fillStyle = style.getFill();\n  const strokeStyle = style.getStroke();\n  if (strokeStyle || fillStyle) {\n    const polygonReplay = builderGroup.getBuilder(style.getZIndex(), 'Polygon');\n    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);\n    polygonReplay.drawMultiPolygon(geometry, feature);\n  }\n  const textStyle = style.getText();\n  if (textStyle && textStyle.getText()) {\n    const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(\n      style.getZIndex(),\n      'Text'\n    );\n    textReplay.setTextStyle(textStyle);\n    textReplay.drawText(geometry, feature);\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/Point.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderPointGeometry(\n  builderGroup,\n  geometry,\n  style,\n  feature,\n  declutterBuilderGroup\n) {\n  const imageStyle = style.getImage();\n  const textStyle = style.getText();\n  /** @type {import(\"../render/canvas.js\").DeclutterImageWithText} */\n  let declutterImageWithText;\n  if (imageStyle) {\n    if (imageStyle.getImageState() != ImageState.LOADED) {\n      return;\n    }\n    let imageBuilderGroup = builderGroup;\n    if (declutterBuilderGroup) {\n      const declutterMode = imageStyle.getDeclutterMode();\n      if (declutterMode !== 'none') {\n        imageBuilderGroup = declutterBuilderGroup;\n        if (declutterMode === 'obstacle') {\n          // draw in non-declutter group:\n          const imageReplay = builderGroup.getBuilder(\n            style.getZIndex(),\n            'Image'\n          );\n          imageReplay.setImageStyle(imageStyle, declutterImageWithText);\n          imageReplay.drawPoint(geometry, feature);\n        } else if (textStyle && textStyle.getText()) {\n          declutterImageWithText = {};\n        }\n      }\n    }\n    const imageReplay = imageBuilderGroup.getBuilder(\n      style.getZIndex(),\n      'Image'\n    );\n    imageReplay.setImageStyle(imageStyle, declutterImageWithText);\n    imageReplay.drawPoint(geometry, feature);\n  }\n  if (textStyle && textStyle.getText()) {\n    let textBuilderGroup = builderGroup;\n    if (declutterBuilderGroup) {\n      textBuilderGroup = declutterBuilderGroup;\n    }\n    const textReplay = textBuilderGroup.getBuilder(style.getZIndex(), 'Text');\n    textReplay.setTextStyle(textStyle, declutterImageWithText);\n    textReplay.drawText(geometry, feature);\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/MultiPoint.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderMultiPointGeometry(\n  builderGroup,\n  geometry,\n  style,\n  feature,\n  declutterBuilderGroup\n) {\n  const imageStyle = style.getImage();\n  const textStyle = style.getText();\n  /** @type {import(\"../render/canvas.js\").DeclutterImageWithText} */\n  let declutterImageWithText;\n  if (imageStyle) {\n    if (imageStyle.getImageState() != ImageState.LOADED) {\n      return;\n    }\n    let imageBuilderGroup = builderGroup;\n    if (declutterBuilderGroup) {\n      const declutterMode = imageStyle.getDeclutterMode();\n      if (declutterMode !== 'none') {\n        imageBuilderGroup = declutterBuilderGroup;\n        if (declutterMode === 'obstacle') {\n          // draw in non-declutter group:\n          const imageReplay = builderGroup.getBuilder(\n            style.getZIndex(),\n            'Image'\n          );\n          imageReplay.setImageStyle(imageStyle, declutterImageWithText);\n          imageReplay.drawMultiPoint(geometry, feature);\n        } else if (textStyle && textStyle.getText()) {\n          declutterImageWithText = {};\n        }\n      }\n    }\n    const imageReplay = imageBuilderGroup.getBuilder(\n      style.getZIndex(),\n      'Image'\n    );\n    imageReplay.setImageStyle(imageStyle, declutterImageWithText);\n    imageReplay.drawMultiPoint(geometry, feature);\n  }\n  if (textStyle && textStyle.getText()) {\n    let textBuilderGroup = builderGroup;\n    if (declutterBuilderGroup) {\n      textBuilderGroup = declutterBuilderGroup;\n    }\n    const textReplay = textBuilderGroup.getBuilder(style.getZIndex(), 'Text');\n    textReplay.setTextStyle(textStyle, declutterImageWithText);\n    textReplay.drawText(geometry, feature);\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/Polygon.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderPolygonGeometry(\n  builderGroup,\n  geometry,\n  style,\n  feature,\n  declutterBuilderGroup\n) {\n  const fillStyle = style.getFill();\n  const strokeStyle = style.getStroke();\n  if (fillStyle || strokeStyle) {\n    const polygonReplay = builderGroup.getBuilder(style.getZIndex(), 'Polygon');\n    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);\n    polygonReplay.drawPolygon(geometry, feature);\n  }\n  const textStyle = style.getText();\n  if (textStyle && textStyle.getText()) {\n    const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(\n      style.getZIndex(),\n      'Text'\n    );\n    textReplay.setTextStyle(textStyle);\n    textReplay.drawText(geometry, feature);\n  }\n}\n","/**\n * @module ol/renderer/webgl/Layer\n */\nimport LayerProperty from '../../layer/Property.js';\nimport LayerRenderer from '../Layer.js';\nimport RenderEvent from '../../render/Event.js';\nimport RenderEventType from '../../render/EventType.js';\nimport WebGLHelper from '../../webgl/Helper.js';\nimport {\n  compose as composeTransform,\n  create as createTransform,\n} from '../../transform.js';\n\n/**\n * @typedef {Object} PostProcessesOptions\n * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than\n * the main canvas that will then be sampled up (useful for saving resource on blur steps).\n * @property {string} [vertexShader] Vertex shader source\n * @property {string} [fragmentShader] Fragment shader source\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process step\n */\n\n/**\n * @typedef {Object} Options\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process steps\n * @property {Array<PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n\n/**\n * @classdesc\n * Base WebGL renderer class.\n * Holds all logic related to data manipulation & some common rendering logic\n * @template {import(\"../../layer/Layer.js\").default} LayerType\n * @extends {LayerRenderer<LayerType>}\n */\nclass WebGLLayerRenderer extends LayerRenderer {\n  /**\n   * @param {LayerType} layer Layer.\n   * @param {Options} [options] Options.\n   */\n  constructor(layer, options) {\n    super(layer);\n\n    options = options || {};\n\n    /**\n     * The transform for viewport CSS pixels to rendered pixels.  This transform is only\n     * set before dispatching rendering events.\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.inversePixelTransform_ = createTransform();\n\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n    this.pixelContext_ = null;\n\n    /**\n     * @private\n     */\n    this.postProcesses_ = options.postProcesses;\n\n    /**\n     * @private\n     */\n    this.uniforms_ = options.uniforms;\n\n    /**\n     * @type {WebGLHelper}\n     * @protected\n     */\n    this.helper;\n\n    layer.addChangeListener(LayerProperty.MAP, this.removeHelper.bind(this));\n\n    this.dispatchPreComposeEvent = this.dispatchPreComposeEvent.bind(this);\n    this.dispatchPostComposeEvent = this.dispatchPostComposeEvent.bind(this);\n  }\n\n  /**\n   * @param {WebGLRenderingContext} context The WebGL rendering context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  dispatchPreComposeEvent(context, frameState) {\n    const layer = this.getLayer();\n    if (layer.hasListener(RenderEventType.PRECOMPOSE)) {\n      const event = new RenderEvent(\n        RenderEventType.PRECOMPOSE,\n        undefined,\n        frameState,\n        context\n      );\n      layer.dispatchEvent(event);\n    }\n  }\n\n  /**\n   * @param {WebGLRenderingContext} context The WebGL rendering context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  dispatchPostComposeEvent(context, frameState) {\n    const layer = this.getLayer();\n    if (layer.hasListener(RenderEventType.POSTCOMPOSE)) {\n      const event = new RenderEvent(\n        RenderEventType.POSTCOMPOSE,\n        undefined,\n        frameState,\n        context\n      );\n      layer.dispatchEvent(event);\n    }\n  }\n\n  /**\n   * Reset options (only handles uniforms).\n   * @param {Options} options Options.\n   */\n  reset(options) {\n    this.uniforms_ = options.uniforms;\n    if (this.helper) {\n      this.helper.setUniforms(this.uniforms_);\n    }\n  }\n\n  /**\n   * @protected\n   */\n  removeHelper() {\n    if (this.helper) {\n      this.helper.dispose();\n      delete this.helper;\n    }\n  }\n\n  /**\n   * Determine whether renderFrame should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    if (this.getLayer().getRenderSource()) {\n      let incrementGroup = true;\n      let groupNumber = -1;\n      let className;\n      for (let i = 0, ii = frameState.layerStatesArray.length; i < ii; i++) {\n        const layer = frameState.layerStatesArray[i].layer;\n        const renderer = layer.getRenderer();\n        if (!(renderer instanceof WebGLLayerRenderer)) {\n          incrementGroup = true;\n          continue;\n        }\n        const layerClassName = layer.getClassName();\n        if (incrementGroup || layerClassName !== className) {\n          groupNumber += 1;\n          incrementGroup = false;\n        }\n        className = layerClassName;\n        if (renderer === this) {\n          break;\n        }\n      }\n\n      const canvasCacheKey =\n        'map/' + frameState.mapId + '/group/' + groupNumber;\n\n      if (!this.helper || !this.helper.canvasCacheKeyMatches(canvasCacheKey)) {\n        this.removeHelper();\n\n        this.helper = new WebGLHelper({\n          postProcesses: this.postProcesses_,\n          uniforms: this.uniforms_,\n          canvasCacheKey: canvasCacheKey,\n        });\n\n        if (className) {\n          this.helper.getCanvas().className = className;\n        }\n\n        this.afterHelperCreated();\n      }\n    }\n\n    return this.prepareFrameInternal(frameState);\n  }\n\n  /**\n   * @protected\n   */\n  afterHelperCreated() {}\n\n  /**\n   * Determine whether renderFrame should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   * @protected\n   */\n  prepareFrameInternal(frameState) {\n    return true;\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    this.removeHelper();\n    super.disposeInternal();\n  }\n\n  /**\n   * @param {import(\"../../render/EventType.js\").default} type Event type.\n   * @param {WebGLRenderingContext} context The rendering context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @private\n   */\n  dispatchRenderEvent_(type, context, frameState) {\n    const layer = this.getLayer();\n    if (layer.hasListener(type)) {\n      composeTransform(\n        this.inversePixelTransform_,\n        0,\n        0,\n        frameState.pixelRatio,\n        -frameState.pixelRatio,\n        0,\n        0,\n        -frameState.size[1]\n      );\n\n      const event = new RenderEvent(\n        type,\n        this.inversePixelTransform_,\n        frameState,\n        context\n      );\n      layer.dispatchEvent(event);\n    }\n  }\n\n  /**\n   * @param {WebGLRenderingContext} context The rendering context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  preRender(context, frameState) {\n    this.dispatchRenderEvent_(RenderEventType.PRERENDER, context, frameState);\n  }\n\n  /**\n   * @param {WebGLRenderingContext} context The rendering context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  postRender(context, frameState) {\n    this.dispatchRenderEvent_(RenderEventType.POSTRENDER, context, frameState);\n  }\n}\n\nexport default WebGLLayerRenderer;\n","/**\n * @module ol/render/webgl/constants\n */\n\n/**\n * @enum {string}\n */\nexport const WebGLWorkerMessageType = {\n  GENERATE_POLYGON_BUFFERS: 'GENERATE_POLYGON_BUFFERS',\n  GENERATE_POINT_BUFFERS: 'GENERATE_POINT_BUFFERS',\n  GENERATE_LINE_STRING_BUFFERS: 'GENERATE_LINE_STRING_BUFFERS',\n};\n\n/**\n * @typedef {Object} WebGLWorkerGenerateBuffersMessage\n * This message will trigger the generation of a vertex and an index buffer based on the given render instructions.\n * When the buffers are generated, the worked will send a message of the same type to the main thread, with\n * the generated buffers in it.\n * Note that any addition properties present in the message *will* be sent back to the main thread.\n * @property {number} id Message id; will be used both in request and response as a means of identification\n * @property {WebGLWorkerMessageType} type Message type\n * @property {ArrayBuffer} renderInstructions Polygon render instructions raw binary buffer.\n * @property {number} [customAttributesSize] Amount of custom attributes count in the polygon render instructions.\n * @property {ArrayBuffer} [vertexBuffer] Vertices array raw binary buffer (sent by the worker).\n * @property {ArrayBuffer} [indexBuffer] Indices array raw binary buffer (sent by the worker).\n * @property {import(\"../../transform\").Transform} [renderInstructionsTransform] Transformation matrix used to project the instructions coordinates\n */\n","/**\n * @module ol/render/webgl/utils\n */\nimport earcut from 'earcut';\nimport {apply as applyTransform} from '../../transform.js';\nimport {clamp} from '../../math.js';\n\nconst tmpArray_ = [];\n\n/**\n * An object holding positions both in an index and a vertex buffer.\n * @typedef {Object} BufferPositions\n * @property {number} vertexPosition Position in the vertex buffer\n * @property {number} indexPosition Position in the index buffer\n */\nconst bufferPositions_ = {vertexPosition: 0, indexPosition: 0};\n\nfunction writePointVertex(buffer, pos, x, y, index) {\n  buffer[pos + 0] = x;\n  buffer[pos + 1] = y;\n  buffer[pos + 2] = index;\n}\n\n/**\n * Pushes a quad (two triangles) based on a point geometry\n * @param {Float32Array} instructions Array of render instructions for points.\n * @param {number} elementIndex Index from which render instructions will be read.\n * @param {Float32Array} vertexBuffer Buffer in the form of a typed array.\n * @param {Uint32Array} indexBuffer Buffer in the form of a typed array.\n * @param {number} customAttributesSize Amount of custom attributes for each element.\n * @param {BufferPositions} [bufferPositions] Buffer write positions; if not specified, positions will be set at 0.\n * @return {BufferPositions} New buffer positions where to write next\n * @property {number} vertexPosition New position in the vertex buffer where future writes should start.\n * @property {number} indexPosition New position in the index buffer where future writes should start.\n * @private\n */\nexport function writePointFeatureToBuffers(\n  instructions,\n  elementIndex,\n  vertexBuffer,\n  indexBuffer,\n  customAttributesSize,\n  bufferPositions\n) {\n  // This is for x, y and index\n  const baseVertexAttrsCount = 3;\n  const baseInstructionsCount = 2;\n  const stride = baseVertexAttrsCount + customAttributesSize;\n\n  const x = instructions[elementIndex + 0];\n  const y = instructions[elementIndex + 1];\n\n  // read custom numerical attributes on the feature\n  const customAttrs = tmpArray_;\n  customAttrs.length = customAttributesSize;\n  for (let i = 0; i < customAttrs.length; i++) {\n    customAttrs[i] = instructions[elementIndex + baseInstructionsCount + i];\n  }\n\n  let vPos = bufferPositions ? bufferPositions.vertexPosition : 0;\n  let iPos = bufferPositions ? bufferPositions.indexPosition : 0;\n  const baseIndex = vPos / stride;\n\n  // push vertices for each of the four quad corners (first standard then custom attributes)\n  writePointVertex(vertexBuffer, vPos, x, y, 0);\n  customAttrs.length &&\n    vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n\n  writePointVertex(vertexBuffer, vPos, x, y, 1);\n  customAttrs.length &&\n    vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n\n  writePointVertex(vertexBuffer, vPos, x, y, 2);\n  customAttrs.length &&\n    vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n\n  writePointVertex(vertexBuffer, vPos, x, y, 3);\n  customAttrs.length &&\n    vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n\n  indexBuffer[iPos++] = baseIndex;\n  indexBuffer[iPos++] = baseIndex + 1;\n  indexBuffer[iPos++] = baseIndex + 3;\n  indexBuffer[iPos++] = baseIndex + 1;\n  indexBuffer[iPos++] = baseIndex + 2;\n  indexBuffer[iPos++] = baseIndex + 3;\n\n  bufferPositions_.vertexPosition = vPos;\n  bufferPositions_.indexPosition = iPos;\n\n  return bufferPositions_;\n}\n\n/**\n * Pushes a single quad to form a line segment; also includes a computation for the join angles with previous and next\n * segment, in order to be able to offset the vertices correctly in the shader\n * @param {Float32Array} instructions Array of render instructions for lines.\n * @param {number} segmentStartIndex Index of the segment start point from which render instructions will be read.\n * @param {number} segmentEndIndex Index of the segment start point from which render instructions will be read.\n * @param {number|null} beforeSegmentIndex Index of the point right before the segment (null if none, e.g this is a line start)\n * @param {number|null} afterSegmentIndex Index of the point right after the segment (null if none, e.g this is a line end)\n * @param {Array<number>} vertexArray Array containing vertices.\n * @param {Array<number>} indexArray Array containing indices.\n * @param {Array<number>} customAttributes Array of custom attributes value\n * @param {import('../../transform.js').Transform} instructionsTransform Transform matrix used to project coordinates in instructions\n * @param {import('../../transform.js').Transform} invertInstructionsTransform Transform matrix used to project coordinates in instructions\n * @private\n */\nexport function writeLineSegmentToBuffers(\n  instructions,\n  segmentStartIndex,\n  segmentEndIndex,\n  beforeSegmentIndex,\n  afterSegmentIndex,\n  vertexArray,\n  indexArray,\n  customAttributes,\n  instructionsTransform,\n  invertInstructionsTransform\n) {\n  // compute the stride to determine how many vertices were already pushed\n  const baseVertexAttrsCount = 5; // base attributes: x0, y0, x1, y1, params (vertex number [0-3], join angle 1, join angle 2)\n  const stride = baseVertexAttrsCount + customAttributes.length;\n  const baseIndex = vertexArray.length / stride;\n\n  // The segment is composed of two positions called P0[x0, y0] and P1[x1, y1]\n  // Depending on whether there are points before and after the segment, its final shape\n  // will be different\n  const p0 = [\n    instructions[segmentStartIndex + 0],\n    instructions[segmentStartIndex + 1],\n  ];\n  const p1 = [instructions[segmentEndIndex], instructions[segmentEndIndex + 1]];\n\n  // to compute offsets from the line center we need to reproject\n  // coordinates back in world units and compute the length of the segment\n  const p0world = applyTransform(invertInstructionsTransform, [...p0]);\n  const p1world = applyTransform(invertInstructionsTransform, [...p1]);\n\n  function computeVertexParameters(vertexNumber, joinAngle1, joinAngle2) {\n    const shift = 10000;\n    const anglePrecision = 1500;\n    return (\n      Math.round(joinAngle1 * anglePrecision) +\n      Math.round(joinAngle2 * anglePrecision) * shift +\n      vertexNumber * shift * shift\n    );\n  }\n\n  // compute the angle between p0pA and p0pB\n  // returns a value in [0, 2PI]\n  function angleBetween(p0, pA, pB) {\n    const lenA = Math.sqrt(\n      (pA[0] - p0[0]) * (pA[0] - p0[0]) + (pA[1] - p0[1]) * (pA[1] - p0[1])\n    );\n    const tangentA = [(pA[0] - p0[0]) / lenA, (pA[1] - p0[1]) / lenA];\n    const orthoA = [-tangentA[1], tangentA[0]];\n    const lenB = Math.sqrt(\n      (pB[0] - p0[0]) * (pB[0] - p0[0]) + (pB[1] - p0[1]) * (pB[1] - p0[1])\n    );\n    const tangentB = [(pB[0] - p0[0]) / lenB, (pB[1] - p0[1]) / lenB];\n\n    // this angle can be clockwise or anticlockwise; hence the computation afterwards\n    const angle =\n      lenA === 0 || lenB === 0\n        ? 0\n        : Math.acos(\n            clamp(tangentB[0] * tangentA[0] + tangentB[1] * tangentA[1], -1, 1)\n          );\n    const isClockwise = tangentB[0] * orthoA[0] + tangentB[1] * orthoA[1] > 0;\n    return !isClockwise ? Math.PI * 2 - angle : angle;\n  }\n\n  const joinBefore = beforeSegmentIndex !== null;\n  const joinAfter = afterSegmentIndex !== null;\n\n  let angle0 = 0;\n  let angle1 = 0;\n\n  // add vertices and adapt offsets for P0 in case of join\n  if (joinBefore) {\n    // B for before\n    const pB = [\n      instructions[beforeSegmentIndex],\n      instructions[beforeSegmentIndex + 1],\n    ];\n    const pBworld = applyTransform(invertInstructionsTransform, [...pB]);\n    angle0 = angleBetween(p0world, p1world, pBworld);\n  }\n  // adapt offsets for P1 in case of join\n  if (joinAfter) {\n    // A for after\n    const pA = [\n      instructions[afterSegmentIndex],\n      instructions[afterSegmentIndex + 1],\n    ];\n    const pAworld = applyTransform(invertInstructionsTransform, [...pA]);\n    angle1 = angleBetween(p1world, p0world, pAworld);\n  }\n\n  // add main segment triangles\n  vertexArray.push(\n    p0[0],\n    p0[1],\n    p1[0],\n    p1[1],\n    computeVertexParameters(0, angle0, angle1)\n  );\n  vertexArray.push(...customAttributes);\n\n  vertexArray.push(\n    p0[0],\n    p0[1],\n    p1[0],\n    p1[1],\n    computeVertexParameters(1, angle0, angle1)\n  );\n  vertexArray.push(...customAttributes);\n\n  vertexArray.push(\n    p0[0],\n    p0[1],\n    p1[0],\n    p1[1],\n    computeVertexParameters(2, angle0, angle1)\n  );\n  vertexArray.push(...customAttributes);\n\n  vertexArray.push(\n    p0[0],\n    p0[1],\n    p1[0],\n    p1[1],\n    computeVertexParameters(3, angle0, angle1)\n  );\n  vertexArray.push(...customAttributes);\n\n  indexArray.push(\n    baseIndex,\n    baseIndex + 1,\n    baseIndex + 2,\n    baseIndex + 1,\n    baseIndex + 3,\n    baseIndex + 2\n  );\n}\n\n/**\n * Pushes several triangles to form a polygon, including holes\n * @param {Float32Array} instructions Array of render instructions for lines.\n * @param {number} polygonStartIndex Index of the polygon start point from which render instructions will be read.\n * @param {Array<number>} vertexArray Array containing vertices.\n * @param {Array<number>} indexArray Array containing indices.\n * @param {number} customAttributesSize Amount of custom attributes for each element.\n * @return {number} Next polygon instructions index\n * @private\n */\nexport function writePolygonTrianglesToBuffers(\n  instructions,\n  polygonStartIndex,\n  vertexArray,\n  indexArray,\n  customAttributesSize\n) {\n  const instructionsPerVertex = 2; // x, y\n  const attributesPerVertex = 2 + customAttributesSize;\n  let instructionsIndex = polygonStartIndex;\n  const customAttributes = instructions.slice(\n    instructionsIndex,\n    instructionsIndex + customAttributesSize\n  );\n  instructionsIndex += customAttributesSize;\n  const ringsCount = instructions[instructionsIndex++];\n  let verticesCount = 0;\n  const holes = new Array(ringsCount - 1);\n  for (let i = 0; i < ringsCount; i++) {\n    verticesCount += instructions[instructionsIndex++];\n    if (i < ringsCount - 1) {\n      holes[i] = verticesCount;\n    }\n  }\n  const flatCoords = instructions.slice(\n    instructionsIndex,\n    instructionsIndex + verticesCount * instructionsPerVertex\n  );\n\n  // pushing to vertices and indices!! this is where the magic happens\n  const result = earcut(flatCoords, holes, instructionsPerVertex);\n  for (let i = 0; i < result.length; i++) {\n    indexArray.push(result[i] + vertexArray.length / attributesPerVertex);\n  }\n  for (let i = 0; i < flatCoords.length; i += 2) {\n    vertexArray.push(flatCoords[i], flatCoords[i + 1], ...customAttributes);\n  }\n\n  return instructionsIndex + verticesCount * instructionsPerVertex;\n}\n\n/**\n * Returns a texture of 1x1 pixel, white\n * @private\n * @return {ImageData} Image data.\n */\nexport function getBlankImageData() {\n  const canvas = document.createElement('canvas');\n  const image = canvas.getContext('2d').createImageData(1, 1);\n  image.data[0] = 255;\n  image.data[1] = 255;\n  image.data[2] = 255;\n  image.data[3] = 255;\n  return image;\n}\n\n/**\n * Generates a color array based on a numerical id\n * Note: the range for each component is 0 to 1 with 256 steps\n * @param {number} id Id\n * @param {Array<number>} [array] Reusable array\n * @return {Array<number>} Color array containing the encoded id\n */\nexport function colorEncodeId(id, array) {\n  array = array || [];\n  const radix = 256;\n  const divide = radix - 1;\n  array[0] = Math.floor(id / radix / radix / radix) / divide;\n  array[1] = (Math.floor(id / radix / radix) % radix) / divide;\n  array[2] = (Math.floor(id / radix) % radix) / divide;\n  array[3] = (id % radix) / divide;\n  return array;\n}\n\n/**\n * Reads an id from a color-encoded array\n * Note: the expected range for each component is 0 to 1 with 256 steps.\n * @param {Array<number>} color Color array containing the encoded id\n * @return {number} Decoded id\n */\nexport function colorDecodeId(color) {\n  let id = 0;\n  const radix = 256;\n  const mult = radix - 1;\n  id += Math.round(color[0] * radix * radix * radix * mult);\n  id += Math.round(color[1] * radix * radix * mult);\n  id += Math.round(color[2] * radix * mult);\n  id += Math.round(color[3] * mult);\n  return id;\n}\n","/**\n * @module ol/renderer/webgl/PointsLayer\n */\nimport BaseVector from '../../layer/BaseVector.js';\nimport VectorEventType from '../../source/VectorEventType.js';\nimport ViewHint from '../../ViewHint.js';\nimport WebGLArrayBuffer from '../../webgl/Buffer.js';\nimport WebGLLayerRenderer from './Layer.js';\nimport WebGLRenderTarget from '../../webgl/RenderTarget.js';\nimport {ARRAY_BUFFER, DYNAMIC_DRAW, ELEMENT_ARRAY_BUFFER} from '../../webgl.js';\nimport {AttributeType, DefaultUniform} from '../../webgl/Helper.js';\nimport {WebGLWorkerMessageType} from '../../render/webgl/constants.js';\nimport {\n  apply as applyTransform,\n  create as createTransform,\n  makeInverse as makeInverseTransform,\n  multiply as multiplyTransform,\n  translate as translateTransform,\n} from '../../transform.js';\nimport {assert} from '../../asserts.js';\nimport {buffer, createEmpty, equals, getWidth} from '../../extent.js';\nimport {colorDecodeId, colorEncodeId} from '../../render/webgl/utils.js';\nimport {create as createWebGLWorker} from '../../worker/webgl.js';\nimport {getUid} from '../../util.js';\nimport {listen, unlistenByKey} from '../../events.js';\n\n/**\n * @typedef {Object} CustomAttribute A description of a custom attribute to be passed on to the GPU, with a value different\n * for each feature.\n * @property {string} name Attribute name.\n * @property {function(import(\"../../Feature\").default, Object<string, *>):number} callback This callback computes the numerical value of the\n * attribute for a given feature (properties are available as 2nd arg for quicker access).\n */\n\n/**\n * @typedef {Object} FeatureCacheItem Object that holds a reference to a feature, its geometry and properties. Used to optimize\n * rebuildBuffers by accessing these objects quicker.\n * @property {import(\"../../Feature\").default} feature Feature\n * @property {Object<string, *>} properties Feature properties\n * @property {import(\"../../geom\").Geometry} geometry Feature geometry\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the canvas element.\n * @property {Array<CustomAttribute>} [attributes] These attributes will be read from the features in the source and then\n * passed to the GPU. The `name` property of each attribute will serve as its identifier:\n *  * In the vertex shader as an `attribute` by prefixing it with `a_`\n *  * In the fragment shader as a `varying` by prefixing it with `v_`\n * Please note that these can only be numerical values.\n * @property {string} vertexShader Vertex shader source, mandatory.\n * @property {string} fragmentShader Fragment shader source, mandatory.\n * @property {boolean} [hitDetectionEnabled] Whether shader is hit detection aware.\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process steps\n * Please note that `u_texture` is reserved for the main texture slot and `u_opacity` is reserved for the layer opacity.\n * @property {Array<import(\"./Layer\").PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n\n/**\n * @classdesc\n * WebGL vector renderer optimized for points.\n * All features will be rendered as quads (two triangles forming a square). New data will be flushed to the GPU\n * every time the vector source changes.\n *\n * You need to provide vertex and fragment shaders for rendering. This can be done using\n * {@link module:ol/webgl/ShaderBuilder~ShaderBuilder} utilities. These shaders shall expect a `a_position` attribute\n * containing the screen-space projected center of the quad, as well as a `a_index` attribute\n * whose value (0, 1, 2 or 3) indicates which quad vertex is currently getting processed (see structure below).\n *\n * To include variable attributes in the shaders, you need to declare them using the `attributes` property of\n * the options object like so:\n * ```js\n * new WebGLPointsLayerRenderer(layer, {\n *   attributes: [\n *     {\n *       name: 'size',\n *       callback: function(feature) {\n *         // compute something with the feature\n *       }\n *     },\n *     {\n *       name: 'weight',\n *       callback: function(feature) {\n *         // compute something with the feature\n *       }\n *     },\n *   ],\n *   vertexShader:\n *     // shader using attribute a_weight and a_size\n *   fragmentShader:\n *     // shader using varying v_weight and v_size\n * ```\n *\n * To enable hit detection, you must as well provide dedicated shaders using the `hitVertexShader`\n * and `hitFragmentShader` properties. These shall expect the `a_hitColor` attribute to contain\n * the final color that will have to be output for hit detection to work.\n *\n * The following uniform is used for the main texture: `u_texture`.\n * The following uniform is used for the layer opacity: `u_opacity`.\n *\n * Please note that the main shader output should have premultiplied alpha, otherwise visual anomalies may occur.\n *\n * Points are rendered as quads with the following structure:\n *\n * ```\n *   (u0, v1)      (u1, v1)\n *  [3]----------[2]\n *   |`           |\n *   |  `         |\n *   |    `       |\n *   |      `     |\n *   |        `   |\n *   |          ` |\n *  [0]----------[1]\n *   (u0, v0)      (u1, v0)\n *  ```\n *\n * This uses {@link module:ol/webgl/Helper~WebGLHelper} internally.\n *\n * @api\n */\nclass WebGLPointsLayerRenderer extends WebGLLayerRenderer {\n  /**\n   * @param {import(\"../../layer/Layer.js\").default} layer Layer.\n   * @param {Options} options Options.\n   */\n  constructor(layer, options) {\n    const uniforms = options.uniforms || {};\n    const projectionMatrixTransform = createTransform();\n    uniforms[DefaultUniform.PROJECTION_MATRIX] = projectionMatrixTransform;\n\n    super(layer, {\n      uniforms: uniforms,\n      postProcesses: options.postProcesses,\n    });\n\n    this.sourceRevision_ = -1;\n\n    this.verticesBuffer_ = new WebGLArrayBuffer(ARRAY_BUFFER, DYNAMIC_DRAW);\n    this.indicesBuffer_ = new WebGLArrayBuffer(\n      ELEMENT_ARRAY_BUFFER,\n      DYNAMIC_DRAW\n    );\n\n    /**\n     * @private\n     */\n    this.vertexShader_ = options.vertexShader;\n\n    /**\n     * @private\n     */\n    this.fragmentShader_ = options.fragmentShader;\n\n    /**\n     * @type {WebGLProgram}\n     * @private\n     */\n    this.program_;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hitDetectionEnabled_ = options.hitDetectionEnabled ?? true;\n\n    const customAttributes = options.attributes\n      ? options.attributes.map(function (attribute) {\n          return {\n            name: 'a_' + attribute.name,\n            size: 1,\n            type: AttributeType.FLOAT,\n          };\n        })\n      : [];\n\n    /**\n     * A list of attributes used by the renderer. By default only the position and\n     * index of the vertex (0 to 3) are required.\n     * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n     */\n    this.attributes = [\n      {\n        name: 'a_position',\n        size: 2,\n        type: AttributeType.FLOAT,\n      },\n      {\n        name: 'a_index',\n        size: 1,\n        type: AttributeType.FLOAT,\n      },\n    ];\n\n    if (this.hitDetectionEnabled_) {\n      this.attributes.push({\n        name: 'a_hitColor',\n        size: 4,\n        type: AttributeType.FLOAT,\n      });\n      this.attributes.push({\n        name: 'a_featureUid',\n        size: 1,\n        type: AttributeType.FLOAT,\n      });\n    }\n    this.attributes.push(...customAttributes);\n\n    this.customAttributes = options.attributes ? options.attributes : [];\n\n    this.previousExtent_ = createEmpty();\n\n    /**\n     * This transform is updated on every frame and is the composition of:\n     * - invert of the world->screen transform that was used when rebuilding buffers (see `this.renderTransform_`)\n     * - current world->screen transform\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.currentTransform_ = projectionMatrixTransform;\n\n    /**\n     * This transform is updated when buffers are rebuilt and converts world space coordinates to screen space\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.renderTransform_ = createTransform();\n\n    /**\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.invertRenderTransform_ = createTransform();\n\n    /**\n     * @type {Float32Array}\n     * @private\n     */\n    this.renderInstructions_ = new Float32Array(0);\n\n    /**\n     * @type {WebGLRenderTarget}\n     * @private\n     */\n    this.hitRenderTarget_;\n\n    /**\n     * Keep track of latest message sent to worker\n     * @type {number}\n     * @private\n     */\n    this.lastSentId = 0;\n\n    /**\n     * @private\n     */\n    this.worker_ = createWebGLWorker();\n\n    this.worker_.addEventListener(\n      'message',\n      /**\n       * @param {*} event Event.\n       */\n      (event) => {\n        const received = event.data;\n        if (received.type === WebGLWorkerMessageType.GENERATE_POINT_BUFFERS) {\n          const projectionTransform = received.projectionTransform;\n          this.verticesBuffer_.fromArrayBuffer(received.vertexBuffer);\n          this.helper.flushBufferData(this.verticesBuffer_);\n          this.indicesBuffer_.fromArrayBuffer(received.indexBuffer);\n          this.helper.flushBufferData(this.indicesBuffer_);\n\n          this.renderTransform_ = projectionTransform;\n          makeInverseTransform(\n            this.invertRenderTransform_,\n            this.renderTransform_\n          );\n          this.renderInstructions_ = new Float32Array(\n            event.data.renderInstructions\n          );\n          if (received.id === this.lastSentId) {\n            this.ready = true;\n          }\n          this.getLayer().changed();\n        }\n      }\n    );\n\n    /**\n     * This object will be updated when the source changes. Key is uid.\n     * @type {Object<string, FeatureCacheItem>}\n     * @private\n     */\n    this.featureCache_ = {};\n\n    /**\n     * Amount of features in the cache.\n     * @type {number}\n     * @private\n     */\n    this.featureCount_ = 0;\n\n    const source = this.getLayer().getSource();\n    this.sourceListenKeys_ = [\n      listen(\n        source,\n        VectorEventType.ADDFEATURE,\n        this.handleSourceFeatureAdded_,\n        this\n      ),\n      listen(\n        source,\n        VectorEventType.CHANGEFEATURE,\n        this.handleSourceFeatureChanged_,\n        this\n      ),\n      listen(\n        source,\n        VectorEventType.REMOVEFEATURE,\n        this.handleSourceFeatureDelete_,\n        this\n      ),\n      listen(\n        source,\n        VectorEventType.CLEAR,\n        this.handleSourceFeatureClear_,\n        this\n      ),\n    ];\n    source.forEachFeature((feature) => {\n      this.featureCache_[getUid(feature)] = {\n        feature: feature,\n        properties: feature.getProperties(),\n        geometry: feature.getGeometry(),\n      };\n      this.featureCount_++;\n    });\n  }\n\n  afterHelperCreated() {\n    this.program_ = this.helper.getProgram(\n      this.fragmentShader_,\n      this.vertexShader_\n    );\n\n    if (this.hitDetectionEnabled_) {\n      this.hitRenderTarget_ = new WebGLRenderTarget(this.helper);\n    }\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureAdded_(event) {\n    const feature = event.feature;\n    this.featureCache_[getUid(feature)] = {\n      feature: feature,\n      properties: feature.getProperties(),\n      geometry: feature.getGeometry(),\n    };\n    this.featureCount_++;\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureChanged_(event) {\n    const feature = event.feature;\n    this.featureCache_[getUid(feature)] = {\n      feature: feature,\n      properties: feature.getProperties(),\n      geometry: feature.getGeometry(),\n    };\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureDelete_(event) {\n    const feature = event.feature;\n    delete this.featureCache_[getUid(feature)];\n    this.featureCount_--;\n  }\n\n  /**\n   * @private\n   */\n  handleSourceFeatureClear_() {\n    this.featureCache_ = {};\n    this.featureCount_ = 0;\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState) {\n    const gl = this.helper.getGL();\n    this.preRender(gl, frameState);\n\n    const [startWorld, endWorld, worldWidth] =\n      this.getWorldParameters_(frameState);\n\n    // draw the normal canvas\n    this.renderWorlds(frameState, false, startWorld, endWorld, worldWidth);\n\n    this.helper.finalizeDraw(\n      frameState,\n      this.dispatchPreComposeEvent,\n      this.dispatchPostComposeEvent\n    );\n    const canvas = this.helper.getCanvas();\n\n    if (this.hitDetectionEnabled_) {\n      this.renderWorlds(frameState, true, startWorld, endWorld, worldWidth);\n      this.hitRenderTarget_.clearCachedData();\n    }\n\n    this.postRender(gl, frameState);\n\n    return canvas;\n  }\n\n  /**\n   * Compute world params\n   * @private\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {Array<number>} The world start, end and width.\n   */\n  getWorldParameters_(frameState) {\n    const projection = frameState.viewState.projection;\n    const layer = this.getLayer();\n    const vectorSource = layer.getSource();\n    // FIXME fix hit detection isn't reliable when rendering multiple worlds\n    const multiWorld = vectorSource.getWrapX() && projection.canWrapX();\n    const projectionExtent = projection.getExtent();\n\n    const extent = frameState.extent;\n    const worldWidth = multiWorld ? getWidth(projectionExtent) : null;\n    const endWorld = multiWorld\n      ? Math.ceil((extent[2] - projectionExtent[2]) / worldWidth) + 1\n      : 1;\n\n    const startWorld = multiWorld\n      ? Math.floor((extent[0] - projectionExtent[0]) / worldWidth)\n      : 0;\n\n    return [startWorld, endWorld, worldWidth];\n  }\n\n  /**\n   * Determine whether renderFrame should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrameInternal(frameState) {\n    const layer = this.getLayer();\n    const vectorSource = layer.getSource();\n    const viewState = frameState.viewState;\n    const viewNotMoving =\n      !frameState.viewHints[ViewHint.ANIMATING] &&\n      !frameState.viewHints[ViewHint.INTERACTING];\n    const extentChanged = !equals(this.previousExtent_, frameState.extent);\n    const sourceChanged = this.sourceRevision_ < vectorSource.getRevision();\n\n    if (sourceChanged) {\n      this.sourceRevision_ = vectorSource.getRevision();\n    }\n\n    if (viewNotMoving && (extentChanged || sourceChanged)) {\n      const projection = viewState.projection;\n      const resolution = viewState.resolution;\n\n      const renderBuffer =\n        layer instanceof BaseVector ? layer.getRenderBuffer() : 0;\n      const extent = buffer(frameState.extent, renderBuffer * resolution);\n      vectorSource.loadFeatures(extent, resolution, projection);\n\n      this.rebuildBuffers_(frameState);\n      this.previousExtent_ = frameState.extent.slice();\n    }\n\n    this.helper.useProgram(this.program_, frameState);\n    this.helper.prepareDraw(frameState);\n\n    // write new data\n    this.helper.bindBuffer(this.verticesBuffer_);\n    this.helper.bindBuffer(this.indicesBuffer_);\n    this.helper.enableAttributes(this.attributes);\n\n    return true;\n  }\n\n  /**\n   * Rebuild internal webgl buffers based on current view extent; costly, should not be called too much\n   * @param {import(\"../../Map\").FrameState} frameState Frame state.\n   * @private\n   */\n  rebuildBuffers_(frameState) {\n    // saves the projection transform for the current frame state\n    const projectionTransform = createTransform();\n    this.helper.makeProjectionTransform(frameState, projectionTransform);\n\n    const baseInstructionLength = this.hitDetectionEnabled_ ? 7 : 2; // see below\n    const singleInstructionLength =\n      baseInstructionLength + this.customAttributes.length;\n    const totalSize = singleInstructionLength * this.featureCount_;\n    if (\n      !this.renderInstructions_ ||\n      this.renderInstructions_.length !== totalSize\n    ) {\n      this.renderInstructions_ = new Float32Array(totalSize);\n    }\n\n    // loop on features to fill the buffer\n    let featureCache, geometry;\n    const tmpCoords = [];\n    const tmpColor = [];\n    let idx = -1;\n    for (const featureUid in this.featureCache_) {\n      featureCache = this.featureCache_[featureUid];\n      geometry = /** @type {import(\"../../geom\").Point} */ (\n        featureCache.geometry\n      );\n      if (!geometry || geometry.getType() !== 'Point') {\n        continue;\n      }\n      tmpCoords[0] = geometry.getFlatCoordinates()[0];\n      tmpCoords[1] = geometry.getFlatCoordinates()[1];\n      applyTransform(projectionTransform, tmpCoords);\n\n      this.renderInstructions_[++idx] = tmpCoords[0];\n      this.renderInstructions_[++idx] = tmpCoords[1];\n\n      // for hit detection, the feature uid is saved in the opacity value\n      // and the index of the opacity value is encoded in the color values\n      if (this.hitDetectionEnabled_) {\n        const hitColor = colorEncodeId(idx + 5, tmpColor);\n        this.renderInstructions_[++idx] = hitColor[0];\n        this.renderInstructions_[++idx] = hitColor[1];\n        this.renderInstructions_[++idx] = hitColor[2];\n        this.renderInstructions_[++idx] = hitColor[3];\n        this.renderInstructions_[++idx] = Number(featureUid);\n      }\n\n      // pushing custom attributes\n      for (let j = 0; j < this.customAttributes.length; j++) {\n        const value = this.customAttributes[j].callback(\n          featureCache.feature,\n          featureCache.properties\n        );\n        this.renderInstructions_[++idx] = value;\n      }\n    }\n\n    /** @type {import('../../render/webgl/constants.js').WebGLWorkerGenerateBuffersMessage} */\n    const message = {\n      id: ++this.lastSentId,\n      type: WebGLWorkerMessageType.GENERATE_POINT_BUFFERS,\n      renderInstructions: this.renderInstructions_.buffer,\n      customAttributesSize: singleInstructionLength - 2,\n    };\n    // additional properties will be sent back as-is by the worker\n    message['projectionTransform'] = projectionTransform;\n    this.ready = false;\n    this.worker_.postMessage(message, [this.renderInstructions_.buffer]);\n    this.renderInstructions_ = null;\n  }\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches\n  ) {\n    assert(this.hitDetectionEnabled_, 66);\n    if (!this.renderInstructions_ || !this.hitDetectionEnabled_) {\n      return undefined;\n    }\n\n    const pixel = applyTransform(\n      frameState.coordinateToPixelTransform,\n      coordinate.slice()\n    );\n\n    const data = this.hitRenderTarget_.readPixel(pixel[0] / 2, pixel[1] / 2);\n    const color = [data[0] / 255, data[1] / 255, data[2] / 255, data[3] / 255];\n    const index = colorDecodeId(color);\n    const opacity = this.renderInstructions_[index];\n    const uid = Math.floor(opacity).toString();\n\n    const source = this.getLayer().getSource();\n    const feature = source.getFeatureByUid(uid);\n    if (feature) {\n      return callback(feature, this.getLayer(), null);\n    }\n    return undefined;\n  }\n\n  /**\n   * Render the world, either to the main framebuffer or to the hit framebuffer\n   * @param {import(\"../../Map.js\").FrameState} frameState current frame state\n   * @param {boolean} forHitDetection whether the rendering is for hit detection\n   * @param {number} startWorld the world to render in the first iteration\n   * @param {number} endWorld the last world to render\n   * @param {number} worldWidth the width of the worlds being rendered\n   */\n  renderWorlds(frameState, forHitDetection, startWorld, endWorld, worldWidth) {\n    let world = startWorld;\n\n    this.helper.useProgram(this.program_, frameState);\n\n    if (forHitDetection) {\n      this.hitRenderTarget_.setSize([\n        Math.floor(frameState.size[0] / 2),\n        Math.floor(frameState.size[1] / 2),\n      ]);\n      this.helper.prepareDrawToRenderTarget(\n        frameState,\n        this.hitRenderTarget_,\n        true\n      );\n    }\n\n    this.helper.bindBuffer(this.verticesBuffer_);\n    this.helper.bindBuffer(this.indicesBuffer_);\n    this.helper.enableAttributes(this.attributes);\n\n    do {\n      this.helper.makeProjectionTransform(frameState, this.currentTransform_);\n      translateTransform(this.currentTransform_, world * worldWidth, 0);\n      multiplyTransform(this.currentTransform_, this.invertRenderTransform_);\n      this.helper.applyUniforms(frameState);\n      this.helper.applyHitDetectionUniform(forHitDetection);\n      const renderCount = this.indicesBuffer_.getSize();\n      this.helper.drawElements(0, renderCount);\n    } while (++world < endWorld);\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    this.worker_.terminate();\n    this.layer_ = null;\n    this.sourceListenKeys_.forEach(function (key) {\n      unlistenByKey(key);\n    });\n    this.sourceListenKeys_ = null;\n    super.disposeInternal();\n  }\n}\n\nexport default WebGLPointsLayerRenderer;\n"],"names":["MapRenderer","Disposable","constructor","map","super","this","map_","dispatchRenderEvent","type","frameState","calculateMatrices2D","viewState","coordinateToPixelTransform","pixelToCoordinateTransform","size","resolution","rotation","center","forEachFeatureAtCoordinate","coordinate","hitTolerance","checkWrapped","callback","thisArg","layerFilter","thisArg2","result","managed","feature","layer","geometry","call","projection","translatedCoordinate","slice","offsets","canWrapX","projectionExtent","getExtent","worldWidth","push","layerStates","layerStatesArray","numLayers","length","matches","tmpCoord","i","j","layerState","hasRenderer","layerRenderer","getRenderer","source","getSource","coordinates","getWrapX","bind","order","forEach","m","distanceSq","sort","a","b","some","hasFeatureAtCoordinate","hasFeature","undefined","getMap","renderFrame","flushDeclutterItems","scheduleExpireIconCache","canExpireCache","postRenderFunctions","expireIconCache","expire","CompositeMapRenderer","Map","fontChangeListenerKey_","ObjectEventType","PROPERTYCHANGE","redrawText","element_","document","createElement","style","position","width","height","zIndex","className","container","getViewport","insertBefore","firstChild","children_","renderedVisible_","declutterLayers_","hasListener","event","dispatchEvent","disposeInternal","parentNode","removeChild","display","PRECOMPOSE","declutterLayers","previousElement","ii","layerIndex","sourceState","getSourceState","unrender","element","render","POSTCOMPOSE","layers","renderDeclutter","LayerRenderer","ready","boundHandleImageChange_","handleImageChange_","layer_","declutterExecutorGroup","getFeatures","pixel","getData","prepareFrame","target","loadedTileCallback","tiles","zoom","tile","tileCoord","toString","createLoadedTileFinder","tileRange","forEachLoadedTile","getLayer","handleFontsChanged","image","getState","LOADED","ERROR","renderIfReadyAndVisible","loadImage","imageState","addEventListener","CHANGE","IDLE","load","getVisible","changed","CanvasImageLayerRenderer","imageLayer","image_","getImage","pixelRatio","viewResolution","imageSource","hints","viewHints","renderedExtent","extent","fromUserExtent","ANIMATING","INTERACTING","EMPTY","layerExtent","imageExtent","img","imageMapWidth","col","Math","floor","imageMapHeight","row","getImageData","imageResolution","getResolution","imagePixelRatio","getPixelRatio","viewCenter","scale","round","pixelTransform","inversePixelTransform","canvasTransform","useContainer","getBackground","context","canvas","containerReused","clearRect","clipped","clipUnrotated","transform","tempTransform","renderedResolution","dw","dh","getInterpolate","imageSmoothingEnabled","preRender","dx","dy","opacity","previousAlpha","globalAlpha","drawImage","postRender","restore","canvasPool","pixelContext","createPixelContext","willReadFrequently","CanvasLayerRenderer","pixelContext_","data","err","background","backgroundColor","layerClassName","getClassName","firstElementChild","HTMLCanvasElement","getContext","appendChild","left","transformOrigin","topLeft","topRight","bottomRight","bottomLeft","inverted","save","beginPath","moveTo","lineTo","clip","dispatchRenderEvent_","PRERENDER","POSTRENDER","getRenderTransform","offsetX","dx1","dy1","sx","sy","dx2","dy2","CanvasTileLayerRenderer","tileLayer","extentChanged","renderedExtent_","renderedPixelRatio","renderedProjection","renderedRevision","renderedTiles","newTiles_","tmpExtent","tmpTileRange_","isDrawableTile","tileState","useInterimTilesOnError","getUseInterimTilesOnError","getTile","z","x","y","tileSource","getPreload","getInterimTile","getRenderSource","tileGrid","getTileGridForProjection","tilePixelRatio","getTilePixelRatio","getZForResolution","getMinZoom","getTileCoordForCoordAndZ","tileOrigin","getOrigin","tileSize","getTileSize","tileResolution","gutter","getGutterForProjection","sourceRevision","getRevision","zDirection","canvasExtent","getTileRangeForExtentAndZ","tilesToDrawByZ","findLoadedTiles","tmpTileRange","viewport","minX","maxX","minY","maxY","tileCoordIntersectsViewport","uid","inTransition","endTransition","includes","getAlpha","time","childTileRange","getTileCoordChildTileRange","covered","forEachTileCoordParentTileRange","canvasScale","clips","clipZs","currentClip","zs","Object","keys","Number","getOpaque","reverse","currentZ","currentTilePixelSize","getTilePixelSize","currentResolution","currentScale","originTileCoord","originTileExtent","getTileCoordExtent","origin","tileGutter","tilesToDraw","tileCoordKey","xIndex","nextX","yIndex","nextY","w","h","transition","contextSaved","drawTileImage","unshift","updateUsedTiles","usedTiles","manageTilePyramid","scheduleExpireCache","getTileImage","alpha","alphaChanged","animate","postRenderFunction","tileSourceKey","expireCache","getKey","preload","tileCallback","wantedTiles","tileQueue","minZoom","tileCount","isKeyQueued","enqueue","getTileCoordCenter","useTile","updateCacheSize","CanvasVectorLayerRenderer","vectorLayer","boundHandleStyleImageChange_","handleStyleImageChange_","animatingOrInteracting_","hitDetectionImageData_","renderedFeatures_","renderedRevision_","renderedResolution_","NaN","wrappedRenderedExtent_","renderedRotation_","renderedCenter_","renderedProjection_","renderedRenderOrder_","replayGroup_","replayGroupChanged","clipping","compositionContext_","opacity_","renderWorlds","executorGroup","declutterTree","vectorSource","snapToPixel","multiWorld","endWorld","ceil","world","execute","setupCompositionContext_","compositionContext","releaseCompositionContext_","replayGroup","isEmpty","hasRenderListeners","Promise","resolve","transforms","startX","getStyleFunction","features","featureCallback","key","match","splice","lastIndexOf","executorGroups","all","item","value","animating","interacting","updateWhileAnimating","getUpdateWhileAnimating","updateWhileInteracting","getUpdateWhileInteracting","frameStateExtent","vectorLayerRevision","vectorLayerRenderBuffer","getRenderBuffer","vectorLayerRenderOrder","getRenderOrder","loadExtents","max","loadExtent","declutterBuilderGroup","getDeclutter","userProjection","getUserProjection","userTransform","userExtent","toUserExtent","loadFeatures","toUserResolution","getTransformFromProjections","squaredTolerance","styles","styleFunction","dirty","renderFeature","getFeaturesInExtent","replayGroupInstructions","finish","getOverlaps","builderGroup","loading","Array","isArray","IMAGE_REPLAYS","VECTOR_REPLAYS","CanvasVectorTileLayerRenderer","renderedLayerRevision_","renderedPixelToCoordinateTransform_","tmpTransform_","prepareTile","state","updateExecutorGroup_","tileImageNeedsRender_","hifi","wantedResolution","Date","now","getRenderMode","renderTileImage_","hasContext","layerRevision","revision","renderOrder","builderState","getReplayState","renderedRenderOrder","declutter","sourceTileGrid","getTileGrid","tileExtent","wrappedTileCoord","sourceTiles","getSourceTiles","layerUid","hitDetectionImageData","declutterExecutorGroups","t","tt","sourceTile","sourceTileCoord","sourceTileExtent","sharedExtent","builderExtent","bufferedExtent","getGeometry","executorGroupInstructions","replayExtent","renderingReplayGroup","hitExtent","getId","found","declutteredFeatures","reject","getTileCoordForCoordAndResolution","loadingSourceTiles","corner","tilePixel","reduce","accumulator","concat","getOpacity","getTileRenderTransform","worldOffset","renderMode","replayTypes","filter","group","hasExecutors","getClipCoords","jj","replayState","renderedTileResolution","renderedTileRevision","renderPixelRatio","renderScale","setTransform","apply","pixelScale","SIMPLIFY_TOLERANCE","GEOMETRY_RENDERERS","renderPointGeometry","renderLineStringGeometry","renderPolygonGeometry","renderMultiPointGeometry","renderMultiLineStringGeometry","renderMultiPolygonGeometry","renderGeometryCollectionGeometry","renderCircleGeometry","defaultOrder","feature1","feature2","parseInt","getSquaredTolerance","tolerance","getTolerance","fillStyle","getFill","strokeStyle","getStroke","circleReplay","getBuilder","getZIndex","setFillStrokeStyle","drawCircle","textStyle","getText","textReplay","setTextStyle","drawText","listener","imageStyle","getImageState","unlistenImageChange","listenImageChange","renderFeatureInternal","getGeometryFunction","simplifiedGeometry","simplifyTransformed","renderer","renderGeometry","geometryRenderer","getType","geometries","getGeometries","replay","drawCustom","getHitDetectionRenderer","getGeometriesArray","lineStringReplay","drawLineString","drawMultiLineString","polygonReplay","drawMultiPolygon","declutterImageWithText","imageBuilderGroup","declutterMode","getDeclutterMode","imageReplay","setImageStyle","drawPoint","textBuilderGroup","drawMultiPoint","drawPolygon","WebGLLayerRenderer","options","inversePixelTransform_","postProcesses_","postProcesses","uniforms_","uniforms","helper","addChangeListener","MAP","removeHelper","dispatchPreComposeEvent","dispatchPostComposeEvent","reset","setUniforms","dispose","incrementGroup","groupNumber","canvasCacheKey","mapId","canvasCacheKeyMatches","getCanvas","afterHelperCreated","prepareFrameInternal","WebGLWorkerMessageType","GENERATE_POLYGON_BUFFERS","GENERATE_POINT_BUFFERS","GENERATE_LINE_STRING_BUFFERS","colorEncodeId","id","array","radix","divide","colorDecodeId","color","mult","WebGLPointsLayerRenderer","projectionMatrixTransform","PROJECTION_MATRIX","sourceRevision_","verticesBuffer_","indicesBuffer_","vertexShader_","vertexShader","fragmentShader_","fragmentShader","program_","hitDetectionEnabled_","hitDetectionEnabled","customAttributes","attributes","attribute","name","FLOAT","previousExtent_","currentTransform_","renderTransform_","invertRenderTransform_","renderInstructions_","Float32Array","hitRenderTarget_","lastSentId","worker_","received","projectionTransform","fromArrayBuffer","vertexBuffer","flushBufferData","indexBuffer","renderInstructions","featureCache_","featureCount_","sourceListenKeys_","VectorEventType","ADDFEATURE","handleSourceFeatureAdded_","CHANGEFEATURE","handleSourceFeatureChanged_","REMOVEFEATURE","handleSourceFeatureDelete_","CLEAR","handleSourceFeatureClear_","forEachFeature","properties","getProperties","getProgram","gl","getGL","startWorld","getWorldParameters_","finalizeDraw","clearCachedData","viewNotMoving","ViewHint","sourceChanged","renderBuffer","BaseVector","rebuildBuffers_","useProgram","prepareDraw","bindBuffer","enableAttributes","makeProjectionTransform","baseInstructionLength","singleInstructionLength","totalSize","featureCache","tmpCoords","tmpColor","idx","featureUid","getFlatCoordinates","hitColor","message","buffer","customAttributesSize","postMessage","readPixel","index","getFeatureByUid","forHitDetection","setSize","prepareDrawToRenderTarget","applyUniforms","applyHitDetectionUniform","renderCount","getSize","drawElements","terminate"],"sourceRoot":""}
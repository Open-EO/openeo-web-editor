{"version":3,"sources":["webpack:///./node_modules/ol/tilegrid/common.js","webpack:///./node_modules/ol/tilegrid.js","webpack:///./node_modules/ol/util.js","webpack:///./node_modules/ol/tilecoord.js","webpack:///./node_modules/ol/tilegrid/WMTS.js","webpack:///./node_modules/ol/tilegrid/TileGrid.js","webpack:///./node_modules/ol/tileurlfunction.js","webpack:///./node_modules/ol/transform.js","webpack:///./node_modules/ol/uri.js"],"names":["DEFAULT_MAX_ZOOM","DEFAULT_TILE_SIZE","getForProjection","projection","tileGrid","getDefaultTileGrid","createForProjection","setDefaultTileGrid","wrapX","tileCoord","z","center","getTileCoordCenter","projectionExtent","extentFromProjection","worldWidth","worldsAway","Math","ceil","getTileCoordForCoordAndZ","createForExtent","extent","opt_maxZoom","opt_tileSize","opt_corner","corner","undefined","TOP_LEFT","resolutions","resolutionsFromExtent","origin","tileSize","createXYZ","opt_options","xyzOptions","getExtent","gridOptions","minZoom","maxZoom","maxResolution","opt_maxResolution","height","width","max","length","Array","pow","half","DEGREES","getMetersPerUnit","abstract","Error","uidCounter_","getUid","obj","ol_uid","String","VERSION","createOrUpdate","x","y","opt_tileCoord","getKeyZXY","getKey","fromKey","key","split","map","Number","hash","withinExtentAndZ","getMinZoom","getMaxZoom","tileRange","getFullTileRange","containsXY","__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","p","prototype","hasOwnProperty","call","TypeError","__","this","constructor","create","WMTSTileGrid","_super","options","_this","origins","tileSizes","sizes","matrixIds_","matrixIds","getMatrixId","getMatrixIds","createFromCapabilitiesMatrixSet","matrixSet","opt_extent","opt_matrixLimits","matrixLimits","supportedCRSPropName","matrixIdsPropName","identifierPropName","scaleDenominatorPropName","topLeftCornerPropName","tileWidthPropName","tileHeightPropName","code","metersPerUnit","switchOriginXY","getAxisOrientation","substr","sort","a","forEach","elt","matrixAvailable","elt_ml","indexOf","push","resolution","tileWidth","tileHeight","tmpTileCoord","TileGrid","zoomFactor","resolutions_","i","ii","zoomFactor_","origin_","origins_","tileSizes_","tileSize_","extent_","fullTileRanges_","tmpSize_","tmpExtent_","size","min","restrictedTileRange","getTileRangeForExtentAndZ","minX","maxX","minY","maxY","calculateTileRanges_","forEachTileCoord","zoom","callback","j","jj","forEachTileCoordParentTileRange","opt_tileRange","tileCoordExtent","getTileCoordExtent","floor","getOrigin","getResolution","getResolutions","getTileCoordChildTileRange","getTileRangeForTileCoordAndZ","tileCoordZ","tileCoordX","tileCoordY","factor","getTileRangeExtent","getTileSize","getTileCoordForXYAndZ_","getTileCoordForCoordAndResolution","coordinate","getTileCoordForXYAndResolution_","reverseIntersectionPolicy","getZForResolution","scale","adjustX","adjustY","xFromOrigin","yFromOrigin","getTileCoordResolution","opt_direction","fullTileRanges","createFromTemplate","template","zRegEx","xRegEx","yRegEx","dashYRegEx","pixelRatio","replace","toString","range","getHeight","createFromTemplates","templates","len","tileUrlFunctions","createFromTileUrlFunctions","h","index","expandUrl","url","urls","match","exec","startCharCode","charCodeAt","stopCharCode","charCode","fromCharCode","stop_1","parseInt","transformStringDiv","tmp_","reset","transform","set","multiply","transform1","transform2","a1","b1","c1","d1","e1","f1","a2","b2","c2","d2","e2","f2","c","e","f","setFromArray","apply","rotate","angle","cos","sin","makeScale","target","translate","dx","dy","compose","dx1","dy1","sx","sy","dx2","dy2","makeInverse","source","det","determinant","mat","transformString","join","node","document","createElement","style","appendParams","uri","params","keyParams","keys","k","encodeURIComponent","qs"],"mappings":"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","file":"js/chunk-7470100f.1738bad3.js","sourcesContent":["/**\n * @module ol/tilegrid/common\n */\n/**\n * Default maximum zoom for default tile grids.\n * @type {number}\n */\nexport var DEFAULT_MAX_ZOOM = 42;\n/**\n * Default tile size.\n * @type {number}\n */\nexport var DEFAULT_TILE_SIZE = 256;\n//# sourceMappingURL=common.js.map","/**\n * @module ol/tilegrid\n */\nimport Corner from './extent/Corner.js';\nimport TileGrid from './tilegrid/TileGrid.js';\nimport Units from './proj/Units.js';\nimport { DEFAULT_MAX_ZOOM, DEFAULT_TILE_SIZE } from './tilegrid/common.js';\nimport { METERS_PER_UNIT, get as getProjection } from './proj.js';\nimport { containsCoordinate, createOrUpdate, getCorner, getHeight, getWidth, } from './extent.js';\nimport { toSize } from './size.js';\n/**\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {!TileGrid} Default tile grid for the\n * passed projection.\n */\nexport function getForProjection(projection) {\n    var tileGrid = projection.getDefaultTileGrid();\n    if (!tileGrid) {\n        tileGrid = createForProjection(projection);\n        projection.setDefaultTileGrid(tileGrid);\n    }\n    return tileGrid;\n}\n/**\n * @param {TileGrid} tileGrid Tile grid.\n * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {import(\"./tilecoord.js\").TileCoord} Tile coordinate.\n */\nexport function wrapX(tileGrid, tileCoord, projection) {\n    var z = tileCoord[0];\n    var center = tileGrid.getTileCoordCenter(tileCoord);\n    var projectionExtent = extentFromProjection(projection);\n    if (!containsCoordinate(projectionExtent, center)) {\n        var worldWidth = getWidth(projectionExtent);\n        var worldsAway = Math.ceil((projectionExtent[0] - center[0]) / worldWidth);\n        center[0] += worldWidth * worldsAway;\n        return tileGrid.getTileCoordForCoordAndZ(center, z);\n    }\n    else {\n        return tileCoord;\n    }\n}\n/**\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number} [opt_maxZoom] Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size} [opt_tileSize] Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {import(\"./extent/Corner.js\").default} [opt_corner] Extent corner (default is `'top-left'`).\n * @return {!TileGrid} TileGrid instance.\n */\nexport function createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner) {\n    var corner = opt_corner !== undefined ? opt_corner : Corner.TOP_LEFT;\n    var resolutions = resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize);\n    return new TileGrid({\n        extent: extent,\n        origin: getCorner(extent, corner),\n        resolutions: resolutions,\n        tileSize: opt_tileSize,\n    });\n}\n/**\n * @typedef {Object} XYZOptions\n * @property {import(\"./extent.js\").Extent} [extent] Extent for the tile grid. The origin for an XYZ tile grid is the\n * top-left corner of the extent. If `maxResolution` is not provided the zero level of the grid is defined by the resolution\n * at which one tile fits in the provided extent. If not provided, the extent of the EPSG:3857 projection is used.\n * @property {number} [maxResolution] Resolution at level zero.\n * @property {number} [maxZoom] Maximum zoom. The default is `42`. This determines the number of levels\n * in the grid set. For example, a `maxZoom` of 21 means there are 22 levels in the grid set.\n * @property {number} [minZoom=0] Minimum zoom.\n * @property {number|import(\"./size.js\").Size} [tileSize=[256, 256]] Tile size in pixels.\n */\n/**\n * Creates a tile grid with a standard XYZ tiling scheme.\n * @param {XYZOptions} [opt_options] Tile grid options.\n * @return {!TileGrid} Tile grid instance.\n * @api\n */\nexport function createXYZ(opt_options) {\n    var xyzOptions = opt_options || {};\n    var extent = xyzOptions.extent || getProjection('EPSG:3857').getExtent();\n    var gridOptions = {\n        extent: extent,\n        minZoom: xyzOptions.minZoom,\n        tileSize: xyzOptions.tileSize,\n        resolutions: resolutionsFromExtent(extent, xyzOptions.maxZoom, xyzOptions.tileSize, xyzOptions.maxResolution),\n    };\n    return new TileGrid(gridOptions);\n}\n/**\n * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number} [opt_maxZoom] Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size} [opt_tileSize] Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {number} [opt_maxResolution] Resolution at level zero.\n * @return {!Array<number>} Resolutions array.\n */\nfunction resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize, opt_maxResolution) {\n    var maxZoom = opt_maxZoom !== undefined ? opt_maxZoom : DEFAULT_MAX_ZOOM;\n    var height = getHeight(extent);\n    var width = getWidth(extent);\n    var tileSize = toSize(opt_tileSize !== undefined ? opt_tileSize : DEFAULT_TILE_SIZE);\n    var maxResolution = opt_maxResolution > 0\n        ? opt_maxResolution\n        : Math.max(width / tileSize[0], height / tileSize[1]);\n    var length = maxZoom + 1;\n    var resolutions = new Array(length);\n    for (var z = 0; z < length; ++z) {\n        resolutions[z] = maxResolution / Math.pow(2, z);\n    }\n    return resolutions;\n}\n/**\n * @param {import(\"./proj.js\").ProjectionLike} projection Projection.\n * @param {number} [opt_maxZoom] Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size} [opt_tileSize] Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {import(\"./extent/Corner.js\").default} [opt_corner] Extent corner (default is `'top-left'`).\n * @return {!TileGrid} TileGrid instance.\n */\nexport function createForProjection(projection, opt_maxZoom, opt_tileSize, opt_corner) {\n    var extent = extentFromProjection(projection);\n    return createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner);\n}\n/**\n * Generate a tile grid extent from a projection.  If the projection has an\n * extent, it is used.  If not, a global extent is assumed.\n * @param {import(\"./proj.js\").ProjectionLike} projection Projection.\n * @return {import(\"./extent.js\").Extent} Extent.\n */\nexport function extentFromProjection(projection) {\n    projection = getProjection(projection);\n    var extent = projection.getExtent();\n    if (!extent) {\n        var half = (180 * METERS_PER_UNIT[Units.DEGREES]) / projection.getMetersPerUnit();\n        extent = createOrUpdate(-half, -half, half, half);\n    }\n    return extent;\n}\n//# sourceMappingURL=tilegrid.js.map","/**\n * @module ol/util\n */\n/**\n * @return {?} Any return.\n */\nexport function abstract() {\n    return /** @type {?} */ ((function () {\n        throw new Error('Unimplemented abstract method.');\n    })());\n}\n/**\n * Counter for getUid.\n * @type {number}\n * @private\n */\nvar uidCounter_ = 0;\n/**\n * Gets a unique ID for an object. This mutates the object so that further calls\n * with the same object as a parameter returns the same value. Unique IDs are generated\n * as a strictly increasing sequence. Adapted from goog.getUid.\n *\n * @param {Object} obj The object to get the unique ID for.\n * @return {string} The unique ID for the object.\n * @api\n */\nexport function getUid(obj) {\n    return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));\n}\n/**\n * OpenLayers version.\n * @type {string}\n */\nexport var VERSION = '6.6.1';\n//# sourceMappingURL=util.js.map","/**\n * @module ol/tilecoord\n */\n/**\n * An array of three numbers representing the location of a tile in a tile\n * grid. The order is `z` (zoom level), `x` (column), and `y` (row).\n * @typedef {Array<number>} TileCoord\n * @api\n */\n/**\n * @param {number} z Z.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {TileCoord} [opt_tileCoord] Tile coordinate.\n * @return {TileCoord} Tile coordinate.\n */\nexport function createOrUpdate(z, x, y, opt_tileCoord) {\n    if (opt_tileCoord !== undefined) {\n        opt_tileCoord[0] = z;\n        opt_tileCoord[1] = x;\n        opt_tileCoord[2] = y;\n        return opt_tileCoord;\n    }\n    else {\n        return [z, x, y];\n    }\n}\n/**\n * @param {number} z Z.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {string} Key.\n */\nexport function getKeyZXY(z, x, y) {\n    return z + '/' + x + '/' + y;\n}\n/**\n * Get the key for a tile coord.\n * @param {TileCoord} tileCoord The tile coord.\n * @return {string} Key.\n */\nexport function getKey(tileCoord) {\n    return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);\n}\n/**\n * Get the tile cache key for a tile key obtained through `tile.getKey()`.\n * @param {string} tileKey The tile key.\n * @return {string} The cache key.\n */\nexport function getCacheKeyForTileKey(tileKey) {\n    var _a = tileKey\n        .substring(tileKey.lastIndexOf('/') + 1, tileKey.length)\n        .split(',')\n        .map(Number), z = _a[0], x = _a[1], y = _a[2];\n    return getKeyZXY(z, x, y);\n}\n/**\n * Get a tile coord given a key.\n * @param {string} key The tile coord key.\n * @return {TileCoord} The tile coord.\n */\nexport function fromKey(key) {\n    return key.split('/').map(Number);\n}\n/**\n * @param {TileCoord} tileCoord Tile coord.\n * @return {number} Hash.\n */\nexport function hash(tileCoord) {\n    return (tileCoord[1] << tileCoord[0]) + tileCoord[2];\n}\n/**\n * @param {TileCoord} tileCoord Tile coordinate.\n * @param {!import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {boolean} Tile coordinate is within extent and zoom level range.\n */\nexport function withinExtentAndZ(tileCoord, tileGrid) {\n    var z = tileCoord[0];\n    var x = tileCoord[1];\n    var y = tileCoord[2];\n    if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {\n        return false;\n    }\n    var tileRange = tileGrid.getFullTileRange(z);\n    if (!tileRange) {\n        return true;\n    }\n    else {\n        return tileRange.containsXY(x, y);\n    }\n}\n//# sourceMappingURL=tilecoord.js.map","/**\n * @module ol/tilegrid/WMTS\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport TileGrid from './TileGrid.js';\nimport { find } from '../array.js';\nimport { get as getProjection } from '../proj.js';\n/**\n * @typedef {Object} Options\n * @property {import(\"../extent.js\").Extent} [extent] Extent for the tile grid. No tiles\n * outside this extent will be requested by {@link module:ol/source/Tile} sources.\n * When no `origin` or `origins` are configured, the `origin` will be set to the\n * top-left corner of the extent.\n * @property {import(\"../coordinate.js\").Coordinate} [origin] The tile grid origin, i.e.\n * where the `x` and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left\n * to right and downwards. If not specified, `extent` or `origins` must be provided.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} [origins] Tile grid origins,\n * i.e. where the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If\n * given, the array length should match the length of the `resolutions` array, i.e.\n * each resolution can have a different origin. Tile coordinates increase left to\n * right and downwards. If not specified, `extent` or `origin` must be provided.\n * @property {!Array<number>} resolutions Resolutions. The array index of each\n * resolution needs to match the zoom level. This means that even if a `minZoom`\n * is configured, the resolutions array will have a length of `maxZoom + 1`\n * @property {!Array<string>} matrixIds matrix IDs. The length of this array needs\n * to match the length of the `resolutions` array.\n * @property {Array<import(\"../size.js\").Size>} [sizes] Number of tile rows and columns\n * of the grid for each zoom level. The values here are the `TileMatrixWidth` and\n * `TileMatrixHeight` advertised in the GetCapabilities response of the WMTS, and\n * define each zoom level's extent together with the `origin` or `origins`.\n * A grid `extent` can be configured in addition, and will further limit the extent for\n * which tile requests are made by sources. If the bottom-left corner of\n * an extent is used as `origin` or `origins`, then the `y` value must be\n * negative because OpenLayers tile coordinates use the top left as the origin.\n * @property {number|import(\"../size.js\").Size} [tileSize] Tile size.\n * @property {Array<import(\"../size.js\").Size>} [tileSizes] Tile sizes. The length of\n * this array needs to match the length of the `resolutions` array.\n */\n/**\n * @classdesc\n * Set the grid pattern for sources accessing WMTS tiled-image servers.\n * @api\n */\nvar WMTSTileGrid = /** @class */ (function (_super) {\n    __extends(WMTSTileGrid, _super);\n    /**\n     * @param {Options} options WMTS options.\n     */\n    function WMTSTileGrid(options) {\n        var _this = _super.call(this, {\n            extent: options.extent,\n            origin: options.origin,\n            origins: options.origins,\n            resolutions: options.resolutions,\n            tileSize: options.tileSize,\n            tileSizes: options.tileSizes,\n            sizes: options.sizes,\n        }) || this;\n        /**\n         * @private\n         * @type {!Array<string>}\n         */\n        _this.matrixIds_ = options.matrixIds;\n        return _this;\n    }\n    /**\n     * @param {number} z Z.\n     * @return {string} MatrixId..\n     */\n    WMTSTileGrid.prototype.getMatrixId = function (z) {\n        return this.matrixIds_[z];\n    };\n    /**\n     * Get the list of matrix identifiers.\n     * @return {Array<string>} MatrixIds.\n     * @api\n     */\n    WMTSTileGrid.prototype.getMatrixIds = function () {\n        return this.matrixIds_;\n    };\n    return WMTSTileGrid;\n}(TileGrid));\nexport default WMTSTileGrid;\n/**\n * Create a tile grid from a WMTS capabilities matrix set and an\n * optional TileMatrixSetLimits.\n * @param {Object} matrixSet An object representing a matrixSet in the\n *     capabilities document.\n * @param {import(\"../extent.js\").Extent} [opt_extent] An optional extent to restrict the tile\n *     ranges the server provides.\n * @param {Array<Object>} [opt_matrixLimits] An optional object representing\n *     the available matrices for tileGrid.\n * @return {WMTSTileGrid} WMTS tileGrid instance.\n * @api\n */\nexport function createFromCapabilitiesMatrixSet(matrixSet, opt_extent, opt_matrixLimits) {\n    /** @type {!Array<number>} */\n    var resolutions = [];\n    /** @type {!Array<string>} */\n    var matrixIds = [];\n    /** @type {!Array<import(\"../coordinate.js\").Coordinate>} */\n    var origins = [];\n    /** @type {!Array<import(\"../size.js\").Size>} */\n    var tileSizes = [];\n    /** @type {!Array<import(\"../size.js\").Size>} */\n    var sizes = [];\n    var matrixLimits = opt_matrixLimits !== undefined ? opt_matrixLimits : [];\n    var supportedCRSPropName = 'SupportedCRS';\n    var matrixIdsPropName = 'TileMatrix';\n    var identifierPropName = 'Identifier';\n    var scaleDenominatorPropName = 'ScaleDenominator';\n    var topLeftCornerPropName = 'TopLeftCorner';\n    var tileWidthPropName = 'TileWidth';\n    var tileHeightPropName = 'TileHeight';\n    var code = matrixSet[supportedCRSPropName];\n    var projection = getProjection(code);\n    var metersPerUnit = projection.getMetersPerUnit();\n    // swap origin x and y coordinates if axis orientation is lat/long\n    var switchOriginXY = projection.getAxisOrientation().substr(0, 2) == 'ne';\n    matrixSet[matrixIdsPropName].sort(function (a, b) {\n        return b[scaleDenominatorPropName] - a[scaleDenominatorPropName];\n    });\n    matrixSet[matrixIdsPropName].forEach(function (elt) {\n        var matrixAvailable;\n        // use of matrixLimits to filter TileMatrices from GetCapabilities\n        // TileMatrixSet from unavailable matrix levels.\n        if (matrixLimits.length > 0) {\n            matrixAvailable = find(matrixLimits, function (elt_ml) {\n                if (elt[identifierPropName] == elt_ml[matrixIdsPropName]) {\n                    return true;\n                }\n                // Fallback for tileMatrix identifiers that don't get prefixed\n                // by their tileMatrixSet identifiers.\n                if (elt[identifierPropName].indexOf(':') === -1) {\n                    return (matrixSet[identifierPropName] + ':' + elt[identifierPropName] ===\n                        elt_ml[matrixIdsPropName]);\n                }\n                return false;\n            });\n        }\n        else {\n            matrixAvailable = true;\n        }\n        if (matrixAvailable) {\n            matrixIds.push(elt[identifierPropName]);\n            var resolution = (elt[scaleDenominatorPropName] * 0.28e-3) / metersPerUnit;\n            var tileWidth = elt[tileWidthPropName];\n            var tileHeight = elt[tileHeightPropName];\n            if (switchOriginXY) {\n                origins.push([\n                    elt[topLeftCornerPropName][1],\n                    elt[topLeftCornerPropName][0],\n                ]);\n            }\n            else {\n                origins.push(elt[topLeftCornerPropName]);\n            }\n            resolutions.push(resolution);\n            tileSizes.push(tileWidth == tileHeight ? tileWidth : [tileWidth, tileHeight]);\n            sizes.push([elt['MatrixWidth'], elt['MatrixHeight']]);\n        }\n    });\n    return new WMTSTileGrid({\n        extent: opt_extent,\n        origins: origins,\n        resolutions: resolutions,\n        matrixIds: matrixIds,\n        tileSizes: tileSizes,\n        sizes: sizes,\n    });\n}\n//# sourceMappingURL=WMTS.js.map","/**\n * @module ol/tilegrid/TileGrid\n */\nimport TileRange, { createOrUpdate as createOrUpdateTileRange, } from '../TileRange.js';\nimport { DEFAULT_TILE_SIZE } from './common.js';\nimport { assert } from '../asserts.js';\nimport { clamp } from '../math.js';\nimport { createOrUpdate, getTopLeft } from '../extent.js';\nimport { createOrUpdate as createOrUpdateTileCoord } from '../tilecoord.js';\nimport { isSorted, linearFindNearest } from '../array.js';\nimport { toSize } from '../size.js';\n/**\n * @private\n * @type {import(\"../tilecoord.js\").TileCoord}\n */\nvar tmpTileCoord = [0, 0, 0];\n/**\n * @typedef {Object} Options\n * @property {import(\"../extent.js\").Extent} [extent] Extent for the tile grid. No tiles outside this\n * extent will be requested by {@link module:ol/source/Tile} sources. When no `origin` or\n * `origins` are configured, the `origin` will be set to the top-left corner of the extent.\n * @property {number} [minZoom=0] Minimum zoom.\n * @property {import(\"../coordinate.js\").Coordinate} [origin] The tile grid origin, i.e. where the `x`\n * and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left to right and downwards. If not\n * specified, `extent` or `origins` must be provided.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} [origins] Tile grid origins, i.e. where\n * the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If given, the array length\n * should match the length of the `resolutions` array, i.e. each resolution can have a different\n * origin. Tile coordinates increase left to right and downwards. If not specified, `extent` or\n * `origin` must be provided.\n * @property {!Array<number>} resolutions Resolutions. The array index of each resolution needs\n * to match the zoom level. This means that even if a `minZoom` is configured, the resolutions\n * array will have a length of `maxZoom + 1`.\n * @property {Array<import(\"../size.js\").Size>} [sizes] Number of tile rows and columns\n * of the grid for each zoom level. If specified the values\n * define each zoom level's extent together with the `origin` or `origins`.\n * A grid `extent` can be configured in addition, and will further limit the extent\n * for which tile requests are made by sources. If the bottom-left corner of\n * an extent is used as `origin` or `origins`, then the `y` value must be\n * negative because OpenLayers tile coordinates use the top left as the origin.\n * @property {number|import(\"../size.js\").Size} [tileSize] Tile size.\n * Default is `[256, 256]`.\n * @property {Array<import(\"../size.js\").Size>} [tileSizes] Tile sizes. If given, the array length\n * should match the length of the `resolutions` array, i.e. each resolution can have a different\n * tile size.\n */\n/**\n * @classdesc\n * Base class for setting the grid pattern for sources accessing tiled-image\n * servers.\n * @api\n */\nvar TileGrid = /** @class */ (function () {\n    /**\n     * @param {Options} options Tile grid options.\n     */\n    function TileGrid(options) {\n        /**\n         * @protected\n         * @type {number}\n         */\n        this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;\n        /**\n         * @private\n         * @type {!Array<number>}\n         */\n        this.resolutions_ = options.resolutions;\n        assert(isSorted(this.resolutions_, function (a, b) {\n            return b - a;\n        }, true), 17); // `resolutions` must be sorted in descending order\n        // check if we've got a consistent zoom factor and origin\n        var zoomFactor;\n        if (!options.origins) {\n            for (var i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {\n                if (!zoomFactor) {\n                    zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];\n                }\n                else {\n                    if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {\n                        zoomFactor = undefined;\n                        break;\n                    }\n                }\n            }\n        }\n        /**\n         * @private\n         * @type {number|undefined}\n         */\n        this.zoomFactor_ = zoomFactor;\n        /**\n         * @protected\n         * @type {number}\n         */\n        this.maxZoom = this.resolutions_.length - 1;\n        /**\n         * @private\n         * @type {import(\"../coordinate.js\").Coordinate}\n         */\n        this.origin_ = options.origin !== undefined ? options.origin : null;\n        /**\n         * @private\n         * @type {Array<import(\"../coordinate.js\").Coordinate>}\n         */\n        this.origins_ = null;\n        if (options.origins !== undefined) {\n            this.origins_ = options.origins;\n            assert(this.origins_.length == this.resolutions_.length, 20); // Number of `origins` and `resolutions` must be equal\n        }\n        var extent = options.extent;\n        if (extent !== undefined && !this.origin_ && !this.origins_) {\n            this.origin_ = getTopLeft(extent);\n        }\n        assert((!this.origin_ && this.origins_) || (this.origin_ && !this.origins_), 18); // Either `origin` or `origins` must be configured, never both\n        /**\n         * @private\n         * @type {Array<number|import(\"../size.js\").Size>}\n         */\n        this.tileSizes_ = null;\n        if (options.tileSizes !== undefined) {\n            this.tileSizes_ = options.tileSizes;\n            assert(this.tileSizes_.length == this.resolutions_.length, 19); // Number of `tileSizes` and `resolutions` must be equal\n        }\n        /**\n         * @private\n         * @type {number|import(\"../size.js\").Size}\n         */\n        this.tileSize_ =\n            options.tileSize !== undefined\n                ? options.tileSize\n                : !this.tileSizes_\n                    ? DEFAULT_TILE_SIZE\n                    : null;\n        assert((!this.tileSize_ && this.tileSizes_) ||\n            (this.tileSize_ && !this.tileSizes_), 22); // Either `tileSize` or `tileSizes` must be configured, never both\n        /**\n         * @private\n         * @type {import(\"../extent.js\").Extent}\n         */\n        this.extent_ = extent !== undefined ? extent : null;\n        /**\n         * @private\n         * @type {Array<import(\"../TileRange.js\").default>}\n         */\n        this.fullTileRanges_ = null;\n        /**\n         * @private\n         * @type {import(\"../size.js\").Size}\n         */\n        this.tmpSize_ = [0, 0];\n        /**\n         * @private\n         * @type {import(\"../extent.js\").Extent}\n         */\n        this.tmpExtent_ = [0, 0, 0, 0];\n        if (options.sizes !== undefined) {\n            this.fullTileRanges_ = options.sizes.map(function (size, z) {\n                var tileRange = new TileRange(Math.min(0, size[0]), Math.max(size[0] - 1, -1), Math.min(0, size[1]), Math.max(size[1] - 1, -1));\n                if (extent) {\n                    var restrictedTileRange = this.getTileRangeForExtentAndZ(extent, z);\n                    tileRange.minX = Math.max(restrictedTileRange.minX, tileRange.minX);\n                    tileRange.maxX = Math.min(restrictedTileRange.maxX, tileRange.maxX);\n                    tileRange.minY = Math.max(restrictedTileRange.minY, tileRange.minY);\n                    tileRange.maxY = Math.min(restrictedTileRange.maxY, tileRange.maxY);\n                }\n                return tileRange;\n            }, this);\n        }\n        else if (extent) {\n            this.calculateTileRanges_(extent);\n        }\n    }\n    /**\n     * Call a function with each tile coordinate for a given extent and zoom level.\n     *\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @param {number} zoom Integer zoom level.\n     * @param {function(import(\"../tilecoord.js\").TileCoord): void} callback Function called with each tile coordinate.\n     * @api\n     */\n    TileGrid.prototype.forEachTileCoord = function (extent, zoom, callback) {\n        var tileRange = this.getTileRangeForExtentAndZ(extent, zoom);\n        for (var i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {\n            for (var j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {\n                callback([zoom, i, j]);\n            }\n        }\n    };\n    /**\n     * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n     * @param {function(number, import(\"../TileRange.js\").default): boolean} callback Callback.\n     * @param {import(\"../TileRange.js\").default} [opt_tileRange] Temporary import(\"../TileRange.js\").default object.\n     * @param {import(\"../extent.js\").Extent} [opt_extent] Temporary import(\"../extent.js\").Extent object.\n     * @return {boolean} Callback succeeded.\n     */\n    TileGrid.prototype.forEachTileCoordParentTileRange = function (tileCoord, callback, opt_tileRange, opt_extent) {\n        var tileRange, x, y;\n        var tileCoordExtent = null;\n        var z = tileCoord[0] - 1;\n        if (this.zoomFactor_ === 2) {\n            x = tileCoord[1];\n            y = tileCoord[2];\n        }\n        else {\n            tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);\n        }\n        while (z >= this.minZoom) {\n            if (this.zoomFactor_ === 2) {\n                x = Math.floor(x / 2);\n                y = Math.floor(y / 2);\n                tileRange = createOrUpdateTileRange(x, x, y, y, opt_tileRange);\n            }\n            else {\n                tileRange = this.getTileRangeForExtentAndZ(tileCoordExtent, z, opt_tileRange);\n            }\n            if (callback(z, tileRange)) {\n                return true;\n            }\n            --z;\n        }\n        return false;\n    };\n    /**\n     * Get the extent for this tile grid, if it was configured.\n     * @return {import(\"../extent.js\").Extent} Extent.\n     * @api\n     */\n    TileGrid.prototype.getExtent = function () {\n        return this.extent_;\n    };\n    /**\n     * Get the maximum zoom level for the grid.\n     * @return {number} Max zoom.\n     * @api\n     */\n    TileGrid.prototype.getMaxZoom = function () {\n        return this.maxZoom;\n    };\n    /**\n     * Get the minimum zoom level for the grid.\n     * @return {number} Min zoom.\n     * @api\n     */\n    TileGrid.prototype.getMinZoom = function () {\n        return this.minZoom;\n    };\n    /**\n     * Get the origin for the grid at the given zoom level.\n     * @param {number} z Integer zoom level.\n     * @return {import(\"../coordinate.js\").Coordinate} Origin.\n     * @api\n     */\n    TileGrid.prototype.getOrigin = function (z) {\n        if (this.origin_) {\n            return this.origin_;\n        }\n        else {\n            return this.origins_[z];\n        }\n    };\n    /**\n     * Get the resolution for the given zoom level.\n     * @param {number} z Integer zoom level.\n     * @return {number} Resolution.\n     * @api\n     */\n    TileGrid.prototype.getResolution = function (z) {\n        return this.resolutions_[z];\n    };\n    /**\n     * Get the list of resolutions for the tile grid.\n     * @return {Array<number>} Resolutions.\n     * @api\n     */\n    TileGrid.prototype.getResolutions = function () {\n        return this.resolutions_;\n    };\n    /**\n     * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n     * @param {import(\"../TileRange.js\").default} [opt_tileRange] Temporary import(\"../TileRange.js\").default object.\n     * @param {import(\"../extent.js\").Extent} [opt_extent] Temporary import(\"../extent.js\").Extent object.\n     * @return {import(\"../TileRange.js\").default} Tile range.\n     */\n    TileGrid.prototype.getTileCoordChildTileRange = function (tileCoord, opt_tileRange, opt_extent) {\n        if (tileCoord[0] < this.maxZoom) {\n            if (this.zoomFactor_ === 2) {\n                var minX = tileCoord[1] * 2;\n                var minY = tileCoord[2] * 2;\n                return createOrUpdateTileRange(minX, minX + 1, minY, minY + 1, opt_tileRange);\n            }\n            var tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent || this.tmpExtent_);\n            return this.getTileRangeForExtentAndZ(tileCoordExtent, tileCoord[0] + 1, opt_tileRange);\n        }\n        return null;\n    };\n    /**\n     * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n     * @param {number} z Integer zoom level.\n     * @param {import(\"../TileRange.js\").default} [opt_tileRange] Temporary import(\"../TileRange.js\").default object.\n     * @return {import(\"../TileRange.js\").default} Tile range.\n     */\n    TileGrid.prototype.getTileRangeForTileCoordAndZ = function (tileCoord, z, opt_tileRange) {\n        if (z > this.maxZoom || z < this.minZoom) {\n            return null;\n        }\n        var tileCoordZ = tileCoord[0];\n        var tileCoordX = tileCoord[1];\n        var tileCoordY = tileCoord[2];\n        if (z === tileCoordZ) {\n            return createOrUpdateTileRange(tileCoordX, tileCoordY, tileCoordX, tileCoordY, opt_tileRange);\n        }\n        if (this.zoomFactor_) {\n            var factor = Math.pow(this.zoomFactor_, z - tileCoordZ);\n            var minX = Math.floor(tileCoordX * factor);\n            var minY = Math.floor(tileCoordY * factor);\n            if (z < tileCoordZ) {\n                return createOrUpdateTileRange(minX, minX, minY, minY, opt_tileRange);\n            }\n            var maxX = Math.floor(factor * (tileCoordX + 1)) - 1;\n            var maxY = Math.floor(factor * (tileCoordY + 1)) - 1;\n            return createOrUpdateTileRange(minX, maxX, minY, maxY, opt_tileRange);\n        }\n        var tileCoordExtent = this.getTileCoordExtent(tileCoord, this.tmpExtent_);\n        return this.getTileRangeForExtentAndZ(tileCoordExtent, z, opt_tileRange);\n    };\n    /**\n     * Get the extent for a tile range.\n     * @param {number} z Integer zoom level.\n     * @param {import(\"../TileRange.js\").default} tileRange Tile range.\n     * @param {import(\"../extent.js\").Extent} [opt_extent] Temporary import(\"../extent.js\").Extent object.\n     * @return {import(\"../extent.js\").Extent} Extent.\n     */\n    TileGrid.prototype.getTileRangeExtent = function (z, tileRange, opt_extent) {\n        var origin = this.getOrigin(z);\n        var resolution = this.getResolution(z);\n        var tileSize = toSize(this.getTileSize(z), this.tmpSize_);\n        var minX = origin[0] + tileRange.minX * tileSize[0] * resolution;\n        var maxX = origin[0] + (tileRange.maxX + 1) * tileSize[0] * resolution;\n        var minY = origin[1] + tileRange.minY * tileSize[1] * resolution;\n        var maxY = origin[1] + (tileRange.maxY + 1) * tileSize[1] * resolution;\n        return createOrUpdate(minX, minY, maxX, maxY, opt_extent);\n    };\n    /**\n     * Get a tile range for the given extent and integer zoom level.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @param {number} z Integer zoom level.\n     * @param {import(\"../TileRange.js\").default} [opt_tileRange] Temporary tile range object.\n     * @return {import(\"../TileRange.js\").default} Tile range.\n     */\n    TileGrid.prototype.getTileRangeForExtentAndZ = function (extent, z, opt_tileRange) {\n        var tileCoord = tmpTileCoord;\n        this.getTileCoordForXYAndZ_(extent[0], extent[3], z, false, tileCoord);\n        var minX = tileCoord[1];\n        var minY = tileCoord[2];\n        this.getTileCoordForXYAndZ_(extent[2], extent[1], z, true, tileCoord);\n        return createOrUpdateTileRange(minX, tileCoord[1], minY, tileCoord[2], opt_tileRange);\n    };\n    /**\n     * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n     * @return {import(\"../coordinate.js\").Coordinate} Tile center.\n     */\n    TileGrid.prototype.getTileCoordCenter = function (tileCoord) {\n        var origin = this.getOrigin(tileCoord[0]);\n        var resolution = this.getResolution(tileCoord[0]);\n        var tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\n        return [\n            origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution,\n            origin[1] - (tileCoord[2] + 0.5) * tileSize[1] * resolution,\n        ];\n    };\n    /**\n     * Get the extent of a tile coordinate.\n     *\n     * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n     * @param {import(\"../extent.js\").Extent} [opt_extent] Temporary extent object.\n     * @return {import(\"../extent.js\").Extent} Extent.\n     * @api\n     */\n    TileGrid.prototype.getTileCoordExtent = function (tileCoord, opt_extent) {\n        var origin = this.getOrigin(tileCoord[0]);\n        var resolution = this.getResolution(tileCoord[0]);\n        var tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\n        var minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;\n        var minY = origin[1] - (tileCoord[2] + 1) * tileSize[1] * resolution;\n        var maxX = minX + tileSize[0] * resolution;\n        var maxY = minY + tileSize[1] * resolution;\n        return createOrUpdate(minX, minY, maxX, maxY, opt_extent);\n    };\n    /**\n     * Get the tile coordinate for the given map coordinate and resolution.  This\n     * method considers that coordinates that intersect tile boundaries should be\n     * assigned the higher tile coordinate.\n     *\n     * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @param {number} resolution Resolution.\n     * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Destination import(\"../tilecoord.js\").TileCoord object.\n     * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n     * @api\n     */\n    TileGrid.prototype.getTileCoordForCoordAndResolution = function (coordinate, resolution, opt_tileCoord) {\n        return this.getTileCoordForXYAndResolution_(coordinate[0], coordinate[1], resolution, false, opt_tileCoord);\n    };\n    /**\n     * Note that this method should not be called for resolutions that correspond\n     * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {number} resolution Resolution (for a non-integer zoom level).\n     * @param {boolean} reverseIntersectionPolicy Instead of letting edge\n     *     intersections go to the higher tile coordinate, let edge intersections\n     *     go to the lower tile coordinate.\n     * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Temporary import(\"../tilecoord.js\").TileCoord object.\n     * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n     * @private\n     */\n    TileGrid.prototype.getTileCoordForXYAndResolution_ = function (x, y, resolution, reverseIntersectionPolicy, opt_tileCoord) {\n        var z = this.getZForResolution(resolution);\n        var scale = resolution / this.getResolution(z);\n        var origin = this.getOrigin(z);\n        var tileSize = toSize(this.getTileSize(z), this.tmpSize_);\n        var adjustX = reverseIntersectionPolicy ? 0.5 : 0;\n        var adjustY = reverseIntersectionPolicy ? 0.5 : 0;\n        var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);\n        var yFromOrigin = Math.floor((origin[1] - y) / resolution + adjustY);\n        var tileCoordX = (scale * xFromOrigin) / tileSize[0];\n        var tileCoordY = (scale * yFromOrigin) / tileSize[1];\n        if (reverseIntersectionPolicy) {\n            tileCoordX = Math.ceil(tileCoordX) - 1;\n            tileCoordY = Math.ceil(tileCoordY) - 1;\n        }\n        else {\n            tileCoordX = Math.floor(tileCoordX);\n            tileCoordY = Math.floor(tileCoordY);\n        }\n        return createOrUpdateTileCoord(z, tileCoordX, tileCoordY, opt_tileCoord);\n    };\n    /**\n     * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,\n     * they should have separate implementations.  This method is for integer zoom\n     * levels.  The other method should only be called for resolutions corresponding\n     * to non-integer zoom levels.\n     * @param {number} x Map x coordinate.\n     * @param {number} y Map y coordinate.\n     * @param {number} z Integer zoom level.\n     * @param {boolean} reverseIntersectionPolicy Instead of letting edge\n     *     intersections go to the higher tile coordinate, let edge intersections\n     *     go to the lower tile coordinate.\n     * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Temporary import(\"../tilecoord.js\").TileCoord object.\n     * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n     * @private\n     */\n    TileGrid.prototype.getTileCoordForXYAndZ_ = function (x, y, z, reverseIntersectionPolicy, opt_tileCoord) {\n        var origin = this.getOrigin(z);\n        var resolution = this.getResolution(z);\n        var tileSize = toSize(this.getTileSize(z), this.tmpSize_);\n        var adjustX = reverseIntersectionPolicy ? 0.5 : 0;\n        var adjustY = reverseIntersectionPolicy ? 0.5 : 0;\n        var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);\n        var yFromOrigin = Math.floor((origin[1] - y) / resolution + adjustY);\n        var tileCoordX = xFromOrigin / tileSize[0];\n        var tileCoordY = yFromOrigin / tileSize[1];\n        if (reverseIntersectionPolicy) {\n            tileCoordX = Math.ceil(tileCoordX) - 1;\n            tileCoordY = Math.ceil(tileCoordY) - 1;\n        }\n        else {\n            tileCoordX = Math.floor(tileCoordX);\n            tileCoordY = Math.floor(tileCoordY);\n        }\n        return createOrUpdateTileCoord(z, tileCoordX, tileCoordY, opt_tileCoord);\n    };\n    /**\n     * Get a tile coordinate given a map coordinate and zoom level.\n     * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @param {number} z Zoom level.\n     * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Destination import(\"../tilecoord.js\").TileCoord object.\n     * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n     * @api\n     */\n    TileGrid.prototype.getTileCoordForCoordAndZ = function (coordinate, z, opt_tileCoord) {\n        return this.getTileCoordForXYAndZ_(coordinate[0], coordinate[1], z, false, opt_tileCoord);\n    };\n    /**\n     * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n     * @return {number} Tile resolution.\n     */\n    TileGrid.prototype.getTileCoordResolution = function (tileCoord) {\n        return this.resolutions_[tileCoord[0]];\n    };\n    /**\n     * Get the tile size for a zoom level. The type of the return value matches the\n     * `tileSize` or `tileSizes` that the tile grid was configured with. To always\n     * get an `import(\"../size.js\").Size`, run the result through `import(\"../size.js\").Size.toSize()`.\n     * @param {number} z Z.\n     * @return {number|import(\"../size.js\").Size} Tile size.\n     * @api\n     */\n    TileGrid.prototype.getTileSize = function (z) {\n        if (this.tileSize_) {\n            return this.tileSize_;\n        }\n        else {\n            return this.tileSizes_[z];\n        }\n    };\n    /**\n     * @param {number} z Zoom level.\n     * @return {import(\"../TileRange.js\").default} Extent tile range for the specified zoom level.\n     */\n    TileGrid.prototype.getFullTileRange = function (z) {\n        if (!this.fullTileRanges_) {\n            return this.extent_\n                ? this.getTileRangeForExtentAndZ(this.extent_, z)\n                : null;\n        }\n        else {\n            return this.fullTileRanges_[z];\n        }\n    };\n    /**\n     * @param {number} resolution Resolution.\n     * @param {number|import(\"../array.js\").NearestDirectionFunction} [opt_direction]\n     *     If 0, the nearest resolution will be used.\n     *     If 1, the nearest higher resolution (lower Z) will be used. If -1, the\n     *     nearest lower resolution (higher Z) will be used. Default is 0.\n     *     Use a {@link module:ol/array~NearestDirectionFunction} for more precise control.\n     *\n     * For example to change tile Z at the midpoint of zoom levels\n     * ```js\n     * function(value, high, low) {\n     *   return value - low * Math.sqrt(high / low);\n     * }\n     * ```\n     * @return {number} Z.\n     * @api\n     */\n    TileGrid.prototype.getZForResolution = function (resolution, opt_direction) {\n        var z = linearFindNearest(this.resolutions_, resolution, opt_direction || 0);\n        return clamp(z, this.minZoom, this.maxZoom);\n    };\n    /**\n     * @param {!import(\"../extent.js\").Extent} extent Extent for this tile grid.\n     * @private\n     */\n    TileGrid.prototype.calculateTileRanges_ = function (extent) {\n        var length = this.resolutions_.length;\n        var fullTileRanges = new Array(length);\n        for (var z = this.minZoom; z < length; ++z) {\n            fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);\n        }\n        this.fullTileRanges_ = fullTileRanges;\n    };\n    return TileGrid;\n}());\nexport default TileGrid;\n//# sourceMappingURL=TileGrid.js.map","/**\n * @module ol/tileurlfunction\n */\nimport { assert } from './asserts.js';\nimport { modulo } from './math.js';\nimport { hash as tileCoordHash } from './tilecoord.js';\n/**\n * @param {string} template Template.\n * @param {import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {import(\"./Tile.js\").UrlFunction} Tile URL function.\n */\nexport function createFromTemplate(template, tileGrid) {\n    var zRegEx = /\\{z\\}/g;\n    var xRegEx = /\\{x\\}/g;\n    var yRegEx = /\\{y\\}/g;\n    var dashYRegEx = /\\{-y\\}/g;\n    return (\n    /**\n     * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile Coordinate.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"./proj/Projection.js\").default} projection Projection.\n     * @return {string|undefined} Tile URL.\n     */\n    function (tileCoord, pixelRatio, projection) {\n        if (!tileCoord) {\n            return undefined;\n        }\n        else {\n            return template\n                .replace(zRegEx, tileCoord[0].toString())\n                .replace(xRegEx, tileCoord[1].toString())\n                .replace(yRegEx, tileCoord[2].toString())\n                .replace(dashYRegEx, function () {\n                var z = tileCoord[0];\n                var range = tileGrid.getFullTileRange(z);\n                assert(range, 55); // The {-y} placeholder requires a tile grid with extent\n                var y = range.getHeight() - tileCoord[2] - 1;\n                return y.toString();\n            });\n        }\n    });\n}\n/**\n * @param {Array<string>} templates Templates.\n * @param {import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {import(\"./Tile.js\").UrlFunction} Tile URL function.\n */\nexport function createFromTemplates(templates, tileGrid) {\n    var len = templates.length;\n    var tileUrlFunctions = new Array(len);\n    for (var i = 0; i < len; ++i) {\n        tileUrlFunctions[i] = createFromTemplate(templates[i], tileGrid);\n    }\n    return createFromTileUrlFunctions(tileUrlFunctions);\n}\n/**\n * @param {Array<import(\"./Tile.js\").UrlFunction>} tileUrlFunctions Tile URL Functions.\n * @return {import(\"./Tile.js\").UrlFunction} Tile URL function.\n */\nexport function createFromTileUrlFunctions(tileUrlFunctions) {\n    if (tileUrlFunctions.length === 1) {\n        return tileUrlFunctions[0];\n    }\n    return (\n    /**\n     * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile Coordinate.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"./proj/Projection.js\").default} projection Projection.\n     * @return {string|undefined} Tile URL.\n     */\n    function (tileCoord, pixelRatio, projection) {\n        if (!tileCoord) {\n            return undefined;\n        }\n        else {\n            var h = tileCoordHash(tileCoord);\n            var index = modulo(h, tileUrlFunctions.length);\n            return tileUrlFunctions[index](tileCoord, pixelRatio, projection);\n        }\n    });\n}\n/**\n * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @param {number} pixelRatio Pixel ratio.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {string|undefined} Tile URL.\n */\nexport function nullTileUrlFunction(tileCoord, pixelRatio, projection) {\n    return undefined;\n}\n/**\n * @param {string} url URL.\n * @return {Array<string>} Array of urls.\n */\nexport function expandUrl(url) {\n    var urls = [];\n    var match = /\\{([a-z])-([a-z])\\}/.exec(url);\n    if (match) {\n        // char range\n        var startCharCode = match[1].charCodeAt(0);\n        var stopCharCode = match[2].charCodeAt(0);\n        var charCode = void 0;\n        for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {\n            urls.push(url.replace(match[0], String.fromCharCode(charCode)));\n        }\n        return urls;\n    }\n    match = /\\{(\\d+)-(\\d+)\\}/.exec(url);\n    if (match) {\n        // number range\n        var stop_1 = parseInt(match[2], 10);\n        for (var i = parseInt(match[1], 10); i <= stop_1; i++) {\n            urls.push(url.replace(match[0], i.toString()));\n        }\n        return urls;\n    }\n    urls.push(url);\n    return urls;\n}\n//# sourceMappingURL=tileurlfunction.js.map","/**\n * @module ol/transform\n */\nimport { WORKER_OFFSCREEN_CANVAS } from './has.js';\nimport { assert } from './asserts.js';\n/**\n * An array representing an affine 2d transformation for use with\n * {@link module:ol/transform} functions. The array has 6 elements.\n * @typedef {!Array<number>} Transform\n * @api\n */\n/**\n * Collection of affine 2d transformation functions. The functions work on an\n * array of 6 elements. The element order is compatible with the [SVGMatrix\n * interface](https://developer.mozilla.org/en-US/docs/Web/API/SVGMatrix) and is\n * a subset (elements a to f) of a 33 matrix:\n * ```\n * [ a c e ]\n * [ b d f ]\n * [ 0 0 1 ]\n * ```\n */\n/**\n * @private\n * @type {Transform}\n */\nvar tmp_ = new Array(6);\n/**\n * Create an identity transform.\n * @return {!Transform} Identity transform.\n */\nexport function create() {\n    return [1, 0, 0, 1, 0, 0];\n}\n/**\n * Resets the given transform to an identity transform.\n * @param {!Transform} transform Transform.\n * @return {!Transform} Transform.\n */\nexport function reset(transform) {\n    return set(transform, 1, 0, 0, 1, 0, 0);\n}\n/**\n * Multiply the underlying matrices of two transforms and return the result in\n * the first transform.\n * @param {!Transform} transform1 Transform parameters of matrix 1.\n * @param {!Transform} transform2 Transform parameters of matrix 2.\n * @return {!Transform} transform1 multiplied with transform2.\n */\nexport function multiply(transform1, transform2) {\n    var a1 = transform1[0];\n    var b1 = transform1[1];\n    var c1 = transform1[2];\n    var d1 = transform1[3];\n    var e1 = transform1[4];\n    var f1 = transform1[5];\n    var a2 = transform2[0];\n    var b2 = transform2[1];\n    var c2 = transform2[2];\n    var d2 = transform2[3];\n    var e2 = transform2[4];\n    var f2 = transform2[5];\n    transform1[0] = a1 * a2 + c1 * b2;\n    transform1[1] = b1 * a2 + d1 * b2;\n    transform1[2] = a1 * c2 + c1 * d2;\n    transform1[3] = b1 * c2 + d1 * d2;\n    transform1[4] = a1 * e2 + c1 * f2 + e1;\n    transform1[5] = b1 * e2 + d1 * f2 + f1;\n    return transform1;\n}\n/**\n * Set the transform components a-f on a given transform.\n * @param {!Transform} transform Transform.\n * @param {number} a The a component of the transform.\n * @param {number} b The b component of the transform.\n * @param {number} c The c component of the transform.\n * @param {number} d The d component of the transform.\n * @param {number} e The e component of the transform.\n * @param {number} f The f component of the transform.\n * @return {!Transform} Matrix with transform applied.\n */\nexport function set(transform, a, b, c, d, e, f) {\n    transform[0] = a;\n    transform[1] = b;\n    transform[2] = c;\n    transform[3] = d;\n    transform[4] = e;\n    transform[5] = f;\n    return transform;\n}\n/**\n * Set transform on one matrix from another matrix.\n * @param {!Transform} transform1 Matrix to set transform to.\n * @param {!Transform} transform2 Matrix to set transform from.\n * @return {!Transform} transform1 with transform from transform2 applied.\n */\nexport function setFromArray(transform1, transform2) {\n    transform1[0] = transform2[0];\n    transform1[1] = transform2[1];\n    transform1[2] = transform2[2];\n    transform1[3] = transform2[3];\n    transform1[4] = transform2[4];\n    transform1[5] = transform2[5];\n    return transform1;\n}\n/**\n * Transforms the given coordinate with the given transform returning the\n * resulting, transformed coordinate. The coordinate will be modified in-place.\n *\n * @param {Transform} transform The transformation.\n * @param {import(\"./coordinate.js\").Coordinate|import(\"./pixel.js\").Pixel} coordinate The coordinate to transform.\n * @return {import(\"./coordinate.js\").Coordinate|import(\"./pixel.js\").Pixel} return coordinate so that operations can be\n *     chained together.\n */\nexport function apply(transform, coordinate) {\n    var x = coordinate[0];\n    var y = coordinate[1];\n    coordinate[0] = transform[0] * x + transform[2] * y + transform[4];\n    coordinate[1] = transform[1] * x + transform[3] * y + transform[5];\n    return coordinate;\n}\n/**\n * Applies rotation to the given transform.\n * @param {!Transform} transform Transform.\n * @param {number} angle Angle in radians.\n * @return {!Transform} The rotated transform.\n */\nexport function rotate(transform, angle) {\n    var cos = Math.cos(angle);\n    var sin = Math.sin(angle);\n    return multiply(transform, set(tmp_, cos, sin, -sin, cos, 0, 0));\n}\n/**\n * Applies scale to a given transform.\n * @param {!Transform} transform Transform.\n * @param {number} x Scale factor x.\n * @param {number} y Scale factor y.\n * @return {!Transform} The scaled transform.\n */\nexport function scale(transform, x, y) {\n    return multiply(transform, set(tmp_, x, 0, 0, y, 0, 0));\n}\n/**\n * Creates a scale transform.\n * @param {!Transform} target Transform to overwrite.\n * @param {number} x Scale factor x.\n * @param {number} y Scale factor y.\n * @return {!Transform} The scale transform.\n */\nexport function makeScale(target, x, y) {\n    return set(target, x, 0, 0, y, 0, 0);\n}\n/**\n * Applies translation to the given transform.\n * @param {!Transform} transform Transform.\n * @param {number} dx Translation x.\n * @param {number} dy Translation y.\n * @return {!Transform} The translated transform.\n */\nexport function translate(transform, dx, dy) {\n    return multiply(transform, set(tmp_, 1, 0, 0, 1, dx, dy));\n}\n/**\n * Creates a composite transform given an initial translation, scale, rotation, and\n * final translation (in that order only, not commutative).\n * @param {!Transform} transform The transform (will be modified in place).\n * @param {number} dx1 Initial translation x.\n * @param {number} dy1 Initial translation y.\n * @param {number} sx Scale factor x.\n * @param {number} sy Scale factor y.\n * @param {number} angle Rotation (in counter-clockwise radians).\n * @param {number} dx2 Final translation x.\n * @param {number} dy2 Final translation y.\n * @return {!Transform} The composite transform.\n */\nexport function compose(transform, dx1, dy1, sx, sy, angle, dx2, dy2) {\n    var sin = Math.sin(angle);\n    var cos = Math.cos(angle);\n    transform[0] = sx * cos;\n    transform[1] = sy * sin;\n    transform[2] = -sx * sin;\n    transform[3] = sy * cos;\n    transform[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;\n    transform[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;\n    return transform;\n}\n/**\n * Creates a composite transform given an initial translation, scale, rotation, and\n * final translation (in that order only, not commutative). The resulting transform\n * string can be applied as `transform` property of an HTMLElement's style.\n * @param {number} dx1 Initial translation x.\n * @param {number} dy1 Initial translation y.\n * @param {number} sx Scale factor x.\n * @param {number} sy Scale factor y.\n * @param {number} angle Rotation (in counter-clockwise radians).\n * @param {number} dx2 Final translation x.\n * @param {number} dy2 Final translation y.\n * @return {string} The composite css transform.\n * @api\n */\nexport function composeCssTransform(dx1, dy1, sx, sy, angle, dx2, dy2) {\n    return toString(compose(create(), dx1, dy1, sx, sy, angle, dx2, dy2));\n}\n/**\n * Invert the given transform.\n * @param {!Transform} source The source transform to invert.\n * @return {!Transform} The inverted (source) transform.\n */\nexport function invert(source) {\n    return makeInverse(source, source);\n}\n/**\n * Invert the given transform.\n * @param {!Transform} target Transform to be set as the inverse of\n *     the source transform.\n * @param {!Transform} source The source transform to invert.\n * @return {!Transform} The inverted (target) transform.\n */\nexport function makeInverse(target, source) {\n    var det = determinant(source);\n    assert(det !== 0, 32); // Transformation matrix cannot be inverted\n    var a = source[0];\n    var b = source[1];\n    var c = source[2];\n    var d = source[3];\n    var e = source[4];\n    var f = source[5];\n    target[0] = d / det;\n    target[1] = -b / det;\n    target[2] = -c / det;\n    target[3] = a / det;\n    target[4] = (c * f - d * e) / det;\n    target[5] = -(a * f - b * e) / det;\n    return target;\n}\n/**\n * Returns the determinant of the given matrix.\n * @param {!Transform} mat Matrix.\n * @return {number} Determinant.\n */\nexport function determinant(mat) {\n    return mat[0] * mat[3] - mat[1] * mat[2];\n}\n/**\n * @type {HTMLElement}\n * @private\n */\nvar transformStringDiv;\n/**\n * A rounded string version of the transform.  This can be used\n * for CSS transforms.\n * @param {!Transform} mat Matrix.\n * @return {string} The transform as a string.\n */\nexport function toString(mat) {\n    var transformString = 'matrix(' + mat.join(', ') + ')';\n    if (WORKER_OFFSCREEN_CANVAS) {\n        return transformString;\n    }\n    var node = transformStringDiv || (transformStringDiv = document.createElement('div'));\n    node.style.transform = transformString;\n    return node.style.transform;\n}\n//# sourceMappingURL=transform.js.map","/**\n * @module ol/uri\n */\n/**\n * Appends query parameters to a URI.\n *\n * @param {string} uri The original URI, which may already have query data.\n * @param {!Object} params An object where keys are URI-encoded parameter keys,\n *     and the values are arbitrary types or arrays.\n * @return {string} The new URI.\n */\nexport function appendParams(uri, params) {\n    var keyParams = [];\n    // Skip any null or undefined parameter values\n    Object.keys(params).forEach(function (k) {\n        if (params[k] !== null && params[k] !== undefined) {\n            keyParams.push(k + '=' + encodeURIComponent(params[k]));\n        }\n    });\n    var qs = keyParams.join('&');\n    // remove any trailing ? or &\n    uri = uri.replace(/[?&]$/, '');\n    // append ? or & depending on whether uri has existing parameters\n    uri = uri.indexOf('?') === -1 ? uri + '?' : uri + '&';\n    return uri + qs;\n}\n//# sourceMappingURL=uri.js.map"],"sourceRoot":""}
{"version":3,"sources":["webpack:///./node_modules/ol/tilegrid/common.js","webpack:///./node_modules/ol/tilegrid.js","webpack:///./node_modules/ol/util.js","webpack:///./node_modules/ol/tilecoord.js","webpack:///./node_modules/ol/tilegrid/WMTS.js","webpack:///./node_modules/ol/tilegrid/TileGrid.js","webpack:///./node_modules/ol/tileurlfunction.js","webpack:///./node_modules/ol/transform.js","webpack:///./node_modules/ol/uri.js","webpack:///./node_modules/ol/xml.js"],"names":["DEFAULT_MAX_ZOOM","DEFAULT_TILE_SIZE","getForProjection","projection","tileGrid","getDefaultTileGrid","createForProjection","setDefaultTileGrid","wrapX","tileCoord","z","center","getTileCoordCenter","projectionExtent","extentFromProjection","worldWidth","worldsAway","Math","ceil","getTileCoordForCoordAndZ","createForExtent","extent","opt_maxZoom","opt_tileSize","opt_corner","corner","undefined","TOP_LEFT","resolutions","resolutionsFromExtent","origin","tileSize","createXYZ","opt_options","xyzOptions","getExtent","gridOptions","minZoom","maxZoom","height","width","maxResolution","max","length","Array","pow","half","DEGREES","getMetersPerUnit","abstract","Error","uidCounter_","getUid","obj","ol_uid","String","VERSION","createOrUpdate","x","y","opt_tileCoord","getKeyZXY","getKey","fromKey","key","split","map","Number","hash","withinExtentAndZ","getMinZoom","getMaxZoom","tileRange","getTileRangeForExtentAndZ","getFullTileRange","containsXY","WMTSTileGrid","TileGrid","options","call","this","origins","tileSizes","sizes","matrixIds_","matrixIds","__proto__","prototype","Object","create","constructor","getMatrixId","getMatrixIds","createFromCapabilitiesMatrixSet","matrixSet","opt_extent","opt_matrixLimits","matrixLimits","supportedCRSPropName","matrixIdsPropName","identifierPropName","scaleDenominatorPropName","topLeftCornerPropName","tileWidthPropName","tileHeightPropName","code","replace","metersPerUnit","switchOriginXY","getAxisOrientation","substr","sort","a","b","forEach","elt","matrixAvailable","elt_ml","indexOf","push","resolution","tileWidth","tileHeight","tmpTileCoord","zoomFactor","resolutions_","i","ii","zoomFactor_","origin_","origins_","tileSizes_","tileSize_","extent_","fullTileRanges_","tmpSize_","size","min","calculateTileRanges_","forEachTileCoord","zoom","callback","minX","maxX","j","minY","jj","maxY","forEachTileCoordParentTileRange","opt_this","opt_tileRange","tileCoordExtent","getTileCoordExtent","floor","getOrigin","getResolution","getResolutions","getTileCoordChildTileRange","getTileRangeExtent","getTileSize","getTileCoordForXYAndZ_","getTileCoordForCoordAndResolution","coordinate","getTileCoordForXYAndResolution_","reverseIntersectionPolicy","getZForResolution","scale","adjustX","adjustY","xFromOrigin","yFromOrigin","tileCoordX","tileCoordY","getTileCoordResolution","opt_direction","fullTileRanges","createFromTemplate","template","zRegEx","xRegEx","yRegEx","dashYRegEx","pixelRatio","toString","range","getHeight","createFromTemplates","templates","len","tileUrlFunctions","createFromTileUrlFunctions","h","index","nullTileUrlFunction","expandUrl","url","urls","match","exec","charCode","startCharCode","charCodeAt","stopCharCode","fromCharCode","stop","parseInt","tmp_","reset","transform","set","multiply","transform1","transform2","a1","b1","c1","d1","e1","f1","a2","b2","c2","d2","e2","f2","c","d","e","f","setFromArray","apply","translate","dx","dy","compose","dx1","dy1","sx","sy","angle","dx2","dy2","sin","cos","invert","det","determinant","mat","appendParams","uri","params","keyParams","keys","k","encodeURIComponent","qs","join","DOCUMENT","document","implementation","createDocument","createElementNS","namespaceURI","qualifiedName","getAllTextContent","node","normalizeWhitespace","getAllTextContent_","accumulator","n","nodeType","Node","CDATA_SECTION_NODE","TEXT_NODE","nodeValue","firstChild","nextSibling","isDocument","object","parse","xml","DOMParser","parseFromString","makeArrayPusher","valueReader","objectStack","value","array","makeObjectPropertyPusher","opt_property","property","localName","makeObjectPropertySetter","makeSimpleNodeFactory","opt_nodeName","opt_namespaceURI","fixedNodeName","context","nodeName","makeStructureNS","namespaceURIs","structure","opt_structureNS","structureNS","parseNode","parsersNS","firstElementChild","nextElementSibling","parsers","parser","pushParseAndPop","pop"],"mappings":"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","file":"js/chunk-3e1c423c.39db7299.js","sourcesContent":["/**\n * @module ol/tilegrid/common\n */\n\n/**\n * Default maximum zoom for default tile grids.\n * @type {number}\n */\nexport var DEFAULT_MAX_ZOOM = 42;\n\n/**\n * Default tile size.\n * @type {number}\n */\nexport var DEFAULT_TILE_SIZE = 256;\n\n//# sourceMappingURL=common.js.map","/**\n * @module ol/tilegrid\n */\nimport {DEFAULT_MAX_ZOOM, DEFAULT_TILE_SIZE} from './tilegrid/common.js';\nimport {toSize} from './size.js';\nimport {containsCoordinate, createOrUpdate, getCorner, getHeight, getWidth} from './extent.js';\nimport Corner from './extent/Corner.js';\nimport {get as getProjection, METERS_PER_UNIT} from './proj.js';\nimport Units from './proj/Units.js';\nimport TileGrid from './tilegrid/TileGrid.js';\n\n\n/**\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {!TileGrid} Default tile grid for the\n * passed projection.\n */\nexport function getForProjection(projection) {\n  var tileGrid = projection.getDefaultTileGrid();\n  if (!tileGrid) {\n    tileGrid = createForProjection(projection);\n    projection.setDefaultTileGrid(tileGrid);\n  }\n  return tileGrid;\n}\n\n\n/**\n * @param {TileGrid} tileGrid Tile grid.\n * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {import(\"./tilecoord.js\").TileCoord} Tile coordinate.\n */\nexport function wrapX(tileGrid, tileCoord, projection) {\n  var z = tileCoord[0];\n  var center = tileGrid.getTileCoordCenter(tileCoord);\n  var projectionExtent = extentFromProjection(projection);\n  if (!containsCoordinate(projectionExtent, center)) {\n    var worldWidth = getWidth(projectionExtent);\n    var worldsAway = Math.ceil((projectionExtent[0] - center[0]) / worldWidth);\n    center[0] += worldWidth * worldsAway;\n    return tileGrid.getTileCoordForCoordAndZ(center, z);\n  } else {\n    return tileCoord;\n  }\n}\n\n\n/**\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number=} opt_maxZoom Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size=} opt_tileSize Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {Corner=} opt_corner Extent corner (default is `'top-left'`).\n * @return {!TileGrid} TileGrid instance.\n */\nexport function createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner) {\n  var corner = opt_corner !== undefined ? opt_corner : Corner.TOP_LEFT;\n\n  var resolutions = resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize);\n\n  return new TileGrid({\n    extent: extent,\n    origin: getCorner(extent, corner),\n    resolutions: resolutions,\n    tileSize: opt_tileSize\n  });\n}\n\n\n/**\n * @typedef {Object} XYZOptions\n * @property {import(\"./extent.js\").Extent} [extent] Extent for the tile grid. The origin for an XYZ tile grid is the\n * top-left corner of the extent. The zero level of the grid is defined by the resolution at which one tile fits in the\n * provided extent. If not provided, the extent of the EPSG:3857 projection is used.\n * @property {number} [maxZoom] Maximum zoom. The default is `42`. This determines the number of levels\n * in the grid set. For example, a `maxZoom` of 21 means there are 22 levels in the grid set.\n * @property {number} [minZoom=0] Minimum zoom.\n * @property {number|import(\"./size.js\").Size} [tileSize=[256, 256]] Tile size in pixels.\n */\n\n\n/**\n * Creates a tile grid with a standard XYZ tiling scheme.\n * @param {XYZOptions=} opt_options Tile grid options.\n * @return {!TileGrid} Tile grid instance.\n * @api\n */\nexport function createXYZ(opt_options) {\n  /** @type {XYZOptions} */\n  var xyzOptions = opt_options || {};\n\n  var extent = xyzOptions.extent || getProjection('EPSG:3857').getExtent();\n\n  /** @type {import(\"./tilegrid/TileGrid.js\").Options} */\n  var gridOptions = {\n    extent: extent,\n    minZoom: xyzOptions.minZoom,\n    tileSize: xyzOptions.tileSize,\n    resolutions: resolutionsFromExtent(\n      extent,\n      xyzOptions.maxZoom,\n      xyzOptions.tileSize\n    )\n  };\n  return new TileGrid(gridOptions);\n}\n\n\n/**\n * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number=} opt_maxZoom Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size=} opt_tileSize Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @return {!Array<number>} Resolutions array.\n */\nfunction resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize) {\n  var maxZoom = opt_maxZoom !== undefined ?\n    opt_maxZoom : DEFAULT_MAX_ZOOM;\n\n  var height = getHeight(extent);\n  var width = getWidth(extent);\n\n  var tileSize = toSize(opt_tileSize !== undefined ?\n    opt_tileSize : DEFAULT_TILE_SIZE);\n  var maxResolution = Math.max(\n    width / tileSize[0], height / tileSize[1]);\n\n  var length = maxZoom + 1;\n  var resolutions = new Array(length);\n  for (var z = 0; z < length; ++z) {\n    resolutions[z] = maxResolution / Math.pow(2, z);\n  }\n  return resolutions;\n}\n\n\n/**\n * @param {import(\"./proj.js\").ProjectionLike} projection Projection.\n * @param {number=} opt_maxZoom Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size=} opt_tileSize Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {Corner=} opt_corner Extent corner (default is `'top-left'`).\n * @return {!TileGrid} TileGrid instance.\n */\nexport function createForProjection(projection, opt_maxZoom, opt_tileSize, opt_corner) {\n  var extent = extentFromProjection(projection);\n  return createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner);\n}\n\n\n/**\n * Generate a tile grid extent from a projection.  If the projection has an\n * extent, it is used.  If not, a global extent is assumed.\n * @param {import(\"./proj.js\").ProjectionLike} projection Projection.\n * @return {import(\"./extent.js\").Extent} Extent.\n */\nexport function extentFromProjection(projection) {\n  projection = getProjection(projection);\n  var extent = projection.getExtent();\n  if (!extent) {\n    var half = 180 * METERS_PER_UNIT[Units.DEGREES] / projection.getMetersPerUnit();\n    extent = createOrUpdate(-half, -half, half, half);\n  }\n  return extent;\n}\n\n//# sourceMappingURL=tilegrid.js.map","/**\n * @module ol/util\n */\n\n/**\n * @return {?} Any return.\n */\nexport function abstract() {\n  return /** @type {?} */ ((function() {\n    throw new Error('Unimplemented abstract method.');\n  })());\n}\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * Usage:\n *\n *     function ParentClass(a, b) { }\n *     ParentClass.prototype.foo = function(a) { }\n *\n *     function ChildClass(a, b, c) {\n *       // Call parent constructor\n *       ParentClass.call(this, a, b);\n *     }\n *     inherits(ChildClass, ParentClass);\n *\n *     var child = new ChildClass('a', 'b', 'see');\n *     child.foo(); // This works.\n *\n * @param {!Function} childCtor Child constructor.\n * @param {!Function} parentCtor Parent constructor.\n * @function module:ol.inherits\n * @deprecated\n * @api\n */\nexport function inherits(childCtor, parentCtor) {\n  childCtor.prototype = Object.create(parentCtor.prototype);\n  childCtor.prototype.constructor = childCtor;\n}\n\n/**\n * Counter for getUid.\n * @type {number}\n * @private\n */\nvar uidCounter_ = 0;\n\n/**\n * Gets a unique ID for an object. This mutates the object so that further calls\n * with the same object as a parameter returns the same value. Unique IDs are generated\n * as a strictly increasing sequence. Adapted from goog.getUid.\n *\n * @param {Object} obj The object to get the unique ID for.\n * @return {string} The unique ID for the object.\n * @function module:ol.getUid\n * @api\n */\nexport function getUid(obj) {\n  return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));\n}\n\n/**\n * OpenLayers version.\n * @type {string}\n */\nexport var VERSION = '5.3.3';\n\n//# sourceMappingURL=util.js.map","/**\n * @module ol/tilecoord\n */\n\n\n/**\n * An array of three numbers representing the location of a tile in a tile\n * grid. The order is `z`, `x`, and `y`. `z` is the zoom level.\n * @typedef {Array<number>} TileCoord\n * @api\n */\n\n\n/**\n * @param {number} z Z.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {TileCoord=} opt_tileCoord Tile coordinate.\n * @return {TileCoord} Tile coordinate.\n */\nexport function createOrUpdate(z, x, y, opt_tileCoord) {\n  if (opt_tileCoord !== undefined) {\n    opt_tileCoord[0] = z;\n    opt_tileCoord[1] = x;\n    opt_tileCoord[2] = y;\n    return opt_tileCoord;\n  } else {\n    return [z, x, y];\n  }\n}\n\n\n/**\n * @param {number} z Z.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {string} Key.\n */\nexport function getKeyZXY(z, x, y) {\n  return z + '/' + x + '/' + y;\n}\n\n\n/**\n * Get the key for a tile coord.\n * @param {TileCoord} tileCoord The tile coord.\n * @return {string} Key.\n */\nexport function getKey(tileCoord) {\n  return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);\n}\n\n\n/**\n * Get a tile coord given a key.\n * @param {string} key The tile coord key.\n * @return {TileCoord} The tile coord.\n */\nexport function fromKey(key) {\n  return key.split('/').map(Number);\n}\n\n\n/**\n * @param {TileCoord} tileCoord Tile coord.\n * @return {number} Hash.\n */\nexport function hash(tileCoord) {\n  return (tileCoord[1] << tileCoord[0]) + tileCoord[2];\n}\n\n\n/**\n * @param {TileCoord} tileCoord Tile coord.\n * @return {string} Quad key.\n */\nexport function quadKey(tileCoord) {\n  var z = tileCoord[0];\n  var digits = new Array(z);\n  var mask = 1 << (z - 1);\n  var i, charCode;\n  for (i = 0; i < z; ++i) {\n    // 48 is charCode for 0 - '0'.charCodeAt(0)\n    charCode = 48;\n    if (tileCoord[1] & mask) {\n      charCode += 1;\n    }\n    if (tileCoord[2] & mask) {\n      charCode += 2;\n    }\n    digits[i] = String.fromCharCode(charCode);\n    mask >>= 1;\n  }\n  return digits.join('');\n}\n\n\n/**\n * @param {TileCoord} tileCoord Tile coordinate.\n * @param {!import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {boolean} Tile coordinate is within extent and zoom level range.\n */\nexport function withinExtentAndZ(tileCoord, tileGrid) {\n  var z = tileCoord[0];\n  var x = tileCoord[1];\n  var y = tileCoord[2];\n\n  if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {\n    return false;\n  }\n  var extent = tileGrid.getExtent();\n  var tileRange;\n  if (!extent) {\n    tileRange = tileGrid.getFullTileRange(z);\n  } else {\n    tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\n  }\n  if (!tileRange) {\n    return true;\n  } else {\n    return tileRange.containsXY(x, y);\n  }\n}\n\n//# sourceMappingURL=tilecoord.js.map","/**\n * @module ol/tilegrid/WMTS\n */\n\nimport {find} from '../array.js';\nimport {get as getProjection} from '../proj.js';\nimport TileGrid from './TileGrid.js';\n\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../extent.js\").Extent} [extent] Extent for the tile grid. No tiles\n * outside this extent will be requested by {@link module:ol/source/Tile} sources.\n * When no `origin` or `origins` are configured, the `origin` will be set to the\n * top-left corner of the extent.\n * @property {import(\"../coordinate.js\").Coordinate} [origin] The tile grid origin, i.e.\n * where the `x` and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left\n * to right and upwards. If not specified, `extent` or `origins` must be provided.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} [origins] Tile grid origins,\n * i.e. where the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If\n * given, the array length should match the length of the `resolutions` array, i.e.\n * each resolution can have a different origin. Tile coordinates increase left to\n * right and upwards. If not specified, `extent` or `origin` must be provided.\n * @property {!Array<number>} resolutions Resolutions. The array index of each\n * resolution needs to match the zoom level. This means that even if a `minZoom`\n * is configured, the resolutions array will have a length of `maxZoom + 1`\n * @property {!Array<string>} matrixIds matrix IDs. The length of this array needs\n * to match the length of the `resolutions` array.\n * @property {Array<import(\"../size.js\").Size>} [sizes] Number of tile rows and columns\n * of the grid for each zoom level. The values here are the `TileMatrixWidth` and\n * `TileMatrixHeight` advertised in the GetCapabilities response of the WMTS, and\n * define the grid's extent together with the `origin`.\n * An `extent` can be configured in addition, and will further limit the extent for\n * which tile requests are made by sources. Note that when the top-left corner of\n * the `extent` is used as `origin` or `origins`, then the `y` value must be\n * negative because OpenLayers tile coordinates increase upwards.\n * @property {number|import(\"../size.js\").Size} [tileSize] Tile size.\n * @property {Array<import(\"../size.js\").Size>} [tileSizes] Tile sizes. The length of\n * this array needs to match the length of the `resolutions` array.\n * @property {Array<number>} [widths] Number of tile columns that cover the grid's\n * extent for each zoom level. Only required when used with a source that has `wrapX`\n * set to `true`, and only when the grid's origin differs from the one of the\n * projection's extent. The array length has to match the length of the `resolutions`\n * array, i.e. each resolution will have a matching entry here.\n */\n\n\n/**\n * @classdesc\n * Set the grid pattern for sources accessing WMTS tiled-image servers.\n * @api\n */\nvar WMTSTileGrid = /*@__PURE__*/(function (TileGrid) {\n  function WMTSTileGrid(options) {\n    TileGrid.call(this, {\n      extent: options.extent,\n      origin: options.origin,\n      origins: options.origins,\n      resolutions: options.resolutions,\n      tileSize: options.tileSize,\n      tileSizes: options.tileSizes,\n      sizes: options.sizes\n    });\n\n    /**\n     * @private\n     * @type {!Array<string>}\n     */\n    this.matrixIds_ = options.matrixIds;\n  }\n\n  if ( TileGrid ) WMTSTileGrid.__proto__ = TileGrid;\n  WMTSTileGrid.prototype = Object.create( TileGrid && TileGrid.prototype );\n  WMTSTileGrid.prototype.constructor = WMTSTileGrid;\n\n  /**\n   * @param {number} z Z.\n   * @return {string} MatrixId..\n   */\n  WMTSTileGrid.prototype.getMatrixId = function getMatrixId (z) {\n    return this.matrixIds_[z];\n  };\n\n  /**\n   * Get the list of matrix identifiers.\n   * @return {Array<string>} MatrixIds.\n   * @api\n   */\n  WMTSTileGrid.prototype.getMatrixIds = function getMatrixIds () {\n    return this.matrixIds_;\n  };\n\n  return WMTSTileGrid;\n}(TileGrid));\n\n\nexport default WMTSTileGrid;\n\n/**\n * Create a tile grid from a WMTS capabilities matrix set and an\n * optional TileMatrixSetLimits.\n * @param {Object} matrixSet An object representing a matrixSet in the\n *     capabilities document.\n * @param {import(\"../extent.js\").Extent=} opt_extent An optional extent to restrict the tile\n *     ranges the server provides.\n * @param {Array<Object>=} opt_matrixLimits An optional object representing\n *     the available matrices for tileGrid.\n * @return {WMTSTileGrid} WMTS tileGrid instance.\n * @api\n */\nexport function createFromCapabilitiesMatrixSet(matrixSet, opt_extent, opt_matrixLimits) {\n\n  /** @type {!Array<number>} */\n  var resolutions = [];\n  /** @type {!Array<string>} */\n  var matrixIds = [];\n  /** @type {!Array<import(\"../coordinate.js\").Coordinate>} */\n  var origins = [];\n  /** @type {!Array<import(\"../size.js\").Size>} */\n  var tileSizes = [];\n  /** @type {!Array<import(\"../size.js\").Size>} */\n  var sizes = [];\n\n  var matrixLimits = opt_matrixLimits !== undefined ? opt_matrixLimits : [];\n\n  var supportedCRSPropName = 'SupportedCRS';\n  var matrixIdsPropName = 'TileMatrix';\n  var identifierPropName = 'Identifier';\n  var scaleDenominatorPropName = 'ScaleDenominator';\n  var topLeftCornerPropName = 'TopLeftCorner';\n  var tileWidthPropName = 'TileWidth';\n  var tileHeightPropName = 'TileHeight';\n\n  var code = matrixSet[supportedCRSPropName];\n  var projection = getProjection(code.replace(/urn:ogc:def:crs:(\\w+):(.*:)?(\\w+)$/, '$1:$3')) ||\n      getProjection(code);\n  var metersPerUnit = projection.getMetersPerUnit();\n  // swap origin x and y coordinates if axis orientation is lat/long\n  var switchOriginXY = projection.getAxisOrientation().substr(0, 2) == 'ne';\n\n  matrixSet[matrixIdsPropName].sort(function(a, b) {\n    return b[scaleDenominatorPropName] - a[scaleDenominatorPropName];\n  });\n\n  matrixSet[matrixIdsPropName].forEach(function(elt) {\n\n    var matrixAvailable;\n    // use of matrixLimits to filter TileMatrices from GetCapabilities\n    // TileMatrixSet from unavailable matrix levels.\n    if (matrixLimits.length > 0) {\n      matrixAvailable = find(matrixLimits, function(elt_ml) {\n        if (elt[identifierPropName] == elt_ml[matrixIdsPropName]) {\n          return true;\n        }\n        // Fallback for tileMatrix identifiers that don't get prefixed\n        // by their tileMatrixSet identifiers.\n        if (elt[identifierPropName].indexOf(':') === -1) {\n          return matrixSet[identifierPropName] + ':' + elt[identifierPropName] === elt_ml[matrixIdsPropName];\n        }\n        return false;\n      });\n    } else {\n      matrixAvailable = true;\n    }\n\n    if (matrixAvailable) {\n      matrixIds.push(elt[identifierPropName]);\n      var resolution = elt[scaleDenominatorPropName] * 0.28E-3 / metersPerUnit;\n      var tileWidth = elt[tileWidthPropName];\n      var tileHeight = elt[tileHeightPropName];\n      if (switchOriginXY) {\n        origins.push([elt[topLeftCornerPropName][1],\n          elt[topLeftCornerPropName][0]]);\n      } else {\n        origins.push(elt[topLeftCornerPropName]);\n      }\n      resolutions.push(resolution);\n      tileSizes.push(tileWidth == tileHeight ?\n        tileWidth : [tileWidth, tileHeight]);\n      // top-left origin, so height is negative\n      sizes.push([elt['MatrixWidth'], -elt['MatrixHeight']]);\n    }\n  });\n\n  return new WMTSTileGrid({\n    extent: opt_extent,\n    origins: origins,\n    resolutions: resolutions,\n    matrixIds: matrixIds,\n    tileSizes: tileSizes,\n    sizes: sizes\n  });\n}\n\n//# sourceMappingURL=WMTS.js.map","/**\n * @module ol/tilegrid/TileGrid\n */\nimport {DEFAULT_TILE_SIZE} from './common.js';\nimport {assert} from '../asserts.js';\nimport TileRange, {createOrUpdate as createOrUpdateTileRange} from '../TileRange.js';\nimport {isSorted, linearFindNearest} from '../array.js';\nimport {createOrUpdate, getTopLeft} from '../extent.js';\nimport {clamp} from '../math.js';\nimport {toSize} from '../size.js';\nimport {createOrUpdate as createOrUpdateTileCoord} from '../tilecoord.js';\n\n\n/**\n * @private\n * @type {import(\"../tilecoord.js\").TileCoord}\n */\nvar tmpTileCoord = [0, 0, 0];\n\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../extent.js\").Extent} [extent] Extent for the tile grid. No tiles outside this\n * extent will be requested by {@link module:ol/source/Tile} sources. When no `origin` or\n * `origins` are configured, the `origin` will be set to the top-left corner of the extent.\n * @property {number} [minZoom=0] Minimum zoom.\n * @property {import(\"../coordinate.js\").Coordinate} [origin] The tile grid origin, i.e. where the `x`\n * and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left to right and upwards. If not\n * specified, `extent` or `origins` must be provided.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} [origins] Tile grid origins, i.e. where\n * the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If given, the array length\n * should match the length of the `resolutions` array, i.e. each resolution can have a different\n * origin. Tile coordinates increase left to right and upwards. If not specified, `extent` or\n * `origin` must be provided.\n * @property {!Array<number>} resolutions Resolutions. The array index of each resolution needs\n * to match the zoom level. This means that even if a `minZoom` is configured, the resolutions\n * array will have a length of `maxZoom + 1`.\n * @property {Array<import(\"../size.js\").Size>} [sizes] Sizes.\n * @property {number|import(\"../size.js\").Size} [tileSize] Tile size.\n * Default is `[256, 256]`.\n * @property {Array<import(\"../size.js\").Size>} [tileSizes] Tile sizes. If given, the array length\n * should match the length of the `resolutions` array, i.e. each resolution can have a different\n * tile size.\n */\n\n\n/**\n * @classdesc\n * Base class for setting the grid pattern for sources accessing tiled-image\n * servers.\n * @api\n */\nvar TileGrid = function TileGrid(options) {\n\n  /**\n   * @protected\n   * @type {number}\n   */\n  this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;\n\n  /**\n   * @private\n   * @type {!Array<number>}\n   */\n  this.resolutions_ = options.resolutions;\n  assert(isSorted(this.resolutions_, function(a, b) {\n    return b - a;\n  }, true), 17); // `resolutions` must be sorted in descending order\n\n\n  // check if we've got a consistent zoom factor and origin\n  var zoomFactor;\n  if (!options.origins) {\n    for (var i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {\n      if (!zoomFactor) {\n        zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];\n      } else {\n        if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {\n          zoomFactor = undefined;\n          break;\n        }\n      }\n    }\n  }\n\n\n  /**\n   * @private\n   * @type {number|undefined}\n   */\n  this.zoomFactor_ = zoomFactor;\n\n\n  /**\n   * @protected\n   * @type {number}\n   */\n  this.maxZoom = this.resolutions_.length - 1;\n\n  /**\n   * @private\n   * @type {import(\"../coordinate.js\").Coordinate}\n   */\n  this.origin_ = options.origin !== undefined ? options.origin : null;\n\n  /**\n   * @private\n   * @type {Array<import(\"../coordinate.js\").Coordinate>}\n   */\n  this.origins_ = null;\n  if (options.origins !== undefined) {\n    this.origins_ = options.origins;\n    assert(this.origins_.length == this.resolutions_.length,\n      20); // Number of `origins` and `resolutions` must be equal\n  }\n\n  var extent = options.extent;\n\n  if (extent !== undefined &&\n      !this.origin_ && !this.origins_) {\n    this.origin_ = getTopLeft(extent);\n  }\n\n  assert(\n    (!this.origin_ && this.origins_) || (this.origin_ && !this.origins_),\n    18); // Either `origin` or `origins` must be configured, never both\n\n  /**\n   * @private\n   * @type {Array<number|import(\"../size.js\").Size>}\n   */\n  this.tileSizes_ = null;\n  if (options.tileSizes !== undefined) {\n    this.tileSizes_ = options.tileSizes;\n    assert(this.tileSizes_.length == this.resolutions_.length,\n      19); // Number of `tileSizes` and `resolutions` must be equal\n  }\n\n  /**\n   * @private\n   * @type {number|import(\"../size.js\").Size}\n   */\n  this.tileSize_ = options.tileSize !== undefined ?\n    options.tileSize :\n    !this.tileSizes_ ? DEFAULT_TILE_SIZE : null;\n  assert(\n    (!this.tileSize_ && this.tileSizes_) ||\n      (this.tileSize_ && !this.tileSizes_),\n    22); // Either `tileSize` or `tileSizes` must be configured, never both\n\n  /**\n   * @private\n   * @type {import(\"../extent.js\").Extent}\n   */\n  this.extent_ = extent !== undefined ? extent : null;\n\n\n  /**\n   * @private\n   * @type {Array<import(\"../TileRange.js\").default>}\n   */\n  this.fullTileRanges_ = null;\n\n  /**\n   * @private\n   * @type {import(\"../size.js\").Size}\n   */\n  this.tmpSize_ = [0, 0];\n\n  if (options.sizes !== undefined) {\n    this.fullTileRanges_ = options.sizes.map(function(size, z) {\n      var tileRange = new TileRange(\n        Math.min(0, size[0]), Math.max(size[0] - 1, -1),\n        Math.min(0, size[1]), Math.max(size[1] - 1, -1));\n      return tileRange;\n    }, this);\n  } else if (extent) {\n    this.calculateTileRanges_(extent);\n  }\n\n};\n\n/**\n * Call a function with each tile coordinate for a given extent and zoom level.\n *\n * @param {import(\"../extent.js\").Extent} extent Extent.\n * @param {number} zoom Integer zoom level.\n * @param {function(import(\"../tilecoord.js\").TileCoord)} callback Function called with each tile coordinate.\n * @api\n */\nTileGrid.prototype.forEachTileCoord = function forEachTileCoord (extent, zoom, callback) {\n  var tileRange = this.getTileRangeForExtentAndZ(extent, zoom);\n  for (var i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {\n    for (var j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {\n      callback([zoom, i, j]);\n    }\n  }\n};\n\n/**\n * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @param {function(this: T, number, import(\"../TileRange.js\").default): boolean} callback Callback.\n * @param {T=} opt_this The object to use as `this` in `callback`.\n * @param {import(\"../TileRange.js\").default=} opt_tileRange Temporary import(\"../TileRange.js\").default object.\n * @param {import(\"../extent.js\").Extent=} opt_extent Temporary import(\"../extent.js\").Extent object.\n * @return {boolean} Callback succeeded.\n * @template T\n */\nTileGrid.prototype.forEachTileCoordParentTileRange = function forEachTileCoordParentTileRange (tileCoord, callback, opt_this, opt_tileRange, opt_extent) {\n  var tileRange, x, y;\n  var tileCoordExtent = null;\n  var z = tileCoord[0] - 1;\n  if (this.zoomFactor_ === 2) {\n    x = tileCoord[1];\n    y = tileCoord[2];\n  } else {\n    tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);\n  }\n  while (z >= this.minZoom) {\n    if (this.zoomFactor_ === 2) {\n      x = Math.floor(x / 2);\n      y = Math.floor(y / 2);\n      tileRange = createOrUpdateTileRange(x, x, y, y, opt_tileRange);\n    } else {\n      tileRange = this.getTileRangeForExtentAndZ(tileCoordExtent, z, opt_tileRange);\n    }\n    if (callback.call(opt_this, z, tileRange)) {\n      return true;\n    }\n    --z;\n  }\n  return false;\n};\n\n/**\n * Get the extent for this tile grid, if it was configured.\n * @return {import(\"../extent.js\").Extent} Extent.\n */\nTileGrid.prototype.getExtent = function getExtent () {\n  return this.extent_;\n};\n\n/**\n * Get the maximum zoom level for the grid.\n * @return {number} Max zoom.\n * @api\n */\nTileGrid.prototype.getMaxZoom = function getMaxZoom () {\n  return this.maxZoom;\n};\n\n/**\n * Get the minimum zoom level for the grid.\n * @return {number} Min zoom.\n * @api\n */\nTileGrid.prototype.getMinZoom = function getMinZoom () {\n  return this.minZoom;\n};\n\n/**\n * Get the origin for the grid at the given zoom level.\n * @param {number} z Integer zoom level.\n * @return {import(\"../coordinate.js\").Coordinate} Origin.\n * @api\n */\nTileGrid.prototype.getOrigin = function getOrigin (z) {\n  if (this.origin_) {\n    return this.origin_;\n  } else {\n    return this.origins_[z];\n  }\n};\n\n/**\n * Get the resolution for the given zoom level.\n * @param {number} z Integer zoom level.\n * @return {number} Resolution.\n * @api\n */\nTileGrid.prototype.getResolution = function getResolution (z) {\n  return this.resolutions_[z];\n};\n\n/**\n * Get the list of resolutions for the tile grid.\n * @return {Array<number>} Resolutions.\n * @api\n */\nTileGrid.prototype.getResolutions = function getResolutions () {\n  return this.resolutions_;\n};\n\n/**\n * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @param {import(\"../TileRange.js\").default=} opt_tileRange Temporary import(\"../TileRange.js\").default object.\n * @param {import(\"../extent.js\").Extent=} opt_extent Temporary import(\"../extent.js\").Extent object.\n * @return {import(\"../TileRange.js\").default} Tile range.\n */\nTileGrid.prototype.getTileCoordChildTileRange = function getTileCoordChildTileRange (tileCoord, opt_tileRange, opt_extent) {\n  if (tileCoord[0] < this.maxZoom) {\n    if (this.zoomFactor_ === 2) {\n      var minX = tileCoord[1] * 2;\n      var minY = tileCoord[2] * 2;\n      return createOrUpdateTileRange(minX, minX + 1, minY, minY + 1, opt_tileRange);\n    }\n    var tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);\n    return this.getTileRangeForExtentAndZ(\n      tileCoordExtent, tileCoord[0] + 1, opt_tileRange);\n  }\n  return null;\n};\n\n/**\n * Get the extent for a tile range.\n * @param {number} z Integer zoom level.\n * @param {import(\"../TileRange.js\").default} tileRange Tile range.\n * @param {import(\"../extent.js\").Extent=} opt_extent Temporary import(\"../extent.js\").Extent object.\n * @return {import(\"../extent.js\").Extent} Extent.\n */\nTileGrid.prototype.getTileRangeExtent = function getTileRangeExtent (z, tileRange, opt_extent) {\n  var origin = this.getOrigin(z);\n  var resolution = this.getResolution(z);\n  var tileSize = toSize(this.getTileSize(z), this.tmpSize_);\n  var minX = origin[0] + tileRange.minX * tileSize[0] * resolution;\n  var maxX = origin[0] + (tileRange.maxX + 1) * tileSize[0] * resolution;\n  var minY = origin[1] + tileRange.minY * tileSize[1] * resolution;\n  var maxY = origin[1] + (tileRange.maxY + 1) * tileSize[1] * resolution;\n  return createOrUpdate(minX, minY, maxX, maxY, opt_extent);\n};\n\n/**\n * Get a tile range for the given extent and integer zoom level.\n * @param {import(\"../extent.js\").Extent} extent Extent.\n * @param {number} z Integer zoom level.\n * @param {import(\"../TileRange.js\").default=} opt_tileRange Temporary tile range object.\n * @return {import(\"../TileRange.js\").default} Tile range.\n */\nTileGrid.prototype.getTileRangeForExtentAndZ = function getTileRangeForExtentAndZ (extent, z, opt_tileRange) {\n  var tileCoord = tmpTileCoord;\n  this.getTileCoordForXYAndZ_(extent[0], extent[1], z, false, tileCoord);\n  var minX = tileCoord[1];\n  var minY = tileCoord[2];\n  this.getTileCoordForXYAndZ_(extent[2], extent[3], z, true, tileCoord);\n  return createOrUpdateTileRange(minX, tileCoord[1], minY, tileCoord[2], opt_tileRange);\n};\n\n/**\n * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @return {import(\"../coordinate.js\").Coordinate} Tile center.\n */\nTileGrid.prototype.getTileCoordCenter = function getTileCoordCenter (tileCoord) {\n  var origin = this.getOrigin(tileCoord[0]);\n  var resolution = this.getResolution(tileCoord[0]);\n  var tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\n  return [\n    origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution,\n    origin[1] + (tileCoord[2] + 0.5) * tileSize[1] * resolution\n  ];\n};\n\n/**\n * Get the extent of a tile coordinate.\n *\n * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @param {import(\"../extent.js\").Extent=} opt_extent Temporary extent object.\n * @return {import(\"../extent.js\").Extent} Extent.\n * @api\n */\nTileGrid.prototype.getTileCoordExtent = function getTileCoordExtent (tileCoord, opt_extent) {\n  var origin = this.getOrigin(tileCoord[0]);\n  var resolution = this.getResolution(tileCoord[0]);\n  var tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\n  var minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;\n  var minY = origin[1] + tileCoord[2] * tileSize[1] * resolution;\n  var maxX = minX + tileSize[0] * resolution;\n  var maxY = minY + tileSize[1] * resolution;\n  return createOrUpdate(minX, minY, maxX, maxY, opt_extent);\n};\n\n/**\n * Get the tile coordinate for the given map coordinate and resolution.This\n * method considers that coordinates that intersect tile boundaries should be\n * assigned the higher tile coordinate.\n *\n * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n * @param {number} resolution Resolution.\n * @param {import(\"../tilecoord.js\").TileCoord=} opt_tileCoord Destination import(\"../tilecoord.js\").TileCoord object.\n * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n * @api\n */\nTileGrid.prototype.getTileCoordForCoordAndResolution = function getTileCoordForCoordAndResolution (coordinate, resolution, opt_tileCoord) {\n  return this.getTileCoordForXYAndResolution_(\n    coordinate[0], coordinate[1], resolution, false, opt_tileCoord);\n};\n\n/**\n * Note that this method should not be called for resolutions that correspond\n * to an integer zoom level.Instead call the `getTileCoordForXYAndZ_` method.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {number} resolution Resolution (for a non-integer zoom level).\n * @param {boolean} reverseIntersectionPolicy Instead of letting edge\n *   intersections go to the higher tile coordinate, let edge intersections\n *   go to the lower tile coordinate.\n * @param {import(\"../tilecoord.js\").TileCoord=} opt_tileCoord Temporary import(\"../tilecoord.js\").TileCoord object.\n * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n * @private\n */\nTileGrid.prototype.getTileCoordForXYAndResolution_ = function getTileCoordForXYAndResolution_ (x, y, resolution, reverseIntersectionPolicy, opt_tileCoord) {\n  var z = this.getZForResolution(resolution);\n  var scale = resolution / this.getResolution(z);\n  var origin = this.getOrigin(z);\n  var tileSize = toSize(this.getTileSize(z), this.tmpSize_);\n\n  var adjustX = reverseIntersectionPolicy ? 0.5 : 0;\n  var adjustY = reverseIntersectionPolicy ? 0 : 0.5;\n  var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);\n  var yFromOrigin = Math.floor((y - origin[1]) / resolution + adjustY);\n  var tileCoordX = scale * xFromOrigin / tileSize[0];\n  var tileCoordY = scale * yFromOrigin / tileSize[1];\n\n  if (reverseIntersectionPolicy) {\n    tileCoordX = Math.ceil(tileCoordX) - 1;\n    tileCoordY = Math.ceil(tileCoordY) - 1;\n  } else {\n    tileCoordX = Math.floor(tileCoordX);\n    tileCoordY = Math.floor(tileCoordY);\n  }\n\n  return createOrUpdateTileCoord(z, tileCoordX, tileCoordY, opt_tileCoord);\n};\n\n/**\n * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,\n * they should have separate implementations.This method is for integer zoom\n * levels.The other method should only be called for resolutions corresponding\n * to non-integer zoom levels.\n * @param {number} x Map x coordinate.\n * @param {number} y Map y coordinate.\n * @param {number} z Integer zoom level.\n * @param {boolean} reverseIntersectionPolicy Instead of letting edge\n *   intersections go to the higher tile coordinate, let edge intersections\n *   go to the lower tile coordinate.\n * @param {import(\"../tilecoord.js\").TileCoord=} opt_tileCoord Temporary import(\"../tilecoord.js\").TileCoord object.\n * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n * @private\n */\nTileGrid.prototype.getTileCoordForXYAndZ_ = function getTileCoordForXYAndZ_ (x, y, z, reverseIntersectionPolicy, opt_tileCoord) {\n  var origin = this.getOrigin(z);\n  var resolution = this.getResolution(z);\n  var tileSize = toSize(this.getTileSize(z), this.tmpSize_);\n\n  var adjustX = reverseIntersectionPolicy ? 0.5 : 0;\n  var adjustY = reverseIntersectionPolicy ? 0 : 0.5;\n  var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);\n  var yFromOrigin = Math.floor((y - origin[1]) / resolution + adjustY);\n  var tileCoordX = xFromOrigin / tileSize[0];\n  var tileCoordY = yFromOrigin / tileSize[1];\n\n  if (reverseIntersectionPolicy) {\n    tileCoordX = Math.ceil(tileCoordX) - 1;\n    tileCoordY = Math.ceil(tileCoordY) - 1;\n  } else {\n    tileCoordX = Math.floor(tileCoordX);\n    tileCoordY = Math.floor(tileCoordY);\n  }\n\n  return createOrUpdateTileCoord(z, tileCoordX, tileCoordY, opt_tileCoord);\n};\n\n/**\n * Get a tile coordinate given a map coordinate and zoom level.\n * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n * @param {number} z Zoom level.\n * @param {import(\"../tilecoord.js\").TileCoord=} opt_tileCoord Destination import(\"../tilecoord.js\").TileCoord object.\n * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n * @api\n */\nTileGrid.prototype.getTileCoordForCoordAndZ = function getTileCoordForCoordAndZ (coordinate, z, opt_tileCoord) {\n  return this.getTileCoordForXYAndZ_(\n    coordinate[0], coordinate[1], z, false, opt_tileCoord);\n};\n\n/**\n * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @return {number} Tile resolution.\n */\nTileGrid.prototype.getTileCoordResolution = function getTileCoordResolution (tileCoord) {\n  return this.resolutions_[tileCoord[0]];\n};\n\n/**\n * Get the tile size for a zoom level. The type of the return value matches the\n * `tileSize` or `tileSizes` that the tile grid was configured with. To always\n * get an `import(\"../size.js\").Size`, run the result through `import(\"../size.js\").Size.toSize()`.\n * @param {number} z Z.\n * @return {number|import(\"../size.js\").Size} Tile size.\n * @api\n */\nTileGrid.prototype.getTileSize = function getTileSize (z) {\n  if (this.tileSize_) {\n    return this.tileSize_;\n  } else {\n    return this.tileSizes_[z];\n  }\n};\n\n/**\n * @param {number} z Zoom level.\n * @return {import(\"../TileRange.js\").default} Extent tile range for the specified zoom level.\n */\nTileGrid.prototype.getFullTileRange = function getFullTileRange (z) {\n  if (!this.fullTileRanges_) {\n    return null;\n  } else {\n    return this.fullTileRanges_[z];\n  }\n};\n\n/**\n * @param {number} resolution Resolution.\n * @param {number=} opt_direction If 0, the nearest resolution will be used.\n *   If 1, the nearest lower resolution will be used. If -1, the nearest\n *   higher resolution will be used. Default is 0.\n * @return {number} Z.\n * @api\n */\nTileGrid.prototype.getZForResolution = function getZForResolution (resolution, opt_direction) {\n  var z = linearFindNearest(this.resolutions_, resolution, opt_direction || 0);\n  return clamp(z, this.minZoom, this.maxZoom);\n};\n\n/**\n * @param {!import(\"../extent.js\").Extent} extent Extent for this tile grid.\n * @private\n */\nTileGrid.prototype.calculateTileRanges_ = function calculateTileRanges_ (extent) {\n  var length = this.resolutions_.length;\n  var fullTileRanges = new Array(length);\n  for (var z = this.minZoom; z < length; ++z) {\n    fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);\n  }\n  this.fullTileRanges_ = fullTileRanges;\n};\n\n\nexport default TileGrid;\n\n//# sourceMappingURL=TileGrid.js.map","/**\n * @module ol/tileurlfunction\n */\nimport {assert} from './asserts.js';\nimport {modulo} from './math.js';\nimport {hash as tileCoordHash} from './tilecoord.js';\n\n\n/**\n * @param {string} template Template.\n * @param {import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {import(\"./Tile.js\").UrlFunction} Tile URL function.\n */\nexport function createFromTemplate(template, tileGrid) {\n  var zRegEx = /\\{z\\}/g;\n  var xRegEx = /\\{x\\}/g;\n  var yRegEx = /\\{y\\}/g;\n  var dashYRegEx = /\\{-y\\}/g;\n  return (\n    /**\n     * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile Coordinate.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"./proj/Projection.js\").default} projection Projection.\n     * @return {string|undefined} Tile URL.\n     */\n    function(tileCoord, pixelRatio, projection) {\n      if (!tileCoord) {\n        return undefined;\n      } else {\n        return template.replace(zRegEx, tileCoord[0].toString())\n          .replace(xRegEx, tileCoord[1].toString())\n          .replace(yRegEx, function() {\n            var y = -tileCoord[2] - 1;\n            return y.toString();\n          })\n          .replace(dashYRegEx, function() {\n            var z = tileCoord[0];\n            var range = tileGrid.getFullTileRange(z);\n            assert(range, 55); // The {-y} placeholder requires a tile grid with extent\n            var y = range.getHeight() + tileCoord[2];\n            return y.toString();\n          });\n      }\n    }\n  );\n}\n\n\n/**\n * @param {Array<string>} templates Templates.\n * @param {import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {import(\"./Tile.js\").UrlFunction} Tile URL function.\n */\nexport function createFromTemplates(templates, tileGrid) {\n  var len = templates.length;\n  var tileUrlFunctions = new Array(len);\n  for (var i = 0; i < len; ++i) {\n    tileUrlFunctions[i] = createFromTemplate(templates[i], tileGrid);\n  }\n  return createFromTileUrlFunctions(tileUrlFunctions);\n}\n\n\n/**\n * @param {Array<import(\"./Tile.js\").UrlFunction>} tileUrlFunctions Tile URL Functions.\n * @return {import(\"./Tile.js\").UrlFunction} Tile URL function.\n */\nexport function createFromTileUrlFunctions(tileUrlFunctions) {\n  if (tileUrlFunctions.length === 1) {\n    return tileUrlFunctions[0];\n  }\n  return (\n    /**\n     * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile Coordinate.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"./proj/Projection.js\").default} projection Projection.\n     * @return {string|undefined} Tile URL.\n     */\n    function(tileCoord, pixelRatio, projection) {\n      if (!tileCoord) {\n        return undefined;\n      } else {\n        var h = tileCoordHash(tileCoord);\n        var index = modulo(h, tileUrlFunctions.length);\n        return tileUrlFunctions[index](tileCoord, pixelRatio, projection);\n      }\n    }\n  );\n}\n\n\n/**\n * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @param {number} pixelRatio Pixel ratio.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {string|undefined} Tile URL.\n */\nexport function nullTileUrlFunction(tileCoord, pixelRatio, projection) {\n  return undefined;\n}\n\n\n/**\n * @param {string} url URL.\n * @return {Array<string>} Array of urls.\n */\nexport function expandUrl(url) {\n  var urls = [];\n  var match = /\\{([a-z])-([a-z])\\}/.exec(url);\n  if (match) {\n    // char range\n    var startCharCode = match[1].charCodeAt(0);\n    var stopCharCode = match[2].charCodeAt(0);\n    var charCode;\n    for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {\n      urls.push(url.replace(match[0], String.fromCharCode(charCode)));\n    }\n    return urls;\n  }\n  match = match = /\\{(\\d+)-(\\d+)\\}/.exec(url);\n  if (match) {\n    // number range\n    var stop = parseInt(match[2], 10);\n    for (var i = parseInt(match[1], 10); i <= stop; i++) {\n      urls.push(url.replace(match[0], i.toString()));\n    }\n    return urls;\n  }\n  urls.push(url);\n  return urls;\n}\n\n//# sourceMappingURL=tileurlfunction.js.map","/**\n * @module ol/transform\n */\nimport {assert} from './asserts.js';\n\n\n/**\n * An array representing an affine 2d transformation for use with\n * {@link module:ol/transform} functions. The array has 6 elements.\n * @typedef {!Array<number>} Transform\n */\n\n\n/**\n * Collection of affine 2d transformation functions. The functions work on an\n * array of 6 elements. The element order is compatible with the [SVGMatrix\n * interface](https://developer.mozilla.org/en-US/docs/Web/API/SVGMatrix) and is\n * a subset (elements a to f) of a 33 matrix:\n * ```\n * [ a c e ]\n * [ b d f ]\n * [ 0 0 1 ]\n * ```\n */\n\n\n/**\n * @private\n * @type {Transform}\n */\nvar tmp_ = new Array(6);\n\n\n/**\n * Create an identity transform.\n * @return {!Transform} Identity transform.\n */\nexport function create() {\n  return [1, 0, 0, 1, 0, 0];\n}\n\n\n/**\n * Resets the given transform to an identity transform.\n * @param {!Transform} transform Transform.\n * @return {!Transform} Transform.\n */\nexport function reset(transform) {\n  return set(transform, 1, 0, 0, 1, 0, 0);\n}\n\n\n/**\n * Multiply the underlying matrices of two transforms and return the result in\n * the first transform.\n * @param {!Transform} transform1 Transform parameters of matrix 1.\n * @param {!Transform} transform2 Transform parameters of matrix 2.\n * @return {!Transform} transform1 multiplied with transform2.\n */\nexport function multiply(transform1, transform2) {\n  var a1 = transform1[0];\n  var b1 = transform1[1];\n  var c1 = transform1[2];\n  var d1 = transform1[3];\n  var e1 = transform1[4];\n  var f1 = transform1[5];\n  var a2 = transform2[0];\n  var b2 = transform2[1];\n  var c2 = transform2[2];\n  var d2 = transform2[3];\n  var e2 = transform2[4];\n  var f2 = transform2[5];\n\n  transform1[0] = a1 * a2 + c1 * b2;\n  transform1[1] = b1 * a2 + d1 * b2;\n  transform1[2] = a1 * c2 + c1 * d2;\n  transform1[3] = b1 * c2 + d1 * d2;\n  transform1[4] = a1 * e2 + c1 * f2 + e1;\n  transform1[5] = b1 * e2 + d1 * f2 + f1;\n\n  return transform1;\n}\n\n/**\n * Set the transform components a-f on a given transform.\n * @param {!Transform} transform Transform.\n * @param {number} a The a component of the transform.\n * @param {number} b The b component of the transform.\n * @param {number} c The c component of the transform.\n * @param {number} d The d component of the transform.\n * @param {number} e The e component of the transform.\n * @param {number} f The f component of the transform.\n * @return {!Transform} Matrix with transform applied.\n */\nexport function set(transform, a, b, c, d, e, f) {\n  transform[0] = a;\n  transform[1] = b;\n  transform[2] = c;\n  transform[3] = d;\n  transform[4] = e;\n  transform[5] = f;\n  return transform;\n}\n\n\n/**\n * Set transform on one matrix from another matrix.\n * @param {!Transform} transform1 Matrix to set transform to.\n * @param {!Transform} transform2 Matrix to set transform from.\n * @return {!Transform} transform1 with transform from transform2 applied.\n */\nexport function setFromArray(transform1, transform2) {\n  transform1[0] = transform2[0];\n  transform1[1] = transform2[1];\n  transform1[2] = transform2[2];\n  transform1[3] = transform2[3];\n  transform1[4] = transform2[4];\n  transform1[5] = transform2[5];\n  return transform1;\n}\n\n\n/**\n * Transforms the given coordinate with the given transform returning the\n * resulting, transformed coordinate. The coordinate will be modified in-place.\n *\n * @param {Transform} transform The transformation.\n * @param {import(\"./coordinate.js\").Coordinate|import(\"./pixel.js\").Pixel} coordinate The coordinate to transform.\n * @return {import(\"./coordinate.js\").Coordinate|import(\"./pixel.js\").Pixel} return coordinate so that operations can be\n *     chained together.\n */\nexport function apply(transform, coordinate) {\n  var x = coordinate[0];\n  var y = coordinate[1];\n  coordinate[0] = transform[0] * x + transform[2] * y + transform[4];\n  coordinate[1] = transform[1] * x + transform[3] * y + transform[5];\n  return coordinate;\n}\n\n\n/**\n * Applies rotation to the given transform.\n * @param {!Transform} transform Transform.\n * @param {number} angle Angle in radians.\n * @return {!Transform} The rotated transform.\n */\nexport function rotate(transform, angle) {\n  var cos = Math.cos(angle);\n  var sin = Math.sin(angle);\n  return multiply(transform, set(tmp_, cos, sin, -sin, cos, 0, 0));\n}\n\n\n/**\n * Applies scale to a given transform.\n * @param {!Transform} transform Transform.\n * @param {number} x Scale factor x.\n * @param {number} y Scale factor y.\n * @return {!Transform} The scaled transform.\n */\nexport function scale(transform, x, y) {\n  return multiply(transform, set(tmp_, x, 0, 0, y, 0, 0));\n}\n\n\n/**\n * Applies translation to the given transform.\n * @param {!Transform} transform Transform.\n * @param {number} dx Translation x.\n * @param {number} dy Translation y.\n * @return {!Transform} The translated transform.\n */\nexport function translate(transform, dx, dy) {\n  return multiply(transform, set(tmp_, 1, 0, 0, 1, dx, dy));\n}\n\n\n/**\n * Creates a composite transform given an initial translation, scale, rotation, and\n * final translation (in that order only, not commutative).\n * @param {!Transform} transform The transform (will be modified in place).\n * @param {number} dx1 Initial translation x.\n * @param {number} dy1 Initial translation y.\n * @param {number} sx Scale factor x.\n * @param {number} sy Scale factor y.\n * @param {number} angle Rotation (in counter-clockwise radians).\n * @param {number} dx2 Final translation x.\n * @param {number} dy2 Final translation y.\n * @return {!Transform} The composite transform.\n */\nexport function compose(transform, dx1, dy1, sx, sy, angle, dx2, dy2) {\n  var sin = Math.sin(angle);\n  var cos = Math.cos(angle);\n  transform[0] = sx * cos;\n  transform[1] = sy * sin;\n  transform[2] = -sx * sin;\n  transform[3] = sy * cos;\n  transform[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;\n  transform[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;\n  return transform;\n}\n\n\n/**\n * Invert the given transform.\n * @param {!Transform} transform Transform.\n * @return {!Transform} Inverse of the transform.\n */\nexport function invert(transform) {\n  var det = determinant(transform);\n  assert(det !== 0, 32); // Transformation matrix cannot be inverted\n\n  var a = transform[0];\n  var b = transform[1];\n  var c = transform[2];\n  var d = transform[3];\n  var e = transform[4];\n  var f = transform[5];\n\n  transform[0] = d / det;\n  transform[1] = -b / det;\n  transform[2] = -c / det;\n  transform[3] = a / det;\n  transform[4] = (c * f - d * e) / det;\n  transform[5] = -(a * f - b * e) / det;\n\n  return transform;\n}\n\n\n/**\n * Returns the determinant of the given matrix.\n * @param {!Transform} mat Matrix.\n * @return {number} Determinant.\n */\nexport function determinant(mat) {\n  return mat[0] * mat[3] - mat[1] * mat[2];\n}\n\n//# sourceMappingURL=transform.js.map","/**\n * @module ol/uri\n */\n\n\n/**\n * Appends query parameters to a URI.\n *\n * @param {string} uri The original URI, which may already have query data.\n * @param {!Object} params An object where keys are URI-encoded parameter keys,\n *     and the values are arbitrary types or arrays.\n * @return {string} The new URI.\n */\nexport function appendParams(uri, params) {\n  var keyParams = [];\n  // Skip any null or undefined parameter values\n  Object.keys(params).forEach(function(k) {\n    if (params[k] !== null && params[k] !== undefined) {\n      keyParams.push(k + '=' + encodeURIComponent(params[k]));\n    }\n  });\n  var qs = keyParams.join('&');\n  // remove any trailing ? or &\n  uri = uri.replace(/[?&]$/, '');\n  // append ? or & depending on whether uri has existing parameters\n  uri = uri.indexOf('?') === -1 ? uri + '?' : uri + '&';\n  return uri + qs;\n}\n\n//# sourceMappingURL=uri.js.map","/**\n * @module ol/xml\n */\nimport {extend} from './array.js';\n\n\n/**\n * When using {@link module:ol/xml~makeChildAppender} or\n * {@link module:ol/xml~makeSimpleNodeFactory}, the top `objectStack` item needs\n * to have this structure.\n * @typedef {Object} NodeStackItem\n * @property {Node} node\n */\n\n\n/**\n * @typedef {function(Element, Array<*>)} Parser\n */\n\n\n/**\n * @typedef {function(Element, *, Array<*>)} Serializer\n */\n\n\n/**\n * This document should be used when creating nodes for XML serializations. This\n * document is also used by {@link module:ol/xml~createElementNS}\n * @const\n * @type {Document}\n */\nexport var DOCUMENT = document.implementation.createDocument('', '', null);\n\n\n/**\n * @type {string}\n */\nexport var XML_SCHEMA_INSTANCE_URI = 'http://www.w3.org/2001/XMLSchema-instance';\n\n\n/**\n * @param {string} namespaceURI Namespace URI.\n * @param {string} qualifiedName Qualified name.\n * @return {Element} Node.\n */\nexport function createElementNS(namespaceURI, qualifiedName) {\n  return DOCUMENT.createElementNS(namespaceURI, qualifiedName);\n}\n\n\n/**\n * Recursively grab all text content of child nodes into a single string.\n * @param {Node} node Node.\n * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line\n * breaks.\n * @return {string} All text content.\n * @api\n */\nexport function getAllTextContent(node, normalizeWhitespace) {\n  return getAllTextContent_(node, normalizeWhitespace, []).join('');\n}\n\n\n/**\n * Recursively grab all text content of child nodes into a single string.\n * @param {Node} node Node.\n * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line\n * breaks.\n * @param {Array<string>} accumulator Accumulator.\n * @private\n * @return {Array<string>} Accumulator.\n */\nexport function getAllTextContent_(node, normalizeWhitespace, accumulator) {\n  if (node.nodeType == Node.CDATA_SECTION_NODE ||\n      node.nodeType == Node.TEXT_NODE) {\n    if (normalizeWhitespace) {\n      accumulator.push(String(node.nodeValue).replace(/(\\r\\n|\\r|\\n)/g, ''));\n    } else {\n      accumulator.push(node.nodeValue);\n    }\n  } else {\n    var n;\n    for (n = node.firstChild; n; n = n.nextSibling) {\n      getAllTextContent_(n, normalizeWhitespace, accumulator);\n    }\n  }\n  return accumulator;\n}\n\n\n/**\n * @param {Object} object Object.\n * @return {boolean} Is a document.\n */\nexport function isDocument(object) {\n  return 'documentElement' in object;\n}\n\n\n/**\n * @param {Element} node Node.\n * @param {?string} namespaceURI Namespace URI.\n * @param {string} name Attribute name.\n * @return {string} Value\n */\nexport function getAttributeNS(node, namespaceURI, name) {\n  return node.getAttributeNS(namespaceURI, name) || '';\n}\n\n\n/**\n * Parse an XML string to an XML Document.\n * @param {string} xml XML.\n * @return {Document} Document.\n * @api\n */\nexport function parse(xml) {\n  return new DOMParser().parseFromString(xml, 'application/xml');\n}\n\n\n/**\n * Make an array extender function for extending the array at the top of the\n * object stack.\n * @param {function(this: T, Node, Array<*>): (Array<*>|undefined)} valueReader Value reader.\n * @param {T=} opt_this The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeArrayExtender(valueReader, opt_this) {\n  return (\n    /**\n     * @param {Node} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function(node, objectStack) {\n      var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);\n      if (value !== undefined) {\n        var array = /** @type {Array<*>} */ (objectStack[objectStack.length - 1]);\n        extend(array, value);\n      }\n    }\n  );\n}\n\n\n/**\n * Make an array pusher function for pushing to the array at the top of the\n * object stack.\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\n * @param {T=} opt_this The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeArrayPusher(valueReader, opt_this) {\n  return (\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function(node, objectStack) {\n      var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);\n      if (value !== undefined) {\n        var array = /** @type {Array<*>} */ (objectStack[objectStack.length - 1]);\n        array.push(value);\n      }\n    });\n}\n\n\n/**\n * Make an object stack replacer function for replacing the object at the\n * top of the stack.\n * @param {function(this: T, Node, Array<*>): *} valueReader Value reader.\n * @param {T=} opt_this The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeReplacer(valueReader, opt_this) {\n  return (\n    /**\n     * @param {Node} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function(node, objectStack) {\n      var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);\n      if (value !== undefined) {\n        objectStack[objectStack.length - 1] = value;\n      }\n    });\n}\n\n\n/**\n * Make an object property pusher function for adding a property to the\n * object at the top of the stack.\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\n * @param {string=} opt_property Property.\n * @param {T=} opt_this The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeObjectPropertyPusher(valueReader, opt_property, opt_this) {\n  return (\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function(node, objectStack) {\n      var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);\n      if (value !== undefined) {\n        var object = /** @type {!Object} */ (objectStack[objectStack.length - 1]);\n        var property = opt_property !== undefined ? opt_property : node.localName;\n        var array;\n        if (property in object) {\n          array = object[property];\n        } else {\n          array = object[property] = [];\n        }\n        array.push(value);\n      }\n    });\n}\n\n\n/**\n * Make an object property setter function.\n * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.\n * @param {string=} opt_property Property.\n * @param {T=} opt_this The object to use as `this` in `valueReader`.\n * @return {Parser} Parser.\n * @template T\n */\nexport function makeObjectPropertySetter(valueReader, opt_property, opt_this) {\n  return (\n    /**\n     * @param {Element} node Node.\n     * @param {Array<*>} objectStack Object stack.\n     */\n    function(node, objectStack) {\n      var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);\n      if (value !== undefined) {\n        var object = /** @type {!Object} */ (objectStack[objectStack.length - 1]);\n        var property = opt_property !== undefined ? opt_property : node.localName;\n        object[property] = value;\n      }\n    });\n}\n\n\n/**\n * Create a serializer that appends nodes written by its `nodeWriter` to its\n * designated parent. The parent is the `node` of the\n * {@link module:ol/xml~NodeStackItem} at the top of the `objectStack`.\n * @param {function(this: T, Node, V, Array<*>)} nodeWriter Node writer.\n * @param {T=} opt_this The object to use as `this` in `nodeWriter`.\n * @return {Serializer} Serializer.\n * @template T, V\n */\nexport function makeChildAppender(nodeWriter, opt_this) {\n  return function(node, value, objectStack) {\n    nodeWriter.call(opt_this !== undefined ? opt_this : this, node, value, objectStack);\n    var parent = /** @type {NodeStackItem} */ (objectStack[objectStack.length - 1]);\n    var parentNode = parent.node;\n    parentNode.appendChild(node);\n  };\n}\n\n\n/**\n * Create a serializer that calls the provided `nodeWriter` from\n * {@link module:ol/xml~serialize}. This can be used by the parent writer to have the\n * 'nodeWriter' called with an array of values when the `nodeWriter` was\n * designed to serialize a single item. An example would be a LineString\n * geometry writer, which could be reused for writing MultiLineString\n * geometries.\n * @param {function(this: T, Element, V, Array<*>)} nodeWriter Node writer.\n * @param {T=} opt_this The object to use as `this` in `nodeWriter`.\n * @return {Serializer} Serializer.\n * @template T, V\n */\nexport function makeArraySerializer(nodeWriter, opt_this) {\n  var serializersNS, nodeFactory;\n  return function(node, value, objectStack) {\n    if (serializersNS === undefined) {\n      serializersNS = {};\n      var serializers = {};\n      serializers[node.localName] = nodeWriter;\n      serializersNS[node.namespaceURI] = serializers;\n      nodeFactory = makeSimpleNodeFactory(node.localName);\n    }\n    serialize(serializersNS, nodeFactory, value, objectStack);\n  };\n}\n\n\n/**\n * Create a node factory which can use the `opt_keys` passed to\n * {@link module:ol/xml~serialize} or {@link module:ol/xml~pushSerializeAndPop} as node names,\n * or a fixed node name. The namespace of the created nodes can either be fixed,\n * or the parent namespace will be used.\n * @param {string=} opt_nodeName Fixed node name which will be used for all\n *     created nodes. If not provided, the 3rd argument to the resulting node\n *     factory needs to be provided and will be the nodeName.\n * @param {string=} opt_namespaceURI Fixed namespace URI which will be used for\n *     all created nodes. If not provided, the namespace of the parent node will\n *     be used.\n * @return {function(*, Array<*>, string=): (Node|undefined)} Node factory.\n */\nexport function makeSimpleNodeFactory(opt_nodeName, opt_namespaceURI) {\n  var fixedNodeName = opt_nodeName;\n  return (\n    /**\n     * @param {*} value Value.\n     * @param {Array<*>} objectStack Object stack.\n     * @param {string=} opt_nodeName Node name.\n     * @return {Node} Node.\n     */\n    function(value, objectStack, opt_nodeName) {\n      var context = /** @type {NodeStackItem} */ (objectStack[objectStack.length - 1]);\n      var node = context.node;\n      var nodeName = fixedNodeName;\n      if (nodeName === undefined) {\n        nodeName = opt_nodeName;\n      }\n\n      var namespaceURI = opt_namespaceURI !== undefined ? opt_namespaceURI : node.namespaceURI;\n      return createElementNS(namespaceURI, /** @type {string} */ (nodeName));\n    }\n  );\n}\n\n\n/**\n * A node factory that creates a node using the parent's `namespaceURI` and the\n * `nodeName` passed by {@link module:ol/xml~serialize} or\n * {@link module:ol/xml~pushSerializeAndPop} to the node factory.\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\nexport var OBJECT_PROPERTY_NODE_FACTORY = makeSimpleNodeFactory();\n\n\n/**\n * Create an array of `values` to be used with {@link module:ol/xml~serialize} or\n * {@link module:ol/xml~pushSerializeAndPop}, where `orderedKeys` has to be provided as\n * `opt_key` argument.\n * @param {Object<string, V>} object Key-value pairs for the sequence. Keys can\n *     be a subset of the `orderedKeys`.\n * @param {Array<string>} orderedKeys Keys in the order of the sequence.\n * @return {Array<V>} Values in the order of the sequence. The resulting array\n *     has the same length as the `orderedKeys` array. Values that are not\n *     present in `object` will be `undefined` in the resulting array.\n * @template V\n */\nexport function makeSequence(object, orderedKeys) {\n  var length = orderedKeys.length;\n  var sequence = new Array(length);\n  for (var i = 0; i < length; ++i) {\n    sequence[i] = object[orderedKeys[i]];\n  }\n  return sequence;\n}\n\n\n/**\n * Create a namespaced structure, using the same values for each namespace.\n * This can be used as a starting point for versioned parsers, when only a few\n * values are version specific.\n * @param {Array<string>} namespaceURIs Namespace URIs.\n * @param {T} structure Structure.\n * @param {Object<string, T>=} opt_structureNS Namespaced structure to add to.\n * @return {Object<string, T>} Namespaced structure.\n * @template T\n */\nexport function makeStructureNS(namespaceURIs, structure, opt_structureNS) {\n  /**\n   * @type {Object<string, T>}\n   */\n  var structureNS = opt_structureNS !== undefined ? opt_structureNS : {};\n  var i, ii;\n  for (i = 0, ii = namespaceURIs.length; i < ii; ++i) {\n    structureNS[namespaceURIs[i]] = structure;\n  }\n  return structureNS;\n}\n\n\n/**\n * Parse a node using the parsers and object stack.\n * @param {Object<string, Object<string, Parser>>} parsersNS\n *     Parsers by namespace.\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @param {*=} opt_this The object to use as `this`.\n */\nexport function parseNode(parsersNS, node, objectStack, opt_this) {\n  var n;\n  for (n = node.firstElementChild; n; n = n.nextElementSibling) {\n    var parsers = parsersNS[n.namespaceURI];\n    if (parsers !== undefined) {\n      var parser = parsers[n.localName];\n      if (parser !== undefined) {\n        parser.call(opt_this, n, objectStack);\n      }\n    }\n  }\n}\n\n\n/**\n * Push an object on top of the stack, parse and return the popped object.\n * @param {T} object Object.\n * @param {Object<string, Object<string, Parser>>} parsersNS\n *     Parsers by namespace.\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @param {*=} opt_this The object to use as `this`.\n * @return {T} Object.\n * @template T\n */\nexport function pushParseAndPop(object, parsersNS, node, objectStack, opt_this) {\n  objectStack.push(object);\n  parseNode(parsersNS, node, objectStack, opt_this);\n  return /** @type {T} */ (objectStack.pop());\n}\n\n\n/**\n * Walk through an array of `values` and call a serializer for each value.\n * @param {Object<string, Object<string, Serializer>>} serializersNS\n *     Namespaced serializers.\n * @param {function(this: T, *, Array<*>, (string|undefined)): (Node|undefined)} nodeFactory\n *     Node factory. The `nodeFactory` creates the node whose namespace and name\n *     will be used to choose a node writer from `serializersNS`. This\n *     separation allows us to decide what kind of node to create, depending on\n *     the value we want to serialize. An example for this would be different\n *     geometry writers based on the geometry type.\n * @param {Array<*>} values Values to serialize. An example would be an array\n *     of {@link module:ol/Feature~Feature} instances.\n * @param {Array<*>} objectStack Node stack.\n * @param {Array<string>=} opt_keys Keys of the `values`. Will be passed to the\n *     `nodeFactory`. This is used for serializing object literals where the\n *     node name relates to the property key. The array length of `opt_keys` has\n *     to match the length of `values`. For serializing a sequence, `opt_keys`\n *     determines the order of the sequence.\n * @param {T=} opt_this The object to use as `this` for the node factory and\n *     serializers.\n * @template T\n */\nexport function serialize(\n  serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this) {\n  var length = (opt_keys !== undefined ? opt_keys : values).length;\n  var value, node;\n  for (var i = 0; i < length; ++i) {\n    value = values[i];\n    if (value !== undefined) {\n      node = nodeFactory.call(opt_this !== undefined ? opt_this : this, value, objectStack,\n        opt_keys !== undefined ? opt_keys[i] : undefined);\n      if (node !== undefined) {\n        serializersNS[node.namespaceURI][node.localName]\n          .call(opt_this, node, value, objectStack);\n      }\n    }\n  }\n}\n\n\n/**\n * @param {O} object Object.\n * @param {Object<string, Object<string, Serializer>>} serializersNS\n *     Namespaced serializers.\n * @param {function(this: T, *, Array<*>, (string|undefined)): (Node|undefined)} nodeFactory\n *     Node factory. The `nodeFactory` creates the node whose namespace and name\n *     will be used to choose a node writer from `serializersNS`. This\n *     separation allows us to decide what kind of node to create, depending on\n *     the value we want to serialize. An example for this would be different\n *     geometry writers based on the geometry type.\n * @param {Array<*>} values Values to serialize. An example would be an array\n *     of {@link module:ol/Feature~Feature} instances.\n * @param {Array<*>} objectStack Node stack.\n * @param {Array<string>=} opt_keys Keys of the `values`. Will be passed to the\n *     `nodeFactory`. This is used for serializing object literals where the\n *     node name relates to the property key. The array length of `opt_keys` has\n *     to match the length of `values`. For serializing a sequence, `opt_keys`\n *     determines the order of the sequence.\n * @param {T=} opt_this The object to use as `this` for the node factory and\n *     serializers.\n * @return {O|undefined} Object.\n * @template O, T\n */\nexport function pushSerializeAndPop(object, serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this) {\n  objectStack.push(object);\n  serialize(serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this);\n  return /** @type {O|undefined} */ (objectStack.pop());\n}\n\n//# sourceMappingURL=xml.js.map"],"sourceRoot":""}
{"version":3,"file":"js/2559.23111f35.js","mappings":"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","sources":["webpack://@openeo/web-editor/./node_modules/ol/renderer/webgl/TileLayerBase.js","webpack://@openeo/web-editor/./node_modules/ol/renderer/webgl/TileLayer.js","webpack://@openeo/web-editor/./node_modules/ol/renderer/canvas/TileLayer.js","webpack://@openeo/web-editor/./node_modules/ol/renderer/canvas/VectorTileLayer.js","webpack://@openeo/web-editor/./node_modules/ol/renderer/canvas/VectorLayer.js","webpack://@openeo/web-editor/./node_modules/ol/renderer/webgl/Layer.js","webpack://@openeo/web-editor/./node_modules/ol/renderer/canvas/ImageLayer.js","webpack://@openeo/web-editor/./node_modules/ol/renderer/vector.js","webpack://@openeo/web-editor/./node_modules/ol/renderer/webgl/worldUtil.js","webpack://@openeo/web-editor/./node_modules/ol/renderer/webgl/PointsLayer.js","webpack://@openeo/web-editor/./node_modules/ol/renderer/canvas/Layer.js"],"sourcesContent":["/**\n * @module ol/renderer/webgl/TileLayerBase\n */\nimport LRUCache from '../../structs/LRUCache.js';\nimport ReprojDataTile from '../../reproj/DataTile.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport WebGLLayerRenderer from './Layer.js';\nimport {abstract, getUid} from '../../util.js';\nimport {create as createMat4} from '../../vec/mat4.js';\nimport {\n  createOrUpdate as createTileCoord,\n  getKey as getTileCoordKey,\n} from '../../tilecoord.js';\nimport {\n  create as createTransform,\n  reset as resetTransform,\n  rotate as rotateTransform,\n  scale as scaleTransform,\n  translate as translateTransform,\n} from '../../transform.js';\nimport {descending} from '../../array.js';\nimport {fromUserExtent} from '../../proj.js';\nimport {getIntersection, isEmpty} from '../../extent.js';\nimport {toSize} from '../../size.js';\n\nexport const Uniforms = {\n  TILE_TRANSFORM: 'u_tileTransform',\n  TRANSITION_ALPHA: 'u_transitionAlpha',\n  DEPTH: 'u_depth',\n  RENDER_EXTENT: 'u_renderExtent', // intersection of layer, source, and view extent\n  PATTERN_ORIGIN: 'u_patternOrigin',\n  RESOLUTION: 'u_resolution',\n  ZOOM: 'u_zoom',\n  GLOBAL_ALPHA: 'u_globalAlpha',\n  PROJECTION_MATRIX: 'u_projectionMatrix',\n  SCREEN_TO_WORLD_MATRIX: 'u_screenToWorldMatrix',\n};\n\n/**\n * @type {Object<string, boolean>}\n */\nconst empty = {};\n\n/**\n * Transform a zoom level into a depth value; zoom level zero has a depth value of 0.5, and increasing values\n * have a depth trending towards 0\n * @param {number} z A zoom level.\n * @return {number} A depth value.\n */\nfunction depthForZ(z) {\n  return 1 / (z + 2);\n}\n\n/**\n * @typedef {import(\"../../webgl/BaseTileRepresentation.js\").default<import(\"../../Tile.js\").default>} AbstractTileRepresentation\n */\n/**\n * @typedef {Object} TileRepresentationLookup\n * @property {Set<string>} tileIds The set of tile ids in the lookup.\n * @property {Object<number, Set<AbstractTileRepresentation>>} representationsByZ Tile representations by zoom level.\n */\n\n/**\n * @return {TileRepresentationLookup} A new tile representation lookup.\n */\nexport function newTileRepresentationLookup() {\n  return {tileIds: new Set(), representationsByZ: {}};\n}\n\n/**\n * Check if a tile is already in the tile representation lookup.\n * @param {TileRepresentationLookup} tileRepresentationLookup Lookup of tile representations by zoom level.\n * @param {import(\"../../Tile.js\").default} tile A tile.\n * @return {boolean} The tile is already in the lookup.\n */\nfunction lookupHasTile(tileRepresentationLookup, tile) {\n  return tileRepresentationLookup.tileIds.has(getUid(tile));\n}\n\n/**\n * Add a tile representation to the lookup.\n * @param {TileRepresentationLookup} tileRepresentationLookup Lookup of tile representations by zoom level.\n * @param {AbstractTileRepresentation} tileRepresentation A tile representation.\n * @param {number} z The zoom level.\n */\nfunction addTileRepresentationToLookup(\n  tileRepresentationLookup,\n  tileRepresentation,\n  z,\n) {\n  const representationsByZ = tileRepresentationLookup.representationsByZ;\n  if (!(z in representationsByZ)) {\n    representationsByZ[z] = new Set();\n  }\n  representationsByZ[z].add(tileRepresentation);\n  tileRepresentationLookup.tileIds.add(getUid(tileRepresentation.tile));\n}\n\n/**\n * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n * @param {import(\"../../extent.js\").Extent} extent The frame extent.\n * @return {import(\"../../extent.js\").Extent} Frame extent intersected with layer extents.\n */\nfunction getRenderExtent(frameState, extent) {\n  const layerState = frameState.layerStatesArray[frameState.layerIndex];\n  if (layerState.extent) {\n    extent = getIntersection(\n      extent,\n      fromUserExtent(layerState.extent, frameState.viewState.projection),\n    );\n  }\n  const source = /** @type {import(\"../../source/Tile.js\").default} */ (\n    layerState.layer.getRenderSource()\n  );\n  if (!source.getWrapX()) {\n    const gridExtent = source\n      .getTileGridForProjection(frameState.viewState.projection)\n      .getExtent();\n    if (gridExtent) {\n      extent = getIntersection(extent, gridExtent);\n    }\n  }\n  return extent;\n}\n\nexport function getCacheKey(source, tileCoord) {\n  return `${source.getKey()},${getTileCoordKey(tileCoord)}`;\n}\n\n/**\n * @typedef {Object} Options\n * @property {Object<string, import(\"../../webgl/Helper\").UniformValue>} [uniforms] Additional uniforms\n * made available to shaders.\n * @property {number} [cacheSize=512] The tile representation cache size.\n * @property {Array<import('./Layer.js').PostProcessesOptions>} [postProcesses] Post-processes definitions.\n */\n\n/**\n * @typedef {import(\"../../layer/BaseTile.js\").default} BaseLayerType\n */\n\n/**\n * @classdesc\n * Base WebGL renderer for tile layers.\n * @template {BaseLayerType} LayerType\n * @template {import(\"../../Tile.js\").default} TileType\n * @template {import(\"../../webgl/BaseTileRepresentation.js\").default<TileType>} TileRepresentation\n * @extends {WebGLLayerRenderer<LayerType>}\n */\nclass WebGLBaseTileLayerRenderer extends WebGLLayerRenderer {\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   * @param {Options} options Options.\n   */\n  constructor(tileLayer, options) {\n    super(tileLayer, {\n      uniforms: options.uniforms,\n      postProcesses: options.postProcesses,\n    });\n\n    /**\n     * The last call to `renderFrame` was completed with all tiles loaded\n     * @type {boolean}\n     */\n    this.renderComplete = false;\n\n    /**\n     * This transform converts representation coordinates to screen coordinates.\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.tileTransform_ = createTransform();\n\n    /**\n     * @type {Array<number>}\n     * @protected\n     */\n    this.tempMat4 = createMat4();\n\n    /**\n     * @type {import(\"../../TileRange.js\").default}\n     * @private\n     */\n    this.tempTileRange_ = new TileRange(0, 0, 0, 0);\n\n    /**\n     * @type {import(\"../../tilecoord.js\").TileCoord}\n     * @private\n     */\n    this.tempTileCoord_ = createTileCoord(0, 0, 0);\n\n    /**\n     * @type {import(\"../../size.js\").Size}\n     * @private\n     */\n    this.tempSize_ = [0, 0];\n\n    const cacheSize = options.cacheSize !== undefined ? options.cacheSize : 512;\n    /**\n     * @type {import(\"../../structs/LRUCache.js\").default<TileRepresentation>}\n     * @protected\n     */\n    this.tileRepresentationCache = new LRUCache(cacheSize);\n\n    /**\n     * @protected\n     * @type {import(\"../../Map.js\").FrameState|null}\n     */\n    this.frameState = null;\n\n    /**\n     * @private\n     * @type {import(\"../../proj/Projection.js\").default}\n     */\n    this.projection_ = undefined;\n  }\n\n  /**\n   * @param {Options} options Options.\n   */\n  reset(options) {\n    super.reset({\n      uniforms: options.uniforms,\n    });\n  }\n\n  /**\n   * @param {TileType} tile Tile.\n   * @return {boolean} Tile is drawable.\n   * @private\n   */\n  isDrawableTile_(tile) {\n    const tileLayer = this.getLayer();\n    const tileState = tile.getState();\n    const useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();\n    return (\n      tileState == TileState.LOADED ||\n      tileState == TileState.EMPTY ||\n      (tileState == TileState.ERROR && !useInterimTilesOnError)\n    );\n  }\n\n  /**\n   * Determine whether renderFrame should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrameInternal(frameState) {\n    if (!this.projection_) {\n      this.projection_ = frameState.viewState.projection;\n    } else if (frameState.viewState.projection !== this.projection_) {\n      this.clearCache();\n      this.projection_ = frameState.viewState.projection;\n    }\n\n    const layer = this.getLayer();\n    const source = layer.getRenderSource();\n    if (!source) {\n      return false;\n    }\n\n    if (isEmpty(getRenderExtent(frameState, frameState.extent))) {\n      return false;\n    }\n    return source.getState() === 'ready';\n  }\n\n  /**\n   * @abstract\n   * @param {import(\"../../webgl/BaseTileRepresentation.js\").TileRepresentationOptions<TileType>} options tile representation options\n   * @return {TileRepresentation} A new tile representation\n   * @protected\n   */\n  createTileRepresentation(options) {\n    return abstract();\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../extent.js\").Extent} extent The extent to be rendered.\n   * @param {number} initialZ The zoom level.\n   * @param {TileRepresentationLookup} tileRepresentationLookup The zoom level.\n   * @param {number} preload Number of additional levels to load.\n   */\n  enqueueTiles(\n    frameState,\n    extent,\n    initialZ,\n    tileRepresentationLookup,\n    preload,\n  ) {\n    const viewState = frameState.viewState;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getRenderSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n    const gutter = tileSource.getGutterForProjection(viewState.projection);\n\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n\n    const wantedTiles = frameState.wantedTiles[tileSourceKey];\n    const tileRepresentationCache = this.tileRepresentationCache;\n\n    const map = tileLayer.getMapInternal();\n    const minZ = Math.max(\n      initialZ - preload,\n      tileGrid.getMinZoom(),\n      tileGrid.getZForResolution(\n        Math.min(\n          tileLayer.getMaxResolution(),\n          map\n            ? map\n                .getView()\n                .getResolutionForZoom(Math.max(tileLayer.getMinZoom(), 0))\n            : tileGrid.getResolution(0),\n        ),\n        tileSource.zDirection,\n      ),\n    );\n    for (let z = initialZ; z >= minZ; --z) {\n      const tileRange = tileGrid.getTileRangeForExtentAndZ(\n        extent,\n        z,\n        this.tempTileRange_,\n      );\n\n      const tileResolution = tileGrid.getResolution(z);\n\n      for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          const tileCoord = createTileCoord(z, x, y, this.tempTileCoord_);\n          const cacheKey = getCacheKey(tileSource, tileCoord);\n\n          /** @type {TileRepresentation} */\n          let tileRepresentation;\n\n          /** @type {TileType} */\n          let tile;\n\n          if (tileRepresentationCache.containsKey(cacheKey)) {\n            tileRepresentation = tileRepresentationCache.get(cacheKey);\n            tile = tileRepresentation.tile;\n          }\n          if (\n            !tileRepresentation ||\n            tileRepresentation.tile.key !== tileSource.getKey()\n          ) {\n            tile = tileSource.getTile(\n              z,\n              x,\n              y,\n              frameState.pixelRatio,\n              viewState.projection,\n            );\n          }\n\n          if (lookupHasTile(tileRepresentationLookup, tile)) {\n            continue;\n          }\n\n          if (!tileRepresentation) {\n            tileRepresentation = this.createTileRepresentation({\n              tile: tile,\n              grid: tileGrid,\n              helper: this.helper,\n              gutter: gutter,\n            });\n            tileRepresentationCache.set(cacheKey, tileRepresentation);\n          } else {\n            if (this.isDrawableTile_(tile)) {\n              tileRepresentation.setTile(tile);\n            } else {\n              const interimTile = /** @type {TileType} */ (\n                tile.getInterimTile()\n              );\n              tileRepresentation.setTile(interimTile);\n            }\n          }\n\n          addTileRepresentationToLookup(\n            tileRepresentationLookup,\n            tileRepresentation,\n            z,\n          );\n\n          const tileQueueKey = tile.getKey();\n          wantedTiles[tileQueueKey] = true;\n\n          if (tile.getState() === TileState.IDLE) {\n            if (!frameState.tileQueue.isKeyQueued(tileQueueKey)) {\n              frameState.tileQueue.enqueue([\n                tile,\n                tileSourceKey,\n                tileGrid.getTileCoordCenter(tileCoord),\n                tileResolution,\n              ]);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {boolean} tilesWithAlpha True if at least one of the rendered tiles has alpha\n   * @protected\n   */\n  beforeTilesRender(frameState, tilesWithAlpha) {\n    this.helper.prepareDraw(this.frameState, !tilesWithAlpha, true);\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} If returns false, tile mask rendering will be skipped\n   * @protected\n   */\n  beforeTilesMaskRender(frameState) {\n    return false;\n  }\n\n  /**\n   * @param {TileRepresentation} tileRepresentation Tile representation\n   * @param {import(\"../../transform.js\").Transform} tileTransform Tile transform\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state\n   * @param {import(\"../../extent.js\").Extent} renderExtent Render extent\n   * @param {number} tileResolution Tile resolution\n   * @param {import(\"../../size.js\").Size} tileSize Tile size\n   * @param {import(\"../../coordinate.js\").Coordinate} tileOrigin Tile origin\n   * @param {import(\"../../extent.js\").Extent} tileExtent tile Extent\n   * @param {number} depth Depth\n   * @param {number} gutter Gutter\n   * @param {number} alpha Alpha\n   * @protected\n   */\n  renderTile(\n    tileRepresentation,\n    tileTransform,\n    frameState,\n    renderExtent,\n    tileResolution,\n    tileSize,\n    tileOrigin,\n    tileExtent,\n    depth,\n    gutter,\n    alpha,\n  ) {}\n\n  /**\n   * @param {TileRepresentation} tileRepresentation Tile representation\n   * @param {number} tileZ Tile Z\n   * @param {import(\"../../extent.js\").Extent} extent Render extent\n   * @param {number} depth Depth\n   * @protected\n   */\n  renderTileMask(tileRepresentation, tileZ, extent, depth) {}\n\n  drawTile_(\n    frameState,\n    tileRepresentation,\n    tileZ,\n    gutter,\n    extent,\n    alphaLookup,\n    tileGrid,\n  ) {\n    if (!tileRepresentation.ready) {\n      return;\n    }\n    const tile = tileRepresentation.tile;\n    const tileCoord = tile.tileCoord;\n    const tileCoordKey = getTileCoordKey(tileCoord);\n    const alpha = tileCoordKey in alphaLookup ? alphaLookup[tileCoordKey] : 1;\n\n    const tileResolution = tileGrid.getResolution(tileZ);\n    const tileSize = toSize(tileGrid.getTileSize(tileZ), this.tempSize_);\n    const tileOrigin = tileGrid.getOrigin(tileZ);\n    const tileExtent = tileGrid.getTileCoordExtent(tileCoord);\n    // tiles with alpha are rendered last to allow blending\n    const depth = alpha < 1 ? -1 : depthForZ(tileZ);\n    if (alpha < 1) {\n      frameState.animate = true;\n    }\n\n    const viewState = frameState.viewState;\n    const centerX = viewState.center[0];\n    const centerY = viewState.center[1];\n\n    const tileWidthWithGutter = tileSize[0] + 2 * gutter;\n    const tileHeightWithGutter = tileSize[1] + 2 * gutter;\n\n    const aspectRatio = tileWidthWithGutter / tileHeightWithGutter;\n\n    const centerI = (centerX - tileOrigin[0]) / (tileSize[0] * tileResolution);\n    const centerJ = (tileOrigin[1] - centerY) / (tileSize[1] * tileResolution);\n\n    const tileScale = viewState.resolution / tileResolution;\n\n    const tileCenterI = tileCoord[1];\n    const tileCenterJ = tileCoord[2];\n\n    resetTransform(this.tileTransform_);\n    scaleTransform(\n      this.tileTransform_,\n      2 / ((frameState.size[0] * tileScale) / tileWidthWithGutter),\n      -2 / ((frameState.size[1] * tileScale) / tileWidthWithGutter),\n    );\n    rotateTransform(this.tileTransform_, viewState.rotation);\n    scaleTransform(this.tileTransform_, 1, 1 / aspectRatio);\n    translateTransform(\n      this.tileTransform_,\n      (tileSize[0] * (tileCenterI - centerI) - gutter) / tileWidthWithGutter,\n      (tileSize[1] * (tileCenterJ - centerJ) - gutter) / tileHeightWithGutter,\n    );\n\n    this.renderTile(\n      /** @type {TileRepresentation} */ (tileRepresentation),\n      this.tileTransform_,\n      frameState,\n      extent,\n      tileResolution,\n      tileSize,\n      tileOrigin,\n      tileExtent,\n      depth,\n      gutter,\n      alpha,\n    );\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState) {\n    this.frameState = frameState;\n    this.renderComplete = true;\n    const gl = this.helper.getGL();\n    this.preRender(gl, frameState);\n\n    const viewState = frameState.viewState;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getRenderSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n    const gutter = tileSource.getGutterForProjection(viewState.projection);\n    const extent = getRenderExtent(frameState, frameState.extent);\n    const z = tileGrid.getZForResolution(\n      viewState.resolution,\n      tileSource.zDirection,\n    );\n\n    /**\n     * @type {TileRepresentationLookup}\n     */\n    const tileRepresentationLookup = newTileRepresentationLookup();\n\n    const preload = tileLayer.getPreload();\n    if (frameState.nextExtent) {\n      const targetZ = tileGrid.getZForResolution(\n        viewState.nextResolution,\n        tileSource.zDirection,\n      );\n      const nextExtent = getRenderExtent(frameState, frameState.nextExtent);\n      this.enqueueTiles(\n        frameState,\n        nextExtent,\n        targetZ,\n        tileRepresentationLookup,\n        preload,\n      );\n    }\n\n    this.enqueueTiles(frameState, extent, z, tileRepresentationLookup, 0);\n    if (preload > 0) {\n      setTimeout(() => {\n        this.enqueueTiles(\n          frameState,\n          extent,\n          z - 1,\n          tileRepresentationLookup,\n          preload - 1,\n        );\n      }, 0);\n    }\n\n    /**\n     * A lookup of alpha values for tiles at the target rendering resolution\n     * for tiles that are in transition.  If a tile coord key is absent from\n     * this lookup, the tile should be rendered at alpha 1.\n     * @type {Object<string, number>}\n     */\n    const alphaLookup = {};\n\n    const uid = getUid(this);\n    const time = frameState.time;\n    let blend = false;\n\n    // look for cached tiles to use if a target tile is not ready\n    for (const tileRepresentation of tileRepresentationLookup\n      .representationsByZ[z]) {\n      const tile = tileRepresentation.tile;\n      if (\n        (tile instanceof ReprojTile || tile instanceof ReprojDataTile) &&\n        tile.getState() === TileState.EMPTY\n      ) {\n        continue;\n      }\n      const tileCoord = tile.tileCoord;\n\n      if (tileRepresentation.ready) {\n        const alpha = tile.getAlpha(uid, time);\n        if (alpha === 1) {\n          // no need to look for alt tiles\n          tile.endTransition(uid);\n          continue;\n        }\n        blend = true;\n        const tileCoordKey = getTileCoordKey(tileCoord);\n        alphaLookup[tileCoordKey] = alpha;\n      }\n      this.renderComplete = false;\n\n      // first look for child tiles (at z + 1)\n      const coveredByChildren = this.findAltTiles_(\n        tileGrid,\n        tileCoord,\n        z + 1,\n        tileRepresentationLookup,\n      );\n\n      if (coveredByChildren) {\n        continue;\n      }\n\n      // next look for parent tiles\n      const minZoom = tileGrid.getMinZoom();\n      for (let parentZ = z - 1; parentZ >= minZoom; --parentZ) {\n        const coveredByParent = this.findAltTiles_(\n          tileGrid,\n          tileCoord,\n          parentZ,\n          tileRepresentationLookup,\n        );\n\n        if (coveredByParent) {\n          break;\n        }\n      }\n    }\n\n    const representationsByZ = tileRepresentationLookup.representationsByZ;\n    const zs = Object.keys(representationsByZ).map(Number).sort(descending);\n\n    const renderTileMask = this.beforeTilesMaskRender(frameState);\n\n    if (renderTileMask) {\n      for (let j = 0, jj = zs.length; j < jj; ++j) {\n        const tileZ = zs[j];\n        for (const tileRepresentation of representationsByZ[tileZ]) {\n          const tileCoord = tileRepresentation.tile.tileCoord;\n          const tileCoordKey = getTileCoordKey(tileCoord);\n          // do not render the tile mask if alpha < 1\n          if (tileCoordKey in alphaLookup) {\n            continue;\n          }\n          const tileExtent = tileGrid.getTileCoordExtent(tileCoord);\n          this.renderTileMask(\n            /** @type {TileRepresentation} */ (tileRepresentation),\n            tileZ,\n            tileExtent,\n            depthForZ(tileZ),\n          );\n        }\n      }\n    }\n\n    this.beforeTilesRender(frameState, blend);\n\n    for (let j = 0, jj = zs.length; j < jj; ++j) {\n      const tileZ = zs[j];\n      for (const tileRepresentation of representationsByZ[tileZ]) {\n        const tileCoord = tileRepresentation.tile.tileCoord;\n        const tileCoordKey = getTileCoordKey(tileCoord);\n        if (tileCoordKey in alphaLookup) {\n          continue;\n        }\n\n        this.drawTile_(\n          frameState,\n          tileRepresentation,\n          tileZ,\n          gutter,\n          extent,\n          alphaLookup,\n          tileGrid,\n        );\n      }\n    }\n\n    for (const tileRepresentation of representationsByZ[z]) {\n      const tileCoord = tileRepresentation.tile.tileCoord;\n      const tileCoordKey = getTileCoordKey(tileCoord);\n      if (tileCoordKey in alphaLookup) {\n        this.drawTile_(\n          frameState,\n          tileRepresentation,\n          z,\n          gutter,\n          extent,\n          alphaLookup,\n          tileGrid,\n        );\n      }\n    }\n\n    this.helper.finalizeDraw(\n      frameState,\n      this.dispatchPreComposeEvent,\n      this.dispatchPostComposeEvent,\n    );\n\n    const canvas = this.helper.getCanvas();\n\n    const tileRepresentationCache = this.tileRepresentationCache;\n    while (tileRepresentationCache.canExpireCache()) {\n      const tileRepresentation = tileRepresentationCache.pop();\n      tileRepresentation.dispose();\n    }\n\n    // TODO: let the renderers manage their own cache instead of managing the source cache\n    /**\n     * Here we unconditionally expire the source cache since the renderer maintains\n     * its own cache.\n     * @param {import(\"../../Map.js\").default} map Map.\n     * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n     */\n    const postRenderFunction = function (map, frameState) {\n      tileSource.updateCacheSize(0.1, frameState.viewState.projection);\n      tileSource.expireCache(frameState.viewState.projection, empty);\n    };\n\n    frameState.postRenderFunctions.push(postRenderFunction);\n\n    this.postRender(gl, frameState);\n    return canvas;\n  }\n\n  /**\n   * Look for tiles covering the provided tile coordinate at an alternate\n   * zoom level.  Loaded tiles will be added to the provided tile representation lookup.\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid The tile grid.\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n   * @param {number} altZ The alternate zoom level.\n   * @param {TileRepresentationLookup} tileRepresentationLookup Lookup of\n   * tile representations by zoom level.\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n   * @private\n   */\n  findAltTiles_(tileGrid, tileCoord, altZ, tileRepresentationLookup) {\n    const tileRange = tileGrid.getTileRangeForTileCoordAndZ(\n      tileCoord,\n      altZ,\n      this.tempTileRange_,\n    );\n\n    if (!tileRange) {\n      return false;\n    }\n\n    let covered = true;\n    const tileRepresentationCache = this.tileRepresentationCache;\n    const source = this.getLayer().getRenderSource();\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        const cacheKey = getCacheKey(source, [altZ, x, y]);\n        let loaded = false;\n        if (tileRepresentationCache.containsKey(cacheKey)) {\n          const tileRepresentation = tileRepresentationCache.get(cacheKey);\n          if (\n            tileRepresentation.ready &&\n            !lookupHasTile(tileRepresentationLookup, tileRepresentation.tile)\n          ) {\n            addTileRepresentationToLookup(\n              tileRepresentationLookup,\n              tileRepresentation,\n              altZ,\n            );\n            loaded = true;\n          }\n        }\n        if (!loaded) {\n          covered = false;\n        }\n      }\n    }\n    return covered;\n  }\n\n  clearCache() {\n    const tileRepresentationCache = this.tileRepresentationCache;\n    tileRepresentationCache.forEach((tileRepresentation) =>\n      tileRepresentation.dispose(),\n    );\n    tileRepresentationCache.clear();\n  }\n\n  removeHelper() {\n    if (this.helper) {\n      this.clearCache();\n    }\n\n    super.removeHelper();\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    super.disposeInternal();\n    delete this.frameState;\n  }\n}\n\nexport default WebGLBaseTileLayerRenderer;\n","/**\n * @module ol/renderer/webgl/TileLayer\n */\nimport ReprojDataTile from '../../reproj/DataTile.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport TileState from '../../TileState.js';\nimport TileTexture from '../../webgl/TileTexture.js';\nimport WebGLArrayBuffer from '../../webgl/Buffer.js';\nimport WebGLBaseTileLayerRenderer, {\n  Uniforms as BaseUniforms,\n  getCacheKey,\n} from './TileLayerBase.js';\nimport {AttributeType} from '../../webgl/Helper.js';\nimport {ELEMENT_ARRAY_BUFFER, STATIC_DRAW} from '../../webgl.js';\nimport {apply as applyTransform} from '../../transform.js';\nimport {\n  boundingExtent,\n  containsCoordinate,\n  getIntersection,\n} from '../../extent.js';\nimport {fromUserExtent} from '../../proj.js';\nimport {fromTransform as mat4FromTransform} from '../../vec/mat4.js';\nimport {toSize} from '../../size.js';\n\nexport const Uniforms = {\n  ...BaseUniforms,\n  TILE_TEXTURE_ARRAY: 'u_tileTextures',\n  TEXTURE_PIXEL_WIDTH: 'u_texturePixelWidth',\n  TEXTURE_PIXEL_HEIGHT: 'u_texturePixelHeight',\n  TEXTURE_RESOLUTION: 'u_textureResolution', // map units per texture pixel\n  TEXTURE_ORIGIN_X: 'u_textureOriginX', // map x coordinate of left edge of texture\n  TEXTURE_ORIGIN_Y: 'u_textureOriginY', // map y coordinate of top edge of texture\n};\n\nexport const Attributes = {\n  TEXTURE_COORD: 'a_textureCoord',\n};\n\n/**\n * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n */\nconst attributeDescriptions = [\n  {\n    name: Attributes.TEXTURE_COORD,\n    size: 2,\n    type: AttributeType.FLOAT,\n  },\n];\n\n/**\n * @typedef {Object} Options\n * @property {string} vertexShader Vertex shader source.\n * @property {string} fragmentShader Fragment shader source.\n * @property {Object<string, import(\"../../webgl/Helper\").UniformValue>} [uniforms] Additional uniforms\n * made available to shaders.\n * @property {Array<import(\"../../webgl/PaletteTexture.js\").default>} [paletteTextures] Palette textures.\n * @property {number} [cacheSize=512] The texture cache size.\n */\n\n/**\n * @typedef {import(\"../../layer/WebGLTile.js\").default} LayerType\n */\n/**\n * @typedef {import(\"../../webgl/TileTexture.js\").TileType} TileTextureType\n */\n/**\n * @typedef {import(\"../../webgl/TileTexture.js\").default} TileTextureRepresentation\n */\n\n/**\n * @classdesc\n * WebGL renderer for tile layers.\n * @extends {WebGLBaseTileLayerRenderer<LayerType, TileTextureType, TileTextureRepresentation>}\n * @api\n */\nclass WebGLTileLayerRenderer extends WebGLBaseTileLayerRenderer {\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   * @param {Options} options Options.\n   */\n  constructor(tileLayer, options) {\n    super(tileLayer, options);\n\n    /**\n     * @type {WebGLProgram}\n     * @private\n     */\n    this.program_;\n\n    /**\n     * @private\n     */\n    this.vertexShader_ = options.vertexShader;\n\n    /**\n     * @private\n     */\n    this.fragmentShader_ = options.fragmentShader;\n\n    /**\n     * Tiles are rendered as a quad with the following structure:\n     *\n     *  [P3]---------[P2]\n     *   |`           |\n     *   |  `     B   |\n     *   |    `       |\n     *   |      `     |\n     *   |   A    `   |\n     *   |          ` |\n     *  [P0]---------[P1]\n     *\n     * Triangle A: P0, P1, P3\n     * Triangle B: P1, P2, P3\n     *\n     * @private\n     */\n    this.indices_ = new WebGLArrayBuffer(ELEMENT_ARRAY_BUFFER, STATIC_DRAW);\n    this.indices_.fromArray([0, 1, 3, 1, 2, 3]);\n\n    /**\n     * @type {Array<import(\"../../webgl/PaletteTexture.js\").default>}\n     * @private\n     */\n    this.paletteTextures_ = options.paletteTextures || [];\n  }\n\n  /**\n   * @param {Options} options Options.\n   */\n  reset(options) {\n    super.reset(options);\n    if (this.helper) {\n      const gl = this.helper.getGL();\n      for (const paletteTexture of this.paletteTextures_) {\n        paletteTexture.delete(gl);\n      }\n    }\n\n    this.vertexShader_ = options.vertexShader;\n    this.fragmentShader_ = options.fragmentShader;\n    this.paletteTextures_ = options.paletteTextures || [];\n\n    if (this.helper) {\n      this.program_ = this.helper.getProgram(\n        this.fragmentShader_,\n        this.vertexShader_,\n      );\n    }\n  }\n\n  afterHelperCreated() {\n    this.program_ = this.helper.getProgram(\n      this.fragmentShader_,\n      this.vertexShader_,\n    );\n    this.helper.flushBufferData(this.indices_);\n  }\n\n  removeHelper() {\n    if (this.helper) {\n      const gl = this.helper.getGL();\n      for (const paletteTexture of this.paletteTextures_) {\n        paletteTexture.delete(gl);\n      }\n    }\n\n    super.removeHelper();\n  }\n\n  createTileRepresentation(options) {\n    return new TileTexture(options);\n  }\n\n  beforeTilesRender(frameState, tilesWithAlpha) {\n    super.beforeTilesRender(frameState, tilesWithAlpha);\n    this.helper.useProgram(this.program_, frameState);\n  }\n\n  renderTile(\n    tileTexture,\n    tileTransform,\n    frameState,\n    renderExtent,\n    tileResolution,\n    tileSize,\n    tileOrigin,\n    tileExtent,\n    depth,\n    gutter,\n    alpha,\n  ) {\n    const gl = this.helper.getGL();\n    this.helper.bindBuffer(tileTexture.coords);\n    this.helper.bindBuffer(this.indices_);\n    this.helper.enableAttributes(attributeDescriptions);\n\n    let textureSlot = 0;\n    while (textureSlot < tileTexture.textures.length) {\n      const uniformName = `${Uniforms.TILE_TEXTURE_ARRAY}[${textureSlot}]`;\n      this.helper.bindTexture(\n        tileTexture.textures[textureSlot],\n        textureSlot,\n        uniformName,\n      );\n      ++textureSlot;\n    }\n\n    for (\n      let paletteIndex = 0;\n      paletteIndex < this.paletteTextures_.length;\n      ++paletteIndex\n    ) {\n      const paletteTexture = this.paletteTextures_[paletteIndex];\n      const texture = paletteTexture.getTexture(gl);\n      this.helper.bindTexture(texture, textureSlot, paletteTexture.name);\n      ++textureSlot;\n    }\n\n    const viewState = frameState.viewState;\n\n    const tileWidthWithGutter = tileSize[0] + 2 * gutter;\n    const tileHeightWithGutter = tileSize[1] + 2 * gutter;\n\n    const tile = tileTexture.tile;\n    const tileCoord = tile.tileCoord;\n\n    const tileCenterI = tileCoord[1];\n    const tileCenterJ = tileCoord[2];\n\n    this.helper.setUniformMatrixValue(\n      Uniforms.TILE_TRANSFORM,\n      mat4FromTransform(this.tempMat4, tileTransform),\n    );\n\n    this.helper.setUniformFloatValue(Uniforms.TRANSITION_ALPHA, alpha);\n    this.helper.setUniformFloatValue(Uniforms.DEPTH, depth);\n\n    let gutterExtent = renderExtent;\n    if (gutter > 0) {\n      gutterExtent = tileExtent;\n      getIntersection(gutterExtent, renderExtent, gutterExtent);\n    }\n    this.helper.setUniformFloatVec4(Uniforms.RENDER_EXTENT, gutterExtent);\n\n    this.helper.setUniformFloatValue(Uniforms.RESOLUTION, viewState.resolution);\n    this.helper.setUniformFloatValue(Uniforms.ZOOM, viewState.zoom);\n\n    this.helper.setUniformFloatValue(\n      Uniforms.TEXTURE_PIXEL_WIDTH,\n      tileWidthWithGutter,\n    );\n    this.helper.setUniformFloatValue(\n      Uniforms.TEXTURE_PIXEL_HEIGHT,\n      tileHeightWithGutter,\n    );\n    this.helper.setUniformFloatValue(\n      Uniforms.TEXTURE_RESOLUTION,\n      tileResolution,\n    );\n    this.helper.setUniformFloatValue(\n      Uniforms.TEXTURE_ORIGIN_X,\n      tileOrigin[0] +\n        tileCenterI * tileSize[0] * tileResolution -\n        gutter * tileResolution,\n    );\n    this.helper.setUniformFloatValue(\n      Uniforms.TEXTURE_ORIGIN_Y,\n      tileOrigin[1] -\n        tileCenterJ * tileSize[1] * tileResolution +\n        gutter * tileResolution,\n    );\n\n    this.helper.drawElements(0, this.indices_.getSize());\n  }\n\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView} Data at the pixel location.\n   */\n  getData(pixel) {\n    const gl = this.helper.getGL();\n    if (!gl) {\n      return null;\n    }\n\n    const frameState = this.frameState;\n    if (!frameState) {\n      return null;\n    }\n\n    const layer = this.getLayer();\n    const coordinate = applyTransform(\n      frameState.pixelToCoordinateTransform,\n      pixel.slice(),\n    );\n\n    const viewState = frameState.viewState;\n    const layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (\n        !containsCoordinate(\n          fromUserExtent(layerExtent, viewState.projection),\n          coordinate,\n        )\n      ) {\n        return null;\n      }\n    }\n\n    // determine last source suitable for rendering at coordinate\n    const sources = layer.getSources(\n      boundingExtent([coordinate]),\n      viewState.resolution,\n    );\n    let i, source, tileGrid;\n    for (i = sources.length - 1; i >= 0; --i) {\n      source = sources[i];\n      if (source.getState() === 'ready') {\n        tileGrid = source.getTileGridForProjection(viewState.projection);\n        if (source.getWrapX()) {\n          break;\n        }\n        const gridExtent = tileGrid.getExtent();\n        if (!gridExtent || containsCoordinate(gridExtent, coordinate)) {\n          break;\n        }\n      }\n    }\n    if (i < 0) {\n      return null;\n    }\n\n    const tileTextureCache = this.tileRepresentationCache;\n    for (\n      let z = tileGrid.getZForResolution(viewState.resolution);\n      z >= tileGrid.getMinZoom();\n      --z\n    ) {\n      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n      const cacheKey = getCacheKey(source, tileCoord);\n      if (!tileTextureCache.containsKey(cacheKey)) {\n        continue;\n      }\n      const tileTexture = tileTextureCache.get(cacheKey);\n      const tile = tileTexture.tile;\n      if (\n        (tile instanceof ReprojTile || tile instanceof ReprojDataTile) &&\n        tile.getState() === TileState.EMPTY\n      ) {\n        return null;\n      }\n      if (!tileTexture.loaded) {\n        continue;\n      }\n      const tileOrigin = tileGrid.getOrigin(z);\n      const tileSize = toSize(tileGrid.getTileSize(z));\n      const tileResolution = tileGrid.getResolution(z);\n\n      const col =\n        (coordinate[0] - tileOrigin[0]) / tileResolution -\n        tileCoord[1] * tileSize[0];\n\n      const row =\n        (tileOrigin[1] - coordinate[1]) / tileResolution -\n        tileCoord[2] * tileSize[1];\n\n      return tileTexture.getPixelData(col, row);\n    }\n    return null;\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    const helper = this.helper;\n    if (helper) {\n      const gl = helper.getGL();\n      for (const paletteTexture of this.paletteTextures_) {\n        paletteTexture.delete(gl);\n      }\n      this.paletteTextures_.length = 0;\n\n      gl.deleteProgram(this.program_);\n      delete this.program_;\n      helper.deleteBuffer(this.indices_);\n    }\n    super.disposeInternal();\n    delete this.indices_;\n  }\n}\n\nexport default WebGLTileLayerRenderer;\n","/**\n * @module ol/renderer/canvas/TileLayer\n */\nimport CanvasLayerRenderer from './Layer.js';\nimport ImageTile from '../../ImageTile.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport {\n  apply as applyTransform,\n  compose as composeTransform,\n} from '../../transform.js';\nimport {ascending} from '../../array.js';\nimport {\n  containsCoordinate,\n  createEmpty,\n  equals,\n  getIntersection,\n  getRotatedViewport,\n  getTopLeft,\n  intersects,\n} from '../../extent.js';\nimport {fromUserExtent} from '../../proj.js';\nimport {getUid} from '../../util.js';\nimport {toSize} from '../../size.js';\n\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n * @template {import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default} [LayerType=import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default]\n * @extends {CanvasLayerRenderer<LayerType>}\n */\nclass CanvasTileLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   */\n  constructor(tileLayer) {\n    super(tileLayer);\n\n    /**\n     * Rendered extent has changed since the previous `renderFrame()` call\n     * @type {boolean}\n     */\n    this.extentChanged = true;\n\n    /**\n     * @private\n     * @type {?import(\"../../extent.js\").Extent}\n     */\n    this.renderedExtent_ = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedPixelRatio;\n\n    /**\n     * @protected\n     * @type {import(\"../../proj/Projection.js\").default}\n     */\n    this.renderedProjection = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedRevision;\n\n    /**\n     * @protected\n     * @type {!Array<import(\"../../Tile.js\").default>}\n     */\n    this.renderedTiles = [];\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.newTiles_ = false;\n\n    /**\n     * @protected\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.tmpExtent = createEmpty();\n\n    /**\n     * @private\n     * @type {import(\"../../TileRange.js\").default}\n     */\n    this.tmpTileRange_ = new TileRange(0, 0, 0, 0);\n  }\n\n  /**\n   * @protected\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {boolean} Tile is drawable.\n   */\n  isDrawableTile(tile) {\n    const tileLayer = this.getLayer();\n    const tileState = tile.getState();\n    const useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();\n    return (\n      tileState == TileState.LOADED ||\n      tileState == TileState.EMPTY ||\n      (tileState == TileState.ERROR && !useInterimTilesOnError)\n    );\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {!import(\"../../Tile.js\").default} Tile.\n   */\n  getTile(z, x, y, frameState) {\n    const pixelRatio = frameState.pixelRatio;\n    const projection = frameState.viewState.projection;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    let tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n    if (tile.getState() == TileState.ERROR) {\n      if (tileLayer.getUseInterimTilesOnError() && tileLayer.getPreload() > 0) {\n        // Preloaded tiles for lower resolutions might have finished loading.\n        this.newTiles_ = true;\n      }\n    }\n    if (!this.isDrawableTile(tile)) {\n      tile = tile.getInterimTile();\n    }\n    return tile;\n  }\n\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray} Data at the pixel location.\n   */\n  getData(pixel) {\n    const frameState = this.frameState;\n    if (!frameState) {\n      return null;\n    }\n\n    const layer = this.getLayer();\n    const coordinate = applyTransform(\n      frameState.pixelToCoordinateTransform,\n      pixel.slice(),\n    );\n\n    const layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (!containsCoordinate(layerExtent, coordinate)) {\n        return null;\n      }\n    }\n\n    const pixelRatio = frameState.pixelRatio;\n    const projection = frameState.viewState.projection;\n    const viewState = frameState.viewState;\n    const source = layer.getRenderSource();\n    const tileGrid = source.getTileGridForProjection(viewState.projection);\n    const tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);\n\n    for (\n      let z = tileGrid.getZForResolution(viewState.resolution);\n      z >= tileGrid.getMinZoom();\n      --z\n    ) {\n      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n      const tile = source.getTile(\n        z,\n        tileCoord[1],\n        tileCoord[2],\n        pixelRatio,\n        projection,\n      );\n      if (\n        !(tile instanceof ImageTile || tile instanceof ReprojTile) ||\n        (tile instanceof ReprojTile && tile.getState() === TileState.EMPTY)\n      ) {\n        return null;\n      }\n\n      if (tile.getState() !== TileState.LOADED) {\n        continue;\n      }\n\n      const tileOrigin = tileGrid.getOrigin(z);\n      const tileSize = toSize(tileGrid.getTileSize(z));\n      const tileResolution = tileGrid.getResolution(z);\n\n      const col = Math.floor(\n        tilePixelRatio *\n          ((coordinate[0] - tileOrigin[0]) / tileResolution -\n            tileCoord[1] * tileSize[0]),\n      );\n\n      const row = Math.floor(\n        tilePixelRatio *\n          ((tileOrigin[1] - coordinate[1]) / tileResolution -\n            tileCoord[2] * tileSize[1]),\n      );\n\n      const gutter = Math.round(\n        tilePixelRatio * source.getGutterForProjection(viewState.projection),\n      );\n\n      return this.getImageData(tile.getImage(), col + gutter, row + gutter);\n    }\n\n    return null;\n  }\n\n  /**\n   * @param {Object<number, Object<string, import(\"../../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n   * @param {number} zoom Zoom level.\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {boolean|void} If `false`, the tile will not be considered loaded.\n   */\n  loadedTileCallback(tiles, zoom, tile) {\n    if (this.isDrawableTile(tile)) {\n      return super.loadedTileCallback(tiles, zoom, tile);\n    }\n    return false;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    return !!this.getLayer().getSource();\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState, target) {\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const viewResolution = viewState.resolution;\n    const viewCenter = viewState.center;\n    const rotation = viewState.rotation;\n    const pixelRatio = frameState.pixelRatio;\n\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const sourceRevision = tileSource.getRevision();\n    const tileGrid = tileSource.getTileGridForProjection(projection);\n    const z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);\n    const tileResolution = tileGrid.getResolution(z);\n\n    let extent = frameState.extent;\n    const resolution = frameState.viewState.resolution;\n    const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n\n    this.prepareContainer(frameState, target);\n\n    // desired dimensions of the canvas in pixels\n    const width = this.context.canvas.width;\n    const height = this.context.canvas.height;\n\n    const layerExtent =\n      layerState.extent && fromUserExtent(layerState.extent, projection);\n    if (layerExtent) {\n      extent = getIntersection(\n        extent,\n        fromUserExtent(layerState.extent, projection),\n      );\n    }\n\n    const dx = (tileResolution * width) / 2 / tilePixelRatio;\n    const dy = (tileResolution * height) / 2 / tilePixelRatio;\n    const canvasExtent = [\n      viewCenter[0] - dx,\n      viewCenter[1] - dy,\n      viewCenter[0] + dx,\n      viewCenter[1] + dy,\n    ];\n\n    const tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\n\n    /**\n     * @type {Object<number, Object<string, import(\"../../Tile.js\").default>>}\n     */\n    const tilesToDrawByZ = {};\n    tilesToDrawByZ[z] = {};\n\n    const findLoadedTiles = this.createLoadedTileFinder(\n      tileSource,\n      projection,\n      tilesToDrawByZ,\n    );\n\n    const tmpExtent = this.tmpExtent;\n    const tmpTileRange = this.tmpTileRange_;\n    this.newTiles_ = false;\n    const viewport = rotation\n      ? getRotatedViewport(\n          viewState.center,\n          resolution,\n          rotation,\n          frameState.size,\n        )\n      : undefined;\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        if (\n          rotation &&\n          !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)\n        ) {\n          continue;\n        }\n        const tile = this.getTile(z, x, y, frameState);\n        if (this.isDrawableTile(tile)) {\n          const uid = getUid(this);\n          if (tile.getState() == TileState.LOADED) {\n            tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;\n            let inTransition = tile.inTransition(uid);\n            if (inTransition && layerState.opacity !== 1) {\n              // Skipping transition when layer is not fully opaque avoids visual artifacts.\n              tile.endTransition(uid);\n              inTransition = false;\n            }\n            if (\n              !this.newTiles_ &&\n              (inTransition || !this.renderedTiles.includes(tile))\n            ) {\n              this.newTiles_ = true;\n            }\n          }\n          if (tile.getAlpha(uid, frameState.time) === 1) {\n            // don't look for alt tiles if alpha is 1\n            continue;\n          }\n        }\n\n        const childTileRange = tileGrid.getTileCoordChildTileRange(\n          tile.tileCoord,\n          tmpTileRange,\n          tmpExtent,\n        );\n\n        let covered = false;\n        if (childTileRange) {\n          covered = findLoadedTiles(z + 1, childTileRange);\n        }\n        if (!covered) {\n          tileGrid.forEachTileCoordParentTileRange(\n            tile.tileCoord,\n            findLoadedTiles,\n            tmpTileRange,\n            tmpExtent,\n          );\n        }\n      }\n    }\n\n    const canvasScale =\n      ((tileResolution / viewResolution) * pixelRatio) / tilePixelRatio;\n\n    const context = this.getRenderContext(frameState);\n\n    // set scale transform for calculating tile positions on the canvas\n    composeTransform(\n      this.tempTransform,\n      width / 2,\n      height / 2,\n      canvasScale,\n      canvasScale,\n      0,\n      -width / 2,\n      -height / 2,\n    );\n\n    if (layerExtent) {\n      this.clipUnrotated(context, frameState, layerExtent);\n    }\n\n    if (!tileSource.getInterpolate()) {\n      context.imageSmoothingEnabled = false;\n    }\n\n    this.preRender(context, frameState);\n\n    this.renderedTiles.length = 0;\n    /** @type {Array<number>} */\n    let zs = Object.keys(tilesToDrawByZ).map(Number);\n    zs.sort(ascending);\n\n    let clips, clipZs, currentClip;\n    if (\n      layerState.opacity === 1 &&\n      (!this.containerReused ||\n        tileSource.getOpaque(frameState.viewState.projection))\n    ) {\n      zs = zs.reverse();\n    } else {\n      clips = [];\n      clipZs = [];\n    }\n    for (let i = zs.length - 1; i >= 0; --i) {\n      const currentZ = zs[i];\n      const currentTilePixelSize = tileSource.getTilePixelSize(\n        currentZ,\n        pixelRatio,\n        projection,\n      );\n      const currentResolution = tileGrid.getResolution(currentZ);\n      const currentScale = currentResolution / tileResolution;\n      const dx = currentTilePixelSize[0] * currentScale * canvasScale;\n      const dy = currentTilePixelSize[1] * currentScale * canvasScale;\n      const originTileCoord = tileGrid.getTileCoordForCoordAndZ(\n        getTopLeft(canvasExtent),\n        currentZ,\n      );\n      const originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);\n      const origin = applyTransform(this.tempTransform, [\n        (tilePixelRatio * (originTileExtent[0] - canvasExtent[0])) /\n          tileResolution,\n        (tilePixelRatio * (canvasExtent[3] - originTileExtent[3])) /\n          tileResolution,\n      ]);\n      const tileGutter =\n        tilePixelRatio * tileSource.getGutterForProjection(projection);\n      const tilesToDraw = tilesToDrawByZ[currentZ];\n      for (const tileCoordKey in tilesToDraw) {\n        const tile = /** @type {import(\"../../ImageTile.js\").default} */ (\n          tilesToDraw[tileCoordKey]\n        );\n        const tileCoord = tile.tileCoord;\n\n        // Calculate integer positions and sizes so that tiles align\n        const xIndex = originTileCoord[1] - tileCoord[1];\n        const nextX = Math.round(origin[0] - (xIndex - 1) * dx);\n        const yIndex = originTileCoord[2] - tileCoord[2];\n        const nextY = Math.round(origin[1] - (yIndex - 1) * dy);\n        const x = Math.round(origin[0] - xIndex * dx);\n        const y = Math.round(origin[1] - yIndex * dy);\n        const w = nextX - x;\n        const h = nextY - y;\n        const transition = z === currentZ;\n\n        const inTransition =\n          transition && tile.getAlpha(getUid(this), frameState.time) !== 1;\n        let contextSaved = false;\n        if (!inTransition) {\n          if (clips) {\n            // Clip mask for regions in this tile that already filled by a higher z tile\n            currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];\n            for (let i = 0, ii = clips.length; i < ii; ++i) {\n              if (z !== currentZ && currentZ < clipZs[i]) {\n                const clip = clips[i];\n                if (\n                  intersects(\n                    [x, y, x + w, y + h],\n                    [clip[0], clip[3], clip[4], clip[7]],\n                  )\n                ) {\n                  if (!contextSaved) {\n                    context.save();\n                    contextSaved = true;\n                  }\n                  context.beginPath();\n                  // counter-clockwise (outer ring) for current tile\n                  context.moveTo(currentClip[0], currentClip[1]);\n                  context.lineTo(currentClip[2], currentClip[3]);\n                  context.lineTo(currentClip[4], currentClip[5]);\n                  context.lineTo(currentClip[6], currentClip[7]);\n                  // clockwise (inner ring) for higher z tile\n                  context.moveTo(clip[6], clip[7]);\n                  context.lineTo(clip[4], clip[5]);\n                  context.lineTo(clip[2], clip[3]);\n                  context.lineTo(clip[0], clip[1]);\n                  context.clip();\n                }\n              }\n            }\n            clips.push(currentClip);\n            clipZs.push(currentZ);\n          } else {\n            context.clearRect(x, y, w, h);\n          }\n        }\n        this.drawTileImage(\n          tile,\n          frameState,\n          x,\n          y,\n          w,\n          h,\n          tileGutter,\n          transition,\n        );\n        if (clips && !inTransition) {\n          if (contextSaved) {\n            context.restore();\n          }\n          this.renderedTiles.unshift(tile);\n        } else {\n          this.renderedTiles.push(tile);\n        }\n        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);\n      }\n    }\n\n    this.renderedRevision = sourceRevision;\n    this.renderedResolution = tileResolution;\n    this.extentChanged =\n      !this.renderedExtent_ || !equals(this.renderedExtent_, canvasExtent);\n    this.renderedExtent_ = canvasExtent;\n    this.renderedPixelRatio = pixelRatio;\n    this.renderedProjection = projection;\n\n    this.manageTilePyramid(\n      frameState,\n      tileSource,\n      tileGrid,\n      pixelRatio,\n      projection,\n      extent,\n      z,\n      tileLayer.getPreload(),\n    );\n    this.scheduleExpireCache(frameState, tileSource);\n\n    this.postRender(this.context, frameState);\n\n    if (layerState.extent) {\n      context.restore();\n    }\n    context.imageSmoothingEnabled = true;\n\n    return this.container;\n  }\n\n  /**\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   */\n  drawTileImage(tile, frameState, x, y, w, h, gutter, transition) {\n    const image = this.getTileImage(tile);\n    if (!image) {\n      return;\n    }\n    const context = this.getRenderContext(frameState);\n    const uid = getUid(this);\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const alpha =\n      layerState.opacity *\n      (transition ? tile.getAlpha(uid, frameState.time) : 1);\n    const alphaChanged = alpha !== context.globalAlpha;\n    if (alphaChanged) {\n      context.save();\n      context.globalAlpha = alpha;\n    }\n    context.drawImage(\n      image,\n      gutter,\n      gutter,\n      image.width - 2 * gutter,\n      image.height - 2 * gutter,\n      x,\n      y,\n      w,\n      h,\n    );\n\n    if (alphaChanged) {\n      context.restore();\n    }\n    if (alpha !== layerState.opacity) {\n      frameState.animate = true;\n    } else if (transition) {\n      tile.endTransition(uid);\n    }\n  }\n\n  /**\n   * @return {HTMLCanvasElement} Image\n   */\n  getImage() {\n    const context = this.context;\n    return context ? context.canvas : null;\n  }\n\n  /**\n   * Get the image from a tile.\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @protected\n   */\n  getTileImage(tile) {\n    return tile.getImage();\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @protected\n   */\n  scheduleExpireCache(frameState, tileSource) {\n    if (tileSource.canExpireCache()) {\n      /**\n       * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n       * @param {import(\"../../Map.js\").default} map Map.\n       * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n       */\n      const postRenderFunction = function (tileSource, map, frameState) {\n        const tileSourceKey = getUid(tileSource);\n        if (tileSourceKey in frameState.usedTiles) {\n          tileSource.expireCache(\n            frameState.viewState.projection,\n            frameState.usedTiles[tileSourceKey],\n          );\n        }\n      }.bind(null, tileSource);\n\n      frameState.postRenderFunctions.push(\n        /** @type {import(\"../../Map.js\").PostRenderFunction} */ (\n          postRenderFunction\n        ),\n      );\n    }\n  }\n\n  /**\n   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import('../../Tile.js').default} tile Tile.\n   * @protected\n   */\n  updateUsedTiles(usedTiles, tileSource, tile) {\n    // FIXME should we use tilesToDrawByZ instead?\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in usedTiles)) {\n      usedTiles[tileSourceKey] = {};\n    }\n    usedTiles[tileSourceKey][tile.getKey()] = true;\n  }\n\n  /**\n   * Manage tile pyramid.\n   * This function performs a number of functions related to the tiles at the\n   * current zoom and lower zoom levels:\n   * - registers idle tiles in frameState.wantedTiles so that they are not\n   *   discarded by the tile queue\n   * - enqueues missing tiles\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @param {import(\"../../extent.js\").Extent} extent Extent.\n   * @param {number} currentZ Current Z.\n   * @param {number} preload Load low resolution tiles up to `preload` levels.\n   * @param {function(import(\"../../Tile.js\").default):void} [tileCallback] Tile callback.\n   * @protected\n   */\n  manageTilePyramid(\n    frameState,\n    tileSource,\n    tileGrid,\n    pixelRatio,\n    projection,\n    extent,\n    currentZ,\n    preload,\n    tileCallback,\n  ) {\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n    const wantedTiles = frameState.wantedTiles[tileSourceKey];\n    const tileQueue = frameState.tileQueue;\n    const minZoom = tileGrid.getMinZoom();\n    const rotation = frameState.viewState.rotation;\n    const viewport = rotation\n      ? getRotatedViewport(\n          frameState.viewState.center,\n          frameState.viewState.resolution,\n          rotation,\n          frameState.size,\n        )\n      : undefined;\n    let tileCount = 0;\n    let tile, tileRange, tileResolution, x, y, z;\n    for (z = minZoom; z <= currentZ; ++z) {\n      tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);\n      tileResolution = tileGrid.getResolution(z);\n      for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          if (\n            rotation &&\n            !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)\n          ) {\n            continue;\n          }\n          if (currentZ - z <= preload) {\n            ++tileCount;\n            tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n            if (tile.getState() == TileState.IDLE) {\n              wantedTiles[tile.getKey()] = true;\n              if (!tileQueue.isKeyQueued(tile.getKey())) {\n                tileQueue.enqueue([\n                  tile,\n                  tileSourceKey,\n                  tileGrid.getTileCoordCenter(tile.tileCoord),\n                  tileResolution,\n                ]);\n              }\n            }\n            if (tileCallback !== undefined) {\n              tileCallback(tile);\n            }\n          } else {\n            tileSource.useTile(z, x, y, projection);\n          }\n        }\n      }\n    }\n    tileSource.updateCacheSize(tileCount, projection);\n  }\n}\n\nexport default CanvasTileLayerRenderer;\n","/**\n * @module ol/renderer/canvas/VectorTileLayer\n */\nimport CanvasBuilderGroup from '../../render/canvas/BuilderGroup.js';\nimport CanvasExecutorGroup, {\n  DECLUTTER,\n} from '../../render/canvas/ExecutorGroup.js';\nimport CanvasTileLayerRenderer from './TileLayer.js';\nimport TileState from '../../TileState.js';\nimport ViewHint from '../../ViewHint.js';\nimport ZIndexContext from '../../render/canvas/ZIndexContext.js';\nimport {\n  HIT_DETECT_RESOLUTION,\n  createHitDetectionImageData,\n  hitDetect,\n} from '../../render/canvas/hitdetect.js';\nimport {\n  apply as applyTransform,\n  create as createTransform,\n  multiply,\n  reset as resetTransform,\n  scale,\n  scale as scaleTransform,\n  translate as translateTransform,\n} from '../../transform.js';\nimport {ascending} from '../../array.js';\nimport {\n  boundingExtent,\n  buffer,\n  containsExtent,\n  equals,\n  getIntersection,\n  getTopLeft,\n  intersects,\n} from '../../extent.js';\nimport {\n  getSquaredTolerance as getSquaredRenderTolerance,\n  renderFeature,\n} from '../vector.js';\nimport {getUid} from '../../util.js';\nimport {toSize} from '../../size.js';\nimport {wrapX} from '../../coordinate.js';\n\n/**\n * @type {!Object<string, Array<import(\"../../render/canvas.js\").BuilderType>>}\n */\nconst IMAGE_REPLAYS = {\n  'image': ['Polygon', 'Circle', 'LineString', 'Image', 'Text'],\n  'hybrid': ['Polygon', 'LineString'],\n  'vector': [],\n};\n\n/**\n * @type {!Object<string, Array<import(\"../../render/canvas.js\").BuilderType>>}\n */\nconst VECTOR_REPLAYS = {\n  'hybrid': ['Image', 'Text', 'Default'],\n  'vector': ['Polygon', 'Circle', 'LineString', 'Image', 'Text', 'Default'],\n};\n\n/**\n * @classdesc\n * Canvas renderer for vector tile layers.\n * @api\n * @extends {CanvasTileLayerRenderer<import(\"../../layer/VectorTile.js\").default>}\n */\nclass CanvasVectorTileLayerRenderer extends CanvasTileLayerRenderer {\n  /**\n   * @param {import(\"../../layer/VectorTile.js\").default} layer VectorTile layer.\n   */\n  constructor(layer) {\n    super(layer);\n\n    /** @private */\n    this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this);\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedLayerRevision_;\n\n    /**\n     * @private\n     * @type {import(\"../../transform\").Transform}\n     */\n    this.renderedPixelToCoordinateTransform_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedRotation_;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedOpacity_ = 1;\n\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.tmpTransform_ = createTransform();\n\n    /**\n     * @private\n     * @type {Array<ZIndexContext>}\n     */\n    this.tileClipContexts_ = null;\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection\").default} projection Projection.\n   * @return {boolean|undefined} Tile needs to be rendered.\n   */\n  prepareTile(tile, pixelRatio, projection) {\n    let render;\n    const state = tile.getState();\n    if (state === TileState.LOADED || state === TileState.ERROR) {\n      this.updateExecutorGroup_(tile, pixelRatio, projection);\n      if (this.tileImageNeedsRender_(tile)) {\n        render = true;\n      }\n    }\n    return render;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {!import(\"../../Tile.js\").default} Tile.\n   */\n  getTile(z, x, y, frameState) {\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const resolution = viewState.resolution;\n    const projection = viewState.projection;\n    const layer = this.getLayer();\n    const tile = layer.getSource().getTile(z, x, y, pixelRatio, projection);\n    const viewHints = frameState.viewHints;\n    const hifi = !(\n      viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]\n    );\n    if (hifi || !tile.wantedResolution) {\n      tile.wantedResolution = resolution;\n    }\n    const render = this.prepareTile(tile, pixelRatio, projection);\n    if (\n      render &&\n      (hifi || Date.now() - frameState.time < 8) &&\n      layer.getRenderMode() !== 'vector'\n    ) {\n      this.renderTileImage_(tile, frameState);\n    }\n    return super.getTile(z, x, y, frameState);\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @return {boolean} Tile is drawable.\n   */\n  isDrawableTile(tile) {\n    const layer = this.getLayer();\n    return (\n      super.isDrawableTile(tile) &&\n      (layer.getRenderMode() === 'vector'\n        ? getUid(layer) in tile.executorGroups\n        : tile.hasContext(layer))\n    );\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getTileImage(tile) {\n    return tile.getImage(this.getLayer());\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    const layerRevision = this.getLayer().getRevision();\n    if (this.renderedLayerRevision_ !== layerRevision) {\n      this.renderedLayerRevision_ = layerRevision;\n      this.renderedTiles.length = 0;\n    }\n    return super.prepareFrame(frameState);\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @private\n   */\n  updateExecutorGroup_(tile, pixelRatio, projection) {\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    const revision = layer.getRevision();\n    const renderOrder = layer.getRenderOrder() || null;\n\n    const resolution = tile.wantedResolution;\n    const builderState = tile.getReplayState(layer);\n    if (\n      !builderState.dirty &&\n      builderState.renderedResolution === resolution &&\n      builderState.renderedRevision == revision &&\n      builderState.renderedRenderOrder == renderOrder\n    ) {\n      return;\n    }\n\n    const source = layer.getSource();\n    const declutter = !!layer.getDeclutter();\n    const sourceTileGrid = source.getTileGrid();\n    const tileGrid = source.getTileGridForProjection(projection);\n    const tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n\n    const sourceTiles = source.getSourceTiles(pixelRatio, projection, tile);\n    const layerUid = getUid(layer);\n    delete tile.hitDetectionImageData[layerUid];\n    tile.executorGroups[layerUid] = [];\n    builderState.dirty = false;\n    for (let t = 0, tt = sourceTiles.length; t < tt; ++t) {\n      const sourceTile = sourceTiles[t];\n      if (sourceTile.getState() != TileState.LOADED) {\n        continue;\n      }\n      const sourceTileCoord = sourceTile.tileCoord;\n      const sourceTileExtent =\n        sourceTileGrid.getTileCoordExtent(sourceTileCoord);\n      const sharedExtent = getIntersection(tileExtent, sourceTileExtent);\n      const builderExtent = buffer(\n        sharedExtent,\n        layer.getRenderBuffer() * resolution,\n        this.tmpExtent,\n      );\n      const bufferedExtent = equals(sourceTileExtent, sharedExtent)\n        ? null\n        : builderExtent;\n      const builderGroup = new CanvasBuilderGroup(\n        0,\n        sharedExtent,\n        resolution,\n        pixelRatio,\n      );\n      const squaredTolerance = getSquaredRenderTolerance(\n        resolution,\n        pixelRatio,\n      );\n\n      /**\n       * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n       * @param {number} [index] Render order index.\n       * @this {CanvasVectorTileLayerRenderer}\n       */\n      const render = function (feature, index) {\n        let styles;\n        const styleFunction =\n          feature.getStyleFunction() || layer.getStyleFunction();\n        if (styleFunction) {\n          styles = styleFunction(feature, resolution);\n        }\n        if (styles) {\n          const dirty = this.renderFeature(\n            feature,\n            squaredTolerance,\n            styles,\n            builderGroup,\n            declutter,\n            index,\n          );\n          builderState.dirty = builderState.dirty || dirty;\n        }\n      };\n\n      const features = sourceTile.getFeatures();\n      if (renderOrder && renderOrder !== builderState.renderedRenderOrder) {\n        features.sort(renderOrder);\n      }\n      for (let i = 0, ii = features.length; i < ii; ++i) {\n        const feature = features[i];\n        if (\n          !bufferedExtent ||\n          intersects(bufferedExtent, feature.getGeometry().getExtent())\n        ) {\n          render.call(this, feature, i);\n        }\n      }\n      const executorGroupInstructions = builderGroup.finish();\n      // no need to clip when the render tile is covered by a single source tile\n      const replayExtent =\n        layer.getRenderMode() !== 'vector' &&\n        declutter &&\n        sourceTiles.length === 1\n          ? null\n          : sharedExtent;\n      const renderingReplayGroup = new CanvasExecutorGroup(\n        replayExtent,\n        resolution,\n        pixelRatio,\n        source.getOverlaps(),\n        executorGroupInstructions,\n        layer.getRenderBuffer(),\n        true,\n      );\n      tile.executorGroups[layerUid].push(renderingReplayGroup);\n    }\n    builderState.renderedRevision = revision;\n    builderState.renderedRenderOrder = renderOrder;\n    builderState.renderedResolution = resolution;\n  }\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches,\n  ) {\n    const resolution = frameState.viewState.resolution;\n    const rotation = frameState.viewState.rotation;\n    hitTolerance = hitTolerance == undefined ? 0 : hitTolerance;\n    const layer = this.getLayer();\n    const source = layer.getSource();\n    const tileGrid = source.getTileGridForProjection(\n      frameState.viewState.projection,\n    );\n\n    const hitExtent = boundingExtent([coordinate]);\n    buffer(hitExtent, resolution * hitTolerance, hitExtent);\n\n    /** @type {!Object<string, import(\"../Map.js\").HitMatch<T>|true>} */\n    const features = {};\n\n    /**\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     * @param {import(\"../../geom/SimpleGeometry.js\").default} geometry Geometry.\n     * @param {number} distanceSq The squared distance to the click position.\n     * @return {T|undefined} Callback result.\n     */\n    const featureCallback = function (feature, geometry, distanceSq) {\n      let key = feature.getId();\n      if (key === undefined) {\n        key = getUid(feature);\n      }\n      const match = features[key];\n      if (!match) {\n        if (distanceSq === 0) {\n          features[key] = true;\n          return callback(feature, layer, geometry);\n        }\n        matches.push(\n          (features[key] = {\n            feature: feature,\n            layer: layer,\n            geometry: geometry,\n            distanceSq: distanceSq,\n            callback: callback,\n          }),\n        );\n      } else if (match !== true && distanceSq < match.distanceSq) {\n        if (distanceSq === 0) {\n          features[key] = true;\n          matches.splice(matches.lastIndexOf(match), 1);\n          return callback(feature, layer, geometry);\n        }\n        match.geometry = geometry;\n        match.distanceSq = distanceSq;\n      }\n      return undefined;\n    };\n\n    const renderedTiles =\n      /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */ (\n        this.renderedTiles\n      );\n\n    let found;\n    for (let i = 0, ii = renderedTiles.length; !found && i < ii; ++i) {\n      const tile = renderedTiles[i];\n      const tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n      if (!intersects(tileExtent, hitExtent)) {\n        continue;\n      }\n\n      const layerUid = getUid(layer);\n      const executorGroups = [tile.executorGroups[layerUid]];\n      const declutter = layer.getDeclutter();\n      executorGroups.some((executorGroups) => {\n        const declutteredFeatures = declutter\n          ? frameState.declutter[declutter].all().map((item) => item.value)\n          : null;\n        for (let t = 0, tt = executorGroups.length; t < tt; ++t) {\n          const executorGroup = executorGroups[t];\n          found = executorGroup.forEachFeatureAtCoordinate(\n            coordinate,\n            resolution,\n            rotation,\n            hitTolerance,\n            featureCallback,\n            declutteredFeatures,\n          );\n          if (found) {\n            return true;\n          }\n        }\n      });\n    }\n    return found;\n  }\n\n  /**\n   * Asynchronous layer level hit detection.\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../../Feature.js\").FeatureLike>>} Promise that resolves with an array of features.\n   */\n  getFeatures(pixel) {\n    return new Promise((resolve, reject) => {\n      const layer = this.getLayer();\n      const layerUid = getUid(layer);\n      const source = layer.getSource();\n      const projection = this.renderedProjection;\n      const projectionExtent = projection.getExtent();\n      const resolution = this.renderedResolution;\n      const tileGrid = source.getTileGridForProjection(projection);\n      const coordinate = applyTransform(\n        this.renderedPixelToCoordinateTransform_,\n        pixel.slice(),\n      );\n      const tileCoord = tileGrid.getTileCoordForCoordAndResolution(\n        coordinate,\n        resolution,\n      );\n      /** @type {import(\"../../VectorRenderTile.js\").default|undefined} */\n      let tile;\n      for (let i = 0, ii = this.renderedTiles.length; i < ii; ++i) {\n        if (\n          tileCoord.toString() === this.renderedTiles[i].tileCoord.toString()\n        ) {\n          tile = /** @type {import(\"../../VectorRenderTile.js\").default} */ (\n            this.renderedTiles[i]\n          );\n          if (tile.getState() === TileState.LOADED) {\n            const extent = tileGrid.getTileCoordExtent(tile.tileCoord);\n            if (\n              source.getWrapX() &&\n              projection.canWrapX() &&\n              !containsExtent(projectionExtent, extent)\n            ) {\n              wrapX(coordinate, projection);\n            }\n            break;\n          }\n          tile = undefined;\n        }\n      }\n      if (!tile || tile.loadingSourceTiles > 0) {\n        resolve([]);\n        return;\n      }\n      const extent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n      const corner = getTopLeft(extent);\n      const tilePixel = [\n        (coordinate[0] - corner[0]) / resolution,\n        (corner[1] - coordinate[1]) / resolution,\n      ];\n      /** @type {Array<import(\"../../Feature.js\").FeatureLike>} */\n      const features = tile.getSourceTiles().reduce(function (\n        accumulator,\n        sourceTile,\n      ) {\n        return accumulator.concat(sourceTile.getFeatures());\n      }, []);\n      /** @type {ImageData|undefined} */\n      let hitDetectionImageData = tile.hitDetectionImageData[layerUid];\n      if (!hitDetectionImageData) {\n        const tileSize = toSize(\n          tileGrid.getTileSize(\n            tileGrid.getZForResolution(resolution, source.zDirection),\n          ),\n        );\n        const rotation = this.renderedRotation_;\n        const transforms = [\n          this.getRenderTransform(\n            tileGrid.getTileCoordCenter(tile.wrappedTileCoord),\n            resolution,\n            0,\n            HIT_DETECT_RESOLUTION,\n            tileSize[0] * HIT_DETECT_RESOLUTION,\n            tileSize[1] * HIT_DETECT_RESOLUTION,\n            0,\n          ),\n        ];\n        hitDetectionImageData = createHitDetectionImageData(\n          tileSize,\n          transforms,\n          features,\n          layer.getStyleFunction(),\n          tileGrid.getTileCoordExtent(tile.wrappedTileCoord),\n          tile.getReplayState(layer).renderedResolution,\n          rotation,\n        );\n        tile.hitDetectionImageData[layerUid] = hitDetectionImageData;\n      }\n      resolve(hitDetect(tilePixel, features, hitDetectionImageData));\n    });\n  }\n\n  /**\n   * Perform action necessary to get the layer rendered after new fonts have loaded\n   */\n  handleFontsChanged() {\n    const layer = this.getLayer();\n    if (layer.getVisible() && this.renderedLayerRevision_ !== undefined) {\n      layer.changed();\n    }\n  }\n\n  /**\n   * Handle changes in image style state.\n   * @param {import(\"../../events/Event.js\").default} event Image style change event.\n   * @private\n   */\n  handleStyleImageChange_(event) {\n    this.renderIfReadyAndVisible();\n  }\n\n  /**\n   * Render declutter items for this layer\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../layer/Layer.js\").State} layerState Layer state.\n   */\n  renderDeclutter(frameState, layerState) {\n    const context = this.context;\n    const alpha = context.globalAlpha;\n    context.globalAlpha = layerState.opacity;\n    const viewHints = frameState.viewHints;\n    const hifi = !(\n      viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]\n    );\n    const tiles =\n      /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */ (\n        this.renderedTiles\n      );\n    for (let i = 0, ii = tiles.length; i < ii; ++i) {\n      const tile = tiles[i];\n      const executorGroups = tile.executorGroups[getUid(this.getLayer())];\n      const declutter = this.getLayer().getDeclutter();\n      if (executorGroups) {\n        for (let j = executorGroups.length - 1; j >= 0; --j) {\n          executorGroups[j].execute(\n            this.context,\n            [this.context.canvas.width, this.context.canvas.height],\n            this.getTileRenderTransform(tile, frameState),\n            frameState.viewState.rotation,\n            hifi,\n            DECLUTTER,\n            declutter ? frameState.declutter[declutter] : undefined,\n          );\n        }\n      }\n    }\n    context.globalAlpha = alpha;\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   */\n  renderDeferredInternal(frameState) {\n    const tiles =\n      /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */ (\n        this.renderedTiles\n      );\n    const executorGroups = tiles.reduce((acc, tile, index) => {\n      tile.executorGroups[getUid(this.getLayer())].forEach((executorGroup) =>\n        acc.push({\n          executorGroup,\n          index,\n        }),\n      );\n      return acc;\n    }, []);\n\n    const executorGroupZIndexContexts = executorGroups.map(({executorGroup}) =>\n      executorGroup.getDeferredZIndexContexts(),\n    );\n    const usedZIndices = {};\n    for (let i = 0, ii = executorGroups.length; i < ii; ++i) {\n      const executorGroupZindexContext =\n        executorGroups[i].executorGroup.getDeferredZIndexContexts();\n      for (const key in executorGroupZindexContext) {\n        usedZIndices[key] = true;\n      }\n    }\n    const zIndexKeys = Object.keys(usedZIndices).sort(ascending);\n    zIndexKeys.map(Number).forEach((zIndex) => {\n      executorGroupZIndexContexts.forEach((zIndexContexts, i) => {\n        if (!zIndexContexts[zIndex]) {\n          return;\n        }\n        zIndexContexts[zIndex].forEach((zIndexContext) => {\n          const {executorGroup, index} = executorGroups[i];\n          const context = executorGroup.getRenderedContext();\n          const alpha = context.globalAlpha;\n          context.globalAlpha = this.renderedOpacity_;\n          const tileClipContext = this.tileClipContexts_[index];\n          if (tileClipContext) {\n            tileClipContext.draw(context);\n          }\n          zIndexContext.draw(context);\n          if (tileClipContext) {\n            context.restore();\n          }\n          context.globalAlpha = alpha;\n          zIndexContext.clear();\n        });\n        zIndexContexts[zIndex].length = 0;\n      });\n    });\n  }\n\n  getTileRenderTransform(tile, frameState) {\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const center = viewState.center;\n    const resolution = viewState.resolution;\n    const rotation = viewState.rotation;\n    const size = frameState.size;\n    const width = Math.round(size[0] * pixelRatio);\n    const height = Math.round(size[1] * pixelRatio);\n\n    const source = this.getLayer().getSource();\n    const tileGrid = source.getTileGridForProjection(\n      frameState.viewState.projection,\n    );\n    const tileCoord = tile.tileCoord;\n    const tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n    const worldOffset =\n      tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent)[0] - tileExtent[0];\n    const transform = multiply(\n      scale(this.inversePixelTransform.slice(), 1 / pixelRatio, 1 / pixelRatio),\n      this.getRenderTransform(\n        center,\n        resolution,\n        rotation,\n        pixelRatio,\n        width,\n        height,\n        worldOffset,\n      ),\n    );\n    return transform;\n  }\n\n  /**\n   * Render the vectors for this layer.\n   * @param {CanvasRenderingContext2D} context Target context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   */\n  postRender(context, frameState) {\n    const viewHints = frameState.viewHints;\n    const hifi = !(\n      viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]\n    );\n\n    this.renderedPixelToCoordinateTransform_ =\n      frameState.pixelToCoordinateTransform.slice();\n    this.renderedRotation_ = frameState.viewState.rotation;\n    this.renderedOpacity_ =\n      frameState.layerStatesArray[frameState.layerIndex].opacity;\n\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    const renderMode = layer.getRenderMode();\n    const alpha = context.globalAlpha;\n    context.globalAlpha = this.renderedOpacity_;\n    const declutter = layer.getDeclutter();\n    const replayTypes = declutter\n      ? VECTOR_REPLAYS[renderMode].filter((type) => !DECLUTTER.includes(type))\n      : VECTOR_REPLAYS[renderMode];\n    const viewState = frameState.viewState;\n    const rotation = viewState.rotation;\n    const tileSource = layer.getSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n    const z = tileGrid.getZForResolution(\n      viewState.resolution,\n      tileSource.zDirection,\n    );\n\n    const tiles = this.renderedTiles;\n    const clips = [];\n    const clipZs = [];\n    const tileClipContexts = [];\n    let ready = true;\n    for (let i = tiles.length - 1; i >= 0; --i) {\n      const tile = /** @type {import(\"../../VectorRenderTile.js\").default} */ (\n        tiles[i]\n      );\n      ready = ready && !tile.getReplayState(layer).dirty;\n      const executorGroups = tile.executorGroups[getUid(layer)].filter(\n        (group) => group.hasExecutors(replayTypes),\n      );\n      if (executorGroups.length === 0) {\n        continue;\n      }\n      const transform = this.getTileRenderTransform(tile, frameState);\n      const currentZ = tile.tileCoord[0];\n      let contextSaved = false;\n      // Clip mask for regions in this tile that already filled by a higher z tile\n      const currentClip = executorGroups[0].getClipCoords(transform);\n      let clipContext = context;\n      let tileClipContext;\n      if (currentClip) {\n        tileClipContext = new ZIndexContext();\n        clipContext = tileClipContext.getContext();\n        for (let j = 0, jj = clips.length; j < jj; ++j) {\n          if (z !== currentZ && currentZ < clipZs[j]) {\n            const clip = clips[j];\n            if (\n              intersects(\n                [\n                  currentClip[0],\n                  currentClip[3],\n                  currentClip[4],\n                  currentClip[7],\n                ],\n                [clip[0], clip[3], clip[4], clip[7]],\n              )\n            ) {\n              if (!contextSaved) {\n                clipContext.save();\n                contextSaved = true;\n              }\n              clipContext.beginPath();\n              // counter-clockwise (outer ring) for current tile\n              clipContext.moveTo(currentClip[0], currentClip[1]);\n              clipContext.lineTo(currentClip[2], currentClip[3]);\n              clipContext.lineTo(currentClip[4], currentClip[5]);\n              clipContext.lineTo(currentClip[6], currentClip[7]);\n              // clockwise (inner ring) for higher z tile\n              clipContext.moveTo(clip[6], clip[7]);\n              clipContext.lineTo(clip[4], clip[5]);\n              clipContext.lineTo(clip[2], clip[3]);\n              clipContext.lineTo(clip[0], clip[1]);\n              clipContext.clip();\n            }\n          }\n        }\n        clips.push(currentClip);\n        clipZs.push(currentZ);\n      }\n      for (let t = 0, tt = executorGroups.length; t < tt; ++t) {\n        const executorGroup = executorGroups[t];\n        executorGroup.execute(\n          context,\n          [context.canvas.width, context.canvas.height],\n          transform,\n          rotation,\n          hifi,\n          replayTypes,\n          frameState.declutter?.[declutter],\n        );\n      }\n      if (contextSaved) {\n        if (clipContext === context) {\n          clipContext.restore();\n        } else {\n          tileClipContexts[i] = tileClipContext;\n        }\n      }\n    }\n    context.globalAlpha = alpha;\n    this.ready = ready;\n    this.tileClipContexts_ = tileClipContexts;\n    if (!frameState.declutter) {\n      this.renderDeferredInternal(frameState);\n    }\n\n    super.postRender(context, frameState);\n  }\n\n  /**\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../../style/Style.js\").default|Array<import(\"../../style/Style.js\").default>} styles The style or array of styles.\n   * @param {import(\"../../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n   * @param {boolean} [declutter] Enable decluttering.\n   * @param {number} [index] Render order index.\n   * @return {boolean} `true` if an image is loading.\n   */\n  renderFeature(\n    feature,\n    squaredTolerance,\n    styles,\n    builderGroup,\n    declutter,\n    index,\n  ) {\n    if (!styles) {\n      return false;\n    }\n    let loading = false;\n    if (Array.isArray(styles)) {\n      for (let i = 0, ii = styles.length; i < ii; ++i) {\n        loading =\n          renderFeature(\n            builderGroup,\n            feature,\n            styles[i],\n            squaredTolerance,\n            this.boundHandleStyleImageChange_,\n            undefined,\n            declutter,\n            index,\n          ) || loading;\n      }\n    } else {\n      loading = renderFeature(\n        builderGroup,\n        feature,\n        styles,\n        squaredTolerance,\n        this.boundHandleStyleImageChange_,\n        undefined,\n        declutter,\n        index,\n      );\n    }\n    return loading;\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @return {boolean} A new tile image was rendered.\n   * @private\n   */\n  tileImageNeedsRender_(tile) {\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    if (layer.getRenderMode() === 'vector') {\n      return false;\n    }\n    const replayState = tile.getReplayState(layer);\n    const revision = layer.getRevision();\n    const resolution = tile.wantedResolution;\n    return (\n      replayState.renderedTileResolution !== resolution ||\n      replayState.renderedTileRevision !== revision\n    );\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {import(\"../../Map\").FrameState} frameState Frame state.\n   * @private\n   */\n  renderTileImage_(tile, frameState) {\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    const replayState = tile.getReplayState(layer);\n    const revision = layer.getRevision();\n    const executorGroups = tile.executorGroups[getUid(layer)];\n    replayState.renderedTileRevision = revision;\n\n    const tileCoord = tile.wrappedTileCoord;\n    const z = tileCoord[0];\n    const source = layer.getSource();\n    let pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const tileGrid = source.getTileGridForProjection(projection);\n    const tileResolution = tileGrid.getResolution(tile.tileCoord[0]);\n    const renderPixelRatio =\n      (frameState.pixelRatio / tile.wantedResolution) * tileResolution;\n    const resolution = tileGrid.getResolution(z);\n    const context = tile.getContext(layer);\n\n    // Increase tile size when overzooming for low pixel ratio, to avoid blurry tiles\n    pixelRatio = Math.round(\n      Math.max(pixelRatio, renderPixelRatio / pixelRatio),\n    );\n    const size = source.getTilePixelSize(z, pixelRatio, projection);\n    context.canvas.width = size[0];\n    context.canvas.height = size[1];\n    const renderScale = pixelRatio / renderPixelRatio;\n    if (renderScale !== 1) {\n      const canvasTransform = resetTransform(this.tmpTransform_);\n      scaleTransform(canvasTransform, renderScale, renderScale);\n      context.setTransform.apply(context, canvasTransform);\n    }\n    const tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);\n    const pixelScale = renderPixelRatio / resolution;\n    const transform = resetTransform(this.tmpTransform_);\n    scaleTransform(transform, pixelScale, -pixelScale);\n    translateTransform(transform, -tileExtent[0], -tileExtent[3]);\n    for (let i = 0, ii = executorGroups.length; i < ii; ++i) {\n      const executorGroup = executorGroups[i];\n      executorGroup.execute(\n        context,\n        [\n          context.canvas.width * renderScale,\n          context.canvas.height * renderScale,\n        ],\n        transform,\n        0,\n        true,\n        IMAGE_REPLAYS[layer.getRenderMode()],\n        null,\n      );\n    }\n    replayState.renderedTileResolution = tile.wantedResolution;\n  }\n}\n\nexport default CanvasVectorTileLayerRenderer;\n","/**\n * @module ol/renderer/canvas/VectorLayer\n */\nimport CanvasBuilderGroup from '../../render/canvas/BuilderGroup.js';\nimport CanvasLayerRenderer, {canvasPool} from './Layer.js';\nimport ExecutorGroup, {\n  ALL,\n  DECLUTTER,\n  NON_DECLUTTER,\n} from '../../render/canvas/ExecutorGroup.js';\nimport RenderEventType from '../../render/EventType.js';\nimport ViewHint from '../../ViewHint.js';\nimport {\n  HIT_DETECT_RESOLUTION,\n  createHitDetectionImageData,\n  hitDetect,\n} from '../../render/canvas/hitdetect.js';\nimport {\n  buffer,\n  containsExtent,\n  createEmpty,\n  getHeight,\n  getWidth,\n  intersects as intersectsExtent,\n  wrapX as wrapExtentX,\n} from '../../extent.js';\nimport {createCanvasContext2D, releaseCanvas} from '../../dom.js';\nimport {\n  defaultOrder as defaultRenderOrder,\n  getTolerance as getRenderTolerance,\n  getSquaredTolerance as getSquaredRenderTolerance,\n  renderFeature,\n} from '../vector.js';\nimport {equals} from '../../array.js';\nimport {\n  fromUserExtent,\n  getTransformFromProjections,\n  getUserProjection,\n  toUserExtent,\n  toUserResolution,\n} from '../../proj.js';\nimport {getUid} from '../../util.js';\nimport {wrapX as wrapCoordinateX} from '../../coordinate.js';\n\n/**\n * @classdesc\n * Canvas renderer for vector layers.\n * @api\n */\nclass CanvasVectorLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {import(\"../../layer/BaseVector.js\").default} vectorLayer Vector layer.\n   */\n  constructor(vectorLayer) {\n    super(vectorLayer);\n\n    /** @private */\n    this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this);\n\n    /**\n     * @type {boolean}\n     */\n    this.animatingOrInteracting_;\n\n    /**\n     * @type {ImageData|null}\n     */\n    this.hitDetectionImageData_ = null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.clipped_ = false;\n\n    /**\n     * @private\n     * @type {Array<import(\"../../Feature.js\").default>}\n     */\n    this.renderedFeatures_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedRevision_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedResolution_ = NaN;\n\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.renderedExtent_ = createEmpty();\n\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.wrappedRenderedExtent_ = createEmpty();\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedRotation_;\n\n    /**\n     * @private\n     * @type {import(\"../../coordinate\").Coordinate}\n     */\n    this.renderedCenter_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../../proj/Projection\").default}\n     */\n    this.renderedProjection_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedPixelRatio_ = 1;\n\n    /**\n     * @private\n     * @type {function(import(\"../../Feature.js\").default, import(\"../../Feature.js\").default): number|null}\n     */\n    this.renderedRenderOrder_ = null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.renderedFrameDeclutter_;\n\n    /**\n     * @private\n     * @type {import(\"../../render/canvas/ExecutorGroup\").default}\n     */\n    this.replayGroup_ = null;\n\n    /**\n     * A new replay group had to be created by `prepareFrame()`\n     * @type {boolean}\n     */\n    this.replayGroupChanged = true;\n\n    /**\n     * Clipping to be performed by `renderFrame()`\n     * @type {boolean}\n     */\n    this.clipping = true;\n\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n    this.targetContext_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.opacity_ = 1;\n  }\n\n  /**\n   * @param {ExecutorGroup} executorGroup Executor group.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {boolean} [declutterable] `true` to only render declutterable items,\n   *     `false` to only render non-declutterable items, `undefined` to render all.\n   */\n  renderWorlds(executorGroup, frameState, declutterable) {\n    const extent = frameState.extent;\n    const viewState = frameState.viewState;\n    const center = viewState.center;\n    const resolution = viewState.resolution;\n    const projection = viewState.projection;\n    const rotation = viewState.rotation;\n    const projectionExtent = projection.getExtent();\n    const vectorSource = this.getLayer().getSource();\n    const declutter = this.getLayer().getDeclutter();\n    const pixelRatio = frameState.pixelRatio;\n    const viewHints = frameState.viewHints;\n    const snapToPixel = !(\n      viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]\n    );\n    const context = this.context;\n    const width = Math.round((getWidth(extent) / resolution) * pixelRatio);\n    const height = Math.round((getHeight(extent) / resolution) * pixelRatio);\n\n    const multiWorld = vectorSource.getWrapX() && projection.canWrapX();\n    const worldWidth = multiWorld ? getWidth(projectionExtent) : null;\n    const endWorld = multiWorld\n      ? Math.ceil((extent[2] - projectionExtent[2]) / worldWidth) + 1\n      : 1;\n    let world = multiWorld\n      ? Math.floor((extent[0] - projectionExtent[0]) / worldWidth)\n      : 0;\n    do {\n      let transform = this.getRenderTransform(\n        center,\n        resolution,\n        0,\n        pixelRatio,\n        width,\n        height,\n        world * worldWidth,\n      );\n      if (frameState.declutter) {\n        transform = transform.slice(0);\n      }\n      executorGroup.execute(\n        context,\n        [context.canvas.width, context.canvas.height],\n        transform,\n        rotation,\n        snapToPixel,\n        declutterable === undefined\n          ? ALL\n          : declutterable\n            ? DECLUTTER\n            : NON_DECLUTTER,\n        declutterable\n          ? declutter && frameState.declutter[declutter]\n          : undefined,\n      );\n    } while (++world < endWorld);\n  }\n\n  /**\n   * @private\n   */\n  setDrawContext_() {\n    if (this.opacity_ !== 1) {\n      this.targetContext_ = this.context;\n      this.context = createCanvasContext2D(\n        this.context.canvas.width,\n        this.context.canvas.height,\n        canvasPool,\n      );\n    }\n  }\n\n  /**\n   * @private\n   */\n  resetDrawContext_() {\n    if (this.opacity_ !== 1) {\n      const alpha = this.targetContext_.globalAlpha;\n      this.targetContext_.globalAlpha = this.opacity_;\n      this.targetContext_.drawImage(this.context.canvas, 0, 0);\n      this.targetContext_.globalAlpha = alpha;\n      releaseCanvas(this.context);\n      canvasPool.push(this.context.canvas);\n      this.context = this.targetContext_;\n      this.targetContext_ = null;\n    }\n  }\n\n  /**\n   * Render declutter items for this layer\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   */\n  renderDeclutter(frameState) {\n    if (!this.replayGroup_ || !this.getLayer().getDeclutter()) {\n      return;\n    }\n    this.renderWorlds(this.replayGroup_, frameState, true);\n  }\n\n  /**\n   * Render deferred instructions.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   */\n  renderDeferredInternal(frameState) {\n    if (!this.replayGroup_) {\n      return;\n    }\n    this.replayGroup_.renderDeferred();\n    if (this.clipped_) {\n      this.context.restore();\n    }\n    this.resetDrawContext_();\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement|null} target Target that may be used to render content to.\n   * @return {HTMLElement|null} The rendered element.\n   */\n  renderFrame(frameState, target) {\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    this.opacity_ = layerState.opacity;\n    const viewState = frameState.viewState;\n\n    this.prepareContainer(frameState, target);\n    const context = this.context;\n\n    const replayGroup = this.replayGroup_;\n    let render = replayGroup && !replayGroup.isEmpty();\n    if (!render) {\n      const hasRenderListeners =\n        this.getLayer().hasListener(RenderEventType.PRERENDER) ||\n        this.getLayer().hasListener(RenderEventType.POSTRENDER);\n      if (!hasRenderListeners) {\n        return null;\n      }\n    }\n\n    this.setDrawContext_();\n\n    this.preRender(context, frameState);\n\n    const projection = viewState.projection;\n\n    // clipped rendering if layer extent is set\n    this.clipped_ = false;\n    if (render && layerState.extent && this.clipping) {\n      const layerExtent = fromUserExtent(layerState.extent, projection);\n      render = intersectsExtent(layerExtent, frameState.extent);\n      this.clipped_ = render && !containsExtent(layerExtent, frameState.extent);\n      if (this.clipped_) {\n        this.clipUnrotated(context, frameState, layerExtent);\n      }\n    }\n\n    if (render) {\n      this.renderWorlds(\n        replayGroup,\n        frameState,\n        this.getLayer().getDeclutter() ? false : undefined,\n      );\n    }\n\n    if (!frameState.declutter && this.clipped_) {\n      context.restore();\n    }\n\n    this.postRender(context, frameState);\n\n    if (this.renderedRotation_ !== viewState.rotation) {\n      this.renderedRotation_ = viewState.rotation;\n      this.hitDetectionImageData_ = null;\n    }\n    if (!frameState.declutter) {\n      this.resetDrawContext_();\n    }\n    return this.container;\n  }\n\n  /**\n   * Asynchronous layer level hit detection.\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../../Feature\").default>>} Promise\n   * that resolves with an array of features.\n   */\n  getFeatures(pixel) {\n    return new Promise((resolve) => {\n      if (\n        this.frameState &&\n        !this.hitDetectionImageData_ &&\n        !this.animatingOrInteracting_\n      ) {\n        const size = this.frameState.size.slice();\n        const center = this.renderedCenter_;\n        const resolution = this.renderedResolution_;\n        const rotation = this.renderedRotation_;\n        const projection = this.renderedProjection_;\n        const extent = this.wrappedRenderedExtent_;\n        const layer = this.getLayer();\n        const transforms = [];\n        const width = size[0] * HIT_DETECT_RESOLUTION;\n        const height = size[1] * HIT_DETECT_RESOLUTION;\n        transforms.push(\n          this.getRenderTransform(\n            center,\n            resolution,\n            rotation,\n            HIT_DETECT_RESOLUTION,\n            width,\n            height,\n            0,\n          ).slice(),\n        );\n        const source = layer.getSource();\n        const projectionExtent = projection.getExtent();\n        if (\n          source.getWrapX() &&\n          projection.canWrapX() &&\n          !containsExtent(projectionExtent, extent)\n        ) {\n          let startX = extent[0];\n          const worldWidth = getWidth(projectionExtent);\n          let world = 0;\n          let offsetX;\n          while (startX < projectionExtent[0]) {\n            --world;\n            offsetX = worldWidth * world;\n            transforms.push(\n              this.getRenderTransform(\n                center,\n                resolution,\n                rotation,\n                HIT_DETECT_RESOLUTION,\n                width,\n                height,\n                offsetX,\n              ).slice(),\n            );\n            startX += worldWidth;\n          }\n          world = 0;\n          startX = extent[2];\n          while (startX > projectionExtent[2]) {\n            ++world;\n            offsetX = worldWidth * world;\n            transforms.push(\n              this.getRenderTransform(\n                center,\n                resolution,\n                rotation,\n                HIT_DETECT_RESOLUTION,\n                width,\n                height,\n                offsetX,\n              ).slice(),\n            );\n            startX -= worldWidth;\n          }\n        }\n        const userProjection = getUserProjection();\n        this.hitDetectionImageData_ = createHitDetectionImageData(\n          size,\n          transforms,\n          this.renderedFeatures_,\n          layer.getStyleFunction(),\n          extent,\n          resolution,\n          rotation,\n          getSquaredRenderTolerance(resolution, this.renderedPixelRatio_),\n          userProjection ? projection : null,\n        );\n      }\n      resolve(\n        hitDetect(pixel, this.renderedFeatures_, this.hitDetectionImageData_),\n      );\n    });\n  }\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches,\n  ) {\n    if (!this.replayGroup_) {\n      return undefined;\n    }\n    const resolution = frameState.viewState.resolution;\n    const rotation = frameState.viewState.rotation;\n    const layer = this.getLayer();\n\n    /** @type {!Object<string, import(\"../Map.js\").HitMatch<T>|true>} */\n    const features = {};\n\n    /**\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     * @param {import(\"../../geom/SimpleGeometry.js\").default} geometry Geometry.\n     * @param {number} distanceSq The squared distance to the click position\n     * @return {T|undefined} Callback result.\n     */\n    const featureCallback = function (feature, geometry, distanceSq) {\n      const key = getUid(feature);\n      const match = features[key];\n      if (!match) {\n        if (distanceSq === 0) {\n          features[key] = true;\n          return callback(feature, layer, geometry);\n        }\n        matches.push(\n          (features[key] = {\n            feature: feature,\n            layer: layer,\n            geometry: geometry,\n            distanceSq: distanceSq,\n            callback: callback,\n          }),\n        );\n      } else if (match !== true && distanceSq < match.distanceSq) {\n        if (distanceSq === 0) {\n          features[key] = true;\n          matches.splice(matches.lastIndexOf(match), 1);\n          return callback(feature, layer, geometry);\n        }\n        match.geometry = geometry;\n        match.distanceSq = distanceSq;\n      }\n      return undefined;\n    };\n\n    let result;\n    const executorGroups = [this.replayGroup_];\n    const declutter = this.getLayer().getDeclutter();\n    executorGroups.some((executorGroup) => {\n      return (result = executorGroup.forEachFeatureAtCoordinate(\n        coordinate,\n        resolution,\n        rotation,\n        hitTolerance,\n        featureCallback,\n        declutter && frameState.declutter[declutter]\n          ? frameState.declutter[declutter].all().map((item) => item.value)\n          : null,\n      ));\n    });\n\n    return result;\n  }\n\n  /**\n   * Perform action necessary to get the layer rendered after new fonts have loaded\n   */\n  handleFontsChanged() {\n    const layer = this.getLayer();\n    if (layer.getVisible() && this.replayGroup_) {\n      layer.changed();\n    }\n  }\n\n  /**\n   * Handle changes in image style state.\n   * @param {import(\"../../events/Event.js\").default} event Image style change event.\n   * @private\n   */\n  handleStyleImageChange_(event) {\n    this.renderIfReadyAndVisible();\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    const vectorLayer = this.getLayer();\n    const vectorSource = vectorLayer.getSource();\n    if (!vectorSource) {\n      return false;\n    }\n\n    const animating = frameState.viewHints[ViewHint.ANIMATING];\n    const interacting = frameState.viewHints[ViewHint.INTERACTING];\n    const updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();\n    const updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();\n\n    if (\n      (this.ready && !updateWhileAnimating && animating) ||\n      (!updateWhileInteracting && interacting)\n    ) {\n      this.animatingOrInteracting_ = true;\n      return true;\n    }\n    this.animatingOrInteracting_ = false;\n\n    const frameStateExtent = frameState.extent;\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const resolution = viewState.resolution;\n    const pixelRatio = frameState.pixelRatio;\n    const vectorLayerRevision = vectorLayer.getRevision();\n    const vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();\n    let vectorLayerRenderOrder = vectorLayer.getRenderOrder();\n\n    if (vectorLayerRenderOrder === undefined) {\n      vectorLayerRenderOrder = defaultRenderOrder;\n    }\n\n    const center = viewState.center.slice();\n    const extent = buffer(\n      frameStateExtent,\n      vectorLayerRenderBuffer * resolution,\n    );\n    const renderedExtent = extent.slice();\n    const loadExtents = [extent.slice()];\n    const projectionExtent = projection.getExtent();\n\n    if (\n      vectorSource.getWrapX() &&\n      projection.canWrapX() &&\n      !containsExtent(projectionExtent, frameState.extent)\n    ) {\n      // For the replay group, we need an extent that intersects the real world\n      // (-180° to +180°). To support geometries in a coordinate range from -540°\n      // to +540°, we add at least 1 world width on each side of the projection\n      // extent. If the viewport is wider than the world, we need to add half of\n      // the viewport width to make sure we cover the whole viewport.\n      const worldWidth = getWidth(projectionExtent);\n      const gutter = Math.max(getWidth(extent) / 2, worldWidth);\n      extent[0] = projectionExtent[0] - gutter;\n      extent[2] = projectionExtent[2] + gutter;\n      wrapCoordinateX(center, projection);\n      const loadExtent = wrapExtentX(loadExtents[0], projection);\n      // If the extent crosses the date line, we load data for both edges of the worlds\n      if (\n        loadExtent[0] < projectionExtent[0] &&\n        loadExtent[2] < projectionExtent[2]\n      ) {\n        loadExtents.push([\n          loadExtent[0] + worldWidth,\n          loadExtent[1],\n          loadExtent[2] + worldWidth,\n          loadExtent[3],\n        ]);\n      } else if (\n        loadExtent[0] > projectionExtent[0] &&\n        loadExtent[2] > projectionExtent[2]\n      ) {\n        loadExtents.push([\n          loadExtent[0] - worldWidth,\n          loadExtent[1],\n          loadExtent[2] - worldWidth,\n          loadExtent[3],\n        ]);\n      }\n    }\n\n    if (\n      this.ready &&\n      this.renderedResolution_ == resolution &&\n      this.renderedRevision_ == vectorLayerRevision &&\n      this.renderedRenderOrder_ == vectorLayerRenderOrder &&\n      this.renderedFrameDeclutter_ === !!frameState.declutter &&\n      containsExtent(this.wrappedRenderedExtent_, extent)\n    ) {\n      if (!equals(this.renderedExtent_, renderedExtent)) {\n        this.hitDetectionImageData_ = null;\n        this.renderedExtent_ = renderedExtent;\n      }\n      this.renderedCenter_ = center;\n      this.replayGroupChanged = false;\n      return true;\n    }\n\n    this.replayGroup_ = null;\n\n    const replayGroup = new CanvasBuilderGroup(\n      getRenderTolerance(resolution, pixelRatio),\n      extent,\n      resolution,\n      pixelRatio,\n    );\n\n    const userProjection = getUserProjection();\n    let userTransform;\n    if (userProjection) {\n      for (let i = 0, ii = loadExtents.length; i < ii; ++i) {\n        const extent = loadExtents[i];\n        const userExtent = toUserExtent(extent, projection);\n        vectorSource.loadFeatures(\n          userExtent,\n          toUserResolution(resolution, projection),\n          userProjection,\n        );\n      }\n      userTransform = getTransformFromProjections(userProjection, projection);\n    } else {\n      for (let i = 0, ii = loadExtents.length; i < ii; ++i) {\n        vectorSource.loadFeatures(loadExtents[i], resolution, projection);\n      }\n    }\n\n    const squaredTolerance = getSquaredRenderTolerance(resolution, pixelRatio);\n    let ready = true;\n    const render =\n      /**\n       * @param {import(\"../../Feature.js\").default} feature Feature.\n       * @param {number} index Index.\n       */\n      (feature, index) => {\n        let styles;\n        const styleFunction =\n          feature.getStyleFunction() || vectorLayer.getStyleFunction();\n        if (styleFunction) {\n          styles = styleFunction(feature, resolution);\n        }\n        if (styles) {\n          const dirty = this.renderFeature(\n            feature,\n            squaredTolerance,\n            styles,\n            replayGroup,\n            userTransform,\n            this.getLayer().getDeclutter(),\n            index,\n          );\n          ready = ready && !dirty;\n        }\n      };\n\n    const userExtent = toUserExtent(extent, projection);\n    /** @type {Array<import(\"../../Feature.js\").default>} */\n    const features = vectorSource.getFeaturesInExtent(userExtent);\n    if (vectorLayerRenderOrder) {\n      features.sort(vectorLayerRenderOrder);\n    }\n    for (let i = 0, ii = features.length; i < ii; ++i) {\n      render(features[i], i);\n    }\n    this.renderedFeatures_ = features;\n    this.ready = ready;\n\n    const replayGroupInstructions = replayGroup.finish();\n    const executorGroup = new ExecutorGroup(\n      extent,\n      resolution,\n      pixelRatio,\n      vectorSource.getOverlaps(),\n      replayGroupInstructions,\n      vectorLayer.getRenderBuffer(),\n      !!frameState.declutter,\n    );\n\n    this.renderedResolution_ = resolution;\n    this.renderedRevision_ = vectorLayerRevision;\n    this.renderedRenderOrder_ = vectorLayerRenderOrder;\n    this.renderedFrameDeclutter_ = !!frameState.declutter;\n    this.renderedExtent_ = renderedExtent;\n    this.wrappedRenderedExtent_ = extent;\n    this.renderedCenter_ = center;\n    this.renderedProjection_ = projection;\n    this.renderedPixelRatio_ = pixelRatio;\n    this.replayGroup_ = executorGroup;\n    this.hitDetectionImageData_ = null;\n\n    this.replayGroupChanged = true;\n    return true;\n  }\n\n  /**\n   * @param {import(\"../../Feature.js\").default} feature Feature.\n   * @param {number} squaredTolerance Squared render tolerance.\n   * @param {import(\"../../style/Style.js\").default|Array<import(\"../../style/Style.js\").default>} styles The style or array of styles.\n   * @param {import(\"../../render/canvas/BuilderGroup.js\").default} builderGroup Builder group.\n   * @param {import(\"../../proj.js\").TransformFunction} [transform] Transform from user to view projection.\n   * @param {boolean} [declutter] Enable decluttering.\n   * @param {number} [index] Render order index.\n   * @return {boolean} `true` if an image is loading.\n   */\n  renderFeature(\n    feature,\n    squaredTolerance,\n    styles,\n    builderGroup,\n    transform,\n    declutter,\n    index,\n  ) {\n    if (!styles) {\n      return false;\n    }\n    let loading = false;\n    if (Array.isArray(styles)) {\n      for (let i = 0, ii = styles.length; i < ii; ++i) {\n        loading =\n          renderFeature(\n            builderGroup,\n            feature,\n            styles[i],\n            squaredTolerance,\n            this.boundHandleStyleImageChange_,\n            transform,\n            declutter,\n            index,\n          ) || loading;\n      }\n    } else {\n      loading = renderFeature(\n        builderGroup,\n        feature,\n        styles,\n        squaredTolerance,\n        this.boundHandleStyleImageChange_,\n        transform,\n        declutter,\n        index,\n      );\n    }\n    return loading;\n  }\n}\n\nexport default CanvasVectorLayerRenderer;\n","/**\n * @module ol/renderer/webgl/Layer\n */\nimport LayerProperty from '../../layer/Property.js';\nimport LayerRenderer from '../Layer.js';\nimport RenderEvent from '../../render/Event.js';\nimport RenderEventType from '../../render/EventType.js';\nimport WebGLHelper from '../../webgl/Helper.js';\nimport {\n  compose as composeTransform,\n  create as createTransform,\n} from '../../transform.js';\n\n/**\n * @typedef {Object} PostProcessesOptions\n * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than\n * the main canvas that will then be sampled up (useful for saving resource on blur steps).\n * @property {string} [vertexShader] Vertex shader source\n * @property {string} [fragmentShader] Fragment shader source\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process step\n */\n\n/**\n * @typedef {Object} Options\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process steps\n * @property {Array<PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n\n/**\n * @classdesc\n * Base WebGL renderer class.\n * Holds all logic related to data manipulation & some common rendering logic\n * @template {import(\"../../layer/Layer.js\").default} LayerType\n * @extends {LayerRenderer<LayerType>}\n */\nclass WebGLLayerRenderer extends LayerRenderer {\n  /**\n   * @param {LayerType} layer Layer.\n   * @param {Options} [options] Options.\n   */\n  constructor(layer, options) {\n    super(layer);\n\n    options = options || {};\n\n    /**\n     * The transform for viewport CSS pixels to rendered pixels.  This transform is only\n     * set before dispatching rendering events.\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.inversePixelTransform_ = createTransform();\n\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n    this.pixelContext_ = null;\n\n    /**\n     * @private\n     */\n    this.postProcesses_ = options.postProcesses;\n\n    /**\n     * @private\n     */\n    this.uniforms_ = options.uniforms;\n\n    /**\n     * @type {WebGLHelper}\n     * @protected\n     */\n    this.helper;\n\n    layer.addChangeListener(LayerProperty.MAP, this.removeHelper.bind(this));\n\n    this.dispatchPreComposeEvent = this.dispatchPreComposeEvent.bind(this);\n    this.dispatchPostComposeEvent = this.dispatchPostComposeEvent.bind(this);\n  }\n\n  /**\n   * @param {WebGLRenderingContext} context The WebGL rendering context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  dispatchPreComposeEvent(context, frameState) {\n    const layer = this.getLayer();\n    if (layer.hasListener(RenderEventType.PRECOMPOSE)) {\n      const event = new RenderEvent(\n        RenderEventType.PRECOMPOSE,\n        undefined,\n        frameState,\n        context,\n      );\n      layer.dispatchEvent(event);\n    }\n  }\n\n  /**\n   * @param {WebGLRenderingContext} context The WebGL rendering context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  dispatchPostComposeEvent(context, frameState) {\n    const layer = this.getLayer();\n    if (layer.hasListener(RenderEventType.POSTCOMPOSE)) {\n      const event = new RenderEvent(\n        RenderEventType.POSTCOMPOSE,\n        undefined,\n        frameState,\n        context,\n      );\n      layer.dispatchEvent(event);\n    }\n  }\n\n  /**\n   * Reset options (only handles uniforms).\n   * @param {Options} options Options.\n   */\n  reset(options) {\n    this.uniforms_ = options.uniforms;\n    if (this.helper) {\n      this.helper.setUniforms(this.uniforms_);\n    }\n  }\n\n  /**\n   * @protected\n   */\n  removeHelper() {\n    if (this.helper) {\n      this.helper.dispose();\n      delete this.helper;\n    }\n  }\n\n  /**\n   * Determine whether renderFrame should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    if (this.getLayer().getRenderSource()) {\n      let incrementGroup = true;\n      let groupNumber = -1;\n      let className;\n      for (let i = 0, ii = frameState.layerStatesArray.length; i < ii; i++) {\n        const layer = frameState.layerStatesArray[i].layer;\n        const renderer = layer.getRenderer();\n        if (!(renderer instanceof WebGLLayerRenderer)) {\n          incrementGroup = true;\n          continue;\n        }\n        const layerClassName = layer.getClassName();\n        if (incrementGroup || layerClassName !== className) {\n          groupNumber += 1;\n          incrementGroup = false;\n        }\n        className = layerClassName;\n        if (renderer === this) {\n          break;\n        }\n      }\n\n      const canvasCacheKey =\n        'map/' + frameState.mapId + '/group/' + groupNumber;\n\n      if (\n        !this.helper ||\n        !this.helper.canvasCacheKeyMatches(canvasCacheKey) ||\n        this.helper.needsToBeRecreated()\n      ) {\n        this.removeHelper();\n\n        this.helper = new WebGLHelper({\n          postProcesses: this.postProcesses_,\n          uniforms: this.uniforms_,\n          canvasCacheKey: canvasCacheKey,\n        });\n\n        if (className) {\n          this.helper.getCanvas().className = className;\n        }\n\n        this.afterHelperCreated();\n      }\n    }\n\n    return this.prepareFrameInternal(frameState);\n  }\n\n  /**\n   * @protected\n   */\n  afterHelperCreated() {}\n\n  /**\n   * Determine whether renderFrame should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   * @protected\n   */\n  prepareFrameInternal(frameState) {\n    return true;\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    this.removeHelper();\n    super.disposeInternal();\n  }\n\n  /**\n   * @param {import(\"../../render/EventType.js\").default} type Event type.\n   * @param {WebGLRenderingContext} context The rendering context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @private\n   */\n  dispatchRenderEvent_(type, context, frameState) {\n    const layer = this.getLayer();\n    if (layer.hasListener(type)) {\n      composeTransform(\n        this.inversePixelTransform_,\n        0,\n        0,\n        frameState.pixelRatio,\n        -frameState.pixelRatio,\n        0,\n        0,\n        -frameState.size[1],\n      );\n\n      const event = new RenderEvent(\n        type,\n        this.inversePixelTransform_,\n        frameState,\n        context,\n      );\n      layer.dispatchEvent(event);\n    }\n  }\n\n  /**\n   * @param {WebGLRenderingContext} context The rendering context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  preRender(context, frameState) {\n    this.dispatchRenderEvent_(RenderEventType.PRERENDER, context, frameState);\n  }\n\n  /**\n   * @param {WebGLRenderingContext} context The rendering context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  postRender(context, frameState) {\n    this.dispatchRenderEvent_(RenderEventType.POSTRENDER, context, frameState);\n  }\n}\n\nexport default WebGLLayerRenderer;\n","/**\n * @module ol/renderer/canvas/ImageLayer\n */\nimport CanvasLayerRenderer from './Layer.js';\nimport ImageState from '../../ImageState.js';\nimport ViewHint from '../../ViewHint.js';\nimport {\n  apply as applyTransform,\n  compose as composeTransform,\n} from '../../transform.js';\nimport {\n  containsCoordinate,\n  containsExtent,\n  getHeight,\n  getIntersection,\n  getWidth,\n  intersects as intersectsExtent,\n  isEmpty,\n} from '../../extent.js';\nimport {fromUserExtent} from '../../proj.js';\n\n/**\n * @classdesc\n * Canvas renderer for image layers.\n * @api\n */\nclass CanvasImageLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {import(\"../../layer/Image.js\").default} imageLayer Image layer.\n   */\n  constructor(imageLayer) {\n    super(imageLayer);\n\n    /**\n     * @protected\n     * @type {?import(\"../../Image.js\").default}\n     */\n    this.image_ = null;\n  }\n\n  /**\n   * @return {import('../../DataTile.js').ImageLike} Image.\n   */\n  getImage() {\n    return !this.image_ ? null : this.image_.getImage();\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const viewResolution = viewState.resolution;\n\n    const imageSource = this.getLayer().getSource();\n\n    const hints = frameState.viewHints;\n\n    let renderedExtent = frameState.extent;\n    if (layerState.extent !== undefined) {\n      renderedExtent = getIntersection(\n        renderedExtent,\n        fromUserExtent(layerState.extent, viewState.projection),\n      );\n    }\n\n    if (\n      !hints[ViewHint.ANIMATING] &&\n      !hints[ViewHint.INTERACTING] &&\n      !isEmpty(renderedExtent)\n    ) {\n      if (imageSource) {\n        const projection = viewState.projection;\n        const image = imageSource.getImage(\n          renderedExtent,\n          viewResolution,\n          pixelRatio,\n          projection,\n        );\n        if (image) {\n          if (this.loadImage(image)) {\n            this.image_ = image;\n          } else if (image.getState() === ImageState.EMPTY) {\n            this.image_ = null;\n          }\n        }\n      } else {\n        this.image_ = null;\n      }\n    }\n\n    return !!this.image_;\n  }\n\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray} Data at the pixel location.\n   */\n  getData(pixel) {\n    const frameState = this.frameState;\n    if (!frameState) {\n      return null;\n    }\n\n    const layer = this.getLayer();\n    const coordinate = applyTransform(\n      frameState.pixelToCoordinateTransform,\n      pixel.slice(),\n    );\n\n    const layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (!containsCoordinate(layerExtent, coordinate)) {\n        return null;\n      }\n    }\n\n    const imageExtent = this.image_.getExtent();\n    const img = this.image_.getImage();\n\n    const imageMapWidth = getWidth(imageExtent);\n    const col = Math.floor(\n      img.width * ((coordinate[0] - imageExtent[0]) / imageMapWidth),\n    );\n    if (col < 0 || col >= img.width) {\n      return null;\n    }\n\n    const imageMapHeight = getHeight(imageExtent);\n    const row = Math.floor(\n      img.height * ((imageExtent[3] - coordinate[1]) / imageMapHeight),\n    );\n    if (row < 0 || row >= img.height) {\n      return null;\n    }\n\n    return this.getImageData(img, col, row);\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState, target) {\n    const image = this.image_;\n    const imageExtent = image.getExtent();\n    const imageResolution = image.getResolution();\n    const [imageResolutionX, imageResolutionY] = Array.isArray(imageResolution)\n      ? imageResolution\n      : [imageResolution, imageResolution];\n    const imagePixelRatio = image.getPixelRatio();\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const viewCenter = viewState.center;\n    const viewResolution = viewState.resolution;\n    const scaleX =\n      (pixelRatio * imageResolutionX) / (viewResolution * imagePixelRatio);\n    const scaleY =\n      (pixelRatio * imageResolutionY) / (viewResolution * imagePixelRatio);\n\n    this.prepareContainer(frameState, target);\n\n    // desired dimensions of the canvas in pixels\n    const width = this.context.canvas.width;\n    const height = this.context.canvas.height;\n\n    const context = this.getRenderContext(frameState);\n\n    // clipped rendering if layer extent is set\n    let clipped = false;\n    let render = true;\n    if (layerState.extent) {\n      const layerExtent = fromUserExtent(\n        layerState.extent,\n        viewState.projection,\n      );\n      render = intersectsExtent(layerExtent, frameState.extent);\n      clipped = render && !containsExtent(layerExtent, frameState.extent);\n      if (clipped) {\n        this.clipUnrotated(context, frameState, layerExtent);\n      }\n    }\n\n    const img = image.getImage();\n\n    const transform = composeTransform(\n      this.tempTransform,\n      width / 2,\n      height / 2,\n      scaleX,\n      scaleY,\n      0,\n      (imagePixelRatio * (imageExtent[0] - viewCenter[0])) / imageResolutionX,\n      (imagePixelRatio * (viewCenter[1] - imageExtent[3])) / imageResolutionY,\n    );\n\n    this.renderedResolution = (imageResolutionY * pixelRatio) / imagePixelRatio;\n\n    const dw = img.width * transform[0];\n    const dh = img.height * transform[3];\n\n    if (!this.getLayer().getSource().getInterpolate()) {\n      context.imageSmoothingEnabled = false;\n    }\n\n    this.preRender(context, frameState);\n    if (render && dw >= 0.5 && dh >= 0.5) {\n      const dx = transform[4];\n      const dy = transform[5];\n      const opacity = layerState.opacity;\n      if (opacity !== 1) {\n        context.save();\n        context.globalAlpha = opacity;\n      }\n      context.drawImage(img, 0, 0, +img.width, +img.height, dx, dy, dw, dh);\n      if (opacity !== 1) {\n        context.restore();\n      }\n    }\n    this.postRender(this.context, frameState);\n\n    if (clipped) {\n      context.restore();\n    }\n    context.imageSmoothingEnabled = true;\n\n    return this.container;\n  }\n}\n\nexport default CanvasImageLayerRenderer;\n","/**\n * @module ol/renderer/vector\n */\nimport ImageState from '../ImageState.js';\nimport {getUid} from '../util.js';\n\n/**\n * Feature callback. The callback will be called with three arguments. The first\n * argument is one {@link module:ol/Feature~Feature feature} or {@link module:ol/render/Feature~RenderFeature render feature}\n * at the pixel, the second is the {@link module:ol/layer/Layer~Layer layer} of the feature and will be null for\n * unmanaged layers. The third is the {@link module:ol/geom/SimpleGeometry~SimpleGeometry} of the feature. For features\n * with a GeometryCollection geometry, it will be the first detected geometry from the collection.\n * @template T\n * @typedef {function(import(\"../Feature.js\").FeatureLike, import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>, import(\"../geom/SimpleGeometry.js\").default): T} FeatureCallback\n */\n\n/**\n * Tolerance for geometry simplification in device pixels.\n * @type {number}\n */\nconst SIMPLIFY_TOLERANCE = 0.5;\n\n/**\n * @const\n * @type {Object<import(\"../geom/Geometry.js\").Type,\n *                function(import(\"../render/canvas/BuilderGroup.js\").default, import(\"../geom/Geometry.js\").default,\n *                         import(\"../style/Style.js\").default, Object): void>}\n */\nconst GEOMETRY_RENDERERS = {\n  'Point': renderPointGeometry,\n  'LineString': renderLineStringGeometry,\n  'Polygon': renderPolygonGeometry,\n  'MultiPoint': renderMultiPointGeometry,\n  'MultiLineString': renderMultiLineStringGeometry,\n  'MultiPolygon': renderMultiPolygonGeometry,\n  'GeometryCollection': renderGeometryCollectionGeometry,\n  'Circle': renderCircleGeometry,\n};\n\n/**\n * @param {import(\"../Feature.js\").FeatureLike} feature1 Feature 1.\n * @param {import(\"../Feature.js\").FeatureLike} feature2 Feature 2.\n * @return {number} Order.\n */\nexport function defaultOrder(feature1, feature2) {\n  return parseInt(getUid(feature1), 10) - parseInt(getUid(feature2), 10);\n}\n\n/**\n * @param {number} resolution Resolution.\n * @param {number} pixelRatio Pixel ratio.\n * @return {number} Squared pixel tolerance.\n */\nexport function getSquaredTolerance(resolution, pixelRatio) {\n  const tolerance = getTolerance(resolution, pixelRatio);\n  return tolerance * tolerance;\n}\n\n/**\n * @param {number} resolution Resolution.\n * @param {number} pixelRatio Pixel ratio.\n * @return {number} Pixel tolerance.\n */\nexport function getTolerance(resolution, pixelRatio) {\n  return (SIMPLIFY_TOLERANCE * resolution) / pixelRatio;\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Builder group.\n * @param {import(\"../geom/Circle.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {number} [index] Render order index.\n */\nfunction renderCircleGeometry(builderGroup, geometry, style, feature, index) {\n  const fillStyle = style.getFill();\n  const strokeStyle = style.getStroke();\n  if (fillStyle || strokeStyle) {\n    const circleReplay = builderGroup.getBuilder(style.getZIndex(), 'Circle');\n    circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);\n    circleReplay.drawCircle(geometry, feature, index);\n  }\n  const textStyle = style.getText();\n  if (textStyle && textStyle.getText()) {\n    const textReplay = builderGroup.getBuilder(style.getZIndex(), 'Text');\n    textReplay.setTextStyle(textStyle);\n    textReplay.drawText(geometry, feature);\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} replayGroup Replay group.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {function(import(\"../events/Event.js\").default): void} listener Listener function.\n * @param {import(\"../proj.js\").TransformFunction} [transform] Transform from user to view projection.\n * @param {boolean} [declutter] Enable decluttering.\n * @param {number} [index] Render order index..\n * @return {boolean} `true` if style is loading.\n */\nexport function renderFeature(\n  replayGroup,\n  feature,\n  style,\n  squaredTolerance,\n  listener,\n  transform,\n  declutter,\n  index,\n) {\n  const loadingPromises = [];\n  const imageStyle = style.getImage();\n  if (imageStyle) {\n    let loading = true;\n    const imageState = imageStyle.getImageState();\n    if (imageState == ImageState.LOADED || imageState == ImageState.ERROR) {\n      loading = false;\n    } else {\n      if (imageState == ImageState.IDLE) {\n        imageStyle.load();\n      }\n    }\n    if (loading) {\n      loadingPromises.push(imageStyle.ready());\n    }\n  }\n  const fillStyle = style.getFill();\n  if (fillStyle && fillStyle.loading()) {\n    loadingPromises.push(fillStyle.ready());\n  }\n  const loading = loadingPromises.length > 0;\n  if (loading) {\n    Promise.all(loadingPromises).then(() => listener(null));\n  }\n  renderFeatureInternal(\n    replayGroup,\n    feature,\n    style,\n    squaredTolerance,\n    transform,\n    declutter,\n    index,\n  );\n\n  return loading;\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} replayGroup Replay group.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {import(\"../proj.js\").TransformFunction} [transform] Optional transform function.\n * @param {boolean} [declutter] Enable decluttering.\n * @param {number} [index] Render order index..\n */\nfunction renderFeatureInternal(\n  replayGroup,\n  feature,\n  style,\n  squaredTolerance,\n  transform,\n  declutter,\n  index,\n) {\n  const geometry = style.getGeometryFunction()(feature);\n  if (!geometry) {\n    return;\n  }\n  const simplifiedGeometry = geometry.simplifyTransformed(\n    squaredTolerance,\n    transform,\n  );\n  const renderer = style.getRenderer();\n  if (renderer) {\n    renderGeometry(replayGroup, simplifiedGeometry, style, feature, index);\n  } else {\n    const geometryRenderer = GEOMETRY_RENDERERS[simplifiedGeometry.getType()];\n    geometryRenderer(\n      replayGroup,\n      simplifiedGeometry,\n      style,\n      feature,\n      index,\n      declutter,\n    );\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} replayGroup Replay group.\n * @param {import(\"../geom/Geometry.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {number} [index] Render order index.\n */\nfunction renderGeometry(replayGroup, geometry, style, feature, index) {\n  if (geometry.getType() == 'GeometryCollection') {\n    const geometries =\n      /** @type {import(\"../geom/GeometryCollection.js\").default} */ (\n        geometry\n      ).getGeometries();\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      renderGeometry(replayGroup, geometries[i], style, feature, index);\n    }\n    return;\n  }\n  const replay = replayGroup.getBuilder(style.getZIndex(), 'Default');\n  replay.drawCustom(\n    /** @type {import(\"../geom/SimpleGeometry.js\").default} */ (geometry),\n    feature,\n    style.getRenderer(),\n    style.getHitDetectionRenderer(),\n    index,\n  );\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} replayGroup Replay group.\n * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [declutterBuilderGroup] Builder for decluttering.\n * @param {number} [index] Render order index.\n */\nfunction renderGeometryCollectionGeometry(\n  replayGroup,\n  geometry,\n  style,\n  feature,\n  declutterBuilderGroup,\n  index,\n) {\n  const geometries = geometry.getGeometriesArray();\n  let i, ii;\n  for (i = 0, ii = geometries.length; i < ii; ++i) {\n    const geometryRenderer = GEOMETRY_RENDERERS[geometries[i].getType()];\n    geometryRenderer(\n      replayGroup,\n      geometries[i],\n      style,\n      feature,\n      declutterBuilderGroup,\n      index,\n    );\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/LineString.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {number} [index] Render order index.\n */\nfunction renderLineStringGeometry(\n  builderGroup,\n  geometry,\n  style,\n  feature,\n  index,\n) {\n  const strokeStyle = style.getStroke();\n  if (strokeStyle) {\n    const lineStringReplay = builderGroup.getBuilder(\n      style.getZIndex(),\n      'LineString',\n    );\n    lineStringReplay.setFillStrokeStyle(null, strokeStyle);\n    lineStringReplay.drawLineString(geometry, feature, index);\n  }\n  const textStyle = style.getText();\n  if (textStyle && textStyle.getText()) {\n    const textReplay = builderGroup.getBuilder(style.getZIndex(), 'Text');\n    textReplay.setTextStyle(textStyle);\n    textReplay.drawText(geometry, feature, index);\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/MultiLineString.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {number} [index] Render order index.\n */\nfunction renderMultiLineStringGeometry(\n  builderGroup,\n  geometry,\n  style,\n  feature,\n  index,\n) {\n  const strokeStyle = style.getStroke();\n  if (strokeStyle) {\n    const lineStringReplay = builderGroup.getBuilder(\n      style.getZIndex(),\n      'LineString',\n    );\n    lineStringReplay.setFillStrokeStyle(null, strokeStyle);\n    lineStringReplay.drawMultiLineString(geometry, feature, index);\n  }\n  const textStyle = style.getText();\n  if (textStyle && textStyle.getText()) {\n    const textReplay = builderGroup.getBuilder(style.getZIndex(), 'Text');\n    textReplay.setTextStyle(textStyle);\n    textReplay.drawText(geometry, feature, index);\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {number} [index] Render order index.\n */\nfunction renderMultiPolygonGeometry(\n  builderGroup,\n  geometry,\n  style,\n  feature,\n  index,\n) {\n  const fillStyle = style.getFill();\n  const strokeStyle = style.getStroke();\n  if (strokeStyle || fillStyle) {\n    const polygonReplay = builderGroup.getBuilder(style.getZIndex(), 'Polygon');\n    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);\n    polygonReplay.drawMultiPolygon(geometry, feature, index);\n  }\n  const textStyle = style.getText();\n  if (textStyle && textStyle.getText()) {\n    const textReplay = builderGroup.getBuilder(style.getZIndex(), 'Text');\n    textReplay.setTextStyle(textStyle);\n    textReplay.drawText(geometry, feature, index);\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/Point.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {number} [index] Render order index.\n * @param {boolean} [declutter] Enable decluttering.\n */\nfunction renderPointGeometry(\n  builderGroup,\n  geometry,\n  style,\n  feature,\n  index,\n  declutter,\n) {\n  const imageStyle = style.getImage();\n  const textStyle = style.getText();\n  const hasText = textStyle && textStyle.getText();\n  /** @type {import(\"../render/canvas.js\").DeclutterImageWithText} */\n  const declutterImageWithText =\n    declutter && imageStyle && hasText ? {} : undefined;\n  if (imageStyle) {\n    if (imageStyle.getImageState() != ImageState.LOADED) {\n      return;\n    }\n    const imageReplay = builderGroup.getBuilder(style.getZIndex(), 'Image');\n    imageReplay.setImageStyle(imageStyle, declutterImageWithText);\n    imageReplay.drawPoint(geometry, feature, index);\n  }\n  if (hasText) {\n    const textReplay = builderGroup.getBuilder(style.getZIndex(), 'Text');\n    textReplay.setTextStyle(textStyle, declutterImageWithText);\n    textReplay.drawText(geometry, feature, index);\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/MultiPoint.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {number} [index] Render order index.\n * @param {boolean} [declutter] Enable decluttering.\n */\nfunction renderMultiPointGeometry(\n  builderGroup,\n  geometry,\n  style,\n  feature,\n  index,\n  declutter,\n) {\n  const imageStyle = style.getImage();\n  const hasImage = imageStyle && imageStyle.getOpacity() !== 0;\n  const textStyle = style.getText();\n  const hasText = textStyle && textStyle.getText();\n  /** @type {import(\"../render/canvas.js\").DeclutterImageWithText} */\n  const declutterImageWithText =\n    declutter && hasImage && hasText ? {} : undefined;\n  if (hasImage) {\n    if (imageStyle.getImageState() != ImageState.LOADED) {\n      return;\n    }\n    const imageReplay = builderGroup.getBuilder(style.getZIndex(), 'Image');\n    imageReplay.setImageStyle(imageStyle, declutterImageWithText);\n    imageReplay.drawMultiPoint(geometry, feature, index);\n  }\n  if (hasText) {\n    const textReplay = builderGroup.getBuilder(style.getZIndex(), 'Text');\n    textReplay.setTextStyle(textStyle, declutterImageWithText);\n    textReplay.drawText(geometry, feature, index);\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/Polygon.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {number} [index] Render order index.\n */\nfunction renderPolygonGeometry(builderGroup, geometry, style, feature, index) {\n  const fillStyle = style.getFill();\n  const strokeStyle = style.getStroke();\n  if (fillStyle || strokeStyle) {\n    const polygonReplay = builderGroup.getBuilder(style.getZIndex(), 'Polygon');\n    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);\n    polygonReplay.drawPolygon(geometry, feature, index);\n  }\n  const textStyle = style.getText();\n  if (textStyle && textStyle.getText()) {\n    const textReplay = builderGroup.getBuilder(style.getZIndex(), 'Text');\n    textReplay.setTextStyle(textStyle);\n    textReplay.drawText(geometry, feature, index);\n  }\n}\n","import {getWidth} from '../../extent.js';\n\n/**\n * Compute world params\n * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n * @param {any} layer The layer\n * @return {Array<number>} The world start, end and width.\n */\nexport function getWorldParameters(frameState, layer) {\n  const projection = frameState.viewState.projection;\n\n  const vectorSource = layer.getSource();\n  const multiWorld = vectorSource.getWrapX() && projection.canWrapX();\n  const projectionExtent = projection.getExtent();\n\n  const extent = frameState.extent;\n  const worldWidth = multiWorld ? getWidth(projectionExtent) : null;\n  const endWorld = multiWorld\n    ? Math.ceil((extent[2] - projectionExtent[2]) / worldWidth) + 1\n    : 1;\n\n  const startWorld = multiWorld\n    ? Math.floor((extent[0] - projectionExtent[0]) / worldWidth)\n    : 0;\n\n  return [startWorld, endWorld, worldWidth];\n}\n","/**\n * @module ol/renderer/webgl/PointsLayer\n */\nimport BaseVector from '../../layer/BaseVector.js';\nimport VectorEventType from '../../source/VectorEventType.js';\nimport ViewHint from '../../ViewHint.js';\nimport WebGLArrayBuffer from '../../webgl/Buffer.js';\nimport WebGLLayerRenderer from './Layer.js';\nimport WebGLRenderTarget from '../../webgl/RenderTarget.js';\nimport {ARRAY_BUFFER, DYNAMIC_DRAW, ELEMENT_ARRAY_BUFFER} from '../../webgl.js';\nimport {AttributeType, DefaultUniform} from '../../webgl/Helper.js';\nimport {WebGLWorkerMessageType} from '../../render/webgl/constants.js';\nimport {\n  apply as applyTransform,\n  create as createTransform,\n  makeInverse as makeInverseTransform,\n  multiply as multiplyTransform,\n  translate as translateTransform,\n} from '../../transform.js';\nimport {assert} from '../../asserts.js';\nimport {buffer, createEmpty, equals} from '../../extent.js';\nimport {colorDecodeId, colorEncodeId} from '../../render/webgl/utils.js';\nimport {create as createWebGLWorker} from '../../worker/webgl.js';\nimport {fromUserCoordinate, getUserProjection} from '../../proj.js';\nimport {getUid} from '../../util.js';\nimport {getWorldParameters} from './worldUtil.js';\nimport {listen, unlistenByKey} from '../../events.js';\n\n/**\n * @typedef {Object} CustomAttribute A description of a custom attribute to be passed on to the GPU, with a value different\n * for each feature.\n * @property {string} name Attribute name.\n * @property {function(import(\"../../Feature\").default, Object<string, *>):number} callback This callback computes the numerical value of the\n * attribute for a given feature (properties are available as 2nd arg for quicker access).\n */\n\n/**\n * @typedef {Object} FeatureCacheItem Object that holds a reference to a feature, its geometry and properties. Used to optimize\n * rebuildBuffers by accessing these objects quicker.\n * @property {import(\"../../Feature\").default} feature Feature\n * @property {Object<string, *>} properties Feature properties\n * @property {import(\"../../geom\").Geometry} geometry Feature geometry\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the canvas element.\n * @property {Array<CustomAttribute>} [attributes] These attributes will be read from the features in the source and then\n * passed to the GPU. The `name` property of each attribute will serve as its identifier:\n *  * In the vertex shader as an `attribute` by prefixing it with `a_`\n *  * In the fragment shader as a `varying` by prefixing it with `v_`\n * Please note that these can only be numerical values.\n * @property {string} vertexShader Vertex shader source, mandatory.\n * @property {string} fragmentShader Fragment shader source, mandatory.\n * @property {boolean} [hitDetectionEnabled] Whether shader is hit detection aware.\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process steps\n * Please note that `u_texture` is reserved for the main texture slot and `u_opacity` is reserved for the layer opacity.\n * @property {Array<import(\"./Layer\").PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n\n/**\n * @classdesc\n * WebGL vector renderer optimized for points.\n * All features will be rendered as quads (two triangles forming a square). New data will be flushed to the GPU\n * every time the vector source changes.\n *\n * You need to provide vertex and fragment shaders for rendering. This can be done using\n * {@link module:ol/webgl/ShaderBuilder~ShaderBuilder} utilities. These shaders shall expect a `a_position` attribute\n * containing the screen-space projected center of the quad, as well as a `a_index` attribute\n * whose value (0, 1, 2 or 3) indicates which quad vertex is currently getting processed (see structure below).\n *\n * To include variable attributes in the shaders, you need to declare them using the `attributes` property of\n * the options object like so:\n * ```js\n * new WebGLPointsLayerRenderer(layer, {\n *   attributes: [\n *     {\n *       name: 'size',\n *       callback: function(feature) {\n *         // compute something with the feature\n *       }\n *     },\n *     {\n *       name: 'weight',\n *       callback: function(feature) {\n *         // compute something with the feature\n *       }\n *     },\n *   ],\n *   vertexShader:\n *     // shader using attribute a_weight and a_size\n *   fragmentShader:\n *     // shader using varying v_weight and v_size\n * ```\n *\n * To enable hit detection, you must as well provide dedicated shaders using the `hitVertexShader`\n * and `hitFragmentShader` properties. These shall expect the `a_hitColor` attribute to contain\n * the final color that will have to be output for hit detection to work.\n *\n * The following uniform is used for the main texture: `u_texture`.\n * The following uniform is used for the layer opacity: `u_opacity`.\n *\n * Please note that the main shader output should have premultiplied alpha, otherwise visual anomalies may occur.\n *\n * Points are rendered as quads with the following structure:\n *\n * ```\n *   (u0, v1)      (u1, v1)\n *  [3]----------[2]\n *   |`           |\n *   |  `         |\n *   |    `       |\n *   |      `     |\n *   |        `   |\n *   |          ` |\n *  [0]----------[1]\n *   (u0, v0)      (u1, v0)\n *  ```\n *\n * This uses {@link module:ol/webgl/Helper~WebGLHelper} internally.\n *\n * @api\n */\nclass WebGLPointsLayerRenderer extends WebGLLayerRenderer {\n  /**\n   * @param {import(\"../../layer/Layer.js\").default} layer Layer.\n   * @param {Options} options Options.\n   */\n  constructor(layer, options) {\n    const uniforms = options.uniforms || {};\n    const projectionMatrixTransform = createTransform();\n    uniforms[DefaultUniform.PROJECTION_MATRIX] = projectionMatrixTransform;\n\n    super(layer, {\n      uniforms: uniforms,\n      postProcesses: options.postProcesses,\n    });\n\n    this.sourceRevision_ = -1;\n\n    this.verticesBuffer_ = new WebGLArrayBuffer(ARRAY_BUFFER, DYNAMIC_DRAW);\n    this.indicesBuffer_ = new WebGLArrayBuffer(\n      ELEMENT_ARRAY_BUFFER,\n      DYNAMIC_DRAW,\n    );\n\n    /**\n     * @private\n     */\n    this.vertexShader_ = options.vertexShader;\n\n    /**\n     * @private\n     */\n    this.fragmentShader_ = options.fragmentShader;\n\n    /**\n     * @type {WebGLProgram}\n     * @private\n     */\n    this.program_;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hitDetectionEnabled_ = options.hitDetectionEnabled ?? true;\n\n    const customAttributes = options.attributes\n      ? options.attributes.map(function (attribute) {\n          return {\n            name: 'a_prop_' + attribute.name,\n            size: 1,\n            type: AttributeType.FLOAT,\n          };\n        })\n      : [];\n\n    /**\n     * A list of attributes used by the renderer. By default only the position and\n     * index of the vertex (0 to 3) are required.\n     * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n     */\n    this.attributes = [\n      {\n        name: 'a_position',\n        size: 2,\n        type: AttributeType.FLOAT,\n      },\n      {\n        name: 'a_index',\n        size: 1,\n        type: AttributeType.FLOAT,\n      },\n    ];\n\n    if (this.hitDetectionEnabled_) {\n      this.attributes.push({\n        name: 'a_prop_hitColor',\n        size: 4,\n        type: AttributeType.FLOAT,\n      });\n      this.attributes.push({\n        name: 'a_featureUid',\n        size: 1,\n        type: AttributeType.FLOAT,\n      });\n    }\n    this.attributes.push(...customAttributes);\n\n    this.customAttributes = options.attributes ? options.attributes : [];\n\n    this.previousExtent_ = createEmpty();\n\n    /**\n     * This transform is updated on every frame and is the composition of:\n     * - invert of the world->screen transform that was used when rebuilding buffers (see `this.renderTransform_`)\n     * - current world->screen transform\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.currentTransform_ = projectionMatrixTransform;\n\n    /**\n     * This transform is updated when buffers are rebuilt and converts world space coordinates to screen space\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.renderTransform_ = createTransform();\n\n    /**\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.invertRenderTransform_ = createTransform();\n\n    /**\n     * @type {Float32Array}\n     * @private\n     */\n    this.renderInstructions_ = new Float32Array(0);\n\n    /**\n     * @type {WebGLRenderTarget}\n     * @private\n     */\n    this.hitRenderTarget_;\n\n    /**\n     * Keep track of latest message sent to worker\n     * @type {number}\n     * @private\n     */\n    this.lastSentId = 0;\n\n    /**\n     * @private\n     */\n    this.worker_ = createWebGLWorker();\n\n    this.worker_.addEventListener(\n      'message',\n      /**\n       * @param {*} event Event.\n       */\n      (event) => {\n        const received = event.data;\n        if (received.type === WebGLWorkerMessageType.GENERATE_POINT_BUFFERS) {\n          const projectionTransform = received.projectionTransform;\n          this.verticesBuffer_.fromArrayBuffer(received.vertexBuffer);\n          this.helper.flushBufferData(this.verticesBuffer_);\n          this.indicesBuffer_.fromArrayBuffer(received.indexBuffer);\n          this.helper.flushBufferData(this.indicesBuffer_);\n\n          this.renderTransform_ = projectionTransform;\n          makeInverseTransform(\n            this.invertRenderTransform_,\n            this.renderTransform_,\n          );\n          this.renderInstructions_ = new Float32Array(\n            event.data.renderInstructions,\n          );\n          if (received.id === this.lastSentId) {\n            this.ready = true;\n          }\n          this.getLayer().changed();\n        }\n      },\n    );\n\n    /**\n     * This object will be updated when the source changes. Key is uid.\n     * @type {Object<string, FeatureCacheItem>}\n     * @private\n     */\n    this.featureCache_ = {};\n\n    /**\n     * Amount of features in the cache.\n     * @type {number}\n     * @private\n     */\n    this.featureCount_ = 0;\n\n    const source = this.getLayer().getSource();\n    this.sourceListenKeys_ = [\n      listen(\n        source,\n        VectorEventType.ADDFEATURE,\n        this.handleSourceFeatureAdded_,\n        this,\n      ),\n      listen(\n        source,\n        VectorEventType.CHANGEFEATURE,\n        this.handleSourceFeatureChanged_,\n        this,\n      ),\n      listen(\n        source,\n        VectorEventType.REMOVEFEATURE,\n        this.handleSourceFeatureDelete_,\n        this,\n      ),\n      listen(\n        source,\n        VectorEventType.CLEAR,\n        this.handleSourceFeatureClear_,\n        this,\n      ),\n    ];\n    source.forEachFeature((feature) => {\n      this.featureCache_[getUid(feature)] = {\n        feature: feature,\n        properties: feature.getProperties(),\n        geometry: feature.getGeometry(),\n      };\n      this.featureCount_++;\n    });\n  }\n\n  afterHelperCreated() {\n    this.program_ = this.helper.getProgram(\n      this.fragmentShader_,\n      this.vertexShader_,\n    );\n\n    if (this.hitDetectionEnabled_) {\n      this.hitRenderTarget_ = new WebGLRenderTarget(this.helper);\n    }\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureAdded_(event) {\n    const feature = event.feature;\n    this.featureCache_[getUid(feature)] = {\n      feature: feature,\n      properties: feature.getProperties(),\n      geometry: feature.getGeometry(),\n    };\n    this.featureCount_++;\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureChanged_(event) {\n    const feature = event.feature;\n    this.featureCache_[getUid(feature)] = {\n      feature: feature,\n      properties: feature.getProperties(),\n      geometry: feature.getGeometry(),\n    };\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureDelete_(event) {\n    const feature = event.feature;\n    delete this.featureCache_[getUid(feature)];\n    this.featureCount_--;\n  }\n\n  /**\n   * @private\n   */\n  handleSourceFeatureClear_() {\n    this.featureCache_ = {};\n    this.featureCount_ = 0;\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState) {\n    const gl = this.helper.getGL();\n    this.preRender(gl, frameState);\n    const [startWorld, endWorld, worldWidth] = getWorldParameters(\n      frameState,\n      this.getLayer(),\n    );\n\n    // draw the normal canvas\n    this.renderWorlds(frameState, false, startWorld, endWorld, worldWidth);\n    this.helper.finalizeDraw(\n      frameState,\n      this.dispatchPreComposeEvent,\n      this.dispatchPostComposeEvent,\n    );\n\n    if (this.hitDetectionEnabled_) {\n      // draw the hit buffer\n      this.renderWorlds(frameState, true, startWorld, endWorld, worldWidth);\n      this.hitRenderTarget_.clearCachedData();\n    }\n\n    this.postRender(gl, frameState);\n\n    const canvas = this.helper.getCanvas();\n    return canvas;\n  }\n\n  /**\n   * Determine whether renderFrame should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrameInternal(frameState) {\n    const layer = this.getLayer();\n    const vectorSource = layer.getSource();\n    const viewState = frameState.viewState;\n    const viewNotMoving =\n      !frameState.viewHints[ViewHint.ANIMATING] &&\n      !frameState.viewHints[ViewHint.INTERACTING];\n    const extentChanged = !equals(this.previousExtent_, frameState.extent);\n    const sourceChanged = this.sourceRevision_ < vectorSource.getRevision();\n\n    if (sourceChanged) {\n      this.sourceRevision_ = vectorSource.getRevision();\n    }\n\n    if (viewNotMoving && (extentChanged || sourceChanged)) {\n      const projection = viewState.projection;\n      const resolution = viewState.resolution;\n\n      const renderBuffer =\n        layer instanceof BaseVector ? layer.getRenderBuffer() : 0;\n      const extent = buffer(frameState.extent, renderBuffer * resolution);\n      vectorSource.loadFeatures(extent, resolution, projection);\n\n      this.rebuildBuffers_(frameState);\n      this.previousExtent_ = frameState.extent.slice();\n    }\n\n    this.helper.useProgram(this.program_, frameState);\n    this.helper.prepareDraw(frameState);\n\n    // write new data\n    this.helper.bindBuffer(this.verticesBuffer_);\n    this.helper.bindBuffer(this.indicesBuffer_);\n    this.helper.enableAttributes(this.attributes);\n\n    return true;\n  }\n\n  /**\n   * Rebuild internal webgl buffers based on current view extent; costly, should not be called too much\n   * @param {import(\"../../Map\").FrameState} frameState Frame state.\n   * @private\n   */\n  rebuildBuffers_(frameState) {\n    // saves the projection transform for the current frame state\n    const projectionTransform = createTransform();\n    this.helper.makeProjectionTransform(frameState, projectionTransform);\n\n    const userProjection = getUserProjection();\n\n    const baseInstructionLength = this.hitDetectionEnabled_ ? 7 : 2; // see below\n    const singleInstructionLength =\n      baseInstructionLength + this.customAttributes.length;\n    const totalSize = singleInstructionLength * this.featureCount_;\n    if (\n      !this.renderInstructions_ ||\n      this.renderInstructions_.length !== totalSize\n    ) {\n      this.renderInstructions_ = new Float32Array(totalSize);\n    }\n\n    // loop on features to fill the buffer\n    let featureCache, geometry;\n    const tmpCoords = [];\n    const tmpColor = [];\n    let idx = -1;\n    for (const featureUid in this.featureCache_) {\n      featureCache = this.featureCache_[featureUid];\n      geometry = /** @type {import(\"../../geom\").Point} */ (\n        featureCache.geometry\n      );\n      if (!geometry || geometry.getType() !== 'Point') {\n        continue;\n      }\n      if (userProjection) {\n        const userCoords = fromUserCoordinate(\n          geometry.getFlatCoordinates(),\n          frameState.viewState.projection,\n        );\n        tmpCoords[0] = userCoords[0];\n        tmpCoords[1] = userCoords[1];\n      } else {\n        tmpCoords[0] = geometry.getFlatCoordinates()[0];\n        tmpCoords[1] = geometry.getFlatCoordinates()[1];\n      }\n      applyTransform(projectionTransform, tmpCoords);\n\n      this.renderInstructions_[++idx] = tmpCoords[0];\n      this.renderInstructions_[++idx] = tmpCoords[1];\n\n      // for hit detection, the feature uid is saved in the opacity value\n      // and the index of the opacity value is encoded in the color values\n      if (this.hitDetectionEnabled_) {\n        const hitColor = colorEncodeId(idx + 5, tmpColor);\n        this.renderInstructions_[++idx] = hitColor[0];\n        this.renderInstructions_[++idx] = hitColor[1];\n        this.renderInstructions_[++idx] = hitColor[2];\n        this.renderInstructions_[++idx] = hitColor[3];\n        this.renderInstructions_[++idx] = Number(featureUid);\n      }\n\n      // pushing custom attributes\n      for (let j = 0; j < this.customAttributes.length; j++) {\n        const value = this.customAttributes[j].callback(\n          featureCache.feature,\n          featureCache.properties,\n        );\n        this.renderInstructions_[++idx] = value;\n      }\n    }\n\n    /** @type {import('../../render/webgl/constants.js').WebGLWorkerGenerateBuffersMessage} */\n    const message = {\n      id: ++this.lastSentId,\n      type: WebGLWorkerMessageType.GENERATE_POINT_BUFFERS,\n      renderInstructions: this.renderInstructions_.buffer,\n      customAttributesSize: singleInstructionLength - 2,\n    };\n    // additional properties will be sent back as-is by the worker\n    message['projectionTransform'] = projectionTransform;\n    this.ready = false;\n    this.worker_.postMessage(message, [this.renderInstructions_.buffer]);\n    this.renderInstructions_ = null;\n  }\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches,\n  ) {\n    assert(\n      this.hitDetectionEnabled_,\n      '`forEachFeatureAtCoordinate` cannot be used on a WebGL layer if the hit detection logic has been disabled using the `disableHitDetection: true` option.',\n    );\n    if (!this.renderInstructions_ || !this.hitDetectionEnabled_) {\n      return undefined;\n    }\n\n    const pixel = applyTransform(\n      frameState.coordinateToPixelTransform,\n      coordinate.slice(),\n    );\n\n    const data = this.hitRenderTarget_.readPixel(pixel[0] / 2, pixel[1] / 2);\n    const color = [data[0] / 255, data[1] / 255, data[2] / 255, data[3] / 255];\n    const index = colorDecodeId(color);\n    const opacity = this.renderInstructions_[index];\n    const uid = Math.floor(opacity).toString();\n\n    const source = this.getLayer().getSource();\n    const feature = source.getFeatureByUid(uid);\n    if (feature) {\n      return callback(feature, this.getLayer(), null);\n    }\n    return undefined;\n  }\n\n  /**\n   * Render the world, either to the main framebuffer or to the hit framebuffer\n   * @param {import(\"../../Map.js\").FrameState} frameState current frame state\n   * @param {boolean} forHitDetection whether the rendering is for hit detection\n   * @param {number} startWorld the world to render in the first iteration\n   * @param {number} endWorld the last world to render\n   * @param {number} worldWidth the width of the worlds being rendered\n   */\n  renderWorlds(frameState, forHitDetection, startWorld, endWorld, worldWidth) {\n    let world = startWorld;\n\n    this.helper.useProgram(this.program_, frameState);\n\n    if (forHitDetection) {\n      this.hitRenderTarget_.setSize([\n        Math.floor(frameState.size[0] / 2),\n        Math.floor(frameState.size[1] / 2),\n      ]);\n      this.helper.prepareDrawToRenderTarget(\n        frameState,\n        this.hitRenderTarget_,\n        true,\n      );\n    }\n\n    this.helper.bindBuffer(this.verticesBuffer_);\n    this.helper.bindBuffer(this.indicesBuffer_);\n    this.helper.enableAttributes(this.attributes);\n\n    do {\n      this.helper.makeProjectionTransform(frameState, this.currentTransform_);\n      translateTransform(this.currentTransform_, world * worldWidth, 0);\n      multiplyTransform(this.currentTransform_, this.invertRenderTransform_);\n      this.helper.applyUniforms(frameState);\n      this.helper.applyHitDetectionUniform(forHitDetection);\n      const renderCount = this.indicesBuffer_.getSize();\n      this.helper.drawElements(0, renderCount);\n    } while (++world < endWorld);\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    this.worker_.terminate();\n    this.layer_ = null;\n    this.sourceListenKeys_.forEach(function (key) {\n      unlistenByKey(key);\n    });\n    this.sourceListenKeys_ = null;\n    super.disposeInternal();\n  }\n\n  renderDeclutter() {}\n}\n\nexport default WebGLPointsLayerRenderer;\n","/**\n * @module ol/renderer/canvas/Layer\n */\nimport LayerRenderer from '../Layer.js';\nimport RenderEvent from '../../render/Event.js';\nimport RenderEventType from '../../render/EventType.js';\nimport ZIndexContext from '../../render/canvas/ZIndexContext.js';\nimport {\n  apply as applyTransform,\n  compose as composeTransform,\n  create as createTransform,\n  makeInverse,\n  toString as toTransformString,\n} from '../../transform.js';\nimport {asArray} from '../../color.js';\nimport {createCanvasContext2D} from '../../dom.js';\nimport {equals} from '../../array.js';\nimport {\n  getBottomLeft,\n  getBottomRight,\n  getHeight,\n  getTopLeft,\n  getTopRight,\n  getWidth,\n} from '../../extent.js';\n\n/**\n * @type {Array<HTMLCanvasElement>}\n */\nexport const canvasPool = [];\n\n/**\n * @type {CanvasRenderingContext2D}\n */\nlet pixelContext = null;\n\nfunction createPixelContext() {\n  pixelContext = createCanvasContext2D(1, 1, undefined, {\n    willReadFrequently: true,\n  });\n}\n\n/**\n * @abstract\n * @template {import(\"../../layer/Layer.js\").default} LayerType\n * @extends {LayerRenderer<LayerType>}\n */\nclass CanvasLayerRenderer extends LayerRenderer {\n  /**\n   * @param {LayerType} layer Layer.\n   */\n  constructor(layer) {\n    super(layer);\n\n    /**\n     * @protected\n     * @type {HTMLElement}\n     */\n    this.container = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedResolution;\n\n    /**\n     * A temporary transform.  The values in this transform should only be used in a\n     * function that sets the values.\n     * @protected\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.tempTransform = createTransform();\n\n    /**\n     * The transform for rendered pixels to viewport CSS pixels.  This transform must\n     * be set when rendering a frame and may be used by other functions after rendering.\n     * @protected\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.pixelTransform = createTransform();\n\n    /**\n     * The transform for viewport CSS pixels to rendered pixels.  This transform must\n     * be set when rendering a frame and may be used by other functions after rendering.\n     * @protected\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.inversePixelTransform = createTransform();\n\n    /**\n     * @type {CanvasRenderingContext2D}\n     */\n    this.context = null;\n\n    /**\n     * @private\n     * @type {ZIndexContext}\n     */\n    this.deferredContext_ = null;\n\n    /**\n     * @type {boolean}\n     */\n    this.containerReused = false;\n\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n    this.pixelContext_ = null;\n\n    /**\n     * @protected\n     * @type {import(\"../../Map.js\").FrameState|null}\n     */\n    this.frameState = null;\n  }\n\n  /**\n   * @param {import('../../DataTile.js').ImageLike} image Image.\n   * @param {number} col The column index.\n   * @param {number} row The row index.\n   * @return {Uint8ClampedArray|null} The image data.\n   */\n  getImageData(image, col, row) {\n    if (!pixelContext) {\n      createPixelContext();\n    }\n    pixelContext.clearRect(0, 0, 1, 1);\n\n    let data;\n    try {\n      pixelContext.drawImage(image, col, row, 1, 1, 0, 0, 1, 1);\n      data = pixelContext.getImageData(0, 0, 1, 1).data;\n    } catch (err) {\n      pixelContext = null;\n      return null;\n    }\n    return data;\n  }\n\n  /**\n   * @param {import('../../Map.js').FrameState} frameState Frame state.\n   * @return {string} Background color.\n   */\n  getBackground(frameState) {\n    const layer = this.getLayer();\n    let background = layer.getBackground();\n    if (typeof background === 'function') {\n      background = background(frameState.viewState.resolution);\n    }\n    return background || undefined;\n  }\n\n  /**\n   * Get a rendering container from an existing target, if compatible.\n   * @param {HTMLElement} target Potential render target.\n   * @param {string} transform CSS Transform.\n   * @param {string} [backgroundColor] Background color.\n   */\n  useContainer(target, transform, backgroundColor) {\n    const layerClassName = this.getLayer().getClassName();\n    let container, context;\n    if (\n      target &&\n      target.className === layerClassName &&\n      (!backgroundColor ||\n        (target &&\n          target.style.backgroundColor &&\n          equals(\n            asArray(target.style.backgroundColor),\n            asArray(backgroundColor),\n          )))\n    ) {\n      const canvas = target.firstElementChild;\n      if (canvas instanceof HTMLCanvasElement) {\n        context = canvas.getContext('2d');\n      }\n    }\n    if (context && context.canvas.style.transform === transform) {\n      // Container of the previous layer renderer can be used.\n      this.container = target;\n      this.context = context;\n      this.containerReused = true;\n    } else if (this.containerReused) {\n      // Previously reused container cannot be used any more.\n      this.container = null;\n      this.context = null;\n      this.containerReused = false;\n    } else if (this.container) {\n      this.container.style.backgroundColor = null;\n    }\n    if (!this.container) {\n      container = document.createElement('div');\n      container.className = layerClassName;\n      let style = container.style;\n      style.position = 'absolute';\n      style.width = '100%';\n      style.height = '100%';\n      context = createCanvasContext2D();\n      const canvas = context.canvas;\n      container.appendChild(canvas);\n      style = canvas.style;\n      style.position = 'absolute';\n      style.left = '0';\n      style.transformOrigin = 'top left';\n      this.container = container;\n      this.context = context;\n    }\n    if (\n      !this.containerReused &&\n      backgroundColor &&\n      !this.container.style.backgroundColor\n    ) {\n      this.container.style.backgroundColor = backgroundColor;\n    }\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../extent.js\").Extent} extent Clip extent.\n   * @protected\n   */\n  clipUnrotated(context, frameState, extent) {\n    const topLeft = getTopLeft(extent);\n    const topRight = getTopRight(extent);\n    const bottomRight = getBottomRight(extent);\n    const bottomLeft = getBottomLeft(extent);\n\n    applyTransform(frameState.coordinateToPixelTransform, topLeft);\n    applyTransform(frameState.coordinateToPixelTransform, topRight);\n    applyTransform(frameState.coordinateToPixelTransform, bottomRight);\n    applyTransform(frameState.coordinateToPixelTransform, bottomLeft);\n\n    const inverted = this.inversePixelTransform;\n    applyTransform(inverted, topLeft);\n    applyTransform(inverted, topRight);\n    applyTransform(inverted, bottomRight);\n    applyTransform(inverted, bottomLeft);\n\n    context.save();\n    context.beginPath();\n    context.moveTo(Math.round(topLeft[0]), Math.round(topLeft[1]));\n    context.lineTo(Math.round(topRight[0]), Math.round(topRight[1]));\n    context.lineTo(Math.round(bottomRight[0]), Math.round(bottomRight[1]));\n    context.lineTo(Math.round(bottomLeft[0]), Math.round(bottomLeft[1]));\n    context.clip();\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @protected\n   */\n  prepareContainer(frameState, target) {\n    const extent = frameState.extent;\n    const resolution = frameState.viewState.resolution;\n    const rotation = frameState.viewState.rotation;\n    const pixelRatio = frameState.pixelRatio;\n    const width = Math.round((getWidth(extent) / resolution) * pixelRatio);\n    const height = Math.round((getHeight(extent) / resolution) * pixelRatio);\n    // set forward and inverse pixel transforms\n    composeTransform(\n      this.pixelTransform,\n      frameState.size[0] / 2,\n      frameState.size[1] / 2,\n      1 / pixelRatio,\n      1 / pixelRatio,\n      rotation,\n      -width / 2,\n      -height / 2,\n    );\n    makeInverse(this.inversePixelTransform, this.pixelTransform);\n\n    const canvasTransform = toTransformString(this.pixelTransform);\n    this.useContainer(target, canvasTransform, this.getBackground(frameState));\n\n    if (!this.containerReused) {\n      const canvas = this.context.canvas;\n      if (canvas.width != width || canvas.height != height) {\n        canvas.width = width;\n        canvas.height = height;\n      } else {\n        this.context.clearRect(0, 0, width, height);\n      }\n      if (canvasTransform !== canvas.style.transform) {\n        canvas.style.transform = canvasTransform;\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../../render/EventType.js\").default} type Event type.\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @private\n   */\n  dispatchRenderEvent_(type, context, frameState) {\n    const layer = this.getLayer();\n    if (layer.hasListener(type)) {\n      const event = new RenderEvent(\n        type,\n        this.inversePixelTransform,\n        frameState,\n        context,\n      );\n      layer.dispatchEvent(event);\n    }\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  preRender(context, frameState) {\n    this.frameState = frameState;\n    if (frameState.declutter) {\n      return;\n    }\n    this.dispatchRenderEvent_(RenderEventType.PRERENDER, context, frameState);\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  postRender(context, frameState) {\n    if (frameState.declutter) {\n      return;\n    }\n    this.dispatchRenderEvent_(RenderEventType.POSTRENDER, context, frameState);\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   */\n  renderDeferredInternal(frameState) {}\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {import('../../render/canvas/ZIndexContext.js').ZIndexContextProxy} Context.\n   */\n  getRenderContext(frameState) {\n    if (frameState.declutter && !this.deferredContext_) {\n      this.deferredContext_ = new ZIndexContext();\n    }\n    return frameState.declutter\n      ? this.deferredContext_.getContext()\n      : this.context;\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @override\n   */\n  renderDeferred(frameState) {\n    if (!frameState.declutter) {\n      return;\n    }\n    this.dispatchRenderEvent_(\n      RenderEventType.PRERENDER,\n      this.context,\n      frameState,\n    );\n    if (frameState.declutter && this.deferredContext_) {\n      this.deferredContext_.draw(this.context);\n      this.deferredContext_.clear();\n    }\n    this.renderDeferredInternal(frameState);\n    this.dispatchRenderEvent_(\n      RenderEventType.POSTRENDER,\n      this.context,\n      frameState,\n    );\n  }\n\n  /**\n   * Creates a transform for rendering to an element that will be rotated after rendering.\n   * @param {import(\"../../coordinate.js\").Coordinate} center Center.\n   * @param {number} resolution Resolution.\n   * @param {number} rotation Rotation.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {number} width Width of the rendered element (in pixels).\n   * @param {number} height Height of the rendered element (in pixels).\n   * @param {number} offsetX Offset on the x-axis in view coordinates.\n   * @protected\n   * @return {!import(\"../../transform.js\").Transform} Transform.\n   */\n  getRenderTransform(\n    center,\n    resolution,\n    rotation,\n    pixelRatio,\n    width,\n    height,\n    offsetX,\n  ) {\n    const dx1 = width / 2;\n    const dy1 = height / 2;\n    const sx = pixelRatio / resolution;\n    const sy = -sx;\n    const dx2 = -center[0] + offsetX;\n    const dy2 = -center[1];\n    return composeTransform(\n      this.tempTransform,\n      dx1,\n      dy1,\n      sx,\n      sy,\n      -rotation,\n      dx2,\n      dy2,\n    );\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    delete this.frameState;\n    super.disposeInternal();\n  }\n}\n\nexport default CanvasLayerRenderer;\n"],"names":["Uniforms","TILE_TRANSFORM","TRANSITION_ALPHA","DEPTH","RENDER_EXTENT","PATTERN_ORIGIN","RESOLUTION","ZOOM","GLOBAL_ALPHA","PROJECTION_MATRIX","SCREEN_TO_WORLD_MATRIX","empty","depthForZ","z","newTileRepresentationLookup","tileIds","Set","representationsByZ","lookupHasTile","tileRepresentationLookup","tile","has","addTileRepresentationToLookup","tileRepresentation","add","getRenderExtent","frameState","extent","layerState","layerStatesArray","layerIndex","fromUserExtent","viewState","projection","source","layer","getRenderSource","getWrapX","gridExtent","getTileGridForProjection","getExtent","getCacheKey","tileCoord","getKey","WebGLBaseTileLayerRenderer","constructor","tileLayer","options","super","uniforms","postProcesses","this","renderComplete","tileTransform_","tempMat4","tempTileRange_","TileRange","tempTileCoord_","tempSize_","cacheSize","undefined","tileRepresentationCache","LRUCache","projection_","reset","isDrawableTile_","getLayer","tileState","getState","useInterimTilesOnError","getUseInterimTilesOnError","TileState","LOADED","EMPTY","ERROR","prepareFrameInternal","clearCache","createTileRepresentation","enqueueTiles","initialZ","preload","tileSource","tileGrid","gutter","getGutterForProjection","tileSourceKey","wantedTiles","map","getMapInternal","minZ","Math","max","getMinZoom","getZForResolution","min","getMaxResolution","getView","getResolutionForZoom","getResolution","zDirection","tileRange","getTileRangeForExtentAndZ","tileResolution","x","minX","maxX","y","minY","maxY","cacheKey","containsKey","get","key","getTile","pixelRatio","setTile","interimTile","getInterimTile","grid","helper","set","tileQueueKey","IDLE","tileQueue","isKeyQueued","enqueue","getTileCoordCenter","beforeTilesRender","tilesWithAlpha","prepareDraw","beforeTilesMaskRender","renderTile","tileTransform","renderExtent","tileSize","tileOrigin","tileExtent","depth","alpha","renderTileMask","tileZ","drawTile_","alphaLookup","ready","tileCoordKey","getTileSize","getOrigin","getTileCoordExtent","animate","centerX","center","centerY","tileWidthWithGutter","tileHeightWithGutter","aspectRatio","centerI","centerJ","tileScale","resolution","tileCenterI","tileCenterJ","size","rotation","renderFrame","gl","getGL","preRender","getPreload","nextExtent","targetZ","nextResolution","setTimeout","uid","time","blend","getAlpha","endTransition","coveredByChildren","findAltTiles_","minZoom","parentZ","coveredByParent","zs","Object","keys","Number","sort","j","jj","length","finalizeDraw","dispatchPreComposeEvent","dispatchPostComposeEvent","canvas","getCanvas","canExpireCache","pop","dispose","postRenderFunction","updateCacheSize","expireCache","postRenderFunctions","push","postRender","altZ","getTileRangeForTileCoordAndZ","covered","loaded","forEach","clear","removeHelper","disposeInternal","TILE_TEXTURE_ARRAY","TEXTURE_PIXEL_WIDTH","TEXTURE_PIXEL_HEIGHT","TEXTURE_RESOLUTION","TEXTURE_ORIGIN_X","TEXTURE_ORIGIN_Y","Attributes","TEXTURE_COORD","attributeDescriptions","name","type","FLOAT","WebGLTileLayerRenderer","program_","vertexShader_","vertexShader","fragmentShader_","fragmentShader","indices_","fromArray","paletteTextures_","paletteTextures","paletteTexture","delete","getProgram","afterHelperCreated","flushBufferData","TileTexture","useProgram","tileTexture","bindBuffer","coords","enableAttributes","textureSlot","textures","uniformName","bindTexture","paletteIndex","texture","getTexture","setUniformMatrixValue","mat4","setUniformFloatValue","gutterExtent","setUniformFloatVec4","zoom","drawElements","getSize","getData","pixel","coordinate","pixelToCoordinateTransform","slice","layerExtent","sources","getSources","i","tileTextureCache","getTileCoordForCoordAndZ","col","row","getPixelData","deleteProgram","deleteBuffer","CanvasTileLayerRenderer","extentChanged","renderedExtent_","renderedPixelRatio","renderedProjection","renderedRevision","renderedTiles","newTiles_","tmpExtent","tmpTileRange_","isDrawableTile","getSource","tilePixelRatio","getTilePixelRatio","floor","round","getImageData","getImage","loadedTileCallback","tiles","prepareFrame","target","viewResolution","viewCenter","sourceRevision","getRevision","prepareContainer","width","context","height","dx","dy","canvasExtent","tilesToDrawByZ","findLoadedTiles","createLoadedTileFinder","tmpTileRange","viewport","tileCoordIntersectsViewport","toString","inTransition","opacity","includes","childTileRange","getTileCoordChildTileRange","forEachTileCoordParentTileRange","canvasScale","getRenderContext","tempTransform","clipUnrotated","getInterpolate","imageSmoothingEnabled","clips","clipZs","currentClip","containerReused","getOpaque","reverse","currentZ","currentTilePixelSize","getTilePixelSize","currentResolution","currentScale","originTileCoord","originTileExtent","origin","tileGutter","tilesToDraw","xIndex","nextX","yIndex","nextY","w","h","transition","contextSaved","ii","clip","save","beginPath","moveTo","lineTo","clearRect","drawTileImage","restore","unshift","updateUsedTiles","usedTiles","renderedResolution","manageTilePyramid","scheduleExpireCache","container","image","getTileImage","alphaChanged","globalAlpha","drawImage","bind","tileCallback","tileCount","useTile","IMAGE_REPLAYS","VECTOR_REPLAYS","CanvasVectorTileLayerRenderer","boundHandleStyleImageChange_","handleStyleImageChange_","renderedLayerRevision_","renderedPixelToCoordinateTransform_","renderedRotation_","renderedOpacity_","tmpTransform_","tileClipContexts_","prepareTile","render","state","updateExecutorGroup_","tileImageNeedsRender_","viewHints","hifi","ANIMATING","INTERACTING","wantedResolution","Date","now","getRenderMode","renderTileImage_","executorGroups","hasContext","layerRevision","revision","renderOrder","getRenderOrder","builderState","getReplayState","dirty","renderedRenderOrder","declutter","getDeclutter","sourceTileGrid","getTileGrid","wrappedTileCoord","sourceTiles","getSourceTiles","layerUid","hitDetectionImageData","t","tt","sourceTile","sourceTileCoord","sourceTileExtent","sharedExtent","builderExtent","getRenderBuffer","bufferedExtent","builderGroup","squaredTolerance","feature","index","styles","styleFunction","getStyleFunction","renderFeature","features","getFeatures","getGeometry","call","executorGroupInstructions","finish","replayExtent","renderingReplayGroup","getOverlaps","forEachFeatureAtCoordinate","hitTolerance","callback","matches","hitExtent","featureCallback","geometry","distanceSq","getId","match","splice","lastIndexOf","found","some","declutteredFeatures","all","item","value","executorGroup","Promise","resolve","reject","projectionExtent","getTileCoordForCoordAndResolution","canWrapX","loadingSourceTiles","corner","tilePixel","reduce","accumulator","concat","transforms","getRenderTransform","handleFontsChanged","getVisible","changed","event","renderIfReadyAndVisible","renderDeclutter","execute","getTileRenderTransform","renderDeferredInternal","acc","executorGroupZIndexContexts","getDeferredZIndexContexts","usedZIndices","executorGroupZindexContext","zIndexKeys","zIndex","zIndexContexts","zIndexContext","getRenderedContext","tileClipContext","draw","worldOffset","transform","inversePixelTransform","renderMode","replayTypes","filter","tileClipContexts","group","hasExecutors","getClipCoords","clipContext","getContext","loading","Array","isArray","replayState","renderedTileResolution","renderedTileRevision","renderPixelRatio","renderScale","canvasTransform","setTransform","apply","pixelScale","CanvasVectorLayerRenderer","vectorLayer","animatingOrInteracting_","hitDetectionImageData_","clipped_","renderedFeatures_","renderedRevision_","renderedResolution_","NaN","wrappedRenderedExtent_","renderedCenter_","renderedProjection_","renderedPixelRatio_","renderedRenderOrder_","renderedFrameDeclutter_","replayGroup_","replayGroupChanged","clipping","targetContext_","opacity_","renderWorlds","declutterable","vectorSource","snapToPixel","multiWorld","worldWidth","endWorld","ceil","world","setDrawContext_","resetDrawContext_","renderDeferred","replayGroup","isEmpty","hasRenderListeners","hasListener","PRERENDER","POSTRENDER","startX","offsetX","userProjection","getUserProjection","result","animating","interacting","updateWhileAnimating","getUpdateWhileAnimating","updateWhileInteracting","getUpdateWhileInteracting","frameStateExtent","vectorLayerRevision","vectorLayerRenderBuffer","vectorLayerRenderOrder","renderedExtent","loadExtents","loadExtent","userTransform","userExtent","toUserExtent","loadFeatures","toUserResolution","getTransformFromProjections","getFeaturesInExtent","replayGroupInstructions","WebGLLayerRenderer","inversePixelTransform_","pixelContext_","postProcesses_","uniforms_","addChangeListener","MAP","PRECOMPOSE","dispatchEvent","POSTCOMPOSE","setUniforms","className","incrementGroup","groupNumber","renderer","getRenderer","layerClassName","getClassName","canvasCacheKey","mapId","canvasCacheKeyMatches","needsToBeRecreated","dispatchRenderEvent_","CanvasImageLayerRenderer","imageLayer","image_","imageSource","hints","loadImage","imageExtent","img","imageMapWidth","imageMapHeight","imageResolution","imageResolutionX","imageResolutionY","imagePixelRatio","getPixelRatio","scaleX","scaleY","clipped","dw","dh","SIMPLIFY_TOLERANCE","GEOMETRY_RENDERERS","renderPointGeometry","renderLineStringGeometry","renderPolygonGeometry","renderMultiPointGeometry","renderMultiLineStringGeometry","renderMultiPolygonGeometry","renderGeometryCollectionGeometry","renderCircleGeometry","defaultOrder","feature1","feature2","parseInt","getSquaredTolerance","tolerance","getTolerance","style","fillStyle","getFill","strokeStyle","getStroke","circleReplay","getBuilder","getZIndex","setFillStrokeStyle","drawCircle","textStyle","getText","textReplay","setTextStyle","drawText","listener","loadingPromises","imageStyle","imageState","getImageState","load","then","renderFeatureInternal","getGeometryFunction","simplifiedGeometry","simplifyTransformed","renderGeometry","geometryRenderer","getType","geometries","getGeometries","replay","drawCustom","getHitDetectionRenderer","declutterBuilderGroup","getGeometriesArray","lineStringReplay","drawLineString","drawMultiLineString","polygonReplay","drawMultiPolygon","hasText","declutterImageWithText","imageReplay","setImageStyle","drawPoint","hasImage","getOpacity","drawMultiPoint","drawPolygon","getWorldParameters","startWorld","WebGLPointsLayerRenderer","projectionMatrixTransform","sourceRevision_","verticesBuffer_","indicesBuffer_","hitDetectionEnabled_","hitDetectionEnabled","customAttributes","attributes","attribute","previousExtent_","currentTransform_","renderTransform_","invertRenderTransform_","renderInstructions_","Float32Array","hitRenderTarget_","lastSentId","worker_","addEventListener","received","data","GENERATE_POINT_BUFFERS","projectionTransform","fromArrayBuffer","vertexBuffer","indexBuffer","renderInstructions","id","featureCache_","featureCount_","sourceListenKeys_","VectorEventType","ADDFEATURE","handleSourceFeatureAdded_","CHANGEFEATURE","handleSourceFeatureChanged_","REMOVEFEATURE","handleSourceFeatureDelete_","CLEAR","handleSourceFeatureClear_","forEachFeature","properties","getProperties","clearCachedData","viewNotMoving","ViewHint","sourceChanged","renderBuffer","BaseVector","rebuildBuffers_","makeProjectionTransform","baseInstructionLength","singleInstructionLength","totalSize","featureCache","tmpCoords","tmpColor","idx","featureUid","userCoords","fromUserCoordinate","getFlatCoordinates","hitColor","message","buffer","customAttributesSize","postMessage","coordinateToPixelTransform","readPixel","color","getFeatureByUid","forHitDetection","setSize","prepareDrawToRenderTarget","applyUniforms","applyHitDetectionUniform","renderCount","terminate","layer_","canvasPool","pixelContext","createPixelContext","willReadFrequently","CanvasLayerRenderer","pixelTransform","deferredContext_","err","getBackground","background","useContainer","backgroundColor","firstElementChild","HTMLCanvasElement","document","createElement","position","appendChild","left","transformOrigin","topLeft","topRight","bottomRight","bottomLeft","inverted","dx1","dy1","sx","sy","dx2","dy2"],"sourceRoot":""}
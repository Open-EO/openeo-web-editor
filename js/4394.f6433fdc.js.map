{"version":3,"file":"js/4394.f6433fdc.js","mappings":"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","sources":["webpack://@openeo/web-editor/./node_modules/ol-ext/interaction/ModifyFeature.js","webpack://@openeo/web-editor/./node_modules/ol-ext/interaction/DrawHole.js","webpack://@openeo/web-editor/./node_modules/ol-ext/geom/GeomUtils.js","webpack://@openeo/web-editor/./node_modules/ol-ext/style/defaultStyle.js","webpack://@openeo/web-editor/./node_modules/ol-ext/interaction/Delete.js","webpack://@openeo/web-editor/./node_modules/ol-ext/control/TextButton.js","webpack://@openeo/web-editor/./node_modules/ol-ext/interaction/DrawRegular.js","webpack://@openeo/web-editor/./node_modules/ol-ext/source/Vector.js","webpack://@openeo/web-editor/./node_modules/ol-ext/interaction/UndoRedo.js","webpack://@openeo/web-editor/./node_modules/ol-ext/control/Toggle.js","webpack://@openeo/web-editor/./node_modules/ol-ext/interaction/Split.js","webpack://@openeo/web-editor/./node_modules/ol/interaction/Draw.js","webpack://@openeo/web-editor/./node_modules/ol-ext/interaction/Transform.js","webpack://@openeo/web-editor/./node_modules/ol-ext/interaction/Offset.js","webpack://@openeo/web-editor/./node_modules/ol/interaction/Extent.js","webpack://@openeo/web-editor/./node_modules/ol/events/SnapEvent.js","webpack://@openeo/web-editor/./node_modules/ol/interaction/Snap.js","webpack://@openeo/web-editor/./node_modules/ol-ext/geom/LineStringSplitAt.js","webpack://@openeo/web-editor/./node_modules/ol/geom/Circle.js"],"sourcesContent":["/*\tCopyright (c) 2016 Jean-Marc VIGLINO, \n  released under the CeCILL-B license (French BSD license)\n  (http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).\n*/\n\nimport ol_style_Style from 'ol/style/Style.js'\nimport ol_style_Stroke from 'ol/style/Stroke.js'\nimport ol_source_Vector from 'ol/source/Vector.js'\nimport ol_style_Fill from 'ol/style/Fill.js'\nimport ol_style_Circle from 'ol/style/Circle.js'\nimport ol_layer_Vector from 'ol/layer/Vector.js'\nimport ol_geom_Point from 'ol/geom/Point.js'\nimport ol_Feature from 'ol/Feature.js'\nimport ol_geom_LineString from 'ol/geom/LineString.js'\nimport ol_interaction_Interaction from 'ol/interaction/Interaction.js'\nimport {ol_coordinate_dist2d, ol_coordinate_equal} from \"../geom/GeomUtils.js\";\nimport {boundingExtent as ol_extent_boundingExtent} from 'ol/extent.js'\nimport {buffer as ol_extent_buffer} from 'ol/extent.js'\nimport {altKeyOnly as ol_events_condition_altKeyOnly} from 'ol/events/condition.js'\nimport {primaryAction as ol_events_condition_primaryAction} from 'ol/events/condition.js'\nimport {always as ol_events_condition_always} from 'ol/events/condition.js'\n\nimport ol_ext_element from '../util/element.js'\nimport '../geom/LineStringSplitAt.js'\n\n/** Interaction for modifying feature geometries. Similar to the core ol/interaction/Modify.\n * The interaction is more suitable to use to handle feature modification: only features concerned \n * by the modification are passed to the events (instead of all feature with ol/interaction/Modify)\n * - the modifystart event is fired before the feature is modified (no points still inserted)\n * - the modifyend event is fired after the modification\n * - it fires a modifying event\n * @constructor\n * @extends {ol_interaction_Interaction}\n * @fires modifystart\n * @fires modifying\n * @fires modifyend\n * @fires select\n * @param {*} options\n *\t@param {ol.source.Vector} options.source a source to modify (configured with useSpatialIndex set to true)\n *\t@param {ol.source.Vector|Array<ol.source.Vector>} options.sources a list of source to modify (configured with useSpatialIndex set to true)\n *  @param {ol.Collection.<ol.Feature>} options.features collection of feature to modify\n *  @param {integer} options.pixelTolerance Pixel tolerance for considering the pointer close enough to a segment or vertex for editing. Default is 10.\n *  @param {function|undefined} options.filter a filter that takes a feature and return true if it can be modified, default always true.\n *  @param {ol.style.Style | Array<ol.style.Style> | undefined} options.style Style for the sketch features.\n *  @param {ol.EventsConditionType | undefined} options.condition A function that takes an ol.MapBrowserEvent and returns a boolean to indicate whether that event will be considered to add or move a vertex to the sketch. Default is ol.events.condition.primaryAction.\n *  @param {ol.EventsConditionType | undefined} options.deleteCondition A function that takes an ol.MapBrowserEvent and returns a boolean to indicate whether that event should be handled. By default, ol.events.condition.singleClick with ol.events.condition.altKeyOnly results in a vertex deletion.\n *  @param {ol.EventsConditionType | undefined} options.insertVertexCondition A function that takes an ol.MapBrowserEvent and returns a boolean to indicate whether a new vertex can be added to the sketch features. Default is ol.events.condition.always\n *  @param {boolean} options.wrapX Wrap the world horizontally on the sketch overlay, default false\n */\nvar ol_interaction_ModifyFeature = class olinteractionModifyFeature extends ol_interaction_Interaction {\n  constructor(options) {\n    options = options || {}\n\n    var dragging, modifying\n    super({\n      handleEvent: function (e) {\n        switch (e.type) {\n          case 'pointerdown': {\n            dragging = this.handleDownEvent(e)\n            modifying = dragging || this._deleteCondition(e)\n            return !dragging\n          }\n          case 'pointerup': {\n            dragging = false\n            return this.handleUpEvent(e)\n          }\n          case 'pointerdrag': {\n            if (dragging)\n              return this.handleDragEvent(e)\n            else\n              return true\n          }\n          case 'pointermove': {\n            if (!dragging){\n              return this.handleMoveEvent(e)\n            } else {\n              return false\n            }\n          }\n          case 'singleclick':\n          case 'click': {\n            // Prevent click when modifying\n            return !modifying\n          }\n          default: return true\n        }\n      }\n    })\n\n    // Snap distance (in px)\n    this.snapDistance_ = options.pixelTolerance || 10\n    // Split tolerance between the calculated intersection and the geometry\n    this.tolerance_ = 1e-10\n    // Cursor\n    this.cursor_ = options.cursor\n\n    // List of source to split\n    this.sources_ = options.sources ? (options.sources instanceof Array) ? options.sources : [options.sources] : []\n    if (options.source) {\n      this.sources_.push(options.source)\n    }\n    if (options.features) {\n      this.sources_.push(new ol_source_Vector({ features: options.features }))\n    }\n    // Get all features candidate\n    this.filterSplit_ = options.filter || function () { return true }\n\n    this._condition = options.condition || ol_events_condition_primaryAction\n    this._deleteCondition = options.deleteCondition || ol_events_condition_altKeyOnly\n    this._insertVertexCondition = options.insertVertexCondition || ol_events_condition_always\n\n    // Default style\n    var sketchStyle = function () {\n      return [new ol_style_Style({\n        image: new ol_style_Circle({\n          radius: 6,\n          fill: new ol_style_Fill({ color: [0, 153, 255, 1] }),\n          stroke: new ol_style_Stroke({ color: '#FFF', width: 1.25 })\n        })\n      })\n      ]\n    }\n\n    // Custom style\n    if (options.style) {\n      if (typeof (options.style) === 'function') {\n        sketchStyle = options.style\n      } else {\n        sketchStyle = function () { return options.style }\n      }\n    }\n\n    // Create a new overlay for the sketch\n    this.overlayLayer_ = new ol_layer_Vector({\n      source: new ol_source_Vector({\n        useSpatialIndex: false\n      }),\n      name: 'Modify overlay',\n      displayInLayerSwitcher: false,\n      style: sketchStyle,\n      wrapX: options.wrapX\n    })\n\n  }\n  /**\n   * Remove the interaction from its current map, if any,  and attach it to a new\n   * map, if any. Pass `null` to just remove the interaction from the current map.\n   * @param {ol.Map} map Map.\n   * @api stable\n   */\n  setMap(map) {\n    if (this.getMap()) this.getMap().removeLayer(this.overlayLayer_)\n    super.setMap(map)\n    this.overlayLayer_.setMap(map)\n  }\n  /**\n   * Activate or deactivate the interaction + remove the sketch.\n   * @param {boolean} active.\n   * @api stable\n   */\n  setActive(active) {\n    super.setActive(active)\n    if (this.overlayLayer_) this.overlayLayer_.getSource().clear()\n  }\n  /** Change the filter function\n   * @param {function|undefined} options.filter a filter that takes a feature and return true if it can be modified, default always true.\n   */\n  setFilter(filter) {\n    if (typeof (filter) === 'function')\n      this.filterSplit_ = filter\n    else if (filter === undefined)\n      this.filterSplit_ = function () { return true }\n  }\n  /** Get closest feature at pixel\n   * @param {ol.Pixel}\n   * @return {*}\n   * @private\n   */\n  getClosestFeature(e) {\n    var f, c, d = this.snapDistance_ + 1\n    for (var i = 0; i < this.sources_.length; i++) {\n      var source = this.sources_[i]\n      f = source.getClosestFeatureToCoordinate(e.coordinate)\n      if (f && this.filterSplit_(f)) {\n        var ci = f.getGeometry().getClosestPoint(e.coordinate)\n        var di = ol_coordinate_dist2d(e.coordinate, ci) / e.frameState.viewState.resolution\n        if (di < d) {\n          d = di\n          c = ci\n        }\n        break\n      }\n    }\n    if (d > this.snapDistance_) {\n      if (this.currentFeature)\n        this.dispatchEvent({ type: 'select', selected: [], deselected: [this.currentFeature] })\n      this.currentFeature = null\n      return false\n    } else {\n      // Snap to node\n      var coord = this.getNearestCoord(c, f.getGeometry())\n      if (coord) {\n        coord = coord.coord\n        var p = this.getMap().getPixelFromCoordinate(coord)\n        if (ol_coordinate_dist2d(e.pixel, p) < this.snapDistance_) {\n          c = coord\n        }\n        //\n        if (this.currentFeature !== f)\n          this.dispatchEvent({ type: 'select', selected: [f], deselected: [this.currentFeature] })\n        this.currentFeature = f\n        return { source: source, feature: f, coord: c }\n      }\n    }\n  }\n  /** Get nearest coordinate in a list\n  * @param {ol.coordinate} pt the point to find nearest\n  * @param {ol.geom} coords list of coordinates\n  * @return {*} the nearest point with a coord (projected point), dist (distance to the geom), ring (if Polygon)\n  */\n  getNearestCoord(pt, geom) {\n    var i, l, p, p0, dm\n    switch (geom.getType()) {\n      case 'Point': {\n        return { coord: geom.getCoordinates(), dist: ol_coordinate_dist2d(geom.getCoordinates(), pt) }\n      }\n      case 'MultiPoint': {\n        return this.getNearestCoord(pt, new ol_geom_LineString(geom.getCoordinates()))\n      }\n      case 'LineString':\n      case 'LinearRing': {\n        var d\n        dm = Number.MAX_VALUE\n        var coords = geom.getCoordinates()\n        for (i = 0; i < coords.length; i++) {\n          d = ol_coordinate_dist2d(pt, coords[i])\n          if (d < dm) {\n            dm = d\n            p0 = coords[i]\n          }\n        }\n        return { coord: p0, dist: dm }\n      }\n      case 'MultiLineString': {\n        var lstring = geom.getLineStrings()\n        p0 = false, dm = Number.MAX_VALUE\n        for (i = 0; l = lstring[i]; i++) {\n          p = this.getNearestCoord(pt, l)\n          if (p && p.dist < dm) {\n            p0 = p\n            dm = p.dist\n            p0.ring = i\n          }\n        }\n        return p0\n      }\n      case 'Polygon': {\n        var lring = geom.getLinearRings()\n        p0 = false\n        dm = Number.MAX_VALUE\n        for (i = 0; l = lring[i]; i++) {\n          p = this.getNearestCoord(pt, l)\n          if (p && p.dist < dm) {\n            p0 = p\n            dm = p.dist\n            p0.ring = i\n          }\n        }\n        return p0\n      }\n      case 'MultiPolygon': {\n        var poly = geom.getPolygons()\n        p0 = false\n        dm = Number.MAX_VALUE\n        for (i = 0; l = poly[i]; i++) {\n          p = this.getNearestCoord(pt, l)\n          if (p && p.dist < dm) {\n            p0 = p\n            dm = p.dist\n            p0.poly = i\n          }\n        }\n        return p0\n      }\n      case 'GeometryCollection': {\n        var g = geom.getGeometries()\n        p0 = false\n        dm = Number.MAX_VALUE\n        for (i = 0; l = g[i]; i++) {\n          p = this.getNearestCoord(pt, l)\n          if (p && p.dist < dm) {\n            p0 = p\n            dm = p.dist\n            p0.geom = i\n          }\n        }\n        return p0\n      }\n      default: return false\n    }\n  }\n  /** Get arcs concerned by a modification\n   * @param {ol.geom} geom the geometry concerned\n   * @param {ol.coordinate} coord pointed coordinates\n   */\n  getArcs(geom, coord) {\n    var arcs = false\n    var coords, i, s, l, g\n    switch (geom.getType()) {\n      case 'Point': {\n        if (ol_coordinate_equal(coord, geom.getCoordinates())) {\n          arcs = {\n            geom: geom,\n            type: geom.getType(),\n            coord1: [],\n            coord2: [],\n            node: true\n          }\n        }\n        break\n      }\n      case 'MultiPoint': {\n        coords = geom.getCoordinates()\n        for (i = 0; i < coords.length; i++) {\n          if (ol_coordinate_equal(coord, coords[i])) {\n            arcs = {\n              geom: geom,\n              type: geom.getType(),\n              index: i,\n              coord1: [],\n              coord2: [],\n              node: true\n            }\n            break\n          }\n        }\n        break\n      }\n      case 'LinearRing':\n      case 'LineString': {\n        var p = geom.getClosestPoint(coord)\n        if (ol_coordinate_dist2d(p, coord) < 1.5 * this.tolerance_) {\n          var split\n          // Split the line in two\n          if (geom.getType() === 'LinearRing') {\n            g = new ol_geom_LineString(geom.getCoordinates())\n            split = g.splitAt(coord, this.tolerance_)\n          } else {\n            split = geom.splitAt(coord, this.tolerance_)\n          }\n          // If more than 2\n          if (split.length > 2) {\n            coords = split[1].getCoordinates()\n            for (i = 2; s = split[i]; i++) {\n              var c = s.getCoordinates()\n              c.shift()\n              coords = coords.concat(c)\n            }\n            split = [split[0], new ol_geom_LineString(coords)]\n          }\n          // Split in two\n          if (split.length === 2) {\n            var c0 = split[0].getCoordinates()\n            var c1 = split[1].getCoordinates()\n            var nbpt = c0.length + c1.length - 1\n            c0.pop()\n            c1.shift()\n            arcs = {\n              geom: geom,\n              type: geom.getType(),\n              coord1: c0,\n              coord2: c1,\n              node: (geom.getCoordinates().length === nbpt),\n              closed: false\n            }\n          } else if (split.length === 1) {\n            s = split[0].getCoordinates()\n            var start = ol_coordinate_equal(s[0], coord)\n            var end = ol_coordinate_equal(s[s.length - 1], coord)\n            // Move first point\n            if (start) {\n              s.shift()\n              if (end)\n                s.pop()\n              arcs = {\n                geom: geom,\n                type: geom.getType(),\n                coord1: [],\n                coord2: s,\n                node: true,\n                closed: end\n              }\n            } else if (end) {\n              // Move last point\n              s.pop()\n              arcs = {\n                geom: geom,\n                type: geom.getType(),\n                coord1: s,\n                coord2: [],\n                node: true,\n                closed: false\n              }\n            }\n          }\n        }\n        break\n      }\n      case 'MultiLineString': {\n        var lstring = geom.getLineStrings()\n        for (i = 0; l = lstring[i]; i++) {\n          arcs = this.getArcs(l, coord)\n          if (arcs) {\n            arcs.geom = geom\n            arcs.type = geom.getType()\n            arcs.lstring = i\n            break\n          }\n        }\n        break\n      }\n      case 'Polygon': {\n        var lring = geom.getLinearRings()\n        for (i = 0; l = lring[i]; i++) {\n          arcs = this.getArcs(l, coord)\n          if (arcs) {\n            arcs.geom = geom\n            arcs.type = geom.getType()\n            arcs.index = i\n            break\n          }\n        }\n        break\n      }\n      case 'MultiPolygon': {\n        var poly = geom.getPolygons()\n        for (i = 0; l = poly[i]; i++) {\n          arcs = this.getArcs(l, coord)\n          if (arcs) {\n            arcs.geom = geom\n            arcs.type = geom.getType()\n            arcs.poly = i\n            break\n          }\n        }\n        break\n      }\n      case 'GeometryCollection': {\n        g = geom.getGeometries()\n        for (i = 0; l = g[i]; i++) {\n          arcs = this.getArcs(l, coord)\n          if (arcs) {\n            arcs.geom = geom\n            arcs.g = i\n            arcs.typeg = arcs.type\n            arcs.type = geom.getType()\n            break\n          }\n        }\n        break\n      }\n      default: {\n        console.error('ol/interaction/ModifyFeature ' + geom.getType() + ' not supported!')\n        break\n      }\n    }\n    return arcs\n  }\n  /**\n   * @param {ol.MapBrowserEvent} evt Map browser event.\n   * @return {boolean} `true` to start the drag sequence.\n   */\n  handleDownEvent(evt) {\n    if (!this.getActive())\n      return false\n\n    // Something to move ?\n    var current = this.getClosestFeature(evt)\n\n    if (current && (this._condition(evt) || this._deleteCondition(evt))) {\n      var features = []\n      this.arcs = []\n\n      // Get features concerned\n      this.sources_.forEach(function (s) {\n        var extent = ol_extent_buffer(ol_extent_boundingExtent([current.coord]), this.tolerance_)\n        features = features.concat(features, s.getFeaturesInExtent(extent))\n      }.bind(this))\n\n      // Get arcs concerned\n      this._modifiedFeatures = []\n      features.forEach(function (f) {\n        var a = this.getArcs(f.getGeometry(), current.coord)\n        if (a) {\n          if (this._insertVertexCondition(evt) || a.node) {\n            a.feature = f\n            this._modifiedFeatures.push(f)\n            this.arcs.push(a)\n          }\n        }\n      }.bind(this))\n\n      if (this._modifiedFeatures.length) {\n        if (this._deleteCondition(evt)) {\n          return !this._removePoint(current, evt)\n        } else {\n          this.dispatchEvent({\n            type: 'modifystart',\n            coordinate: current.coord,\n            originalEvent: evt.originalEvent,\n            features: this._modifiedFeatures\n          })\n          this.handleDragEvent({\n            coordinate: current.coord,\n            originalEvent: evt.originalEvent\n          })\n          return true\n        }\n      } else {\n        return true\n      }\n    } else {\n      return false\n    }\n  }\n  /** Get modified features\n   * @return {Array<ol.Feature>} list of modified features\n   */\n  getModifiedFeatures() {\n    return this._modifiedFeatures || []\n  }\n  /** Removes the vertex currently being pointed.\n   */\n  removePoint() {\n    this._removePoint({}, {})\n  }\n  /**\n   * @private\n   */\n  _getModification(a) {\n    var coords = a.coord1.concat(a.coord2)\n    switch (a.type) {\n      case 'LineString': {\n        if (a.closed)\n          coords.push(coords[0])\n        if (coords.length > 1) {\n          if (a.geom.getCoordinates().length != coords.length) {\n            a.coords = coords\n            return true\n          }\n        }\n        break\n      }\n      case 'MultiLineString': {\n        if (a.closed)\n          coords.push(coords[0])\n        if (coords.length > 1) {\n          var c = a.geom.getCoordinates()\n          if (c[a.lstring].length != coords.length) {\n            c[a.lstring] = coords\n            a.coords = c\n            return true\n          }\n        }\n        break\n      }\n      case 'Polygon': {\n        if (a.closed)\n          coords.push(coords[0])\n        if (coords.length > 3) {\n          c = a.geom.getCoordinates()\n          if (c[a.index].length != coords.length) {\n            c[a.index] = coords\n            a.coords = c\n            return true\n          }\n        }\n        break\n      }\n      case 'MultiPolygon': {\n        if (a.closed)\n          coords.push(coords[0])\n        if (coords.length > 3) {\n          c = a.geom.getCoordinates()\n          if (c[a.poly][a.index].length != coords.length) {\n            c[a.poly][a.index] = coords\n            a.coords = c\n            return true\n          }\n        }\n        break\n      }\n      case 'GeometryCollection': {\n        a.type = a.typeg\n        var geom = a.geom\n        var geoms = geom.getGeometries()\n        a.geom = geoms[a.g]\n        var found = this._getModification(a)\n        // Restore current arc\n        geom.setGeometries(geoms)\n        a.geom = geom\n        a.type = 'GeometryCollection'\n        return found\n      }\n      default: {\n        //console.error('ol/interaction/ModifyFeature '+a.type+' not supported!');\n        break\n      }\n    }\n    return false\n  }\n  /** Removes the vertex currently being pointed.\n   * @private\n   */\n  _removePoint(current, evt) {\n    if (!this.arcs)\n      return false\n\n    this.overlayLayer_.getSource().clear()\n\n    var found = false\n    // Get all modifications\n    this.arcs.forEach(function (a) {\n      found = found || this._getModification(a)\n    }.bind(this))\n\n    // Almost one point is removed\n    if (found) {\n      this.dispatchEvent({\n        type: 'modifystart',\n        coordinate: current.coord,\n        originalEvent: evt.originalEvent,\n        features: this._modifiedFeatures\n      })\n      this.arcs.forEach(function (a) {\n        if (a.geom.getType() === 'GeometryCollection') {\n          if (a.coords) {\n            var geoms = a.geom.getGeometries()\n            geoms[a.g].setCoordinates(a.coords)\n            a.geom.setGeometries(geoms)\n          }\n        } else {\n          if (a.coords)\n            a.geom.setCoordinates(a.coords)\n        }\n      }.bind(this))\n      this.dispatchEvent({\n        type: 'modifyend',\n        coordinate: current.coord,\n        originalEvent: evt.originalEvent,\n        features: this._modifiedFeatures\n      })\n    }\n\n    this.arcs = []\n    return found\n  }\n  /**\n   * @private\n   */\n  handleUpEvent(e) {\n    if (!this.getActive())\n      return false\n    if (!this.arcs || !this.arcs.length)\n      return true\n\n    this.overlayLayer_.getSource().clear()\n    this.dispatchEvent({\n      type: 'modifyend',\n      coordinate: e.coordinate,\n      originalEvent: e.originalEvent,\n      features: this._modifiedFeatures\n    })\n\n    this.arcs = []\n    return true\n  }\n  /**\n   * @private\n   */\n  setArcCoordinates(a, coords) {\n    var c\n    switch (a.type) {\n      case 'Point': {\n        a.geom.setCoordinates(coords[0])\n        break\n      }\n      case 'MultiPoint': {\n        c = a.geom.getCoordinates()\n        c[a.index] = coords[0]\n        a.geom.setCoordinates(c)\n        break\n      }\n      case 'LineString': {\n        a.geom.setCoordinates(coords)\n        break\n      }\n      case 'MultiLineString': {\n        c = a.geom.getCoordinates()\n        c[a.lstring] = coords\n        a.geom.setCoordinates(c)\n        break\n      }\n      case 'Polygon': {\n        c = a.geom.getCoordinates()\n        c[a.index] = coords\n        a.geom.setCoordinates(c)\n        break\n      }\n      case 'MultiPolygon': {\n        c = a.geom.getCoordinates()\n        c[a.poly][a.index] = coords\n        a.geom.setCoordinates(c)\n        break\n      }\n      case 'GeometryCollection': {\n        a.type = a.typeg\n        var geom = a.geom\n        var geoms = geom.getGeometries()\n        a.geom = geoms[a.g]\n        this.setArcCoordinates(a, coords)\n        geom.setGeometries(geoms)\n        a.geom = geom\n        a.type = 'GeometryCollection'\n        break\n      }\n    }\n  }\n  /**\n   * @private\n   */\n  handleDragEvent(e) {\n    if (!this.getActive()) return false\n    if (!this.arcs) return true\n\n    // Show sketch\n    this.overlayLayer_.getSource().clear()\n    var p = new ol_Feature(new ol_geom_Point(e.coordinate))\n    this.overlayLayer_.getSource().addFeature(p)\n\n    // Nothing to do\n    if (!this.arcs.length) return true\n\n    // Move arcs\n    this.arcs.forEach(function (a) {\n      var coords = a.coord1.concat([e.coordinate], a.coord2)\n      if (a.closed) coords.push(e.coordinate)\n      this.setArcCoordinates(a, coords)\n    }.bind(this))\n\n    this.dispatchEvent({\n      type: 'modifying',\n      coordinate: e.coordinate,\n      originalEvent: e.originalEvent,\n      features: this._modifiedFeatures\n    })\n\n    return true\n  }\n  /**\n   * @param {ol.MapBrowserEvent} evt Event.\n   * @private\n   */\n  handleMoveEvent(e) {\n    if (!this.getActive()) return true\n\n    this.overlayLayer_.getSource().clear()\n    var current = this.getClosestFeature(e)\n\n    // Draw sketch\n    if (current) {\n      var p = new ol_Feature(new ol_geom_Point(current.coord))\n      this.overlayLayer_.getSource().addFeature(p)\n    }\n\n    // Show cursor\n    var element = e.map.getTargetElement()\n    if (this.cursor_) {\n      if (current) {\n        if (element.style.cursor != this.cursor_) {\n          this.previousCursor_ = element.style.cursor\n          ol_ext_element.setCursor(element, this.cursor_)\n        }\n      } else if (this.previousCursor_ !== undefined) {\n        ol_ext_element.setCursor(element, this.previousCursor_)\n        this.previousCursor_ = undefined\n      }\n    }\n    return true\n  }\n  /** Get the current feature to modify\n   * @return {ol.Feature}\n   */\n  getCurrentFeature() {\n    return this.currentFeature\n  }\n}\n\nexport default ol_interaction_ModifyFeature","/*\tCopyright (c) 2017 Jean-Marc VIGLINO, \n  released under the CeCILL-B license (French BSD license)\n  (http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).\n*/\n\nimport ol_geom_Polygon from 'ol/geom/Polygon.js'\nimport ol_geom_MultiPolygon from 'ol/geom/MultiPolygon.js'\nimport ol_geom_LinearRing from 'ol/geom/LinearRing.js'\nimport ol_interaction_Draw from 'ol/interaction/Draw.js'\nimport ol_interaction_Select from 'ol/interaction/Select.js'\n\n/** Interaction to draw holes in a polygon.\n * It fires a drawstart, drawend event when drawing the hole\n * and a modifystart, modifyend event before and after inserting the hole in the feature geometry.\n * @constructor\n * @extends {ol_interaction_Interaction}\n * @fires drawstart\n * @fires drawend\n * @fires modifystart\n * @fires modifyend\n * @param {olx.interaction.DrawHoleOptions} options extend olx.interaction.DrawOptions\n * \t@param {Array<ol.layer.Vector> | function | undefined} options.layers A list of layers from which polygons should be selected. Alternatively, a filter function can be provided. default: all visible layers\n * \t@param {Array<ol.Feature> | ol.Collection<ol.Feature> | function | undefined} options.featureFilter An array or a collection of features the interaction applies on or a function that takes a feature and a layer and returns true if the feature is a candidate\n * \t@param { ol.style.Style | Array<ol.style.Style> | StyleFunction | undefined }\tStyle for the selected features, default: default edit style\n * \t@param {function | undefined}\toptions.geometryFunction Draw interaction geometry function to customize the hole\n */\nvar ol_interaction_DrawHole = class olinteractionDrawHole extends ol_interaction_Draw {\n  constructor(options) {\n    options = options || {}\n    // Geometry function that test points inside the current selection\n    var _geometryFn = function(coordinates, geometry) {\n      var coord = coordinates[0].pop()\n      if (!this.getPolygon() || this.getPolygon().intersectsCoordinate(coord)) {\n        this.lastOKCoord = [coord[0], coord[1]]\n      }\n      coordinates[0].push([this.lastOKCoord[0], this.lastOKCoord[1]])\n  \n      if (geometry) {\n        geometry.setCoordinates([coordinates[0].concat([coordinates[0][0]])])\n      } else {\n        geometry = new ol_geom_Polygon(coordinates)\n      }\n      return geometry\n    }\n    var geomFn = options.geometryFunction\n    if (geomFn) {\n      options.geometryFunction = function (c, g, p) {\n        g = _geometryFn.bind(this)(c, g)\n        return geomFn.bind(this)(c, g, p)\n      }\n    } else {\n      options.geometryFunction = _geometryFn\n    }\n\n    // Create draw interaction\n    options.type = 'Polygon';\n    super(options)\n    \n    // Select interaction for the current feature\n    this._select = new ol_interaction_Select({ style: options.style })\n    this._select.setActive(false)\n\n    // Layer filter function\n    if (options.layers) {\n      if (typeof (options.layers) === 'function') {\n        this.layers_ = options.layers\n      } else if (options.layers.indexOf) {\n        this.layers_ = function (l) {\n          return (options.layers.indexOf(l) >= 0)\n        }\n      }\n    }\n\n    // Features to apply on \n    if (typeof (options.featureFilter) === 'function') {\n      this._features = options.featureFilter\n    } else if (options.featureFilter) {\n      var features = options.featureFilter\n      this._features = function (f) {\n        if (features.indexOf) {\n          return !!features[features.indexOf(f)]\n        } else {\n          return !!features.item(features.getArray().indexOf(f))\n        }\n      }\n    } else {\n      this._features = function () { return true }\n    }\n\n    // Start drawing if inside a feature\n    this.on('drawstart', this._startDrawing.bind(this))\n    // End drawing add the hole to the current Polygon\n    this.on('drawend', this._finishDrawing.bind(this))\n  }\n\n  /**\n   * Remove the interaction from its current map, if any,  and attach it to a new\n   * map, if any. Pass `null` to just remove the interaction from the current map.\n   * @param {ol.Map} map Map.\n   * @api stable\n   */\n  setMap(map) {\n    // Remove previous selection\n    if (this.getMap()) this.getMap().removeInteraction(this._select)\n    // Add new one\n    if (map) map.addInteraction(this._select)\n    super.setMap.call(this, map)\n  }\n  /**\n   * Activate/deactivate the interaction\n   * @param {boolean}\n   * @api stable\n   */\n  setActive(b) {\n    if (this._select) this._select.getFeatures().clear()\n    super.setActive.call(this, b)\n  }\n  /**\n   * Remove last point of the feature currently being drawn\n   * (test if points to remove before).\n   */\n  removeLastPoint() {\n    if (this._feature && this._feature.getGeometry().getCoordinates()[0].length > 2) {\n      super.removeLastPoint.call(this)\n    }\n  }\n  /**\n   * Get the current polygon to hole\n   * @return {ol.Feature}\n   */\n  getPolygon() {\n    return this._polygon\n    // return this._select.getFeatures().item(0).getGeometry();\n  }\n  /**\n   * Get current feature to add a hole and start drawing\n   * @param {ol_interaction_Draw.Event} e\n   * @private\n   */\n  _startDrawing(e) {\n    var map = this.getMap()\n    this._feature = e.feature\n    var coord = e.feature.getGeometry().getCoordinates()[0][0]\n    this._current = null\n    // Check object under the pointer\n    map.forEachFeatureAtPixel(\n      map.getPixelFromCoordinate(coord),\n      function (feature, layer) {\n        // Not yet found?\n        if (!this._current && this._features(feature, layer)) {\n          var poly = feature.getGeometry()\n          if (poly.getType() === \"Polygon\"\n            && poly.intersectsCoordinate(coord)) {\n            this._polygonIndex = false\n            this._polygon = poly\n            this._current = feature\n          } else if (poly.getType() === \"MultiPolygon\"\n            && poly.intersectsCoordinate(coord)) {\n            for (var i = 0, p; p = poly.getPolygon(i); i++) {\n              if (p.intersectsCoordinate(coord)) {\n                this._polygonIndex = i\n                this._polygon = p\n                this._current = feature\n                break\n              }\n            }\n          }\n        }\n      }.bind(this), {\n      layerFilter: this.layers_\n    }\n    )\n    this._select.getFeatures().clear()\n    if (!this._current) {\n      this.setActive(false)\n      this.setActive(true)\n    } else {\n      this._select.getFeatures().push(this._current)\n    }\n  }\n  /**\n   * Stop drawing and add the sketch feature to the target feature.\n   * @param {ol_interaction_Draw.Event} e\n   * @private\n   */\n  _finishDrawing(e) {\n    // The feature is the hole\n    e.hole = e.feature\n    // Get the current feature\n    e.feature = this._select.getFeatures().item(0)\n    this.dispatchEvent({ type: 'modifystart', features: [this._current] })\n    // Create the hole\n    var c = e.hole.getGeometry().getCoordinates()[0]\n    if (c.length > 3) {\n      if (this._polygonIndex !== false) {\n        var geom = e.feature.getGeometry()\n        var newGeom = new ol_geom_MultiPolygon([])\n        for (var i = 0, pi; pi = geom.getPolygon(i); i++) {\n          if (i === this._polygonIndex) {\n            pi.appendLinearRing(new ol_geom_LinearRing(c))\n            newGeom.appendPolygon(pi)\n          } else {\n            newGeom.appendPolygon(pi)\n          }\n        }\n        e.feature.setGeometry(newGeom)\n      } else {\n        this.getPolygon().appendLinearRing(new ol_geom_LinearRing(c))\n      }\n    }\n    this.dispatchEvent({ type: 'modifyend', features: [this._current] })\n    // reset\n    this._feature = null\n    this._select.getFeatures().clear()\n  }\n  /**\n   * Function that is called when a geometry's coordinates are updated.\n   * @param {Array<ol.coordinate>} coordinates\n   * @param {ol_geom_Polygon} geometry\n   * @return {ol_geom_Polygon}\n   * @private\n   */\n  _geometryFn(coordinates, geometry) {\n    var coord = coordinates[0].pop()\n    if (!this.getPolygon() || this.getPolygon().intersectsCoordinate(coord)) {\n      this.lastOKCoord = [coord[0], coord[1]]\n    }\n    coordinates[0].push([this.lastOKCoord[0], this.lastOKCoord[1]])\n\n    if (geometry) {\n      geometry.setCoordinates([coordinates[0].concat([coordinates[0][0]])])\n    } else {\n      geometry = new ol_geom_Polygon(coordinates)\n    }\n    return geometry\n  }\n}\n\nexport default ol_interaction_DrawHole\n","/*\tCopyright (c) 2016 Jean-Marc VIGLINO, \n  released under the CeCILL-B license (French BSD license)\n  (http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).\n\n  Usefull function to handle geometric operations\n*/\n\nimport ol_geom_LineString from 'ol/geom/LineString.js'\nimport ol_geom_LinearRing from 'ol/geom/LinearRing.js'\nimport ol_geom_MultiLineString from 'ol/geom/MultiLineString.js'\nimport ol_geom_MultiPoint from 'ol/geom/MultiPoint.js'\nimport ol_geom_MultiPolygon from 'ol/geom/MultiPolygon.js'\nimport ol_geom_Point from 'ol/geom/Point.js'\nimport ol_geom_Polygon from 'ol/geom/Polygon.js'\nimport ol_geom_Circle from 'ol/geom/Circle.js'\nimport {getCenter as ol_extent_getCenter} from 'ol/extent.js'\nimport {buffer as ol_extent_buffer} from 'ol/extent.js'\n\n/** Distance beetween 2 points\n *\tUsefull geometric functions\n * @param {ol.Coordinate} p1 first point\n * @param {ol.Coordinate} p2 second point\n * @return {number} distance\n */\nvar ol_coordinate_dist2d = function(p1, p2) {\n  var dx = p1[0]-p2[0];\n  var dy = p1[1]-p2[1];\n  return Math.sqrt(dx*dx+dy*dy);\n}\n\n/** 2 points are equal\n *\tUsefull geometric functions\n * @param {ol.Coordinate} p1 first point\n * @param {ol.Coordinate} p2 second point\n * @return {boolean}\n */\nvar ol_coordinate_equal = function(p1, p2) {\n  return (p1[0]==p2[0] && p1[1]==p2[1]);\n}\n\n/** Get center coordinate of a feature\n * @param {ol.Feature} f\n * @return {ol.coordinate} the center\n */\nvar ol_coordinate_getFeatureCenter = function(f) {\n  return ol_coordinate_getGeomCenter (f.getGeometry());\n};\n\n/** Get center coordinate of a geometry\n* @param {ol.geom.Geometry} geom\n* @return {ol.Coordinate} the center\n*/\nvar ol_coordinate_getGeomCenter = function(geom) {\n  switch (geom.getType()) {\n    case 'Point': \n      return geom.getCoordinates();\n    case \"MultiPolygon\":\n      geom = geom.getPolygon(0);\n      // fallthrough\n    case \"Polygon\":\n      return geom.getInteriorPoint().getCoordinates();\n    default:\n      return geom.getClosestPoint(ol_extent_getCenter(geom.getExtent()));\n  }\n};\n\n/** Offset a polyline\n * @param {Array<ol.Coordinate>} coords\n * @param {number} offset\n * @return {Array<ol.Coordinate>} resulting coord\n * @see http://stackoverflow.com/a/11970006/796832\n * @see https://drive.google.com/viewerng/viewer?a=v&pid=sites&srcid=ZGVmYXVsdGRvbWFpbnxqa2dhZGdldHN0b3JlfGd4OjQ4MzI5M2Y0MjNmNzI2MjY\n */\nvar ol_coordinate_offsetCoords = function (coords, offset) {\n  var path = [];\n  var N = coords.length-1;\n  var max = N;\n  var mi, mi1, li, li1, ri, ri1, si, si1, Xi1, Yi1;\n  var p0, p1, p2;\n  var isClosed = ol_coordinate_equal(coords[0],coords[N]);\n  if (!isClosed) {\n    p0 = coords[0];\n    p1 = coords[1];\n    p2 = [\n      p0[0] + (p1[1] - p0[1]) / ol_coordinate_dist2d(p0,p1) *offset,\n      p0[1] - (p1[0] - p0[0]) / ol_coordinate_dist2d(p0,p1) *offset\n    ];\n    path.push(p2);\n    coords.push(coords[N])\n    N++;\n    max--;\n  }\n  for (var i = 0; i < max; i++) {\n    p0 = coords[i];\n    p1 = coords[(i+1) % N];\n    p2 = coords[(i+2) % N];\n\n    mi = (p1[1] - p0[1])/(p1[0] - p0[0]);\n    mi1 = (p2[1] - p1[1])/(p2[0] - p1[0]);\n    // Prevent alignements\n    if (Math.abs(mi-mi1) > 1e-10) {\n      li = Math.sqrt((p1[0] - p0[0])*(p1[0] - p0[0])+(p1[1] - p0[1])*(p1[1] - p0[1]));\n      li1 = Math.sqrt((p2[0] - p1[0])*(p2[0] - p1[0])+(p2[1] - p1[1])*(p2[1] - p1[1]));\n      ri = p0[0] + offset*(p1[1] - p0[1])/li;\n      ri1 = p1[0] + offset*(p2[1] - p1[1])/li1;\n      si = p0[1] - offset*(p1[0] - p0[0])/li;\n      si1 = p1[1] - offset*(p2[0] - p1[0])/li1;\n      Xi1 = (mi1*ri1-mi*ri+si-si1) / (mi1-mi);\n      Yi1 = (mi*mi1*(ri1-ri)+mi1*si-mi*si1) / (mi1-mi);\n\n      // Correction for vertical lines\n      if(p1[0] - p0[0] == 0) {\n        Xi1 = p1[0] + offset*(p1[1] - p0[1])/Math.abs(p1[1] - p0[1]);\n        Yi1 = mi1*Xi1 - mi1*ri1 + si1;\n      }\n      if (p2[0] - p1[0] == 0 ) {\n        Xi1 = p2[0] + offset*(p2[1] - p1[1])/Math.abs(p2[1] - p1[1]);\n        Yi1 = mi*Xi1 - mi*ri + si;\n      }\n\n      path.push([Xi1, Yi1]);\n    }\n  }\n  if (isClosed) {\n    path.push(path[0]);\n  } else {\n    coords.pop();\n    p0 = coords[coords.length-1];\n    p1 = coords[coords.length-2];\n    p2 = [\n      p0[0] - (p1[1] - p0[1]) / ol_coordinate_dist2d(p0,p1) *offset,\n      p0[1] + (p1[0] - p0[0]) / ol_coordinate_dist2d(p0,p1) *offset\n    ];\n    path.push(p2);\n  }\n  return path;\n}\n\n/** Find the segment a point belongs to\n * @param {ol.Coordinate} pt\n * @param {Array<ol.Coordinate>} coords\n * @return {} the index (-1 if not found) and the segment\n */\nvar ol_coordinate_findSegment = function (pt, coords) {\n  for (var i=0; i<coords.length-1; i++) {\n    var p0 = coords[i];\n    var p1 = coords[i+1];\n    if (ol_coordinate_equal(pt, p0) || ol_coordinate_equal(pt, p1)) {\n      return { index:1, segment: [p0,p1] };\n    } else {\n      var d0 = ol_coordinate_dist2d(p0,p1);\n      var v0 = [ (p1[0] - p0[0]) / d0, (p1[1] - p0[1]) / d0 ];\n      var d1 = ol_coordinate_dist2d(p0,pt);\n      var v1 = [ (pt[0] - p0[0]) / d1, (pt[1] - p0[1]) / d1 ];\n      if (Math.abs(v0[0]*v1[1] - v0[1]*v1[0]) < 1e-10) {\n        return { index:1, segment: [p0,p1] };\n      }\n    }\n  }\n  return { index: -1 };\n};\n\n/**\n * Split a Polygon geom with horizontal lines\n * @param {Array<ol.Coordinate>} geom\n * @param {number} y the y to split\n * @param {number} n contour index\n * @return {Array<Array<ol.Coordinate>>}\n */\nvar ol_coordinate_splitH = function (geom, y, n) {\n  var x, abs;\n  var list = [];\n  for (var i=0; i<geom.length-1; i++) {\n    // Hole separator?\n    if (!geom[i].length || !geom[i+1].length) continue;\n    // Intersect\n    if (geom[i][1]<=y && geom[i+1][1]>y || geom[i][1]>=y && geom[i+1][1]<y) {\n      abs = (y-geom[i][1]) / (geom[i+1][1]-geom[i][1]);\n      x = abs * (geom[i+1][0]-geom[i][0]) + geom[i][0];\n      list.push ({ contour: n, index: i, pt: [x,y], abs: abs });\n    }\n  }\n  // Sort x\n  list.sort(function(a,b) { return a.pt[0] - b.pt[0] });\n  // Horizontal segment\n  var result = [];\n  for (var j=0; j<list.length-1; j += 2) {\n    result.push([list[j], list[j+1]])\n  }\n  return result;\n};\n\n/** Create a geometry given a type and coordinates */\nvar ol_geom_createFromType = function (type, coordinates) {\n  switch (type) {\n    case 'LineString': return new ol_geom_LineString(coordinates);\n    case 'LinearRing': return new ol_geom_LinearRing(coordinates);\n    case 'MultiLineString': return new ol_geom_MultiLineString(coordinates);\n    case 'MultiPoint': return new ol_geom_MultiPoint(coordinates);\n    case 'MultiPolygon': return new ol_geom_MultiPolygon(coordinates);\n    case 'Point': return new ol_geom_Point(coordinates);\n    case 'Polygon': return new ol_geom_Polygon(coordinates);\n    default:\n      console.error('[createFromType] Unsupported type: '+type);\n      return null;\n  }\n};\n\nexport {ol_geom_createFromType}\nexport {ol_coordinate_dist2d, ol_coordinate_equal, ol_coordinate_findSegment, ol_coordinate_getFeatureCenter, ol_coordinate_getGeomCenter, ol_coordinate_offsetCoords, ol_coordinate_splitH}\n\n/** Intersect 2 lines\n * @param {Arrar<ol.coordinate>} d1\n * @param {Arrar<ol.coordinate>} d2\n */\nvar ol_coordinate_getIntersectionPoint = function (d1, d2) {\n  var d1x = d1[1][0] - d1[0][0];\n  var d1y = d1[1][1] - d1[0][1];\n  var d2x = d2[1][0] - d2[0][0];\n  var d2y = d2[1][1] - d2[0][1];\n  var det = d1x * d2y - d1y * d2x;\n  if (det != 0) {\n    var k = (d1x * d1[0][1] - d1x * d2[0][1] - d1y * d1[0][0] + d1y * d2[0][0]) / det;\n    return [d2[0][0] + k*d2x, d2[0][1] + k*d2y];\n  } else {\n    return false;\n  }\n};\n\nexport { ol_coordinate_getIntersectionPoint }\n\nvar ol_extent_intersection;\n\n(function() {\n// Split at x\nfunction splitX(pts, x) {\n  var pt;\n  for (let i=pts.length-1; i>0; i--) {\n    if ((pts[i][0]>x && pts[i-1][0]<x) || (pts[i][0]<x && pts[i-1][0]>x)) {\n      pt = [ x, (x - pts[i][0]) / (pts[i-1][0]-pts[i][0]) * (pts[i-1][1]-pts[i][1]) + pts[i][1]];\n      pts.splice(i, 0, pt);\n    }\n  }\n}\n// Split at y\nfunction splitY(pts, y) {\n  var pt;\n  for (let i=pts.length-1; i>0; i--) {\n    if ((pts[i][1]>y && pts[i-1][1]<y) || (pts[i][1]<y && pts[i-1][1]>y)) {\n      pt = [ (y - pts[i][1]) / (pts[i-1][1]-pts[i][1]) * (pts[i-1][0]-pts[i][0]) + pts[i][0], y];\n      pts.splice(i, 0, pt);\n    }\n  }\n}\n\n/** Fast polygon intersection with an extent (used for area calculation)\n * @param {ol_extent_Extent} extent\n * @param {ol_geom_Polygon|ol_geom_MultiPolygon} polygon\n * @returns {ol_geom_Polygon|ol_geom_MultiPolygon|null} return null if not a polygon geometry\n */\nol_extent_intersection = function(extent, polygon) {\n  var poly = (polygon.getType() === 'Polygon');\n  if (!poly && polygon.getType() !== 'MultiPolygon') return null;\n  var geom = polygon.getCoordinates();\n  if (poly) geom = [geom];\n  geom.forEach(function(g) {\n    g.forEach(function(c) {\n      splitX(c, extent[0]);\n      splitX(c, extent[2]);\n      splitY(c, extent[1]);\n      splitY(c, extent[3]);\n    });\n  })\n  // Snap geom to the extent \n  geom.forEach(function(g) {\n    g.forEach(function(c) {\n      c.forEach(function(p) {\n        if (p[0]<extent[0]) p[0] = extent[0];\n        else if (p[0]>extent[2]) p[0] = extent[2];\n        if (p[1]<extent[1]) p[1] = extent[1];\n        else if (p[1]>extent[3]) p[1] = extent[3];\n      })\n    })\n  })\n  if (poly) {\n    return new ol_geom_Polygon(geom[0]);\n  } else {\n    return new ol_geom_MultiPolygon(geom);\n  }\n};\n})();\n\nexport { ol_extent_intersection }\nexport { ol_extent_intersection as extentIntersection }\n\n/** Add points along a segment\n * @param {ol_Coordinate} p1 \n * @param {ol_Coordinate} p2 \n * @param {number} d \n * @param {boolean} start include starting point, default true\n * @returns {Array<ol_Coordinate>}\n */\nvar ol_coordinate_sampleAt = function(p1, p2, d, start) {\n  var pts = [];\n  if (start!==false) pts.push(p1);\n  var dl = ol_coordinate_dist2d(p1,p2);\n  if (dl) {\n    var nb = Math.round(dl/d);\n    if (nb>1) {\n      var dx = (p2[0]-p1[0]) / nb;\n      var dy = (p2[1]-p1[1]) / nb;\n      for (var i=1; i<nb; i++) {\n        pts.push([p1[0] + dx*i, p1[1] + dy*i])\n      }\n    }\n  }\n  pts.push(p2);\n  return pts;\n};\nexport { ol_coordinate_sampleAt }\n\n/** Sample a LineString at a distance\n * @param {number} d\n * @returns {ol_geom_LineString}\n */\nol_geom_LineString.prototype.sampleAt = function(d) {\n  var line = this.getCoordinates();\n  var result = [];\n  for (var i=1; i<line.length; i++) {\n    result = result.concat(ol_coordinate_sampleAt(line[i-1], line[i], d, i===1));\n  }\n  return new ol_geom_LineString(result);\n};\n\n/** Sample a MultiLineString at a distance\n * @param {number} d\n * @returns {ol_geom_MultiLineString}\n */\nol_geom_MultiLineString.prototype.sampleAt = function(d) {\n  var lines = this.getCoordinates();\n  var result = [];\n  lines.forEach(function(p) {\n    var l = [];\n    for (var i=1; i<p.length; i++) {\n      l = l.concat(ol_coordinate_sampleAt(p[i-1], p[i], d, i===1));\n    }\n    result.push(l);\n  })\n  return new ol_geom_MultiLineString(result);\n};\n\n/** Sample a Polygon at a distance\n * @param {number} d\n * @returns {ol_geom_Polygon}\n */\nol_geom_Polygon.prototype.sampleAt = function(res) {\n  var poly = this.getCoordinates();\n  var result = [];\n  poly.forEach(function(p) {\n    var l = [];\n    for (var i=1; i<p.length; i++) {\n      l = l.concat(ol_coordinate_sampleAt(p[i-1], p[i], res, i===1));\n    }\n    result.push(l);\n  })\n  return new ol_geom_Polygon(result);\n};\n\n/** Sample a MultiPolygon at a distance\n * @param {number} res\n * @returns {ol_geom_MultiPolygon}\n */\nol_geom_MultiPolygon.prototype.sampleAt = function(res) {\n  var mpoly = this.getCoordinates();\n  var result = [];\n  mpoly.forEach(function(poly) {\n    var a = [];\n    result.push(a);\n    poly.forEach(function(p) {\n      var l = [];\n      for (var i=1; i<p.length; i++) {\n        l = l.concat(ol_coordinate_sampleAt(p[i-1], p[i], res, i===1));\n      }\n      a.push(l);\n    })\n  });\n  return new ol_geom_MultiPolygon(result);\n};\n\n/** Intersect a geometry using a circle\n * @param {ol_geom_Geometry} geom\n * @param {number} resolution circle resolution to sample the polygon on the circle, default 1\n * @returns {ol_geom_Geometry}\n */\nol_geom_Circle.prototype.intersection = function(geom, resolution) {\n  if (geom.sampleAt) {\n    var ext = ol_extent_buffer(this.getCenter().concat(this.getCenter()), this.getRadius());\n    geom = ol_extent_intersection(ext, geom);\n    geom = geom.simplify(resolution);\n    var c = this.getCenter();\n    var r = this.getRadius();\n    //var res = (resolution||1) * r / 100;\n    var g = geom.sampleAt(resolution).getCoordinates();\n    switch (geom.getType()) {\n      case 'Polygon': g = [g];\n        // fallthrough\n      case 'MultiPolygon': {\n        var hasout = false;\n        // var hasin = false;\n        var result = [];\n        g.forEach(function(poly) {\n          var a = [];\n          result.push(a);\n          poly.forEach(function(ring) {\n            var l = [];\n            a.push(l);\n            ring.forEach(function(p) {\n              var d = ol_coordinate_dist2d(c, p);\n              if (d > r) {\n                hasout = true;\n                l.push([\n                  c[0] + r / d * (p[0]-c[0]),\n                  c[1] + r / d * (p[1]-c[1])\n                ]);\n              } else {\n                // hasin = true;\n                l.push(p);\n              }\n            });\n          })\n        });\n        if (!hasout) return geom;\n        if (geom.getType() === 'Polygon') {\n          return new ol_geom_Polygon(result[0]);\n        } else {\n          return new ol_geom_MultiPolygon(result);\n        }\n      }\n    }\n  } else {\n    console.warn('[ol/geom/Circle~intersection] Unsupported geometry type: '+geom.getType());\n  }\n  return geom;\n};\n","import ol_style_Style from 'ol/style/Style.js'\nimport ol_style_Circle from 'ol/style/Circle.js'\nimport ol_style_Stroke from 'ol/style/Stroke.js'\nimport ol_style_Fill from 'ol/style/Fill.js'\n\nvar ol_style_Style_defaultStyle;\n\n(function() {\n\n// Style\nvar white = [255, 255, 255, 1];\nvar blue = [0, 153, 255, 1];\nvar width = 3;\n\nvar defaultEditStyle = [\n  new ol_style_Style({\n    stroke: new ol_style_Stroke({ color: white, width: width + 2 })\n  }),\n  new ol_style_Style({\n    image: new ol_style_Circle({\n      radius: width * 2,\n      fill: new ol_style_Fill({ color: blue }),\n      stroke: new ol_style_Stroke({ color: white, width: width / 2 })\n    }),\n    stroke: new ol_style_Stroke({ color: blue, width: width }),\n    fill: new ol_style_Fill({\n      color: [255, 255, 255, 0.5]\n    })\n  })\n];\n\n/**\n * Get the default style\n * @param {boolean|*} [edit] true to get editing style or a { color, fillColor } object, default get default blue style\n * @return {Array<ol.style.Style>}\n */\nol_style_Style_defaultStyle = function(edit) {\n  if (edit===true) {\n    return defaultEditStyle;\n  } else {\n    edit = edit || {};\n    var fill = new ol_style_Fill({\n      color: edit.fillColor || 'rgba(255,255,255,0.4)'\n    });\n    var stroke = new ol_style_Stroke({\n      color: edit.color || '#3399CC',\n      width: 1.25\n    });\n    var style = new ol_style_Style({\n      image: new ol_style_Circle({\n        fill: fill,\n        stroke: stroke,\n        radius: 5\n      }),\n      fill: fill,\n      stroke: stroke\n    });\n    return [ style ];\n  }\n};\n\n})();\n\nexport default ol_style_Style_defaultStyle\n","/*\tCopyright (c) 2018 Jean-Marc VIGLINO, \n\treleased under the CeCILL-B license (French BSD license)\n\t(http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).\n*/\n\nimport ol_interaction_Select from 'ol/interaction/Select.js'\nimport ol_source_Vector from 'ol/source/Vector.js'\n\n/** A Select interaction to delete features on click.\n * @constructor\n * @extends {ol_interaction_Interaction}\n * @fires deletestart\n * @fires deleteend\n * @param {Object} options ol.interaction.Select options\n */\nvar ol_interaction_Delete = class olinteractionDelete extends ol_interaction_Select {\n  constructor(options) {\n    super(options);\n    this.on('select', function (e) {\n      this.getFeatures().clear();\n      this.delete(e.selected);\n    }.bind(this));\n  }\n  /** Get vector source of the map\n   * @return {Array<ol.source.Vector>}\n   */\n  _getSources(layers) {\n    if (!this.getMap())\n      return [];\n    if (!layers)\n      layers = this.getMap().getLayers();\n    var sources = [];\n    layers.forEach(function (l) {\n      // LayerGroup\n      if (l.getLayers) {\n        sources = sources.concat(this._getSources(l.getLayers()));\n      } else {\n        if (l.getSource && l.getSource() instanceof ol_source_Vector) {\n          sources.push(l.getSource());\n        }\n      }\n    }.bind(this));\n    return sources;\n  }\n  /** Delete features: remove the features from the map (from all layers in the map)\n   * @param {ol.Collection<ol.Feature>|Array<ol.Feature>} features The features to delete\n   * @api\n   */\n  delete(features) {\n    if (features && (features.length || features.getLength())) {\n      this.dispatchEvent({ type: 'deletestart', features: features });\n      var delFeatures = [];\n      // Get the sources concerned\n      this._getSources().forEach(function (source) {\n        try {\n          // Try to delete features in the source\n          features.forEach(function (f) {\n            source.removeFeature(f);\n            delFeatures.push(f);\n          });\n        } catch (e) { /* ok */ }\n      });\n      this.dispatchEvent({ type: 'deleteend', features: delFeatures });\n    }\n  }\n}\n\nexport default ol_interaction_Delete","/*\tCopyright (c) 2016 Jean-Marc VIGLINO,\nreleased under the CeCILL-B license (French BSD license)\n(http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).\n*/\n\nimport ol_control_Button from \"./Button.js\";\n\n/** A simple push button control drawn as text\n * @constructor\n * @extends {ol_control_Button}\n * @param {Object=} options Control options.\n *\t@param {String} options.className class of the control\n*\t@param {String} options.title title of the control\n*\t@param {String} options.html html to insert in the control\n*\t@param {function} options.handleClick callback when control is clicked (or use change:active event)\n*/\nvar ol_control_TextButton = class olcontrolTextButton extends ol_control_Button {\n  constructor(options) {\n    options = options || {};\n    options.className = (options.className || '') + ' ol-text-button';\n    super(options);\n  }\n}\n\nexport default ol_control_TextButton\n","/*\tCopyright (c) 2016 Jean-Marc VIGLINO, \n  released under the CeCILL-B license (French BSD license)\n  (http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).\n*/\n\nimport ol_interaction_Interaction from 'ol/interaction/Interaction.js'\nimport ol_style_Style_defaultStyle from '../style/defaultStyle.js'\nimport ol_Collection from 'ol/Collection.js'\nimport ol_layer_Vector from 'ol/layer/Vector.js'\nimport ol_source_Vector from 'ol/source/Vector.js'\nimport ol_geom_Circle from 'ol/geom/Circle.js'\nimport {fromCircle as ol_geom_Polygon_fromCircle} from 'ol/geom/Polygon.js'\nimport ol_geom_Point from 'ol/geom/Point.js'\nimport ol_geom_LineString from 'ol/geom/LineString.js'\nimport ol_geom_Polygon from 'ol/geom/Polygon.js'\nimport ol_Feature from 'ol/Feature.js'\n\n/** Interaction rotate\n * @constructor\n * @extends {ol_interaction_Interaction}\n * @fires drawstart, drawing, drawend, drawcancel\n * @param {olx.interaction.TransformOptions} options\n *  @param {Array<ol.Layer>} options.source Destination source for the drawn features\n *  @param {ol.Collection<ol.Feature>} options.features Destination collection for the drawn features \n *  @param {ol.style.Style | Array.<ol.style.Style> | ol.style.StyleFunction | undefined} options.style style for the sketch\n *  @param {integer} options.sides number of sides, default 0 = circle\n *  @param { ol.events.ConditionType | undefined } options.condition A function that takes an ol.MapBrowserEvent and returns a boolean that event should be handled. By default module:ol/events/condition.always.\n *  @param { ol.events.ConditionType | undefined } options.squareCondition A function that takes an ol.MapBrowserEvent and returns a boolean to draw square features. Default test shift key\n *  @param { ol.events.ConditionType | undefined } options.centerCondition A function that takes an ol.MapBrowserEvent and returns a boolean to draw centered features. Default check Ctrl key\n *  @param { bool } options.canRotate Allow rotation when centered + square, default: true\n *  @param { string } [options.geometryName=geometry] \n *  @param { number } options.clickTolerance click tolerance on touch devices, default: 6\n *  @param { number } options.maxCircleCoordinates Maximum number of point on a circle, default: 100\n */\nvar ol_interaction_DrawRegular = class olinteractionDrawRegular extends ol_interaction_Interaction {\n  constructor(options) {\n    options = options || {}\n    \n    super({\n      handleEvent: function(e) { return self.handleEvent_(e) }\n    })\n\n    var self = this;\n\n    this.squaredClickTolerance_ = options.clickTolerance ? options.clickTolerance * options.clickTolerance : 36\n    this.maxCircleCoordinates_ = options.maxCircleCoordinates || 100\n\n    // Collection of feature to transform \n    this.features_ = options.features\n    // List of layers to transform \n    this.source_ = options.source\n    // Square condition\n    this.conditionFn_ = options.condition\n    // Square condition\n    this.squareFn_ = options.squareCondition\n    // Centered condition\n    this.centeredFn_ = options.centerCondition\n    // Allow rotation when centered + square\n    this.canRotate_ = (options.canRotate !== false)\n    // Specify custom geometry name\n    this.geometryName_ = options.geometryName || 'geometry'\n\n    // Number of sides (default=0: circle)\n    this.setSides(options.sides)\n\n    // Style\n    var defaultStyle = ol_style_Style_defaultStyle(true)\n\n    // Create a new overlay layer for the sketch\n    this.sketch_ = new ol_Collection()\n    this.overlayLayer_ = new ol_layer_Vector({\n      source: new ol_source_Vector({\n        features: this.sketch_,\n        useSpatialIndex: false\n      }),\n      name: 'DrawRegular overlay',\n      displayInLayerSwitcher: false,\n      style: options.style || defaultStyle\n    })\n  }\n  /**\n   * Remove the interaction from its current map, if any,  and attach it to a new\n   * map, if any. Pass `null` to just remove the interaction from the current map.\n   * @param {ol.Map} map Map.\n   * @api stable\n   */\n  setMap(map) {\n    if (this.getMap()) this.getMap().removeLayer(this.overlayLayer_)\n    super.setMap(map)\n    this.overlayLayer_.setMap(map)\n  }\n  /**\n   * Activate/deactivate the interaction\n   * @param {boolean}\n   * @api stable\n   */\n  setActive(b) {\n    this.reset()\n    super.setActive(b)\n  }\n  /**\n   * Reset the interaction\n   * @api stable\n   */\n  reset() {\n    if (this.overlayLayer_) this.overlayLayer_.getSource().clear()\n    this.started_ = false\n  }\n  /**\n   * Set the number of sides.\n   * @param {int} number of sides.\n   * @api stable\n   */\n  setSides(nb) {\n    nb = parseInt(nb)\n    this.sides_ = nb > 2 ? nb : 0\n  }\n  /**\n   * Allow rotation when centered + square\n   * @param {bool}\n   * @api stable\n   */\n  canRotate(b) {\n    if (b === true || b === false)\n      this.canRotate_ = b\n    return this.canRotate_\n  }\n  /**\n   * Get the number of sides.\n   * @return {int} number of sides.\n   * @api stable\n   */\n  getSides() {\n    return this.sides_\n  }\n  /** Get geom of the current drawing\n  * @return {ol.geom.Polygon | ol.geom.Point}\n  */\n  getGeom_() {\n    this.overlayLayer_.getSource().clear()\n    if (!this.center_)\n      return false\n\n    var g\n    if (this.coord_) {\n      var center = this.center_\n      var coord = this.coord_\n\n      // Specific case: circle\n      var d, dmax, r, circle, centerPx\n      if (!this.sides_ && this.square_ && !this.centered_) {\n        center = [(coord[0] + center[0]) / 2, (coord[1] + center[1]) / 2]\n        d = [coord[0] - center[0], coord[1] - center[1]]\n        r = Math.sqrt(d[0] * d[0] + d[1] * d[1])\n        circle = new ol_geom_Circle(center, r, 'XY')\n        // Optimize points on the circle\n        centerPx = this.getMap().getPixelFromCoordinate(center)\n        dmax = Math.max(100, Math.abs(centerPx[0] - this.coordPx_[0]), Math.abs(centerPx[1] - this.coordPx_[1]))\n        dmax = Math.min(this.maxCircleCoordinates_, Math.round(dmax / 3))\n        return ol_geom_Polygon_fromCircle(circle, dmax, 0)\n      } else {\n        var hasrotation = this.canRotate_ && this.centered_ && this.square_\n        d = [coord[0] - center[0], coord[1] - center[1]]\n        if (this.square_ && !hasrotation) {\n          //var d = [coord[0] - center[0], coord[1] - center[1]];\n          var dm = Math.max(Math.abs(d[0]), Math.abs(d[1]))\n          coord = [\n            center[0] + (d[0] > 0 ? dm : -dm),\n            center[1] + (d[1] > 0 ? dm : -dm)\n          ]\n        }\n        r = Math.sqrt(d[0] * d[0] + d[1] * d[1])\n        if (r > 0) {\n          circle = new ol_geom_Circle(center, r, 'XY')\n          var a\n          if (hasrotation)\n            a = Math.atan2(d[1], d[0])\n          else\n            a = this.startAngle[this.sides_] || this.startAngle['default']\n\n          if (this.sides_) {\n            g = ol_geom_Polygon_fromCircle(circle, this.sides_, a)\n          } else {\n            // Optimize points on the circle\n            centerPx = this.getMap().getPixelFromCoordinate(this.center_)\n            dmax = Math.max(100, Math.abs(centerPx[0] - this.coordPx_[0]), Math.abs(centerPx[1] - this.coordPx_[1]))\n            dmax = Math.min(this.maxCircleCoordinates_, Math.round(dmax / (this.centered_ ? 3 : 5)))\n            g = ol_geom_Polygon_fromCircle(circle, dmax, 0)\n          }\n\n          if (hasrotation)\n            return g\n\n          // Scale polygon to fit extent\n          var ext = g.getExtent()\n          if (!this.centered_)\n            center = this.center_\n          else\n            center = [2 * this.center_[0] - this.coord_[0], 2 * this.center_[1] - this.coord_[1]]\n          var scx = (center[0] - coord[0]) / (ext[0] - ext[2])\n          var scy = (center[1] - coord[1]) / (ext[1] - ext[3])\n          if (this.square_) {\n            var sc = Math.min(Math.abs(scx), Math.abs(scy))\n            scx = Math.sign(scx) * sc\n            scy = Math.sign(scy) * sc\n          }\n          var t = [center[0] - ext[0] * scx, center[1] - ext[1] * scy]\n\n          g.applyTransform(function (g1, g2, dim) {\n            for (var i = 0; i < g1.length; i += dim) {\n              g2[i] = g1[i] * scx + t[0]\n              g2[i + 1] = g1[i + 1] * scy + t[1]\n            }\n            return g2\n          })\n          return g\n        }\n      }\n    }\n\n    // No geom => return a point\n    return new ol_geom_Point(this.center_)\n  }\n  /** Draw sketch\n  * @return {ol.Feature} The feature being drawn.\n  */\n  drawSketch_(evt) {\n    this.overlayLayer_.getSource().clear()\n    if (evt) {\n      this.square_ = this.squareFn_ ? this.squareFn_(evt) : evt.originalEvent.shiftKey\n      this.centered_ = this.centeredFn_ ? this.centeredFn_(evt) : evt.originalEvent.metaKey || evt.originalEvent.ctrlKey\n      var g = this.getGeom_()\n      if (g) {\n        var f = this.feature_\n\n        //f.setGeometry (g);\n        if (g.getType() === 'Polygon')\n          f.getGeometry().setCoordinates(g.getCoordinates())\n        this.overlayLayer_.getSource().addFeature(f)\n        if (this.coord_\n          && this.square_\n          && ((this.canRotate_ && this.centered_ && this.coord_) || (!this.sides_ && !this.centered_))) {\n          this.overlayLayer_.getSource().addFeature(new ol_Feature(new ol_geom_LineString([this.center_, this.coord_])))\n        }\n        return f\n      }\n    }\n  }\n  /** Draw sketch (Point)\n  */\n  drawPoint_(pt, noclear) {\n    if (!noclear) {\n      this.overlayLayer_.getSource().clear()\n    }\n    this.overlayLayer_.getSource().addFeature(new ol_Feature(new ol_geom_Point(pt)))\n  }\n  /**\n   * @param {ol.MapBrowserEvent} evt Map browser event.\n   */\n  handleEvent_(evt) {\n    var dx, dy\n    // Event date time\n    this._eventTime = new Date();\n    switch (evt.type) {\n      case \"pointerdown\": {\n        if (this.conditionFn_ && !this.conditionFn_(evt)) break\n        this.downPx_ = evt.pixel\n        this.start_(evt)\n        // Test long touch\n        var dt = 500\n        this._longTouch = false\n        setTimeout(function () {\n          this._longTouch = (new Date() - this._eventTime > .9 * dt)\n          if (this._longTouch)\n            this.handleMoveEvent_(evt)\n        }.bind(this), dt)\n        this.lastEvent = evt.type;\n        break\n      }\n      case \"pointerup\": {\n        // Started and fisrt move\n        if (this.started_ && this.coord_) {\n          dx = this.downPx_[0] - evt.pixel[0]\n          dy = this.downPx_[1] - evt.pixel[1]\n\n          if (dx * dx + dy * dy <= this.squaredClickTolerance_) {\n            // The pointer has moved\n            if (this.lastEvent == \"pointerdown\" || this.lastEvent == \"pointermove\" || this.lastEvent == \"keydown\") {\n              this.end_(evt)\n            }\n\n            // On touch device there is no move event : terminate = click on the same point\n            else {\n              dx = this.upPx_[0] - evt.pixel[0]\n              dy = this.upPx_[1] - evt.pixel[1]\n              if (dx * dx + dy * dy <= this.squaredClickTolerance_) {\n                this.end_(evt)\n              } else {\n                this.handleMoveEvent_(evt)\n                this.drawPoint_(evt.coordinate, true)\n              }\n            }\n          }\n        }\n        this.upPx_ = evt.pixel\n        break\n      }\n      case \"pointerdrag\": {\n        if (this.started_) {\n          var centerPx = this.getMap().getPixelFromCoordinate(this.center_)\n          dx = centerPx[0] - evt.pixel[0]\n          dy = centerPx[1] - evt.pixel[1]\n          if (dx * dx + dy * dy <= this.squaredClickTolerance_) {\n            this.reset()\n          }\n        }\n        return !this._longTouch\n        // break;\n      }\n      case \"pointermove\": {\n        if (this.started_) {\n          dx = this.downPx_[0] - evt.pixel[0]\n          dy = this.downPx_[1] - evt.pixel[1]\n          if (dx * dx + dy * dy > this.squaredClickTolerance_) {\n            this.handleMoveEvent_(evt)\n            this.lastEvent = evt.type\n          }\n        } else {\n          this.drawPoint_(evt.coordinate)\n        }\n        break\n      }\n      default: {\n        // Prevent zoom or other event on click/singleclick/dblclick\n        if (this.started_ && (evt.type === 'click' || evt.type === 'singleclick' || evt.type === 'dblclick')) {\n          //evt.stopPropagation();\n          return false\n        }\n        this.lastEvent = evt.type\n\n        break\n      }\n    }\n    return true\n  }\n  /** Stop drawing.\n   */\n  finishDrawing() {\n    if (this.started_ && this.coord_) {\n      this.end_({ pixel: this.upPx_, coordinate: this.coord_ })\n    }\n  }\n  /**\n   * @param {ol.MapBrowserEvent} evt Event.\n   */\n  handleMoveEvent_(evt) {\n    if (this.started_) {\n      this.coord_ = evt.coordinate\n      this.coordPx_ = evt.pixel\n      var f = this.drawSketch_(evt)\n      this.dispatchEvent({\n        type: 'drawing',\n        feature: f,\n        pixel: evt.pixel,\n        startCoordinate: this.center_,\n        coordinate: evt.coordinate,\n        square: this.square_,\n        centered: this.centered_\n      })\n    } else {\n      this.drawPoint_(evt.coordinate)\n    }\n  }\n  /** Start an new draw\n   * @param {ol.MapBrowserEvent} evt Map browser event.\n   * @return {boolean} `false` to stop the drag sequence.\n   */\n  start_(evt) {\n    if (!this.started_) {\n      this.started_ = true\n      this.center_ = evt.coordinate\n      this.coord_ = null\n      var f = this.feature_ = new ol_Feature({})\n      f.setGeometryName(this.geometryName_ || 'geometry')\n      f.setGeometry(new ol_geom_Polygon([[evt.coordinate, evt.coordinate, evt.coordinate]]))\n      this.drawSketch_(evt)\n      this.dispatchEvent({ type: 'drawstart', feature: f, pixel: evt.pixel, coordinate: evt.coordinate })\n    } else {\n      this.coord_ = evt.coordinate\n    }\n  }\n  /** End drawing\n   * @param {ol.MapBrowserEvent} evt Map browser event.\n   * @return {boolean} `false` to stop the drag sequence.\n   */\n  end_(evt) {\n    this.coord_ = evt.coordinate\n    this.started_ = false\n    if (this.coord_ && (this.center_[0] !== this.coord_[0] || this.center_[1] !== this.coord_[1])) {\n      var f = this.feature_\n\n      f.setGeometry(this.getGeom_())\n      if (this.source_)\n        this.source_.addFeature(f)\n      else if (this.features_)\n        this.features_.push(f)\n      this.dispatchEvent({ type: 'drawend', feature: f, pixel: evt.pixel, coordinate: evt.coordinate, square: this.square_, centered: this.centered_ })\n    } else {\n      this.dispatchEvent({ type: 'drawcancel', feature: null, pixel: evt.pixel, coordinate: evt.coordinate, square: this.square_, centered: this.centered_ })\n    }\n\n    this.center_ = this.coord_ = null\n    this.drawSketch_()\n  }\n}\n\n/** Default start angle array for each sides\n*/\nol_interaction_DrawRegular.prototype.startAngle = {\n  'default':Math.PI/2,\n  3: -Math.PI/2,\n  4: Math.PI/4\n};\n\nexport default ol_interaction_DrawRegular\n","import ol_source_Vector from 'ol/source/Vector.js'\n\n;(function () {\n  var clear = ol_source_Vector.prototype.clear;\n\n  /** Overwrite ol/source/Vector clear to fire clearstart / clearend event\n   */\n  ol_source_Vector.prototype.clear = function(opt_fast) {\n    this.dispatchEvent({ type: 'clearstart' });\n    clear.call(this, opt_fast)\n    this.dispatchEvent({ type: 'clearend' });\n  };\n})();\n","import ol_Collection from 'ol/Collection.js'\nimport ol_interaction_Interaction from 'ol/interaction/Interaction.js'\nimport ol_source_Vector from 'ol/source/Vector.js'\nimport {unByKey as ol_Observable_unByKey} from 'ol/Observable.js'\nimport { ol_coordinate_equal } from '../geom/GeomUtils.js'\n\nimport '../source/Vector.js'\n\n/** Undo/redo interaction\n * @constructor\n * @extends {ol_interaction_Interaction}\n * @fires undo\n * @fires redo\n * @fires stack:add\n * @fires stack:remove\n * @fires stack:clear\n * @param {Object} options\n *  @param {number=} options.maxLength max undo stack length (0=Infinity), default Infinity\n *  @param {Array<ol.Layer>} options.layers array of layers to undo/redo\n */\nvar ol_interaction_UndoRedo = class olinteractionUndoRedo extends ol_interaction_Interaction {\n  constructor(options) {\n    options = options || {}\n\n    super({\n      handleEvent: function () {\n        return true\n      }\n    })\n\n    //array of layers to undo/redo\n    this._layers = options.layers\n\n    this._undoStack = new ol_Collection()\n    this._redoStack = new ol_Collection()\n    // Zero level stack\n    this._undo = []\n    this._redo = []\n    this._undoStack.on('add', function (e) {\n      if (e.element.level === undefined) {\n        e.element.level = this._level\n        if (!e.element.level) {\n          e.element.view = {\n            center: this.getMap().getView().getCenter(),\n            zoom: this.getMap().getView().getZoom()\n          }\n          this._undo.push(e.element)\n        }\n      } else {\n        if (!e.element.level)\n          this._undo.push(this._redo.shift())\n      }\n      if (!e.element.level) {\n        this.dispatchEvent({\n          type: 'stack:add',\n          action: e.element\n        })\n      }\n      this._reduce()\n    }.bind(this))\n    this._undoStack.on('remove', function (e) {\n      if (!e.element.level) {\n        if (this._doShift) {\n          this._undo.shift()\n        } else if (this._abort) {\n          this._undo.pop()\n        } else {\n          if (this._undo.length) {\n            this._redo.push(this._undo.pop())\n          }\n        }\n        if (!this._doClear) {\n          this.dispatchEvent({\n            type: 'stack:remove',\n            action: e.element,\n            shift: this._doShift,\n            abort: this._abort\n          })\n        }\n      }\n    }.bind(this))\n    // Block counter\n    this._block = 0\n    this._level = 0\n    // Shift an undo action ?\n    this._doShift = false\n    // Start recording\n    this._record = true\n    // Custom definitions\n    this._defs = {}\n  }\n  /** Add a custom undo/redo\n   * @param {string} action the action key name\n   * @param {function} undoFn function called when undoing\n   * @param {function} redoFn function called when redoing\n   * @api\n   */\n  define(action, undoFn, redoFn) {\n    this._defs[action] = { undo: undoFn, redo: redoFn }\n  }\n  /** Get first level undo / redo length\n   * @param {string} [type] get redo stack length, default get undo\n   * @return {number}\n   */\n  length(type) {\n    return (type === 'redo') ? this._redo.length : this._undo.length\n  }\n  /** Set undo stack max length\n   * @param {number} length\n   */\n  setMaxLength(length) {\n    length = parseInt(length)\n    if (length && length < 0)\n      length = 0\n    this.set('maxLength', length)\n    this._reduce()\n  }\n  /** Get undo / redo size (includes all block levels)\n   * @param {string} [type] get redo stack length, default get undo\n   * @return {number}\n   */\n  size(type) {\n    return (type === 'redo') ? this._redoStack.getLength() : this._undoStack.getLength()\n  }\n  /** Set undo stack max size\n   * @param {number} size\n   */\n  setMaxSize(size) {\n    size = parseInt(size)\n    if (size && size < 0)\n      size = 0\n    this.set('maxSize', size)\n    this._reduce()\n  }\n  /** Reduce stack: shift undo to set size\n   * @private\n   */\n  _reduce() {\n    if (this.get('maxLength')) {\n      while (this.length() > this.get('maxLength')) {\n        this.shift()\n      }\n    }\n    if (this.get('maxSize')) {\n      while (this.length() > 1 && this.size() > this.get('maxSize')) {\n        this.shift()\n      }\n    }\n  }\n  /** Get first level undo / redo first level stack\n   * @param {string} [type] get redo stack, default get undo\n   * @return {Array<*>}\n   */\n  getStack(type) {\n    return (type === 'redo') ? this._redo : this._undo\n  }\n  /** Add a new custom undo/redo\n   * @param {string} action the action key name\n   * @param {any} prop an object that will be passed in the undo/redo functions of the action\n   * @param {string} name action name\n   * @return {boolean} true if the action is defined\n   */\n  push(action, prop, name) {\n    if (this._defs[action]) {\n      this._undoStack.push({\n        type: action,\n        name: name,\n        custom: true,\n        prop: prop\n      })\n      return true\n    } else {\n      console.warn('[UndoRedoInteraction]: \"' + action + '\" is not defined.')\n      return false\n    }\n  }\n  /** Remove undo action from the beginning of the stack.\n   * The action is not returned.\n   */\n  shift() {\n    this._doShift = true\n    var a = this._undoStack.removeAt(0)\n    this._doShift = false\n    // Remove all block\n    if (a.type === 'blockstart') {\n      a = this._undoStack.item(0)\n      while (this._undoStack.getLength() && a.level > 0) {\n        this._undoStack.removeAt(0)\n        a = this._undoStack.item(0)\n      }\n    }\n  }\n  /** Activate or deactivate the interaction, ie. records or not events on the map.\n   * @param {boolean} active\n   * @api stable\n   */\n  setActive(active) {\n    super.setActive(active)\n    this._record = active\n  }\n  /**\n   * Remove the interaction from its current map, if any, and attach it to a new\n   * map, if any. Pass `null` to just remove the interaction from the current map.\n   * @param {ol.Map} map Map.\n   * @api stable\n   */\n  setMap(map) {\n    if (this._mapListener) {\n      this._mapListener.forEach(function (l) { ol_Observable_unByKey(l) })\n    }\n    this._mapListener = []\n    super.setMap(map)\n    // Watch blocks\n    if (map) {\n      this._mapListener.push(map.on('undoblockstart', this.blockStart.bind(this)))\n      this._mapListener.push(map.on('undoblockend', this.blockEnd.bind(this)))\n    }\n    // Watch sources\n    this._watchSources()\n    this._watchInteractions()\n  }\n  /** Watch for changes in the map sources\n   * @private\n   */\n  _watchSources() {\n    var map = this.getMap()\n    // Clear listeners\n    if (this._sourceListener) {\n      this._sourceListener.forEach(function (l) { ol_Observable_unByKey(l) })\n    }\n    this._sourceListener = []\n\n    var self = this\n\n    // Ges vector layers \n    function getVectorLayers(layers, init) {\n      if (!init) {\n        init = []\n      }\n      layers.forEach(function (l) {\n        if (l.getSource && l.getSource() instanceof ol_source_Vector) {\n          if (!self._layers || self._layers.indexOf(l) >= 0) {\n            init.push(l)\n          }\n        } else if (l.getLayers) {\n          getVectorLayers(l.getLayers(), init)\n        }\n      })\n      return init\n    }\n\n    if (map) {\n      // Watch the vector sources in the map \n      var vectors = getVectorLayers(map.getLayers())\n      vectors.forEach((function (l) {\n        var s = l.getSource()\n        this._sourceListener.push(s.on(['addfeature', 'removefeature'], this._onAddRemove.bind(this)))\n        this._sourceListener.push(s.on('clearstart', function () {\n          this.blockStart('clear')\n        }.bind(this)))\n        this._sourceListener.push(s.on('clearend', this.blockEnd.bind(this)))\n      }).bind(this))\n\n      // Watch new inserted/removed\n      this._sourceListener.push(map.getLayers().on(['add', 'remove'], this._watchSources.bind(this)))\n    }\n  }\n  /** Watch for interactions\n   * @private\n   */\n  _watchInteractions() {\n    var map = this.getMap()\n    // Clear listeners\n    if (this._interactionListener) {\n      this._interactionListener.forEach(function (l) { ol_Observable_unByKey(l) })\n    }\n    this._interactionListener = []\n\n    if (map) {\n      // Watch the interactions in the map \n      map.getInteractions().forEach((function (i) {\n        this._interactionListener.push(i.on(\n          ['setattributestart', 'modifystart', 'modifyend', 'rotatestart', 'rotateend', 'translatestart', 'translateend', 'scalestart', 'scaleend', 'deletestart', 'deleteend', 'beforesplit', 'aftersplit'],\n          this._onInteraction.bind(this)\n        ))\n      }).bind(this))\n\n      // Watch new inserted / unwatch removed\n      this._interactionListener.push(map.getInteractions().on(\n        ['add', 'remove'],\n        this._watchInteractions.bind(this)\n      ))\n    }\n  }\n  /** A feature is added / removed\n   */\n  _onAddRemove(e) {\n    if (this._record) {\n      this._redoStack.clear()\n      this._redo.length = 0\n      this._undoStack.push({\n        type: e.type,\n        source: e.target,\n        feature: e.feature\n      })\n    }\n  }\n  /** Perform an interaction\n   * @private\n   */\n  _onInteraction(e) {\n    var fn = this._onInteraction[e.type]\n    if (fn)\n      fn.call(this, e)\n  }\n  /** Start an undo block\n   * @param {string} [name] name f the action\n   * @api\n   */\n  blockStart(name) {\n    this._redoStack.clear()\n    this._redo.length = 0\n    this._undoStack.push({\n      type: 'blockstart',\n      name: name\n    })\n    this._level++\n  }\n  /** End an undo block\n   * @api\n   */\n  blockEnd() {\n    this._undoStack.push({ type: 'blockend' })\n    this._level--\n  }\n  /** handle undo/redo\n   * @private\n   */\n  _handleDo(e, undo) {\n    // Not active\n    if (!this.getActive())\n      return\n\n    // Stop recording while undoing\n    this._record = false\n    if (e.custom) {\n      if (this._defs[e.type]) {\n        if (undo)\n          this._defs[e.type].undo(e.prop)\n        else\n          this._defs[e.type].redo(e.prop)\n      } else {\n        console.warn('[UndoRedoInteraction]: \"' + e.type + '\" is not defined.')\n      }\n    } else {\n      switch (e.type) {\n        case 'addfeature': {\n          if (undo)\n            e.source.removeFeature(e.feature)\n          else\n            e.source.addFeature(e.feature)\n          break\n        }\n        case 'removefeature': {\n          if (undo)\n            e.source.addFeature(e.feature)\n          else\n            e.source.removeFeature(e.feature)\n          break\n        }\n        case 'changegeometry': {\n          var geom = e.feature.getGeometry()\n          e.feature.setGeometry(e.oldGeom)\n          e.oldGeom = geom\n          break\n        }\n        case 'changeattribute': {\n          var newp = e.newProperties\n          var oldp = e.oldProperties\n          for (var p in oldp) {\n            if (oldp === undefined)\n              e.feature.unset(p)\n            else\n              e.feature.set(p, oldp[p])\n          }\n          e.oldProperties = newp\n          e.newProperties = oldp\n          break\n        }\n        case 'blockstart': {\n          this._block += undo ? -1 : 1\n          break\n        }\n        case 'blockend': {\n          this._block += undo ? 1 : -1\n          break\n        }\n        default: {\n          console.warn('[UndoRedoInteraction]: \"' + e.type + '\" is not defined.')\n        }\n      }\n    }\n\n    // Handle block\n    if (this._block < 0)\n      this._block = 0\n    if (this._block) {\n      if (undo)\n        this.undo()\n      else\n        this.redo()\n    }\n    this._record = true\n\n    // Dispatch event\n    this.dispatchEvent({\n      type: undo ? 'undo' : 'redo',\n      action: e\n    })\n  }\n  /** Undo last operation\n   * @api\n   */\n  undo() {\n    var e = this._undoStack.item(this._undoStack.getLength() - 1)\n    if (!e) {\n      return\n    }\n    this._redoStack.push(e)\n    this._undoStack.pop()\n    this._handleDo(e, true)\n  }\n  /** Abort last operation (remove from stack but no redo)\n   * @api\n   */\n  abort() {\n    var e = this._undoStack.item(this._undoStack.getLength() - 1)\n    if (!e) {\n      return\n    }\n    this._abort = true\n    var action = this._undoStack.pop()\n    while (action.level !== 0) {\n      action = this._undoStack.pop()\n    }\n    this._abort = false\n  }\n  /** Redo last operation\n   * @api\n   */\n  redo() {\n    var e = this._redoStack.item(this._redoStack.getLength() - 1)\n    if (!e)\n      return\n    this._undoStack.push(e)\n    this._redoStack.pop()\n    this._handleDo(e, false)\n  }\n  /** Clear undo stack\n   * @api\n   */\n  clear() {\n    this._doClear = true\n    this._undo.length = this._redo.length = 0\n    this._undoStack.clear()\n    this._redoStack.clear()\n    this._doClear = false\n    this.dispatchEvent({ type: 'stack:clear' })\n  }\n  /** Check if undo is avaliable\n   * @return {number} the number of undo\n   * @api\n   */\n  hasUndo() {\n    return this._undoStack.getLength()\n  }\n  /** Check if redo is avaliable\n   * @return {number} the number of redo\n   * @api\n   */\n  hasRedo() {\n    return this._redoStack.getLength()\n  }\n}\n\n/** Set attribute\n * @private\n */\nol_interaction_UndoRedo.prototype._onInteraction.setattributestart = function(e) {\n  this.blockStart(e.target.get('name') || 'setattribute');\n  var newp = Object.assign({}, e.properties);\n  e.features.forEach(function(f) {\n    var oldp = {};\n    for (var p in newp) {\n      oldp[p] = f.get(p);\n    }\n    this._undoStack.push({\n      type: 'changeattribute', \n      feature: f,\n      newProperties: newp,\n      oldProperties: oldp\n    });\n  }.bind(this));\n  this.blockEnd();\n};\n\nol_interaction_UndoRedo.prototype._onInteraction.rotatestart = \nol_interaction_UndoRedo.prototype._onInteraction.translatestart = \nol_interaction_UndoRedo.prototype._onInteraction.scalestart = \nol_interaction_UndoRedo.prototype._onInteraction.modifystart = function (e) {\n  this._modify = {\n    coordinate: e.coordinate,\n    blockStart: e.type.replace(/start$/,''),\n    modify: []\n  }\n  e.features.forEach(function(m) {\n    this._modify.modify.push({ \n      type: 'changegeometry', \n      feature: m, \n      oldGeom: m.getGeometry().clone(),\n    });\n  }.bind(this));\n};\n\n/** @private\n */\nol_interaction_UndoRedo.prototype._onInteraction.translateend =\nol_interaction_UndoRedo.prototype._onInteraction.rotateend = \nol_interaction_UndoRedo.prototype._onInteraction.scaleend =\nol_interaction_UndoRedo.prototype._onInteraction.modifyend = function(e) {\n  if (!this._modify) return;\n  // Handle modification\n  if (e.type==='modifyend') {\n    e.transformed = !e.coordinate || !ol_coordinate_equal(this._modify.coordinate, e.coordinate);\n    if (!e.transformed) {\n      this._modify.modify.forEach(function(m) {\n        if (m.feature.getGeometry().getFlatCoordinates().length !== m.oldGeom.getFlatCoordinates().length) {\n          e.transformed = true;\n        }\n        console.log(m.feature.getGeometry().getFlatCoordinates().length, m.oldGeom.getFlatCoordinates().length)\n      })\n    }\n  }\n  if (e.type==='translateend' && e.coordinate) {\n    e.transformed = !ol_coordinate_equal(this._modify.coordinate, e.coordinate);\n  }\n  // prevent undo if nothing appends\n  if (e.transformed) {\n    this.blockStart(this._modify.blockStart);\n    this._modify.modify.forEach(function(m) {\n      this._undoStack.push(m);\n    }.bind(this));\n    this.blockEnd();\n  }\n  this._modify = null\n}\n\n/** @private\n */\nol_interaction_UndoRedo.prototype._onInteraction.beforesplit = function() {\n  // Check modify before split\n  var l = this._undoStack.getLength();\n  if (l>2 \n    && this._undoStack.item(l-1).type === 'blockend'\n    && this._undoStack.item(l-2).type === 'changegeometry') {\n    this._undoStack.pop();\n  } else {\n    this.blockStart('split');\n  }\n};\nol_interaction_UndoRedo.prototype._onInteraction.deletestart = function() {\n  this.blockStart('delete');\n}\n\n\n/** @private\n */\nol_interaction_UndoRedo.prototype._onInteraction.aftersplit =\nol_interaction_UndoRedo.prototype._onInteraction.deleteend =\nol_interaction_UndoRedo.prototype.blockEnd;\n\nexport default ol_interaction_UndoRedo\n","/*\tCopyright (c) 2016 Jean-Marc VIGLINO,\n  released under the CeCILL-B license (French BSD license)\n  (http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).\n*/\n\nimport ol_control_Button from './Button.js'\n\n/** A simple toggle control\n * The control can be created with an interaction to control its activation.\n *\n * @constructor\n * @extends {ol_control_Button}\n * @fires change:active, change:disable\n * @param {Object=} options Control options.\n *  @param {String} [options.className] class of the control\n *  @param {String} [options.classButton] class of the button\n *  @param {String} [options.title] title of the control\n *  @param {String} [options.html] html to insert in the control\n *  @param {ol.interaction} [options.interaction] interaction associated with the control\n *  @param {bool} [options.active] the control is created active, default false\n *  @param {bool} [options.disable] the control is created disabled, default false\n *  @param {ol.control.Bar} [options.bar] a subbar associated with the control (drawn when active if control is nested in a ol.control.Bar)\n *  @param {bool} [options.autoActive] the control will activate when shown in an ol.control.Bar, default false\n *  @param {function} [options.onToggle] callback when control is clicked (or use change:active event)\n *  @param {Object} [options.attributes] key value attributes to set on the button element\n */\nvar ol_control_Toggle = class olcontrolToggle extends ol_control_Button {\n  constructor(options) {\n    options = options || {};\n\n    if (options.toggleFn) {\n      options.onToggle = options.toggleFn; // compat old version\n    }\n    options.handleClick = function () {\n      self.toggle();\n      if (options.onToggle) {\n        options.onToggle.call(self, self.getActive());\n      }\n    };\n    options.className = (options.className || '') + ' ol-toggle';\n    super(options);\n\n    var self = this;\n\n    this.interaction_ = options.interaction;\n    if (this.interaction_) {\n      this.interaction_.setActive(options.active);\n      this.interaction_.on(\"change:active\", function () {\n        self.setActive(self.interaction_.getActive());\n      });\n    }\n\n    this.set(\"title\", options.title);\n\n    this.set(\"autoActivate\", options.autoActivate);\n    if (options.bar) {\n      this.setSubBar(options.bar);\n    }\n\n    this.setActive(options.active);\n    this.setDisable(options.disable);\n  }\n  /**\n   * Set the map instance the control is associated with\n   * and add interaction attached to it to this map.\n   * @param {_ol_Map_} map The map instance.\n   */\n  setMap(map) {\n    if (!map && this.getMap()) {\n      if (this.interaction_) {\n        this.getMap().removeInteraction(this.interaction_);\n      }\n      if (this.subbar_)\n        this.getMap().removeControl(this.subbar_);\n    }\n\n    super.setMap(map);\n\n    if (map) {\n      if (this.interaction_)\n        map.addInteraction(this.interaction_);\n      if (this.subbar_)\n        map.addControl(this.subbar_);\n    }\n  }\n  /** Get the subbar associated with a control\n   * @return {ol_control_Bar}\n   */\n  getSubBar() {\n    return this.subbar_;\n  }\n  /** Set the subbar associated with a control\n   * @param {ol_control_Bar} [bar] a subbar if none remove the current subbar\n   */\n  setSubBar(bar) {\n    var map = this.getMap();\n    if (map && this.subbar_) {\n      map.removeControl(this.subbar_);\n    }\n    this.subbar_ = bar;\n    if (bar) {\n      this.subbar_.setTarget(this.element);\n      this.subbar_.element.classList.add(\"ol-option-bar\");\n      if (map) {\n        map.addControl(this.subbar_);\n      }\n      // Accessibility\n      if (bar.element.id) {\n        this.getButtonElement().setAttribute('aria-controls', bar.element.id);\n        bar.element.setAttribute('aria-labelledby', this.getButtonElement().id);\n        this.on('change:active', function (e) {\n          this.getButtonElement().setAttribute('aria-expanded', !!e.active);\n        }.bind(this));\n      }\n    }\n  }\n  /**\n   * Test if the control is disabled.\n   * @return {bool}\n   * @api stable\n   */\n  getDisable() {\n    var button = this.element.querySelector('button');\n    return button && button.disabled;\n  }\n  /** Disable the control. If disable, the control will be deactivated too.\n  * @param {bool} b disable (or enable) the control, default false (enable)\n  */\n  setDisable(b) {\n    if (this.getDisable() == b) return;\n    this.element.querySelector('button').disabled = b;\n    if (b && this.getActive()) this.setActive(false);\n\n    this.dispatchEvent({ type: 'change:disable', key: 'disable', oldValue: !b, disable: b });\n  }\n  /**\n   * Test if the control is active.\n   * @return {bool}.\n   * @api stable\n   */\n  getActive() {\n    return this.element.classList.contains(\"ol-active\");\n  }\n  /** Toggle control state active/deactive\n   */\n  toggle() {\n    if (this.getActive())\n      this.setActive(false);\n    else\n      this.setActive(true);\n  }\n  /** Change control state\n   * @param {bool} b activate or deactivate the control, default false\n   */\n  setActive(b) {\n    if (this.interaction_) {\n      this.interaction_.setActive(b);\n    }\n    if (this.subbar_) {\n      this.subbar_.setActive(b);\n    }\n    if (this.getActive() === b) {\n      return;\n    }\n    if (b) {\n      this.element.classList.add('ol-active');\n    } else {\n      this.element.classList.remove('ol-active');\n    }\n    this.button_.setAttribute('aria-pressed', b);\n\n    this.dispatchEvent({ type: 'change:active', key: 'active', oldValue: !b, active: b });\n  }\n  /** Set the control interaction\n  * @param {_ol_interaction_} i interaction to associate with the control\n  */\n  setInteraction(i) {\n    this.interaction_ = i;\n  }\n  /** Get the control interaction\n  * @return {_ol_interaction_} interaction associated with the control\n  */\n  getInteraction() {\n    return this.interaction_;\n  }\n}\n\nexport default ol_control_Toggle\n","/*\tCopyright (c) 2016 Jean-Marc VIGLINO, \n  released under the CeCILL-B license (French BSD license)\n  (http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).\n*/\n\nimport ol_interaction_Interaction from 'ol/interaction/Interaction.js'\nimport ol_style_Style from 'ol/style/Style.js'\nimport ol_style_Stroke from 'ol/style/Stroke.js'\nimport ol_source_Vector from 'ol/source/Vector.js'\nimport ol_style_Fill from 'ol/style/Fill.js'\nimport ol_style_Circle from 'ol/style/Circle.js'\nimport ol_layer_Vector from 'ol/layer/Vector.js'\nimport ol_geom_Point from 'ol/geom/Point.js'\nimport ol_Feature from 'ol/Feature.js'\nimport ol_geom_LineString from 'ol/geom/LineString.js'\nimport {ol_coordinate_dist2d} from \"../geom/GeomUtils.js\";\nimport '../geom/LineStringSplitAt.js'\nimport ol_ext_element from '../util/element.js'\n\n/** Interaction split interaction for splitting feature geometry\n * @constructor\n * @extends {ol_interaction_Interaction}\n * @fires  beforesplit, aftersplit, pointermove\n * @param {*} \n *  @param {ol.source.Vector|Array<ol.source.Vector>} [options.sources] a list of source to split (configured with useSpatialIndex set to true), if none use map visible layers.\n *  @param {ol.Collection.<ol.Feature>} options.features collection of feature to split (instead of a list of sources)\n *  @param {integer} options.snapDistance distance (in px) to snap to an object, default 25px\n *\t@param {string|undefined} options.cursor cursor name to display when hovering an objet\n *  @param {function|undefined} options.filter a filter that takes a feature and return true if it can be clipped, default always split.\n *  @param ol_style_Style | Array<ol_style_Style> | false | undefined} options.featureStyle Style for the selected features, choose false if you don't want feature selection. By default the default edit style is used.\n *  @param {ol_style_Style | Array<ol_style_Style> | undefined} options.sketchStyle Style for the sektch features. \n *  @param {function|undefined} options.tolerance Distance between the calculated intersection and a vertex on the source geometry below which the existing vertex will be used for the split.  Default is 1e-10.\n */\nvar ol_interaction_Split = class olinteractionSplit extends ol_interaction_Interaction {\n  constructor(options) {\n    if (!options)\n      options = {}\n\n    super({\n      handleEvent: function (e) {\n        switch (e.type) {\n          case \"singleclick\":\n            return this.handleDownEvent(e)\n          case \"pointermove\":\n            return this.handleMoveEvent(e)\n          default:\n            return true\n        }\n        //return true;\n      }\n    })\n\n    // Snap distance (in px)\n    this.snapDistance_ = options.snapDistance || 25\n    // Split tolerance between the calculated intersection and the geometry\n    this.tolerance_ = options.tolerance || 1e-10\n    // Cursor\n    this.cursor_ = options.cursor\n\n    // List of source to split\n    this.setSources(options.sources)\n\n    if (options.features) {\n      if (!this.sources_) this.sources_ = [];\n      this.sources_.push(new ol_source_Vector({ features: options.features }))\n    }\n\n    // Get all features candidate\n    this.filterSplit_ = options.filter || function () { return true }\n\n    // Default style\n    var white = [255, 255, 255, 1]\n    var blue = [0, 153, 255, 1]\n    var width = 3\n    var fill = new ol_style_Fill({ color: 'rgba(255,255,255,0.4)' })\n    var stroke = new ol_style_Stroke({\n      color: '#3399CC',\n      width: 1.25\n    })\n    var sketchStyle = [\n      new ol_style_Style({\n        image: new ol_style_Circle({\n          fill: fill,\n          stroke: stroke,\n          radius: 5\n        }),\n        fill: fill,\n        stroke: stroke\n      })\n    ]\n    var featureStyle = [\n      new ol_style_Style({\n        stroke: new ol_style_Stroke({\n          color: white,\n          width: width + 2\n        })\n      }),\n      new ol_style_Style({\n        image: new ol_style_Circle({\n          radius: 2 * width,\n          fill: new ol_style_Fill({\n            color: blue\n          }),\n          stroke: new ol_style_Stroke({\n            color: white,\n            width: width / 2\n          })\n        }),\n        stroke: new ol_style_Stroke({\n          color: blue,\n          width: width\n        })\n      }),\n    ]\n\n    // Custom style\n    if (options.sketchStyle)\n      sketchStyle = options.sketchStyle instanceof Array ? options.sketchStyle : [options.sketchStyle]\n    if (options.featureStyle)\n      featureStyle = options.featureStyle instanceof Array ? options.featureStyle : [options.featureStyle]\n\n    // Create a new overlay for the sketch\n    this.overlayLayer_ = new ol_layer_Vector({\n      source: new ol_source_Vector({\n        useSpatialIndex: false\n      }),\n      name: 'Split overlay',\n      displayInLayerSwitcher: false,\n      style: function (f) {\n        if (f._sketch_)\n          return sketchStyle\n        else\n          return featureStyle\n      }\n    })\n\n  }\n  /**\n   * Remove the interaction from its current map, if any,  and attach it to a new\n   * map, if any. Pass `null` to just remove the interaction from the current map.\n   * @param {ol.Map} map Map.\n   * @api stable\n   */\n  setMap(map) {\n    if (this.getMap()) {\n      this.getMap().removeLayer(this.overlayLayer_)\n    }\n    super.setMap(map)\n    this.overlayLayer_.setMap(map)\n  }\n  /** Get sources to split features in\n   * @return {Array<ol.source.Vector>}\n   */\n  getSources() {\n    if (!this.sources_ && this.getMap()) {\n      var sources = []\n      var getSources = function (layers) {\n        layers.forEach(function (layer) {\n          if (layer.getVisible()) {\n            if (layer.getSource && layer.getSource() instanceof ol_source_Vector) {\n              sources.unshift(layer.getSource())\n            } else if (layer.getLayers) {\n              getSources(layer.getLayers())\n            }\n          }\n        })\n      }\n      getSources(this.getMap().getLayers())\n      return sources\n    }\n    return this.sources_ || []\n  }\n  /** Set sources to split features in\n   * @param {ol.source.Vector|Array<ol.source.Vector>|boolean} [sources] if not defined get all map vector sources\n   */\n  setSources(sources) {\n    this.sources_ = sources ? (sources instanceof Array ? sources || false : [sources]) : false\n  }\n  /** Get closest feature at pixel\n   * @param {ol.Pixel}\n   * @return {ol.feature}\n   * @private\n   */\n  getClosestFeature(e) {\n    var source, f, c, g, d = this.snapDistance_ + 1\n    // Look for closest point in the sources\n    this.getSources().forEach(function (si) {\n      var fi = si.getClosestFeatureToCoordinate(e.coordinate)\n      if (fi && fi.getGeometry().splitAt) {\n        var ci = fi.getGeometry().getClosestPoint(e.coordinate)\n        var gi = new ol_geom_LineString([e.coordinate, ci])\n        var di = gi.getLength() / e.frameState.viewState.resolution\n        if (di < d) {\n          source = si\n          d = di\n          f = fi\n          g = gi\n          c = ci\n        }\n      }\n    })\n    // Snap ?\n    if (d > this.snapDistance_) {\n      return false\n    } else {\n      // Snap to node\n      var coord = this.getNearestCoord(c, f.getGeometry().getCoordinates())\n      var p = this.getMap().getPixelFromCoordinate(coord)\n      if (ol_coordinate_dist2d(e.pixel, p) < this.snapDistance_) {\n        c = coord\n      }\n      //\n      return { source: source, feature: f, coord: c, link: g }\n    }\n  }\n  /** Get nearest coordinate in a list\n  * @param {ol.coordinate} pt the point to find nearest\n  * @param {Array<ol.coordinate>} coords list of coordinates\n  * @return {ol.coordinate} the nearest coordinate in the list\n  */\n  getNearestCoord(pt, coords) {\n    var d, dm = Number.MAX_VALUE, p0\n    for (var i = 0; i < coords.length; i++) {\n      d = ol_coordinate_dist2d(pt, coords[i])\n      if (d < dm) {\n        dm = d\n        p0 = coords[i]\n      }\n    }\n    return p0\n  }\n  /**\n   * @param {ol.MapBrowserEvent} evt Map browser event.\n   * @return {boolean} `true` to start the drag sequence.\n   */\n  handleDownEvent(evt) {\n    // Something to split ?\n    var current = this.getClosestFeature(evt)\n\n    if (current) {\n      var self = this\n      self.overlayLayer_.getSource().clear()\n      var split = current.feature.getGeometry().splitAt(current.coord, this.tolerance_)\n      var i\n      if (split.length > 1) {\n        var tosplit = []\n        for (i = 0; i < split.length; i++) {\n          var f = current.feature.clone()\n          f.setGeometry(split[i])\n          tosplit.push(f)\n        }\n        self.dispatchEvent({ type: 'beforesplit', original: current.feature, features: tosplit })\n        current.source.dispatchEvent({ type: 'beforesplit', original: current.feature, features: tosplit })\n        current.source.removeFeature(current.feature)\n        for (i = 0; i < tosplit.length; i++) {\n          current.source.addFeature(tosplit[i])\n        }\n        self.dispatchEvent({ type: 'aftersplit', original: current.feature, features: tosplit })\n        current.source.dispatchEvent({ type: 'aftersplit', original: current.feature, features: tosplit })\n      }\n    }\n    return false\n  }\n  /**\n   * @param {ol.MapBrowserEvent} evt Event.\n   */\n  handleMoveEvent(e) {\n    var map = e.map\n    this.overlayLayer_.getSource().clear()\n    var current = this.getClosestFeature(e)\n\n    if (current && this.filterSplit_(current.feature)) {\n      var p, l\n      // Draw sketch\n      this.overlayLayer_.getSource().addFeature(current.feature)\n      p = new ol_Feature(new ol_geom_Point(current.coord))\n      p._sketch_ = true\n      this.overlayLayer_.getSource().addFeature(p)\n      //\n      l = new ol_Feature(current.link)\n      l._sketch_ = true\n      this.overlayLayer_.getSource().addFeature(l)\n      // move event\n      this.dispatchEvent({\n        type: 'pointermove',\n        coordinate: e.coordinate,\n        frameState: e.frameState,\n        originalEvent: e.originalEvent,\n        map: e.map,\n        pixel: e.pixel,\n        feature: current.feature,\n        linkGeometry: current.link\n      })\n    } else {\n      this.dispatchEvent(e)\n    }\n\n    var element = map.getTargetElement()\n    if (this.cursor_) {\n      if (current) {\n        if (element.style.cursor != this.cursor_) {\n          this.previousCursor_ = element.style.cursor\n          ol_ext_element.setCursor(element, this.cursor_)\n        }\n      } else if (this.previousCursor_ !== undefined) {\n        ol_ext_element.setCursor(element, this.previousCursor_)\n        this.previousCursor_ = undefined\n      }\n    }\n  }\n}\n\nexport default ol_interaction_Split\n","/**\n * @module ol/interaction/Draw\n */\nimport Circle from '../geom/Circle.js';\nimport Event from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport Feature from '../Feature.js';\nimport GeometryCollection from '../geom/GeometryCollection.js';\nimport InteractionProperty from './Property.js';\nimport LineString from '../geom/LineString.js';\nimport MapBrowserEvent from '../MapBrowserEvent.js';\nimport MapBrowserEventType from '../MapBrowserEventType.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport PointerInteraction from './Pointer.js';\nimport Polygon, {fromCircle, makeRegular} from '../geom/Polygon.js';\nimport VectorLayer from '../layer/Vector.js';\nimport VectorSource from '../source/Vector.js';\nimport {FALSE, TRUE} from '../functions.js';\nimport {\n  always,\n  never,\n  noModifierKeys,\n  shiftKeyOnly,\n} from '../events/condition.js';\nimport {\n  boundingExtent,\n  getBottomLeft,\n  getBottomRight,\n  getTopLeft,\n  getTopRight,\n} from '../extent.js';\nimport {clamp, squaredDistance, toFixed} from '../math.js';\nimport {createEditingStyle} from '../style/Style.js';\nimport {\n  distance,\n  squaredDistance as squaredCoordinateDistance,\n} from '../coordinate.js';\nimport {fromUserCoordinate, getUserProjection} from '../proj.js';\nimport {getStrideForLayout} from '../geom/SimpleGeometry.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../geom/Geometry.js\").Type} type Geometry type of\n * the geometries being drawn with this instance.\n * @property {number} [clickTolerance=6] The maximum distance in pixels between\n * \"down\" and \"up\" for a \"up\" event to be considered a \"click\" event and\n * actually add a point/vertex to the geometry being drawn.  The default of `6`\n * was chosen for the draw interaction to behave correctly on mouse as well as\n * on touch devices.\n * @property {import(\"../Collection.js\").default<Feature>} [features]\n * Destination collection for the drawn features.\n * @property {VectorSource} [source] Destination source for\n * the drawn features.\n * @property {number} [dragVertexDelay=500] Delay in milliseconds after pointerdown\n * before the current vertex can be dragged to its exact position.\n * @property {number} [snapTolerance=12] Pixel distance for snapping to the\n * drawing finish. Must be greater than `0`.\n * @property {boolean} [stopClick=false] Stop click, singleclick, and\n * doubleclick events from firing during drawing.\n * @property {number} [maxPoints] The number of points that can be drawn before\n * a polygon ring or line string is finished. By default there is no\n * restriction.\n * @property {number} [minPoints] The number of points that must be drawn\n * before a polygon ring or line string can be finished. Default is `3` for\n * polygon rings and `2` for line strings.\n * @property {import(\"../events/condition.js\").Condition} [finishCondition] A function\n * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether the drawing can be finished. Not used when drawing\n * POINT or MULTI_POINT geometries.\n * @property {import(\"../style/Style.js\").StyleLike|import(\"../style/flat.js\").FlatStyleLike} [style]\n * Style for sketch features. The draw interaction can have up to three sketch features, depending on the mode.\n * It will always contain a feature with a `Point` geometry that corresponds to the current cursor position.\n * If the mode is `LineString` or `Polygon`, and there is at least one drawn point, it will also contain a feature with\n * a `LineString` geometry that corresponds to the line between the already drawn points and the current cursor position.\n * If the mode is `Polygon`, and there is at least one drawn point, it will also contain a feature with a `Polygon`\n * geometry that corresponds to the polygon between the already drawn points and the current cursor position\n * (note that this polygon has only two points if only one point is drawn).\n * If the mode is `Circle`, and there is one point drawn, it will also contain a feature with a `Circle` geometry whose\n * center is the drawn point and the radius is determined by the distance between the drawn point and the cursor.\n * @property {GeometryFunction} [geometryFunction]\n * Function that is called when a geometry's coordinates are updated.\n * @property {string} [geometryName] Geometry name to use for features created\n * by the draw interaction.\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * By default {@link module:ol/events/condition.noModifierKeys}, i.e. a click,\n * adds a vertex or deactivates freehand drawing.\n * @property {boolean} [freehand=false] Operate in freehand mode for lines,\n * polygons, and circles.  This makes the interaction always operate in freehand\n * mode and takes precedence over any `freehandCondition` option.\n * @property {import(\"../events/condition.js\").Condition} [freehandCondition]\n * Condition that activates freehand drawing for lines and polygons. This\n * function takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and\n * returns a boolean to indicate whether that event should be handled. The\n * default is {@link module:ol/events/condition.shiftKeyOnly}, meaning that the\n * Shift key activates freehand drawing.\n * @property {boolean|import(\"../events/condition.js\").Condition} [trace=false] Trace a portion of another geometry.\n * Ignored when in freehand mode.\n * @property {VectorSource} [traceSource] Source for features to trace.  If tracing is active and a `traceSource` is\n * not provided, the interaction's `source` will be used.  Tracing requires that the interaction is configured with\n * either a `traceSource` or a `source`.\n * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch\n * overlay.\n * @property {import(\"../geom/Geometry.js\").GeometryLayout} [geometryLayout='XY'] Layout of the\n * feature geometries created by the draw interaction.\n */\n\n/**\n * Coordinate type when drawing points.\n * @typedef {import(\"../coordinate.js\").Coordinate} PointCoordType\n */\n\n/**\n * Coordinate type when drawing lines.\n * @typedef {Array<import(\"../coordinate.js\").Coordinate>} LineCoordType\n */\n\n/**\n * Coordinate type when drawing polygons.\n * @typedef {Array<Array<import(\"../coordinate.js\").Coordinate>>} PolyCoordType\n */\n\n/**\n * Types used for drawing coordinates.\n * @typedef {PointCoordType|LineCoordType|PolyCoordType} SketchCoordType\n */\n\n/**\n * @typedef {Object} TraceState\n * @property {boolean} active Tracing active.\n * @property {import(\"../pixel.js\").Pixel} [startPx] The initially clicked pixel location.\n * @property {Array<TraceTarget>} [targets] Targets available for tracing.\n * @property {number} [targetIndex] The index of the currently traced target.  A value of -1 indicates\n * that no trace target is active.\n */\n\n/**\n * @typedef {Object} TraceTarget\n * @property {Array<import(\"../coordinate.js\").Coordinate>} coordinates Target coordinates.\n * @property {boolean} ring The target coordinates are a linear ring.\n * @property {number} startIndex The index of first traced coordinate.  A fractional index represents an\n * edge intersection.  Index values for rings will wrap (may be negative or larger than coordinates length).\n * @property {number} endIndex The index of last traced coordinate.  Details from startIndex also apply here.\n */\n\n/**\n * Function that takes an array of coordinates and an optional existing geometry\n * and a projection as arguments, and returns a geometry. The optional existing\n * geometry is the geometry that is returned when the function is called without\n * a second argument.\n * @typedef {function(!SketchCoordType, import(\"../geom/SimpleGeometry.js\").default,\n *     import(\"../proj/Projection.js\").default):\n *     import(\"../geom/SimpleGeometry.js\").default} GeometryFunction\n */\n\n/**\n * @typedef {'Point' | 'LineString' | 'Polygon' | 'Circle'} Mode\n * Draw mode.  This collapses multi-part geometry types with their single-part\n * cousins.\n */\n\n/**\n * @enum {string}\n */\nconst DrawEventType = {\n  /**\n   * Triggered upon feature draw start\n   * @event DrawEvent#drawstart\n   * @api\n   */\n  DRAWSTART: 'drawstart',\n  /**\n   * Triggered upon feature draw end\n   * @event DrawEvent#drawend\n   * @api\n   */\n  DRAWEND: 'drawend',\n  /**\n   * Triggered upon feature draw abortion\n   * @event DrawEvent#drawabort\n   * @api\n   */\n  DRAWABORT: 'drawabort',\n};\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/Draw~Draw} instances are\n * instances of this type.\n */\nexport class DrawEvent extends Event {\n  /**\n   * @param {DrawEventType} type Type.\n   * @param {Feature} feature The feature drawn.\n   */\n  constructor(type, feature) {\n    super(type);\n\n    /**\n     * The feature being drawn.\n     * @type {Feature}\n     * @api\n     */\n    this.feature = feature;\n  }\n}\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} coordinate The coordinate.\n * @param {Array<Feature>} features The candidate features.\n * @return {Array<TraceTarget>} The trace targets.\n */\nfunction getTraceTargets(coordinate, features) {\n  /**\n   * @type {Array<TraceTarget>}\n   */\n  const targets = [];\n\n  for (let i = 0; i < features.length; ++i) {\n    const feature = features[i];\n    const geometry = feature.getGeometry();\n    appendGeometryTraceTargets(coordinate, geometry, targets);\n  }\n\n  return targets;\n}\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} a One coordinate.\n * @param {import(\"../coordinate.js\").Coordinate} b Another coordinate.\n * @return {number} The squared distance between the two coordinates.\n */\nfunction getSquaredDistance(a, b) {\n  return squaredDistance(a[0], a[1], b[0], b[1]);\n}\n\n/**\n * @param {LineCoordType} coordinates The ring coordinates.\n * @param {number} index The index.  May be wrapped.\n * @return {import(\"../coordinate.js\").Coordinate} The coordinate.\n */\nfunction getCoordinate(coordinates, index) {\n  const count = coordinates.length;\n  if (index < 0) {\n    return coordinates[index + count];\n  }\n  if (index >= count) {\n    return coordinates[index - count];\n  }\n  return coordinates[index];\n}\n\n/**\n * Get the cumulative squared distance along a ring path.  The end index index may be \"wrapped\" and it may\n * be less than the start index to indicate the direction of travel.  The start and end index may have\n * a fractional part to indicate a point between two coordinates.\n * @param {LineCoordType} coordinates Ring coordinates.\n * @param {number} startIndex The start index.\n * @param {number} endIndex The end index.\n * @return {number} The cumulative squared distance along the ring path.\n */\nfunction getCumulativeSquaredDistance(coordinates, startIndex, endIndex) {\n  let lowIndex, highIndex;\n  if (startIndex < endIndex) {\n    lowIndex = startIndex;\n    highIndex = endIndex;\n  } else {\n    lowIndex = endIndex;\n    highIndex = startIndex;\n  }\n  const lowWholeIndex = Math.ceil(lowIndex);\n  const highWholeIndex = Math.floor(highIndex);\n\n  if (lowWholeIndex > highWholeIndex) {\n    // both start and end are on the same segment\n    const start = interpolateCoordinate(coordinates, lowIndex);\n    const end = interpolateCoordinate(coordinates, highIndex);\n    return getSquaredDistance(start, end);\n  }\n\n  let sd = 0;\n\n  if (lowIndex < lowWholeIndex) {\n    const start = interpolateCoordinate(coordinates, lowIndex);\n    const end = getCoordinate(coordinates, lowWholeIndex);\n    sd += getSquaredDistance(start, end);\n  }\n\n  if (highWholeIndex < highIndex) {\n    const start = getCoordinate(coordinates, highWholeIndex);\n    const end = interpolateCoordinate(coordinates, highIndex);\n    sd += getSquaredDistance(start, end);\n  }\n\n  for (let i = lowWholeIndex; i < highWholeIndex - 1; ++i) {\n    const start = getCoordinate(coordinates, i);\n    const end = getCoordinate(coordinates, i + 1);\n    sd += getSquaredDistance(start, end);\n  }\n\n  return sd;\n}\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} coordinate The coordinate.\n * @param {import(\"../geom/Geometry.js\").default} geometry The candidate geometry.\n * @param {Array<TraceTarget>} targets The trace targets.\n */\nfunction appendGeometryTraceTargets(coordinate, geometry, targets) {\n  if (geometry instanceof LineString) {\n    appendTraceTarget(coordinate, geometry.getCoordinates(), false, targets);\n    return;\n  }\n  if (geometry instanceof MultiLineString) {\n    const coordinates = geometry.getCoordinates();\n    for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n      appendTraceTarget(coordinate, coordinates[i], false, targets);\n    }\n    return;\n  }\n  if (geometry instanceof Polygon) {\n    const coordinates = geometry.getCoordinates();\n    for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n      appendTraceTarget(coordinate, coordinates[i], true, targets);\n    }\n    return;\n  }\n  if (geometry instanceof MultiPolygon) {\n    const polys = geometry.getCoordinates();\n    for (let i = 0, ii = polys.length; i < ii; ++i) {\n      const coordinates = polys[i];\n      for (let j = 0, jj = coordinates.length; j < jj; ++j) {\n        appendTraceTarget(coordinate, coordinates[j], true, targets);\n      }\n    }\n    return;\n  }\n  if (geometry instanceof GeometryCollection) {\n    const geometries = geometry.getGeometries();\n    for (let i = 0; i < geometries.length; ++i) {\n      appendGeometryTraceTargets(coordinate, geometries[i], targets);\n    }\n    return;\n  }\n  // other types cannot be traced\n}\n\n/**\n * @typedef {Object} TraceTargetUpdateInfo\n * @property {number} index The new target index.\n * @property {number} endIndex The new segment end index.\n */\n\n/**\n * @type {TraceTargetUpdateInfo}\n */\nconst sharedUpdateInfo = {index: -1, endIndex: NaN};\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} coordinate The coordinate.\n * @param {TraceState} traceState The trace state.\n * @param {import(\"../Map.js\").default} map The map.\n * @param {number} snapTolerance The snap tolerance.\n * @return {TraceTargetUpdateInfo} Information about the new trace target.  The returned\n * object is reused between calls and must not be modified by the caller.\n */\nfunction getTraceTargetUpdate(coordinate, traceState, map, snapTolerance) {\n  const x = coordinate[0];\n  const y = coordinate[1];\n\n  let closestTargetDistance = Infinity;\n\n  let newTargetIndex = -1;\n  let newEndIndex = NaN;\n\n  for (\n    let targetIndex = 0;\n    targetIndex < traceState.targets.length;\n    ++targetIndex\n  ) {\n    const target = traceState.targets[targetIndex];\n    const coordinates = target.coordinates;\n\n    let minSegmentDistance = Infinity;\n    let endIndex;\n    for (\n      let coordinateIndex = 0;\n      coordinateIndex < coordinates.length - 1;\n      ++coordinateIndex\n    ) {\n      const start = coordinates[coordinateIndex];\n      const end = coordinates[coordinateIndex + 1];\n      const rel = getPointSegmentRelationship(x, y, start, end);\n      if (rel.squaredDistance < minSegmentDistance) {\n        minSegmentDistance = rel.squaredDistance;\n        endIndex = coordinateIndex + rel.along;\n      }\n    }\n\n    if (minSegmentDistance < closestTargetDistance) {\n      closestTargetDistance = minSegmentDistance;\n      if (target.ring && traceState.targetIndex === targetIndex) {\n        // same target, maintain the same trace direction\n        if (target.endIndex > target.startIndex) {\n          // forward trace\n          if (endIndex < target.startIndex) {\n            endIndex += coordinates.length;\n          }\n        } else if (target.endIndex < target.startIndex) {\n          // reverse trace\n          if (endIndex > target.startIndex) {\n            endIndex -= coordinates.length;\n          }\n        }\n      }\n      newEndIndex = endIndex;\n      newTargetIndex = targetIndex;\n    }\n  }\n\n  const newTarget = traceState.targets[newTargetIndex];\n  let considerBothDirections = newTarget.ring;\n  if (traceState.targetIndex === newTargetIndex && considerBothDirections) {\n    // only consider switching trace direction if close to the start\n    const newCoordinate = interpolateCoordinate(\n      newTarget.coordinates,\n      newEndIndex,\n    );\n    const pixel = map.getPixelFromCoordinate(newCoordinate);\n    if (distance(pixel, traceState.startPx) > snapTolerance) {\n      considerBothDirections = false;\n    }\n  }\n\n  if (considerBothDirections) {\n    const coordinates = newTarget.coordinates;\n    const count = coordinates.length;\n    const startIndex = newTarget.startIndex;\n    const endIndex = newEndIndex;\n    if (startIndex < endIndex) {\n      const forwardDistance = getCumulativeSquaredDistance(\n        coordinates,\n        startIndex,\n        endIndex,\n      );\n      const reverseDistance = getCumulativeSquaredDistance(\n        coordinates,\n        startIndex,\n        endIndex - count,\n      );\n      if (reverseDistance < forwardDistance) {\n        newEndIndex -= count;\n      }\n    } else {\n      const reverseDistance = getCumulativeSquaredDistance(\n        coordinates,\n        startIndex,\n        endIndex,\n      );\n      const forwardDistance = getCumulativeSquaredDistance(\n        coordinates,\n        startIndex,\n        endIndex + count,\n      );\n      if (forwardDistance < reverseDistance) {\n        newEndIndex += count;\n      }\n    }\n  }\n\n  sharedUpdateInfo.index = newTargetIndex;\n  sharedUpdateInfo.endIndex = newEndIndex;\n  return sharedUpdateInfo;\n}\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} coordinate The clicked coordinate.\n * @param {Array<import(\"../coordinate.js\").Coordinate>} coordinates The geometry component coordinates.\n * @param {boolean} ring The coordinates represent a linear ring.\n * @param {Array<TraceTarget>} targets The trace targets.\n */\nfunction appendTraceTarget(coordinate, coordinates, ring, targets) {\n  const x = coordinate[0];\n  const y = coordinate[1];\n  for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n    const start = coordinates[i];\n    const end = coordinates[i + 1];\n    const rel = getPointSegmentRelationship(x, y, start, end);\n    if (rel.squaredDistance === 0) {\n      const index = i + rel.along;\n      targets.push({\n        coordinates: coordinates,\n        ring: ring,\n        startIndex: index,\n        endIndex: index,\n      });\n      return;\n    }\n  }\n}\n\n/**\n * @typedef {Object} PointSegmentRelationship\n * @property {number} along The closest point expressed as a fraction along the segment length.\n * @property {number} squaredDistance The squared distance of the point to the segment.\n */\n\n/**\n * @type {PointSegmentRelationship}\n */\nconst sharedRel = {along: 0, squaredDistance: 0};\n\n/**\n * @param {number} x The point x.\n * @param {number} y The point y.\n * @param {import(\"../coordinate.js\").Coordinate} start The segment start.\n * @param {import(\"../coordinate.js\").Coordinate} end The segment end.\n * @return {PointSegmentRelationship} The point segment relationship.  The returned object is\n * shared between calls and must not be modified by the caller.\n */\nfunction getPointSegmentRelationship(x, y, start, end) {\n  const x1 = start[0];\n  const y1 = start[1];\n  const x2 = end[0];\n  const y2 = end[1];\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  let along = 0;\n  let px = x1;\n  let py = y1;\n  if (dx !== 0 || dy !== 0) {\n    along = clamp(((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy), 0, 1);\n    px += dx * along;\n    py += dy * along;\n  }\n\n  sharedRel.along = along;\n  sharedRel.squaredDistance = toFixed(squaredDistance(x, y, px, py), 10);\n  return sharedRel;\n}\n\n/**\n * @param {LineCoordType} coordinates The coordinates.\n * @param {number} index The index.  May be fractional and may wrap.\n * @return {import(\"../coordinate.js\").Coordinate} The interpolated coordinate.\n */\nfunction interpolateCoordinate(coordinates, index) {\n  const count = coordinates.length;\n\n  let startIndex = Math.floor(index);\n  const along = index - startIndex;\n  if (startIndex >= count) {\n    startIndex -= count;\n  } else if (startIndex < 0) {\n    startIndex += count;\n  }\n\n  let endIndex = startIndex + 1;\n  if (endIndex >= count) {\n    endIndex -= count;\n  }\n\n  const start = coordinates[startIndex];\n  const x0 = start[0];\n  const y0 = start[1];\n  const end = coordinates[endIndex];\n  const dx = end[0] - x0;\n  const dy = end[1] - y0;\n\n  return [x0 + dx * along, y0 + dy * along];\n}\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'drawabort'|'drawend'|'drawstart', DrawEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'drawabort'|'drawend'|'drawstart', Return>} DrawOnSignature\n */\n\n/**\n * @classdesc\n * Interaction for drawing feature geometries.\n *\n * @fires DrawEvent\n * @api\n */\nclass Draw extends PointerInteraction {\n  /**\n   * @param {Options} options Options.\n   */\n  constructor(options) {\n    const pointerOptions = /** @type {import(\"./Pointer.js\").Options} */ (\n      options\n    );\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n\n    super(pointerOptions);\n\n    /***\n     * @type {DrawOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {DrawOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {DrawOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.shouldHandle_ = false;\n\n    /**\n     * @type {import(\"../pixel.js\").Pixel}\n     * @private\n     */\n    this.downPx_ = null;\n\n    /**\n     * @type {ReturnType<typeof setTimeout>}\n     * @private\n     */\n    this.downTimeout_;\n\n    /**\n     * @type {number|undefined}\n     * @private\n     */\n    this.lastDragTime_;\n\n    /**\n     * Pointer type of the last pointermove event\n     * @type {string}\n     * @private\n     */\n    this.pointerType_;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.freehand_ = false;\n\n    /**\n     * Target source for drawn features.\n     * @type {VectorSource|null}\n     * @private\n     */\n    this.source_ = options.source ? options.source : null;\n\n    /**\n     * Target collection for drawn features.\n     * @type {import(\"../Collection.js\").default<Feature>|null}\n     * @private\n     */\n    this.features_ = options.features ? options.features : null;\n\n    /**\n     * Pixel distance for snapping.\n     * @type {number}\n     * @private\n     */\n    this.snapTolerance_ = options.snapTolerance ? options.snapTolerance : 12;\n\n    /**\n     * Geometry type.\n     * @type {import(\"../geom/Geometry.js\").Type}\n     * @private\n     */\n    this.type_ = /** @type {import(\"../geom/Geometry.js\").Type} */ (\n      options.type\n    );\n\n    /**\n     * Drawing mode (derived from geometry type.\n     * @type {Mode}\n     * @private\n     */\n    this.mode_ = getMode(this.type_);\n\n    /**\n     * Stop click, singleclick, and doubleclick events from firing during drawing.\n     * Default is `false`.\n     * @type {boolean}\n     * @private\n     */\n    this.stopClick_ = !!options.stopClick;\n\n    /**\n     * The number of points that must be drawn before a polygon ring or line\n     * string can be finished.  The default is 3 for polygon rings and 2 for\n     * line strings.\n     * @type {number}\n     * @private\n     */\n    this.minPoints_ = options.minPoints\n      ? options.minPoints\n      : this.mode_ === 'Polygon'\n        ? 3\n        : 2;\n\n    /**\n     * The number of points that can be drawn before a polygon ring or line string\n     * is finished. The default is no restriction.\n     * @type {number}\n     * @private\n     */\n    this.maxPoints_ =\n      this.mode_ === 'Circle'\n        ? 2\n        : options.maxPoints\n          ? options.maxPoints\n          : Infinity;\n\n    /**\n     * A function to decide if a potential finish coordinate is permissible\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.finishCondition_ = options.finishCondition\n      ? options.finishCondition\n      : TRUE;\n\n    /**\n     * @private\n     * @type {import(\"../geom/Geometry.js\").GeometryLayout}\n     */\n    this.geometryLayout_ = options.geometryLayout\n      ? options.geometryLayout\n      : 'XY';\n\n    let geometryFunction = options.geometryFunction;\n    if (!geometryFunction) {\n      const mode = this.mode_;\n      if (mode === 'Circle') {\n        /**\n         * @param {!LineCoordType} coordinates The coordinates.\n         * @param {import(\"../geom/SimpleGeometry.js\").default|undefined} geometry Optional geometry.\n         * @param {import(\"../proj/Projection.js\").default} projection The view projection.\n         * @return {import(\"../geom/SimpleGeometry.js\").default} A geometry.\n         */\n        geometryFunction = function (coordinates, geometry, projection) {\n          const circle = geometry\n            ? /** @type {Circle} */ (geometry)\n            : new Circle([NaN, NaN]);\n          const center = fromUserCoordinate(coordinates[0], projection);\n          const squaredLength = squaredCoordinateDistance(\n            center,\n            fromUserCoordinate(coordinates[coordinates.length - 1], projection),\n          );\n          circle.setCenterAndRadius(\n            center,\n            Math.sqrt(squaredLength),\n            this.geometryLayout_,\n          );\n          const userProjection = getUserProjection();\n          if (userProjection) {\n            circle.transform(projection, userProjection);\n          }\n          return circle;\n        };\n      } else {\n        let Constructor;\n        if (mode === 'Point') {\n          Constructor = Point;\n        } else if (mode === 'LineString') {\n          Constructor = LineString;\n        } else if (mode === 'Polygon') {\n          Constructor = Polygon;\n        }\n        /**\n         * @param {!LineCoordType} coordinates The coordinates.\n         * @param {import(\"../geom/SimpleGeometry.js\").default|undefined} geometry Optional geometry.\n         * @param {import(\"../proj/Projection.js\").default} projection The view projection.\n         * @return {import(\"../geom/SimpleGeometry.js\").default} A geometry.\n         */\n        geometryFunction = function (coordinates, geometry, projection) {\n          if (geometry) {\n            if (mode === 'Polygon') {\n              if (coordinates[0].length) {\n                // Add a closing coordinate to match the first\n                geometry.setCoordinates(\n                  [coordinates[0].concat([coordinates[0][0]])],\n                  this.geometryLayout_,\n                );\n              } else {\n                geometry.setCoordinates([], this.geometryLayout_);\n              }\n            } else {\n              geometry.setCoordinates(coordinates, this.geometryLayout_);\n            }\n          } else {\n            geometry = new Constructor(coordinates, this.geometryLayout_);\n          }\n          return geometry;\n        };\n      }\n    }\n\n    /**\n     * @type {GeometryFunction}\n     * @private\n     */\n    this.geometryFunction_ = geometryFunction;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.dragVertexDelay_ =\n      options.dragVertexDelay !== undefined ? options.dragVertexDelay : 500;\n\n    /**\n     * Finish coordinate for the feature (first point for polygons, last point for\n     * linestrings).\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    this.finishCoordinate_ = null;\n\n    /**\n     * Sketch feature.\n     * @type {Feature<import('../geom/SimpleGeometry.js').default>}\n     * @private\n     */\n    this.sketchFeature_ = null;\n\n    /**\n     * Sketch point.\n     * @type {Feature<Point>}\n     * @private\n     */\n    this.sketchPoint_ = null;\n\n    /**\n     * Sketch coordinates. Used when drawing a line or polygon.\n     * @type {SketchCoordType}\n     * @private\n     */\n    this.sketchCoords_ = null;\n\n    /**\n     * Sketch line. Used when drawing polygon.\n     * @type {Feature<LineString>}\n     * @private\n     */\n    this.sketchLine_ = null;\n\n    /**\n     * Sketch line coordinates. Used when drawing a polygon or circle.\n     * @type {LineCoordType}\n     * @private\n     */\n    this.sketchLineCoords_ = null;\n\n    /**\n     * Squared tolerance for handling up events.  If the squared distance\n     * between a down and up event is greater than this tolerance, up events\n     * will not be handled.\n     * @type {number}\n     * @private\n     */\n    this.squaredClickTolerance_ = options.clickTolerance\n      ? options.clickTolerance * options.clickTolerance\n      : 36;\n\n    /**\n     * Draw overlay where our sketch features are drawn.\n     * @type {VectorLayer}\n     * @private\n     */\n    this.overlay_ = new VectorLayer({\n      source: new VectorSource({\n        useSpatialIndex: false,\n        wrapX: options.wrapX ? options.wrapX : false,\n      }),\n      style: options.style ? options.style : getDefaultStyleFunction(),\n      updateWhileInteracting: true,\n    });\n\n    /**\n     * Name of the geometry attribute for newly created features.\n     * @type {string|undefined}\n     * @private\n     */\n    this.geometryName_ = options.geometryName;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.condition_ = options.condition ? options.condition : noModifierKeys;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.freehandCondition_;\n    if (options.freehand) {\n      this.freehandCondition_ = always;\n    } else {\n      this.freehandCondition_ = options.freehandCondition\n        ? options.freehandCondition\n        : shiftKeyOnly;\n    }\n\n    /**\n     * @type {import(\"../events/condition.js\").Condition}\n     * @private\n     */\n    this.traceCondition_;\n    this.setTrace(options.trace || false);\n\n    /**\n     * @type {TraceState}\n     * @private\n     */\n    this.traceState_ = {active: false};\n\n    /**\n     * @type {VectorSource|null}\n     * @private\n     */\n    this.traceSource_ = options.traceSource || options.source || null;\n\n    this.addChangeListener(InteractionProperty.ACTIVE, this.updateState_);\n  }\n\n  /**\n   * Toggle tracing mode or set a tracing condition.\n   *\n   * @param {boolean|import(\"../events/condition.js\").Condition} trace A boolean to toggle tracing mode or an event\n   *     condition that will be checked when a feature is clicked to determine if tracing should be active.\n   */\n  setTrace(trace) {\n    let condition;\n    if (!trace) {\n      condition = never;\n    } else if (trace === true) {\n      condition = always;\n    } else {\n      condition = trace;\n    }\n    this.traceCondition_ = condition;\n  }\n\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../Map.js\").default} map Map.\n   */\n  setMap(map) {\n    super.setMap(map);\n    this.updateState_();\n  }\n\n  /**\n   * Get the overlay layer that this interaction renders sketch features to.\n   * @return {VectorLayer} Overlay layer.\n   * @api\n   */\n  getOverlay() {\n    return this.overlay_;\n  }\n\n  /**\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may actually draw or finish the drawing.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   * @api\n   */\n  handleEvent(event) {\n    if (event.originalEvent.type === EventType.CONTEXTMENU) {\n      // Avoid context menu for long taps when drawing on mobile\n      event.originalEvent.preventDefault();\n    }\n    this.freehand_ = this.mode_ !== 'Point' && this.freehandCondition_(event);\n    let move = event.type === MapBrowserEventType.POINTERMOVE;\n    let pass = true;\n    if (\n      !this.freehand_ &&\n      this.lastDragTime_ &&\n      event.type === MapBrowserEventType.POINTERDRAG\n    ) {\n      const now = Date.now();\n      if (now - this.lastDragTime_ >= this.dragVertexDelay_) {\n        this.downPx_ = event.pixel;\n        this.shouldHandle_ = !this.freehand_;\n        move = true;\n      } else {\n        this.lastDragTime_ = undefined;\n      }\n      if (this.shouldHandle_ && this.downTimeout_ !== undefined) {\n        clearTimeout(this.downTimeout_);\n        this.downTimeout_ = undefined;\n      }\n    }\n    if (\n      this.freehand_ &&\n      event.type === MapBrowserEventType.POINTERDRAG &&\n      this.sketchFeature_ !== null\n    ) {\n      this.addToDrawing_(event.coordinate);\n      pass = false;\n    } else if (\n      this.freehand_ &&\n      event.type === MapBrowserEventType.POINTERDOWN\n    ) {\n      pass = false;\n    } else if (move && this.getPointerCount() < 2) {\n      pass = event.type === MapBrowserEventType.POINTERMOVE;\n      if (pass && this.freehand_) {\n        this.handlePointerMove_(event);\n        if (this.shouldHandle_) {\n          // Avoid page scrolling when freehand drawing on mobile\n          event.originalEvent.preventDefault();\n        }\n      } else if (\n        event.originalEvent.pointerType === 'mouse' ||\n        (event.type === MapBrowserEventType.POINTERDRAG &&\n          this.downTimeout_ === undefined)\n      ) {\n        this.handlePointerMove_(event);\n      }\n    } else if (event.type === MapBrowserEventType.DBLCLICK) {\n      pass = false;\n    }\n\n    return super.handleEvent(event) && pass;\n  }\n\n  /**\n   * Handle pointer down events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleDownEvent(event) {\n    this.shouldHandle_ = !this.freehand_;\n\n    if (this.freehand_) {\n      this.downPx_ = event.pixel;\n      if (!this.finishCoordinate_) {\n        this.startDrawing_(event.coordinate);\n      }\n      return true;\n    }\n\n    if (!this.condition_(event)) {\n      this.lastDragTime_ = undefined;\n      return false;\n    }\n\n    this.lastDragTime_ = Date.now();\n    this.downTimeout_ = setTimeout(() => {\n      this.handlePointerMove_(\n        new MapBrowserEvent(\n          MapBrowserEventType.POINTERMOVE,\n          event.map,\n          event.originalEvent,\n          false,\n          event.frameState,\n        ),\n      );\n    }, this.dragVertexDelay_);\n    this.downPx_ = event.pixel;\n    return true;\n  }\n\n  /**\n   * @private\n   */\n  deactivateTrace_() {\n    this.traceState_ = {active: false};\n  }\n\n  /**\n   * Activate or deactivate trace state based on a browser event.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @private\n   */\n  toggleTraceState_(event) {\n    if (!this.traceSource_ || !this.traceCondition_(event)) {\n      return;\n    }\n\n    if (this.traceState_.active) {\n      this.deactivateTrace_();\n      return;\n    }\n\n    const map = this.getMap();\n    const lowerLeft = map.getCoordinateFromPixel([\n      event.pixel[0] - this.snapTolerance_,\n      event.pixel[1] + this.snapTolerance_,\n    ]);\n    const upperRight = map.getCoordinateFromPixel([\n      event.pixel[0] + this.snapTolerance_,\n      event.pixel[1] - this.snapTolerance_,\n    ]);\n    const extent = boundingExtent([lowerLeft, upperRight]);\n    const features = this.traceSource_.getFeaturesInExtent(extent);\n    if (features.length === 0) {\n      return;\n    }\n\n    const targets = getTraceTargets(event.coordinate, features);\n    if (targets.length) {\n      this.traceState_ = {\n        active: true,\n        startPx: event.pixel.slice(),\n        targets: targets,\n        targetIndex: -1,\n      };\n    }\n  }\n\n  /**\n   * @param {TraceTarget} target The trace target.\n   * @param {number} endIndex The new end index of the trace.\n   * @private\n   */\n  addOrRemoveTracedCoordinates_(target, endIndex) {\n    // three cases to handle:\n    //  1. traced in the same direction and points need adding\n    //  2. traced in the same direction and points need removing\n    //  3. traced in a new direction\n    const previouslyForward = target.startIndex <= target.endIndex;\n    const currentlyForward = target.startIndex <= endIndex;\n    if (previouslyForward === currentlyForward) {\n      // same direction\n      if (\n        (previouslyForward && endIndex > target.endIndex) ||\n        (!previouslyForward && endIndex < target.endIndex)\n      ) {\n        // case 1 - add new points\n        this.addTracedCoordinates_(target, target.endIndex, endIndex);\n      } else if (\n        (previouslyForward && endIndex < target.endIndex) ||\n        (!previouslyForward && endIndex > target.endIndex)\n      ) {\n        // case 2 - remove old points\n        this.removeTracedCoordinates_(endIndex, target.endIndex);\n      }\n    } else {\n      // case 3 - remove old points, add new points\n      this.removeTracedCoordinates_(target.startIndex, target.endIndex);\n      this.addTracedCoordinates_(target, target.startIndex, endIndex);\n    }\n  }\n\n  /**\n   * @param {number} fromIndex The start index.\n   * @param {number} toIndex The end index.\n   * @private\n   */\n  removeTracedCoordinates_(fromIndex, toIndex) {\n    if (fromIndex === toIndex) {\n      return;\n    }\n\n    let remove = 0;\n    if (fromIndex < toIndex) {\n      const start = Math.ceil(fromIndex);\n      let end = Math.floor(toIndex);\n      if (end === toIndex) {\n        end -= 1;\n      }\n      remove = end - start + 1;\n    } else {\n      const start = Math.floor(fromIndex);\n      let end = Math.ceil(toIndex);\n      if (end === toIndex) {\n        end += 1;\n      }\n      remove = start - end + 1;\n    }\n\n    if (remove > 0) {\n      this.removeLastPoints_(remove);\n    }\n  }\n\n  /**\n   * @param {TraceTarget} target The trace target.\n   * @param {number} fromIndex The start index.\n   * @param {number} toIndex The end index.\n   * @private\n   */\n  addTracedCoordinates_(target, fromIndex, toIndex) {\n    if (fromIndex === toIndex) {\n      return;\n    }\n\n    const coordinates = [];\n    if (fromIndex < toIndex) {\n      // forward trace\n      const start = Math.ceil(fromIndex);\n      let end = Math.floor(toIndex);\n      if (end === toIndex) {\n        // if end is snapped to a vertex, it will be added later\n        end -= 1;\n      }\n      for (let i = start; i <= end; ++i) {\n        coordinates.push(getCoordinate(target.coordinates, i));\n      }\n    } else {\n      // reverse trace\n      const start = Math.floor(fromIndex);\n      let end = Math.ceil(toIndex);\n      if (end === toIndex) {\n        end += 1;\n      }\n      for (let i = start; i >= end; --i) {\n        coordinates.push(getCoordinate(target.coordinates, i));\n      }\n    }\n    if (coordinates.length) {\n      this.appendCoordinates(coordinates);\n    }\n  }\n\n  /**\n   * Update the trace.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @private\n   */\n  updateTrace_(event) {\n    const traceState = this.traceState_;\n    if (!traceState.active) {\n      return;\n    }\n\n    if (traceState.targetIndex === -1) {\n      // check if we are ready to pick a target\n      if (distance(traceState.startPx, event.pixel) < this.snapTolerance_) {\n        return;\n      }\n    }\n\n    const updatedTraceTarget = getTraceTargetUpdate(\n      event.coordinate,\n      traceState,\n      this.getMap(),\n      this.snapTolerance_,\n    );\n\n    if (traceState.targetIndex !== updatedTraceTarget.index) {\n      // target changed\n      if (traceState.targetIndex !== -1) {\n        // remove points added during previous trace\n        const oldTarget = traceState.targets[traceState.targetIndex];\n        this.removeTracedCoordinates_(oldTarget.startIndex, oldTarget.endIndex);\n      }\n      // add points for the new target\n      const newTarget = traceState.targets[updatedTraceTarget.index];\n      this.addTracedCoordinates_(\n        newTarget,\n        newTarget.startIndex,\n        updatedTraceTarget.endIndex,\n      );\n    } else {\n      // target stayed the same\n      const target = traceState.targets[traceState.targetIndex];\n      this.addOrRemoveTracedCoordinates_(target, updatedTraceTarget.endIndex);\n    }\n\n    // modify the state with updated info\n    traceState.targetIndex = updatedTraceTarget.index;\n    const target = traceState.targets[traceState.targetIndex];\n    target.endIndex = updatedTraceTarget.endIndex;\n\n    // update event coordinate and pixel to match end point of final segment\n    const coordinate = interpolateCoordinate(\n      target.coordinates,\n      target.endIndex,\n    );\n    const pixel = this.getMap().getPixelFromCoordinate(coordinate);\n    event.coordinate = coordinate;\n    event.pixel = [Math.round(pixel[0]), Math.round(pixel[1])];\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleUpEvent(event) {\n    let pass = true;\n\n    if (this.getPointerCount() === 0) {\n      if (this.downTimeout_) {\n        clearTimeout(this.downTimeout_);\n        this.downTimeout_ = undefined;\n      }\n\n      this.handlePointerMove_(event);\n      const tracing = this.traceState_.active;\n      this.toggleTraceState_(event);\n\n      if (this.shouldHandle_) {\n        const startingToDraw = !this.finishCoordinate_;\n        if (startingToDraw) {\n          this.startDrawing_(event.coordinate);\n        }\n        if (!startingToDraw && this.freehand_) {\n          this.finishDrawing();\n        } else if (\n          !this.freehand_ &&\n          (!startingToDraw || this.mode_ === 'Point')\n        ) {\n          if (this.atFinish_(event.pixel, tracing)) {\n            if (this.finishCondition_(event)) {\n              this.finishDrawing();\n            }\n          } else {\n            this.addToDrawing_(event.coordinate);\n          }\n        }\n        pass = false;\n      } else if (this.freehand_) {\n        this.abortDrawing();\n      }\n    }\n\n    if (!pass && this.stopClick_) {\n      event.preventDefault();\n    }\n    return pass;\n  }\n\n  /**\n   * Handle move events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event A move event.\n   * @private\n   */\n  handlePointerMove_(event) {\n    this.pointerType_ = event.originalEvent.pointerType;\n    if (\n      this.downPx_ &&\n      ((!this.freehand_ && this.shouldHandle_) ||\n        (this.freehand_ && !this.shouldHandle_))\n    ) {\n      const downPx = this.downPx_;\n      const clickPx = event.pixel;\n      const dx = downPx[0] - clickPx[0];\n      const dy = downPx[1] - clickPx[1];\n      const squaredDistance = dx * dx + dy * dy;\n      this.shouldHandle_ = this.freehand_\n        ? squaredDistance > this.squaredClickTolerance_\n        : squaredDistance <= this.squaredClickTolerance_;\n      if (!this.shouldHandle_) {\n        return;\n      }\n    }\n\n    if (!this.finishCoordinate_) {\n      this.createOrUpdateSketchPoint_(event.coordinate.slice());\n      return;\n    }\n\n    this.updateTrace_(event);\n    this.modifyDrawing_(event.coordinate);\n  }\n\n  /**\n   * Determine if an event is within the snapping tolerance of the start coord.\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @param {boolean} [tracing] Drawing in trace mode (only stop if at the starting point).\n   * @return {boolean} The event is within the snapping tolerance of the start.\n   * @private\n   */\n  atFinish_(pixel, tracing) {\n    let at = false;\n    if (this.sketchFeature_) {\n      let potentiallyDone = false;\n      let potentiallyFinishCoordinates = [this.finishCoordinate_];\n      const mode = this.mode_;\n      if (mode === 'Point') {\n        at = true;\n      } else if (mode === 'Circle') {\n        at = this.sketchCoords_.length === 2;\n      } else if (mode === 'LineString') {\n        potentiallyDone =\n          !tracing && this.sketchCoords_.length > this.minPoints_;\n      } else if (mode === 'Polygon') {\n        const sketchCoords = /** @type {PolyCoordType} */ (this.sketchCoords_);\n        potentiallyDone = sketchCoords[0].length > this.minPoints_;\n        potentiallyFinishCoordinates = [\n          sketchCoords[0][0],\n          sketchCoords[0][sketchCoords[0].length - 2],\n        ];\n        if (tracing) {\n          potentiallyFinishCoordinates = [sketchCoords[0][0]];\n        } else {\n          potentiallyFinishCoordinates = [\n            sketchCoords[0][0],\n            sketchCoords[0][sketchCoords[0].length - 2],\n          ];\n        }\n      }\n      if (potentiallyDone) {\n        const map = this.getMap();\n        for (let i = 0, ii = potentiallyFinishCoordinates.length; i < ii; i++) {\n          const finishCoordinate = potentiallyFinishCoordinates[i];\n          const finishPixel = map.getPixelFromCoordinate(finishCoordinate);\n          const dx = pixel[0] - finishPixel[0];\n          const dy = pixel[1] - finishPixel[1];\n          const snapTolerance = this.freehand_ ? 1 : this.snapTolerance_;\n          at = Math.sqrt(dx * dx + dy * dy) <= snapTolerance;\n          if (at) {\n            this.finishCoordinate_ = finishCoordinate;\n            break;\n          }\n        }\n      }\n    }\n    return at;\n  }\n\n  /**\n   * @param {import(\"../coordinate\").Coordinate} coordinates Coordinate.\n   * @private\n   */\n  createOrUpdateSketchPoint_(coordinates) {\n    if (!this.sketchPoint_) {\n      this.sketchPoint_ = new Feature(new Point(coordinates));\n      this.updateSketchFeatures_();\n    } else {\n      const sketchPointGeom = this.sketchPoint_.getGeometry();\n      sketchPointGeom.setCoordinates(coordinates);\n    }\n  }\n\n  /**\n   * @param {import(\"../geom/Polygon.js\").default} geometry Polygon geometry.\n   * @private\n   */\n  createOrUpdateCustomSketchLine_(geometry) {\n    if (!this.sketchLine_) {\n      this.sketchLine_ = new Feature();\n    }\n    const ring = geometry.getLinearRing(0);\n    let sketchLineGeom = this.sketchLine_.getGeometry();\n    if (!sketchLineGeom) {\n      sketchLineGeom = new LineString(\n        ring.getFlatCoordinates(),\n        ring.getLayout(),\n      );\n      this.sketchLine_.setGeometry(sketchLineGeom);\n    } else {\n      sketchLineGeom.setFlatCoordinates(\n        ring.getLayout(),\n        ring.getFlatCoordinates(),\n      );\n      sketchLineGeom.changed();\n    }\n  }\n\n  /**\n   * Start the drawing.\n   * @param {import(\"../coordinate.js\").Coordinate} start Start coordinate.\n   * @private\n   */\n  startDrawing_(start) {\n    const projection = this.getMap().getView().getProjection();\n    const stride = getStrideForLayout(this.geometryLayout_);\n    while (start.length < stride) {\n      start.push(0);\n    }\n    this.finishCoordinate_ = start;\n    if (this.mode_ === 'Point') {\n      this.sketchCoords_ = start.slice();\n    } else if (this.mode_ === 'Polygon') {\n      this.sketchCoords_ = [[start.slice(), start.slice()]];\n      this.sketchLineCoords_ = this.sketchCoords_[0];\n    } else {\n      this.sketchCoords_ = [start.slice(), start.slice()];\n    }\n    if (this.sketchLineCoords_) {\n      this.sketchLine_ = new Feature(new LineString(this.sketchLineCoords_));\n    }\n    const geometry = this.geometryFunction_(\n      this.sketchCoords_,\n      undefined,\n      projection,\n    );\n    this.sketchFeature_ = new Feature();\n    if (this.geometryName_) {\n      this.sketchFeature_.setGeometryName(this.geometryName_);\n    }\n    this.sketchFeature_.setGeometry(geometry);\n    this.updateSketchFeatures_();\n    this.dispatchEvent(\n      new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_),\n    );\n  }\n\n  /**\n   * Modify the drawing.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @private\n   */\n  modifyDrawing_(coordinate) {\n    const map = this.getMap();\n    const geometry = this.sketchFeature_.getGeometry();\n    const projection = map.getView().getProjection();\n    const stride = getStrideForLayout(this.geometryLayout_);\n    let coordinates, last;\n    while (coordinate.length < stride) {\n      coordinate.push(0);\n    }\n    if (this.mode_ === 'Point') {\n      last = this.sketchCoords_;\n    } else if (this.mode_ === 'Polygon') {\n      coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];\n      last = coordinates[coordinates.length - 1];\n      if (this.atFinish_(map.getPixelFromCoordinate(coordinate))) {\n        // snap to finish\n        coordinate = this.finishCoordinate_.slice();\n      }\n    } else {\n      coordinates = this.sketchCoords_;\n      last = coordinates[coordinates.length - 1];\n    }\n    last[0] = coordinate[0];\n    last[1] = coordinate[1];\n    this.geometryFunction_(\n      /** @type {!LineCoordType} */ (this.sketchCoords_),\n      geometry,\n      projection,\n    );\n    if (this.sketchPoint_) {\n      const sketchPointGeom = this.sketchPoint_.getGeometry();\n      sketchPointGeom.setCoordinates(coordinate);\n    }\n    if (geometry.getType() === 'Polygon' && this.mode_ !== 'Polygon') {\n      this.createOrUpdateCustomSketchLine_(/** @type {Polygon} */ (geometry));\n    } else if (this.sketchLineCoords_) {\n      const sketchLineGeom = this.sketchLine_.getGeometry();\n      sketchLineGeom.setCoordinates(this.sketchLineCoords_);\n    }\n    this.updateSketchFeatures_();\n  }\n\n  /**\n   * Add a new coordinate to the drawing.\n   * @param {!PointCoordType} coordinate Coordinate\n   * @return {Feature<import(\"../geom/SimpleGeometry.js\").default>} The sketch feature.\n   * @private\n   */\n  addToDrawing_(coordinate) {\n    const geometry = this.sketchFeature_.getGeometry();\n    const projection = this.getMap().getView().getProjection();\n    let done;\n    let coordinates;\n    const mode = this.mode_;\n    if (mode === 'LineString' || mode === 'Circle') {\n      this.finishCoordinate_ = coordinate.slice();\n      coordinates = /** @type {LineCoordType} */ (this.sketchCoords_);\n      if (coordinates.length >= this.maxPoints_) {\n        if (this.freehand_) {\n          coordinates.pop();\n        } else {\n          done = true;\n        }\n      }\n      coordinates.push(coordinate.slice());\n      this.geometryFunction_(coordinates, geometry, projection);\n    } else if (mode === 'Polygon') {\n      coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];\n      if (coordinates.length >= this.maxPoints_) {\n        if (this.freehand_) {\n          coordinates.pop();\n        } else {\n          done = true;\n        }\n      }\n      coordinates.push(coordinate.slice());\n      if (done) {\n        this.finishCoordinate_ = coordinates[0];\n      }\n      this.geometryFunction_(this.sketchCoords_, geometry, projection);\n    }\n    this.createOrUpdateSketchPoint_(coordinate.slice());\n    this.updateSketchFeatures_();\n    if (done) {\n      return this.finishDrawing();\n    }\n    return this.sketchFeature_;\n  }\n\n  /**\n   * @param {number} n The number of points to remove.\n   */\n  removeLastPoints_(n) {\n    if (!this.sketchFeature_) {\n      return;\n    }\n    const geometry = this.sketchFeature_.getGeometry();\n    const projection = this.getMap().getView().getProjection();\n    const mode = this.mode_;\n    for (let i = 0; i < n; ++i) {\n      let coordinates;\n      if (mode === 'LineString' || mode === 'Circle') {\n        coordinates = /** @type {LineCoordType} */ (this.sketchCoords_);\n        coordinates.splice(-2, 1);\n        if (coordinates.length >= 2) {\n          this.finishCoordinate_ = coordinates[coordinates.length - 2].slice();\n          const finishCoordinate = this.finishCoordinate_.slice();\n          coordinates[coordinates.length - 1] = finishCoordinate;\n          this.createOrUpdateSketchPoint_(finishCoordinate);\n        }\n        this.geometryFunction_(coordinates, geometry, projection);\n        if (geometry.getType() === 'Polygon' && this.sketchLine_) {\n          this.createOrUpdateCustomSketchLine_(\n            /** @type {Polygon} */ (geometry),\n          );\n        }\n      } else if (mode === 'Polygon') {\n        coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];\n        coordinates.splice(-2, 1);\n        const sketchLineGeom = this.sketchLine_.getGeometry();\n        if (coordinates.length >= 2) {\n          const finishCoordinate = coordinates[coordinates.length - 2].slice();\n          coordinates[coordinates.length - 1] = finishCoordinate;\n          this.createOrUpdateSketchPoint_(finishCoordinate);\n        }\n        sketchLineGeom.setCoordinates(coordinates);\n        this.geometryFunction_(this.sketchCoords_, geometry, projection);\n      }\n\n      if (coordinates.length === 1) {\n        this.abortDrawing();\n        break;\n      }\n    }\n\n    this.updateSketchFeatures_();\n  }\n\n  /**\n   * Remove last point of the feature currently being drawn. Does not do anything when\n   * drawing POINT or MULTI_POINT geometries.\n   * @api\n   */\n  removeLastPoint() {\n    this.removeLastPoints_(1);\n  }\n\n  /**\n   * Stop drawing and add the sketch feature to the target layer.\n   * The {@link module:ol/interaction/Draw~DrawEventType.DRAWEND} event is\n   * dispatched before inserting the feature.\n   * @return {Feature<import(\"../geom/SimpleGeometry.js\").default>|null} The drawn feature.\n   * @api\n   */\n  finishDrawing() {\n    const sketchFeature = this.abortDrawing_();\n    if (!sketchFeature) {\n      return null;\n    }\n    let coordinates = this.sketchCoords_;\n    const geometry = sketchFeature.getGeometry();\n    const projection = this.getMap().getView().getProjection();\n    if (this.mode_ === 'LineString') {\n      // remove the redundant last point\n      coordinates.pop();\n      this.geometryFunction_(coordinates, geometry, projection);\n    } else if (this.mode_ === 'Polygon') {\n      // remove the redundant last point in ring\n      /** @type {PolyCoordType} */ (coordinates)[0].pop();\n      this.geometryFunction_(coordinates, geometry, projection);\n      coordinates = geometry.getCoordinates();\n    }\n\n    // cast multi-part geometries\n    if (this.type_ === 'MultiPoint') {\n      sketchFeature.setGeometry(\n        new MultiPoint([/** @type {PointCoordType} */ (coordinates)]),\n      );\n    } else if (this.type_ === 'MultiLineString') {\n      sketchFeature.setGeometry(\n        new MultiLineString([/** @type {LineCoordType} */ (coordinates)]),\n      );\n    } else if (this.type_ === 'MultiPolygon') {\n      sketchFeature.setGeometry(\n        new MultiPolygon([/** @type {PolyCoordType} */ (coordinates)]),\n      );\n    }\n\n    // First dispatch event to allow full set up of feature\n    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWEND, sketchFeature));\n\n    // Then insert feature\n    if (this.features_) {\n      this.features_.push(sketchFeature);\n    }\n    if (this.source_) {\n      this.source_.addFeature(sketchFeature);\n    }\n    return sketchFeature;\n  }\n\n  /**\n   * Stop drawing without adding the sketch feature to the target layer.\n   * @return {Feature<import(\"../geom/SimpleGeometry.js\").default>|null} The sketch feature (or null if none).\n   * @private\n   */\n  abortDrawing_() {\n    this.finishCoordinate_ = null;\n    const sketchFeature = this.sketchFeature_;\n    this.sketchFeature_ = null;\n    this.sketchPoint_ = null;\n    this.sketchLine_ = null;\n    this.overlay_.getSource().clear(true);\n    this.deactivateTrace_();\n    return sketchFeature;\n  }\n\n  /**\n   * Stop drawing without adding the sketch feature to the target layer.\n   * @api\n   */\n  abortDrawing() {\n    const sketchFeature = this.abortDrawing_();\n    if (sketchFeature) {\n      this.dispatchEvent(new DrawEvent(DrawEventType.DRAWABORT, sketchFeature));\n    }\n  }\n\n  /**\n   * Append coordinates to the end of the geometry that is currently being drawn.\n   * This can be used when drawing LineStrings or Polygons. Coordinates will\n   * either be appended to the current LineString or the outer ring of the current\n   * Polygon. If no geometry is being drawn, a new one will be created.\n   * @param {!LineCoordType} coordinates Linear coordinates to be appended to\n   * the coordinate array.\n   * @api\n   */\n  appendCoordinates(coordinates) {\n    const mode = this.mode_;\n    const newDrawing = !this.sketchFeature_;\n    if (newDrawing) {\n      this.startDrawing_(coordinates[0]);\n    }\n    /** @type {LineCoordType} */\n    let sketchCoords;\n    if (mode === 'LineString' || mode === 'Circle') {\n      sketchCoords = /** @type {LineCoordType} */ (this.sketchCoords_);\n    } else if (mode === 'Polygon') {\n      sketchCoords =\n        this.sketchCoords_ && this.sketchCoords_.length\n          ? /** @type {PolyCoordType} */ (this.sketchCoords_)[0]\n          : [];\n    } else {\n      return;\n    }\n\n    if (newDrawing) {\n      sketchCoords.shift();\n    }\n\n    // Remove last coordinate from sketch drawing (this coordinate follows cursor position)\n    sketchCoords.pop();\n\n    // Append coordinate list\n    for (let i = 0; i < coordinates.length; i++) {\n      this.addToDrawing_(coordinates[i]);\n    }\n\n    const ending = coordinates[coordinates.length - 1];\n    // Duplicate last coordinate for sketch drawing (cursor position)\n    this.sketchFeature_ = this.addToDrawing_(ending);\n    this.modifyDrawing_(ending);\n  }\n\n  /**\n   * Initiate draw mode by starting from an existing geometry which will\n   * receive new additional points. This only works on features with\n   * `LineString` geometries, where the interaction will extend lines by adding\n   * points to the end of the coordinates array.\n   * This will change the original feature, instead of drawing a copy.\n   *\n   * The function will dispatch a `drawstart` event.\n   *\n   * @param {!Feature<LineString>} feature Feature to be extended.\n   * @api\n   */\n  extend(feature) {\n    const geometry = feature.getGeometry();\n    const lineString = geometry;\n    this.sketchFeature_ = feature;\n    this.sketchCoords_ = lineString.getCoordinates();\n    const last = this.sketchCoords_[this.sketchCoords_.length - 1];\n    this.finishCoordinate_ = last.slice();\n    this.sketchCoords_.push(last.slice());\n    this.sketchPoint_ = new Feature(new Point(last));\n    this.updateSketchFeatures_();\n    this.dispatchEvent(\n      new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_),\n    );\n  }\n\n  /**\n   * Redraw the sketch features.\n   * @private\n   */\n  updateSketchFeatures_() {\n    const sketchFeatures = [];\n    if (this.sketchFeature_) {\n      sketchFeatures.push(this.sketchFeature_);\n    }\n    if (this.sketchLine_) {\n      sketchFeatures.push(this.sketchLine_);\n    }\n    if (this.sketchPoint_) {\n      sketchFeatures.push(this.sketchPoint_);\n    }\n    const overlaySource = this.overlay_.getSource();\n    overlaySource.clear(true);\n    overlaySource.addFeatures(sketchFeatures);\n  }\n\n  /**\n   * @private\n   */\n  updateState_() {\n    const map = this.getMap();\n    const active = this.getActive();\n    if (!map || !active) {\n      this.abortDrawing();\n    }\n    this.overlay_.setMap(active ? map : null);\n  }\n}\n\n/**\n * @return {import(\"../style/Style.js\").StyleFunction} Styles.\n */\nfunction getDefaultStyleFunction() {\n  const styles = createEditingStyle();\n  return function (feature, resolution) {\n    return styles[feature.getGeometry().getType()];\n  };\n}\n\n/**\n * Create a `geometryFunction` for `type: 'Circle'` that will create a regular\n * polygon with a user specified number of sides and start angle instead of a\n * {@link import(\"../geom/Circle.js\").Circle} geometry.\n * @param {number} [sides] Number of sides of the regular polygon.\n *     Default is 32.\n * @param {number} [angle] Angle of the first point in counter-clockwise\n *     radians. 0 means East.\n *     Default is the angle defined by the heading from the center of the\n *     regular polygon to the current pointer position.\n * @return {GeometryFunction} Function that draws a polygon.\n * @api\n */\nexport function createRegularPolygon(sides, angle) {\n  return function (coordinates, geometry, projection) {\n    const center = fromUserCoordinate(\n      /** @type {LineCoordType} */ (coordinates)[0],\n      projection,\n    );\n    const end = fromUserCoordinate(\n      /** @type {LineCoordType} */ (coordinates)[coordinates.length - 1],\n      projection,\n    );\n    const radius = Math.sqrt(squaredCoordinateDistance(center, end));\n    geometry = geometry || fromCircle(new Circle(center), sides);\n\n    let internalAngle = angle;\n    if (!angle && angle !== 0) {\n      const x = end[0] - center[0];\n      const y = end[1] - center[1];\n      internalAngle = Math.atan2(y, x);\n    }\n    makeRegular(\n      /** @type {Polygon} */ (geometry),\n      center,\n      radius,\n      internalAngle,\n    );\n\n    const userProjection = getUserProjection();\n    if (userProjection) {\n      geometry.transform(projection, userProjection);\n    }\n    return geometry;\n  };\n}\n\n/**\n * Create a `geometryFunction` that will create a box-shaped polygon (aligned\n * with the coordinate system axes).  Use this with the draw interaction and\n * `type: 'Circle'` to return a box instead of a circle geometry.\n * @return {GeometryFunction} Function that draws a box-shaped polygon.\n * @api\n */\nexport function createBox() {\n  return function (coordinates, geometry, projection) {\n    const extent = boundingExtent(\n      /** @type {LineCoordType} */ ([\n        coordinates[0],\n        coordinates[coordinates.length - 1],\n      ]).map(function (coordinate) {\n        return fromUserCoordinate(coordinate, projection);\n      }),\n    );\n    const boxCoordinates = [\n      [\n        getBottomLeft(extent),\n        getBottomRight(extent),\n        getTopRight(extent),\n        getTopLeft(extent),\n        getBottomLeft(extent),\n      ],\n    ];\n    if (geometry) {\n      geometry.setCoordinates(boxCoordinates);\n    } else {\n      geometry = new Polygon(boxCoordinates);\n    }\n    const userProjection = getUserProjection();\n    if (userProjection) {\n      geometry.transform(projection, userProjection);\n    }\n    return geometry;\n  };\n}\n\n/**\n * Get the drawing mode.  The mode for multi-part geometries is the same as for\n * their single-part cousins.\n * @param {import(\"../geom/Geometry.js\").Type} type Geometry type.\n * @return {Mode} Drawing mode.\n */\nfunction getMode(type) {\n  switch (type) {\n    case 'Point':\n    case 'MultiPoint':\n      return 'Point';\n    case 'LineString':\n    case 'MultiLineString':\n      return 'LineString';\n    case 'Polygon':\n    case 'MultiPolygon':\n      return 'Polygon';\n    case 'Circle':\n      return 'Circle';\n    default:\n      throw new Error('Invalid type: ' + type);\n  }\n}\n\nexport default Draw;\n","import ol_style_Style from 'ol/style/Style.js'\nimport ol_style_Stroke from 'ol/style/Stroke.js'\nimport ol_source_Vector from 'ol/source/Vector.js'\nimport ol_style_Fill from 'ol/style/Fill.js'\nimport ol_layer_Vector from 'ol/layer/Vector.js'\nimport ol_geom_Point from 'ol/geom/Point.js'\nimport ol_Feature from 'ol/Feature.js'\nimport ol_Collection from 'ol/Collection.js'\nimport ol_interaction_Pointer from 'ol/interaction/Pointer.js'\nimport ol_style_RegularShape from 'ol/style/RegularShape.js'\nimport {fromExtent as ol_geom_Polygon_fromExtent} from 'ol/geom/Polygon.js'\nimport {boundingExtent as ol_extent_boundingExtent, buffer as ol_extent_buffer, createEmpty as ol_extent_createEmpty, extend as ol_extent_extend, getCenter as ol_extent_getCenter} from 'ol/extent.js'\nimport {unByKey as ol_Observable_unByKey} from 'ol/Observable.js'\nimport ol_geom_Polygon from 'ol/geom/Polygon.js'\nimport ol_ext_element from '../util/element.js'\n\n/** Interaction rotate\n * @constructor\n * @extends {ol_interaction_Pointer}\n * @fires select | rotatestart | rotating | rotateend | translatestart | translating | translateend | scalestart | scaling | scaleend\n * @param {any} options\n *  @param {function} options.filter A function that takes a Feature and a Layer and returns true if the feature may be transformed or false otherwise.\n *  @param {Array<ol.Layer>} options.layers array of layers to transform,\n *  @param {ol.Collection<ol.Feature>} options.features collection of feature to transform,\n *  @param {ol.interaction.Select} [options.select] a select interaction to synchronize with\n *\t@param {ol.EventsConditionType|undefined} options.condition A function that takes an ol.MapBrowserEvent and a feature collection and returns a boolean to indicate whether that event should be handled. default: ol.events.condition.always.\n *\t@param {ol.EventsConditionType|undefined} options.addCondition A function that takes an ol.MapBrowserEvent and returns a boolean to indicate whether that event should be handled ie. the feature will be added to the transforms features. default: ol.events.condition.never.\n *\t@param {number | undefined} options.hitTolerance Tolerance to select feature in pixel, default 0\n *\t@param {bool} options.translateFeature Translate when click on feature\n *\t@param {bool} options.translate Can translate the feature\n *  @param {bool} options.translateBBox Enable translate when the user drags inside the bounding box\n *\t@param {bool} options.stretch can stretch the feature\n *\t@param {bool} options.scale can scale the feature\n *\t@param {bool} options.rotate can rotate the feature\n *\t@param {bool} options.noFlip prevent the feature geometry to flip, default false\n *\t@param {bool} options.selection the intraction handle selection/deselection, if not use the select prototype to add features to transform, default true\n *\t@param {ol.events.ConditionType | undefined} options.keepAspectRatio A function that takes an ol.MapBrowserEvent and returns a boolean to keep aspect ratio, default ol.events.condition.shiftKeyOnly.\n *\t@param {ol.events.ConditionType | undefined} options.modifyCenter A function that takes an ol.MapBrowserEvent and returns a boolean to apply scale & strech from the center, default ol.events.condition.metaKey or ol.events.condition.ctrlKey.\n *\t@param {boolean} options.enableRotatedTransform Enable transform when map is rotated\n *\t@param {boolean} [options.keepRectangle=false] keep rectangle when possible\n *  @param {number} [options.buffer] Increase the extent used as bounding box, default 0\n *\t@param {*} options.style list of ol.style for handles\n *  @param {number|Array<number>|function} [options.pointRadius=0] radius for points or a function that takes a feature and returns the radius (or [radiusX, radiusY]). If not null show handles to transform the points\n */\nvar ol_interaction_Transform = class olinteractionTransform extends ol_interaction_Pointer {\n  constructor(options) {\n    options = options || {}\n    // Extend pointer\n    super({\n      handleDownEvent: function(e) { return self.handleDownEvent_(e) },\n      handleDragEvent: function(e) { return this.handleDragEvent_(e) },\n      handleMoveEvent: function(e) { return this.handleMoveEvent_(e) },\n      handleUpEvent: function(e) { return this.handleUpEvent_(e) },\n    })\n    \n    var self = this\n    this.selection_ = new ol_Collection()\n\n    // Create a new overlay layer for the sketch\n    this.handles_ = new ol_Collection()\n    this.overlayLayer_ = new ol_layer_Vector({\n      source: new ol_source_Vector({\n        features: this.handles_,\n        useSpatialIndex: false,\n        wrapX: false // For vector editing across the -180 and 180 meridians to work properly, this should be set to false\n      }),\n      name: 'Transform overlay',\n      displayInLayerSwitcher: false,\n      // Return the style according to the handle type\n      style: function (feature) {\n        return (self.style[(feature.get('handle') || 'default') + (feature.get('constraint') || '') + (feature.get('option') || '')])\n      },\n      updateWhileAnimating: true,\n      updateWhileInteracting: true,\n    })\n\n    // Collection of feature to transform\n    this.features_ = options.features\n    // Filter or list of layers to transform\n    if (typeof (options.filter) === 'function')\n      this._filter = options.filter\n    this.layers_ = options.layers ? (options.layers instanceof Array) ? options.layers : [options.layers] : null\n\n    this._handleEvent = options.condition || function () { return true }\n    this.addFn_ = options.addCondition || function () { return false }\n    this.setPointRadius(options.pointRadius)\n    /* Translate when click on feature */\n    this.set('translateFeature', (options.translateFeature !== false))\n    /* Can translate the feature */\n    this.set('translate', (options.translate !== false))\n    /* Translate when click on the bounding box */\n    this.set('translateBBox', (options.translateBBox === true))\n    /* Can stretch the feature */\n    this.set('stretch', (options.stretch !== false))\n    /* Can scale the feature */\n    this.set('scale', (options.scale !== false))\n    /* Can rotate the feature */\n    this.set('rotate', (options.rotate !== false))\n    /* Keep aspect ratio */\n    this.set('keepAspectRatio', (options.keepAspectRatio || function (e) { return e.originalEvent.shiftKey }))\n    /* Modify center */\n    this.set('modifyCenter', (options.modifyCenter || function (e) { return e.originalEvent.metaKey || e.originalEvent.ctrlKey }))\n    /* Prevent flip */\n    this.set('noFlip', (options.noFlip || false))\n    /* Handle selection */\n    this.set('selection', (options.selection !== false))\n    /*  */\n    this.set('hitTolerance', (options.hitTolerance || 0))\n    /* Enable view rotated transforms */\n    this.set('enableRotatedTransform', (options.enableRotatedTransform || false))\n    /* Keep rectangle angles 90 degrees */\n    this.set('keepRectangle', (options.keepRectangle || false))\n    /* Add buffer to the feature's extent */\n    this.set('buffer', (options.buffer || 0))\n\n    // Force redraw when changed\n    this.on('propertychange', function () {\n      this.drawSketch_()\n    })\n\n    // setstyle\n    this.setDefaultStyle()\n\n    // Synchronize selection\n    if (options.select) {\n      // this.selection_ = options.select.getFeatures();\n      this.on('change:active', function(e) {\n        if (this.getActive()) {\n          this.setSelection(options.select.getFeatures().getArray())\n        } else {\n          options.select.getFeatures().extend(this.selection_)\n          this.selection_.forEach(function(f) {\n            options.select.getFeatures().push(f)\n          })\n          this.select(null)\n        }\n      }.bind(this))\n    } else {\n      this.on('change:active', function(e) {\n        this.select(null)\n      }.bind(this))\n    }\n\n  }\n  /**\n   * Remove the interaction from its current map, if any,  and attach it to a new\n   * map, if any. Pass `null` to just remove the interaction from the current map.\n   * @param {ol.Map} map Map.\n   * @api stable\n   */\n  setMap(map) {\n    var oldMap = this.getMap()\n    if (oldMap) {\n      oldMap.removeLayer(this.overlayLayer_)\n      if (this.previousCursor_) {\n        ol_ext_element.setCursor(oldMap, this.previousCursor_)\n      }\n      this.previousCursor_ = undefined\n    }\n    super.setMap(map)\n    this.overlayLayer_.setMap(map)\n    if (map === null) {\n      this.select(null)\n    }\n    if (map !== null) {\n      this.isTouch = /touch/.test(map.getViewport().className)\n      this.setDefaultStyle()\n    }\n  }\n  /**\n   * Activate/deactivate interaction\n   * @param {bool}\n   * @api stable\n   */\n  setActive(b) {\n    // this.select(null)\n    if (this.overlayLayer_) this.overlayLayer_.setVisible(b)\n    super.setActive(b)\n  }\n  /** Set default sketch style\n   * @param {Object} [options]\n   *  @param {ol_style_Stroke} [stroke] stroke style for selection rectangle, default red dash\n   *  @param {ol_style_Fill} [fill] fill style for selection rectangle, default red\n   *  @param {ol_style_Stroke} [pointStroke] stroke style for handles, default red\n   *  @param {ol_style_Fill} [pointFill] fill style for handles, default white\n   */\n  setDefaultStyle(options) {\n    options = options || {}\n    // Style\n    var stroke = options.pointStroke || new ol_style_Stroke({ color: [255, 0, 0, 1], width: 1 })\n    var strokedash = options.stroke || new ol_style_Stroke({ color: [255, 0, 0, 1], width: 1, lineDash: [4, 4] })\n    var fill0 = options.fill || new ol_style_Fill({ color: [255, 0, 0, 0.01] })\n    var fill = options.pointFill || new ol_style_Fill({ color: [255, 255, 255, 0.8] })\n    var circle = new ol_style_RegularShape({\n      fill: fill,\n      stroke: stroke,\n      radius: this.isTouch ? 12 : 6,\n      displacement: this.isTouch ? [24, -24] : [12, -12],\n      points: 15\n    })\n    // Old version with no displacement\n    if (!circle.setDisplacement)\n      circle.getAnchor()[0] = this.isTouch ? -10 : -5\n    var bigpt = new ol_style_RegularShape({\n      fill: fill,\n      stroke: stroke,\n      radius: this.isTouch ? 16 : 8,\n      points: 4,\n      angle: Math.PI / 4\n    })\n    var smallpt = new ol_style_RegularShape({\n      fill: fill,\n      stroke: stroke,\n      radius: this.isTouch ? 12 : 6,\n      points: 4,\n      angle: Math.PI / 4\n    })\n    function createStyle(img, stroke, fill) {\n      return [new ol_style_Style({ image: img, stroke: stroke, fill: fill })]\n    }\n    /** Style for handles */\n    this.style = {\n      'default': createStyle(bigpt, strokedash, fill0),\n      'translate': createStyle(bigpt, stroke, fill),\n      'rotate': createStyle(circle, stroke, fill),\n      'rotate0': createStyle(bigpt, stroke, fill),\n      'scale': createStyle(bigpt, stroke, fill),\n      'scale1': createStyle(bigpt, stroke, fill),\n      'scale2': createStyle(bigpt, stroke, fill),\n      'scale3': createStyle(bigpt, stroke, fill),\n      'scalev': createStyle(smallpt, stroke, fill),\n      'scaleh1': createStyle(smallpt, stroke, fill),\n      'scalev2': createStyle(smallpt, stroke, fill),\n      'scaleh3': createStyle(smallpt, stroke, fill),\n    }\n    this.drawSketch_()\n  }\n  /**\n   * Set sketch style.\n   * @param {style} style Style name: 'default','translate','rotate','rotate0','scale','scale1','scale2','scale3','scalev','scaleh1','scalev2','scaleh3'\n   * @param {ol.style.Style|Array<ol.style.Style>} olstyle\n   * @api stable\n   */\n  setStyle(style, olstyle) {\n    if (!olstyle)\n      return\n    if (olstyle instanceof Array)\n      this.style[style] = olstyle\n    else\n      this.style[style] = [olstyle]\n    for (var i = 0; i < this.style[style].length; i++) {\n      var im = this.style[style][i].getImage()\n      if (im) {\n        if (style == 'rotate') {\n          im.getAnchor()[0] = -5\n        }\n        if (this.isTouch)\n          im.setScale(1.8)\n      }\n      var tx = this.style[style][i].getText()\n      if (tx) {\n        if (style == 'rotate')\n          tx.setOffsetX(this.isTouch ? 14 : 7)\n        if (this.isTouch)\n          tx.setScale(1.8)\n      }\n    }\n    this.drawSketch_()\n  }\n  /** Get Feature at pixel\n   * @param {ol.Pixel}\n   * @return {ol.feature}\n   * @private\n   */\n  getFeatureAtPixel_(pixel) {\n    var self = this\n    return this.getMap().forEachFeatureAtPixel(pixel,\n      function (feature, layer) {\n        var found = false\n        // Overlay ?\n        if (!layer) {\n          if (feature === self.bbox_) {\n            if (self.get('translateBBox')) {\n              return { feature: feature, handle: 'translate', constraint: '', option: '' }\n            } else {\n              return false\n            }\n          }\n          self.handles_.forEach(function (f) {\n            if (f === feature)\n              found = true\n          })\n          if (found)\n            return { feature: feature, handle: feature.get('handle'), constraint: feature.get('constraint'), option: feature.get('option') }\n        }\n        // No seletion\n        if (!self.get('selection')) {\n          // Return the currently selected feature the user is interacting with.\n          if (self.selection_.getArray().some(function (f) { return feature === f })) {\n            return { feature: feature }\n          }\n          return null\n        }\n        // filter condition\n        if (self._filter) {\n          if (self._filter(feature, layer))\n            return { feature: feature }\n          else\n            return null\n        }\n\n        // feature belong to a layer\n        else if (self.layers_) {\n          for (var i = 0; i < self.layers_.length; i++) {\n            if (self.layers_[i] === layer)\n              return { feature: feature }\n          }\n          return null\n        }\n\n        // feature in the collection\n        else if (self.features_) {\n          self.features_.forEach(function (f) {\n            if (f === feature)\n              found = true\n          })\n          if (found)\n            return { feature: feature }\n          else\n            return null\n        }\n\n        // Others\n        else\n          return { feature: feature }\n      },\n      { hitTolerance: this.get('hitTolerance') }\n    ) || {}\n  }\n  /** Rotate feature from map view rotation\n   * @param {ol.Feature} f the feature\n   * @param {boolean} clone clone resulting geom\n   * @param {ol.geom.Geometry} rotated geometry\n   */\n  getGeometryRotateToZero_(f, clone) {\n    var origGeom = f.getGeometry()\n    var viewRotation = this.getMap().getView().getRotation()\n    if (viewRotation === 0 || !this.get('enableRotatedTransform')) {\n      return (clone) ? origGeom.clone() : origGeom\n    }\n    var rotGeom = origGeom.clone()\n    rotGeom.rotate(viewRotation * -1, this.getMap().getView().getCenter())\n    return rotGeom\n  }\n  /** Test if rectangle\n   * @param {ol.Geometry} geom\n   * @returns {boolean}\n   * @private\n   */\n  _isRectangle(geom) {\n    if (this.get('keepRectangle') && geom.getType() === 'Polygon') {\n      var coords = geom.getCoordinates()[0]\n      return coords.length === 5\n    }\n    return false\n  }\n  /** Draw transform sketch\n  * @param {boolean} draw only the center\n  */\n  drawSketch_(center) {\n    var i, f, geom\n    var keepRectangle = this.selection_.item(0) && this._isRectangle(this.selection_.item(0).getGeometry())\n    this.overlayLayer_.getSource().clear()\n    if (!this.selection_.getLength())\n      return\n    var viewRotation = this.getMap().getView().getRotation()\n    var ext = this.getGeometryRotateToZero_(this.selection_.item(0)).getExtent()\n    var coords\n    if (keepRectangle) {\n      coords = this.getGeometryRotateToZero_(this.selection_.item(0)).getCoordinates()[0].slice(0, 4)\n      coords.unshift(coords[3])\n    }\n    // Clone and extend\n    ext = ol_extent_buffer(ext, this.get('buffer'))\n    this.selection_.forEach(function (f) {\n      var extendExt = this.getGeometryRotateToZero_(f).getExtent()\n      ol_extent_extend(ext, extendExt)\n    }.bind(this))\n\n    var ptRadius = (this.selection_.getLength() === 1 ? this._pointRadius(this.selection_.item(0)) : 0)\n    if (ptRadius && !(ptRadius instanceof Array))\n      ptRadius = [ptRadius, ptRadius]\n\n    if (center === true) {\n      if (!this.ispt_) {\n        this.overlayLayer_.getSource().addFeature(new ol_Feature({ geometry: new ol_geom_Point(this.center_), handle: 'rotate0' }))\n        geom = ol_geom_Polygon_fromExtent(ext)\n        if (this.get('enableRotatedTransform') && viewRotation !== 0) {\n          geom.rotate(viewRotation, this.getMap().getView().getCenter())\n        }\n        f = this.bbox_ = new ol_Feature(geom)\n        this.overlayLayer_.getSource().addFeature(f)\n      }\n    } else {\n      if (this.ispt_) {\n        // Calculate extent arround the point\n        var p = this.getMap().getPixelFromCoordinate(ol_extent_getCenter(ext))\n        if (p) {\n          var dx = ptRadius ? ptRadius[0] || 10 : 10\n          var dy = ptRadius ? ptRadius[1] || 10 : 10\n          ext = ol_extent_boundingExtent([\n            this.getMap().getCoordinateFromPixel([p[0] - dx, p[1] - dy]),\n            this.getMap().getCoordinateFromPixel([p[0] + dx, p[1] + dy])\n          ])\n        }\n      }\n      geom = keepRectangle ? new ol_geom_Polygon([coords]) : ol_geom_Polygon_fromExtent(ext)\n      if (this.get('enableRotatedTransform') && viewRotation !== 0) {\n        geom.rotate(viewRotation, this.getMap().getView().getCenter())\n      }\n      f = this.bbox_ = new ol_Feature(geom)\n      var features = []\n      var g = geom.getCoordinates()[0]\n      if (!this.ispt_ || ptRadius) {\n        features.push(f)\n        // Middle\n        if (!this.iscircle_ && !this.ispt_ && this.get('stretch') && this.get('scale'))\n          for (i = 0; i < g.length - 1; i++) {\n            f = new ol_Feature({ geometry: new ol_geom_Point([(g[i][0] + g[i + 1][0]) / 2, (g[i][1] + g[i + 1][1]) / 2]), handle: 'scale', constraint: i % 2 ? \"h\" : \"v\", option: i })\n            features.push(f)\n          }\n        // Handles\n        if (this.get('scale'))\n          for (i = 0; i < g.length - 1; i++) {\n            f = new ol_Feature({ geometry: new ol_geom_Point(g[i]), handle: 'scale', option: i })\n            features.push(f)\n          }\n        // Center\n        if (this.get('translate') && !this.get('translateFeature')) {\n          f = new ol_Feature({ geometry: new ol_geom_Point([(g[0][0] + g[2][0]) / 2, (g[0][1] + g[2][1]) / 2]), handle: 'translate' })\n          features.push(f)\n        }\n      }\n      // Rotate\n      if (!this.iscircle_ && this.get('rotate')) {\n        f = new ol_Feature({ geometry: new ol_geom_Point(g[3]), handle: 'rotate' })\n        features.push(f)\n      }\n      // Add sketch\n      this.overlayLayer_.getSource().addFeatures(features)\n    }\n\n  }\n  /** Select a feature to transform\n  * @param {ol.Feature} feature the feature to transform\n  * @param {boolean} add true to add the feature to the selection, default false\n  */\n  select(feature, add) {\n    if (!feature) {\n      if (this.selection_) {\n        this.selection_.clear()\n        this.drawSketch_()\n      }\n      return\n    }\n    if (!feature.getGeometry || !feature.getGeometry()) return\n    // Add to selection\n    if (add) {\n      this.selection_.push(feature)\n    } else {\n      var index = this.selection_.getArray().indexOf(feature)\n      this.selection_.removeAt(index)\n    }\n    this.ispt_ = (this.selection_.getLength() === 1 ? (this.selection_.item(0).getGeometry().getType() == \"Point\") : false)\n    this.iscircle_ = (this.selection_.getLength() === 1 ? (this.selection_.item(0).getGeometry().getType() == \"Circle\") : false)\n    this.drawSketch_()\n    this.watchFeatures_()\n    // select event\n    this.dispatchEvent({ type: 'select', feature: feature, features: this.selection_ })\n  }\n  /** Update the selection collection.\n  * @param {ol.Collection<ol.Feature>} features the features to transform\n  */\n  setSelection(features) {\n    this.selection_.clear()\n    features.forEach(function (feature) {\n      this.selection_.push(feature)\n    }.bind(this))\n\n    this.ispt_ = (this.selection_.getLength() === 1 ? (this.selection_.item(0).getGeometry().getType() == \"Point\") : false)\n    this.iscircle_ = (this.selection_.getLength() === 1 ? (this.selection_.item(0).getGeometry().getType() == \"Circle\") : false)\n    this.drawSketch_()\n    this.watchFeatures_()\n    // select event\n    this.dispatchEvent({ type: 'select', features: this.selection_ })\n  }\n  /** Watch selected features\n   * @private\n   */\n  watchFeatures_() {\n    // Listen to feature modification\n    if (this._featureListeners) {\n      this._featureListeners.forEach(function (l) {\n        ol_Observable_unByKey(l)\n      })\n    }\n    this._featureListeners = []\n    this.selection_.forEach(function (f) {\n      this._featureListeners.push(\n        f.on('change', function () {\n          if (!this.isUpdating_) {\n            this.drawSketch_()\n          }\n        }.bind(this))\n      )\n    }.bind(this))\n  }\n  /**\n   * @param {ol.MapBrowserEvent} evt Map browser event.\n   * @return {boolean} `true` to start the drag sequence.\n   * @private\n   */\n  handleDownEvent_(evt) {\n    if (!this._handleEvent(evt, this.selection_))\n      return\n    var sel = this.getFeatureAtPixel_(evt.pixel)\n    var feature = sel.feature\n    if (this.selection_.getLength()\n      && this.selection_.getArray().indexOf(feature) >= 0\n      && ((this.ispt_ && this.get('translate')) || this.get('translateFeature'))) {\n      sel.handle = 'translate'\n    }\n    if (sel.handle) {\n      this.mode_ = sel.handle\n      this.opt_ = sel.option\n      this.constraint_ = sel.constraint\n      // Save info\n      var viewRotation = this.getMap().getView().getRotation()\n      // Get coordinate of the handle (for snapping)\n      this.coordinate_ = feature.get('handle') ? feature.getGeometry().getCoordinates() : evt.coordinate;\n      this.pixel_ = this.getMap().getCoordinateFromPixel(this.coordinate_) // evt.pixel;\n      this.geoms_ = []\n      this.rotatedGeoms_ = []\n      var extent = ol_extent_createEmpty()\n      var rotExtent = ol_extent_createEmpty()\n      this.hasChanged_ = false;\n      for (var i = 0, f; f = this.selection_.item(i); i++) {\n        this.geoms_.push(f.getGeometry().clone())\n        extent = ol_extent_extend(extent, f.getGeometry().getExtent())\n        if (this.get('enableRotatedTransform') && viewRotation !== 0) {\n          var rotGeom = this.getGeometryRotateToZero_(f, true)\n          this.rotatedGeoms_.push(rotGeom)\n          rotExtent = ol_extent_extend(rotExtent, rotGeom.getExtent())\n        }\n      }\n      this.extent_ = (ol_geom_Polygon_fromExtent(extent)).getCoordinates()[0]\n      if (this.get('enableRotatedTransform') && viewRotation !== 0) {\n        this.rotatedExtent_ = (ol_geom_Polygon_fromExtent(rotExtent)).getCoordinates()[0]\n      }\n      if (this.mode_ === 'rotate') {\n        this.center_ = this.getCenter() || ol_extent_getCenter(extent)\n        // we are now rotating (cursor down on rotate mode), so apply the grabbing cursor\n        var element = evt.map.getTargetElement()\n        ol_ext_element.setCursor(element, this.Cursors.rotate0)\n        this.previousCursor_ = element.style.cursor\n      } else {\n        this.center_ = ol_extent_getCenter(extent)\n      }\n      this.angle_ = Math.atan2(this.center_[1] - evt.coordinate[1], this.center_[0] - evt.coordinate[0])\n\n      this.dispatchEvent({\n        type: this.mode_ + 'start',\n        feature: this.selection_.item(0),\n        features: this.selection_,\n        pixel: evt.pixel,\n        coordinate: evt.coordinate\n      })\n      return true\n    }\n    else if (this.get('selection')) {\n      if (feature) {\n        if (!this.addFn_(evt))\n          this.selection_.clear()\n        var index = this.selection_.getArray().indexOf(feature)\n        if (index < 0)\n          this.selection_.push(feature)\n        else\n          this.selection_.removeAt(index)\n      } else {\n        this.selection_.clear()\n      }\n      this.ispt_ = this.selection_.getLength() === 1 ? (this.selection_.item(0).getGeometry().getType() == \"Point\") : false\n      this.iscircle_ = (this.selection_.getLength() === 1 ? (this.selection_.item(0).getGeometry().getType() == \"Circle\") : false)\n      this.drawSketch_()\n      this.watchFeatures_()\n      this.dispatchEvent({ type: 'select', feature: feature, features: this.selection_, pixel: evt.pixel, coordinate: evt.coordinate })\n      return false\n    }\n  }\n  /**\n   * Get the rotation center\n   * @return {ol.coordinate|undefined}\n   */\n  getCenter() {\n    return this.get('center')\n  }\n  /**\n   * Set the rotation center\n   * @param {ol.coordinate|undefined} c the center point, default center on the objet\n   */\n  setCenter(c) {\n    return this.set('center', c)\n  }\n  /**\n   * @param {ol.MapBrowserEvent} evt Map browser event.\n   * @private\n   */\n  handleDragEvent_(evt) {\n    if (!this._handleEvent(evt, this.features_))\n      return\n    var viewRotation = this.getMap().getView().getRotation()\n    var i, j, f, geometry\n    var pt0 = [this.coordinate_[0], this.coordinate_[1]]\n    var pt = [evt.coordinate[0], evt.coordinate[1]]\n    this.isUpdating_ = true\n    this.hasChanged_ = true\n    switch (this.mode_) {\n      case 'rotate': {\n        var a = Math.atan2(this.center_[1] - pt[1], this.center_[0] - pt[0])\n        if (!this.ispt) {\n          // var geometry = this.geom_.clone();\n          // geometry.rotate(a-this.angle_, this.center_);\n          // this.feature_.setGeometry(geometry);\n          for (i = 0, f; f = this.selection_.item(i); i++) {\n            geometry = this.geoms_[i].clone()\n            geometry.rotate(a - this.angle_, this.center_)\n            // bug: ol, bad calculation circle geom extent\n            if (geometry.getType() == 'Circle')\n              geometry.setCenterAndRadius(geometry.getCenter(), geometry.getRadius())\n            f.setGeometry(geometry)\n          }\n        }\n        this.drawSketch_(true)\n        this.dispatchEvent({\n          type: 'rotating',\n          feature: this.selection_.item(0),\n          features: this.selection_,\n          angle: a - this.angle_,\n          pixel: evt.pixel,\n          coordinate: evt.coordinate\n        })\n        break\n      }\n      case 'translate': {\n        var deltaX = pt[0] - pt0[0]\n        var deltaY = pt[1] - pt0[1]\n\n        //this.feature_.getGeometry().translate(deltaX, deltaY);\n        for (i = 0, f; f = this.selection_.item(i); i++) {\n          f.getGeometry().translate(deltaX, deltaY)\n        }\n        this.handles_.forEach(function (f) {\n          f.getGeometry().translate(deltaX, deltaY)\n        })\n\n        this.coordinate_ = evt.coordinate\n        this.dispatchEvent({\n          type: 'translating',\n          feature: this.selection_.item(0),\n          features: this.selection_,\n          delta: [deltaX, deltaY],\n          pixel: evt.pixel,\n          coordinate: evt.coordinate\n        })\n        break\n      }\n      case 'scale': {\n        var center = this.center_\n        if (this.get('modifyCenter')(evt)) {\n          var extentCoordinates = this.extent_\n          if (this.get('enableRotatedTransform') && viewRotation !== 0) {\n            extentCoordinates = this.rotatedExtent_\n          }\n          center = extentCoordinates[(Number(this.opt_) + 2) % 4]\n        }\n        var keepRectangle = (this.geoms_.length == 1 && this._isRectangle(this.geoms_[0]))\n        var stretch = this.constraint_\n        var opt = this.opt_\n\n        var downCoordinate = this.coordinate_\n        var dragCoordinate = evt.coordinate\n        if (this.get('enableRotatedTransform') && viewRotation !== 0) {\n          var downPoint = new ol_geom_Point(this.coordinate_)\n          downPoint.rotate(viewRotation * -1, center)\n          downCoordinate = downPoint.getCoordinates()\n\n          var dragPoint = new ol_geom_Point(evt.coordinate)\n          dragPoint.rotate(viewRotation * -1, center)\n          dragCoordinate = dragPoint.getCoordinates()\n        }\n\n        var scx = ((dragCoordinate)[0] - (center)[0]) / (downCoordinate[0] - (center)[0])\n        var scy = ((dragCoordinate)[1] - (center)[1]) / (downCoordinate[1] - (center)[1])\n        var displacementVector = [dragCoordinate[0] - downCoordinate[0], (dragCoordinate)[1] - downCoordinate[1]]\n\n        if (this.get('enableRotatedTransform') && viewRotation !== 0) {\n          var centerPoint = new ol_geom_Point(center)\n          centerPoint.rotate(viewRotation * -1, this.getMap().getView().getCenter())\n          center = centerPoint.getCoordinates()\n        }\n\n        if (this.get('noFlip')) {\n          if (scx < 0)\n            scx = -scx\n          if (scy < 0)\n            scy = -scy\n        }\n\n        if (this.constraint_) {\n          if (this.constraint_ == \"h\")\n            scx = 1\n          else\n            scy = 1\n        } else {\n          if (this.get('keepAspectRatio')(evt)) {\n            scx = scy = Math.min(scx, scy)\n          }\n        }\n\n        for (i = 0, f; f = this.selection_.item(i); i++) {\n          geometry = (viewRotation === 0 || !this.get('enableRotatedTransform')) ? this.geoms_[i].clone() : this.rotatedGeoms_[i].clone()\n          geometry.applyTransform(function (g1, g2, dim) {\n            if (dim < 2) return g2\n\n            if (!keepRectangle) {\n              for (j = 0; j < g1.length; j += dim) {\n                if (scx != 1)\n                  g2[j] = center[0] + (g1[j] - center[0]) * scx\n                if (scy != 1)\n                  g2[j + 1] = center[1] + (g1[j + 1] - center[1]) * scy\n              }\n            } else {\n              var pointArray = [[6], [0, 8], [2], [4]]\n              var pointA = [g1[0], g1[1]]\n              var pointB = [g1[2], g1[3]]\n              var pointC = [g1[4], g1[5]]\n              var pointD = [g1[6], g1[7]]\n              var pointA1 = [g1[8], g1[9]]\n\n              if (stretch) {\n                var base = (opt % 2 === 0) ? this._countVector(pointA, pointB) : this._countVector(pointD, pointA)\n                var projectedVector = this._projectVectorOnVector(displacementVector, base)\n                var nextIndex = opt + 1 < pointArray.length ? opt + 1 : 0\n                var coordsToChange = [...pointArray[opt], ...pointArray[nextIndex]]\n\n                for (j = 0; j < g1.length; j += dim) {\n                  g2[j] = coordsToChange.includes(j) ? g1[j] + projectedVector[0] : g1[j]\n                  g2[j + 1] = coordsToChange.includes(j) ? g1[j + 1] + projectedVector[1] : g1[j + 1]\n                }\n              } else {\n                var projectedLeft, projectedRight\n                switch (opt) {\n                  case 0:\n                    displacementVector = this._countVector(pointD, dragCoordinate)\n                    projectedLeft = this._projectVectorOnVector(displacementVector, this._countVector(pointC, pointD))\n                    projectedRight = this._projectVectorOnVector(displacementVector, this._countVector(pointA, pointD));\n                    [g2[0], g2[1]] = this._movePoint(pointA, projectedLeft);\n                    [g2[4], g2[5]] = this._movePoint(pointC, projectedRight);\n                    [g2[6], g2[7]] = this._movePoint(pointD, displacementVector);\n                    [g2[8], g2[9]] = this._movePoint(pointA1, projectedLeft)\n                    break\n                  case 1:\n                    displacementVector = this._countVector(pointA, dragCoordinate)\n                    projectedLeft = this._projectVectorOnVector(displacementVector, this._countVector(pointD, pointA))\n                    projectedRight = this._projectVectorOnVector(displacementVector, this._countVector(pointB, pointA));\n                    [g2[0], g2[1]] = this._movePoint(pointA, displacementVector);\n                    [g2[2], g2[3]] = this._movePoint(pointB, projectedLeft);\n                    [g2[6], g2[7]] = this._movePoint(pointD, projectedRight);\n                    [g2[8], g2[9]] = this._movePoint(pointA1, displacementVector)\n                    break\n                  case 2:\n                    displacementVector = this._countVector(pointB, dragCoordinate)\n                    projectedLeft = this._projectVectorOnVector(displacementVector, this._countVector(pointA, pointB))\n                    projectedRight = this._projectVectorOnVector(displacementVector, this._countVector(pointC, pointB));\n                    [g2[0], g2[1]] = this._movePoint(pointA, projectedRight);\n                    [g2[2], g2[3]] = this._movePoint(pointB, displacementVector);\n                    [g2[4], g2[5]] = this._movePoint(pointC, projectedLeft);\n                    [g2[8], g2[9]] = this._movePoint(pointA1, projectedRight)\n                    break\n                  case 3:\n                    displacementVector = this._countVector(pointC, dragCoordinate)\n                    projectedLeft = this._projectVectorOnVector(displacementVector, this._countVector(pointB, pointC))\n                    projectedRight = this._projectVectorOnVector(displacementVector, this._countVector(pointD, pointC));\n                    [g2[2], g2[3]] = this._movePoint(pointB, projectedRight);\n                    [g2[4], g2[5]] = this._movePoint(pointC, displacementVector);\n                    [g2[6], g2[7]] = this._movePoint(pointD, projectedLeft)\n                    break\n                }\n              }\n            }\n\n            // bug: ol, bad calculation circle geom extent\n            if (geometry.getType() == 'Circle') geometry.setCenterAndRadius(geometry.getCenter(), geometry.getRadius())\n            return g2\n          }.bind(this))\n          if (this.get('enableRotatedTransform') && viewRotation !== 0) {\n            //geometry.rotate(viewRotation, rotationCenter);\n            geometry.rotate(viewRotation, this.getMap().getView().getCenter())\n          }\n          f.setGeometry(geometry)\n        }\n        this.drawSketch_()\n        this.dispatchEvent({\n          type: 'scaling',\n          feature: this.selection_.item(0),\n          features: this.selection_,\n          scale: [scx, scy],\n          pixel: evt.pixel,\n          coordinate: evt.coordinate\n        })\n        break\n      }\n      default: break\n    }\n    this.isUpdating_ = false\n  }\n  /**\n   * @param {ol.MapBrowserEvent} evt Event.\n   * @private\n   */\n  handleMoveEvent_(evt) {\n    if (!this._handleEvent(evt, this.features_))\n      return\n    // console.log(\"handleMoveEvent\");\n    if (!this.mode_) {\n      var sel = this.getFeatureAtPixel_(evt.pixel)\n      var element = evt.map.getTargetElement()\n      if (sel.feature) {\n        var c = sel.handle ? this.Cursors[(sel.handle || 'default') + (sel.constraint || '') + (sel.option || '')] : this.Cursors.select\n\n        if (this.previousCursor_ === undefined) {\n          this.previousCursor_ = element.style.cursor\n        }\n        ol_ext_element.setCursor(element, c);\n      } else {\n        if (this.previousCursor_ !== undefined) {\n          ol_ext_element.setCursor(element, this.previousCursor_)\n        }\n        this.previousCursor_ = undefined\n      }\n    }\n  }\n  /**\n   * @param {ol.MapBrowserEvent} evt Map browser event.\n   * @return {boolean} `false` to stop the drag sequence.\n   */\n  handleUpEvent_(evt) {\n    // remove rotate0 cursor on Up event, otherwise it's stuck on grab/grabbing\n    if (this.mode_ === 'rotate') {\n      var element = evt.map.getTargetElement()\n      ol_ext_element.setCursor(element, this.Cursors.default)\n      this.previousCursor_ = undefined\n    }\n\n    //dispatchEvent\n    this.dispatchEvent({\n      type: this.mode_ + 'end',\n      feature: this.selection_.item(0),\n      features: this.selection_,\n      oldgeom: this.geoms_[0],\n      oldgeoms: this.geoms_,\n      // handle changes\n      transformed: this.hasChanged_,\n    })\n    \n    this.drawSketch_()\n    this.hasChanged_ = false;\n    this.mode_ = null\n    return false\n  }\n  /** Set the point radius to calculate handles on points\n   *  @param {number|Array<number>|function} [pointRadius=0] radius for points or a function that takes a feature and returns the radius (or [radiusX, radiusY]). If not null show handles to transform the points\n   */\n  setPointRadius(pointRadius) {\n    if (typeof (pointRadius) === 'function') {\n      this._pointRadius = pointRadius\n    } else {\n      this._pointRadius = function () { return pointRadius }\n    }\n  }\n  /** Get the features that are selected for transform\n   * @return ol.Collection\n   */\n  getFeatures() {\n    return this.selection_;\n  }\n  /**\n   * @private\n   */\n  _projectVectorOnVector(displacement_vector, base) {\n    var k = (displacement_vector[0] * base[0] + displacement_vector[1] * base[1]) / (base[0] * base[0] + base[1] * base[1]);\n    return [base[0] * k, base[1] * k];\n  }\n  /**\n   * @private\n   */\n  _countVector(start, end) {\n    return [end[0] - start[0], end[1] - start[1]];\n  }\n  /**\n   * @private\n   */\n  _movePoint(point, displacementVector) {\n    return [point[0]+displacementVector[0], point[1]+displacementVector[1]];\n  }\n  \n  \n}\n\n/** Cursors for transform\n*/\nol_interaction_Transform.prototype.Cursors = {\n  'default': 'auto',\n  'select': 'pointer',\n  'translate': 'move',\n  'rotate': 'move',\n  'rotate0': 'move',\n  'scale': 'nesw-resize',\n  'scale1': 'nwse-resize',\n  'scale2': 'nesw-resize',\n  'scale3': 'nwse-resize',\n  'scalev': 'ew-resize',\n  'scaleh1': 'ns-resize',\n  'scalev2': 'ew-resize',\n  'scaleh3': 'ns-resize'\n};\n\nexport default ol_interaction_Transform\n","/*\tCopyright (c) 2016 Jean-Marc VIGLINO, \n\treleased under the CeCILL-B license (French BSD license)\n\t(http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).\n*/\nimport ol_interaction_Pointer from 'ol/interaction/Pointer.js'\nimport ol_geom_LineString from 'ol/geom/LineString.js'\nimport ol_geom_Polygon from 'ol/geom/Polygon.js'\nimport {ol_coordinate_dist2d, ol_coordinate_findSegment, ol_coordinate_offsetCoords} from \"../geom/GeomUtils.js\";\n\nimport ol_style_Style_defaultStyle from '../style/defaultStyle.js'\nimport ol_ext_element from '../util/element.js';\n\n/** Offset interaction for offseting feature geometry\n * @constructor\n * @extends {ol_interaction_Pointer}\n * @fires offsetstart\n * @fires offsetting\n * @fires offsetend\n * @param {any} options\n *\t@param {function} [options.filter] a function that takes a feature and a layer and return true if the feature can be modified\n *\t@param {ol.layer.Vector | Array<ol.layer.Vector>} options.layers list of feature to transform \n *\t@param {ol.Collection.<ol.Feature>} options.features collection of feature to transform\n *\t@param {ol.source.Vector | undefined} options.source source to duplicate feature when ctrl key is down\n *\t@param {boolean} options.duplicate force feature to duplicate (source must be set)\n *  @param {ol.style.Style | Array.<ol.style.Style> | ol.style.StyleFunction | undefined} style style for the sketch\n */\nvar ol_interaction_Offset = class olinteractionOffset extends ol_interaction_Pointer {\n  constructor(options) {\n    options = options || {};\n\n    // Extend pointer\n    super({\n      handleDownEvent: function(e) { return self.handleDownEvent_(e) },\n      handleDragEvent: function(e) { return self.handleDragEvent_(e) },\n      handleMoveEvent: function(e) { return self.handleMoveEvent_(e) },\n      handleUpEvent: function(e) { return self.handleUpEvent_(e) },\n    });\n    var self = this;\n\n    this._filter = options.filter;\n    // Collection of feature to transform\n    this.features_ = options.features;\n    // List of layers to transform\n    this.layers_ = options.layers ? (options.layers instanceof Array) ? options.layers : [options.layers] : null;\n    // duplicate\n    this.set('duplicate', options.duplicate);\n    this.source_ = options.source;\n    // Style\n    this._style = (typeof (options.style) === 'function') ? options.style : function () {\n      if (options.style)\n        return options.style;\n      else\n        return ol_style_Style_defaultStyle(true);\n    };\n\n    // init\n    this.previousCursor_ = false;\n  }\n  /** Get Feature at pixel\n   * @param {ol.MapBrowserEvent} evt Map browser event.\n   * @return {any} a feature and the hit point\n   * @private\n   */\n  getFeatureAtPixel_(e) {\n    var self = this;\n    return this.getMap().forEachFeatureAtPixel(e.pixel,\n      function (feature, layer) {\n        var current;\n        if (self._filter && !self._filter(feature, layer))\n          return false;\n        // feature belong to a layer\n        if (self.layers_) {\n          for (var i = 0; i < self.layers_.length; i++) {\n            if (self.layers_[i] === layer) {\n              current = feature;\n              break;\n            }\n          }\n        }\n\n        // feature in the collection\n        else if (self.features_) {\n          self.features_.forEach(function (f) {\n            if (f === feature) {\n              current = feature;\n            }\n          });\n        }\n\n        // Others\n        else {\n          current = feature;\n        }\n\n        // Only poygon or linestring\n        var typeGeom = current.getGeometry().getType();\n        if (current && /Polygon|LineString/.test(typeGeom)) {\n          if (typeGeom === 'Polygon' && current.getGeometry().getCoordinates().length > 1)\n            return false;\n          // test distance\n          var p = current.getGeometry().getClosestPoint(e.coordinate);\n          var dx = p[0] - e.coordinate[0];\n          var dy = p[1] - e.coordinate[1];\n          var d = Math.sqrt(dx * dx + dy * dy) / e.frameState.viewState.resolution;\n\n          if (d < 5) {\n            return {\n              feature: current,\n              hit: p,\n              coordinates: current.getGeometry().getCoordinates(),\n              geom: current.getGeometry().clone(),\n              geomType: typeGeom\n            };\n          } else {\n            return false;\n          }\n        } else {\n          return false;\n        }\n      }, { hitTolerance: 5 });\n  }\n  /**\n   * @param {ol.MapBrowserEvent} e Map browser event.\n   * @return {boolean} `true` to start the drag sequence.\n   * @private\n   */\n  handleDownEvent_(e) {\n    this.current_ = this.getFeatureAtPixel_(e);\n    if (this.current_) {\n      this.currentStyle_ = this.current_.feature.getStyle();\n      if (this.source_ && (this.get('duplicate') || e.originalEvent.ctrlKey)) {\n        this.current_.feature = this.current_.feature.clone();\n        this.current_.feature.setStyle(this._style(this.current_.feature));\n        this.source_.addFeature(this.current_.feature);\n      } else {\n        // Modify the current feature\n        this.current_.feature.setStyle(this._style(this.current_.feature));\n        this._modifystart = true;\n      }\n      this.dispatchEvent({ type: 'offsetstart', feature: this.current_.feature, offset: 0 });\n      return true;\n    } else {\n      return false;\n    }\n  }\n  /**\n   * @param {ol.MapBrowserEvent} e Map browser event.\n   * @private\n   */\n  handleDragEvent_(e) {\n    if (this._modifystart) {\n      this.dispatchEvent({ type: 'modifystart', features: [this.current_.feature] });\n      this._modifystart = false;\n    }\n    var p = this.current_.geom.getClosestPoint(e.coordinate);\n    var d = ol_coordinate_dist2d(p, e.coordinate);\n    var seg, v1, v2, offset;\n    switch (this.current_.geomType) {\n      case 'Polygon': {\n        seg = ol_coordinate_findSegment(p, this.current_.coordinates[0]).segment;\n        if (seg) {\n          v1 = [seg[1][0] - seg[0][0], seg[1][1] - seg[0][1]];\n          v2 = [e.coordinate[0] - p[0], e.coordinate[1] - p[1]];\n          if (v1[0] * v2[1] - v1[1] * v2[0] > 0) {\n            d = -d;\n          }\n\n          offset = [];\n          for (var i = 0; i < this.current_.coordinates.length; i++) {\n            offset.push(ol_coordinate_offsetCoords(this.current_.coordinates[i], i == 0 ? d : -d));\n          }\n          this.current_.feature.setGeometry(new ol_geom_Polygon(offset));\n        }\n        break;\n      }\n      case 'LineString': {\n        seg = ol_coordinate_findSegment(p, this.current_.coordinates).segment;\n        if (seg) {\n          v1 = [seg[1][0] - seg[0][0], seg[1][1] - seg[0][1]];\n          v2 = [e.coordinate[0] - p[0], e.coordinate[1] - p[1]];\n          if (v1[0] * v2[1] - v1[1] * v2[0] > 0) {\n            d = -d;\n          }\n          offset = ol_coordinate_offsetCoords(this.current_.coordinates, d);\n          this.current_.feature.setGeometry(new ol_geom_LineString(offset));\n        }\n        break;\n      }\n      default: {\n        break;\n      }\n    }\n    this.dispatchEvent({ type: 'offsetting', feature: this.current_.feature, offset: d, segment: [p, e.coordinate], coordinate: e.coordinate });\n  }\n  /**\n   * @param {ol.MapBrowserEvent} e Map browser event.\n   * @private\n   */\n  handleUpEvent_(e) {\n    if (!this._modifystart) {\n      this.dispatchEvent({ type: 'offsetend', feature: this.current_.feature, coordinate: e.coordinate });\n    }\n    this.current_.feature.setStyle(this.currentStyle_);\n    this.current_ = false;\n  }\n  /**\n   * @param {ol.MapBrowserEvent} e Event.\n   * @private\n   */\n  handleMoveEvent_(e) {\n    var f = this.getFeatureAtPixel_(e);\n    if (f) {\n      if (this.previousCursor_ === false) {\n        this.previousCursor_ = e.map.getTargetElement().style.cursor;\n      }\n      ol_ext_element.setCursor(e.map, 'pointer');\n    } else {\n      ol_ext_element.setCursor(e.map, this.previousCursor_);\n      this.previousCursor_ = false;\n    }\n  }\n}\n\nexport default ol_interaction_Offset\n","/**\n * @module ol/interaction/Extent\n */\nimport Event from '../events/Event.js';\nimport Feature from '../Feature.js';\nimport MapBrowserEventType from '../MapBrowserEventType.js';\nimport Point from '../geom/Point.js';\nimport PointerInteraction from './Pointer.js';\nimport VectorLayer from '../layer/Vector.js';\nimport VectorSource from '../source/Vector.js';\nimport {always} from '../events/condition.js';\nimport {boundingExtent, getArea} from '../extent.js';\nimport {\n  closestOnSegment,\n  distance as coordinateDistance,\n  squaredDistance as squaredCoordinateDistance,\n  squaredDistanceToSegment,\n} from '../coordinate.js';\nimport {createEditingStyle} from '../style/Style.js';\nimport {fromExtent as polygonFromExtent} from '../geom/Polygon.js';\nimport {toUserExtent} from '../proj.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * Default is {@link module:ol/events/condition.always}.\n * @property {import(\"../extent.js\").Extent} [extent] Initial extent. Defaults to no\n * initial extent.\n * @property {import(\"../style/Style.js\").StyleLike} [boxStyle]\n * Style for the drawn extent box. Defaults to the `Polygon` editing style\n * documented in {@link module:ol/style/Style~Style}\n * @property {number} [pixelTolerance=10] Pixel tolerance for considering the\n * pointer close enough to a segment or vertex for editing.\n * @property {import(\"../style/Style.js\").StyleLike} [pointerStyle]\n * Style for the cursor used to draw the extent. Defaults to the `Point` editing style\n * documented in {@link module:ol/style/Style~Style}\n * @property {boolean} [wrapX=false] Wrap the drawn extent across multiple maps\n * in the X direction? Only affects visuals, not functionality.\n */\n\n/**\n * @enum {string}\n */\nconst ExtentEventType = {\n  /**\n   * Triggered after the extent is changed\n   * @event ExtentEvent#extentchanged\n   * @api\n   */\n  EXTENTCHANGED: 'extentchanged',\n};\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/Extent~Extent} instances are\n * instances of this type.\n */\nexport class ExtentEvent extends Event {\n  /**\n   * @param {import(\"../extent.js\").Extent} extent the new extent\n   */\n  constructor(extent) {\n    super(ExtentEventType.EXTENTCHANGED);\n\n    /**\n     * The current extent.\n     * @type {import(\"../extent.js\").Extent}\n     * @api\n     */\n    this.extent = extent;\n  }\n}\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'extentchanged', ExtentEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'extentchanged', Return>} ExtentOnSignature\n */\n\n/**\n * @classdesc\n * Allows the user to draw a vector box by clicking and dragging on the map.\n * Once drawn, the vector box can be modified by dragging its vertices or edges.\n * This interaction is only supported for mouse devices.\n *\n * @fires ExtentEvent\n * @api\n */\nclass Extent extends PointerInteraction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options || {};\n\n    super(/** @type {import(\"./Pointer.js\").Options} */ (options));\n\n    /***\n     * @type {ExtentOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {ExtentOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {ExtentOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * Condition\n     * @type {import(\"../events/condition.js\").Condition}\n     * @private\n     */\n    this.condition_ = options.condition ? options.condition : always;\n\n    /**\n     * Extent of the drawn box\n     * @type {import(\"../extent.js\").Extent}\n     * @private\n     */\n    this.extent_ = null;\n\n    /**\n     * Handler for pointer move events\n     * @type {function (import(\"../coordinate.js\").Coordinate): import(\"../extent.js\").Extent|null}\n     * @private\n     */\n    this.pointerHandler_ = null;\n\n    /**\n     * Pixel threshold to snap to extent\n     * @type {number}\n     * @private\n     */\n    this.pixelTolerance_ =\n      options.pixelTolerance !== undefined ? options.pixelTolerance : 10;\n\n    /**\n     * Is the pointer snapped to an extent vertex\n     * @type {boolean}\n     * @private\n     */\n    this.snappedToVertex_ = false;\n\n    /**\n     * Feature for displaying the visible extent\n     * @type {Feature}\n     * @private\n     */\n    this.extentFeature_ = null;\n\n    /**\n     * Feature for displaying the visible pointer\n     * @type {Feature<Point>}\n     * @private\n     */\n    this.vertexFeature_ = null;\n\n    if (!options) {\n      options = {};\n    }\n\n    /**\n     * Layer for the extentFeature\n     * @type {VectorLayer}\n     * @private\n     */\n    this.extentOverlay_ = new VectorLayer({\n      source: new VectorSource({\n        useSpatialIndex: false,\n        wrapX: !!options.wrapX,\n      }),\n      style: options.boxStyle\n        ? options.boxStyle\n        : getDefaultExtentStyleFunction(),\n      updateWhileAnimating: true,\n      updateWhileInteracting: true,\n    });\n\n    /**\n     * Layer for the vertexFeature\n     * @type {VectorLayer}\n     * @private\n     */\n    this.vertexOverlay_ = new VectorLayer({\n      source: new VectorSource({\n        useSpatialIndex: false,\n        wrapX: !!options.wrapX,\n      }),\n      style: options.pointerStyle\n        ? options.pointerStyle\n        : getDefaultPointerStyleFunction(),\n      updateWhileAnimating: true,\n      updateWhileInteracting: true,\n    });\n\n    if (options.extent) {\n      this.setExtent(options.extent);\n    }\n  }\n\n  /**\n   * @param {import(\"../pixel.js\").Pixel} pixel cursor location\n   * @param {import(\"../Map.js\").default} map map\n   * @return {import(\"../coordinate.js\").Coordinate|null} snapped vertex on extent\n   * @private\n   */\n  snapToVertex_(pixel, map) {\n    const pixelCoordinate = map.getCoordinateFromPixelInternal(pixel);\n    const sortByDistance = function (a, b) {\n      return (\n        squaredDistanceToSegment(pixelCoordinate, a) -\n        squaredDistanceToSegment(pixelCoordinate, b)\n      );\n    };\n    const extent = this.getExtentInternal();\n    if (extent) {\n      //convert extents to line segments and find the segment closest to pixelCoordinate\n      const segments = getSegments(extent);\n      segments.sort(sortByDistance);\n      const closestSegment = segments[0];\n\n      let vertex = closestOnSegment(pixelCoordinate, closestSegment);\n      const vertexPixel = map.getPixelFromCoordinateInternal(vertex);\n\n      //if the distance is within tolerance, snap to the segment\n      if (coordinateDistance(pixel, vertexPixel) <= this.pixelTolerance_) {\n        //test if we should further snap to a vertex\n        const pixel1 = map.getPixelFromCoordinateInternal(closestSegment[0]);\n        const pixel2 = map.getPixelFromCoordinateInternal(closestSegment[1]);\n        const squaredDist1 = squaredCoordinateDistance(vertexPixel, pixel1);\n        const squaredDist2 = squaredCoordinateDistance(vertexPixel, pixel2);\n        const dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));\n        this.snappedToVertex_ = dist <= this.pixelTolerance_;\n        if (this.snappedToVertex_) {\n          vertex =\n            squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];\n        }\n        return vertex;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent pointer move event\n   * @private\n   */\n  handlePointerMove_(mapBrowserEvent) {\n    const pixel = mapBrowserEvent.pixel;\n    const map = mapBrowserEvent.map;\n\n    let vertex = this.snapToVertex_(pixel, map);\n    if (!vertex) {\n      vertex = map.getCoordinateFromPixelInternal(pixel);\n    }\n    this.createOrUpdatePointerFeature_(vertex);\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent extent\n   * @return {Feature} extent as featrue\n   * @private\n   */\n  createOrUpdateExtentFeature_(extent) {\n    let extentFeature = this.extentFeature_;\n\n    if (!extentFeature) {\n      if (!extent) {\n        extentFeature = new Feature({});\n      } else {\n        extentFeature = new Feature(polygonFromExtent(extent));\n      }\n      this.extentFeature_ = extentFeature;\n      this.extentOverlay_.getSource().addFeature(extentFeature);\n    } else {\n      if (!extent) {\n        extentFeature.setGeometry(undefined);\n      } else {\n        extentFeature.setGeometry(polygonFromExtent(extent));\n      }\n    }\n    return extentFeature;\n  }\n\n  /**\n   * @param {import(\"../coordinate.js\").Coordinate} vertex location of feature\n   * @return {Feature} vertex as feature\n   * @private\n   */\n  createOrUpdatePointerFeature_(vertex) {\n    let vertexFeature = this.vertexFeature_;\n    if (!vertexFeature) {\n      vertexFeature = new Feature(new Point(vertex));\n      this.vertexFeature_ = vertexFeature;\n      this.vertexOverlay_.getSource().addFeature(vertexFeature);\n    } else {\n      const geometry = vertexFeature.getGeometry();\n      geometry.setCoordinates(vertex);\n    }\n    return vertexFeature;\n  }\n\n  /**\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   */\n  handleEvent(mapBrowserEvent) {\n    if (!mapBrowserEvent.originalEvent || !this.condition_(mapBrowserEvent)) {\n      return true;\n    }\n    //display pointer (if not dragging)\n    if (\n      mapBrowserEvent.type == MapBrowserEventType.POINTERMOVE &&\n      !this.handlingDownUpSequence\n    ) {\n      this.handlePointerMove_(mapBrowserEvent);\n    }\n    //call pointer to determine up/down/drag\n    super.handleEvent(mapBrowserEvent);\n    //return false to stop propagation\n    return false;\n  }\n\n  /**\n   * Handle pointer down events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleDownEvent(mapBrowserEvent) {\n    const pixel = mapBrowserEvent.pixel;\n    const map = mapBrowserEvent.map;\n\n    const extent = this.getExtentInternal();\n    let vertex = this.snapToVertex_(pixel, map);\n\n    //find the extent corner opposite the passed corner\n    const getOpposingPoint = function (point) {\n      let x_ = null;\n      let y_ = null;\n      if (point[0] == extent[0]) {\n        x_ = extent[2];\n      } else if (point[0] == extent[2]) {\n        x_ = extent[0];\n      }\n      if (point[1] == extent[1]) {\n        y_ = extent[3];\n      } else if (point[1] == extent[3]) {\n        y_ = extent[1];\n      }\n      if (x_ !== null && y_ !== null) {\n        return [x_, y_];\n      }\n      return null;\n    };\n    if (vertex && extent) {\n      const x =\n        vertex[0] == extent[0] || vertex[0] == extent[2] ? vertex[0] : null;\n      const y =\n        vertex[1] == extent[1] || vertex[1] == extent[3] ? vertex[1] : null;\n\n      //snap to point\n      if (x !== null && y !== null) {\n        this.pointerHandler_ = getPointHandler(getOpposingPoint(vertex));\n        //snap to edge\n      } else if (x !== null) {\n        this.pointerHandler_ = getEdgeHandler(\n          getOpposingPoint([x, extent[1]]),\n          getOpposingPoint([x, extent[3]]),\n        );\n      } else if (y !== null) {\n        this.pointerHandler_ = getEdgeHandler(\n          getOpposingPoint([extent[0], y]),\n          getOpposingPoint([extent[2], y]),\n        );\n      }\n      //no snap - new bbox\n    } else {\n      vertex = map.getCoordinateFromPixelInternal(pixel);\n      this.setExtent([vertex[0], vertex[1], vertex[0], vertex[1]]);\n      this.pointerHandler_ = getPointHandler(vertex);\n    }\n    return true; //event handled; start downup sequence\n  }\n\n  /**\n   * Handle pointer drag events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   */\n  handleDragEvent(mapBrowserEvent) {\n    if (this.pointerHandler_) {\n      const pixelCoordinate = mapBrowserEvent.coordinate;\n      this.setExtent(this.pointerHandler_(pixelCoordinate));\n      this.createOrUpdatePointerFeature_(pixelCoordinate);\n    }\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleUpEvent(mapBrowserEvent) {\n    this.pointerHandler_ = null;\n    //If bbox is zero area, set to null;\n    const extent = this.getExtentInternal();\n    if (!extent || getArea(extent) === 0) {\n      this.setExtent(null);\n    }\n    return false; //Stop handling downup sequence\n  }\n\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../Map.js\").default} map Map.\n   */\n  setMap(map) {\n    this.extentOverlay_.setMap(map);\n    this.vertexOverlay_.setMap(map);\n    super.setMap(map);\n  }\n\n  /**\n   * Returns the current drawn extent in the view projection (or user projection if set)\n   *\n   * @return {import(\"../extent.js\").Extent} Drawn extent in the view projection.\n   * @api\n   */\n  getExtent() {\n    return toUserExtent(\n      this.getExtentInternal(),\n      this.getMap().getView().getProjection(),\n    );\n  }\n\n  /**\n   * Returns the current drawn extent in the view projection\n   *\n   * @return {import(\"../extent.js\").Extent} Drawn extent in the view projection.\n   * @api\n   */\n  getExtentInternal() {\n    return this.extent_;\n  }\n\n  /**\n   * Manually sets the drawn extent, using the view projection.\n   *\n   * @param {import(\"../extent.js\").Extent} extent Extent\n   * @api\n   */\n  setExtent(extent) {\n    //Null extent means no bbox\n    this.extent_ = extent ? extent : null;\n    this.createOrUpdateExtentFeature_(extent);\n    this.dispatchEvent(new ExtentEvent(this.extent_));\n  }\n}\n\n/**\n * Returns the default style for the drawn bbox\n *\n * @return {import(\"../style/Style.js\").StyleFunction} Default Extent style\n */\nfunction getDefaultExtentStyleFunction() {\n  const style = createEditingStyle();\n  return function (feature, resolution) {\n    return style['Polygon'];\n  };\n}\n\n/**\n * Returns the default style for the pointer\n *\n * @return {import(\"../style/Style.js\").StyleFunction} Default pointer style\n */\nfunction getDefaultPointerStyleFunction() {\n  const style = createEditingStyle();\n  return function (feature, resolution) {\n    return style['Point'];\n  };\n}\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} fixedPoint corner that will be unchanged in the new extent\n * @return {function (import(\"../coordinate.js\").Coordinate): import(\"../extent.js\").Extent} event handler\n */\nfunction getPointHandler(fixedPoint) {\n  return function (point) {\n    return boundingExtent([fixedPoint, point]);\n  };\n}\n\n/**\n * @param {import(\"../coordinate.js\").Coordinate} fixedP1 first corner that will be unchanged in the new extent\n * @param {import(\"../coordinate.js\").Coordinate} fixedP2 second corner that will be unchanged in the new extent\n * @return {function (import(\"../coordinate.js\").Coordinate): import(\"../extent.js\").Extent|null} event handler\n */\nfunction getEdgeHandler(fixedP1, fixedP2) {\n  if (fixedP1[0] == fixedP2[0]) {\n    return function (point) {\n      return boundingExtent([fixedP1, [point[0], fixedP2[1]]]);\n    };\n  }\n  if (fixedP1[1] == fixedP2[1]) {\n    return function (point) {\n      return boundingExtent([fixedP1, [fixedP2[0], point[1]]]);\n    };\n  }\n  return null;\n}\n\n/**\n * @param {import(\"../extent.js\").Extent} extent extent\n * @return {Array<Array<import(\"../coordinate.js\").Coordinate>>} extent line segments\n */\nfunction getSegments(extent) {\n  return [\n    [\n      [extent[0], extent[1]],\n      [extent[0], extent[3]],\n    ],\n    [\n      [extent[0], extent[3]],\n      [extent[2], extent[3]],\n    ],\n    [\n      [extent[2], extent[3]],\n      [extent[2], extent[1]],\n    ],\n    [\n      [extent[2], extent[1]],\n      [extent[0], extent[1]],\n    ],\n  ];\n}\n\nexport default Extent;\n","/**\n * @module ol/events/SnapEvent\n */\nimport Event from './Event.js';\n\n/**\n * @enum {string}\n */\nexport const SnapEventType = {\n  /**\n   * Triggered upon snapping to vertex or edge\n   * @event SnapEvent#snap\n   * @api\n   */\n  SNAP: 'snap',\n};\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/Snap~Snap} instances are instances of this\n */\nexport class SnapEvent extends Event {\n  /**\n   * @param {SnapEventType} type Type.\n   * @param {Object} options Options.\n   * @param {import(\"../coordinate.js\").Coordinate} options.vertex The snapped vertex.\n   * @param {import(\"../coordinate.js\").Coordinate} options.vertexPixel The pixel of the snapped vertex.\n   * @param {import(\"../Feature.js\").default} options.feature The feature being snapped.\n   * @param {Array<import(\"../coordinate.js\").Coordinate>|null} options.segment Segment, or `null` if snapped to a vertex.\n   */\n  constructor(type, options) {\n    super(type);\n    /**\n     * The Map coordinate of the snapped point.\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @api\n     */\n    this.vertex = options.vertex;\n    /**\n     * The Map pixel of the snapped point.\n     * @type {Array<number>&Array<number>}\n     * @api\n     */\n    this.vertexPixel = options.vertexPixel;\n    /**\n     * The feature closest to the snapped point.\n     * @type {import(\"../Feature.js\").default<import(\"../geom/Geometry.js\").default>}\n     * @api\n     */\n    this.feature = options.feature;\n    /**\n     * The segment closest to the snapped point, if snapped to a segment.\n     * @type {Array<import(\"../coordinate.js\").Coordinate>|null}\n     * @api\n     */\n    this.segment = options.segment;\n  }\n}\n","/**\n * @module ol/interaction/Snap\n */\nimport CollectionEventType from '../CollectionEventType.js';\nimport EventType from '../events/EventType.js';\nimport PointerInteraction from './Pointer.js';\nimport RBush from '../structs/RBush.js';\nimport VectorEventType from '../source/VectorEventType.js';\nimport {FALSE, TRUE} from '../functions.js';\nimport {SnapEvent, SnapEventType} from '../events/SnapEvent.js';\nimport {boundingExtent, buffer, createEmpty} from '../extent.js';\nimport {\n  closestOnCircle,\n  closestOnSegment,\n  squaredDistance,\n} from '../coordinate.js';\nimport {fromCircle} from '../geom/Polygon.js';\nimport {\n  fromUserCoordinate,\n  getUserProjection,\n  toUserCoordinate,\n  toUserExtent,\n} from '../proj.js';\nimport {getUid} from '../util.js';\nimport {listen, unlistenByKey} from '../events.js';\n\n/**\n * @typedef {Object} Result\n * @property {import(\"../coordinate.js\").Coordinate|null} vertex Vertex.\n * @property {import(\"../pixel.js\").Pixel|null} vertexPixel VertexPixel.\n * @property {import(\"../Feature.js\").default|null} feature Feature.\n * @property {Array<import(\"../coordinate.js\").Coordinate>|null} segment Segment, or `null` if snapped to a vertex.\n */\n\n/**\n * @typedef {Object} SegmentData\n * @property {import(\"../Feature.js\").default} feature Feature.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} segment Segment.\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../Collection.js\").default<import(\"../Feature.js\").default>} [features] Snap to these features. Either this option or source should be provided.\n * @property {boolean} [edge=true] Snap to edges.\n * @property {boolean} [vertex=true] Snap to vertices.\n * @property {number} [pixelTolerance=10] Pixel tolerance for considering the pointer close enough to a segment or\n * vertex for snapping.\n * @property {import(\"../source/Vector.js\").default} [source] Snap to features from this source. Either this option or features should be provided\n */\n\n/**\n * @param  {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} evt Event.\n * @return {import(\"../Feature.js\").default|null} Feature.\n */\nfunction getFeatureFromEvent(evt) {\n  if (\n    /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */ (evt).feature\n  ) {\n    return /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */ (evt)\n      .feature;\n  }\n  if (\n    /** @type {import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} */ (\n      evt\n    ).element\n  ) {\n    return /** @type {import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} */ (\n      evt\n    ).element;\n  }\n  return null;\n}\n\nconst tempSegment = [];\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'snap', SnapEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'snap', Return>} SnapOnSignature\n */\n\n/**\n * @classdesc\n * Handles snapping of vector features while modifying or drawing them.  The\n * features can come from a {@link module:ol/source/Vector~VectorSource} or {@link module:ol/Collection~Collection}\n * Any interaction object that allows the user to interact\n * with the features using the mouse can benefit from the snapping, as long\n * as it is added before.\n *\n * The snap interaction modifies map browser event `coordinate` and `pixel`\n * properties to force the snap to occur to any interaction that them.\n *\n * Example:\n *\n *     import Snap from 'ol/interaction/Snap.js';\n *\n *     const snap = new Snap({\n *       source: source\n *     });\n *\n *     map.addInteraction(snap);\n *\n * @fires SnapEvent\n * @api\n */\nclass Snap extends PointerInteraction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const pointerOptions = /** @type {import(\"./Pointer.js\").Options} */ (\n      options\n    );\n\n    if (!pointerOptions.handleDownEvent) {\n      pointerOptions.handleDownEvent = TRUE;\n    }\n\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n\n    super(pointerOptions);\n\n    /***\n     * @type {SnapOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {SnapOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {SnapOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @type {import(\"../source/Vector.js\").default|null}\n     * @private\n     */\n    this.source_ = options.source ? options.source : null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.vertex_ = options.vertex !== undefined ? options.vertex : true;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.edge_ = options.edge !== undefined ? options.edge : true;\n\n    /**\n     * @type {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|null}\n     * @private\n     */\n    this.features_ = options.features ? options.features : null;\n\n    /**\n     * @type {Array<import(\"../events.js\").EventsKey>}\n     * @private\n     */\n    this.featuresListenerKeys_ = [];\n\n    /**\n     * @type {Object<string, import(\"../events.js\").EventsKey>}\n     * @private\n     */\n    this.featureChangeListenerKeys_ = {};\n\n    /**\n     * Extents are preserved so indexed segment can be quickly removed\n     * when its feature geometry changes\n     * @type {Object<string, import(\"../extent.js\").Extent>}\n     * @private\n     */\n    this.indexedFeaturesExtents_ = {};\n\n    /**\n     * If a feature geometry changes while a pointer drag|move event occurs, the\n     * feature doesn't get updated right away.  It will be at the next 'pointerup'\n     * event fired.\n     * @type {!Object<string, import(\"../Feature.js\").default>}\n     * @private\n     */\n    this.pendingFeatures_ = {};\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.pixelTolerance_ =\n      options.pixelTolerance !== undefined ? options.pixelTolerance : 10;\n\n    /**\n     * Segment RTree for each layer\n     * @type {import(\"../structs/RBush.js\").default<SegmentData>}\n     * @private\n     */\n    this.rBush_ = new RBush();\n\n    /**\n     * @const\n     * @private\n     * @type {Object<string, function(Array<Array<import('../coordinate.js').Coordinate>>, import(\"../geom/Geometry.js\").default): void>}\n     */\n    this.GEOMETRY_SEGMENTERS_ = {\n      'Point': this.segmentPointGeometry_.bind(this),\n      'LineString': this.segmentLineStringGeometry_.bind(this),\n      'LinearRing': this.segmentLineStringGeometry_.bind(this),\n      'Polygon': this.segmentPolygonGeometry_.bind(this),\n      'MultiPoint': this.segmentMultiPointGeometry_.bind(this),\n      'MultiLineString': this.segmentMultiLineStringGeometry_.bind(this),\n      'MultiPolygon': this.segmentMultiPolygonGeometry_.bind(this),\n      'GeometryCollection': this.segmentGeometryCollectionGeometry_.bind(this),\n      'Circle': this.segmentCircleGeometry_.bind(this),\n    };\n  }\n\n  /**\n   * Add a feature to the collection of features that we may snap to.\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {boolean} [register] Whether to listen to the feature change or not\n   *     Defaults to `true`.\n   * @api\n   */\n  addFeature(feature, register) {\n    register = register !== undefined ? register : true;\n    const feature_uid = getUid(feature);\n    const geometry = feature.getGeometry();\n    if (geometry) {\n      const segmenter = this.GEOMETRY_SEGMENTERS_[geometry.getType()];\n      if (segmenter) {\n        this.indexedFeaturesExtents_[feature_uid] =\n          geometry.getExtent(createEmpty());\n        const segments =\n          /** @type {Array<Array<import('../coordinate.js').Coordinate>>} */ ([]);\n        segmenter(segments, geometry);\n        if (segments.length === 1) {\n          this.rBush_.insert(boundingExtent(segments[0]), {\n            feature: feature,\n            segment: segments[0],\n          });\n        } else if (segments.length > 1) {\n          const extents = segments.map((s) => boundingExtent(s));\n          const segmentsData = segments.map((segment) => ({\n            feature: feature,\n            segment: segment,\n          }));\n          this.rBush_.load(extents, segmentsData);\n        }\n      }\n    }\n\n    if (register) {\n      this.featureChangeListenerKeys_[feature_uid] = listen(\n        feature,\n        EventType.CHANGE,\n        this.handleFeatureChange_,\n        this,\n      );\n    }\n  }\n\n  /**\n   * @return {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|Array<import(\"../Feature.js\").default>} Features.\n   * @private\n   */\n  getFeatures_() {\n    /** @type {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|Array<import(\"../Feature.js\").default>} */\n    let features;\n    if (this.features_) {\n      features = this.features_;\n    } else if (this.source_) {\n      features = this.source_.getFeatures();\n    }\n    return features;\n  }\n\n  /**\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   * @api\n   */\n  handleEvent(evt) {\n    const result = this.snapTo(evt.pixel, evt.coordinate, evt.map);\n    if (result) {\n      evt.coordinate = result.vertex.slice(0, 2);\n      evt.pixel = result.vertexPixel;\n      this.dispatchEvent(\n        new SnapEvent(SnapEventType.SNAP, {\n          vertex: evt.coordinate,\n          vertexPixel: evt.pixel,\n          feature: result.feature,\n          segment: result.segment,\n        }),\n      );\n    }\n    return super.handleEvent(evt);\n  }\n\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} evt Event.\n   * @private\n   */\n  handleFeatureAdd_(evt) {\n    const feature = getFeatureFromEvent(evt);\n    if (feature) {\n      this.addFeature(feature);\n    }\n  }\n\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent<import(\"../Feature.js\").default>} evt Event.\n   * @private\n   */\n  handleFeatureRemove_(evt) {\n    const feature = getFeatureFromEvent(evt);\n    if (feature) {\n      this.removeFeature(feature);\n    }\n  }\n\n  /**\n   * @param {import(\"../events/Event.js\").default} evt Event.\n   * @private\n   */\n  handleFeatureChange_(evt) {\n    const feature = /** @type {import(\"../Feature.js\").default} */ (evt.target);\n    if (this.handlingDownUpSequence) {\n      const uid = getUid(feature);\n      if (!(uid in this.pendingFeatures_)) {\n        this.pendingFeatures_[uid] = feature;\n      }\n    } else {\n      this.updateFeature_(feature);\n    }\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} evt Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleUpEvent(evt) {\n    const featuresToUpdate = Object.values(this.pendingFeatures_);\n    if (featuresToUpdate.length) {\n      featuresToUpdate.forEach(this.updateFeature_.bind(this));\n      this.pendingFeatures_ = {};\n    }\n    return false;\n  }\n\n  /**\n   * Remove a feature from the collection of features that we may snap to.\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {boolean} [unlisten] Whether to unlisten to the feature change\n   *     or not. Defaults to `true`.\n   * @api\n   */\n  removeFeature(feature, unlisten) {\n    const unregister = unlisten !== undefined ? unlisten : true;\n    const feature_uid = getUid(feature);\n    const extent = this.indexedFeaturesExtents_[feature_uid];\n    if (extent) {\n      const rBush = this.rBush_;\n      const nodesToRemove = [];\n      rBush.forEachInExtent(extent, function (node) {\n        if (feature === node.feature) {\n          nodesToRemove.push(node);\n        }\n      });\n      for (let i = nodesToRemove.length - 1; i >= 0; --i) {\n        rBush.remove(nodesToRemove[i]);\n      }\n    }\n\n    if (unregister) {\n      unlistenByKey(this.featureChangeListenerKeys_[feature_uid]);\n      delete this.featureChangeListenerKeys_[feature_uid];\n    }\n  }\n\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../Map.js\").default} map Map.\n   */\n  setMap(map) {\n    const currentMap = this.getMap();\n    const keys = this.featuresListenerKeys_;\n    const features = /** @type {Array<import(\"../Feature.js\").default>} */ (\n      this.getFeatures_()\n    );\n\n    if (currentMap) {\n      keys.forEach(unlistenByKey);\n      keys.length = 0;\n      this.rBush_.clear();\n      Object.values(this.featureChangeListenerKeys_).forEach(unlistenByKey);\n      this.featureChangeListenerKeys_ = {};\n    }\n    super.setMap(map);\n\n    if (map) {\n      if (this.features_) {\n        keys.push(\n          listen(\n            this.features_,\n            CollectionEventType.ADD,\n            this.handleFeatureAdd_,\n            this,\n          ),\n          listen(\n            this.features_,\n            CollectionEventType.REMOVE,\n            this.handleFeatureRemove_,\n            this,\n          ),\n        );\n      } else if (this.source_) {\n        keys.push(\n          listen(\n            this.source_,\n            VectorEventType.ADDFEATURE,\n            this.handleFeatureAdd_,\n            this,\n          ),\n          listen(\n            this.source_,\n            VectorEventType.REMOVEFEATURE,\n            this.handleFeatureRemove_,\n            this,\n          ),\n        );\n      }\n      features.forEach((feature) => this.addFeature(feature));\n    }\n  }\n\n  /**\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel\n   * @param {import(\"../coordinate.js\").Coordinate} pixelCoordinate Coordinate\n   * @param {import(\"../Map.js\").default} map Map.\n   * @return {Result|null} Snap result\n   */\n  snapTo(pixel, pixelCoordinate, map) {\n    const projection = map.getView().getProjection();\n    const projectedCoordinate = fromUserCoordinate(pixelCoordinate, projection);\n\n    const box = toUserExtent(\n      buffer(\n        boundingExtent([projectedCoordinate]),\n        map.getView().getResolution() * this.pixelTolerance_,\n      ),\n      projection,\n    );\n\n    const segments = this.rBush_.getInExtent(box);\n    const segmentsLength = segments.length;\n    if (segmentsLength === 0) {\n      return null;\n    }\n\n    let closestVertex;\n    let minSquaredDistance = Infinity;\n    let closestFeature;\n    let closestSegment = null;\n\n    const squaredPixelTolerance = this.pixelTolerance_ * this.pixelTolerance_;\n    const getResult = () => {\n      if (closestVertex) {\n        const vertexPixel = map.getPixelFromCoordinate(closestVertex);\n        const squaredPixelDistance = squaredDistance(pixel, vertexPixel);\n        if (squaredPixelDistance <= squaredPixelTolerance) {\n          return {\n            vertex: closestVertex,\n            vertexPixel: [\n              Math.round(vertexPixel[0]),\n              Math.round(vertexPixel[1]),\n            ],\n            feature: closestFeature,\n            segment: closestSegment,\n          };\n        }\n      }\n      return null;\n    };\n\n    if (this.vertex_) {\n      for (let i = 0; i < segmentsLength; ++i) {\n        const segmentData = segments[i];\n        if (segmentData.feature.getGeometry().getType() !== 'Circle') {\n          segmentData.segment.forEach((vertex) => {\n            const tempVertexCoord = fromUserCoordinate(vertex, projection);\n            const delta = squaredDistance(projectedCoordinate, tempVertexCoord);\n            if (delta < minSquaredDistance) {\n              closestVertex = vertex;\n              minSquaredDistance = delta;\n              closestFeature = segmentData.feature;\n            }\n          });\n        }\n      }\n      const result = getResult();\n      if (result) {\n        return result;\n      }\n    }\n\n    if (this.edge_) {\n      for (let i = 0; i < segmentsLength; ++i) {\n        let vertex = null;\n        const segmentData = segments[i];\n        if (segmentData.feature.getGeometry().getType() === 'Circle') {\n          let circleGeometry = segmentData.feature.getGeometry();\n          const userProjection = getUserProjection();\n          if (userProjection) {\n            circleGeometry = circleGeometry\n              .clone()\n              .transform(userProjection, projection);\n          }\n          vertex = closestOnCircle(\n            projectedCoordinate,\n            /** @type {import(\"../geom/Circle.js\").default} */ (circleGeometry),\n          );\n        } else {\n          const [segmentStart, segmentEnd] = segmentData.segment;\n          // points have only one coordinate\n          if (segmentEnd) {\n            tempSegment[0] = fromUserCoordinate(segmentStart, projection);\n            tempSegment[1] = fromUserCoordinate(segmentEnd, projection);\n            vertex = closestOnSegment(projectedCoordinate, tempSegment);\n          }\n        }\n        if (vertex) {\n          const delta = squaredDistance(projectedCoordinate, vertex);\n          if (delta < minSquaredDistance) {\n            closestVertex = toUserCoordinate(vertex, projection);\n            closestSegment =\n              segmentData.feature.getGeometry().getType() === 'Circle'\n                ? null\n                : segmentData.segment;\n            minSquaredDistance = delta;\n            closestFeature = segmentData.feature;\n          }\n        }\n      }\n\n      const result = getResult();\n      if (result) {\n        return result;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @private\n   */\n  updateFeature_(feature) {\n    this.removeFeature(feature, false);\n    this.addFeature(feature, false);\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/Circle.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentCircleGeometry_(segments, geometry) {\n    const projection = this.getMap().getView().getProjection();\n    let circleGeometry = geometry;\n    const userProjection = getUserProjection();\n    if (userProjection) {\n      circleGeometry = circleGeometry\n        .clone()\n        .transform(userProjection, projection);\n    }\n    const polygon = fromCircle(circleGeometry);\n    if (userProjection) {\n      polygon.transform(projection, userProjection);\n    }\n    const coordinates = polygon.getCoordinates()[0];\n    for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      segments.push(coordinates.slice(i, i + 2));\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentGeometryCollectionGeometry_(segments, geometry) {\n    const geometries = geometry.getGeometriesArray();\n    for (let i = 0; i < geometries.length; ++i) {\n      const segmenter = this.GEOMETRY_SEGMENTERS_[geometries[i].getType()];\n      if (segmenter) {\n        segmenter(segments, geometries[i]);\n      }\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/LineString.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentLineStringGeometry_(segments, geometry) {\n    const coordinates = geometry.getCoordinates();\n    for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      segments.push(coordinates.slice(i, i + 2));\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/MultiLineString.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentMultiLineStringGeometry_(segments, geometry) {\n    const lines = geometry.getCoordinates();\n    for (let j = 0, jj = lines.length; j < jj; ++j) {\n      const coordinates = lines[j];\n      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        segments.push(coordinates.slice(i, i + 2));\n      }\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/MultiPoint.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentMultiPointGeometry_(segments, geometry) {\n    geometry.getCoordinates().forEach((point) => {\n      segments.push([point]);\n    });\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentMultiPolygonGeometry_(segments, geometry) {\n    const polygons = geometry.getCoordinates();\n    for (let k = 0, kk = polygons.length; k < kk; ++k) {\n      const rings = polygons[k];\n      for (let j = 0, jj = rings.length; j < jj; ++j) {\n        const coordinates = rings[j];\n        for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n          segments.push(coordinates.slice(i, i + 2));\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/Point.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentPointGeometry_(segments, geometry) {\n    segments.push([geometry.getCoordinates()]);\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments\n   * @param {import(\"../geom/Polygon.js\").default} geometry Geometry.\n   * @private\n   */\n  segmentPolygonGeometry_(segments, geometry) {\n    const rings = geometry.getCoordinates();\n    for (let j = 0, jj = rings.length; j < jj; ++j) {\n      const coordinates = rings[j];\n      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        segments.push(coordinates.slice(i, i + 2));\n      }\n    }\n  }\n}\n\nexport default Snap;\n","import {ol_coordinate_equal} from \"./GeomUtils.js\";\nimport ol_geom_LineString from \"ol/geom/LineString.js\";\n\n/** Split a lineString by a point or a list of points\n *\tNB: points must be on the line, use getClosestPoint() to get one\n * @param {ol.Coordinate | Array<ol.Coordinate>} pt points to split the line\n * @param {Number} tol distance tolerance for 2 points to be equal\n */\nol_geom_LineString.prototype.splitAt = function(pt, tol) {\n  var i;\n  if (!pt) return [this];\n    if (!tol) tol = 1e-10;\n    // Test if list of points\n    if (pt.length && pt[0].length) {\n      var result = [this];\n      for (i=0; i<pt.length; i++) {\n        var r = [];\n        for (var k=0; k<result.length; k++) {\n          var ri = result[k].splitAt(pt[i], tol);\n          r = r.concat(ri);\n        }\n        result = r;\n      }\n      return result;\n    }\n    // Nothing to do\n    if (ol_coordinate_equal(pt,this.getFirstCoordinate())\n    || ol_coordinate_equal(pt,this.getLastCoordinate())) {\n      return [this];\n    }\n    // Get\n    var c0 = this.getCoordinates();\n    var ci=[c0[0]];\n    var c = [];\n    for (i=0; i<c0.length-1; i++) {\n      // Filter equal points\n      if (ol_coordinate_equal(c0[i],c0[i+1])) continue;\n      // Extremity found\n      if (ol_coordinate_equal(pt,c0[i+1])) {\n        ci.push(c0[i+1]);\n        c.push(new ol_geom_LineString(ci));\n        ci = [];\n      }\n      // Test alignement\n      else if (!ol_coordinate_equal(pt,c0[i])) {\n        var d1, d2, split=false;\n        if (c0[i][0] == c0[i+1][0]) {\n          d1 = (c0[i][1]-pt[1]) / (c0[i][1]-c0[i+1][1]);\n          split = (c0[i][0] == pt[0]) && (0 < d1 && d1 <= 1)\n        } else if (c0[i][1] == c0[i+1][1]) {\n          d1 = (c0[i][0]-pt[0]) / (c0[i][0]-c0[i+1][0]);\n          split = (c0[i][1] == pt[1]) && (0 < d1 && d1 <= 1)\n        } else {\n          d1 = (c0[i][0]-pt[0]) / (c0[i][0]-c0[i+1][0]);\n          d2 = (c0[i][1]-pt[1]) / (c0[i][1]-c0[i+1][1]);\n          split = (Math.abs(d1-d2) <= tol && 0 < d1 && d1 <= 1)\n        }\n        // pt is inside the segment > split\n        if (split) {\n          ci.push(pt);\n          c.push (new ol_geom_LineString(ci));\n          ci = [pt];\n        }\n      }\n      ci.push(c0[i+1]);\n    }\n    if (ci.length>1) c.push (new ol_geom_LineString(ci));\n    if (c.length) return c;\n    else return [this];\n}\n\n// import('ol-ext/geom/LineStringSplitAt')","/**\n * @module ol/geom/Circle\n */\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {createOrUpdate, forEachCorner, intersects} from '../extent.js';\nimport {deflateCoordinate} from './flat/deflate.js';\nimport {rotate} from './flat/transform.js';\n\n/**\n * @classdesc\n * Circle geometry.\n *\n * @api\n */\nclass Circle extends SimpleGeometry {\n  /**\n   * @param {!import(\"../coordinate.js\").Coordinate} center Center.\n   *     For internal use, flat coordinates in combination with `layout` and no\n   *     `radius` are also accepted.\n   * @param {number} [radius] Radius in units of the projection.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   */\n  constructor(center, radius, layout) {\n    super();\n    if (layout !== undefined && radius === undefined) {\n      this.setFlatCoordinates(layout, center);\n    } else {\n      radius = radius ? radius : 0;\n      this.setCenterAndRadius(center, radius, layout);\n    }\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!Circle} Clone.\n   * @api\n   */\n  clone() {\n    const circle = new Circle(\n      this.flatCoordinates.slice(),\n      undefined,\n      this.layout,\n    );\n    circle.applyProperties(this);\n    return circle;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    const flatCoordinates = this.flatCoordinates;\n    const dx = x - flatCoordinates[0];\n    const dy = y - flatCoordinates[1];\n    const squaredDistance = dx * dx + dy * dy;\n    if (squaredDistance < minSquaredDistance) {\n      if (squaredDistance === 0) {\n        for (let i = 0; i < this.stride; ++i) {\n          closestPoint[i] = flatCoordinates[i];\n        }\n      } else {\n        const delta = this.getRadius() / Math.sqrt(squaredDistance);\n        closestPoint[0] = flatCoordinates[0] + delta * dx;\n        closestPoint[1] = flatCoordinates[1] + delta * dy;\n        for (let i = 2; i < this.stride; ++i) {\n          closestPoint[i] = flatCoordinates[i];\n        }\n      }\n      closestPoint.length = this.stride;\n      return squaredDistance;\n    }\n    return minSquaredDistance;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @return {boolean} Contains (x, y).\n   */\n  containsXY(x, y) {\n    const flatCoordinates = this.flatCoordinates;\n    const dx = x - flatCoordinates[0];\n    const dy = y - flatCoordinates[1];\n    return dx * dx + dy * dy <= this.getRadiusSquared_();\n  }\n\n  /**\n   * Return the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.\n   * @return {import(\"../coordinate.js\").Coordinate} Center.\n   * @api\n   */\n  getCenter() {\n    return this.flatCoordinates.slice(0, this.stride);\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @protected\n   * @return {import(\"../extent.js\").Extent} extent Extent.\n   */\n  computeExtent(extent) {\n    const flatCoordinates = this.flatCoordinates;\n    const radius = flatCoordinates[this.stride] - flatCoordinates[0];\n    return createOrUpdate(\n      flatCoordinates[0] - radius,\n      flatCoordinates[1] - radius,\n      flatCoordinates[0] + radius,\n      flatCoordinates[1] + radius,\n      extent,\n    );\n  }\n\n  /**\n   * Return the radius of the circle.\n   * @return {number} Radius.\n   * @api\n   */\n  getRadius() {\n    return Math.sqrt(this.getRadiusSquared_());\n  }\n\n  /**\n   * @private\n   * @return {number} Radius squared.\n   */\n  getRadiusSquared_() {\n    const dx = this.flatCoordinates[this.stride] - this.flatCoordinates[0];\n    const dy = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];\n    return dx * dx + dy * dy;\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   */\n  getType() {\n    return 'Circle';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   */\n  intersectsExtent(extent) {\n    const circleExtent = this.getExtent();\n    if (intersects(extent, circleExtent)) {\n      const center = this.getCenter();\n\n      if (extent[0] <= center[0] && extent[2] >= center[0]) {\n        return true;\n      }\n      if (extent[1] <= center[1] && extent[3] >= center[1]) {\n        return true;\n      }\n\n      return forEachCorner(extent, this.intersectsCoordinate.bind(this));\n    }\n    return false;\n  }\n\n  /**\n   * Set the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.\n   * @param {import(\"../coordinate.js\").Coordinate} center Center.\n   * @api\n   */\n  setCenter(center) {\n    const stride = this.stride;\n    const radius = this.flatCoordinates[stride] - this.flatCoordinates[0];\n    const flatCoordinates = center.slice();\n    flatCoordinates[stride] = flatCoordinates[0] + radius;\n    for (let i = 1; i < stride; ++i) {\n      flatCoordinates[stride + i] = center[i];\n    }\n    this.setFlatCoordinates(this.layout, flatCoordinates);\n    this.changed();\n  }\n\n  /**\n   * Set the center (as {@link module:ol/coordinate~Coordinate coordinate}) and the radius (as\n   * number) of the circle.\n   * @param {!import(\"../coordinate.js\").Coordinate} center Center.\n   * @param {number} radius Radius.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @api\n   */\n  setCenterAndRadius(center, radius, layout) {\n    this.setLayout(layout, center, 0);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    /** @type {Array<number>} */\n    const flatCoordinates = this.flatCoordinates;\n    let offset = deflateCoordinate(flatCoordinates, 0, center, this.stride);\n    flatCoordinates[offset++] = flatCoordinates[0] + radius;\n    for (let i = 1, ii = this.stride; i < ii; ++i) {\n      flatCoordinates[offset++] = flatCoordinates[i];\n    }\n    flatCoordinates.length = offset;\n    this.changed();\n  }\n\n  getCoordinates() {\n    return null;\n  }\n\n  setCoordinates(coordinates, layout) {}\n\n  /**\n   * Set the radius of the circle. The radius is in the units of the projection.\n   * @param {number} radius Radius.\n   * @api\n   */\n  setRadius(radius) {\n    this.flatCoordinates[this.stride] = this.flatCoordinates[0] + radius;\n    this.changed();\n  }\n\n  /**\n   * Rotate the geometry around a given coordinate. This modifies the geometry\n   * coordinates in place.\n   * @param {number} angle Rotation angle in counter-clockwise radians.\n   * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\n   * @api\n   */\n  rotate(angle, anchor) {\n    const center = this.getCenter();\n    const stride = this.getStride();\n    this.setCenter(\n      rotate(center, 0, center.length, stride, angle, anchor, center),\n    );\n    this.changed();\n  }\n}\n\n/**\n * Transform each coordinate of the circle from one coordinate reference system\n * to another. The geometry is modified in place.\n * If you do not want the geometry modified in place, first clone() it and\n * then use this function on the clone.\n *\n * Internally a circle is currently represented by two points: the center of\n * the circle `[cx, cy]`, and the point to the right of the circle\n * `[cx + r, cy]`. This `transform` function just transforms these two points.\n * So the resulting geometry is also a circle, and that circle does not\n * correspond to the shape that would be obtained by transforming every point\n * of the original circle.\n *\n * @param {import(\"../proj.js\").ProjectionLike} source The current projection.  Can be a\n *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n * @param {import(\"../proj.js\").ProjectionLike} destination The desired projection.  Can be a\n *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n * @return {Circle} This geometry.  Note that original geometry is\n *     modified in place.\n * @function\n * @api\n */\nCircle.prototype.transform;\nexport default Circle;\n"],"names":["ol_interaction_ModifyFeature","constructor","options","dragging","modifying","super","handleEvent","e","type","this","handleDownEvent","_deleteCondition","handleUpEvent","handleDragEvent","handleMoveEvent","snapDistance_","pixelTolerance","tolerance_","cursor_","cursor","sources_","sources","Array","source","push","features","filterSplit_","filter","_condition","condition","deleteCondition","_insertVertexCondition","insertVertexCondition","sketchStyle","image","radius","fill","color","stroke","width","style","overlayLayer_","useSpatialIndex","name","displayInLayerSwitcher","wrapX","setMap","map","getMap","removeLayer","setActive","active","getSource","clear","setFilter","undefined","getClosestFeature","f","c","d","i","length","getClosestFeatureToCoordinate","coordinate","ci","getGeometry","getClosestPoint","di","frameState","viewState","resolution","currentFeature","dispatchEvent","selected","deselected","coord","getNearestCoord","p","getPixelFromCoordinate","pixel","feature","pt","geom","l","p0","dm","getType","getCoordinates","dist","Number","MAX_VALUE","coords","lstring","getLineStrings","ring","lring","getLinearRings","poly","getPolygons","g","getGeometries","getArcs","s","arcs","coord1","coord2","node","index","split","splitAt","shift","concat","c0","c1","nbpt","pop","closed","start","end","typeg","console","error","evt","getActive","current","forEach","extent","getFeaturesInExtent","bind","_modifiedFeatures","a","_removePoint","originalEvent","getModifiedFeatures","removePoint","_getModification","geoms","found","setGeometries","setCoordinates","setArcCoordinates","addFeature","element","getTargetElement","previousCursor_","setCursor","getCurrentFeature","ol_interaction_DrawHole","_geometryFn","coordinates","geometry","getPolygon","intersectsCoordinate","lastOKCoord","geomFn","geometryFunction","_select","layers","layers_","indexOf","_features","featureFilter","item","getArray","on","_startDrawing","_finishDrawing","removeInteraction","addInteraction","call","b","getFeatures","removeLastPoint","_feature","_polygon","_current","forEachFeatureAtPixel","layer","_polygonIndex","layerFilter","hole","pi","newGeom","appendLinearRing","appendPolygon","setGeometry","ol_extent_intersection","ol_coordinate_dist2d","p1","p2","dx","dy","Math","sqrt","ol_coordinate_equal","ol_coordinate_offsetCoords","offset","mi","mi1","li","li1","ri","ri1","si","si1","Xi1","Yi1","path","N","max","isClosed","abs","ol_coordinate_findSegment","segment","d0","v0","d1","v1","splitX","pts","x","splice","splitY","y","polygon","ol_coordinate_sampleAt","dl","nb","round","prototype","sampleAt","line","result","lines","res","mpoly","intersection","ext","getCenter","getRadius","simplify","r","hasout","warn","ol_style_Style_defaultStyle","white","blue","defaultEditStyle","edit","fillColor","ol_interaction_Delete","delete","_getSources","getLayers","getLength","delFeatures","removeFeature","ol_control_TextButton","className","ol_interaction_DrawRegular","self","handleEvent_","squaredClickTolerance_","clickTolerance","maxCircleCoordinates_","maxCircleCoordinates","features_","source_","conditionFn_","squareFn_","squareCondition","centeredFn_","centerCondition","canRotate_","canRotate","geometryName_","geometryName","setSides","sides","defaultStyle","sketch_","reset","started_","parseInt","sides_","getSides","getGeom_","center_","coord_","dmax","circle","centerPx","center","square_","centered_","coordPx_","min","hasrotation","atan2","startAngle","getExtent","scx","scy","sc","sign","t","applyTransform","g1","g2","dim","drawSketch_","shiftKey","metaKey","ctrlKey","feature_","drawPoint_","noclear","_eventTime","Date","downPx_","start_","dt","_longTouch","setTimeout","handleMoveEvent_","lastEvent","end_","upPx_","finishDrawing","startCoordinate","square","centered","setGeometryName","PI","opt_fast","ol_interaction_UndoRedo","_layers","_undoStack","_redoStack","_undo","_redo","level","_level","view","getView","zoom","getZoom","action","_reduce","_doShift","_abort","_doClear","abort","_block","_record","_defs","define","undoFn","redoFn","undo","redo","setMaxLength","set","size","setMaxSize","get","getStack","prop","custom","removeAt","_mapListener","blockStart","blockEnd","_watchSources","_watchInteractions","_sourceListener","getVectorLayers","init","vectors","_onAddRemove","_interactionListener","getInteractions","_onInteraction","target","fn","_handleDo","oldGeom","newp","newProperties","oldp","oldProperties","unset","hasUndo","hasRedo","setattributestart","Object","assign","properties","rotatestart","translatestart","scalestart","modifystart","_modify","replace","modify","m","clone","translateend","rotateend","scaleend","modifyend","transformed","getFlatCoordinates","log","beforesplit","deletestart","aftersplit","deleteend","ol_control_Toggle","toggleFn","onToggle","handleClick","toggle","interaction_","interaction","title","autoActivate","bar","setSubBar","setDisable","disable","subbar_","removeControl","addControl","getSubBar","setTarget","classList","add","id","getButtonElement","setAttribute","getDisable","button","querySelector","disabled","key","oldValue","contains","remove","button_","setInteraction","getInteraction","ol_interaction_Split","snapDistance","tolerance","setSources","featureStyle","_sketch_","getSources","getVisible","unshift","fi","gi","link","tosplit","original","linkGeometry","DrawEventType","DRAWSTART","DRAWEND","DRAWABORT","DrawEvent","getTraceTargets","targets","appendGeometryTraceTargets","getSquaredDistance","getCoordinate","count","getCumulativeSquaredDistance","startIndex","endIndex","lowIndex","highIndex","lowWholeIndex","ceil","highWholeIndex","floor","interpolateCoordinate","sd","appendTraceTarget","ii","polys","j","jj","geometries","sharedUpdateInfo","NaN","getTraceTargetUpdate","traceState","snapTolerance","closestTargetDistance","Infinity","newTargetIndex","newEndIndex","targetIndex","minSegmentDistance","coordinateIndex","rel","getPointSegmentRelationship","squaredDistance","along","newTarget","considerBothDirections","newCoordinate","startPx","forwardDistance","reverseDistance","sharedRel","x1","y1","x2","y2","px","py","x0","y0","Draw","pointerOptions","stopDown","once","un","shouldHandle_","downTimeout_","lastDragTime_","pointerType_","freehand_","snapTolerance_","type_","mode_","getMode","stopClick_","stopClick","minPoints_","minPoints","maxPoints_","maxPoints","finishCondition_","finishCondition","geometryLayout_","geometryLayout","mode","projection","fromUserCoordinate","squaredLength","setCenterAndRadius","userProjection","getUserProjection","transform","Constructor","geometryFunction_","dragVertexDelay_","dragVertexDelay","finishCoordinate_","sketchFeature_","sketchPoint_","sketchCoords_","sketchLine_","sketchLineCoords_","overlay_","getDefaultStyleFunction","updateWhileInteracting","condition_","freehandCondition_","freehand","freehandCondition","traceCondition_","setTrace","trace","traceState_","traceSource_","traceSource","addChangeListener","ACTIVE","updateState_","getOverlay","event","CONTEXTMENU","preventDefault","move","POINTERMOVE","pass","POINTERDRAG","now","clearTimeout","addToDrawing_","POINTERDOWN","getPointerCount","handlePointerMove_","pointerType","DBLCLICK","startDrawing_","deactivateTrace_","toggleTraceState_","lowerLeft","getCoordinateFromPixel","upperRight","slice","addOrRemoveTracedCoordinates_","previouslyForward","currentlyForward","addTracedCoordinates_","removeTracedCoordinates_","fromIndex","toIndex","removeLastPoints_","appendCoordinates","updateTrace_","updatedTraceTarget","oldTarget","tracing","startingToDraw","atFinish_","abortDrawing","downPx","clickPx","modifyDrawing_","createOrUpdateSketchPoint_","at","potentiallyDone","potentiallyFinishCoordinates","sketchCoords","finishCoordinate","finishPixel","sketchPointGeom","updateSketchFeatures_","createOrUpdateCustomSketchLine_","getLinearRing","sketchLineGeom","setFlatCoordinates","getLayout","changed","getProjection","stride","last","done","n","sketchFeature","abortDrawing_","newDrawing","ending","extend","lineString","sketchFeatures","overlaySource","addFeatures","styles","createEditingStyle","Error","ol_interaction_Transform","handleDownEvent_","handleDragEvent_","handleUpEvent_","selection_","handles_","updateWhileAnimating","_filter","_handleEvent","addFn_","addCondition","setPointRadius","pointRadius","translateFeature","translate","translateBBox","stretch","scale","rotate","keepAspectRatio","modifyCenter","noFlip","selection","hitTolerance","enableRotatedTransform","keepRectangle","buffer","setDefaultStyle","select","setSelection","oldMap","isTouch","test","getViewport","setVisible","pointStroke","strokedash","lineDash","fill0","pointFill","displacement","points","setDisplacement","getAnchor","bigpt","angle","smallpt","createStyle","img","setStyle","olstyle","im","getImage","setScale","tx","getText","setOffsetX","getFeatureAtPixel_","bbox_","handle","constraint","option","some","getGeometryRotateToZero_","origGeom","viewRotation","getRotation","rotGeom","_isRectangle","extendExt","ptRadius","_pointRadius","ispt_","iscircle_","watchFeatures_","_featureListeners","isUpdating_","sel","opt_","constraint_","coordinate_","pixel_","geoms_","rotatedGeoms_","rotExtent","hasChanged_","extent_","rotatedExtent_","Cursors","rotate0","angle_","setCenter","pt0","ispt","deltaX","deltaY","delta","extentCoordinates","opt","downCoordinate","dragCoordinate","downPoint","dragPoint","displacementVector","centerPoint","pointArray","pointA","pointB","pointC","pointD","pointA1","base","_countVector","projectedVector","_projectVectorOnVector","nextIndex","coordsToChange","includes","projectedLeft","projectedRight","_movePoint","default","oldgeom","oldgeoms","displacement_vector","k","point","ol_interaction_Offset","duplicate","_style","typeGeom","hit","geomType","current_","currentStyle_","getStyle","_modifystart","seg","v2","ExtentEventType","EXTENTCHANGED","ExtentEvent","Extent","pointerHandler_","pixelTolerance_","snappedToVertex_","extentFeature_","vertexFeature_","extentOverlay_","boxStyle","getDefaultExtentStyleFunction","vertexOverlay_","pointerStyle","getDefaultPointerStyleFunction","setExtent","snapToVertex_","pixelCoordinate","getCoordinateFromPixelInternal","sortByDistance","getExtentInternal","segments","getSegments","sort","closestSegment","vertex","vertexPixel","getPixelFromCoordinateInternal","pixel1","pixel2","squaredDist1","squaredDist2","mapBrowserEvent","createOrUpdatePointerFeature_","createOrUpdateExtentFeature_","extentFeature","vertexFeature","handlingDownUpSequence","getOpposingPoint","x_","y_","getPointHandler","getEdgeHandler","toUserExtent","fixedPoint","fixedP1","fixedP2","SnapEventType","SNAP","SnapEvent","Event","getFeatureFromEvent","tempSegment","Snap","Pointer","vertex_","edge_","edge","featuresListenerKeys_","featureChangeListenerKeys_","indexedFeaturesExtents_","pendingFeatures_","rBush_","RBush","GEOMETRY_SEGMENTERS_","segmentPointGeometry_","segmentLineStringGeometry_","segmentPolygonGeometry_","segmentMultiPointGeometry_","segmentMultiLineStringGeometry_","segmentMultiPolygonGeometry_","segmentGeometryCollectionGeometry_","segmentCircleGeometry_","register","feature_uid","segmenter","insert","extents","segmentsData","load","EventType","CHANGE","handleFeatureChange_","getFeatures_","snapTo","handleFeatureAdd_","handleFeatureRemove_","uid","updateFeature_","featuresToUpdate","values","unlisten","unregister","rBush","nodesToRemove","forEachInExtent","currentMap","keys","CollectionEventType","ADD","REMOVE","VectorEventType","ADDFEATURE","REMOVEFEATURE","projectedCoordinate","box","getResolution","getInExtent","segmentsLength","closestVertex","closestFeature","minSquaredDistance","squaredPixelTolerance","getResult","squaredPixelDistance","segmentData","tempVertexCoord","circleGeometry","segmentStart","segmentEnd","toUserCoordinate","getGeometriesArray","polygons","kk","rings","tol","getFirstCoordinate","getLastCoordinate","d2","Circle","layout","flatCoordinates","applyProperties","closestPointXY","closestPoint","containsXY","getRadiusSquared_","computeExtent","intersectsExtent","circleExtent","setLayout","setRadius","anchor","getStride"],"ignoreList":[],"sourceRoot":""}
{"version":3,"file":"js/5918.1e6b1ec1.js","mappings":"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","sources":["webpack://@openeo/web-editor/./node_modules/ol/renderer/Map.js","webpack://@openeo/web-editor/./node_modules/ol/renderer/Composite.js","webpack://@openeo/web-editor/./node_modules/ol/renderer/Layer.js","webpack://@openeo/web-editor/./node_modules/ol/renderer/canvas/ImageLayer.js","webpack://@openeo/web-editor/./node_modules/ol/renderer/canvas/Layer.js","webpack://@openeo/web-editor/./node_modules/ol/renderer/canvas/TileLayer.js","webpack://@openeo/web-editor/./node_modules/ol/renderer/canvas/VectorLayer.js","webpack://@openeo/web-editor/./node_modules/ol/renderer/canvas/VectorTileLayer.js","webpack://@openeo/web-editor/./node_modules/ol/renderer/vector.js","webpack://@openeo/web-editor/./node_modules/ol/renderer/webgl/Layer.js","webpack://@openeo/web-editor/./node_modules/ol/render/webgl/constants.js","webpack://@openeo/web-editor/./node_modules/ol/render/webgl/utils.js","webpack://@openeo/web-editor/./node_modules/ol/renderer/webgl/PointsLayer.js"],"sourcesContent":["/**\n * @module ol/renderer/Map\n */\nimport Disposable from '../Disposable.js';\nimport {TRUE} from '../functions.js';\nimport {abstract} from '../util.js';\nimport {compose as composeTransform, makeInverse} from '../transform.js';\nimport {getWidth} from '../extent.js';\nimport {shared as iconImageCache} from '../style/IconImageCache.js';\nimport {inView} from '../layer/Layer.js';\nimport {wrapX} from '../coordinate.js';\n\n/**\n * @typedef HitMatch\n * @property {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @property {import(\"../layer/Layer.js\").default} layer Layer.\n * @property {import(\"../geom/SimpleGeometry.js\").default} geometry Geometry.\n * @property {number} distanceSq Squared distance.\n * @property {import(\"./vector.js\").FeatureCallback<T>} callback Callback.\n * @template T\n */\n\n/**\n * @abstract\n */\nclass MapRenderer extends Disposable {\n  /**\n   * @param {import(\"../Map.js\").default} map Map.\n   */\n  constructor(map) {\n    super();\n\n    /**\n     * @private\n     * @type {import(\"../Map.js\").default}\n     */\n    this.map_ = map;\n  }\n\n  /**\n   * @abstract\n   * @param {import(\"../render/EventType.js\").default} type Event type.\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   */\n  dispatchRenderEvent(type, frameState) {\n    abstract();\n  }\n\n  /**\n   * @param {import(\"../Map.js\").FrameState} frameState FrameState.\n   * @protected\n   */\n  calculateMatrices2D(frameState) {\n    const viewState = frameState.viewState;\n    const coordinateToPixelTransform = frameState.coordinateToPixelTransform;\n    const pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;\n\n    composeTransform(\n      coordinateToPixelTransform,\n      frameState.size[0] / 2,\n      frameState.size[1] / 2,\n      1 / viewState.resolution,\n      -1 / viewState.resolution,\n      -viewState.rotation,\n      -viewState.center[0],\n      -viewState.center[1]\n    );\n\n    makeInverse(pixelToCoordinateTransform, coordinateToPixelTransform);\n  }\n\n  /**\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../Map.js\").FrameState} frameState FrameState.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {boolean} checkWrapped Check for wrapped geometries.\n   * @param {import(\"./vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {S} thisArg Value to use as `this` when executing `callback`.\n   * @param {function(this: U, import(\"../layer/Layer.js\").default): boolean} layerFilter Layer filter\n   *     function, only layers which are visible and for which this function\n   *     returns `true` will be tested for features.  By default, all visible\n   *     layers will be tested.\n   * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.\n   * @return {T|undefined} Callback result.\n   * @template S,T,U\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    checkWrapped,\n    callback,\n    thisArg,\n    layerFilter,\n    thisArg2\n  ) {\n    let result;\n    const viewState = frameState.viewState;\n\n    /**\n     * @param {boolean} managed Managed layer.\n     * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n     * @param {import(\"../layer/Layer.js\").default} layer Layer.\n     * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n     * @return {T|undefined} Callback result.\n     */\n    function forEachFeatureAtCoordinate(managed, feature, layer, geometry) {\n      return callback.call(thisArg, feature, managed ? layer : null, geometry);\n    }\n\n    const projection = viewState.projection;\n\n    const translatedCoordinate = wrapX(coordinate.slice(), projection);\n    const offsets = [[0, 0]];\n    if (projection.canWrapX() && checkWrapped) {\n      const projectionExtent = projection.getExtent();\n      const worldWidth = getWidth(projectionExtent);\n      offsets.push([-worldWidth, 0], [worldWidth, 0]);\n    }\n\n    const layerStates = frameState.layerStatesArray;\n    const numLayers = layerStates.length;\n\n    const matches = /** @type {Array<HitMatch<T>>} */ ([]);\n    const tmpCoord = [];\n    for (let i = 0; i < offsets.length; i++) {\n      for (let j = numLayers - 1; j >= 0; --j) {\n        const layerState = layerStates[j];\n        const layer = layerState.layer;\n        if (\n          layer.hasRenderer() &&\n          inView(layerState, viewState) &&\n          layerFilter.call(thisArg2, layer)\n        ) {\n          const layerRenderer = layer.getRenderer();\n          const source = layer.getSource();\n          if (layerRenderer && source) {\n            const coordinates = source.getWrapX()\n              ? translatedCoordinate\n              : coordinate;\n            const callback = forEachFeatureAtCoordinate.bind(\n              null,\n              layerState.managed\n            );\n            tmpCoord[0] = coordinates[0] + offsets[i][0];\n            tmpCoord[1] = coordinates[1] + offsets[i][1];\n            result = layerRenderer.forEachFeatureAtCoordinate(\n              tmpCoord,\n              frameState,\n              hitTolerance,\n              callback,\n              matches\n            );\n          }\n          if (result) {\n            return result;\n          }\n        }\n      }\n    }\n    if (matches.length === 0) {\n      return undefined;\n    }\n    const order = 1 / matches.length;\n    matches.forEach((m, i) => (m.distanceSq += i * order));\n    matches.sort((a, b) => a.distanceSq - b.distanceSq);\n    matches.some((m) => {\n      return (result = m.callback(m.feature, m.layer, m.geometry));\n    });\n    return result;\n  }\n\n  /**\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../Map.js\").FrameState} frameState FrameState.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {boolean} checkWrapped Check for wrapped geometries.\n   * @param {function(this: U, import(\"../layer/Layer.js\").default): boolean} layerFilter Layer filter\n   *     function, only layers which are visible and for which this function\n   *     returns `true` will be tested for features.  By default, all visible\n   *     layers will be tested.\n   * @param {U} thisArg Value to use as `this` when executing `layerFilter`.\n   * @return {boolean} Is there a feature at the given coordinate?\n   * @template U\n   */\n  hasFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    checkWrapped,\n    layerFilter,\n    thisArg\n  ) {\n    const hasFeature = this.forEachFeatureAtCoordinate(\n      coordinate,\n      frameState,\n      hitTolerance,\n      checkWrapped,\n      TRUE,\n      this,\n      layerFilter,\n      thisArg\n    );\n\n    return hasFeature !== undefined;\n  }\n\n  /**\n   * @return {import(\"../Map.js\").default} Map.\n   */\n  getMap() {\n    return this.map_;\n  }\n\n  /**\n   * Render.\n   * @abstract\n   * @param {?import(\"../Map.js\").FrameState} frameState Frame state.\n   */\n  renderFrame(frameState) {\n    abstract();\n  }\n\n  /**\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  scheduleExpireIconCache(frameState) {\n    if (iconImageCache.canExpireCache()) {\n      frameState.postRenderFunctions.push(expireIconCache);\n    }\n  }\n}\n\n/**\n * @param {import(\"../Map.js\").default} map Map.\n * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n */\nfunction expireIconCache(map, frameState) {\n  iconImageCache.expire();\n}\n\nexport default MapRenderer;\n","/**\n * @module ol/renderer/Composite\n */\nimport MapRenderer from './Map.js';\nimport ObjectEventType from '../ObjectEventType.js';\nimport RenderEvent from '../render/Event.js';\nimport RenderEventType from '../render/EventType.js';\nimport {CLASS_UNSELECTABLE} from '../css.js';\nimport {checkedFonts} from '../render/canvas.js';\nimport {inView} from '../layer/Layer.js';\nimport {listen, unlistenByKey} from '../events.js';\nimport {replaceChildren} from '../dom.js';\n\n/**\n * @classdesc\n * Canvas map renderer.\n * @api\n */\nclass CompositeMapRenderer extends MapRenderer {\n  /**\n   * @param {import(\"../Map.js\").default} map Map.\n   */\n  constructor(map) {\n    super(map);\n\n    /**\n     * @type {import(\"../events.js\").EventsKey}\n     */\n    this.fontChangeListenerKey_ = listen(\n      checkedFonts,\n      ObjectEventType.PROPERTYCHANGE,\n      map.redrawText.bind(map)\n    );\n\n    /**\n     * @private\n     * @type {HTMLDivElement}\n     */\n    this.element_ = document.createElement('div');\n    const style = this.element_.style;\n    style.position = 'absolute';\n    style.width = '100%';\n    style.height = '100%';\n    style.zIndex = '0';\n\n    this.element_.className = CLASS_UNSELECTABLE + ' ol-layers';\n\n    const container = map.getViewport();\n    container.insertBefore(this.element_, container.firstChild || null);\n\n    /**\n     * @private\n     * @type {Array<HTMLElement>}\n     */\n    this.children_ = [];\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.renderedVisible_ = true;\n  }\n\n  /**\n   * @param {import(\"../render/EventType.js\").default} type Event type.\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   */\n  dispatchRenderEvent(type, frameState) {\n    const map = this.getMap();\n    if (map.hasListener(type)) {\n      const event = new RenderEvent(type, undefined, frameState);\n      map.dispatchEvent(event);\n    }\n  }\n\n  disposeInternal() {\n    unlistenByKey(this.fontChangeListenerKey_);\n    this.element_.parentNode.removeChild(this.element_);\n    super.disposeInternal();\n  }\n\n  /**\n   * Render.\n   * @param {?import(\"../Map.js\").FrameState} frameState Frame state.\n   */\n  renderFrame(frameState) {\n    if (!frameState) {\n      if (this.renderedVisible_) {\n        this.element_.style.display = 'none';\n        this.renderedVisible_ = false;\n      }\n      return;\n    }\n\n    this.calculateMatrices2D(frameState);\n    this.dispatchRenderEvent(RenderEventType.PRECOMPOSE, frameState);\n\n    const layerStatesArray = frameState.layerStatesArray.sort(function (a, b) {\n      return a.zIndex - b.zIndex;\n    });\n    const viewState = frameState.viewState;\n\n    this.children_.length = 0;\n    /**\n     * @type {Array<import(\"../layer/BaseVector.js\").default>}\n     */\n    const declutterLayers = [];\n    let previousElement = null;\n    for (let i = 0, ii = layerStatesArray.length; i < ii; ++i) {\n      const layerState = layerStatesArray[i];\n      frameState.layerIndex = i;\n\n      const layer = layerState.layer;\n      const sourceState = layer.getSourceState();\n      if (\n        !inView(layerState, viewState) ||\n        (sourceState != 'ready' && sourceState != 'undefined')\n      ) {\n        layer.unrender();\n        continue;\n      }\n\n      const element = layer.render(frameState, previousElement);\n      if (!element) {\n        continue;\n      }\n      if (element !== previousElement) {\n        this.children_.push(element);\n        previousElement = element;\n      }\n      if ('getDeclutter' in layer) {\n        declutterLayers.push(\n          /** @type {import(\"../layer/BaseVector.js\").default} */ (layer)\n        );\n      }\n    }\n    for (let i = declutterLayers.length - 1; i >= 0; --i) {\n      declutterLayers[i].renderDeclutter(frameState);\n    }\n\n    replaceChildren(this.element_, this.children_);\n\n    this.dispatchRenderEvent(RenderEventType.POSTCOMPOSE, frameState);\n\n    if (!this.renderedVisible_) {\n      this.element_.style.display = '';\n      this.renderedVisible_ = true;\n    }\n\n    this.scheduleExpireIconCache(frameState);\n  }\n}\n\nexport default CompositeMapRenderer;\n","/**\n * @module ol/renderer/Layer\n */\nimport EventType from '../events/EventType.js';\nimport ImageState from '../ImageState.js';\nimport Observable from '../Observable.js';\nimport {abstract} from '../util.js';\n\n/**\n * @template {import(\"../layer/Layer.js\").default} LayerType\n */\nclass LayerRenderer extends Observable {\n  /**\n   * @param {LayerType} layer Layer.\n   */\n  constructor(layer) {\n    super();\n\n    /**\n     * The renderer is initialized and ready to render.\n     * @type {boolean}\n     */\n    this.ready = true;\n\n    /** @private */\n    this.boundHandleImageChange_ = this.handleImageChange_.bind(this);\n\n    /**\n     * @protected\n     * @type {LayerType}\n     */\n    this.layer_ = layer;\n\n    /**\n     * @type {import(\"../render/canvas/ExecutorGroup\").default}\n     */\n    this.declutterExecutorGroup = null;\n  }\n\n  /**\n   * Asynchronous layer level hit detection.\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../Feature\").FeatureLike>>} Promise that resolves with\n   * an array of features.\n   */\n  getFeatures(pixel) {\n    return abstract();\n  }\n\n  /**\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\n   */\n  getData(pixel) {\n    return null;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @abstract\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    return abstract();\n  }\n\n  /**\n   * Render the layer.\n   * @abstract\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState, target) {\n    return abstract();\n  }\n\n  /**\n   * @param {Object<number, Object<string, import(\"../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n   * @param {number} zoom Zoom level.\n   * @param {import(\"../Tile.js\").default} tile Tile.\n   * @return {boolean|void} If `false`, the tile will not be considered loaded.\n   */\n  loadedTileCallback(tiles, zoom, tile) {\n    if (!tiles[zoom]) {\n      tiles[zoom] = {};\n    }\n    tiles[zoom][tile.tileCoord.toString()] = tile;\n    return undefined;\n  }\n\n  /**\n   * Create a function that adds loaded tiles to the tile lookup.\n   * @param {import(\"../source/Tile.js\").default} source Tile source.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection of the tiles.\n   * @param {Object<number, Object<string, import(\"../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n   * @return {function(number, import(\"../TileRange.js\").default):boolean} A function that can be\n   *     called with a zoom level and a tile range to add loaded tiles to the lookup.\n   * @protected\n   */\n  createLoadedTileFinder(source, projection, tiles) {\n    return (\n      /**\n       * @param {number} zoom Zoom level.\n       * @param {import(\"../TileRange.js\").default} tileRange Tile range.\n       * @return {boolean} The tile range is fully loaded.\n       */\n      (zoom, tileRange) => {\n        const callback = this.loadedTileCallback.bind(this, tiles, zoom);\n        return source.forEachLoadedTile(projection, zoom, tileRange, callback);\n      }\n    );\n  }\n  /**\n   * @abstract\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"./vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"./Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches\n  ) {\n    return undefined;\n  }\n\n  /**\n   * @return {LayerType} Layer.\n   */\n  getLayer() {\n    return this.layer_;\n  }\n\n  /**\n   * Perform action necessary to get the layer rendered after new fonts have loaded\n   * @abstract\n   */\n  handleFontsChanged() {}\n\n  /**\n   * Handle changes in image state.\n   * @param {import(\"../events/Event.js\").default} event Image change event.\n   * @private\n   */\n  handleImageChange_(event) {\n    const image = /** @type {import(\"../Image.js\").default} */ (event.target);\n    if (image.getState() === ImageState.LOADED) {\n      this.renderIfReadyAndVisible();\n    }\n  }\n\n  /**\n   * Load the image if not already loaded, and register the image change\n   * listener if needed.\n   * @param {import(\"../ImageBase.js\").default} image Image.\n   * @return {boolean} `true` if the image is already loaded, `false` otherwise.\n   * @protected\n   */\n  loadImage(image) {\n    let imageState = image.getState();\n    if (imageState != ImageState.LOADED && imageState != ImageState.ERROR) {\n      image.addEventListener(EventType.CHANGE, this.boundHandleImageChange_);\n    }\n    if (imageState == ImageState.IDLE) {\n      image.load();\n      imageState = image.getState();\n    }\n    return imageState == ImageState.LOADED;\n  }\n\n  /**\n   * @protected\n   */\n  renderIfReadyAndVisible() {\n    const layer = this.getLayer();\n    if (layer && layer.getVisible() && layer.getSourceState() === 'ready') {\n      layer.changed();\n    }\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    delete this.layer_;\n    super.disposeInternal();\n  }\n}\n\nexport default LayerRenderer;\n","/**\n * @module ol/renderer/canvas/ImageLayer\n */\nimport CanvasLayerRenderer from './Layer.js';\nimport ImageState from '../../ImageState.js';\nimport ViewHint from '../../ViewHint.js';\nimport {\n  apply as applyTransform,\n  compose as composeTransform,\n  makeInverse,\n  toString as toTransformString,\n} from '../../transform.js';\nimport {\n  containsCoordinate,\n  containsExtent,\n  getHeight,\n  getIntersection,\n  getWidth,\n  intersects as intersectsExtent,\n  isEmpty,\n} from '../../extent.js';\nimport {fromUserExtent} from '../../proj.js';\n\n/**\n * @classdesc\n * Canvas renderer for image layers.\n * @api\n */\nclass CanvasImageLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {import(\"../../layer/Image.js\").default} imageLayer Image layer.\n   */\n  constructor(imageLayer) {\n    super(imageLayer);\n\n    /**\n     * @protected\n     * @type {?import(\"../../ImageBase.js\").default}\n     */\n    this.image_ = null;\n  }\n\n  /**\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   */\n  getImage() {\n    return !this.image_ ? null : this.image_.getImage();\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const viewResolution = viewState.resolution;\n\n    const imageSource = this.getLayer().getSource();\n\n    const hints = frameState.viewHints;\n\n    let renderedExtent = frameState.extent;\n    if (layerState.extent !== undefined) {\n      renderedExtent = getIntersection(\n        renderedExtent,\n        fromUserExtent(layerState.extent, viewState.projection)\n      );\n    }\n\n    if (\n      !hints[ViewHint.ANIMATING] &&\n      !hints[ViewHint.INTERACTING] &&\n      !isEmpty(renderedExtent)\n    ) {\n      if (imageSource) {\n        const projection = viewState.projection;\n        const image = imageSource.getImage(\n          renderedExtent,\n          viewResolution,\n          pixelRatio,\n          projection\n        );\n        if (image) {\n          if (this.loadImage(image)) {\n            this.image_ = image;\n          } else if (image.getState() === ImageState.EMPTY) {\n            this.image_ = null;\n          }\n        }\n      } else {\n        this.image_ = null;\n      }\n    }\n\n    return !!this.image_;\n  }\n\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray} Data at the pixel location.\n   */\n  getData(pixel) {\n    const frameState = this.frameState;\n    if (!frameState) {\n      return null;\n    }\n\n    const layer = this.getLayer();\n    const coordinate = applyTransform(\n      frameState.pixelToCoordinateTransform,\n      pixel.slice()\n    );\n\n    const layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (!containsCoordinate(layerExtent, coordinate)) {\n        return null;\n      }\n    }\n\n    const imageExtent = this.image_.getExtent();\n    const img = this.image_.getImage();\n\n    const imageMapWidth = getWidth(imageExtent);\n    const col = Math.floor(\n      img.width * ((coordinate[0] - imageExtent[0]) / imageMapWidth)\n    );\n    if (col < 0 || col >= img.width) {\n      return null;\n    }\n\n    const imageMapHeight = getHeight(imageExtent);\n    const row = Math.floor(\n      img.height * ((imageExtent[3] - coordinate[1]) / imageMapHeight)\n    );\n    if (row < 0 || row >= img.height) {\n      return null;\n    }\n\n    return this.getImageData(img, col, row);\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState, target) {\n    const image = this.image_;\n    const imageExtent = image.getExtent();\n    const imageResolution = image.getResolution();\n    const imagePixelRatio = image.getPixelRatio();\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const viewCenter = viewState.center;\n    const viewResolution = viewState.resolution;\n    const scale =\n      (pixelRatio * imageResolution) / (viewResolution * imagePixelRatio);\n\n    const extent = frameState.extent;\n    const resolution = viewState.resolution;\n    const rotation = viewState.rotation;\n    // desired dimensions of the canvas in pixels\n    const width = Math.round((getWidth(extent) / resolution) * pixelRatio);\n    const height = Math.round((getHeight(extent) / resolution) * pixelRatio);\n\n    // set forward and inverse pixel transforms\n    composeTransform(\n      this.pixelTransform,\n      frameState.size[0] / 2,\n      frameState.size[1] / 2,\n      1 / pixelRatio,\n      1 / pixelRatio,\n      rotation,\n      -width / 2,\n      -height / 2\n    );\n    makeInverse(this.inversePixelTransform, this.pixelTransform);\n\n    const canvasTransform = toTransformString(this.pixelTransform);\n\n    this.useContainer(target, canvasTransform, this.getBackground(frameState));\n\n    const context = this.context;\n    const canvas = context.canvas;\n\n    if (canvas.width != width || canvas.height != height) {\n      canvas.width = width;\n      canvas.height = height;\n    } else if (!this.containerReused) {\n      context.clearRect(0, 0, width, height);\n    }\n\n    // clipped rendering if layer extent is set\n    let clipped = false;\n    let render = true;\n    if (layerState.extent) {\n      const layerExtent = fromUserExtent(\n        layerState.extent,\n        viewState.projection\n      );\n      render = intersectsExtent(layerExtent, frameState.extent);\n      clipped = render && !containsExtent(layerExtent, frameState.extent);\n      if (clipped) {\n        this.clipUnrotated(context, frameState, layerExtent);\n      }\n    }\n\n    const img = image.getImage();\n\n    const transform = composeTransform(\n      this.tempTransform,\n      width / 2,\n      height / 2,\n      scale,\n      scale,\n      0,\n      (imagePixelRatio * (imageExtent[0] - viewCenter[0])) / imageResolution,\n      (imagePixelRatio * (viewCenter[1] - imageExtent[3])) / imageResolution\n    );\n\n    this.renderedResolution = (imageResolution * pixelRatio) / imagePixelRatio;\n\n    const dw = img.width * transform[0];\n    const dh = img.height * transform[3];\n\n    if (!this.getLayer().getSource().getInterpolate()) {\n      context.imageSmoothingEnabled = false;\n    }\n\n    this.preRender(context, frameState);\n    if (render && dw >= 0.5 && dh >= 0.5) {\n      const dx = transform[4];\n      const dy = transform[5];\n      const opacity = layerState.opacity;\n      let previousAlpha;\n      if (opacity !== 1) {\n        previousAlpha = context.globalAlpha;\n        context.globalAlpha = opacity;\n      }\n      context.drawImage(img, 0, 0, +img.width, +img.height, dx, dy, dw, dh);\n      if (opacity !== 1) {\n        context.globalAlpha = previousAlpha;\n      }\n    }\n    this.postRender(context, frameState);\n\n    if (clipped) {\n      context.restore();\n    }\n    context.imageSmoothingEnabled = true;\n\n    if (canvasTransform !== canvas.style.transform) {\n      canvas.style.transform = canvasTransform;\n    }\n\n    return this.container;\n  }\n}\n\nexport default CanvasImageLayerRenderer;\n","/**\n * @module ol/renderer/canvas/Layer\n */\nimport LayerRenderer from '../Layer.js';\nimport RenderEvent from '../../render/Event.js';\nimport RenderEventType from '../../render/EventType.js';\nimport {\n  apply as applyTransform,\n  compose as composeTransform,\n  create as createTransform,\n} from '../../transform.js';\nimport {asArray} from '../../color.js';\nimport {createCanvasContext2D} from '../../dom.js';\nimport {equals} from '../../array.js';\nimport {\n  getBottomLeft,\n  getBottomRight,\n  getTopLeft,\n  getTopRight,\n} from '../../extent.js';\n\n/**\n * @type {Array<HTMLCanvasElement>}\n */\nexport const canvasPool = [];\n\n/**\n * @type {CanvasRenderingContext2D}\n */\nlet pixelContext = null;\n\nfunction createPixelContext() {\n  pixelContext = createCanvasContext2D(1, 1, undefined, {\n    willReadFrequently: true,\n  });\n}\n\n/**\n * @abstract\n * @template {import(\"../../layer/Layer.js\").default} LayerType\n * @extends {LayerRenderer<LayerType>}\n */\nclass CanvasLayerRenderer extends LayerRenderer {\n  /**\n   * @param {LayerType} layer Layer.\n   */\n  constructor(layer) {\n    super(layer);\n\n    /**\n     * @protected\n     * @type {HTMLElement}\n     */\n    this.container = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedResolution;\n\n    /**\n     * A temporary transform.  The values in this transform should only be used in a\n     * function that sets the values.\n     * @protected\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.tempTransform = createTransform();\n\n    /**\n     * The transform for rendered pixels to viewport CSS pixels.  This transform must\n     * be set when rendering a frame and may be used by other functions after rendering.\n     * @protected\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.pixelTransform = createTransform();\n\n    /**\n     * The transform for viewport CSS pixels to rendered pixels.  This transform must\n     * be set when rendering a frame and may be used by other functions after rendering.\n     * @protected\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.inversePixelTransform = createTransform();\n\n    /**\n     * @type {CanvasRenderingContext2D}\n     */\n    this.context = null;\n\n    /**\n     * @type {boolean}\n     */\n    this.containerReused = false;\n\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n    this.pixelContext_ = null;\n\n    /**\n     * @protected\n     * @type {import(\"../../Map.js\").FrameState|null}\n     */\n    this.frameState = null;\n  }\n\n  /**\n   * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.\n   * @param {number} col The column index.\n   * @param {number} row The row index.\n   * @return {Uint8ClampedArray|null} The image data.\n   */\n  getImageData(image, col, row) {\n    if (!pixelContext) {\n      createPixelContext();\n    }\n    pixelContext.clearRect(0, 0, 1, 1);\n\n    let data;\n    try {\n      pixelContext.drawImage(image, col, row, 1, 1, 0, 0, 1, 1);\n      data = pixelContext.getImageData(0, 0, 1, 1).data;\n    } catch (err) {\n      pixelContext = null;\n      return null;\n    }\n    return data;\n  }\n\n  /**\n   * @param {import('../../Map.js').FrameState} frameState Frame state.\n   * @return {string} Background color.\n   */\n  getBackground(frameState) {\n    const layer = this.getLayer();\n    let background = layer.getBackground();\n    if (typeof background === 'function') {\n      background = background(frameState.viewState.resolution);\n    }\n    return background || undefined;\n  }\n\n  /**\n   * Get a rendering container from an existing target, if compatible.\n   * @param {HTMLElement} target Potential render target.\n   * @param {string} transform CSS Transform.\n   * @param {string} [backgroundColor] Background color.\n   */\n  useContainer(target, transform, backgroundColor) {\n    const layerClassName = this.getLayer().getClassName();\n    let container, context;\n    if (\n      target &&\n      target.className === layerClassName &&\n      (!backgroundColor ||\n        (target &&\n          target.style.backgroundColor &&\n          equals(\n            asArray(target.style.backgroundColor),\n            asArray(backgroundColor)\n          )))\n    ) {\n      const canvas = target.firstElementChild;\n      if (canvas instanceof HTMLCanvasElement) {\n        context = canvas.getContext('2d');\n      }\n    }\n    if (context && context.canvas.style.transform === transform) {\n      // Container of the previous layer renderer can be used.\n      this.container = target;\n      this.context = context;\n      this.containerReused = true;\n    } else if (this.containerReused) {\n      // Previously reused container cannot be used any more.\n      this.container = null;\n      this.context = null;\n      this.containerReused = false;\n    }\n    if (!this.container) {\n      container = document.createElement('div');\n      container.className = layerClassName;\n      let style = container.style;\n      style.position = 'absolute';\n      style.width = '100%';\n      style.height = '100%';\n      context = createCanvasContext2D();\n      const canvas = context.canvas;\n      container.appendChild(canvas);\n      style = canvas.style;\n      style.position = 'absolute';\n      style.left = '0';\n      style.transformOrigin = 'top left';\n      this.container = container;\n      this.context = context;\n    }\n    if (\n      !this.containerReused &&\n      backgroundColor &&\n      !this.container.style.backgroundColor\n    ) {\n      this.container.style.backgroundColor = backgroundColor;\n    }\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../extent.js\").Extent} extent Clip extent.\n   * @protected\n   */\n  clipUnrotated(context, frameState, extent) {\n    const topLeft = getTopLeft(extent);\n    const topRight = getTopRight(extent);\n    const bottomRight = getBottomRight(extent);\n    const bottomLeft = getBottomLeft(extent);\n\n    applyTransform(frameState.coordinateToPixelTransform, topLeft);\n    applyTransform(frameState.coordinateToPixelTransform, topRight);\n    applyTransform(frameState.coordinateToPixelTransform, bottomRight);\n    applyTransform(frameState.coordinateToPixelTransform, bottomLeft);\n\n    const inverted = this.inversePixelTransform;\n    applyTransform(inverted, topLeft);\n    applyTransform(inverted, topRight);\n    applyTransform(inverted, bottomRight);\n    applyTransform(inverted, bottomLeft);\n\n    context.save();\n    context.beginPath();\n    context.moveTo(Math.round(topLeft[0]), Math.round(topLeft[1]));\n    context.lineTo(Math.round(topRight[0]), Math.round(topRight[1]));\n    context.lineTo(Math.round(bottomRight[0]), Math.round(bottomRight[1]));\n    context.lineTo(Math.round(bottomLeft[0]), Math.round(bottomLeft[1]));\n    context.clip();\n  }\n\n  /**\n   * @param {import(\"../../render/EventType.js\").default} type Event type.\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @private\n   */\n  dispatchRenderEvent_(type, context, frameState) {\n    const layer = this.getLayer();\n    if (layer.hasListener(type)) {\n      const event = new RenderEvent(\n        type,\n        this.inversePixelTransform,\n        frameState,\n        context\n      );\n      layer.dispatchEvent(event);\n    }\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  preRender(context, frameState) {\n    this.frameState = frameState;\n    this.dispatchRenderEvent_(RenderEventType.PRERENDER, context, frameState);\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  postRender(context, frameState) {\n    this.dispatchRenderEvent_(RenderEventType.POSTRENDER, context, frameState);\n  }\n\n  /**\n   * Creates a transform for rendering to an element that will be rotated after rendering.\n   * @param {import(\"../../coordinate.js\").Coordinate} center Center.\n   * @param {number} resolution Resolution.\n   * @param {number} rotation Rotation.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {number} width Width of the rendered element (in pixels).\n   * @param {number} height Height of the rendered element (in pixels).\n   * @param {number} offsetX Offset on the x-axis in view coordinates.\n   * @protected\n   * @return {!import(\"../../transform.js\").Transform} Transform.\n   */\n  getRenderTransform(\n    center,\n    resolution,\n    rotation,\n    pixelRatio,\n    width,\n    height,\n    offsetX\n  ) {\n    const dx1 = width / 2;\n    const dy1 = height / 2;\n    const sx = pixelRatio / resolution;\n    const sy = -sx;\n    const dx2 = -center[0] + offsetX;\n    const dy2 = -center[1];\n    return composeTransform(\n      this.tempTransform,\n      dx1,\n      dy1,\n      sx,\n      sy,\n      -rotation,\n      dx2,\n      dy2\n    );\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    delete this.frameState;\n    super.disposeInternal();\n  }\n}\n\nexport default CanvasLayerRenderer;\n","/**\n * @module ol/renderer/canvas/TileLayer\n */\nimport CanvasLayerRenderer from './Layer.js';\nimport ImageTile from '../../ImageTile.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport {\n  apply as applyTransform,\n  compose as composeTransform,\n  makeInverse,\n  toString as toTransformString,\n} from '../../transform.js';\nimport {ascending} from '../../array.js';\nimport {\n  containsCoordinate,\n  createEmpty,\n  equals,\n  getHeight,\n  getIntersection,\n  getRotatedViewport,\n  getTopLeft,\n  getWidth,\n  intersects,\n} from '../../extent.js';\nimport {fromUserExtent} from '../../proj.js';\nimport {getUid} from '../../util.js';\nimport {toSize} from '../../size.js';\n\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n * @template {import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default} [LayerType=import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default]\n * @extends {CanvasLayerRenderer<LayerType>}\n */\nclass CanvasTileLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   */\n  constructor(tileLayer) {\n    super(tileLayer);\n\n    /**\n     * Rendered extent has changed since the previous `renderFrame()` call\n     * @type {boolean}\n     */\n    this.extentChanged = true;\n\n    /**\n     * @private\n     * @type {?import(\"../../extent.js\").Extent}\n     */\n    this.renderedExtent_ = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedPixelRatio;\n\n    /**\n     * @protected\n     * @type {import(\"../../proj/Projection.js\").default}\n     */\n    this.renderedProjection = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedRevision;\n\n    /**\n     * @protected\n     * @type {!Array<import(\"../../Tile.js\").default>}\n     */\n    this.renderedTiles = [];\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.newTiles_ = false;\n\n    /**\n     * @protected\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.tmpExtent = createEmpty();\n\n    /**\n     * @private\n     * @type {import(\"../../TileRange.js\").default}\n     */\n    this.tmpTileRange_ = new TileRange(0, 0, 0, 0);\n  }\n\n  /**\n   * @protected\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {boolean} Tile is drawable.\n   */\n  isDrawableTile(tile) {\n    const tileLayer = this.getLayer();\n    const tileState = tile.getState();\n    const useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();\n    return (\n      tileState == TileState.LOADED ||\n      tileState == TileState.EMPTY ||\n      (tileState == TileState.ERROR && !useInterimTilesOnError)\n    );\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {!import(\"../../Tile.js\").default} Tile.\n   */\n  getTile(z, x, y, frameState) {\n    const pixelRatio = frameState.pixelRatio;\n    const projection = frameState.viewState.projection;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    let tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n    if (tile.getState() == TileState.ERROR) {\n      if (tileLayer.getUseInterimTilesOnError() && tileLayer.getPreload() > 0) {\n        // Preloaded tiles for lower resolutions might have finished loading.\n        this.newTiles_ = true;\n      }\n    }\n    if (!this.isDrawableTile(tile)) {\n      tile = tile.getInterimTile();\n    }\n    return tile;\n  }\n\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray} Data at the pixel location.\n   */\n  getData(pixel) {\n    const frameState = this.frameState;\n    if (!frameState) {\n      return null;\n    }\n\n    const layer = this.getLayer();\n    const coordinate = applyTransform(\n      frameState.pixelToCoordinateTransform,\n      pixel.slice()\n    );\n\n    const layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (!containsCoordinate(layerExtent, coordinate)) {\n        return null;\n      }\n    }\n\n    const pixelRatio = frameState.pixelRatio;\n    const projection = frameState.viewState.projection;\n    const viewState = frameState.viewState;\n    const source = layer.getRenderSource();\n    const tileGrid = source.getTileGridForProjection(viewState.projection);\n    const tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);\n\n    for (\n      let z = tileGrid.getZForResolution(viewState.resolution);\n      z >= tileGrid.getMinZoom();\n      --z\n    ) {\n      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n      const tile = source.getTile(\n        z,\n        tileCoord[1],\n        tileCoord[2],\n        pixelRatio,\n        projection\n      );\n      if (\n        !(tile instanceof ImageTile || tile instanceof ReprojTile) ||\n        (tile instanceof ReprojTile && tile.getState() === TileState.EMPTY)\n      ) {\n        return null;\n      }\n\n      if (tile.getState() !== TileState.LOADED) {\n        continue;\n      }\n\n      const tileOrigin = tileGrid.getOrigin(z);\n      const tileSize = toSize(tileGrid.getTileSize(z));\n      const tileResolution = tileGrid.getResolution(z);\n\n      const col = Math.floor(\n        tilePixelRatio *\n          ((coordinate[0] - tileOrigin[0]) / tileResolution -\n            tileCoord[1] * tileSize[0])\n      );\n\n      const row = Math.floor(\n        tilePixelRatio *\n          ((tileOrigin[1] - coordinate[1]) / tileResolution -\n            tileCoord[2] * tileSize[1])\n      );\n\n      const gutter = Math.round(\n        tilePixelRatio * source.getGutterForProjection(viewState.projection)\n      );\n\n      return this.getImageData(tile.getImage(), col + gutter, row + gutter);\n    }\n\n    return null;\n  }\n\n  /**\n   * @param {Object<number, Object<string, import(\"../../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n   * @param {number} zoom Zoom level.\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {boolean|void} If `false`, the tile will not be considered loaded.\n   */\n  loadedTileCallback(tiles, zoom, tile) {\n    if (this.isDrawableTile(tile)) {\n      return super.loadedTileCallback(tiles, zoom, tile);\n    }\n    return false;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    return !!this.getLayer().getSource();\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState, target) {\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const viewResolution = viewState.resolution;\n    const viewCenter = viewState.center;\n    const rotation = viewState.rotation;\n    const pixelRatio = frameState.pixelRatio;\n\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const sourceRevision = tileSource.getRevision();\n    const tileGrid = tileSource.getTileGridForProjection(projection);\n    const z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);\n    const tileResolution = tileGrid.getResolution(z);\n\n    let extent = frameState.extent;\n    const resolution = frameState.viewState.resolution;\n    const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n    // desired dimensions of the canvas in pixels\n    const width = Math.round((getWidth(extent) / resolution) * pixelRatio);\n    const height = Math.round((getHeight(extent) / resolution) * pixelRatio);\n\n    const layerExtent =\n      layerState.extent && fromUserExtent(layerState.extent, projection);\n    if (layerExtent) {\n      extent = getIntersection(\n        extent,\n        fromUserExtent(layerState.extent, projection)\n      );\n    }\n\n    const dx = (tileResolution * width) / 2 / tilePixelRatio;\n    const dy = (tileResolution * height) / 2 / tilePixelRatio;\n    const canvasExtent = [\n      viewCenter[0] - dx,\n      viewCenter[1] - dy,\n      viewCenter[0] + dx,\n      viewCenter[1] + dy,\n    ];\n\n    const tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\n\n    /**\n     * @type {Object<number, Object<string, import(\"../../Tile.js\").default>>}\n     */\n    const tilesToDrawByZ = {};\n    tilesToDrawByZ[z] = {};\n\n    const findLoadedTiles = this.createLoadedTileFinder(\n      tileSource,\n      projection,\n      tilesToDrawByZ\n    );\n\n    const tmpExtent = this.tmpExtent;\n    const tmpTileRange = this.tmpTileRange_;\n    this.newTiles_ = false;\n    const viewport = rotation\n      ? getRotatedViewport(\n          viewState.center,\n          resolution,\n          rotation,\n          frameState.size\n        )\n      : undefined;\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        if (\n          rotation &&\n          !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)\n        ) {\n          continue;\n        }\n        const tile = this.getTile(z, x, y, frameState);\n        if (this.isDrawableTile(tile)) {\n          const uid = getUid(this);\n          if (tile.getState() == TileState.LOADED) {\n            tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;\n            let inTransition = tile.inTransition(uid);\n            if (inTransition && layerState.opacity !== 1) {\n              // Skipping transition when layer is not fully opaque avoids visual artifacts.\n              tile.endTransition(uid);\n              inTransition = false;\n            }\n            if (\n              !this.newTiles_ &&\n              (inTransition || !this.renderedTiles.includes(tile))\n            ) {\n              this.newTiles_ = true;\n            }\n          }\n          if (tile.getAlpha(uid, frameState.time) === 1) {\n            // don't look for alt tiles if alpha is 1\n            continue;\n          }\n        }\n\n        const childTileRange = tileGrid.getTileCoordChildTileRange(\n          tile.tileCoord,\n          tmpTileRange,\n          tmpExtent\n        );\n\n        let covered = false;\n        if (childTileRange) {\n          covered = findLoadedTiles(z + 1, childTileRange);\n        }\n        if (!covered) {\n          tileGrid.forEachTileCoordParentTileRange(\n            tile.tileCoord,\n            findLoadedTiles,\n            tmpTileRange,\n            tmpExtent\n          );\n        }\n      }\n    }\n\n    const canvasScale =\n      ((tileResolution / viewResolution) * pixelRatio) / tilePixelRatio;\n\n    // set forward and inverse pixel transforms\n    composeTransform(\n      this.pixelTransform,\n      frameState.size[0] / 2,\n      frameState.size[1] / 2,\n      1 / pixelRatio,\n      1 / pixelRatio,\n      rotation,\n      -width / 2,\n      -height / 2\n    );\n\n    const canvasTransform = toTransformString(this.pixelTransform);\n\n    this.useContainer(target, canvasTransform, this.getBackground(frameState));\n    const context = this.context;\n    const canvas = context.canvas;\n\n    makeInverse(this.inversePixelTransform, this.pixelTransform);\n\n    // set scale transform for calculating tile positions on the canvas\n    composeTransform(\n      this.tempTransform,\n      width / 2,\n      height / 2,\n      canvasScale,\n      canvasScale,\n      0,\n      -width / 2,\n      -height / 2\n    );\n\n    if (canvas.width != width || canvas.height != height) {\n      canvas.width = width;\n      canvas.height = height;\n    } else if (!this.containerReused) {\n      context.clearRect(0, 0, width, height);\n    }\n\n    if (layerExtent) {\n      this.clipUnrotated(context, frameState, layerExtent);\n    }\n\n    if (!tileSource.getInterpolate()) {\n      context.imageSmoothingEnabled = false;\n    }\n\n    this.preRender(context, frameState);\n\n    this.renderedTiles.length = 0;\n    /** @type {Array<number>} */\n    let zs = Object.keys(tilesToDrawByZ).map(Number);\n    zs.sort(ascending);\n\n    let clips, clipZs, currentClip;\n    if (\n      layerState.opacity === 1 &&\n      (!this.containerReused ||\n        tileSource.getOpaque(frameState.viewState.projection))\n    ) {\n      zs = zs.reverse();\n    } else {\n      clips = [];\n      clipZs = [];\n    }\n    for (let i = zs.length - 1; i >= 0; --i) {\n      const currentZ = zs[i];\n      const currentTilePixelSize = tileSource.getTilePixelSize(\n        currentZ,\n        pixelRatio,\n        projection\n      );\n      const currentResolution = tileGrid.getResolution(currentZ);\n      const currentScale = currentResolution / tileResolution;\n      const dx = currentTilePixelSize[0] * currentScale * canvasScale;\n      const dy = currentTilePixelSize[1] * currentScale * canvasScale;\n      const originTileCoord = tileGrid.getTileCoordForCoordAndZ(\n        getTopLeft(canvasExtent),\n        currentZ\n      );\n      const originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);\n      const origin = applyTransform(this.tempTransform, [\n        (tilePixelRatio * (originTileExtent[0] - canvasExtent[0])) /\n          tileResolution,\n        (tilePixelRatio * (canvasExtent[3] - originTileExtent[3])) /\n          tileResolution,\n      ]);\n      const tileGutter =\n        tilePixelRatio * tileSource.getGutterForProjection(projection);\n      const tilesToDraw = tilesToDrawByZ[currentZ];\n      for (const tileCoordKey in tilesToDraw) {\n        const tile = /** @type {import(\"../../ImageTile.js\").default} */ (\n          tilesToDraw[tileCoordKey]\n        );\n        const tileCoord = tile.tileCoord;\n\n        // Calculate integer positions and sizes so that tiles align\n        const xIndex = originTileCoord[1] - tileCoord[1];\n        const nextX = Math.round(origin[0] - (xIndex - 1) * dx);\n        const yIndex = originTileCoord[2] - tileCoord[2];\n        const nextY = Math.round(origin[1] - (yIndex - 1) * dy);\n        const x = Math.round(origin[0] - xIndex * dx);\n        const y = Math.round(origin[1] - yIndex * dy);\n        const w = nextX - x;\n        const h = nextY - y;\n        const transition = z === currentZ;\n\n        const inTransition =\n          transition && tile.getAlpha(getUid(this), frameState.time) !== 1;\n        let contextSaved = false;\n        if (!inTransition) {\n          if (clips) {\n            // Clip mask for regions in this tile that already filled by a higher z tile\n            currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];\n            for (let i = 0, ii = clips.length; i < ii; ++i) {\n              if (z !== currentZ && currentZ < clipZs[i]) {\n                const clip = clips[i];\n                if (\n                  intersects(\n                    [x, y, x + w, y + h],\n                    [clip[0], clip[3], clip[4], clip[7]]\n                  )\n                ) {\n                  if (!contextSaved) {\n                    context.save();\n                    contextSaved = true;\n                  }\n                  context.beginPath();\n                  // counter-clockwise (outer ring) for current tile\n                  context.moveTo(currentClip[0], currentClip[1]);\n                  context.lineTo(currentClip[2], currentClip[3]);\n                  context.lineTo(currentClip[4], currentClip[5]);\n                  context.lineTo(currentClip[6], currentClip[7]);\n                  // clockwise (inner ring) for higher z tile\n                  context.moveTo(clip[6], clip[7]);\n                  context.lineTo(clip[4], clip[5]);\n                  context.lineTo(clip[2], clip[3]);\n                  context.lineTo(clip[0], clip[1]);\n                  context.clip();\n                }\n              }\n            }\n            clips.push(currentClip);\n            clipZs.push(currentZ);\n          } else {\n            context.clearRect(x, y, w, h);\n          }\n        }\n        this.drawTileImage(\n          tile,\n          frameState,\n          x,\n          y,\n          w,\n          h,\n          tileGutter,\n          transition\n        );\n        if (clips && !inTransition) {\n          if (contextSaved) {\n            context.restore();\n          }\n          this.renderedTiles.unshift(tile);\n        } else {\n          this.renderedTiles.push(tile);\n        }\n        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);\n      }\n    }\n\n    this.renderedRevision = sourceRevision;\n    this.renderedResolution = tileResolution;\n    this.extentChanged =\n      !this.renderedExtent_ || !equals(this.renderedExtent_, canvasExtent);\n    this.renderedExtent_ = canvasExtent;\n    this.renderedPixelRatio = pixelRatio;\n    this.renderedProjection = projection;\n\n    this.manageTilePyramid(\n      frameState,\n      tileSource,\n      tileGrid,\n      pixelRatio,\n      projection,\n      extent,\n      z,\n      tileLayer.getPreload()\n    );\n    this.scheduleExpireCache(frameState, tileSource);\n\n    this.postRender(context, frameState);\n\n    if (layerState.extent) {\n      context.restore();\n    }\n    context.imageSmoothingEnabled = true;\n\n    if (canvasTransform !== canvas.style.transform) {\n      canvas.style.transform = canvasTransform;\n    }\n\n    return this.container;\n  }\n\n  /**\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   */\n  drawTileImage(tile, frameState, x, y, w, h, gutter, transition) {\n    const image = this.getTileImage(tile);\n    if (!image) {\n      return;\n    }\n    const uid = getUid(this);\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const alpha =\n      layerState.opacity *\n      (transition ? tile.getAlpha(uid, frameState.time) : 1);\n    const alphaChanged = alpha !== this.context.globalAlpha;\n    if (alphaChanged) {\n      this.context.save();\n      this.context.globalAlpha = alpha;\n    }\n    this.context.drawImage(\n      image,\n      gutter,\n      gutter,\n      image.width - 2 * gutter,\n      image.height - 2 * gutter,\n      x,\n      y,\n      w,\n      h\n    );\n\n    if (alphaChanged) {\n      this.context.restore();\n    }\n    if (alpha !== layerState.opacity) {\n      frameState.animate = true;\n    } else if (transition) {\n      tile.endTransition(uid);\n    }\n  }\n\n  /**\n   * @return {HTMLCanvasElement} Image\n   */\n  getImage() {\n    const context = this.context;\n    return context ? context.canvas : null;\n  }\n\n  /**\n   * Get the image from a tile.\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @protected\n   */\n  getTileImage(tile) {\n    return tile.getImage();\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @protected\n   */\n  scheduleExpireCache(frameState, tileSource) {\n    if (tileSource.canExpireCache()) {\n      /**\n       * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n       * @param {import(\"../../Map.js\").default} map Map.\n       * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n       */\n      const postRenderFunction = function (tileSource, map, frameState) {\n        const tileSourceKey = getUid(tileSource);\n        if (tileSourceKey in frameState.usedTiles) {\n          tileSource.expireCache(\n            frameState.viewState.projection,\n            frameState.usedTiles[tileSourceKey]\n          );\n        }\n      }.bind(null, tileSource);\n\n      frameState.postRenderFunctions.push(\n        /** @type {import(\"../../Map.js\").PostRenderFunction} */ (\n          postRenderFunction\n        )\n      );\n    }\n  }\n\n  /**\n   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import('../../Tile.js').default} tile Tile.\n   * @protected\n   */\n  updateUsedTiles(usedTiles, tileSource, tile) {\n    // FIXME should we use tilesToDrawByZ instead?\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in usedTiles)) {\n      usedTiles[tileSourceKey] = {};\n    }\n    usedTiles[tileSourceKey][tile.getKey()] = true;\n  }\n\n  /**\n   * Manage tile pyramid.\n   * This function performs a number of functions related to the tiles at the\n   * current zoom and lower zoom levels:\n   * - registers idle tiles in frameState.wantedTiles so that they are not\n   *   discarded by the tile queue\n   * - enqueues missing tiles\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @param {import(\"../../extent.js\").Extent} extent Extent.\n   * @param {number} currentZ Current Z.\n   * @param {number} preload Load low resolution tiles up to `preload` levels.\n   * @param {function(import(\"../../Tile.js\").default):void} [tileCallback] Tile callback.\n   * @protected\n   */\n  manageTilePyramid(\n    frameState,\n    tileSource,\n    tileGrid,\n    pixelRatio,\n    projection,\n    extent,\n    currentZ,\n    preload,\n    tileCallback\n  ) {\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n    const wantedTiles = frameState.wantedTiles[tileSourceKey];\n    const tileQueue = frameState.tileQueue;\n    const minZoom = tileGrid.getMinZoom();\n    const rotation = frameState.viewState.rotation;\n    const viewport = rotation\n      ? getRotatedViewport(\n          frameState.viewState.center,\n          frameState.viewState.resolution,\n          rotation,\n          frameState.size\n        )\n      : undefined;\n    let tileCount = 0;\n    let tile, tileRange, tileResolution, x, y, z;\n    for (z = minZoom; z <= currentZ; ++z) {\n      tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);\n      tileResolution = tileGrid.getResolution(z);\n      for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          if (\n            rotation &&\n            !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)\n          ) {\n            continue;\n          }\n          if (currentZ - z <= preload) {\n            ++tileCount;\n            tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n            if (tile.getState() == TileState.IDLE) {\n              wantedTiles[tile.getKey()] = true;\n              if (!tileQueue.isKeyQueued(tile.getKey())) {\n                tileQueue.enqueue([\n                  tile,\n                  tileSourceKey,\n                  tileGrid.getTileCoordCenter(tile.tileCoord),\n                  tileResolution,\n                ]);\n              }\n            }\n            if (tileCallback !== undefined) {\n              tileCallback(tile);\n            }\n          } else {\n            tileSource.useTile(z, x, y, projection);\n          }\n        }\n      }\n    }\n    tileSource.updateCacheSize(tileCount, projection);\n  }\n}\n\nexport default CanvasTileLayerRenderer;\n","/**\n * @module ol/renderer/canvas/VectorLayer\n */\nimport CanvasBuilderGroup from '../../render/canvas/BuilderGroup.js';\nimport CanvasLayerRenderer, {canvasPool} from './Layer.js';\nimport ExecutorGroup from '../../render/canvas/ExecutorGroup.js';\nimport ViewHint from '../../ViewHint.js';\nimport {\n  HIT_DETECT_RESOLUTION,\n  createHitDetectionImageData,\n  hitDetect,\n} from '../../render/canvas/hitdetect.js';\nimport {\n  apply,\n  makeInverse,\n  makeScale,\n  toString as transformToString,\n} from '../../transform.js';\nimport {\n  buffer,\n  containsExtent,\n  createEmpty,\n  getWidth,\n  intersects as intersectsExtent,\n  wrapX as wrapExtentX,\n} from '../../extent.js';\nimport {createCanvasContext2D, releaseCanvas} from '../../dom.js';\nimport {\n  defaultOrder as defaultRenderOrder,\n  getTolerance as getRenderTolerance,\n  getSquaredTolerance as getSquaredRenderTolerance,\n  renderFeature,\n} from '../vector.js';\nimport {equals} from '../../array.js';\nimport {\n  fromUserExtent,\n  getTransformFromProjections,\n  getUserProjection,\n  toUserExtent,\n  toUserResolution,\n} from '../../proj.js';\nimport {getUid} from '../../util.js';\nimport {wrapX as wrapCoordinateX} from '../../coordinate.js';\n\n/**\n * @classdesc\n * Canvas renderer for vector layers.\n * @api\n */\nclass CanvasVectorLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {import(\"../../layer/BaseVector.js\").default} vectorLayer Vector layer.\n   */\n  constructor(vectorLayer) {\n    super(vectorLayer);\n\n    /** @private */\n    this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this);\n\n    /**\n     * @type {boolean}\n     */\n    this.animatingOrInteracting_;\n\n    /**\n     * @type {ImageData|null}\n     */\n    this.hitDetectionImageData_ = null;\n\n    /**\n     * @type {Array<import(\"../../Feature.js\").default>}\n     */\n    this.renderedFeatures_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedRevision_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedResolution_ = NaN;\n\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.renderedExtent_ = createEmpty();\n\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.wrappedRenderedExtent_ = createEmpty();\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedRotation_;\n\n    /**\n     * @private\n     * @type {import(\"../../coordinate\").Coordinate}\n     */\n    this.renderedCenter_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../../proj/Projection\").default}\n     */\n    this.renderedProjection_ = null;\n\n    /**\n     * @private\n     * @type {function(import(\"../../Feature.js\").default, import(\"../../Feature.js\").default): number|null}\n     */\n    this.renderedRenderOrder_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../../render/canvas/ExecutorGroup\").default}\n     */\n    this.replayGroup_ = null;\n\n    /**\n     * A new replay group had to be created by `prepareFrame()`\n     * @type {boolean}\n     */\n    this.replayGroupChanged = true;\n\n    /**\n     * @type {import(\"../../render/canvas/ExecutorGroup\").default}\n     */\n    this.declutterExecutorGroup = null;\n\n    /**\n     * Clipping to be performed by `renderFrame()`\n     * @type {boolean}\n     */\n    this.clipping = true;\n\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n    this.compositionContext_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.opacity_ = 1;\n  }\n\n  /**\n   * @param {ExecutorGroup} executorGroup Executor group.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"rbush\").default} [declutterTree] Declutter tree.\n   */\n  renderWorlds(executorGroup, frameState, declutterTree) {\n    const extent = frameState.extent;\n    const viewState = frameState.viewState;\n    const center = viewState.center;\n    const resolution = viewState.resolution;\n    const projection = viewState.projection;\n    const rotation = viewState.rotation;\n    const projectionExtent = projection.getExtent();\n    const vectorSource = this.getLayer().getSource();\n    const pixelRatio = frameState.pixelRatio;\n    const viewHints = frameState.viewHints;\n    const snapToPixel = !(\n      viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]\n    );\n    const context = this.compositionContext_;\n    const width = Math.round(frameState.size[0] * pixelRatio);\n    const height = Math.round(frameState.size[1] * pixelRatio);\n\n    const multiWorld = vectorSource.getWrapX() && projection.canWrapX();\n    const worldWidth = multiWorld ? getWidth(projectionExtent) : null;\n    const endWorld = multiWorld\n      ? Math.ceil((extent[2] - projectionExtent[2]) / worldWidth) + 1\n      : 1;\n    let world = multiWorld\n      ? Math.floor((extent[0] - projectionExtent[0]) / worldWidth)\n      : 0;\n    do {\n      const transform = this.getRenderTransform(\n        center,\n        resolution,\n        rotation,\n        pixelRatio,\n        width,\n        height,\n        world * worldWidth\n      );\n      executorGroup.execute(\n        context,\n        1,\n        transform,\n        rotation,\n        snapToPixel,\n        undefined,\n        declutterTree\n      );\n    } while (++world < endWorld);\n  }\n\n  setupCompositionContext_() {\n    if (this.opacity_ !== 1) {\n      const compositionContext = createCanvasContext2D(\n        this.context.canvas.width,\n        this.context.canvas.height,\n        canvasPool\n      );\n      this.compositionContext_ = compositionContext;\n    } else {\n      this.compositionContext_ = this.context;\n    }\n  }\n\n  releaseCompositionContext_() {\n    if (this.opacity_ !== 1) {\n      const alpha = this.context.globalAlpha;\n      this.context.globalAlpha = this.opacity_;\n      this.context.drawImage(this.compositionContext_.canvas, 0, 0);\n      this.context.globalAlpha = alpha;\n      releaseCanvas(this.compositionContext_);\n      canvasPool.push(this.compositionContext_.canvas);\n      this.compositionContext_ = null;\n    }\n  }\n\n  /**\n   * Render declutter items for this layer\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   */\n  renderDeclutter(frameState) {\n    if (this.declutterExecutorGroup) {\n      this.setupCompositionContext_();\n      this.renderWorlds(\n        this.declutterExecutorGroup,\n        frameState,\n        frameState.declutterTree\n      );\n      this.releaseCompositionContext_();\n    }\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState, target) {\n    const pixelRatio = frameState.pixelRatio;\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n\n    // set forward and inverse pixel transforms\n    makeScale(this.pixelTransform, 1 / pixelRatio, 1 / pixelRatio);\n    makeInverse(this.inversePixelTransform, this.pixelTransform);\n\n    const canvasTransform = transformToString(this.pixelTransform);\n\n    this.useContainer(target, canvasTransform, this.getBackground(frameState));\n    const context = this.context;\n    const canvas = context.canvas;\n\n    const replayGroup = this.replayGroup_;\n    const declutterExecutorGroup = this.declutterExecutorGroup;\n    if (\n      (!replayGroup || replayGroup.isEmpty()) &&\n      (!declutterExecutorGroup || declutterExecutorGroup.isEmpty())\n    ) {\n      return null;\n    }\n\n    // resize and clear\n    const width = Math.round(frameState.size[0] * pixelRatio);\n    const height = Math.round(frameState.size[1] * pixelRatio);\n    if (canvas.width != width || canvas.height != height) {\n      canvas.width = width;\n      canvas.height = height;\n      if (canvas.style.transform !== canvasTransform) {\n        canvas.style.transform = canvasTransform;\n      }\n    } else if (!this.containerReused) {\n      context.clearRect(0, 0, width, height);\n    }\n\n    this.preRender(context, frameState);\n\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n\n    this.opacity_ = layerState.opacity;\n    this.setupCompositionContext_();\n\n    // clipped rendering if layer extent is set\n    let clipped = false;\n    let render = true;\n    if (layerState.extent && this.clipping) {\n      const layerExtent = fromUserExtent(layerState.extent, projection);\n      render = intersectsExtent(layerExtent, frameState.extent);\n      clipped = render && !containsExtent(layerExtent, frameState.extent);\n      if (clipped) {\n        this.clipUnrotated(this.compositionContext_, frameState, layerExtent);\n      }\n    }\n\n    if (render) {\n      this.renderWorlds(replayGroup, frameState);\n    }\n\n    if (clipped) {\n      this.compositionContext_.restore();\n    }\n\n    this.releaseCompositionContext_();\n\n    this.postRender(context, frameState);\n\n    if (this.renderedRotation_ !== viewState.rotation) {\n      this.renderedRotation_ = viewState.rotation;\n      this.hitDetectionImageData_ = null;\n    }\n    return this.container;\n  }\n\n  /**\n   * Asynchronous layer level hit detection.\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../../Feature\").default>>} Promise\n   * that resolves with an array of features.\n   */\n  getFeatures(pixel) {\n    return new Promise((resolve) => {\n      if (!this.hitDetectionImageData_ && !this.animatingOrInteracting_) {\n        const size = [this.context.canvas.width, this.context.canvas.height];\n        apply(this.pixelTransform, size);\n        const center = this.renderedCenter_;\n        const resolution = this.renderedResolution_;\n        const rotation = this.renderedRotation_;\n        const projection = this.renderedProjection_;\n        const extent = this.wrappedRenderedExtent_;\n        const layer = this.getLayer();\n        const transforms = [];\n        const width = size[0] * HIT_DETECT_RESOLUTION;\n        const height = size[1] * HIT_DETECT_RESOLUTION;\n        transforms.push(\n          this.getRenderTransform(\n            center,\n            resolution,\n            rotation,\n            HIT_DETECT_RESOLUTION,\n            width,\n            height,\n            0\n          ).slice()\n        );\n        const source = layer.getSource();\n        const projectionExtent = projection.getExtent();\n        if (\n          source.getWrapX() &&\n          projection.canWrapX() &&\n          !containsExtent(projectionExtent, extent)\n        ) {\n          let startX = extent[0];\n          const worldWidth = getWidth(projectionExtent);\n          let world = 0;\n          let offsetX;\n          while (startX < projectionExtent[0]) {\n            --world;\n            offsetX = worldWidth * world;\n            transforms.push(\n              this.getRenderTransform(\n                center,\n                resolution,\n                rotation,\n                HIT_DETECT_RESOLUTION,\n                width,\n                height,\n                offsetX\n              ).slice()\n            );\n            startX += worldWidth;\n          }\n          world = 0;\n          startX = extent[2];\n          while (startX > projectionExtent[2]) {\n            ++world;\n            offsetX = worldWidth * world;\n            transforms.push(\n              this.getRenderTransform(\n                center,\n                resolution,\n                rotation,\n                HIT_DETECT_RESOLUTION,\n                width,\n                height,\n                offsetX\n              ).slice()\n            );\n            startX -= worldWidth;\n          }\n        }\n\n        this.hitDetectionImageData_ = createHitDetectionImageData(\n          size,\n          transforms,\n          this.renderedFeatures_,\n          layer.getStyleFunction(),\n          extent,\n          resolution,\n          rotation\n        );\n      }\n      resolve(\n        hitDetect(pixel, this.renderedFeatures_, this.hitDetectionImageData_)\n      );\n    });\n  }\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches\n  ) {\n    if (!this.replayGroup_) {\n      return undefined;\n    }\n    const resolution = frameState.viewState.resolution;\n    const rotation = frameState.viewState.rotation;\n    const layer = this.getLayer();\n\n    /** @type {!Object<string, import(\"../Map.js\").HitMatch<T>|true>} */\n    const features = {};\n\n    /**\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     * @param {import(\"../../geom/SimpleGeometry.js\").default} geometry Geometry.\n     * @param {number} distanceSq The squared distance to the click position\n     * @return {T|undefined} Callback result.\n     */\n    const featureCallback = function (feature, geometry, distanceSq) {\n      const key = getUid(feature);\n      const match = features[key];\n      if (!match) {\n        if (distanceSq === 0) {\n          features[key] = true;\n          return callback(feature, layer, geometry);\n        }\n        matches.push(\n          (features[key] = {\n            feature: feature,\n            layer: layer,\n            geometry: geometry,\n            distanceSq: distanceSq,\n            callback: callback,\n          })\n        );\n      } else if (match !== true && distanceSq < match.distanceSq) {\n        if (distanceSq === 0) {\n          features[key] = true;\n          matches.splice(matches.lastIndexOf(match), 1);\n          return callback(feature, layer, geometry);\n        }\n        match.geometry = geometry;\n        match.distanceSq = distanceSq;\n      }\n      return undefined;\n    };\n\n    let result;\n    const executorGroups = [this.replayGroup_];\n    if (this.declutterExecutorGroup) {\n      executorGroups.push(this.declutterExecutorGroup);\n    }\n    executorGroups.some((executorGroup) => {\n      return (result = executorGroup.forEachFeatureAtCoordinate(\n        coordinate,\n        resolution,\n        rotation,\n        hitTolerance,\n        featureCallback,\n        executorGroup === this.declutterExecutorGroup &&\n          frameState.declutterTree\n          ? frameState.declutterTree.all().map((item) => item.value)\n          : null\n      ));\n    });\n\n    return result;\n  }\n\n  /**\n   * Perform action necessary to get the layer rendered after new fonts have loaded\n   */\n  handleFontsChanged() {\n    const layer = this.getLayer();\n    if (layer.getVisible() && this.replayGroup_) {\n      layer.changed();\n    }\n  }\n\n  /**\n   * Handle changes in image style state.\n   * @param {import(\"../../events/Event.js\").default} event Image style change event.\n   * @private\n   */\n  handleStyleImageChange_(event) {\n    this.renderIfReadyAndVisible();\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    const vectorLayer = this.getLayer();\n    const vectorSource = vectorLayer.getSource();\n    if (!vectorSource) {\n      return false;\n    }\n\n    const animating = frameState.viewHints[ViewHint.ANIMATING];\n    const interacting = frameState.viewHints[ViewHint.INTERACTING];\n    const updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();\n    const updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();\n\n    if (\n      (this.ready && !updateWhileAnimating && animating) ||\n      (!updateWhileInteracting && interacting)\n    ) {\n      this.animatingOrInteracting_ = true;\n      return true;\n    }\n    this.animatingOrInteracting_ = false;\n\n    const frameStateExtent = frameState.extent;\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const resolution = viewState.resolution;\n    const pixelRatio = frameState.pixelRatio;\n    const vectorLayerRevision = vectorLayer.getRevision();\n    const vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();\n    let vectorLayerRenderOrder = vectorLayer.getRenderOrder();\n\n    if (vectorLayerRenderOrder === undefined) {\n      vectorLayerRenderOrder = defaultRenderOrder;\n    }\n\n    const center = viewState.center.slice();\n    const extent = buffer(\n      frameStateExtent,\n      vectorLayerRenderBuffer * resolution\n    );\n    const renderedExtent = extent.slice();\n    const loadExtents = [extent.slice()];\n    const projectionExtent = projection.getExtent();\n\n    if (\n      vectorSource.getWrapX() &&\n      projection.canWrapX() &&\n      !containsExtent(projectionExtent, frameState.extent)\n    ) {\n      // For the replay group, we need an extent that intersects the real world\n      // (-180 to +180). To support geometries in a coordinate range from -540\n      // to +540, we add at least 1 world width on each side of the projection\n      // extent. If the viewport is wider than the world, we need to add half of\n      // the viewport width to make sure we cover the whole viewport.\n      const worldWidth = getWidth(projectionExtent);\n      const gutter = Math.max(getWidth(extent) / 2, worldWidth);\n      extent[0] = projectionExtent[0] - gutter;\n      extent[2] = projectionExtent[2] + gutter;\n      wrapCoordinateX(center, projection);\n      const loadExtent = wrapExtentX(loadExtents[0], projection);\n      // If the extent crosses the date line, we load data for both edges of the worlds\n      if (\n        loadExtent[0] < projectionExtent[0] &&\n        loadExtent[2] < projectionExtent[2]\n      ) {\n        loadExtents.push([\n          loadExtent[0] + worldWidth,\n          loadExtent[1],\n          loadExtent[2] + worldWidth,\n          loadExtent[3],\n        ]);\n      } else if (\n        loadExtent[0] > projectionExtent[0] &&\n        loadExtent[2] > projectionExtent[2]\n      ) {\n        loadExtents.push([\n          loadExtent[0] - worldWidth,\n          loadExtent[1],\n          loadExtent[2] - worldWidth,\n          loadExtent[3],\n        ]);\n      }\n    }\n\n    if (\n      this.ready &&\n      this.renderedResolution_ == resolution &&\n      this.renderedRevision_ == vectorLayerRevision &&\n      this.renderedRenderOrder_ == vectorLayerRenderOrder &&\n      containsExtent(this.wrappedRenderedExtent_, extent)\n    ) {\n      if (!equals(this.renderedExtent_, renderedExtent)) {\n        this.hitDetectionImageData_ = null;\n        this.renderedExtent_ = renderedExtent;\n      }\n      this.renderedCenter_ = center;\n      this.replayGroupChanged = false;\n      return true;\n    }\n\n    this.replayGroup_ = null;\n\n    const replayGroup = new CanvasBuilderGroup(\n      getRenderTolerance(resolution, pixelRatio),\n      extent,\n      resolution,\n      pixelRatio\n    );\n\n    let declutterBuilderGroup;\n    if (this.getLayer().getDeclutter()) {\n      declutterBuilderGroup = new CanvasBuilderGroup(\n        getRenderTolerance(resolution, pixelRatio),\n        extent,\n        resolution,\n        pixelRatio\n      );\n    }\n\n    const userProjection = getUserProjection();\n    let userTransform;\n    if (userProjection) {\n      for (let i = 0, ii = loadExtents.length; i < ii; ++i) {\n        const extent = loadExtents[i];\n        const userExtent = toUserExtent(extent, projection);\n        vectorSource.loadFeatures(\n          userExtent,\n          toUserResolution(resolution, projection),\n          userProjection\n        );\n      }\n      userTransform = getTransformFromProjections(userProjection, projection);\n    } else {\n      for (let i = 0, ii = loadExtents.length; i < ii; ++i) {\n        vectorSource.loadFeatures(loadExtents[i], resolution, projection);\n      }\n    }\n\n    const squaredTolerance = getSquaredRenderTolerance(resolution, pixelRatio);\n    let ready = true;\n    const render =\n      /**\n       * @param {import(\"../../Feature.js\").default} feature Feature.\n       */\n      (feature) => {\n        let styles;\n        const styleFunction =\n          feature.getStyleFunction() || vectorLayer.getStyleFunction();\n        if (styleFunction) {\n          styles = styleFunction(feature, resolution);\n        }\n        if (styles) {\n          const dirty = this.renderFeature(\n            feature,\n            squaredTolerance,\n            styles,\n            replayGroup,\n            userTransform,\n            declutterBuilderGroup\n          );\n          ready = ready && !dirty;\n        }\n      };\n\n    const userExtent = toUserExtent(extent, projection);\n    /** @type {Array<import(\"../../Feature.js\").default>} */\n    const features = vectorSource.getFeaturesInExtent(userExtent);\n    if (vectorLayerRenderOrder) {\n      features.sort(vectorLayerRenderOrder);\n    }\n    for (let i = 0, ii = features.length; i < ii; ++i) {\n      render(features[i]);\n    }\n    this.renderedFeatures_ = features;\n    this.ready = ready;\n\n    const replayGroupInstructions = replayGroup.finish();\n    const executorGroup = new ExecutorGroup(\n      extent,\n      resolution,\n      pixelRatio,\n      vectorSource.getOverlaps(),\n      replayGroupInstructions,\n      vectorLayer.getRenderBuffer()\n    );\n\n    if (declutterBuilderGroup) {\n      this.declutterExecutorGroup = new ExecutorGroup(\n        extent,\n        resolution,\n        pixelRatio,\n        vectorSource.getOverlaps(),\n        declutterBuilderGroup.finish(),\n        vectorLayer.getRenderBuffer()\n      );\n    }\n\n    this.renderedResolution_ = resolution;\n    this.renderedRevision_ = vectorLayerRevision;\n    this.renderedRenderOrder_ = vectorLayerRenderOrder;\n    this.renderedExtent_ = renderedExtent;\n    this.wrappedRenderedExtent_ = extent;\n    this.renderedCenter_ = center;\n    this.renderedProjection_ = projection;\n    this.replayGroup_ = executorGroup;\n    this.hitDetectionImageData_ = null;\n\n    this.replayGroupChanged = true;\n    return true;\n  }\n\n  /**\n   * @param {import(\"../../Feature.js\").default} feature Feature.\n   * @param {number} squaredTolerance Squared render tolerance.\n   * @param {import(\"../../style/Style.js\").default|Array<import(\"../../style/Style.js\").default>} styles The style or array of styles.\n   * @param {import(\"../../render/canvas/BuilderGroup.js\").default} builderGroup Builder group.\n   * @param {import(\"../../proj.js\").TransformFunction} [transform] Transform from user to view projection.\n   * @param {import(\"../../render/canvas/BuilderGroup.js\").default} [declutterBuilderGroup] Builder for decluttering.\n   * @return {boolean} `true` if an image is loading.\n   */\n  renderFeature(\n    feature,\n    squaredTolerance,\n    styles,\n    builderGroup,\n    transform,\n    declutterBuilderGroup\n  ) {\n    if (!styles) {\n      return false;\n    }\n    let loading = false;\n    if (Array.isArray(styles)) {\n      for (let i = 0, ii = styles.length; i < ii; ++i) {\n        loading =\n          renderFeature(\n            builderGroup,\n            feature,\n            styles[i],\n            squaredTolerance,\n            this.boundHandleStyleImageChange_,\n            transform,\n            declutterBuilderGroup\n          ) || loading;\n      }\n    } else {\n      loading = renderFeature(\n        builderGroup,\n        feature,\n        styles,\n        squaredTolerance,\n        this.boundHandleStyleImageChange_,\n        transform,\n        declutterBuilderGroup\n      );\n    }\n    return loading;\n  }\n}\n\nexport default CanvasVectorLayerRenderer;\n","/**\n * @module ol/renderer/canvas/VectorTileLayer\n */\nimport CanvasBuilderGroup from '../../render/canvas/BuilderGroup.js';\nimport CanvasExecutorGroup from '../../render/canvas/ExecutorGroup.js';\nimport CanvasTileLayerRenderer from './TileLayer.js';\nimport TileState from '../../TileState.js';\nimport ViewHint from '../../ViewHint.js';\nimport {\n  HIT_DETECT_RESOLUTION,\n  createHitDetectionImageData,\n  hitDetect,\n} from '../../render/canvas/hitdetect.js';\nimport {\n  apply as applyTransform,\n  create as createTransform,\n  multiply,\n  reset as resetTransform,\n  scale,\n  scale as scaleTransform,\n  translate as translateTransform,\n} from '../../transform.js';\nimport {\n  boundingExtent,\n  buffer,\n  containsExtent,\n  equals,\n  getIntersection,\n  getTopLeft,\n  intersects,\n} from '../../extent.js';\nimport {\n  getSquaredTolerance as getSquaredRenderTolerance,\n  renderFeature,\n} from '../vector.js';\nimport {getUid} from '../../util.js';\nimport {toSize} from '../../size.js';\nimport {wrapX} from '../../coordinate.js';\n\n/**\n * @type {!Object<string, Array<import(\"../../render/canvas.js\").BuilderType>>}\n */\nconst IMAGE_REPLAYS = {\n  'image': ['Polygon', 'Circle', 'LineString', 'Image', 'Text'],\n  'hybrid': ['Polygon', 'LineString'],\n  'vector': [],\n};\n\n/**\n * @type {!Object<string, Array<import(\"../../render/canvas.js\").BuilderType>>}\n */\nconst VECTOR_REPLAYS = {\n  'hybrid': ['Image', 'Text', 'Default'],\n  'vector': ['Polygon', 'Circle', 'LineString', 'Image', 'Text', 'Default'],\n};\n\n/**\n * @classdesc\n * Canvas renderer for vector tile layers.\n * @api\n * @extends {CanvasTileLayerRenderer<import(\"../../layer/VectorTile.js\").default>}\n */\nclass CanvasVectorTileLayerRenderer extends CanvasTileLayerRenderer {\n  /**\n   * @param {import(\"../../layer/VectorTile.js\").default} layer VectorTile layer.\n   */\n  constructor(layer) {\n    super(layer);\n\n    /** @private */\n    this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this);\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedLayerRevision_;\n\n    /**\n     * @private\n     * @type {import(\"../../transform\").Transform}\n     */\n    this.renderedPixelToCoordinateTransform_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedRotation_;\n\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.tmpTransform_ = createTransform();\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection\").default} projection Projection.\n   * @return {boolean|undefined} Tile needs to be rendered.\n   */\n  prepareTile(tile, pixelRatio, projection) {\n    let render;\n    const state = tile.getState();\n    if (state === TileState.LOADED || state === TileState.ERROR) {\n      this.updateExecutorGroup_(tile, pixelRatio, projection);\n      if (this.tileImageNeedsRender_(tile)) {\n        render = true;\n      }\n    }\n    return render;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {!import(\"../../Tile.js\").default} Tile.\n   */\n  getTile(z, x, y, frameState) {\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const resolution = viewState.resolution;\n    const projection = viewState.projection;\n    const layer = this.getLayer();\n    const tile = layer.getSource().getTile(z, x, y, pixelRatio, projection);\n    const viewHints = frameState.viewHints;\n    const hifi = !(\n      viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]\n    );\n    if (hifi || !tile.wantedResolution) {\n      tile.wantedResolution = resolution;\n    }\n    const render = this.prepareTile(tile, pixelRatio, projection);\n    if (\n      render &&\n      (hifi || Date.now() - frameState.time < 8) &&\n      layer.getRenderMode() !== 'vector'\n    ) {\n      this.renderTileImage_(tile, frameState);\n    }\n    return super.getTile(z, x, y, frameState);\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @return {boolean} Tile is drawable.\n   */\n  isDrawableTile(tile) {\n    const layer = this.getLayer();\n    return (\n      super.isDrawableTile(tile) &&\n      (layer.getRenderMode() === 'vector'\n        ? getUid(layer) in tile.executorGroups\n        : tile.hasContext(layer))\n    );\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getTileImage(tile) {\n    return tile.getImage(this.getLayer());\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    const layerRevision = this.getLayer().getRevision();\n    if (this.renderedLayerRevision_ !== layerRevision) {\n      this.renderedLayerRevision_ = layerRevision;\n      this.renderedTiles.length = 0;\n    }\n    return super.prepareFrame(frameState);\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @private\n   */\n  updateExecutorGroup_(tile, pixelRatio, projection) {\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    const revision = layer.getRevision();\n    const renderOrder = layer.getRenderOrder() || null;\n\n    const resolution = tile.wantedResolution;\n    const builderState = tile.getReplayState(layer);\n    if (\n      !builderState.dirty &&\n      builderState.renderedResolution === resolution &&\n      builderState.renderedRevision == revision &&\n      builderState.renderedRenderOrder == renderOrder\n    ) {\n      return;\n    }\n\n    const source = layer.getSource();\n    const declutter = layer.getDeclutter();\n    const sourceTileGrid = source.getTileGrid();\n    const tileGrid = source.getTileGridForProjection(projection);\n    const tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n\n    const sourceTiles = source.getSourceTiles(pixelRatio, projection, tile);\n    const layerUid = getUid(layer);\n    delete tile.hitDetectionImageData[layerUid];\n    tile.executorGroups[layerUid] = [];\n    if (declutter) {\n      tile.declutterExecutorGroups[layerUid] = [];\n    }\n    builderState.dirty = false;\n    for (let t = 0, tt = sourceTiles.length; t < tt; ++t) {\n      const sourceTile = sourceTiles[t];\n      if (sourceTile.getState() != TileState.LOADED) {\n        continue;\n      }\n      const sourceTileCoord = sourceTile.tileCoord;\n      const sourceTileExtent =\n        sourceTileGrid.getTileCoordExtent(sourceTileCoord);\n      const sharedExtent = getIntersection(tileExtent, sourceTileExtent);\n      const builderExtent = buffer(\n        sharedExtent,\n        layer.getRenderBuffer() * resolution,\n        this.tmpExtent\n      );\n      const bufferedExtent = equals(sourceTileExtent, sharedExtent)\n        ? null\n        : builderExtent;\n      const builderGroup = new CanvasBuilderGroup(\n        0,\n        builderExtent,\n        resolution,\n        pixelRatio\n      );\n      const declutterBuilderGroup = declutter\n        ? new CanvasBuilderGroup(0, sharedExtent, resolution, pixelRatio)\n        : undefined;\n      const squaredTolerance = getSquaredRenderTolerance(\n        resolution,\n        pixelRatio\n      );\n\n      /**\n       * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n       * @this {CanvasVectorTileLayerRenderer}\n       */\n      const render = function (feature) {\n        let styles;\n        const styleFunction =\n          feature.getStyleFunction() || layer.getStyleFunction();\n        if (styleFunction) {\n          styles = styleFunction(feature, resolution);\n        }\n        if (styles) {\n          const dirty = this.renderFeature(\n            feature,\n            squaredTolerance,\n            styles,\n            builderGroup,\n            declutterBuilderGroup\n          );\n          builderState.dirty = builderState.dirty || dirty;\n        }\n      };\n\n      const features = sourceTile.getFeatures();\n      if (renderOrder && renderOrder !== builderState.renderedRenderOrder) {\n        features.sort(renderOrder);\n      }\n      for (let i = 0, ii = features.length; i < ii; ++i) {\n        const feature = features[i];\n        if (\n          !bufferedExtent ||\n          intersects(bufferedExtent, feature.getGeometry().getExtent())\n        ) {\n          render.call(this, feature);\n        }\n      }\n      const executorGroupInstructions = builderGroup.finish();\n      // no need to clip when the render tile is covered by a single source tile\n      const replayExtent =\n        layer.getRenderMode() !== 'vector' &&\n        declutter &&\n        sourceTiles.length === 1\n          ? null\n          : sharedExtent;\n      const renderingReplayGroup = new CanvasExecutorGroup(\n        replayExtent,\n        resolution,\n        pixelRatio,\n        source.getOverlaps(),\n        executorGroupInstructions,\n        layer.getRenderBuffer()\n      );\n      tile.executorGroups[layerUid].push(renderingReplayGroup);\n      if (declutterBuilderGroup) {\n        const declutterExecutorGroup = new CanvasExecutorGroup(\n          null,\n          resolution,\n          pixelRatio,\n          source.getOverlaps(),\n          declutterBuilderGroup.finish(),\n          layer.getRenderBuffer()\n        );\n        tile.declutterExecutorGroups[layerUid].push(declutterExecutorGroup);\n      }\n    }\n    builderState.renderedRevision = revision;\n    builderState.renderedRenderOrder = renderOrder;\n    builderState.renderedResolution = resolution;\n  }\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches\n  ) {\n    const resolution = frameState.viewState.resolution;\n    const rotation = frameState.viewState.rotation;\n    hitTolerance = hitTolerance == undefined ? 0 : hitTolerance;\n    const layer = this.getLayer();\n    const source = layer.getSource();\n    const tileGrid = source.getTileGridForProjection(\n      frameState.viewState.projection\n    );\n\n    const hitExtent = boundingExtent([coordinate]);\n    buffer(hitExtent, resolution * hitTolerance, hitExtent);\n\n    /** @type {!Object<string, import(\"../Map.js\").HitMatch<T>|true>} */\n    const features = {};\n\n    /**\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     * @param {import(\"../../geom/SimpleGeometry.js\").default} geometry Geometry.\n     * @param {number} distanceSq The squared distance to the click position.\n     * @return {T|undefined} Callback result.\n     */\n    const featureCallback = function (feature, geometry, distanceSq) {\n      let key = feature.getId();\n      if (key === undefined) {\n        key = getUid(feature);\n      }\n      const match = features[key];\n      if (!match) {\n        if (distanceSq === 0) {\n          features[key] = true;\n          return callback(feature, layer, geometry);\n        }\n        matches.push(\n          (features[key] = {\n            feature: feature,\n            layer: layer,\n            geometry: geometry,\n            distanceSq: distanceSq,\n            callback: callback,\n          })\n        );\n      } else if (match !== true && distanceSq < match.distanceSq) {\n        if (distanceSq === 0) {\n          features[key] = true;\n          matches.splice(matches.lastIndexOf(match), 1);\n          return callback(feature, layer, geometry);\n        }\n        match.geometry = geometry;\n        match.distanceSq = distanceSq;\n      }\n      return undefined;\n    };\n\n    const renderedTiles =\n      /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */ (\n        this.renderedTiles\n      );\n\n    let found;\n    for (let i = 0, ii = renderedTiles.length; !found && i < ii; ++i) {\n      const tile = renderedTiles[i];\n      const tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n      if (!intersects(tileExtent, hitExtent)) {\n        continue;\n      }\n\n      const layerUid = getUid(layer);\n      const executorGroups = [tile.executorGroups[layerUid]];\n      const declutterExecutorGroups = tile.declutterExecutorGroups[layerUid];\n      if (declutterExecutorGroups) {\n        executorGroups.push(declutterExecutorGroups);\n      }\n      executorGroups.some((executorGroups) => {\n        const declutteredFeatures =\n          executorGroups === declutterExecutorGroups\n            ? frameState.declutterTree.all().map((item) => item.value)\n            : null;\n        for (let t = 0, tt = executorGroups.length; t < tt; ++t) {\n          const executorGroup = executorGroups[t];\n          found = executorGroup.forEachFeatureAtCoordinate(\n            coordinate,\n            resolution,\n            rotation,\n            hitTolerance,\n            featureCallback,\n            declutteredFeatures\n          );\n          if (found) {\n            return true;\n          }\n        }\n      });\n    }\n    return found;\n  }\n\n  /**\n   * Asynchronous layer level hit detection.\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../../Feature.js\").FeatureLike>>} Promise that resolves with an array of features.\n   */\n  getFeatures(pixel) {\n    return new Promise((resolve, reject) => {\n      const layer = this.getLayer();\n      const layerUid = getUid(layer);\n      const source = layer.getSource();\n      const projection = this.renderedProjection;\n      const projectionExtent = projection.getExtent();\n      const resolution = this.renderedResolution;\n      const tileGrid = source.getTileGridForProjection(projection);\n      const coordinate = applyTransform(\n        this.renderedPixelToCoordinateTransform_,\n        pixel.slice()\n      );\n      const tileCoord = tileGrid.getTileCoordForCoordAndResolution(\n        coordinate,\n        resolution\n      );\n      /** @type {import(\"../../VectorRenderTile.js\").default|undefined} */\n      let tile;\n      for (let i = 0, ii = this.renderedTiles.length; i < ii; ++i) {\n        if (\n          tileCoord.toString() === this.renderedTiles[i].tileCoord.toString()\n        ) {\n          tile = /** @type {import(\"../../VectorRenderTile.js\").default} */ (\n            this.renderedTiles[i]\n          );\n          if (tile.getState() === TileState.LOADED) {\n            const extent = tileGrid.getTileCoordExtent(tile.tileCoord);\n            if (\n              source.getWrapX() &&\n              projection.canWrapX() &&\n              !containsExtent(projectionExtent, extent)\n            ) {\n              wrapX(coordinate, projection);\n            }\n            break;\n          }\n          tile = undefined;\n        }\n      }\n      if (!tile || tile.loadingSourceTiles > 0) {\n        resolve([]);\n        return;\n      }\n      const extent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n      const corner = getTopLeft(extent);\n      const tilePixel = [\n        (coordinate[0] - corner[0]) / resolution,\n        (corner[1] - coordinate[1]) / resolution,\n      ];\n      /** @type {Array<import(\"../../Feature.js\").FeatureLike>} */\n      const features = tile\n        .getSourceTiles()\n        .reduce(function (accumulator, sourceTile) {\n          return accumulator.concat(sourceTile.getFeatures());\n        }, []);\n      /** @type {ImageData|undefined} */\n      let hitDetectionImageData = tile.hitDetectionImageData[layerUid];\n      if (!hitDetectionImageData) {\n        const tileSize = toSize(\n          tileGrid.getTileSize(\n            tileGrid.getZForResolution(resolution, source.zDirection)\n          )\n        );\n        const rotation = this.renderedRotation_;\n        const transforms = [\n          this.getRenderTransform(\n            tileGrid.getTileCoordCenter(tile.wrappedTileCoord),\n            resolution,\n            0,\n            HIT_DETECT_RESOLUTION,\n            tileSize[0] * HIT_DETECT_RESOLUTION,\n            tileSize[1] * HIT_DETECT_RESOLUTION,\n            0\n          ),\n        ];\n        hitDetectionImageData = createHitDetectionImageData(\n          tileSize,\n          transforms,\n          features,\n          layer.getStyleFunction(),\n          tileGrid.getTileCoordExtent(tile.wrappedTileCoord),\n          tile.getReplayState(layer).renderedResolution,\n          rotation\n        );\n        tile.hitDetectionImageData[layerUid] = hitDetectionImageData;\n      }\n      resolve(hitDetect(tilePixel, features, hitDetectionImageData));\n    });\n  }\n\n  /**\n   * Perform action necessary to get the layer rendered after new fonts have loaded\n   */\n  handleFontsChanged() {\n    const layer = this.getLayer();\n    if (layer.getVisible() && this.renderedLayerRevision_ !== undefined) {\n      layer.changed();\n    }\n  }\n\n  /**\n   * Handle changes in image style state.\n   * @param {import(\"../../events/Event.js\").default} event Image style change event.\n   * @private\n   */\n  handleStyleImageChange_(event) {\n    this.renderIfReadyAndVisible();\n  }\n\n  /**\n   * Render declutter items for this layer\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   */\n  renderDeclutter(frameState) {\n    const context = this.context;\n    const alpha = context.globalAlpha;\n    context.globalAlpha = this.getLayer().getOpacity();\n    const viewHints = frameState.viewHints;\n    const hifi = !(\n      viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]\n    );\n    const tiles =\n      /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */ (\n        this.renderedTiles\n      );\n    for (let i = 0, ii = tiles.length; i < ii; ++i) {\n      const tile = tiles[i];\n      const declutterExecutorGroups =\n        tile.declutterExecutorGroups[getUid(this.getLayer())];\n      if (declutterExecutorGroups) {\n        for (let j = declutterExecutorGroups.length - 1; j >= 0; --j) {\n          declutterExecutorGroups[j].execute(\n            this.context,\n            1,\n            this.getTileRenderTransform(tile, frameState),\n            frameState.viewState.rotation,\n            hifi,\n            undefined,\n            frameState.declutterTree\n          );\n        }\n      }\n    }\n    context.globalAlpha = alpha;\n  }\n\n  getTileRenderTransform(tile, frameState) {\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const center = viewState.center;\n    const resolution = viewState.resolution;\n    const rotation = viewState.rotation;\n    const size = frameState.size;\n    const width = Math.round(size[0] * pixelRatio);\n    const height = Math.round(size[1] * pixelRatio);\n\n    const source = this.getLayer().getSource();\n    const tileGrid = source.getTileGridForProjection(\n      frameState.viewState.projection\n    );\n    const tileCoord = tile.tileCoord;\n    const tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n    const worldOffset =\n      tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent)[0] - tileExtent[0];\n    const transform = multiply(\n      scale(this.inversePixelTransform.slice(), 1 / pixelRatio, 1 / pixelRatio),\n      this.getRenderTransform(\n        center,\n        resolution,\n        rotation,\n        pixelRatio,\n        width,\n        height,\n        worldOffset\n      )\n    );\n    return transform;\n  }\n\n  /**\n   * Render the vectors for this layer.\n   * @param {CanvasRenderingContext2D} context Target context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   */\n  postRender(context, frameState) {\n    const viewHints = frameState.viewHints;\n    const hifi = !(\n      viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]\n    );\n\n    this.renderedPixelToCoordinateTransform_ =\n      frameState.pixelToCoordinateTransform.slice();\n    this.renderedRotation_ = frameState.viewState.rotation;\n\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    const renderMode = layer.getRenderMode();\n    const alpha = context.globalAlpha;\n    context.globalAlpha = layer.getOpacity();\n    const replayTypes = VECTOR_REPLAYS[renderMode];\n    const viewState = frameState.viewState;\n    const rotation = viewState.rotation;\n    const tileSource = layer.getSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n    const z = tileGrid.getZForResolution(\n      viewState.resolution,\n      tileSource.zDirection\n    );\n\n    const tiles = this.renderedTiles;\n    const clips = [];\n    const clipZs = [];\n    let ready = true;\n    for (let i = tiles.length - 1; i >= 0; --i) {\n      const tile = /** @type {import(\"../../VectorRenderTile.js\").default} */ (\n        tiles[i]\n      );\n      ready = ready && !tile.getReplayState(layer).dirty;\n      const executorGroups = tile.executorGroups[getUid(layer)].filter(\n        (group) => group.hasExecutors(replayTypes)\n      );\n      if (executorGroups.length === 0) {\n        continue;\n      }\n      const transform = this.getTileRenderTransform(tile, frameState);\n      const currentZ = tile.tileCoord[0];\n      let contextSaved = false;\n      // Clip mask for regions in this tile that already filled by a higher z tile\n      const currentClip = executorGroups[0].getClipCoords(transform);\n      if (currentClip) {\n        for (let j = 0, jj = clips.length; j < jj; ++j) {\n          if (z !== currentZ && currentZ < clipZs[j]) {\n            const clip = clips[j];\n            if (\n              intersects(\n                [\n                  currentClip[0],\n                  currentClip[3],\n                  currentClip[4],\n                  currentClip[7],\n                ],\n                [clip[0], clip[3], clip[4], clip[7]]\n              )\n            ) {\n              if (!contextSaved) {\n                context.save();\n                contextSaved = true;\n              }\n              context.beginPath();\n              // counter-clockwise (outer ring) for current tile\n              context.moveTo(currentClip[0], currentClip[1]);\n              context.lineTo(currentClip[2], currentClip[3]);\n              context.lineTo(currentClip[4], currentClip[5]);\n              context.lineTo(currentClip[6], currentClip[7]);\n              // clockwise (inner ring) for higher z tile\n              context.moveTo(clip[6], clip[7]);\n              context.lineTo(clip[4], clip[5]);\n              context.lineTo(clip[2], clip[3]);\n              context.lineTo(clip[0], clip[1]);\n              context.clip();\n            }\n          }\n        }\n        clips.push(currentClip);\n        clipZs.push(currentZ);\n      }\n      for (let t = 0, tt = executorGroups.length; t < tt; ++t) {\n        const executorGroup = executorGroups[t];\n        executorGroup.execute(\n          context,\n          1,\n          transform,\n          rotation,\n          hifi,\n          replayTypes\n        );\n      }\n      if (contextSaved) {\n        context.restore();\n      }\n    }\n    context.globalAlpha = alpha;\n    this.ready = ready;\n\n    super.postRender(context, frameState);\n  }\n\n  /**\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../../style/Style.js\").default|Array<import(\"../../style/Style.js\").default>} styles The style or array of styles.\n   * @param {import(\"../../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n   * @param {import(\"../../render/canvas/BuilderGroup.js\").default} [declutterBuilderGroup] Builder group for decluttering.\n   * @return {boolean} `true` if an image is loading.\n   */\n  renderFeature(\n    feature,\n    squaredTolerance,\n    styles,\n    builderGroup,\n    declutterBuilderGroup\n  ) {\n    if (!styles) {\n      return false;\n    }\n    let loading = false;\n    if (Array.isArray(styles)) {\n      for (let i = 0, ii = styles.length; i < ii; ++i) {\n        loading =\n          renderFeature(\n            builderGroup,\n            feature,\n            styles[i],\n            squaredTolerance,\n            this.boundHandleStyleImageChange_,\n            undefined,\n            declutterBuilderGroup\n          ) || loading;\n      }\n    } else {\n      loading = renderFeature(\n        builderGroup,\n        feature,\n        styles,\n        squaredTolerance,\n        this.boundHandleStyleImageChange_,\n        undefined,\n        declutterBuilderGroup\n      );\n    }\n    return loading;\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @return {boolean} A new tile image was rendered.\n   * @private\n   */\n  tileImageNeedsRender_(tile) {\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    if (layer.getRenderMode() === 'vector') {\n      return false;\n    }\n    const replayState = tile.getReplayState(layer);\n    const revision = layer.getRevision();\n    const resolution = tile.wantedResolution;\n    return (\n      replayState.renderedTileResolution !== resolution ||\n      replayState.renderedTileRevision !== revision\n    );\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {import(\"../../Map\").FrameState} frameState Frame state.\n   * @private\n   */\n  renderTileImage_(tile, frameState) {\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    const replayState = tile.getReplayState(layer);\n    const revision = layer.getRevision();\n    const executorGroups = tile.executorGroups[getUid(layer)];\n    replayState.renderedTileRevision = revision;\n\n    const tileCoord = tile.wrappedTileCoord;\n    const z = tileCoord[0];\n    const source = layer.getSource();\n    let pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const tileGrid = source.getTileGridForProjection(projection);\n    const tileResolution = tileGrid.getResolution(tile.tileCoord[0]);\n    const renderPixelRatio =\n      (frameState.pixelRatio / tile.wantedResolution) * tileResolution;\n    const resolution = tileGrid.getResolution(z);\n    const context = tile.getContext(layer);\n\n    // Increase tile size when overzooming for low pixel ratio, to avoid blurry tiles\n    pixelRatio = Math.round(\n      Math.max(pixelRatio, renderPixelRatio / pixelRatio)\n    );\n    const size = source.getTilePixelSize(z, pixelRatio, projection);\n    context.canvas.width = size[0];\n    context.canvas.height = size[1];\n    const renderScale = pixelRatio / renderPixelRatio;\n    if (renderScale !== 1) {\n      const canvasTransform = resetTransform(this.tmpTransform_);\n      scaleTransform(canvasTransform, renderScale, renderScale);\n      context.setTransform.apply(context, canvasTransform);\n    }\n    const tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);\n    const pixelScale = renderPixelRatio / resolution;\n    const transform = resetTransform(this.tmpTransform_);\n    scaleTransform(transform, pixelScale, -pixelScale);\n    translateTransform(transform, -tileExtent[0], -tileExtent[3]);\n    for (let i = 0, ii = executorGroups.length; i < ii; ++i) {\n      const executorGroup = executorGroups[i];\n      executorGroup.execute(\n        context,\n        renderScale,\n        transform,\n        0,\n        true,\n        IMAGE_REPLAYS[layer.getRenderMode()]\n      );\n    }\n    replayState.renderedTileResolution = tile.wantedResolution;\n  }\n}\n\nexport default CanvasVectorTileLayerRenderer;\n","/**\n * @module ol/renderer/vector\n */\nimport ImageState from '../ImageState.js';\nimport {getUid} from '../util.js';\n\n/**\n * Feature callback. The callback will be called with three arguments. The first\n * argument is one {@link module:ol/Feature~Feature feature} or {@link module:ol/render/Feature~RenderFeature render feature}\n * at the pixel, the second is the {@link module:ol/layer/Layer~Layer layer} of the feature and will be null for\n * unmanaged layers. The third is the {@link module:ol/geom/SimpleGeometry~SimpleGeometry} of the feature. For features\n * with a GeometryCollection geometry, it will be the first detected geometry from the collection.\n * @template T\n * @typedef {function(import(\"../Feature.js\").FeatureLike, import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>, import(\"../geom/SimpleGeometry.js\").default): T} FeatureCallback\n */\n\n/**\n * Tolerance for geometry simplification in device pixels.\n * @type {number}\n */\nconst SIMPLIFY_TOLERANCE = 0.5;\n\n/**\n * @const\n * @type {Object<import(\"../geom/Geometry.js\").Type,\n *                function(import(\"../render/canvas/BuilderGroup.js\").default, import(\"../geom/Geometry.js\").default,\n *                         import(\"../style/Style.js\").default, Object): void>}\n */\nconst GEOMETRY_RENDERERS = {\n  'Point': renderPointGeometry,\n  'LineString': renderLineStringGeometry,\n  'Polygon': renderPolygonGeometry,\n  'MultiPoint': renderMultiPointGeometry,\n  'MultiLineString': renderMultiLineStringGeometry,\n  'MultiPolygon': renderMultiPolygonGeometry,\n  'GeometryCollection': renderGeometryCollectionGeometry,\n  'Circle': renderCircleGeometry,\n};\n\n/**\n * @param {import(\"../Feature.js\").FeatureLike} feature1 Feature 1.\n * @param {import(\"../Feature.js\").FeatureLike} feature2 Feature 2.\n * @return {number} Order.\n */\nexport function defaultOrder(feature1, feature2) {\n  return parseInt(getUid(feature1), 10) - parseInt(getUid(feature2), 10);\n}\n\n/**\n * @param {number} resolution Resolution.\n * @param {number} pixelRatio Pixel ratio.\n * @return {number} Squared pixel tolerance.\n */\nexport function getSquaredTolerance(resolution, pixelRatio) {\n  const tolerance = getTolerance(resolution, pixelRatio);\n  return tolerance * tolerance;\n}\n\n/**\n * @param {number} resolution Resolution.\n * @param {number} pixelRatio Pixel ratio.\n * @return {number} Pixel tolerance.\n */\nexport function getTolerance(resolution, pixelRatio) {\n  return (SIMPLIFY_TOLERANCE * resolution) / pixelRatio;\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Builder group.\n * @param {import(\"../geom/Circle.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderCircleGeometry(\n  builderGroup,\n  geometry,\n  style,\n  feature,\n  declutterBuilderGroup\n) {\n  const fillStyle = style.getFill();\n  const strokeStyle = style.getStroke();\n  if (fillStyle || strokeStyle) {\n    const circleReplay = builderGroup.getBuilder(style.getZIndex(), 'Circle');\n    circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);\n    circleReplay.drawCircle(geometry, feature);\n  }\n  const textStyle = style.getText();\n  if (textStyle && textStyle.getText()) {\n    const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(\n      style.getZIndex(),\n      'Text'\n    );\n    textReplay.setTextStyle(textStyle);\n    textReplay.drawText(geometry, feature);\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} replayGroup Replay group.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {function(import(\"../events/Event.js\").default): void} listener Listener function.\n * @param {import(\"../proj.js\").TransformFunction} [transform] Transform from user to view projection.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [declutterBuilderGroup] Builder for decluttering.\n * @return {boolean} `true` if style is loading.\n */\nexport function renderFeature(\n  replayGroup,\n  feature,\n  style,\n  squaredTolerance,\n  listener,\n  transform,\n  declutterBuilderGroup\n) {\n  let loading = false;\n  const imageStyle = style.getImage();\n  if (imageStyle) {\n    const imageState = imageStyle.getImageState();\n    if (imageState == ImageState.LOADED || imageState == ImageState.ERROR) {\n      imageStyle.unlistenImageChange(listener);\n    } else {\n      if (imageState == ImageState.IDLE) {\n        imageStyle.load();\n      }\n      imageStyle.listenImageChange(listener);\n      loading = true;\n    }\n  }\n  renderFeatureInternal(\n    replayGroup,\n    feature,\n    style,\n    squaredTolerance,\n    transform,\n    declutterBuilderGroup\n  );\n\n  return loading;\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} replayGroup Replay group.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {import(\"../proj.js\").TransformFunction} [transform] Optional transform function.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderFeatureInternal(\n  replayGroup,\n  feature,\n  style,\n  squaredTolerance,\n  transform,\n  declutterBuilderGroup\n) {\n  const geometry = style.getGeometryFunction()(feature);\n  if (!geometry) {\n    return;\n  }\n  const simplifiedGeometry = geometry.simplifyTransformed(\n    squaredTolerance,\n    transform\n  );\n  const renderer = style.getRenderer();\n  if (renderer) {\n    renderGeometry(replayGroup, simplifiedGeometry, style, feature);\n  } else {\n    const geometryRenderer = GEOMETRY_RENDERERS[simplifiedGeometry.getType()];\n    geometryRenderer(\n      replayGroup,\n      simplifiedGeometry,\n      style,\n      feature,\n      declutterBuilderGroup\n    );\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} replayGroup Replay group.\n * @param {import(\"../geom/Geometry.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n */\nfunction renderGeometry(replayGroup, geometry, style, feature) {\n  if (geometry.getType() == 'GeometryCollection') {\n    const geometries =\n      /** @type {import(\"../geom/GeometryCollection.js\").default} */ (\n        geometry\n      ).getGeometries();\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      renderGeometry(replayGroup, geometries[i], style, feature);\n    }\n    return;\n  }\n  const replay = replayGroup.getBuilder(style.getZIndex(), 'Default');\n  replay.drawCustom(\n    /** @type {import(\"../geom/SimpleGeometry.js\").default} */ (geometry),\n    feature,\n    style.getRenderer(),\n    style.getHitDetectionRenderer()\n  );\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} replayGroup Replay group.\n * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderGeometryCollectionGeometry(\n  replayGroup,\n  geometry,\n  style,\n  feature,\n  declutterBuilderGroup\n) {\n  const geometries = geometry.getGeometriesArray();\n  let i, ii;\n  for (i = 0, ii = geometries.length; i < ii; ++i) {\n    const geometryRenderer = GEOMETRY_RENDERERS[geometries[i].getType()];\n    geometryRenderer(\n      replayGroup,\n      geometries[i],\n      style,\n      feature,\n      declutterBuilderGroup\n    );\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/LineString.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderLineStringGeometry(\n  builderGroup,\n  geometry,\n  style,\n  feature,\n  declutterBuilderGroup\n) {\n  const strokeStyle = style.getStroke();\n  if (strokeStyle) {\n    const lineStringReplay = builderGroup.getBuilder(\n      style.getZIndex(),\n      'LineString'\n    );\n    lineStringReplay.setFillStrokeStyle(null, strokeStyle);\n    lineStringReplay.drawLineString(geometry, feature);\n  }\n  const textStyle = style.getText();\n  if (textStyle && textStyle.getText()) {\n    const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(\n      style.getZIndex(),\n      'Text'\n    );\n    textReplay.setTextStyle(textStyle);\n    textReplay.drawText(geometry, feature);\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/MultiLineString.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderMultiLineStringGeometry(\n  builderGroup,\n  geometry,\n  style,\n  feature,\n  declutterBuilderGroup\n) {\n  const strokeStyle = style.getStroke();\n  if (strokeStyle) {\n    const lineStringReplay = builderGroup.getBuilder(\n      style.getZIndex(),\n      'LineString'\n    );\n    lineStringReplay.setFillStrokeStyle(null, strokeStyle);\n    lineStringReplay.drawMultiLineString(geometry, feature);\n  }\n  const textStyle = style.getText();\n  if (textStyle && textStyle.getText()) {\n    const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(\n      style.getZIndex(),\n      'Text'\n    );\n    textReplay.setTextStyle(textStyle);\n    textReplay.drawText(geometry, feature);\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderMultiPolygonGeometry(\n  builderGroup,\n  geometry,\n  style,\n  feature,\n  declutterBuilderGroup\n) {\n  const fillStyle = style.getFill();\n  const strokeStyle = style.getStroke();\n  if (strokeStyle || fillStyle) {\n    const polygonReplay = builderGroup.getBuilder(style.getZIndex(), 'Polygon');\n    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);\n    polygonReplay.drawMultiPolygon(geometry, feature);\n  }\n  const textStyle = style.getText();\n  if (textStyle && textStyle.getText()) {\n    const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(\n      style.getZIndex(),\n      'Text'\n    );\n    textReplay.setTextStyle(textStyle);\n    textReplay.drawText(geometry, feature);\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/Point.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderPointGeometry(\n  builderGroup,\n  geometry,\n  style,\n  feature,\n  declutterBuilderGroup\n) {\n  const imageStyle = style.getImage();\n  const textStyle = style.getText();\n  /** @type {import(\"../render/canvas.js\").DeclutterImageWithText} */\n  let declutterImageWithText;\n  if (imageStyle) {\n    if (imageStyle.getImageState() != ImageState.LOADED) {\n      return;\n    }\n    let imageBuilderGroup = builderGroup;\n    if (declutterBuilderGroup) {\n      const declutterMode = imageStyle.getDeclutterMode();\n      if (declutterMode !== 'none') {\n        imageBuilderGroup = declutterBuilderGroup;\n        if (declutterMode === 'obstacle') {\n          // draw in non-declutter group:\n          const imageReplay = builderGroup.getBuilder(\n            style.getZIndex(),\n            'Image'\n          );\n          imageReplay.setImageStyle(imageStyle, declutterImageWithText);\n          imageReplay.drawPoint(geometry, feature);\n        } else if (textStyle && textStyle.getText()) {\n          declutterImageWithText = {};\n        }\n      }\n    }\n    const imageReplay = imageBuilderGroup.getBuilder(\n      style.getZIndex(),\n      'Image'\n    );\n    imageReplay.setImageStyle(imageStyle, declutterImageWithText);\n    imageReplay.drawPoint(geometry, feature);\n  }\n  if (textStyle && textStyle.getText()) {\n    let textBuilderGroup = builderGroup;\n    if (declutterBuilderGroup) {\n      textBuilderGroup = declutterBuilderGroup;\n    }\n    const textReplay = textBuilderGroup.getBuilder(style.getZIndex(), 'Text');\n    textReplay.setTextStyle(textStyle, declutterImageWithText);\n    textReplay.drawText(geometry, feature);\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/MultiPoint.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderMultiPointGeometry(\n  builderGroup,\n  geometry,\n  style,\n  feature,\n  declutterBuilderGroup\n) {\n  const imageStyle = style.getImage();\n  const textStyle = style.getText();\n  /** @type {import(\"../render/canvas.js\").DeclutterImageWithText} */\n  let declutterImageWithText;\n  if (imageStyle) {\n    if (imageStyle.getImageState() != ImageState.LOADED) {\n      return;\n    }\n    let imageBuilderGroup = builderGroup;\n    if (declutterBuilderGroup) {\n      const declutterMode = imageStyle.getDeclutterMode();\n      if (declutterMode !== 'none') {\n        imageBuilderGroup = declutterBuilderGroup;\n        if (declutterMode === 'obstacle') {\n          // draw in non-declutter group:\n          const imageReplay = builderGroup.getBuilder(\n            style.getZIndex(),\n            'Image'\n          );\n          imageReplay.setImageStyle(imageStyle, declutterImageWithText);\n          imageReplay.drawMultiPoint(geometry, feature);\n        } else if (textStyle && textStyle.getText()) {\n          declutterImageWithText = {};\n        }\n      }\n    }\n    const imageReplay = imageBuilderGroup.getBuilder(\n      style.getZIndex(),\n      'Image'\n    );\n    imageReplay.setImageStyle(imageStyle, declutterImageWithText);\n    imageReplay.drawMultiPoint(geometry, feature);\n  }\n  if (textStyle && textStyle.getText()) {\n    let textBuilderGroup = builderGroup;\n    if (declutterBuilderGroup) {\n      textBuilderGroup = declutterBuilderGroup;\n    }\n    const textReplay = textBuilderGroup.getBuilder(style.getZIndex(), 'Text');\n    textReplay.setTextStyle(textStyle, declutterImageWithText);\n    textReplay.drawText(geometry, feature);\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/Polygon.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderPolygonGeometry(\n  builderGroup,\n  geometry,\n  style,\n  feature,\n  declutterBuilderGroup\n) {\n  const fillStyle = style.getFill();\n  const strokeStyle = style.getStroke();\n  if (fillStyle || strokeStyle) {\n    const polygonReplay = builderGroup.getBuilder(style.getZIndex(), 'Polygon');\n    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);\n    polygonReplay.drawPolygon(geometry, feature);\n  }\n  const textStyle = style.getText();\n  if (textStyle && textStyle.getText()) {\n    const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(\n      style.getZIndex(),\n      'Text'\n    );\n    textReplay.setTextStyle(textStyle);\n    textReplay.drawText(geometry, feature);\n  }\n}\n","/**\n * @module ol/renderer/webgl/Layer\n */\nimport LayerProperty from '../../layer/Property.js';\nimport LayerRenderer from '../Layer.js';\nimport RenderEvent from '../../render/Event.js';\nimport RenderEventType from '../../render/EventType.js';\nimport WebGLHelper from '../../webgl/Helper.js';\nimport {\n  compose as composeTransform,\n  create as createTransform,\n} from '../../transform.js';\n\n/**\n * @typedef {Object} PostProcessesOptions\n * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than\n * the main canvas that will then be sampled up (useful for saving resource on blur steps).\n * @property {string} [vertexShader] Vertex shader source\n * @property {string} [fragmentShader] Fragment shader source\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process step\n */\n\n/**\n * @typedef {Object} Options\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process steps\n * @property {Array<PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n\n/**\n * @classdesc\n * Base WebGL renderer class.\n * Holds all logic related to data manipulation & some common rendering logic\n * @template {import(\"../../layer/Layer.js\").default} LayerType\n * @extends {LayerRenderer<LayerType>}\n */\nclass WebGLLayerRenderer extends LayerRenderer {\n  /**\n   * @param {LayerType} layer Layer.\n   * @param {Options} [options] Options.\n   */\n  constructor(layer, options) {\n    super(layer);\n\n    options = options || {};\n\n    /**\n     * The transform for viewport CSS pixels to rendered pixels.  This transform is only\n     * set before dispatching rendering events.\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.inversePixelTransform_ = createTransform();\n\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n    this.pixelContext_ = null;\n\n    /**\n     * @private\n     */\n    this.postProcesses_ = options.postProcesses;\n\n    /**\n     * @private\n     */\n    this.uniforms_ = options.uniforms;\n\n    /**\n     * @type {WebGLHelper}\n     * @protected\n     */\n    this.helper;\n\n    layer.addChangeListener(LayerProperty.MAP, this.removeHelper.bind(this));\n\n    this.dispatchPreComposeEvent = this.dispatchPreComposeEvent.bind(this);\n    this.dispatchPostComposeEvent = this.dispatchPostComposeEvent.bind(this);\n  }\n\n  /**\n   * @param {WebGLRenderingContext} context The WebGL rendering context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  dispatchPreComposeEvent(context, frameState) {\n    const layer = this.getLayer();\n    if (layer.hasListener(RenderEventType.PRECOMPOSE)) {\n      const event = new RenderEvent(\n        RenderEventType.PRECOMPOSE,\n        undefined,\n        frameState,\n        context\n      );\n      layer.dispatchEvent(event);\n    }\n  }\n\n  /**\n   * @param {WebGLRenderingContext} context The WebGL rendering context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  dispatchPostComposeEvent(context, frameState) {\n    const layer = this.getLayer();\n    if (layer.hasListener(RenderEventType.POSTCOMPOSE)) {\n      const event = new RenderEvent(\n        RenderEventType.POSTCOMPOSE,\n        undefined,\n        frameState,\n        context\n      );\n      layer.dispatchEvent(event);\n    }\n  }\n\n  /**\n   * Reset options (only handles uniforms).\n   * @param {Options} options Options.\n   */\n  reset(options) {\n    this.uniforms_ = options.uniforms;\n    if (this.helper) {\n      this.helper.setUniforms(this.uniforms_);\n    }\n  }\n\n  /**\n   * @protected\n   */\n  removeHelper() {\n    if (this.helper) {\n      this.helper.dispose();\n      delete this.helper;\n    }\n  }\n\n  /**\n   * Determine whether renderFrame should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    if (this.getLayer().getRenderSource()) {\n      let incrementGroup = true;\n      let groupNumber = -1;\n      let className;\n      for (let i = 0, ii = frameState.layerStatesArray.length; i < ii; i++) {\n        const layer = frameState.layerStatesArray[i].layer;\n        const renderer = layer.getRenderer();\n        if (!(renderer instanceof WebGLLayerRenderer)) {\n          incrementGroup = true;\n          continue;\n        }\n        const layerClassName = layer.getClassName();\n        if (incrementGroup || layerClassName !== className) {\n          groupNumber += 1;\n          incrementGroup = false;\n        }\n        className = layerClassName;\n        if (renderer === this) {\n          break;\n        }\n      }\n\n      const canvasCacheKey =\n        'map/' + frameState.mapId + '/group/' + groupNumber;\n\n      if (!this.helper || !this.helper.canvasCacheKeyMatches(canvasCacheKey)) {\n        this.removeHelper();\n\n        this.helper = new WebGLHelper({\n          postProcesses: this.postProcesses_,\n          uniforms: this.uniforms_,\n          canvasCacheKey: canvasCacheKey,\n        });\n\n        if (className) {\n          this.helper.getCanvas().className = className;\n        }\n\n        this.afterHelperCreated();\n      }\n    }\n\n    return this.prepareFrameInternal(frameState);\n  }\n\n  /**\n   * @protected\n   */\n  afterHelperCreated() {}\n\n  /**\n   * Determine whether renderFrame should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   * @protected\n   */\n  prepareFrameInternal(frameState) {\n    return true;\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    this.removeHelper();\n    super.disposeInternal();\n  }\n\n  /**\n   * @param {import(\"../../render/EventType.js\").default} type Event type.\n   * @param {WebGLRenderingContext} context The rendering context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @private\n   */\n  dispatchRenderEvent_(type, context, frameState) {\n    const layer = this.getLayer();\n    if (layer.hasListener(type)) {\n      composeTransform(\n        this.inversePixelTransform_,\n        0,\n        0,\n        frameState.pixelRatio,\n        -frameState.pixelRatio,\n        0,\n        0,\n        -frameState.size[1]\n      );\n\n      const event = new RenderEvent(\n        type,\n        this.inversePixelTransform_,\n        frameState,\n        context\n      );\n      layer.dispatchEvent(event);\n    }\n  }\n\n  /**\n   * @param {WebGLRenderingContext} context The rendering context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  preRender(context, frameState) {\n    this.dispatchRenderEvent_(RenderEventType.PRERENDER, context, frameState);\n  }\n\n  /**\n   * @param {WebGLRenderingContext} context The rendering context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  postRender(context, frameState) {\n    this.dispatchRenderEvent_(RenderEventType.POSTRENDER, context, frameState);\n  }\n}\n\nexport default WebGLLayerRenderer;\n","/**\n * @module ol/render/webgl/constants\n */\n\n/**\n * @enum {string}\n */\nexport const WebGLWorkerMessageType = {\n  GENERATE_POLYGON_BUFFERS: 'GENERATE_POLYGON_BUFFERS',\n  GENERATE_POINT_BUFFERS: 'GENERATE_POINT_BUFFERS',\n  GENERATE_LINE_STRING_BUFFERS: 'GENERATE_LINE_STRING_BUFFERS',\n};\n\n/**\n * @typedef {Object} WebGLWorkerGenerateBuffersMessage\n * This message will trigger the generation of a vertex and an index buffer based on the given render instructions.\n * When the buffers are generated, the worked will send a message of the same type to the main thread, with\n * the generated buffers in it.\n * Note that any addition properties present in the message *will* be sent back to the main thread.\n * @property {number} id Message id; will be used both in request and response as a means of identification\n * @property {WebGLWorkerMessageType} type Message type\n * @property {ArrayBuffer} renderInstructions Polygon render instructions raw binary buffer.\n * @property {number} [customAttributesCount] Amount of custom attributes count in the polygon render instructions.\n * @property {ArrayBuffer} [vertexBuffer] Vertices array raw binary buffer (sent by the worker).\n * @property {ArrayBuffer} [indexBuffer] Indices array raw binary buffer (sent by the worker).\n * @property {import(\"../../transform\").Transform} [renderInstructionsTransform] Transformation matrix used to project the instructions coordinates\n */\n","/**\n * @module ol/render/webgl/utils\n */\nimport earcut from 'earcut';\nimport {apply as applyTransform} from '../../transform.js';\nimport {clamp} from '../../math.js';\n\nconst tmpArray_ = [];\n\n/**\n * An object holding positions both in an index and a vertex buffer.\n * @typedef {Object} BufferPositions\n * @property {number} vertexPosition Position in the vertex buffer\n * @property {number} indexPosition Position in the index buffer\n */\nconst bufferPositions_ = {vertexPosition: 0, indexPosition: 0};\n\nfunction writePointVertex(buffer, pos, x, y, index) {\n  buffer[pos + 0] = x;\n  buffer[pos + 1] = y;\n  buffer[pos + 2] = index;\n}\n\n/**\n * Pushes a quad (two triangles) based on a point geometry\n * @param {Float32Array} instructions Array of render instructions for points.\n * @param {number} elementIndex Index from which render instructions will be read.\n * @param {Float32Array} vertexBuffer Buffer in the form of a typed array.\n * @param {Uint32Array} indexBuffer Buffer in the form of a typed array.\n * @param {number} customAttributesCount Amount of custom attributes for each element.\n * @param {BufferPositions} [bufferPositions] Buffer write positions; if not specified, positions will be set at 0.\n * @return {BufferPositions} New buffer positions where to write next\n * @property {number} vertexPosition New position in the vertex buffer where future writes should start.\n * @property {number} indexPosition New position in the index buffer where future writes should start.\n * @private\n */\nexport function writePointFeatureToBuffers(\n  instructions,\n  elementIndex,\n  vertexBuffer,\n  indexBuffer,\n  customAttributesCount,\n  bufferPositions\n) {\n  // This is for x, y and index\n  const baseVertexAttrsCount = 3;\n  const baseInstructionsCount = 2;\n  const stride = baseVertexAttrsCount + customAttributesCount;\n\n  const x = instructions[elementIndex + 0];\n  const y = instructions[elementIndex + 1];\n\n  // read custom numerical attributes on the feature\n  const customAttrs = tmpArray_;\n  customAttrs.length = customAttributesCount;\n  for (let i = 0; i < customAttrs.length; i++) {\n    customAttrs[i] = instructions[elementIndex + baseInstructionsCount + i];\n  }\n\n  let vPos = bufferPositions ? bufferPositions.vertexPosition : 0;\n  let iPos = bufferPositions ? bufferPositions.indexPosition : 0;\n  const baseIndex = vPos / stride;\n\n  // push vertices for each of the four quad corners (first standard then custom attributes)\n  writePointVertex(vertexBuffer, vPos, x, y, 0);\n  customAttrs.length &&\n    vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n\n  writePointVertex(vertexBuffer, vPos, x, y, 1);\n  customAttrs.length &&\n    vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n\n  writePointVertex(vertexBuffer, vPos, x, y, 2);\n  customAttrs.length &&\n    vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n\n  writePointVertex(vertexBuffer, vPos, x, y, 3);\n  customAttrs.length &&\n    vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n\n  indexBuffer[iPos++] = baseIndex;\n  indexBuffer[iPos++] = baseIndex + 1;\n  indexBuffer[iPos++] = baseIndex + 3;\n  indexBuffer[iPos++] = baseIndex + 1;\n  indexBuffer[iPos++] = baseIndex + 2;\n  indexBuffer[iPos++] = baseIndex + 3;\n\n  bufferPositions_.vertexPosition = vPos;\n  bufferPositions_.indexPosition = iPos;\n\n  return bufferPositions_;\n}\n\n/**\n * Pushes a single quad to form a line segment; also includes a computation for the join angles with previous and next\n * segment, in order to be able to offset the vertices correctly in the shader\n * @param {Float32Array} instructions Array of render instructions for lines.\n * @param {number} segmentStartIndex Index of the segment start point from which render instructions will be read.\n * @param {number} segmentEndIndex Index of the segment start point from which render instructions will be read.\n * @param {number|null} beforeSegmentIndex Index of the point right before the segment (null if none, e.g this is a line start)\n * @param {number|null} afterSegmentIndex Index of the point right after the segment (null if none, e.g this is a line end)\n * @param {Array<number>} vertexArray Array containing vertices.\n * @param {Array<number>} indexArray Array containing indices.\n * @param {Array<number>} customAttributes Array of custom attributes value\n * @param {import('../../transform.js').Transform} instructionsTransform Transform matrix used to project coordinates in instructions\n * @param {import('../../transform.js').Transform} invertInstructionsTransform Transform matrix used to project coordinates in instructions\n * @private\n */\nexport function writeLineSegmentToBuffers(\n  instructions,\n  segmentStartIndex,\n  segmentEndIndex,\n  beforeSegmentIndex,\n  afterSegmentIndex,\n  vertexArray,\n  indexArray,\n  customAttributes,\n  instructionsTransform,\n  invertInstructionsTransform\n) {\n  // compute the stride to determine how many vertices were already pushed\n  const baseVertexAttrsCount = 5; // base attributes: x0, y0, x1, y1, params (vertex number [0-3], join angle 1, join angle 2)\n  const stride = baseVertexAttrsCount + customAttributes.length;\n  const baseIndex = vertexArray.length / stride;\n\n  // The segment is composed of two positions called P0[x0, y0] and P1[x1, y1]\n  // Depending on whether there are points before and after the segment, its final shape\n  // will be different\n  const p0 = [\n    instructions[segmentStartIndex + 0],\n    instructions[segmentStartIndex + 1],\n  ];\n  const p1 = [instructions[segmentEndIndex], instructions[segmentEndIndex + 1]];\n\n  // to compute offsets from the line center we need to reproject\n  // coordinates back in world units and compute the length of the segment\n  const p0world = applyTransform(invertInstructionsTransform, [...p0]);\n  const p1world = applyTransform(invertInstructionsTransform, [...p1]);\n\n  function computeVertexParameters(vertexNumber, joinAngle1, joinAngle2) {\n    const shift = 10000;\n    const anglePrecision = 1500;\n    return (\n      Math.round(joinAngle1 * anglePrecision) +\n      Math.round(joinAngle2 * anglePrecision) * shift +\n      vertexNumber * shift * shift\n    );\n  }\n\n  // compute the angle between p0pA and p0pB\n  // returns a value in [0, 2PI]\n  function angleBetween(p0, pA, pB) {\n    const lenA = Math.sqrt(\n      (pA[0] - p0[0]) * (pA[0] - p0[0]) + (pA[1] - p0[1]) * (pA[1] - p0[1])\n    );\n    const tangentA = [(pA[0] - p0[0]) / lenA, (pA[1] - p0[1]) / lenA];\n    const orthoA = [-tangentA[1], tangentA[0]];\n    const lenB = Math.sqrt(\n      (pB[0] - p0[0]) * (pB[0] - p0[0]) + (pB[1] - p0[1]) * (pB[1] - p0[1])\n    );\n    const tangentB = [(pB[0] - p0[0]) / lenB, (pB[1] - p0[1]) / lenB];\n\n    // this angle can be clockwise or anticlockwise; hence the computation afterwards\n    const angle =\n      lenA === 0 || lenB === 0\n        ? 0\n        : Math.acos(\n            clamp(tangentB[0] * tangentA[0] + tangentB[1] * tangentA[1], -1, 1)\n          );\n    const isClockwise = tangentB[0] * orthoA[0] + tangentB[1] * orthoA[1] > 0;\n    return !isClockwise ? Math.PI * 2 - angle : angle;\n  }\n\n  const joinBefore = beforeSegmentIndex !== null;\n  const joinAfter = afterSegmentIndex !== null;\n\n  let angle0 = 0;\n  let angle1 = 0;\n\n  // add vertices and adapt offsets for P0 in case of join\n  if (joinBefore) {\n    // B for before\n    const pB = [\n      instructions[beforeSegmentIndex],\n      instructions[beforeSegmentIndex + 1],\n    ];\n    const pBworld = applyTransform(invertInstructionsTransform, [...pB]);\n    angle0 = angleBetween(p0world, p1world, pBworld);\n  }\n  // adapt offsets for P1 in case of join\n  if (joinAfter) {\n    // A for after\n    const pA = [\n      instructions[afterSegmentIndex],\n      instructions[afterSegmentIndex + 1],\n    ];\n    const pAworld = applyTransform(invertInstructionsTransform, [...pA]);\n    angle1 = angleBetween(p1world, p0world, pAworld);\n  }\n\n  // add main segment triangles\n  vertexArray.push(\n    p0[0],\n    p0[1],\n    p1[0],\n    p1[1],\n    computeVertexParameters(0, angle0, angle1)\n  );\n  vertexArray.push(...customAttributes);\n\n  vertexArray.push(\n    p0[0],\n    p0[1],\n    p1[0],\n    p1[1],\n    computeVertexParameters(1, angle0, angle1)\n  );\n  vertexArray.push(...customAttributes);\n\n  vertexArray.push(\n    p0[0],\n    p0[1],\n    p1[0],\n    p1[1],\n    computeVertexParameters(2, angle0, angle1)\n  );\n  vertexArray.push(...customAttributes);\n\n  vertexArray.push(\n    p0[0],\n    p0[1],\n    p1[0],\n    p1[1],\n    computeVertexParameters(3, angle0, angle1)\n  );\n  vertexArray.push(...customAttributes);\n\n  indexArray.push(\n    baseIndex,\n    baseIndex + 1,\n    baseIndex + 2,\n    baseIndex + 1,\n    baseIndex + 3,\n    baseIndex + 2\n  );\n}\n\n/**\n * Pushes several triangles to form a polygon, including holes\n * @param {Float32Array} instructions Array of render instructions for lines.\n * @param {number} polygonStartIndex Index of the polygon start point from which render instructions will be read.\n * @param {Array<number>} vertexArray Array containing vertices.\n * @param {Array<number>} indexArray Array containing indices.\n * @param {number} customAttributesCount Amount of custom attributes for each element.\n * @return {number} Next polygon instructions index\n * @private\n */\nexport function writePolygonTrianglesToBuffers(\n  instructions,\n  polygonStartIndex,\n  vertexArray,\n  indexArray,\n  customAttributesCount\n) {\n  const instructionsPerVertex = 2; // x, y\n  const attributesPerVertex = 2 + customAttributesCount;\n  let instructionsIndex = polygonStartIndex;\n  const customAttributes = instructions.slice(\n    instructionsIndex,\n    instructionsIndex + customAttributesCount\n  );\n  instructionsIndex += customAttributesCount;\n  const ringsCount = instructions[instructionsIndex++];\n  let verticesCount = 0;\n  const holes = new Array(ringsCount - 1);\n  for (let i = 0; i < ringsCount; i++) {\n    verticesCount += instructions[instructionsIndex++];\n    if (i < ringsCount - 1) {\n      holes[i] = verticesCount;\n    }\n  }\n  const flatCoords = instructions.slice(\n    instructionsIndex,\n    instructionsIndex + verticesCount * instructionsPerVertex\n  );\n\n  // pushing to vertices and indices!! this is where the magic happens\n  const result = earcut(flatCoords, holes, instructionsPerVertex);\n  for (let i = 0; i < result.length; i++) {\n    indexArray.push(result[i] + vertexArray.length / attributesPerVertex);\n  }\n  for (let i = 0; i < flatCoords.length; i += 2) {\n    vertexArray.push(flatCoords[i], flatCoords[i + 1], ...customAttributes);\n  }\n\n  return instructionsIndex + verticesCount * instructionsPerVertex;\n}\n\n/**\n * Returns a texture of 1x1 pixel, white\n * @private\n * @return {ImageData} Image data.\n */\nexport function getBlankImageData() {\n  const canvas = document.createElement('canvas');\n  const image = canvas.getContext('2d').createImageData(1, 1);\n  image.data[0] = 255;\n  image.data[1] = 255;\n  image.data[2] = 255;\n  image.data[3] = 255;\n  return image;\n}\n\n/**\n * Generates a color array based on a numerical id\n * Note: the range for each component is 0 to 1 with 256 steps\n * @param {number} id Id\n * @param {Array<number>} [array] Reusable array\n * @return {Array<number>} Color array containing the encoded id\n */\nexport function colorEncodeId(id, array) {\n  array = array || [];\n  const radix = 256;\n  const divide = radix - 1;\n  array[0] = Math.floor(id / radix / radix / radix) / divide;\n  array[1] = (Math.floor(id / radix / radix) % radix) / divide;\n  array[2] = (Math.floor(id / radix) % radix) / divide;\n  array[3] = (id % radix) / divide;\n  return array;\n}\n\n/**\n * Reads an id from a color-encoded array\n * Note: the expected range for each component is 0 to 1 with 256 steps.\n * @param {Array<number>} color Color array containing the encoded id\n * @return {number} Decoded id\n */\nexport function colorDecodeId(color) {\n  let id = 0;\n  const radix = 256;\n  const mult = radix - 1;\n  id += Math.round(color[0] * radix * radix * radix * mult);\n  id += Math.round(color[1] * radix * radix * mult);\n  id += Math.round(color[2] * radix * mult);\n  id += Math.round(color[3] * mult);\n  return id;\n}\n","/**\n * @module ol/renderer/webgl/PointsLayer\n */\nimport BaseVector from '../../layer/BaseVector.js';\nimport VectorEventType from '../../source/VectorEventType.js';\nimport ViewHint from '../../ViewHint.js';\nimport WebGLArrayBuffer from '../../webgl/Buffer.js';\nimport WebGLLayerRenderer from './Layer.js';\nimport WebGLRenderTarget from '../../webgl/RenderTarget.js';\nimport {ARRAY_BUFFER, DYNAMIC_DRAW, ELEMENT_ARRAY_BUFFER} from '../../webgl.js';\nimport {AttributeType, DefaultUniform} from '../../webgl/Helper.js';\nimport {WebGLWorkerMessageType} from '../../render/webgl/constants.js';\nimport {\n  apply as applyTransform,\n  create as createTransform,\n  makeInverse as makeInverseTransform,\n  multiply as multiplyTransform,\n  translate as translateTransform,\n} from '../../transform.js';\nimport {assert} from '../../asserts.js';\nimport {buffer, createEmpty, equals, getWidth} from '../../extent.js';\nimport {colorDecodeId, colorEncodeId} from '../../render/webgl/utils.js';\nimport {create as createWebGLWorker} from '../../worker/webgl.js';\nimport {getUid} from '../../util.js';\nimport {listen, unlistenByKey} from '../../events.js';\n\n/**\n * @typedef {Object} CustomAttribute A description of a custom attribute to be passed on to the GPU, with a value different\n * for each feature.\n * @property {string} name Attribute name.\n * @property {function(import(\"../../Feature\").default, Object<string, *>):number} callback This callback computes the numerical value of the\n * attribute for a given feature (properties are available as 2nd arg for quicker access).\n */\n\n/**\n * @typedef {Object} FeatureCacheItem Object that holds a reference to a feature, its geometry and properties. Used to optimize\n * rebuildBuffers by accessing these objects quicker.\n * @property {import(\"../../Feature\").default} feature Feature\n * @property {Object<string, *>} properties Feature properties\n * @property {import(\"../../geom\").Geometry} geometry Feature geometry\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the canvas element.\n * @property {Array<CustomAttribute>} [attributes] These attributes will be read from the features in the source and then\n * passed to the GPU. The `name` property of each attribute will serve as its identifier:\n *  * In the vertex shader as an `attribute` by prefixing it with `a_`\n *  * In the fragment shader as a `varying` by prefixing it with `v_`\n * Please note that these can only be numerical values.\n * @property {string} vertexShader Vertex shader source, mandatory.\n * @property {string} fragmentShader Fragment shader source, mandatory.\n * @property {string} [hitVertexShader] Vertex shader source for hit detection rendering.\n * @property {string} [hitFragmentShader] Fragment shader source for hit detection rendering.\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process steps\n * Please note that `u_texture` is reserved for the main texture slot and `u_opacity` is reserved for the layer opacity.\n * @property {Array<import(\"./Layer\").PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n\n/**\n * @classdesc\n * WebGL vector renderer optimized for points.\n * All features will be rendered as quads (two triangles forming a square). New data will be flushed to the GPU\n * every time the vector source changes.\n *\n * You need to provide vertex and fragment shaders for rendering. This can be done using\n * {@link module:ol/webgl/ShaderBuilder~ShaderBuilder} utilities. These shaders shall expect a `a_position` attribute\n * containing the screen-space projected center of the quad, as well as a `a_index` attribute\n * whose value (0, 1, 2 or 3) indicates which quad vertex is currently getting processed (see structure below).\n *\n * To include variable attributes in the shaders, you need to declare them using the `attributes` property of\n * the options object like so:\n * ```js\n * new WebGLPointsLayerRenderer(layer, {\n *   attributes: [\n *     {\n *       name: 'size',\n *       callback: function(feature) {\n *         // compute something with the feature\n *       }\n *     },\n *     {\n *       name: 'weight',\n *       callback: function(feature) {\n *         // compute something with the feature\n *       }\n *     },\n *   ],\n *   vertexShader:\n *     // shader using attribute a_weight and a_size\n *   fragmentShader:\n *     // shader using varying v_weight and v_size\n * ```\n *\n * To enable hit detection, you must as well provide dedicated shaders using the `hitVertexShader`\n * and `hitFragmentShader` properties. These shall expect the `a_hitColor` attribute to contain\n * the final color that will have to be output for hit detection to work.\n *\n * The following uniform is used for the main texture: `u_texture`.\n * The following uniform is used for the layer opacity: `u_opacity`.\n *\n * Please note that the main shader output should have premultiplied alpha, otherwise visual anomalies may occur.\n *\n * Points are rendered as quads with the following structure:\n *\n * ```\n *   (u0, v1)      (u1, v1)\n *  [3]----------[2]\n *   |`           |\n *   |  `         |\n *   |    `       |\n *   |      `     |\n *   |        `   |\n *   |          ` |\n *  [0]----------[1]\n *   (u0, v0)      (u1, v0)\n *  ```\n *\n * This uses {@link module:ol/webgl/Helper~WebGLHelper} internally.\n *\n * @api\n */\nclass WebGLPointsLayerRenderer extends WebGLLayerRenderer {\n  /**\n   * @param {import(\"../../layer/Layer.js\").default} layer Layer.\n   * @param {Options} options Options.\n   */\n  constructor(layer, options) {\n    const uniforms = options.uniforms || {};\n    const projectionMatrixTransform = createTransform();\n    uniforms[DefaultUniform.PROJECTION_MATRIX] = projectionMatrixTransform;\n\n    super(layer, {\n      uniforms: uniforms,\n      postProcesses: options.postProcesses,\n    });\n\n    this.ready = false;\n\n    this.sourceRevision_ = -1;\n\n    this.verticesBuffer_ = new WebGLArrayBuffer(ARRAY_BUFFER, DYNAMIC_DRAW);\n    this.hitVerticesBuffer_ = new WebGLArrayBuffer(ARRAY_BUFFER, DYNAMIC_DRAW);\n    this.indicesBuffer_ = new WebGLArrayBuffer(\n      ELEMENT_ARRAY_BUFFER,\n      DYNAMIC_DRAW\n    );\n\n    /**\n     * @private\n     */\n    this.vertexShader_ = options.vertexShader;\n\n    /**\n     * @private\n     */\n    this.fragmentShader_ = options.fragmentShader;\n\n    /**\n     * @type {WebGLProgram}\n     * @private\n     */\n    this.program_;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hitDetectionEnabled_ =\n      options.hitFragmentShader && options.hitVertexShader ? true : false;\n\n    /**\n     * @private\n     */\n    this.hitVertexShader_ = options.hitVertexShader;\n\n    /**\n     * @private\n     */\n    this.hitFragmentShader_ = options.hitFragmentShader;\n\n    /**\n     * @type {WebGLProgram}\n     * @private\n     */\n    this.hitProgram_;\n\n    const customAttributes = options.attributes\n      ? options.attributes.map(function (attribute) {\n          return {\n            name: 'a_' + attribute.name,\n            size: 1,\n            type: AttributeType.FLOAT,\n          };\n        })\n      : [];\n\n    /**\n     * A list of attributes used by the renderer. By default only the position and\n     * index of the vertex (0 to 3) are required.\n     * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n     */\n    this.attributes = [\n      {\n        name: 'a_position',\n        size: 2,\n        type: AttributeType.FLOAT,\n      },\n      {\n        name: 'a_index',\n        size: 1,\n        type: AttributeType.FLOAT,\n      },\n    ].concat(customAttributes);\n\n    /**\n     * A list of attributes used for hit detection.\n     * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n     */\n    this.hitDetectionAttributes = [\n      {\n        name: 'a_position',\n        size: 2,\n        type: AttributeType.FLOAT,\n      },\n      {\n        name: 'a_index',\n        size: 1,\n        type: AttributeType.FLOAT,\n      },\n      {\n        name: 'a_hitColor',\n        size: 4,\n        type: AttributeType.FLOAT,\n      },\n      {\n        name: 'a_featureUid',\n        size: 1,\n        type: AttributeType.FLOAT,\n      },\n    ].concat(customAttributes);\n\n    this.customAttributes = options.attributes ? options.attributes : [];\n\n    this.previousExtent_ = createEmpty();\n\n    /**\n     * This transform is updated on every frame and is the composition of:\n     * - invert of the world->screen transform that was used when rebuilding buffers (see `this.renderTransform_`)\n     * - current world->screen transform\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.currentTransform_ = projectionMatrixTransform;\n\n    /**\n     * This transform is updated when buffers are rebuilt and converts world space coordinates to screen space\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.renderTransform_ = createTransform();\n\n    /**\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.invertRenderTransform_ = createTransform();\n\n    /**\n     * @type {Float32Array}\n     * @private\n     */\n    this.renderInstructions_ = new Float32Array(0);\n\n    /**\n     * These instructions are used for hit detection\n     * @type {Float32Array}\n     * @private\n     */\n    this.hitRenderInstructions_ = new Float32Array(0);\n\n    /**\n     * @type {WebGLRenderTarget}\n     * @private\n     */\n    this.hitRenderTarget_;\n\n    /**\n     * Keep track of latest message sent to worker\n     * @type {number}\n     * @private\n     */\n    this.generateBuffersRun_ = 0;\n\n    /**\n     * @private\n     */\n    this.worker_ = createWebGLWorker();\n\n    this.worker_.addEventListener(\n      'message',\n      /**\n       * @param {*} event Event.\n       */\n      (event) => {\n        const received = event.data;\n        if (received.type === WebGLWorkerMessageType.GENERATE_POINT_BUFFERS) {\n          const projectionTransform = received.projectionTransform;\n          if (received.hitDetection) {\n            this.hitVerticesBuffer_.fromArrayBuffer(received.vertexBuffer);\n            this.helper.flushBufferData(this.hitVerticesBuffer_);\n          } else {\n            this.verticesBuffer_.fromArrayBuffer(received.vertexBuffer);\n            this.helper.flushBufferData(this.verticesBuffer_);\n          }\n          this.indicesBuffer_.fromArrayBuffer(received.indexBuffer);\n          this.helper.flushBufferData(this.indicesBuffer_);\n\n          this.renderTransform_ = projectionTransform;\n          makeInverseTransform(\n            this.invertRenderTransform_,\n            this.renderTransform_\n          );\n          if (received.hitDetection) {\n            this.hitRenderInstructions_ = new Float32Array(\n              event.data.renderInstructions\n            );\n          } else {\n            this.renderInstructions_ = new Float32Array(\n              event.data.renderInstructions\n            );\n            if (received.generateBuffersRun === this.generateBuffersRun_) {\n              this.ready = true;\n            }\n          }\n\n          this.getLayer().changed();\n        }\n      }\n    );\n\n    /**\n     * This object will be updated when the source changes. Key is uid.\n     * @type {Object<string, FeatureCacheItem>}\n     * @private\n     */\n    this.featureCache_ = {};\n\n    /**\n     * Amount of features in the cache.\n     * @type {number}\n     * @private\n     */\n    this.featureCount_ = 0;\n\n    const source = this.getLayer().getSource();\n    this.sourceListenKeys_ = [\n      listen(\n        source,\n        VectorEventType.ADDFEATURE,\n        this.handleSourceFeatureAdded_,\n        this\n      ),\n      listen(\n        source,\n        VectorEventType.CHANGEFEATURE,\n        this.handleSourceFeatureChanged_,\n        this\n      ),\n      listen(\n        source,\n        VectorEventType.REMOVEFEATURE,\n        this.handleSourceFeatureDelete_,\n        this\n      ),\n      listen(\n        source,\n        VectorEventType.CLEAR,\n        this.handleSourceFeatureClear_,\n        this\n      ),\n    ];\n    source.forEachFeature((feature) => {\n      this.featureCache_[getUid(feature)] = {\n        feature: feature,\n        properties: feature.getProperties(),\n        geometry: feature.getGeometry(),\n      };\n      this.featureCount_++;\n    });\n  }\n\n  afterHelperCreated() {\n    this.program_ = this.helper.getProgram(\n      this.fragmentShader_,\n      this.vertexShader_\n    );\n\n    if (this.hitDetectionEnabled_) {\n      this.hitProgram_ = this.helper.getProgram(\n        this.hitFragmentShader_,\n        this.hitVertexShader_\n      );\n\n      this.hitRenderTarget_ = new WebGLRenderTarget(this.helper);\n    }\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureAdded_(event) {\n    const feature = event.feature;\n    this.featureCache_[getUid(feature)] = {\n      feature: feature,\n      properties: feature.getProperties(),\n      geometry: feature.getGeometry(),\n    };\n    this.featureCount_++;\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureChanged_(event) {\n    const feature = event.feature;\n    this.featureCache_[getUid(feature)] = {\n      feature: feature,\n      properties: feature.getProperties(),\n      geometry: feature.getGeometry(),\n    };\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureDelete_(event) {\n    const feature = event.feature;\n    delete this.featureCache_[getUid(feature)];\n    this.featureCount_--;\n  }\n\n  /**\n   * @private\n   */\n  handleSourceFeatureClear_() {\n    this.featureCache_ = {};\n    this.featureCount_ = 0;\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState) {\n    const gl = this.helper.getGL();\n    this.preRender(gl, frameState);\n\n    const projection = frameState.viewState.projection;\n    const layer = this.getLayer();\n    const vectorSource = layer.getSource();\n    // FIXME fix hit detection isn't reliable when rendering multiple worlds\n    const multiWorld = vectorSource.getWrapX() && projection.canWrapX();\n    const projectionExtent = projection.getExtent();\n\n    const extent = frameState.extent;\n    const worldWidth = multiWorld ? getWidth(projectionExtent) : null;\n    const endWorld = multiWorld\n      ? Math.ceil((extent[2] - projectionExtent[2]) / worldWidth) + 1\n      : 1;\n\n    const startWorld = multiWorld\n      ? Math.floor((extent[0] - projectionExtent[0]) / worldWidth)\n      : 0;\n\n    let world = startWorld;\n    const renderCount = this.indicesBuffer_.getSize();\n\n    do {\n      // apply the current projection transform with the invert of the one used to fill buffers\n      this.helper.makeProjectionTransform(frameState, this.currentTransform_);\n      translateTransform(this.currentTransform_, world * worldWidth, 0);\n      multiplyTransform(this.currentTransform_, this.invertRenderTransform_);\n      this.helper.applyUniforms(frameState);\n\n      this.helper.drawElements(0, renderCount);\n    } while (++world < endWorld);\n\n    this.helper.finalizeDraw(\n      frameState,\n      this.dispatchPreComposeEvent,\n      this.dispatchPostComposeEvent\n    );\n    const canvas = this.helper.getCanvas();\n\n    if (this.hitDetectionEnabled_) {\n      this.renderHitDetection(frameState, startWorld, endWorld, worldWidth);\n      this.hitRenderTarget_.clearCachedData();\n    }\n\n    this.postRender(gl, frameState);\n\n    return canvas;\n  }\n\n  /**\n   * Determine whether renderFrame should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrameInternal(frameState) {\n    const layer = this.getLayer();\n    const vectorSource = layer.getSource();\n    const viewState = frameState.viewState;\n    const viewNotMoving =\n      !frameState.viewHints[ViewHint.ANIMATING] &&\n      !frameState.viewHints[ViewHint.INTERACTING];\n    const extentChanged = !equals(this.previousExtent_, frameState.extent);\n    const sourceChanged = this.sourceRevision_ < vectorSource.getRevision();\n\n    if (sourceChanged) {\n      this.sourceRevision_ = vectorSource.getRevision();\n    }\n\n    if (viewNotMoving && (extentChanged || sourceChanged)) {\n      const projection = viewState.projection;\n      const resolution = viewState.resolution;\n\n      const renderBuffer =\n        layer instanceof BaseVector ? layer.getRenderBuffer() : 0;\n      const extent = buffer(frameState.extent, renderBuffer * resolution);\n      vectorSource.loadFeatures(extent, resolution, projection);\n\n      this.rebuildBuffers_(frameState);\n      this.previousExtent_ = frameState.extent.slice();\n    }\n\n    this.helper.useProgram(this.program_, frameState);\n    this.helper.prepareDraw(frameState);\n\n    // write new data\n    this.helper.bindBuffer(this.verticesBuffer_);\n    this.helper.bindBuffer(this.indicesBuffer_);\n    this.helper.enableAttributes(this.attributes);\n\n    return true;\n  }\n\n  /**\n   * Rebuild internal webgl buffers based on current view extent; costly, should not be called too much\n   * @param {import(\"../../Map\").FrameState} frameState Frame state.\n   * @private\n   */\n  rebuildBuffers_(frameState) {\n    // saves the projection transform for the current frame state\n    const projectionTransform = createTransform();\n    this.helper.makeProjectionTransform(frameState, projectionTransform);\n\n    // here we anticipate the amount of render instructions that we well generate\n    // this can be done since we know that for normal render we only have x, y as base instructions,\n    // and x, y, r, g, b, a and featureUid for hit render instructions\n    // and we also know the amount of custom attributes to append to these\n    const totalInstructionsCount =\n      (2 + this.customAttributes.length) * this.featureCount_;\n    if (\n      !this.renderInstructions_ ||\n      this.renderInstructions_.length !== totalInstructionsCount\n    ) {\n      this.renderInstructions_ = new Float32Array(totalInstructionsCount);\n    }\n    if (this.hitDetectionEnabled_) {\n      const totalHitInstructionsCount =\n        (7 + this.customAttributes.length) * this.featureCount_;\n      if (\n        !this.hitRenderInstructions_ ||\n        this.hitRenderInstructions_.length !== totalHitInstructionsCount\n      ) {\n        this.hitRenderInstructions_ = new Float32Array(\n          totalHitInstructionsCount\n        );\n      }\n    }\n\n    // loop on features to fill the buffer\n    let featureCache, geometry;\n    const tmpCoords = [];\n    const tmpColor = [];\n    let renderIndex = 0;\n    let hitIndex = 0;\n    let hitColor;\n    for (const featureUid in this.featureCache_) {\n      featureCache = this.featureCache_[featureUid];\n      geometry = /** @type {import(\"../../geom\").Point} */ (\n        featureCache.geometry\n      );\n      if (!geometry || geometry.getType() !== 'Point') {\n        continue;\n      }\n\n      tmpCoords[0] = geometry.getFlatCoordinates()[0];\n      tmpCoords[1] = geometry.getFlatCoordinates()[1];\n      applyTransform(projectionTransform, tmpCoords);\n\n      hitColor = colorEncodeId(hitIndex + 6, tmpColor);\n\n      this.renderInstructions_[renderIndex++] = tmpCoords[0];\n      this.renderInstructions_[renderIndex++] = tmpCoords[1];\n\n      // for hit detection, the feature uid is saved in the opacity value\n      // and the index of the opacity value is encoded in the color values\n      if (this.hitDetectionEnabled_) {\n        this.hitRenderInstructions_[hitIndex++] = tmpCoords[0];\n        this.hitRenderInstructions_[hitIndex++] = tmpCoords[1];\n        this.hitRenderInstructions_[hitIndex++] = hitColor[0];\n        this.hitRenderInstructions_[hitIndex++] = hitColor[1];\n        this.hitRenderInstructions_[hitIndex++] = hitColor[2];\n        this.hitRenderInstructions_[hitIndex++] = hitColor[3];\n        this.hitRenderInstructions_[hitIndex++] = Number(featureUid);\n      }\n\n      // pushing custom attributes\n      let value;\n      for (let j = 0; j < this.customAttributes.length; j++) {\n        value = this.customAttributes[j].callback(\n          featureCache.feature,\n          featureCache.properties\n        );\n        this.renderInstructions_[renderIndex++] = value;\n        if (this.hitDetectionEnabled_) {\n          this.hitRenderInstructions_[hitIndex++] = value;\n        }\n      }\n    }\n\n    /** @type {import('../../render/webgl/constants.js').WebGLWorkerGenerateBuffersMessage} */\n    const message = {\n      id: 0,\n      type: WebGLWorkerMessageType.GENERATE_POINT_BUFFERS,\n      renderInstructions: this.renderInstructions_.buffer,\n      customAttributesCount: this.customAttributes.length,\n    };\n    // additional properties will be sent back as-is by the worker\n    message['projectionTransform'] = projectionTransform;\n    message['generateBuffersRun'] = ++this.generateBuffersRun_;\n    this.ready = false;\n    this.worker_.postMessage(message, [this.renderInstructions_.buffer]);\n    this.renderInstructions_ = null;\n\n    /** @type {import('../../render/webgl/constants.js').WebGLWorkerGenerateBuffersMessage} */\n    if (this.hitDetectionEnabled_) {\n      const hitMessage = {\n        id: 0,\n        type: WebGLWorkerMessageType.GENERATE_POINT_BUFFERS,\n        renderInstructions: this.hitRenderInstructions_.buffer,\n        customAttributesCount: 5 + this.customAttributes.length,\n      };\n      hitMessage['projectionTransform'] = projectionTransform;\n      hitMessage['hitDetection'] = true;\n      this.worker_.postMessage(hitMessage, [\n        this.hitRenderInstructions_.buffer,\n      ]);\n      this.hitRenderInstructions_ = null;\n    }\n  }\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches\n  ) {\n    assert(this.hitDetectionEnabled_, 66);\n    if (!this.hitRenderInstructions_) {\n      return undefined;\n    }\n\n    const pixel = applyTransform(\n      frameState.coordinateToPixelTransform,\n      coordinate.slice()\n    );\n\n    const data = this.hitRenderTarget_.readPixel(pixel[0] / 2, pixel[1] / 2);\n    const color = [data[0] / 255, data[1] / 255, data[2] / 255, data[3] / 255];\n    const index = colorDecodeId(color);\n    const opacity = this.hitRenderInstructions_[index];\n    const uid = Math.floor(opacity).toString();\n\n    const source = this.getLayer().getSource();\n    const feature = source.getFeatureByUid(uid);\n    if (feature) {\n      return callback(feature, this.getLayer(), null);\n    }\n    return undefined;\n  }\n\n  /**\n   * Render the hit detection data to the corresponding render target\n   * @param {import(\"../../Map.js\").FrameState} frameState current frame state\n   * @param {number} startWorld the world to render in the first iteration\n   * @param {number} endWorld the last world to render\n   * @param {number} worldWidth the width of the worlds being rendered\n   */\n  renderHitDetection(frameState, startWorld, endWorld, worldWidth) {\n    // skip render entirely if vertex buffers not ready/generated yet\n    if (!this.hitVerticesBuffer_.getSize()) {\n      return;\n    }\n\n    let world = startWorld;\n\n    this.hitRenderTarget_.setSize([\n      Math.floor(frameState.size[0] / 2),\n      Math.floor(frameState.size[1] / 2),\n    ]);\n\n    this.helper.useProgram(this.hitProgram_, frameState);\n    this.helper.prepareDrawToRenderTarget(\n      frameState,\n      this.hitRenderTarget_,\n      true\n    );\n\n    this.helper.bindBuffer(this.hitVerticesBuffer_);\n    this.helper.bindBuffer(this.indicesBuffer_);\n    this.helper.enableAttributes(this.hitDetectionAttributes);\n\n    do {\n      this.helper.makeProjectionTransform(frameState, this.currentTransform_);\n      translateTransform(this.currentTransform_, world * worldWidth, 0);\n      multiplyTransform(this.currentTransform_, this.invertRenderTransform_);\n      this.helper.applyUniforms(frameState);\n\n      const renderCount = this.indicesBuffer_.getSize();\n      this.helper.drawElements(0, renderCount);\n    } while (++world < endWorld);\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    this.worker_.terminate();\n    this.layer_ = null;\n    this.sourceListenKeys_.forEach(function (key) {\n      unlistenByKey(key);\n    });\n    this.sourceListenKeys_ = null;\n    super.disposeInternal();\n  }\n}\n\nexport default WebGLPointsLayerRenderer;\n"],"names":["MapRenderer","Disposable","constructor","map","super","this","map_","dispatchRenderEvent","type","frameState","calculateMatrices2D","viewState","coordinateToPixelTransform","pixelToCoordinateTransform","size","resolution","rotation","center","forEachFeatureAtCoordinate","coordinate","hitTolerance","checkWrapped","callback","thisArg","layerFilter","thisArg2","result","managed","feature","layer","geometry","call","projection","translatedCoordinate","slice","offsets","canWrapX","projectionExtent","getExtent","worldWidth","push","layerStates","layerStatesArray","numLayers","length","matches","tmpCoord","i","j","layerState","hasRenderer","layerRenderer","getRenderer","source","getSource","coordinates","getWrapX","bind","order","forEach","m","distanceSq","sort","a","b","some","hasFeatureAtCoordinate","hasFeature","undefined","getMap","renderFrame","scheduleExpireIconCache","postRenderFunctions","expireIconCache","CompositeMapRenderer","Map","fontChangeListenerKey_","ObjectEventType","redrawText","element_","document","createElement","style","position","width","height","zIndex","className","container","getViewport","insertBefore","firstChild","children_","renderedVisible_","hasListener","event","dispatchEvent","disposeInternal","parentNode","removeChild","display","declutterLayers","previousElement","ii","layerIndex","sourceState","getSourceState","unrender","element","render","renderDeclutter","LayerRenderer","ready","boundHandleImageChange_","handleImageChange_","layer_","declutterExecutorGroup","getFeatures","pixel","getData","prepareFrame","target","loadedTileCallback","tiles","zoom","tile","tileCoord","toString","createLoadedTileFinder","tileRange","forEachLoadedTile","getLayer","handleFontsChanged","image","getState","renderIfReadyAndVisible","loadImage","imageState","addEventListener","load","getVisible","changed","CanvasImageLayerRenderer","imageLayer","image_","getImage","pixelRatio","viewResolution","imageSource","hints","viewHints","renderedExtent","extent","fromUserExtent","layerExtent","imageExtent","img","imageMapWidth","col","Math","floor","imageMapHeight","row","getImageData","imageResolution","getResolution","imagePixelRatio","getPixelRatio","viewCenter","scale","round","pixelTransform","inversePixelTransform","canvasTransform","useContainer","getBackground","context","canvas","containerReused","clearRect","clipped","clipUnrotated","transform","tempTransform","renderedResolution","dw","dh","getInterpolate","imageSmoothingEnabled","preRender","dx","dy","opacity","previousAlpha","globalAlpha","drawImage","postRender","restore","canvasPool","pixelContext","createPixelContext","willReadFrequently","CanvasLayerRenderer","pixelContext_","data","err","background","backgroundColor","layerClassName","getClassName","firstElementChild","HTMLCanvasElement","getContext","appendChild","left","transformOrigin","topLeft","topRight","bottomRight","bottomLeft","inverted","save","beginPath","moveTo","lineTo","clip","dispatchRenderEvent_","getRenderTransform","offsetX","dx1","dy1","sx","sy","dx2","dy2","CanvasTileLayerRenderer","tileLayer","extentChanged","renderedExtent_","renderedPixelRatio","renderedProjection","renderedRevision","renderedTiles","newTiles_","tmpExtent","tmpTileRange_","isDrawableTile","tileState","useInterimTilesOnError","getUseInterimTilesOnError","getTile","z","x","y","tileSource","getPreload","getInterimTile","getRenderSource","tileGrid","getTileGridForProjection","tilePixelRatio","getTilePixelRatio","getZForResolution","getMinZoom","getTileCoordForCoordAndZ","tileOrigin","getOrigin","tileSize","getTileSize","tileResolution","gutter","getGutterForProjection","sourceRevision","getRevision","zDirection","canvasExtent","getTileRangeForExtentAndZ","tilesToDrawByZ","findLoadedTiles","tmpTileRange","viewport","minX","maxX","minY","maxY","tileCoordIntersectsViewport","uid","inTransition","endTransition","includes","getAlpha","time","childTileRange","getTileCoordChildTileRange","covered","forEachTileCoordParentTileRange","canvasScale","clips","clipZs","currentClip","zs","Object","keys","Number","getOpaque","reverse","currentZ","currentTilePixelSize","getTilePixelSize","currentResolution","currentScale","originTileCoord","originTileExtent","getTileCoordExtent","origin","tileGutter","tilesToDraw","tileCoordKey","xIndex","nextX","yIndex","nextY","w","h","transition","contextSaved","drawTileImage","unshift","updateUsedTiles","usedTiles","manageTilePyramid","scheduleExpireCache","getTileImage","alpha","alphaChanged","animate","canExpireCache","postRenderFunction","tileSourceKey","expireCache","getKey","preload","tileCallback","wantedTiles","tileQueue","minZoom","tileCount","isKeyQueued","enqueue","getTileCoordCenter","useTile","updateCacheSize","CanvasVectorLayerRenderer","vectorLayer","boundHandleStyleImageChange_","handleStyleImageChange_","animatingOrInteracting_","hitDetectionImageData_","renderedFeatures_","renderedRevision_","renderedResolution_","NaN","wrappedRenderedExtent_","renderedRotation_","renderedCenter_","renderedProjection_","renderedRenderOrder_","replayGroup_","replayGroupChanged","clipping","compositionContext_","opacity_","renderWorlds","executorGroup","declutterTree","vectorSource","snapToPixel","multiWorld","endWorld","ceil","world","execute","setupCompositionContext_","compositionContext","releaseCompositionContext_","replayGroup","isEmpty","Promise","resolve","transforms","startX","getStyleFunction","features","featureCallback","key","match","splice","lastIndexOf","executorGroups","all","item","value","animating","interacting","updateWhileAnimating","getUpdateWhileAnimating","updateWhileInteracting","getUpdateWhileInteracting","frameStateExtent","vectorLayerRevision","vectorLayerRenderBuffer","getRenderBuffer","vectorLayerRenderOrder","getRenderOrder","loadExtents","max","loadExtent","declutterBuilderGroup","getDeclutter","userProjection","getUserProjection","userTransform","userExtent","toUserExtent","loadFeatures","toUserResolution","getTransformFromProjections","squaredTolerance","styles","styleFunction","dirty","renderFeature","getFeaturesInExtent","replayGroupInstructions","finish","getOverlaps","builderGroup","loading","Array","isArray","IMAGE_REPLAYS","VECTOR_REPLAYS","CanvasVectorTileLayerRenderer","renderedLayerRevision_","renderedPixelToCoordinateTransform_","tmpTransform_","prepareTile","state","updateExecutorGroup_","tileImageNeedsRender_","hifi","wantedResolution","Date","now","getRenderMode","renderTileImage_","hasContext","layerRevision","revision","renderOrder","builderState","getReplayState","renderedRenderOrder","declutter","sourceTileGrid","getTileGrid","tileExtent","wrappedTileCoord","sourceTiles","getSourceTiles","layerUid","hitDetectionImageData","declutterExecutorGroups","t","tt","sourceTile","sourceTileCoord","sourceTileExtent","sharedExtent","builderExtent","bufferedExtent","getGeometry","executorGroupInstructions","replayExtent","renderingReplayGroup","hitExtent","getId","found","declutteredFeatures","reject","getTileCoordForCoordAndResolution","loadingSourceTiles","corner","tilePixel","reduce","accumulator","concat","getOpacity","getTileRenderTransform","worldOffset","renderMode","replayTypes","filter","group","hasExecutors","getClipCoords","jj","replayState","renderedTileResolution","renderedTileRevision","renderPixelRatio","renderScale","setTransform","apply","pixelScale","SIMPLIFY_TOLERANCE","GEOMETRY_RENDERERS","renderPointGeometry","renderLineStringGeometry","renderPolygonGeometry","renderMultiPointGeometry","renderMultiLineStringGeometry","renderMultiPolygonGeometry","renderGeometryCollectionGeometry","renderCircleGeometry","defaultOrder","feature1","feature2","parseInt","getSquaredTolerance","tolerance","getTolerance","fillStyle","getFill","strokeStyle","getStroke","circleReplay","getBuilder","getZIndex","setFillStrokeStyle","drawCircle","textStyle","getText","textReplay","setTextStyle","drawText","listener","imageStyle","getImageState","unlistenImageChange","listenImageChange","renderFeatureInternal","getGeometryFunction","simplifiedGeometry","simplifyTransformed","renderer","renderGeometry","geometryRenderer","getType","geometries","getGeometries","replay","drawCustom","getHitDetectionRenderer","getGeometriesArray","lineStringReplay","drawLineString","drawMultiLineString","polygonReplay","drawMultiPolygon","declutterImageWithText","imageBuilderGroup","declutterMode","getDeclutterMode","imageReplay","setImageStyle","drawPoint","textBuilderGroup","drawMultiPoint","drawPolygon","WebGLLayerRenderer","options","inversePixelTransform_","postProcesses_","postProcesses","uniforms_","uniforms","helper","addChangeListener","removeHelper","dispatchPreComposeEvent","dispatchPostComposeEvent","reset","setUniforms","dispose","incrementGroup","groupNumber","canvasCacheKey","mapId","canvasCacheKeyMatches","getCanvas","afterHelperCreated","prepareFrameInternal","WebGLWorkerMessageType","GENERATE_POLYGON_BUFFERS","GENERATE_POINT_BUFFERS","GENERATE_LINE_STRING_BUFFERS","colorEncodeId","id","array","radix","divide","colorDecodeId","color","mult","WebGLPointsLayerRenderer","projectionMatrixTransform","sourceRevision_","verticesBuffer_","hitVerticesBuffer_","indicesBuffer_","vertexShader_","vertexShader","fragmentShader_","fragmentShader","program_","hitDetectionEnabled_","hitFragmentShader","hitVertexShader","hitVertexShader_","hitFragmentShader_","hitProgram_","customAttributes","attributes","attribute","name","hitDetectionAttributes","previousExtent_","currentTransform_","renderTransform_","invertRenderTransform_","renderInstructions_","Float32Array","hitRenderInstructions_","hitRenderTarget_","generateBuffersRun_","worker_","received","projectionTransform","hitDetection","fromArrayBuffer","vertexBuffer","flushBufferData","indexBuffer","renderInstructions","generateBuffersRun","featureCache_","featureCount_","sourceListenKeys_","VectorEventType","handleSourceFeatureAdded_","handleSourceFeatureChanged_","handleSourceFeatureDelete_","handleSourceFeatureClear_","forEachFeature","properties","getProperties","getProgram","gl","getGL","startWorld","renderCount","getSize","makeProjectionTransform","applyUniforms","drawElements","finalizeDraw","renderHitDetection","clearCachedData","viewNotMoving","ViewHint","sourceChanged","renderBuffer","BaseVector","rebuildBuffers_","useProgram","prepareDraw","bindBuffer","enableAttributes","totalInstructionsCount","totalHitInstructionsCount","featureCache","tmpCoords","tmpColor","hitColor","renderIndex","hitIndex","featureUid","getFlatCoordinates","message","buffer","customAttributesCount","postMessage","hitMessage","readPixel","index","getFeatureByUid","setSize","prepareDrawToRenderTarget","terminate"],"sourceRoot":""}
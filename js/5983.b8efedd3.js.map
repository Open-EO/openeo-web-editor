{"version":3,"file":"js/5983.b8efedd3.js","mappings":"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","sources":["webpack://@openeo/web-editor/./node_modules/ol/TileQueue.js","webpack://@openeo/web-editor/./node_modules/ol/Map.js","webpack://@openeo/web-editor/./node_modules/ol/Object.js","webpack://@openeo/web-editor/./node_modules/ol/ObjectEventType.js","webpack://@openeo/web-editor/./node_modules/ol/Observable.js","webpack://@openeo/web-editor/./node_modules/ol/Tile.js","webpack://@openeo/web-editor/./node_modules/ol/TileCache.js","webpack://@openeo/web-editor/./node_modules/ol/TileRange.js","webpack://@openeo/web-editor/./node_modules/ol/TileState.js","webpack://@openeo/web-editor/./node_modules/ol/ViewProperty.js","webpack://@openeo/web-editor/./node_modules/ol/View.js","webpack://@openeo/web-editor/./node_modules/ol/ViewHint.js"],"sourcesContent":["/**\n * @module ol/TileQueue\n */\nimport EventType from './events/EventType.js';\nimport PriorityQueue, {DROP} from './structs/PriorityQueue.js';\nimport TileState from './TileState.js';\n\n/**\n * @typedef {function(import(\"./Tile.js\").default, string, import(\"./coordinate.js\").Coordinate, number): number} PriorityFunction\n */\n\nclass TileQueue extends PriorityQueue {\n  /**\n   * @param {PriorityFunction} tilePriorityFunction Tile priority function.\n   * @param {function(): ?} tileChangeCallback Function called on each tile change event.\n   */\n  constructor(tilePriorityFunction, tileChangeCallback) {\n    super(\n      /**\n       * @param {Array} element Element.\n       * @return {number} Priority.\n       */\n      function (element) {\n        return tilePriorityFunction.apply(null, element);\n      },\n      /**\n       * @param {Array} element Element.\n       * @return {string} Key.\n       */\n      function (element) {\n        return /** @type {import(\"./Tile.js\").default} */ (element[0]).getKey();\n      },\n    );\n\n    /** @private */\n    this.boundHandleTileChange_ = this.handleTileChange.bind(this);\n\n    /**\n     * @private\n     * @type {function(): ?}\n     */\n    this.tileChangeCallback_ = tileChangeCallback;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.tilesLoading_ = 0;\n\n    /**\n     * @private\n     * @type {!Object<string,boolean>}\n     */\n    this.tilesLoadingKeys_ = {};\n  }\n\n  /**\n   * @param {Array} element Element.\n   * @return {boolean} The element was added to the queue.\n   */\n  enqueue(element) {\n    const added = super.enqueue(element);\n    if (added) {\n      const tile = element[0];\n      tile.addEventListener(EventType.CHANGE, this.boundHandleTileChange_);\n    }\n    return added;\n  }\n\n  /**\n   * @return {number} Number of tiles loading.\n   */\n  getTilesLoading() {\n    return this.tilesLoading_;\n  }\n\n  /**\n   * @param {import(\"./events/Event.js\").default} event Event.\n   * @protected\n   */\n  handleTileChange(event) {\n    const tile = /** @type {import(\"./Tile.js\").default} */ (event.target);\n    const state = tile.getState();\n    if (\n      state === TileState.LOADED ||\n      state === TileState.ERROR ||\n      state === TileState.EMPTY\n    ) {\n      if (state !== TileState.ERROR) {\n        tile.removeEventListener(EventType.CHANGE, this.boundHandleTileChange_);\n      }\n      const tileKey = tile.getKey();\n      if (tileKey in this.tilesLoadingKeys_) {\n        delete this.tilesLoadingKeys_[tileKey];\n        --this.tilesLoading_;\n      }\n      this.tileChangeCallback_();\n    }\n  }\n\n  /**\n   * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.\n   * @param {number} maxNewLoads Maximum number of new tiles to load.\n   */\n  loadMoreTiles(maxTotalLoading, maxNewLoads) {\n    let newLoads = 0;\n    let state, tile, tileKey;\n    while (\n      this.tilesLoading_ < maxTotalLoading &&\n      newLoads < maxNewLoads &&\n      this.getCount() > 0\n    ) {\n      tile = /** @type {import(\"./Tile.js\").default} */ (this.dequeue()[0]);\n      tileKey = tile.getKey();\n      state = tile.getState();\n      if (state === TileState.IDLE && !(tileKey in this.tilesLoadingKeys_)) {\n        this.tilesLoadingKeys_[tileKey] = true;\n        ++this.tilesLoading_;\n        ++newLoads;\n        tile.load();\n      }\n    }\n  }\n}\n\nexport default TileQueue;\n\n/**\n * @param {import('./Map.js').FrameState} frameState Frame state.\n * @param {import(\"./Tile.js\").default} tile Tile.\n * @param {string} tileSourceKey Tile source key.\n * @param {import(\"./coordinate.js\").Coordinate} tileCenter Tile center.\n * @param {number} tileResolution Tile resolution.\n * @return {number} Tile priority.\n */\nexport function getTilePriority(\n  frameState,\n  tile,\n  tileSourceKey,\n  tileCenter,\n  tileResolution,\n) {\n  // Filter out tiles at higher zoom levels than the current zoom level, or that\n  // are outside the visible extent.\n  if (!frameState || !(tileSourceKey in frameState.wantedTiles)) {\n    return DROP;\n  }\n  if (!frameState.wantedTiles[tileSourceKey][tile.getKey()]) {\n    return DROP;\n  }\n  // Prioritize the highest zoom level tiles closest to the focus.\n  // Tiles at higher zoom levels are prioritized using Math.log(tileResolution).\n  // Within a zoom level, tiles are prioritized by the distance in pixels between\n  // the center of the tile and the center of the viewport.  The factor of 65536\n  // means that the prioritization should behave as desired for tiles up to\n  // 65536 * Math.log(2) = 45426 pixels from the focus.\n  const center = frameState.viewState.center;\n  const deltaX = tileCenter[0] - center[0];\n  const deltaY = tileCenter[1] - center[1];\n  return (\n    65536 * Math.log(tileResolution) +\n    Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution\n  );\n}\n","/**\n * @module ol/Map\n */\nimport BaseObject from './Object.js';\nimport Collection from './Collection.js';\nimport CollectionEventType from './CollectionEventType.js';\nimport CompositeMapRenderer from './renderer/Composite.js';\nimport EventType from './events/EventType.js';\nimport Layer from './layer/Layer.js';\nimport LayerGroup, {GroupEvent} from './layer/Group.js';\nimport MapBrowserEvent from './MapBrowserEvent.js';\nimport MapBrowserEventHandler from './MapBrowserEventHandler.js';\nimport MapBrowserEventType from './MapBrowserEventType.js';\nimport MapEvent from './MapEvent.js';\nimport MapEventType from './MapEventType.js';\nimport MapProperty from './MapProperty.js';\nimport ObjectEventType from './ObjectEventType.js';\nimport PointerEventType from './pointer/EventType.js';\nimport RenderEventType from './render/EventType.js';\nimport TileQueue, {getTilePriority} from './TileQueue.js';\nimport View from './View.js';\nimport ViewHint from './ViewHint.js';\nimport {DEVICE_PIXEL_RATIO, PASSIVE_EVENT_LISTENERS} from './has.js';\nimport {TRUE} from './functions.js';\nimport {\n  apply as applyTransform,\n  create as createTransform,\n} from './transform.js';\nimport {assert} from './asserts.js';\nimport {\n  clone,\n  createOrUpdateEmpty,\n  equals as equalsExtent,\n  getForViewAndSize,\n  isEmpty,\n} from './extent.js';\nimport {defaults as defaultControls} from './control/defaults.js';\nimport {defaults as defaultInteractions} from './interaction/defaults.js';\nimport {equals} from './array.js';\nimport {fromUserCoordinate, toUserCoordinate} from './proj.js';\nimport {getUid} from './util.js';\nimport {hasArea} from './size.js';\nimport {listen, unlistenByKey} from './events.js';\nimport {removeNode} from './dom.js';\nimport {warn} from './console.js';\n\n/**\n * State of the current frame. Only `pixelRatio`, `time` and `viewState` should\n * be used in applications.\n * @typedef {Object} FrameState\n * @property {number} pixelRatio The pixel ratio of the frame.\n * @property {number} time The time when rendering of the frame was requested.\n * @property {import(\"./View.js\").State} viewState The state of the current view.\n * @property {boolean} animate Animate.\n * @property {import(\"./transform.js\").Transform} coordinateToPixelTransform CoordinateToPixelTransform.\n * @property {Object<string, import(\"rbush\").default>|null} declutter Declutter trees by declutter group.\n * When null, no decluttering is needed because no layers have decluttering enabled.\n * @property {null|import(\"./extent.js\").Extent} extent Extent (in view projection coordinates).\n * @property {import(\"./extent.js\").Extent} [nextExtent] Next extent during an animation series.\n * @property {number} index Index.\n * @property {Array<import(\"./layer/Layer.js\").State>} layerStatesArray LayerStatesArray.\n * @property {number} layerIndex LayerIndex.\n * @property {import(\"./transform.js\").Transform} pixelToCoordinateTransform PixelToCoordinateTransform.\n * @property {Array<PostRenderFunction>} postRenderFunctions PostRenderFunctions.\n * @property {import(\"./size.js\").Size} size Size.\n * @property {TileQueue} tileQueue TileQueue.\n * @property {!Object<string, Object<string, boolean>>} usedTiles UsedTiles.\n * @property {Array<number>} viewHints ViewHints.\n * @property {!Object<string, Object<string, boolean>>} wantedTiles WantedTiles.\n * @property {string} mapId The id of the map.\n * @property {Object<string, boolean>} renderTargets Identifiers of previously rendered elements.\n */\n\n/**\n * @typedef {function(Map, ?FrameState): any} PostRenderFunction\n */\n\n/**\n * @typedef {Object} AtPixelOptions\n * @property {undefined|function(import(\"./layer/Layer.js\").default<import(\"./source/Source\").default>): boolean} [layerFilter] Layer filter\n * function. The filter function will receive one argument, the\n * {@link module:ol/layer/Layer~Layer layer-candidate} and it should return a boolean value.\n * Only layers which are visible and for which this function returns `true`\n * will be tested for features. By default, all visible layers will be tested.\n * @property {number} [hitTolerance=0] Hit-detection tolerance in css pixels. Pixels\n * inside the radius around the given position will be checked for features.\n * @property {boolean} [checkWrapped=true] Check-Wrapped Will check for wrapped geometries inside the range of\n *   +/- 1 world width. Works only if a projection is used that can be wrapped.\n */\n\n/**\n * @typedef {Object} MapOptionsInternal\n * @property {Collection<import(\"./control/Control.js\").default>} [controls] Controls.\n * @property {Collection<import(\"./interaction/Interaction.js\").default>} [interactions] Interactions.\n * @property {HTMLElement|Document} keyboardEventTarget KeyboardEventTarget.\n * @property {Collection<import(\"./Overlay.js\").default>} overlays Overlays.\n * @property {Object<string, *>} values Values.\n */\n\n/**\n * @typedef {import(\"./ObjectEventType\").Types|'change:layergroup'|'change:size'|'change:target'|'change:view'} MapObjectEventTypes\n */\n\n/***\n * @template Return\n * @typedef {import(\"./Observable\").OnSignature<import(\"./Observable\").EventTypes, import(\"./events/Event.js\").default, Return> &\n *    import(\"./Observable\").OnSignature<MapObjectEventTypes, import(\"./Object\").ObjectEvent, Return> &\n *    import(\"./Observable\").OnSignature<import(\"./MapBrowserEventType\").Types, import(\"./MapBrowserEvent\").default, Return> &\n *    import(\"./Observable\").OnSignature<import(\"./MapEventType\").Types, import(\"./MapEvent\").default, Return> &\n *    import(\"./Observable\").OnSignature<import(\"./render/EventType\").MapRenderEventTypes, import(\"./render/Event\").default, Return> &\n *    import(\"./Observable\").CombinedOnSignature<import(\"./Observable\").EventTypes|MapObjectEventTypes|\n *      import(\"./MapBrowserEventType\").Types|import(\"./MapEventType\").Types|\n *      import(\"./render/EventType\").MapRenderEventTypes, Return>} MapEventHandler\n */\n\n/**\n * Object literal with config options for the map.\n * @typedef {Object} MapOptions\n * @property {Collection<import(\"./control/Control.js\").default>|Array<import(\"./control/Control.js\").default>} [controls]\n * Controls initially added to the map. If not specified,\n * {@link module:ol/control/defaults.defaults} is used.\n * @property {number} [pixelRatio=window.devicePixelRatio] The ratio between\n * physical pixels and device-independent pixels (dips) on the device.\n * @property {Collection<import(\"./interaction/Interaction.js\").default>|Array<import(\"./interaction/Interaction.js\").default>} [interactions]\n * Interactions that are initially added to the map. If not specified,\n * {@link module:ol/interaction/defaults.defaults} is used.\n * @property {HTMLElement|Document|string} [keyboardEventTarget] The element to\n * listen to keyboard events on. This determines when the `KeyboardPan` and\n * `KeyboardZoom` interactions trigger. For example, if this option is set to\n * `document` the keyboard interactions will always trigger. If this option is\n * not specified, the element the library listens to keyboard events on is the\n * map target (i.e. the user-provided div for the map). If this is not\n * `document`, the target element needs to be focused for key events to be\n * emitted, requiring that the target element has a `tabindex` attribute.\n * @property {Array<import(\"./layer/Base.js\").default>|Collection<import(\"./layer/Base.js\").default>|LayerGroup} [layers]\n * Layers. If this is not defined, a map with no layers will be rendered. Note\n * that layers are rendered in the order supplied, so if you want, for example,\n * a vector layer to appear on top of a tile layer, it must come after the tile\n * layer.\n * @property {number} [maxTilesLoading=16] Maximum number tiles to load\n * simultaneously.\n * @property {number} [moveTolerance=1] The minimum distance in pixels the\n * cursor must move to be detected as a map move event instead of a click.\n * Increasing this value can make it easier to click on the map.\n * @property {Collection<import(\"./Overlay.js\").default>|Array<import(\"./Overlay.js\").default>} [overlays]\n * Overlays initially added to the map. By default, no overlays are added.\n * @property {HTMLElement|string} [target] The container for the map, either the\n * element itself or the `id` of the element. If not specified at construction\n * time, {@link module:ol/Map~Map#setTarget} must be called for the map to be\n * rendered. If passed by element, the container can be in a secondary document.\n * **Note:** CSS `transform` support for the target element is limited to `scale`.\n * @property {View|Promise<import(\"./View.js\").ViewOptions>} [view] The map's view.  No layer sources will be\n * fetched unless this is specified at construction time or through\n * {@link module:ol/Map~Map#setView}.\n */\n\n/**\n * @param {import(\"./layer/Base.js\").default} layer Layer.\n */\nfunction removeLayerMapProperty(layer) {\n  if (layer instanceof Layer) {\n    layer.setMapInternal(null);\n    return;\n  }\n  if (layer instanceof LayerGroup) {\n    layer.getLayers().forEach(removeLayerMapProperty);\n  }\n}\n\n/**\n * @param {import(\"./layer/Base.js\").default} layer Layer.\n * @param {Map} map Map.\n */\nfunction setLayerMapProperty(layer, map) {\n  if (layer instanceof Layer) {\n    layer.setMapInternal(map);\n    return;\n  }\n  if (layer instanceof LayerGroup) {\n    const layers = layer.getLayers().getArray();\n    for (let i = 0, ii = layers.length; i < ii; ++i) {\n      setLayerMapProperty(layers[i], map);\n    }\n  }\n}\n\n/**\n * @classdesc\n * The map is the core component of OpenLayers. For a map to render, a view,\n * one or more layers, and a target container are needed:\n *\n *     import Map from 'ol/Map.js';\n *     import View from 'ol/View.js';\n *     import TileLayer from 'ol/layer/Tile.js';\n *     import OSM from 'ol/source/OSM.js';\n *\n *     const map = new Map({\n *       view: new View({\n *         center: [0, 0],\n *         zoom: 1,\n *       }),\n *       layers: [\n *         new TileLayer({\n *           source: new OSM(),\n *         }),\n *       ],\n *       target: 'map',\n *     });\n *\n * The above snippet creates a map using a {@link module:ol/layer/Tile~TileLayer} to\n * display {@link module:ol/source/OSM~OSM} OSM data and render it to a DOM\n * element with the id `map`.\n *\n * The constructor places a viewport container (with CSS class name\n * `ol-viewport`) in the target element (see `getViewport()`), and then two\n * further elements within the viewport: one with CSS class name\n * `ol-overlaycontainer-stopevent` for controls and some overlays, and one with\n * CSS class name `ol-overlaycontainer` for other overlays (see the `stopEvent`\n * option of {@link module:ol/Overlay~Overlay} for the difference). The map\n * itself is placed in a further element within the viewport.\n *\n * Layers are stored as a {@link module:ol/Collection~Collection} in\n * layerGroups. A top-level group is provided by the library. This is what is\n * accessed by `getLayerGroup` and `setLayerGroup`. Layers entered in the\n * options are added to this group, and `addLayer` and `removeLayer` change the\n * layer collection in the group. `getLayers` is a convenience function for\n * `getLayerGroup().getLayers()`. Note that {@link module:ol/layer/Group~LayerGroup}\n * is a subclass of {@link module:ol/layer/Base~BaseLayer}, so layers entered in the\n * options or added with `addLayer` can be groups, which can contain further\n * groups, and so on.\n *\n * @fires import(\"./MapBrowserEvent.js\").MapBrowserEvent\n * @fires import(\"./MapEvent.js\").MapEvent\n * @fires import(\"./render/Event.js\").default#precompose\n * @fires import(\"./render/Event.js\").default#postcompose\n * @fires import(\"./render/Event.js\").default#rendercomplete\n * @api\n */\nclass Map extends BaseObject {\n  /**\n   * @param {MapOptions} [options] Map options.\n   */\n  constructor(options) {\n    super();\n\n    options = options || {};\n\n    /***\n     * @type {MapEventHandler<import(\"./events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {MapEventHandler<import(\"./events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {MapEventHandler<void>}\n     */\n    this.un;\n\n    const optionsInternal = createOptionsInternal(options);\n\n    /**\n     * @private\n     * @type {boolean|undefined}\n     */\n    this.renderComplete_;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.loaded_ = true;\n\n    /** @private */\n    this.boundHandleBrowserEvent_ = this.handleBrowserEvent.bind(this);\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.maxTilesLoading_ =\n      options.maxTilesLoading !== undefined ? options.maxTilesLoading : 16;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ =\n      options.pixelRatio !== undefined\n        ? options.pixelRatio\n        : DEVICE_PIXEL_RATIO;\n\n    /**\n     * @private\n     * @type {ReturnType<typeof setTimeout>}\n     */\n    this.postRenderTimeoutHandle_;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.animationDelayKey_;\n\n    /**\n     * @private\n     */\n    this.animationDelay_ = this.animationDelay_.bind(this);\n\n    /**\n     * @private\n     * @type {import(\"./transform.js\").Transform}\n     */\n    this.coordinateToPixelTransform_ = createTransform();\n\n    /**\n     * @private\n     * @type {import(\"./transform.js\").Transform}\n     */\n    this.pixelToCoordinateTransform_ = createTransform();\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.frameIndex_ = 0;\n\n    /**\n     * @private\n     * @type {?FrameState}\n     */\n    this.frameState_ = null;\n\n    /**\n     * The extent at the previous 'moveend' event.\n     * @private\n     * @type {import(\"./extent.js\").Extent}\n     */\n    this.previousExtent_ = null;\n\n    /**\n     * @private\n     * @type {?import(\"./events.js\").EventsKey}\n     */\n    this.viewPropertyListenerKey_ = null;\n\n    /**\n     * @private\n     * @type {?import(\"./events.js\").EventsKey}\n     */\n    this.viewChangeListenerKey_ = null;\n\n    /**\n     * @private\n     * @type {?Array<import(\"./events.js\").EventsKey>}\n     */\n    this.layerGroupPropertyListenerKeys_ = null;\n\n    /**\n     * @private\n     * @type {!HTMLElement}\n     */\n    this.viewport_ = document.createElement('div');\n    this.viewport_.className =\n      'ol-viewport' + ('ontouchstart' in window ? ' ol-touch' : '');\n    this.viewport_.style.position = 'relative';\n    this.viewport_.style.overflow = 'hidden';\n    this.viewport_.style.width = '100%';\n    this.viewport_.style.height = '100%';\n\n    /**\n     * @private\n     * @type {!HTMLElement}\n     */\n    this.overlayContainer_ = document.createElement('div');\n    this.overlayContainer_.style.position = 'absolute';\n    this.overlayContainer_.style.zIndex = '0';\n    this.overlayContainer_.style.width = '100%';\n    this.overlayContainer_.style.height = '100%';\n    this.overlayContainer_.style.pointerEvents = 'none';\n    this.overlayContainer_.className = 'ol-overlaycontainer';\n    this.viewport_.appendChild(this.overlayContainer_);\n\n    /**\n     * @private\n     * @type {!HTMLElement}\n     */\n    this.overlayContainerStopEvent_ = document.createElement('div');\n    this.overlayContainerStopEvent_.style.position = 'absolute';\n    this.overlayContainerStopEvent_.style.zIndex = '0';\n    this.overlayContainerStopEvent_.style.width = '100%';\n    this.overlayContainerStopEvent_.style.height = '100%';\n    this.overlayContainerStopEvent_.style.pointerEvents = 'none';\n    this.overlayContainerStopEvent_.className = 'ol-overlaycontainer-stopevent';\n    this.viewport_.appendChild(this.overlayContainerStopEvent_);\n\n    /**\n     * @private\n     * @type {MapBrowserEventHandler}\n     */\n    this.mapBrowserEventHandler_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.moveTolerance_ = options.moveTolerance;\n\n    /**\n     * @private\n     * @type {HTMLElement|Document}\n     */\n    this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;\n\n    /**\n     * @private\n     * @type {?Array<import(\"./events.js\").EventsKey>}\n     */\n    this.targetChangeHandlerKeys_ = null;\n\n    /**\n     * @private\n     * @type {HTMLElement|null}\n     */\n    this.targetElement_ = null;\n\n    /**\n     * @type {ResizeObserver}\n     */\n    this.resizeObserver_ = new ResizeObserver(() => this.updateSize());\n\n    /**\n     * @type {Collection<import(\"./control/Control.js\").default>}\n     * @protected\n     */\n    this.controls = optionsInternal.controls || defaultControls();\n\n    /**\n     * @type {Collection<import(\"./interaction/Interaction.js\").default>}\n     * @protected\n     */\n    this.interactions =\n      optionsInternal.interactions ||\n      defaultInteractions({\n        onFocusOnly: true,\n      });\n\n    /**\n     * @type {Collection<import(\"./Overlay.js\").default>}\n     * @private\n     */\n    this.overlays_ = optionsInternal.overlays;\n\n    /**\n     * A lookup of overlays by id.\n     * @private\n     * @type {Object<string, import(\"./Overlay.js\").default>}\n     */\n    this.overlayIdIndex_ = {};\n\n    /**\n     * @type {import(\"./renderer/Map.js\").default|null}\n     * @private\n     */\n    this.renderer_ = null;\n\n    /**\n     * @private\n     * @type {!Array<PostRenderFunction>}\n     */\n    this.postRenderFunctions_ = [];\n\n    /**\n     * @private\n     * @type {TileQueue}\n     */\n    this.tileQueue_ = new TileQueue(\n      this.getTilePriority.bind(this),\n      this.handleTileChange_.bind(this),\n    );\n\n    this.addChangeListener(\n      MapProperty.LAYERGROUP,\n      this.handleLayerGroupChanged_,\n    );\n    this.addChangeListener(MapProperty.VIEW, this.handleViewChanged_);\n    this.addChangeListener(MapProperty.SIZE, this.handleSizeChanged_);\n    this.addChangeListener(MapProperty.TARGET, this.handleTargetChanged_);\n\n    // setProperties will trigger the rendering of the map if the map\n    // is \"defined\" already.\n    this.setProperties(optionsInternal.values);\n\n    const map = this;\n    if (options.view && !(options.view instanceof View)) {\n      options.view.then(function (viewOptions) {\n        map.setView(new View(viewOptions));\n      });\n    }\n\n    this.controls.addEventListener(\n      CollectionEventType.ADD,\n      /**\n       * @param {import(\"./Collection.js\").CollectionEvent<import(\"./control/Control.js\").default>} event CollectionEvent\n       */\n      (event) => {\n        event.element.setMap(this);\n      },\n    );\n\n    this.controls.addEventListener(\n      CollectionEventType.REMOVE,\n      /**\n       * @param {import(\"./Collection.js\").CollectionEvent<import(\"./control/Control.js\").default>} event CollectionEvent.\n       */\n      (event) => {\n        event.element.setMap(null);\n      },\n    );\n\n    this.interactions.addEventListener(\n      CollectionEventType.ADD,\n      /**\n       * @param {import(\"./Collection.js\").CollectionEvent<import(\"./interaction/Interaction.js\").default>} event CollectionEvent.\n       */\n      (event) => {\n        event.element.setMap(this);\n      },\n    );\n\n    this.interactions.addEventListener(\n      CollectionEventType.REMOVE,\n      /**\n       * @param {import(\"./Collection.js\").CollectionEvent<import(\"./interaction/Interaction.js\").default>} event CollectionEvent.\n       */\n      (event) => {\n        event.element.setMap(null);\n      },\n    );\n\n    this.overlays_.addEventListener(\n      CollectionEventType.ADD,\n      /**\n       * @param {import(\"./Collection.js\").CollectionEvent<import(\"./Overlay.js\").default>} event CollectionEvent.\n       */\n      (event) => {\n        this.addOverlayInternal_(event.element);\n      },\n    );\n\n    this.overlays_.addEventListener(\n      CollectionEventType.REMOVE,\n      /**\n       * @param {import(\"./Collection.js\").CollectionEvent<import(\"./Overlay.js\").default>} event CollectionEvent.\n       */\n      (event) => {\n        const id = event.element.getId();\n        if (id !== undefined) {\n          delete this.overlayIdIndex_[id.toString()];\n        }\n        event.element.setMap(null);\n      },\n    );\n\n    this.controls.forEach(\n      /**\n       * @param {import(\"./control/Control.js\").default} control Control.\n       */\n      (control) => {\n        control.setMap(this);\n      },\n    );\n\n    this.interactions.forEach(\n      /**\n       * @param {import(\"./interaction/Interaction.js\").default} interaction Interaction.\n       */\n      (interaction) => {\n        interaction.setMap(this);\n      },\n    );\n\n    this.overlays_.forEach(this.addOverlayInternal_.bind(this));\n  }\n\n  /**\n   * Add the given control to the map.\n   * @param {import(\"./control/Control.js\").default} control Control.\n   * @api\n   */\n  addControl(control) {\n    this.getControls().push(control);\n  }\n\n  /**\n   * Add the given interaction to the map. If you want to add an interaction\n   * at another point of the collection use `getInteractions()` and the methods\n   * available on {@link module:ol/Collection~Collection}. This can be used to\n   * stop the event propagation from the handleEvent function. The interactions\n   * get to handle the events in the reverse order of this collection.\n   * @param {import(\"./interaction/Interaction.js\").default} interaction Interaction to add.\n   * @api\n   */\n  addInteraction(interaction) {\n    this.getInteractions().push(interaction);\n  }\n\n  /**\n   * Adds the given layer to the top of this map. If you want to add a layer\n   * elsewhere in the stack, use `getLayers()` and the methods available on\n   * {@link module:ol/Collection~Collection}.\n   * @param {import(\"./layer/Base.js\").default} layer Layer.\n   * @api\n   */\n  addLayer(layer) {\n    const layers = this.getLayerGroup().getLayers();\n    layers.push(layer);\n  }\n\n  /**\n   * @param {import(\"./layer/Group.js\").GroupEvent} event The layer add event.\n   * @private\n   */\n  handleLayerAdd_(event) {\n    setLayerMapProperty(event.layer, this);\n  }\n\n  /**\n   * Add the given overlay to the map.\n   * @param {import(\"./Overlay.js\").default} overlay Overlay.\n   * @api\n   */\n  addOverlay(overlay) {\n    this.getOverlays().push(overlay);\n  }\n\n  /**\n   * This deals with map's overlay collection changes.\n   * @param {import(\"./Overlay.js\").default} overlay Overlay.\n   * @private\n   */\n  addOverlayInternal_(overlay) {\n    const id = overlay.getId();\n    if (id !== undefined) {\n      this.overlayIdIndex_[id.toString()] = overlay;\n    }\n    overlay.setMap(this);\n  }\n\n  /**\n   *\n   * Clean up.\n   */\n  disposeInternal() {\n    this.controls.clear();\n    this.interactions.clear();\n    this.overlays_.clear();\n    this.resizeObserver_.disconnect();\n    this.setTarget(null);\n    super.disposeInternal();\n  }\n\n  /**\n   * Detect features that intersect a pixel on the viewport, and execute a\n   * callback with each intersecting feature. Layers included in the detection can\n   * be configured through the `layerFilter` option in `options`.\n   * @param {import(\"./pixel.js\").Pixel} pixel Pixel.\n   * @param {function(import(\"./Feature.js\").FeatureLike, import(\"./layer/Layer.js\").default<import(\"./source/Source\").default>, import(\"./geom/SimpleGeometry.js\").default): T} callback Feature callback. The callback will be\n   *     called with two arguments. The first argument is one\n   *     {@link module:ol/Feature~Feature feature} or\n   *     {@link module:ol/render/Feature~RenderFeature render feature} at the pixel, the second is\n   *     the {@link module:ol/layer/Layer~Layer layer} of the feature and will be null for\n   *     unmanaged layers. To stop detection, callback functions can return a\n   *     truthy value.\n   * @param {AtPixelOptions} [options] Optional options.\n   * @return {T|undefined} Callback result, i.e. the return value of last\n   * callback execution, or the first truthy callback return value.\n   * @template T\n   * @api\n   */\n  forEachFeatureAtPixel(pixel, callback, options) {\n    if (!this.frameState_ || !this.renderer_) {\n      return;\n    }\n    const coordinate = this.getCoordinateFromPixelInternal(pixel);\n    options = options !== undefined ? options : {};\n    const hitTolerance =\n      options.hitTolerance !== undefined ? options.hitTolerance : 0;\n    const layerFilter =\n      options.layerFilter !== undefined ? options.layerFilter : TRUE;\n    const checkWrapped = options.checkWrapped !== false;\n    return this.renderer_.forEachFeatureAtCoordinate(\n      coordinate,\n      this.frameState_,\n      hitTolerance,\n      checkWrapped,\n      callback,\n      null,\n      layerFilter,\n      null,\n    );\n  }\n\n  /**\n   * Get all features that intersect a pixel on the viewport.\n   * @param {import(\"./pixel.js\").Pixel} pixel Pixel.\n   * @param {AtPixelOptions} [options] Optional options.\n   * @return {Array<import(\"./Feature.js\").FeatureLike>} The detected features or\n   * an empty array if none were found.\n   * @api\n   */\n  getFeaturesAtPixel(pixel, options) {\n    const features = [];\n    this.forEachFeatureAtPixel(\n      pixel,\n      function (feature) {\n        features.push(feature);\n      },\n      options,\n    );\n    return features;\n  }\n\n  /**\n   * Get all layers from all layer groups.\n   * @return {Array<import(\"./layer/Layer.js\").default>} Layers.\n   * @api\n   */\n  getAllLayers() {\n    const layers = [];\n    function addLayersFrom(layerGroup) {\n      layerGroup.forEach(function (layer) {\n        if (layer instanceof LayerGroup) {\n          addLayersFrom(layer.getLayers());\n        } else {\n          layers.push(layer);\n        }\n      });\n    }\n    addLayersFrom(this.getLayers());\n    return layers;\n  }\n\n  /**\n   * Detect if features intersect a pixel on the viewport. Layers included in the\n   * detection can be configured through the `layerFilter` option.\n   * @param {import(\"./pixel.js\").Pixel} pixel Pixel.\n   * @param {AtPixelOptions} [options] Optional options.\n   * @return {boolean} Is there a feature at the given pixel?\n   * @api\n   */\n  hasFeatureAtPixel(pixel, options) {\n    if (!this.frameState_ || !this.renderer_) {\n      return false;\n    }\n    const coordinate = this.getCoordinateFromPixelInternal(pixel);\n    options = options !== undefined ? options : {};\n    const layerFilter =\n      options.layerFilter !== undefined ? options.layerFilter : TRUE;\n    const hitTolerance =\n      options.hitTolerance !== undefined ? options.hitTolerance : 0;\n    const checkWrapped = options.checkWrapped !== false;\n    return this.renderer_.hasFeatureAtCoordinate(\n      coordinate,\n      this.frameState_,\n      hitTolerance,\n      checkWrapped,\n      layerFilter,\n      null,\n    );\n  }\n\n  /**\n   * Returns the coordinate in user projection for a browser event.\n   * @param {MouseEvent} event Event.\n   * @return {import(\"./coordinate.js\").Coordinate} Coordinate.\n   * @api\n   */\n  getEventCoordinate(event) {\n    return this.getCoordinateFromPixel(this.getEventPixel(event));\n  }\n\n  /**\n   * Returns the coordinate in view projection for a browser event.\n   * @param {MouseEvent} event Event.\n   * @return {import(\"./coordinate.js\").Coordinate} Coordinate.\n   */\n  getEventCoordinateInternal(event) {\n    return this.getCoordinateFromPixelInternal(this.getEventPixel(event));\n  }\n\n  /**\n   * Returns the map pixel position for a browser event relative to the viewport.\n   * @param {UIEvent|{clientX: number, clientY: number}} event Event.\n   * @return {import(\"./pixel.js\").Pixel} Pixel.\n   * @api\n   */\n  getEventPixel(event) {\n    const viewport = this.viewport_;\n    const viewportPosition = viewport.getBoundingClientRect();\n    const viewportSize = this.getSize();\n    const scaleX = viewportPosition.width / viewportSize[0];\n    const scaleY = viewportPosition.height / viewportSize[1];\n    const eventPosition =\n      //FIXME Are we really calling this with a TouchEvent anywhere?\n      'changedTouches' in event\n        ? /** @type {TouchEvent} */ (event).changedTouches[0]\n        : /** @type {MouseEvent} */ (event);\n\n    return [\n      (eventPosition.clientX - viewportPosition.left) / scaleX,\n      (eventPosition.clientY - viewportPosition.top) / scaleY,\n    ];\n  }\n\n  /**\n   * Get the target in which this map is rendered.\n   * Note that this returns what is entered as an option or in setTarget:\n   * if that was an element, it returns an element; if a string, it returns that.\n   * @return {HTMLElement|string|undefined} The Element or id of the Element that the\n   *     map is rendered in.\n   * @observable\n   * @api\n   */\n  getTarget() {\n    return /** @type {HTMLElement|string|undefined} */ (\n      this.get(MapProperty.TARGET)\n    );\n  }\n\n  /**\n   * Get the DOM element into which this map is rendered. In contrast to\n   * `getTarget` this method always return an `Element`, or `null` if the\n   * map has no target.\n   * @return {HTMLElement} The element that the map is rendered in.\n   * @api\n   */\n  getTargetElement() {\n    return this.targetElement_;\n  }\n\n  /**\n   * Get the coordinate for a given pixel.  This returns a coordinate in the\n   * user projection.\n   * @param {import(\"./pixel.js\").Pixel} pixel Pixel position in the map viewport.\n   * @return {import(\"./coordinate.js\").Coordinate} The coordinate for the pixel position.\n   * @api\n   */\n  getCoordinateFromPixel(pixel) {\n    return toUserCoordinate(\n      this.getCoordinateFromPixelInternal(pixel),\n      this.getView().getProjection(),\n    );\n  }\n\n  /**\n   * Get the coordinate for a given pixel.  This returns a coordinate in the\n   * map view projection.\n   * @param {import(\"./pixel.js\").Pixel} pixel Pixel position in the map viewport.\n   * @return {import(\"./coordinate.js\").Coordinate} The coordinate for the pixel position.\n   */\n  getCoordinateFromPixelInternal(pixel) {\n    const frameState = this.frameState_;\n    if (!frameState) {\n      return null;\n    }\n    return applyTransform(frameState.pixelToCoordinateTransform, pixel.slice());\n  }\n\n  /**\n   * Get the map controls. Modifying this collection changes the controls\n   * associated with the map.\n   * @return {Collection<import(\"./control/Control.js\").default>} Controls.\n   * @api\n   */\n  getControls() {\n    return this.controls;\n  }\n\n  /**\n   * Get the map overlays. Modifying this collection changes the overlays\n   * associated with the map.\n   * @return {Collection<import(\"./Overlay.js\").default>} Overlays.\n   * @api\n   */\n  getOverlays() {\n    return this.overlays_;\n  }\n\n  /**\n   * Get an overlay by its identifier (the value returned by overlay.getId()).\n   * Note that the index treats string and numeric identifiers as the same. So\n   * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.\n   * @param {string|number} id Overlay identifier.\n   * @return {import(\"./Overlay.js\").default|null} Overlay.\n   * @api\n   */\n  getOverlayById(id) {\n    const overlay = this.overlayIdIndex_[id.toString()];\n    return overlay !== undefined ? overlay : null;\n  }\n\n  /**\n   * Get the map interactions. Modifying this collection changes the interactions\n   * associated with the map.\n   *\n   * Interactions are used for e.g. pan, zoom and rotate.\n   * @return {Collection<import(\"./interaction/Interaction.js\").default>} Interactions.\n   * @api\n   */\n  getInteractions() {\n    return this.interactions;\n  }\n\n  /**\n   * Get the layergroup associated with this map.\n   * @return {LayerGroup} A layer group containing the layers in this map.\n   * @observable\n   * @api\n   */\n  getLayerGroup() {\n    return /** @type {LayerGroup} */ (this.get(MapProperty.LAYERGROUP));\n  }\n\n  /**\n   * Clear any existing layers and add layers to the map.\n   * @param {Array<import(\"./layer/Base.js\").default>|Collection<import(\"./layer/Base.js\").default>} layers The layers to be added to the map.\n   * @api\n   */\n  setLayers(layers) {\n    const group = this.getLayerGroup();\n    if (layers instanceof Collection) {\n      group.setLayers(layers);\n      return;\n    }\n\n    const collection = group.getLayers();\n    collection.clear();\n    collection.extend(layers);\n  }\n\n  /**\n   * Get the collection of layers associated with this map.\n   * @return {!Collection<import(\"./layer/Base.js\").default>} Layers.\n   * @api\n   */\n  getLayers() {\n    const layers = this.getLayerGroup().getLayers();\n    return layers;\n  }\n\n  /**\n   * @return {boolean} Layers have sources that are still loading.\n   */\n  getLoadingOrNotReady() {\n    const layerStatesArray = this.getLayerGroup().getLayerStatesArray();\n    for (let i = 0, ii = layerStatesArray.length; i < ii; ++i) {\n      const state = layerStatesArray[i];\n      if (!state.visible) {\n        continue;\n      }\n      const renderer = state.layer.getRenderer();\n      if (renderer && !renderer.ready) {\n        return true;\n      }\n      const source = state.layer.getSource();\n      if (source && source.loading) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Get the pixel for a coordinate.  This takes a coordinate in the user\n   * projection and returns the corresponding pixel.\n   * @param {import(\"./coordinate.js\").Coordinate} coordinate A map coordinate.\n   * @return {import(\"./pixel.js\").Pixel} A pixel position in the map viewport.\n   * @api\n   */\n  getPixelFromCoordinate(coordinate) {\n    const viewCoordinate = fromUserCoordinate(\n      coordinate,\n      this.getView().getProjection(),\n    );\n    return this.getPixelFromCoordinateInternal(viewCoordinate);\n  }\n\n  /**\n   * Get the pixel for a coordinate.  This takes a coordinate in the map view\n   * projection and returns the corresponding pixel.\n   * @param {import(\"./coordinate.js\").Coordinate} coordinate A map coordinate.\n   * @return {import(\"./pixel.js\").Pixel} A pixel position in the map viewport.\n   */\n  getPixelFromCoordinateInternal(coordinate) {\n    const frameState = this.frameState_;\n    if (!frameState) {\n      return null;\n    }\n    return applyTransform(\n      frameState.coordinateToPixelTransform,\n      coordinate.slice(0, 2),\n    );\n  }\n\n  /**\n   * Get the map renderer.\n   * @return {import(\"./renderer/Map.js\").default|null} Renderer\n   */\n  getRenderer() {\n    return this.renderer_;\n  }\n\n  /**\n   * Get the size of this map.\n   * @return {import(\"./size.js\").Size|undefined} The size in pixels of the map in the DOM.\n   * @observable\n   * @api\n   */\n  getSize() {\n    return /** @type {import(\"./size.js\").Size|undefined} */ (\n      this.get(MapProperty.SIZE)\n    );\n  }\n\n  /**\n   * Get the view associated with this map. A view manages properties such as\n   * center and resolution.\n   * @return {View} The view that controls this map.\n   * @observable\n   * @api\n   */\n  getView() {\n    return /** @type {View} */ (this.get(MapProperty.VIEW));\n  }\n\n  /**\n   * Get the element that serves as the map viewport.\n   * @return {HTMLElement} Viewport.\n   * @api\n   */\n  getViewport() {\n    return this.viewport_;\n  }\n\n  /**\n   * Get the element that serves as the container for overlays.  Elements added to\n   * this container will let mousedown and touchstart events through to the map,\n   * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}\n   * events.\n   * @return {!HTMLElement} The map's overlay container.\n   */\n  getOverlayContainer() {\n    return this.overlayContainer_;\n  }\n\n  /**\n   * Get the element that serves as a container for overlays that don't allow\n   * event propagation. Elements added to this container won't let mousedown and\n   * touchstart events through to the map, so clicks and gestures on an overlay\n   * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\n   * @return {!HTMLElement} The map's overlay container that stops events.\n   */\n  getOverlayContainerStopEvent() {\n    return this.overlayContainerStopEvent_;\n  }\n\n  /**\n   * @return {!Document} The document where the map is displayed.\n   */\n  getOwnerDocument() {\n    const targetElement = this.getTargetElement();\n    return targetElement ? targetElement.ownerDocument : document;\n  }\n\n  /**\n   * @param {import(\"./Tile.js\").default} tile Tile.\n   * @param {string} tileSourceKey Tile source key.\n   * @param {import(\"./coordinate.js\").Coordinate} tileCenter Tile center.\n   * @param {number} tileResolution Tile resolution.\n   * @return {number} Tile priority.\n   */\n  getTilePriority(tile, tileSourceKey, tileCenter, tileResolution) {\n    return getTilePriority(\n      this.frameState_,\n      tile,\n      tileSourceKey,\n      tileCenter,\n      tileResolution,\n    );\n  }\n\n  /**\n   * @param {UIEvent} browserEvent Browser event.\n   * @param {string} [type] Type.\n   */\n  handleBrowserEvent(browserEvent, type) {\n    type = type || browserEvent.type;\n    const mapBrowserEvent = new MapBrowserEvent(type, this, browserEvent);\n    this.handleMapBrowserEvent(mapBrowserEvent);\n  }\n\n  /**\n   * @param {MapBrowserEvent} mapBrowserEvent The event to handle.\n   */\n  handleMapBrowserEvent(mapBrowserEvent) {\n    if (!this.frameState_) {\n      // With no view defined, we cannot translate pixels into geographical\n      // coordinates so interactions cannot be used.\n      return;\n    }\n    const originalEvent = /** @type {PointerEvent} */ (\n      mapBrowserEvent.originalEvent\n    );\n    const eventType = originalEvent.type;\n    if (\n      eventType === PointerEventType.POINTERDOWN ||\n      eventType === EventType.WHEEL ||\n      eventType === EventType.KEYDOWN\n    ) {\n      const doc = this.getOwnerDocument();\n      const rootNode = this.viewport_.getRootNode\n        ? this.viewport_.getRootNode()\n        : doc;\n      const target = /** @type {Node} */ (originalEvent.target);\n      if (\n        // Abort if the target is a child of the container for elements whose events are not meant\n        // to be handled by map interactions.\n        this.overlayContainerStopEvent_.contains(target) ||\n        // Abort if the event target is a child of the container that is no longer in the page.\n        // It's possible for the target to no longer be in the page if it has been removed in an\n        // event listener, this might happen in a Control that recreates it's content based on\n        // user interaction either manually or via a render in something like https://reactjs.org/\n        !(rootNode === doc ? doc.documentElement : rootNode).contains(target)\n      ) {\n        return;\n      }\n    }\n    mapBrowserEvent.frameState = this.frameState_;\n    if (this.dispatchEvent(mapBrowserEvent) !== false) {\n      const interactionsArray = this.getInteractions().getArray().slice();\n      for (let i = interactionsArray.length - 1; i >= 0; i--) {\n        const interaction = interactionsArray[i];\n        if (\n          interaction.getMap() !== this ||\n          !interaction.getActive() ||\n          !this.getTargetElement()\n        ) {\n          continue;\n        }\n        const cont = interaction.handleEvent(mapBrowserEvent);\n        if (!cont || mapBrowserEvent.propagationStopped) {\n          break;\n        }\n      }\n    }\n  }\n\n  /**\n   * @protected\n   */\n  handlePostRender() {\n    const frameState = this.frameState_;\n\n    // Manage the tile queue\n    // Image loads are expensive and a limited resource, so try to use them\n    // efficiently:\n    // * When the view is static we allow a large number of parallel tile loads\n    //   to complete the frame as quickly as possible.\n    // * When animating or interacting, image loads can cause janks, so we reduce\n    //   the maximum number of loads per frame and limit the number of parallel\n    //   tile loads to remain reactive to view changes and to reduce the chance of\n    //   loading tiles that will quickly disappear from view.\n    const tileQueue = this.tileQueue_;\n    if (!tileQueue.isEmpty()) {\n      let maxTotalLoading = this.maxTilesLoading_;\n      let maxNewLoads = maxTotalLoading;\n      if (frameState) {\n        const hints = frameState.viewHints;\n        if (hints[ViewHint.ANIMATING] || hints[ViewHint.INTERACTING]) {\n          const lowOnFrameBudget = Date.now() - frameState.time > 8;\n          maxTotalLoading = lowOnFrameBudget ? 0 : 8;\n          maxNewLoads = lowOnFrameBudget ? 0 : 2;\n        }\n      }\n      if (tileQueue.getTilesLoading() < maxTotalLoading) {\n        tileQueue.reprioritize(); // FIXME only call if view has changed\n        tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);\n      }\n    }\n\n    if (frameState && this.renderer_ && !frameState.animate) {\n      if (this.renderComplete_ === true) {\n        if (this.hasListener(RenderEventType.RENDERCOMPLETE)) {\n          this.renderer_.dispatchRenderEvent(\n            RenderEventType.RENDERCOMPLETE,\n            frameState,\n          );\n        }\n        if (this.loaded_ === false) {\n          this.loaded_ = true;\n          this.dispatchEvent(\n            new MapEvent(MapEventType.LOADEND, this, frameState),\n          );\n        }\n      } else if (this.loaded_ === true) {\n        this.loaded_ = false;\n        this.dispatchEvent(\n          new MapEvent(MapEventType.LOADSTART, this, frameState),\n        );\n      }\n    }\n\n    const postRenderFunctions = this.postRenderFunctions_;\n    for (let i = 0, ii = postRenderFunctions.length; i < ii; ++i) {\n      postRenderFunctions[i](this, frameState);\n    }\n    postRenderFunctions.length = 0;\n  }\n\n  /**\n   * @private\n   */\n  handleSizeChanged_() {\n    if (this.getView() && !this.getView().getAnimating()) {\n      this.getView().resolveConstraints(0);\n    }\n\n    this.render();\n  }\n\n  /**\n   * @private\n   */\n  handleTargetChanged_() {\n    if (this.mapBrowserEventHandler_) {\n      for (let i = 0, ii = this.targetChangeHandlerKeys_.length; i < ii; ++i) {\n        unlistenByKey(this.targetChangeHandlerKeys_[i]);\n      }\n      this.targetChangeHandlerKeys_ = null;\n      this.viewport_.removeEventListener(\n        EventType.CONTEXTMENU,\n        this.boundHandleBrowserEvent_,\n      );\n      this.viewport_.removeEventListener(\n        EventType.WHEEL,\n        this.boundHandleBrowserEvent_,\n      );\n      this.mapBrowserEventHandler_.dispose();\n      this.mapBrowserEventHandler_ = null;\n      removeNode(this.viewport_);\n    }\n\n    if (this.targetElement_) {\n      this.resizeObserver_.unobserve(this.targetElement_);\n      const rootNode = this.targetElement_.getRootNode();\n      if (rootNode instanceof ShadowRoot) {\n        this.resizeObserver_.unobserve(rootNode.host);\n      }\n      this.setSize(undefined);\n    }\n\n    // target may be undefined, null, a string or an Element.\n    // If it's a string we convert it to an Element before proceeding.\n    // If it's not now an Element we remove the viewport from the DOM.\n    // If it's an Element we append the viewport element to it.\n\n    const target = this.getTarget();\n    const targetElement =\n      typeof target === 'string' ? document.getElementById(target) : target;\n    this.targetElement_ = targetElement;\n    if (!targetElement) {\n      if (this.renderer_) {\n        clearTimeout(this.postRenderTimeoutHandle_);\n        this.postRenderTimeoutHandle_ = undefined;\n        this.postRenderFunctions_.length = 0;\n        this.renderer_.dispose();\n        this.renderer_ = null;\n      }\n      if (this.animationDelayKey_) {\n        cancelAnimationFrame(this.animationDelayKey_);\n        this.animationDelayKey_ = undefined;\n      }\n    } else {\n      targetElement.appendChild(this.viewport_);\n      if (!this.renderer_) {\n        this.renderer_ = new CompositeMapRenderer(this);\n      }\n\n      this.mapBrowserEventHandler_ = new MapBrowserEventHandler(\n        this,\n        this.moveTolerance_,\n      );\n      for (const key in MapBrowserEventType) {\n        this.mapBrowserEventHandler_.addEventListener(\n          MapBrowserEventType[key],\n          this.handleMapBrowserEvent.bind(this),\n        );\n      }\n      this.viewport_.addEventListener(\n        EventType.CONTEXTMENU,\n        this.boundHandleBrowserEvent_,\n        false,\n      );\n      this.viewport_.addEventListener(\n        EventType.WHEEL,\n        this.boundHandleBrowserEvent_,\n        PASSIVE_EVENT_LISTENERS ? {passive: false} : false,\n      );\n\n      const keyboardEventTarget = !this.keyboardEventTarget_\n        ? targetElement\n        : this.keyboardEventTarget_;\n      this.targetChangeHandlerKeys_ = [\n        listen(\n          keyboardEventTarget,\n          EventType.KEYDOWN,\n          this.handleBrowserEvent,\n          this,\n        ),\n        listen(\n          keyboardEventTarget,\n          EventType.KEYPRESS,\n          this.handleBrowserEvent,\n          this,\n        ),\n      ];\n      const rootNode = targetElement.getRootNode();\n      if (rootNode instanceof ShadowRoot) {\n        this.resizeObserver_.observe(rootNode.host);\n      }\n      this.resizeObserver_.observe(targetElement);\n    }\n\n    this.updateSize();\n    // updateSize calls setSize, so no need to call this.render\n    // ourselves here.\n  }\n\n  /**\n   * @private\n   */\n  handleTileChange_() {\n    this.render();\n  }\n\n  /**\n   * @private\n   */\n  handleViewPropertyChanged_() {\n    this.render();\n  }\n\n  /**\n   * @private\n   */\n  handleViewChanged_() {\n    if (this.viewPropertyListenerKey_) {\n      unlistenByKey(this.viewPropertyListenerKey_);\n      this.viewPropertyListenerKey_ = null;\n    }\n    if (this.viewChangeListenerKey_) {\n      unlistenByKey(this.viewChangeListenerKey_);\n      this.viewChangeListenerKey_ = null;\n    }\n    const view = this.getView();\n    if (view) {\n      this.updateViewportSize_(this.getSize());\n\n      this.viewPropertyListenerKey_ = listen(\n        view,\n        ObjectEventType.PROPERTYCHANGE,\n        this.handleViewPropertyChanged_,\n        this,\n      );\n      this.viewChangeListenerKey_ = listen(\n        view,\n        EventType.CHANGE,\n        this.handleViewPropertyChanged_,\n        this,\n      );\n\n      view.resolveConstraints(0);\n    }\n    this.render();\n  }\n\n  /**\n   * @private\n   */\n  handleLayerGroupChanged_() {\n    if (this.layerGroupPropertyListenerKeys_) {\n      this.layerGroupPropertyListenerKeys_.forEach(unlistenByKey);\n      this.layerGroupPropertyListenerKeys_ = null;\n    }\n    const layerGroup = this.getLayerGroup();\n    if (layerGroup) {\n      this.handleLayerAdd_(new GroupEvent('addlayer', layerGroup));\n      this.layerGroupPropertyListenerKeys_ = [\n        listen(layerGroup, ObjectEventType.PROPERTYCHANGE, this.render, this),\n        listen(layerGroup, EventType.CHANGE, this.render, this),\n        listen(layerGroup, 'addlayer', this.handleLayerAdd_, this),\n        listen(layerGroup, 'removelayer', this.handleLayerRemove_, this),\n      ];\n    }\n    this.render();\n  }\n\n  /**\n   * @return {boolean} Is rendered.\n   */\n  isRendered() {\n    return !!this.frameState_;\n  }\n\n  /**\n   * @private\n   */\n  animationDelay_() {\n    this.animationDelayKey_ = undefined;\n    this.renderFrame_(Date.now());\n  }\n\n  /**\n   * Requests an immediate render in a synchronous manner.\n   * @api\n   */\n  renderSync() {\n    if (this.animationDelayKey_) {\n      cancelAnimationFrame(this.animationDelayKey_);\n    }\n    this.animationDelay_();\n  }\n\n  /**\n   * Redraws all text after new fonts have loaded\n   */\n  redrawText() {\n    const layerStates = this.getLayerGroup().getLayerStatesArray();\n    for (let i = 0, ii = layerStates.length; i < ii; ++i) {\n      const layer = layerStates[i].layer;\n      if (layer.hasRenderer()) {\n        layer.getRenderer().handleFontsChanged();\n      }\n    }\n  }\n\n  /**\n   * Request a map rendering (at the next animation frame).\n   * @api\n   */\n  render() {\n    if (this.renderer_ && this.animationDelayKey_ === undefined) {\n      this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);\n    }\n  }\n\n  /**\n   * Remove the given control from the map.\n   * @param {import(\"./control/Control.js\").default} control Control.\n   * @return {import(\"./control/Control.js\").default|undefined} The removed control (or undefined\n   *     if the control was not found).\n   * @api\n   */\n  removeControl(control) {\n    return this.getControls().remove(control);\n  }\n\n  /**\n   * Remove the given interaction from the map.\n   * @param {import(\"./interaction/Interaction.js\").default} interaction Interaction to remove.\n   * @return {import(\"./interaction/Interaction.js\").default|undefined} The removed interaction (or\n   *     undefined if the interaction was not found).\n   * @api\n   */\n  removeInteraction(interaction) {\n    return this.getInteractions().remove(interaction);\n  }\n\n  /**\n   * Removes the given layer from the map.\n   * @param {import(\"./layer/Base.js\").default} layer Layer.\n   * @return {import(\"./layer/Base.js\").default|undefined} The removed layer (or undefined if the\n   *     layer was not found).\n   * @api\n   */\n  removeLayer(layer) {\n    const layers = this.getLayerGroup().getLayers();\n    return layers.remove(layer);\n  }\n\n  /**\n   * @param {import(\"./layer/Group.js\").GroupEvent} event The layer remove event.\n   * @private\n   */\n  handleLayerRemove_(event) {\n    removeLayerMapProperty(event.layer);\n  }\n\n  /**\n   * Remove the given overlay from the map.\n   * @param {import(\"./Overlay.js\").default} overlay Overlay.\n   * @return {import(\"./Overlay.js\").default|undefined} The removed overlay (or undefined\n   *     if the overlay was not found).\n   * @api\n   */\n  removeOverlay(overlay) {\n    return this.getOverlays().remove(overlay);\n  }\n\n  /**\n   * @param {number} time Time.\n   * @private\n   */\n  renderFrame_(time) {\n    const size = this.getSize();\n    const view = this.getView();\n    const previousFrameState = this.frameState_;\n    /** @type {?FrameState} */\n    let frameState = null;\n    if (size !== undefined && hasArea(size) && view && view.isDef()) {\n      const viewHints = view.getHints(\n        this.frameState_ ? this.frameState_.viewHints : undefined,\n      );\n      const viewState = view.getState();\n      frameState = {\n        animate: false,\n        coordinateToPixelTransform: this.coordinateToPixelTransform_,\n        declutter: null,\n        extent: getForViewAndSize(\n          viewState.center,\n          viewState.resolution,\n          viewState.rotation,\n          size,\n        ),\n        index: this.frameIndex_++,\n        layerIndex: 0,\n        layerStatesArray: this.getLayerGroup().getLayerStatesArray(),\n        pixelRatio: this.pixelRatio_,\n        pixelToCoordinateTransform: this.pixelToCoordinateTransform_,\n        postRenderFunctions: [],\n        size: size,\n        tileQueue: this.tileQueue_,\n        time: time,\n        usedTiles: {},\n        viewState: viewState,\n        viewHints: viewHints,\n        wantedTiles: {},\n        mapId: getUid(this),\n        renderTargets: {},\n      };\n      if (viewState.nextCenter && viewState.nextResolution) {\n        const rotation = isNaN(viewState.nextRotation)\n          ? viewState.rotation\n          : viewState.nextRotation;\n\n        frameState.nextExtent = getForViewAndSize(\n          viewState.nextCenter,\n          viewState.nextResolution,\n          rotation,\n          size,\n        );\n      }\n    }\n\n    this.frameState_ = frameState;\n    this.renderer_.renderFrame(frameState);\n\n    if (frameState) {\n      if (frameState.animate) {\n        this.render();\n      }\n      Array.prototype.push.apply(\n        this.postRenderFunctions_,\n        frameState.postRenderFunctions,\n      );\n\n      if (previousFrameState) {\n        const moveStart =\n          !this.previousExtent_ ||\n          (!isEmpty(this.previousExtent_) &&\n            !equalsExtent(frameState.extent, this.previousExtent_));\n        if (moveStart) {\n          this.dispatchEvent(\n            new MapEvent(MapEventType.MOVESTART, this, previousFrameState),\n          );\n          this.previousExtent_ = createOrUpdateEmpty(this.previousExtent_);\n        }\n      }\n\n      const idle =\n        this.previousExtent_ &&\n        !frameState.viewHints[ViewHint.ANIMATING] &&\n        !frameState.viewHints[ViewHint.INTERACTING] &&\n        !equalsExtent(frameState.extent, this.previousExtent_);\n\n      if (idle) {\n        this.dispatchEvent(\n          new MapEvent(MapEventType.MOVEEND, this, frameState),\n        );\n        clone(frameState.extent, this.previousExtent_);\n      }\n    }\n\n    this.dispatchEvent(new MapEvent(MapEventType.POSTRENDER, this, frameState));\n\n    this.renderComplete_ =\n      this.hasListener(MapEventType.LOADSTART) ||\n      this.hasListener(MapEventType.LOADEND) ||\n      this.hasListener(RenderEventType.RENDERCOMPLETE)\n        ? !this.tileQueue_.getTilesLoading() &&\n          !this.tileQueue_.getCount() &&\n          !this.getLoadingOrNotReady()\n        : undefined;\n\n    if (!this.postRenderTimeoutHandle_) {\n      this.postRenderTimeoutHandle_ = setTimeout(() => {\n        this.postRenderTimeoutHandle_ = undefined;\n        this.handlePostRender();\n      }, 0);\n    }\n  }\n\n  /**\n   * Sets the layergroup of this map.\n   * @param {LayerGroup} layerGroup A layer group containing the layers in this map.\n   * @observable\n   * @api\n   */\n  setLayerGroup(layerGroup) {\n    const oldLayerGroup = this.getLayerGroup();\n    if (oldLayerGroup) {\n      this.handleLayerRemove_(new GroupEvent('removelayer', oldLayerGroup));\n    }\n    this.set(MapProperty.LAYERGROUP, layerGroup);\n  }\n\n  /**\n   * Set the size of this map.\n   * @param {import(\"./size.js\").Size|undefined} size The size in pixels of the map in the DOM.\n   * @observable\n   * @api\n   */\n  setSize(size) {\n    this.set(MapProperty.SIZE, size);\n  }\n\n  /**\n   * Set the target element to render this map into.\n   * @param {HTMLElement|string} [target] The Element or id of the Element\n   *     that the map is rendered in.\n   * @observable\n   * @api\n   */\n  setTarget(target) {\n    this.set(MapProperty.TARGET, target);\n  }\n\n  /**\n   * Set the view for this map.\n   * @param {View|Promise<import(\"./View.js\").ViewOptions>} view The view that controls this map.\n   * It is also possible to pass a promise that resolves to options for constructing a view.  This\n   * alternative allows view properties to be resolved by sources or other components that load\n   * view-related metadata.\n   * @observable\n   * @api\n   */\n  setView(view) {\n    if (!view || view instanceof View) {\n      this.set(MapProperty.VIEW, view);\n      return;\n    }\n    this.set(MapProperty.VIEW, new View());\n\n    const map = this;\n    view.then(function (viewOptions) {\n      map.setView(new View(viewOptions));\n    });\n  }\n\n  /**\n   * Force a recalculation of the map viewport size.  This should be called when\n   * third-party code changes the size of the map viewport.\n   * @api\n   */\n  updateSize() {\n    const targetElement = this.getTargetElement();\n\n    let size = undefined;\n    if (targetElement) {\n      const computedStyle = getComputedStyle(targetElement);\n      const width =\n        targetElement.offsetWidth -\n        parseFloat(computedStyle['borderLeftWidth']) -\n        parseFloat(computedStyle['paddingLeft']) -\n        parseFloat(computedStyle['paddingRight']) -\n        parseFloat(computedStyle['borderRightWidth']);\n      const height =\n        targetElement.offsetHeight -\n        parseFloat(computedStyle['borderTopWidth']) -\n        parseFloat(computedStyle['paddingTop']) -\n        parseFloat(computedStyle['paddingBottom']) -\n        parseFloat(computedStyle['borderBottomWidth']);\n      if (!isNaN(width) && !isNaN(height)) {\n        size = [width, height];\n        if (\n          !hasArea(size) &&\n          !!(\n            targetElement.offsetWidth ||\n            targetElement.offsetHeight ||\n            targetElement.getClientRects().length\n          )\n        ) {\n          warn(\n            \"No map visible because the map container's width or height are 0.\",\n          );\n        }\n      }\n    }\n\n    const oldSize = this.getSize();\n    if (size && (!oldSize || !equals(size, oldSize))) {\n      this.setSize(size);\n      this.updateViewportSize_(size);\n    }\n  }\n\n  /**\n   * Recomputes the viewport size and save it on the view object (if any)\n   * @param {import(\"./size.js\").Size|undefined} size The size.\n   * @private\n   */\n  updateViewportSize_(size) {\n    const view = this.getView();\n    if (view) {\n      view.setViewportSize(size);\n    }\n  }\n}\n\n/**\n * @param {MapOptions} options Map options.\n * @return {MapOptionsInternal} Internal map options.\n */\nfunction createOptionsInternal(options) {\n  /**\n   * @type {HTMLElement|Document}\n   */\n  let keyboardEventTarget = null;\n  if (options.keyboardEventTarget !== undefined) {\n    keyboardEventTarget =\n      typeof options.keyboardEventTarget === 'string'\n        ? document.getElementById(options.keyboardEventTarget)\n        : options.keyboardEventTarget;\n  }\n\n  /**\n   * @type {Object<string, *>}\n   */\n  const values = {};\n\n  const layerGroup =\n    options.layers &&\n    typeof (/** @type {?} */ (options.layers).getLayers) === 'function'\n      ? /** @type {LayerGroup} */ (options.layers)\n      : new LayerGroup({\n          layers:\n            /** @type {Collection<import(\"./layer/Base.js\").default>|Array<import(\"./layer/Base.js\").default>} */ (\n              options.layers\n            ),\n        });\n  values[MapProperty.LAYERGROUP] = layerGroup;\n\n  values[MapProperty.TARGET] = options.target;\n\n  values[MapProperty.VIEW] =\n    options.view instanceof View ? options.view : new View();\n\n  /** @type {Collection<import(\"./control/Control.js\").default>} */\n  let controls;\n  if (options.controls !== undefined) {\n    if (Array.isArray(options.controls)) {\n      controls = new Collection(options.controls.slice());\n    } else {\n      assert(\n        typeof (/** @type {?} */ (options.controls).getArray) === 'function',\n        'Expected `controls` to be an array or an `ol/Collection.js`',\n      );\n      controls = options.controls;\n    }\n  }\n\n  /** @type {Collection<import(\"./interaction/Interaction\").default>} */\n  let interactions;\n  if (options.interactions !== undefined) {\n    if (Array.isArray(options.interactions)) {\n      interactions = new Collection(options.interactions.slice());\n    } else {\n      assert(\n        typeof (/** @type {?} */ (options.interactions).getArray) ===\n          'function',\n        'Expected `interactions` to be an array or an `ol/Collection.js`',\n      );\n      interactions = options.interactions;\n    }\n  }\n\n  /** @type {Collection<import(\"./Overlay.js\").default>} */\n  let overlays;\n  if (options.overlays !== undefined) {\n    if (Array.isArray(options.overlays)) {\n      overlays = new Collection(options.overlays.slice());\n    } else {\n      assert(\n        typeof (/** @type {?} */ (options.overlays).getArray) === 'function',\n        'Expected `overlays` to be an array or an `ol/Collection.js`',\n      );\n      overlays = options.overlays;\n    }\n  } else {\n    overlays = new Collection();\n  }\n\n  return {\n    controls: controls,\n    interactions: interactions,\n    keyboardEventTarget: keyboardEventTarget,\n    overlays: overlays,\n    values: values,\n  };\n}\nexport default Map;\n","/**\n * @module ol/Object\n */\nimport Event from './events/Event.js';\nimport ObjectEventType from './ObjectEventType.js';\nimport Observable from './Observable.js';\nimport {getUid} from './util.js';\nimport {isEmpty} from './obj.js';\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/Object~BaseObject} instances are instances of this type.\n */\nexport class ObjectEvent extends Event {\n  /**\n   * @param {string} type The event type.\n   * @param {string} key The property name.\n   * @param {*} oldValue The old value for `key`.\n   */\n  constructor(type, key, oldValue) {\n    super(type);\n\n    /**\n     * The name of the property whose value is changing.\n     * @type {string}\n     * @api\n     */\n    this.key = key;\n\n    /**\n     * The old value. To get the new value use `e.target.get(e.key)` where\n     * `e` is the event object.\n     * @type {*}\n     * @api\n     */\n    this.oldValue = oldValue;\n  }\n}\n\n/***\n * @template Return\n * @typedef {import(\"./Observable\").OnSignature<import(\"./Observable\").EventTypes, import(\"./events/Event.js\").default, Return> &\n *    import(\"./Observable\").OnSignature<import(\"./ObjectEventType\").Types, ObjectEvent, Return> &\n *    import(\"./Observable\").CombinedOnSignature<import(\"./Observable\").EventTypes|import(\"./ObjectEventType\").Types, Return>} ObjectOnSignature\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Most non-trivial classes inherit from this.\n *\n * This extends {@link module:ol/Observable~Observable} with observable\n * properties, where each property is observable as well as the object as a\n * whole.\n *\n * Classes that inherit from this have pre-defined properties, to which you can\n * add your owns. The pre-defined properties are listed in this documentation as\n * 'Observable Properties', and have their own accessors; for example,\n * {@link module:ol/Map~Map} has a `target` property, accessed with\n * `getTarget()` and changed with `setTarget()`. Not all properties are however\n * settable. There are also general-purpose accessors `get()` and `set()`. For\n * example, `get('target')` is equivalent to `getTarget()`.\n *\n * The `set` accessors trigger a change event, and you can monitor this by\n * registering a listener. For example, {@link module:ol/View~View} has a\n * `center` property, so `view.on('change:center', function(evt) {...});` would\n * call the function whenever the value of the center property changes. Within\n * the function, `evt.target` would be the view, so `evt.target.getCenter()`\n * would return the new center.\n *\n * You can add your own observable properties with\n * `object.set('prop', 'value')`, and retrieve that with `object.get('prop')`.\n * You can listen for changes on that property value with\n * `object.on('change:prop', listener)`. You can get a list of all\n * properties with {@link module:ol/Object~BaseObject#getProperties}.\n *\n * Note that the observable properties are separate from standard JS properties.\n * You can, for example, give your map object a title with\n * `map.title='New title'` and with `map.set('title', 'Another title')`. The\n * first will be a `hasOwnProperty`; the second will appear in\n * `getProperties()`. Only the second is observable.\n *\n * Properties can be deleted by using the unset method. E.g.\n * object.unset('foo').\n *\n * @fires ObjectEvent\n * @api\n */\nclass BaseObject extends Observable {\n  /**\n   * @param {Object<string, *>} [values] An object with key-value pairs.\n   */\n  constructor(values) {\n    super();\n\n    /***\n     * @type {ObjectOnSignature<import(\"./events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {ObjectOnSignature<import(\"./events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {ObjectOnSignature<void>}\n     */\n    this.un;\n\n    // Call {@link module:ol/util.getUid} to ensure that the order of objects' ids is\n    // the same as the order in which they were created.  This also helps to\n    // ensure that object properties are always added in the same order, which\n    // helps many JavaScript engines generate faster code.\n    getUid(this);\n\n    /**\n     * @private\n     * @type {Object<string, *>|null}\n     */\n    this.values_ = null;\n\n    if (values !== undefined) {\n      this.setProperties(values);\n    }\n  }\n\n  /**\n   * Gets a value.\n   * @param {string} key Key name.\n   * @return {*} Value.\n   * @api\n   */\n  get(key) {\n    let value;\n    if (this.values_ && this.values_.hasOwnProperty(key)) {\n      value = this.values_[key];\n    }\n    return value;\n  }\n\n  /**\n   * Get a list of object property names.\n   * @return {Array<string>} List of property names.\n   * @api\n   */\n  getKeys() {\n    return (this.values_ && Object.keys(this.values_)) || [];\n  }\n\n  /**\n   * Get an object of all property names and values.\n   * @return {Object<string, *>} Object.\n   * @api\n   */\n  getProperties() {\n    return (this.values_ && Object.assign({}, this.values_)) || {};\n  }\n\n  /**\n   * Get an object of all property names and values.\n   * @return {Object<string, *>?} Object.\n   */\n  getPropertiesInternal() {\n    return this.values_;\n  }\n\n  /**\n   * @return {boolean} The object has properties.\n   */\n  hasProperties() {\n    return !!this.values_;\n  }\n\n  /**\n   * @param {string} key Key name.\n   * @param {*} oldValue Old value.\n   */\n  notify(key, oldValue) {\n    let eventType;\n    eventType = `change:${key}`;\n    if (this.hasListener(eventType)) {\n      this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));\n    }\n    eventType = ObjectEventType.PROPERTYCHANGE;\n    if (this.hasListener(eventType)) {\n      this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));\n    }\n  }\n\n  /**\n   * @param {string} key Key name.\n   * @param {import(\"./events.js\").Listener} listener Listener.\n   */\n  addChangeListener(key, listener) {\n    this.addEventListener(`change:${key}`, listener);\n  }\n\n  /**\n   * @param {string} key Key name.\n   * @param {import(\"./events.js\").Listener} listener Listener.\n   */\n  removeChangeListener(key, listener) {\n    this.removeEventListener(`change:${key}`, listener);\n  }\n\n  /**\n   * Sets a value.\n   * @param {string} key Key name.\n   * @param {*} value Value.\n   * @param {boolean} [silent] Update without triggering an event.\n   * @api\n   */\n  set(key, value, silent) {\n    const values = this.values_ || (this.values_ = {});\n    if (silent) {\n      values[key] = value;\n    } else {\n      const oldValue = values[key];\n      values[key] = value;\n      if (oldValue !== value) {\n        this.notify(key, oldValue);\n      }\n    }\n  }\n\n  /**\n   * Sets a collection of key-value pairs.  Note that this changes any existing\n   * properties and adds new ones (it does not remove any existing properties).\n   * @param {Object<string, *>} values Values.\n   * @param {boolean} [silent] Update without triggering an event.\n   * @api\n   */\n  setProperties(values, silent) {\n    for (const key in values) {\n      this.set(key, values[key], silent);\n    }\n  }\n\n  /**\n   * Apply any properties from another object without triggering events.\n   * @param {BaseObject} source The source object.\n   * @protected\n   */\n  applyProperties(source) {\n    if (!source.values_) {\n      return;\n    }\n    Object.assign(this.values_ || (this.values_ = {}), source.values_);\n  }\n\n  /**\n   * Unsets a property.\n   * @param {string} key Key name.\n   * @param {boolean} [silent] Unset without triggering an event.\n   * @api\n   */\n  unset(key, silent) {\n    if (this.values_ && key in this.values_) {\n      const oldValue = this.values_[key];\n      delete this.values_[key];\n      if (isEmpty(this.values_)) {\n        this.values_ = null;\n      }\n      if (!silent) {\n        this.notify(key, oldValue);\n      }\n    }\n  }\n}\n\nexport default BaseObject;\n","/**\n * @module ol/ObjectEventType\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  /**\n   * Triggered when a property is changed.\n   * @event module:ol/Object.ObjectEvent#propertychange\n   * @api\n   */\n  PROPERTYCHANGE: 'propertychange',\n};\n\n/**\n * @typedef {'propertychange'} Types\n */\n","/**\n * @module ol/Observable\n */\nimport EventTarget from './events/Target.js';\nimport EventType from './events/EventType.js';\nimport {listen, listenOnce, unlistenByKey} from './events.js';\n\n/***\n * @template {string} Type\n * @template {Event|import(\"./events/Event.js\").default} EventClass\n * @template Return\n * @typedef {(type: Type, listener: (event: EventClass) => ?) => Return} OnSignature\n */\n\n/***\n * @template {string} Type\n * @template Return\n * @typedef {(type: Type[], listener: (event: Event|import(\"./events/Event\").default) => ?) => Return extends void ? void : Return[]} CombinedOnSignature\n */\n\n/**\n * @typedef {'change'|'error'} EventTypes\n */\n\n/***\n * @template Return\n * @typedef {OnSignature<EventTypes, import(\"./events/Event.js\").default, Return> & CombinedOnSignature<EventTypes, Return>} ObservableOnSignature\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * An event target providing convenient methods for listener registration\n * and unregistration. A generic `change` event is always available through\n * {@link module:ol/Observable~Observable#changed}.\n *\n * @fires import(\"./events/Event.js\").default\n * @api\n */\nclass Observable extends EventTarget {\n  constructor() {\n    super();\n\n    this.on =\n      /** @type {ObservableOnSignature<import(\"./events\").EventsKey>} */ (\n        this.onInternal\n      );\n\n    this.once =\n      /** @type {ObservableOnSignature<import(\"./events\").EventsKey>} */ (\n        this.onceInternal\n      );\n\n    this.un = /** @type {ObservableOnSignature<void>} */ (this.unInternal);\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.revision_ = 0;\n  }\n\n  /**\n   * Increases the revision counter and dispatches a 'change' event.\n   * @api\n   */\n  changed() {\n    ++this.revision_;\n    this.dispatchEvent(EventType.CHANGE);\n  }\n\n  /**\n   * Get the version number for this object.  Each time the object is modified,\n   * its version number will be incremented.\n   * @return {number} Revision.\n   * @api\n   */\n  getRevision() {\n    return this.revision_;\n  }\n\n  /**\n   * @param {string|Array<string>} type Type.\n   * @param {function((Event|import(\"./events/Event\").default)): ?} listener Listener.\n   * @return {import(\"./events.js\").EventsKey|Array<import(\"./events.js\").EventsKey>} Event key.\n   * @protected\n   */\n  onInternal(type, listener) {\n    if (Array.isArray(type)) {\n      const len = type.length;\n      const keys = new Array(len);\n      for (let i = 0; i < len; ++i) {\n        keys[i] = listen(this, type[i], listener);\n      }\n      return keys;\n    }\n    return listen(this, /** @type {string} */ (type), listener);\n  }\n\n  /**\n   * @param {string|Array<string>} type Type.\n   * @param {function((Event|import(\"./events/Event\").default)): ?} listener Listener.\n   * @return {import(\"./events.js\").EventsKey|Array<import(\"./events.js\").EventsKey>} Event key.\n   * @protected\n   */\n  onceInternal(type, listener) {\n    let key;\n    if (Array.isArray(type)) {\n      const len = type.length;\n      key = new Array(len);\n      for (let i = 0; i < len; ++i) {\n        key[i] = listenOnce(this, type[i], listener);\n      }\n    } else {\n      key = listenOnce(this, /** @type {string} */ (type), listener);\n    }\n    /** @type {Object} */ (listener).ol_key = key;\n    return key;\n  }\n\n  /**\n   * Unlisten for a certain type of event.\n   * @param {string|Array<string>} type Type.\n   * @param {function((Event|import(\"./events/Event\").default)): ?} listener Listener.\n   * @protected\n   */\n  unInternal(type, listener) {\n    const key = /** @type {Object} */ (listener).ol_key;\n    if (key) {\n      unByKey(key);\n    } else if (Array.isArray(type)) {\n      for (let i = 0, ii = type.length; i < ii; ++i) {\n        this.removeEventListener(type[i], listener);\n      }\n    } else {\n      this.removeEventListener(type, listener);\n    }\n  }\n}\n\n/**\n * Listen for a certain type of event.\n * @function\n * @param {string|Array<string>} type The event type or array of event types.\n * @param {function((Event|import(\"./events/Event\").default)): ?} listener The listener function.\n * @return {import(\"./events.js\").EventsKey|Array<import(\"./events.js\").EventsKey>} Unique key for the listener. If\n *     called with an array of event types as the first argument, the return\n *     will be an array of keys.\n * @api\n */\nObservable.prototype.on;\n\n/**\n * Listen once for a certain type of event.\n * @function\n * @param {string|Array<string>} type The event type or array of event types.\n * @param {function((Event|import(\"./events/Event\").default)): ?} listener The listener function.\n * @return {import(\"./events.js\").EventsKey|Array<import(\"./events.js\").EventsKey>} Unique key for the listener. If\n *     called with an array of event types as the first argument, the return\n *     will be an array of keys.\n * @api\n */\nObservable.prototype.once;\n\n/**\n * Unlisten for a certain type of event.\n * @function\n * @param {string|Array<string>} type The event type or array of event types.\n * @param {function((Event|import(\"./events/Event\").default)): ?} listener The listener function.\n * @api\n */\nObservable.prototype.un;\n\n/**\n * Removes an event listener using the key returned by `on()` or `once()`.\n * @param {import(\"./events.js\").EventsKey|Array<import(\"./events.js\").EventsKey>} key The key returned by `on()`\n *     or `once()` (or an array of keys).\n * @api\n */\nexport function unByKey(key) {\n  if (Array.isArray(key)) {\n    for (let i = 0, ii = key.length; i < ii; ++i) {\n      unlistenByKey(key[i]);\n    }\n  } else {\n    unlistenByKey(/** @type {import(\"./events.js\").EventsKey} */ (key));\n  }\n}\n\nexport default Observable;\n","/**\n * @module ol/Tile\n */\nimport EventTarget from './events/Target.js';\nimport EventType from './events/EventType.js';\nimport TileState from './TileState.js';\nimport {abstract} from './util.js';\nimport {easeIn} from './easing.js';\n\n/**\n * A function that takes an {@link module:ol/Tile~Tile} for the tile and a\n * `{string}` for the url as arguments. The default is\n * ```js\n * source.setTileLoadFunction(function(tile, src) {\n *   tile.getImage().src = src;\n * });\n * ```\n * For more fine grained control, the load function can use fetch or XMLHttpRequest and involve\n * error handling:\n *\n * ```js\n * import TileState from 'ol/TileState.js';\n *\n * source.setTileLoadFunction(function(tile, src) {\n *   const xhr = new XMLHttpRequest();\n *   xhr.responseType = 'blob';\n *   xhr.addEventListener('loadend', function (evt) {\n *     const data = this.response;\n *     if (data !== undefined) {\n *       tile.getImage().src = URL.createObjectURL(data);\n *     } else {\n *       tile.setState(TileState.ERROR);\n *     }\n *   });\n *   xhr.addEventListener('error', function () {\n *     tile.setState(TileState.ERROR);\n *   });\n *   xhr.open('GET', src);\n *   xhr.send();\n * });\n * ```\n *\n * @typedef {function(Tile, string): void} LoadFunction\n * @api\n */\n\n/**\n * {@link module:ol/source/Tile~TileSource} sources use a function of this type to get\n * the url that provides a tile for a given tile coordinate.\n *\n * This function takes an {@link module:ol/tilecoord~TileCoord} for the tile\n * coordinate, a `{number}` representing the pixel ratio and a\n * {@link module:ol/proj/Projection~Projection} for the projection  as arguments\n * and returns a `{string}` representing the tile URL, or undefined if no tile\n * should be requested for the passed tile coordinate.\n *\n * @typedef {function(import(\"./tilecoord.js\").TileCoord, number,\n *           import(\"./proj/Projection.js\").default): (string|undefined)} UrlFunction\n * @api\n */\n\n/**\n * @typedef {Object} Options\n * @property {number} [transition=250] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n * @api\n */\n\n/**\n * @classdesc\n * Base class for tiles.\n *\n * @abstract\n */\nclass Tile extends EventTarget {\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @param {Options} [options] Tile options.\n   */\n  constructor(tileCoord, state, options) {\n    super();\n\n    options = options ? options : {};\n\n    /**\n     * @type {import(\"./tilecoord.js\").TileCoord}\n     */\n    this.tileCoord = tileCoord;\n\n    /**\n     * @protected\n     * @type {import(\"./TileState.js\").default}\n     */\n    this.state = state;\n\n    /**\n     * An \"interim\" tile for this tile. The interim tile may be used while this\n     * one is loading, for \"smooth\" transitions when changing params/dimensions\n     * on the source.\n     * @type {Tile|null}\n     */\n    this.interimTile = null;\n\n    /**\n     * A key assigned to the tile. This is used by the tile source to determine\n     * if this tile can effectively be used, or if a new tile should be created\n     * and this one be used as an interim tile for this new tile.\n     * @type {string}\n     */\n    this.key = '';\n\n    /**\n     * The duration for the opacity transition.\n     * @type {number}\n     */\n    this.transition_ =\n      options.transition === undefined ? 250 : options.transition;\n\n    /**\n     * Lookup of start times for rendering transitions.  If the start time is\n     * equal to -1, the transition is complete.\n     * @type {Object<string, number>}\n     */\n    this.transitionStarts_ = {};\n\n    /**\n     * @type {boolean}\n     */\n    this.interpolate = !!options.interpolate;\n  }\n\n  /**\n   * @protected\n   */\n  changed() {\n    this.dispatchEvent(EventType.CHANGE);\n  }\n\n  /**\n   * Called by the tile cache when the tile is removed from the cache due to expiry\n   */\n  release() {\n    if (this.state === TileState.ERROR) {\n      // to remove the `change` listener on this tile in `ol/TileQueue#handleTileChange`\n      this.setState(TileState.EMPTY);\n    }\n  }\n\n  /**\n   * @return {string} Key.\n   */\n  getKey() {\n    return this.key + '/' + this.tileCoord;\n  }\n\n  /**\n   * Get the interim tile most suitable for rendering using the chain of interim\n   * tiles. This corresponds to the  most recent tile that has been loaded, if no\n   * such tile exists, the original tile is returned.\n   * @return {!Tile} Best tile for rendering.\n   */\n  getInterimTile() {\n    let tile = this.interimTile;\n    if (!tile) {\n      //empty chain\n      return this;\n    }\n\n    // find the first loaded tile and return it. Since the chain is sorted in\n    // decreasing order of creation time, there is no need to search the remainder\n    // of the list (all those tiles correspond to older requests and will be\n    // cleaned up by refreshInterimChain)\n    do {\n      if (tile.getState() == TileState.LOADED) {\n        // Show tile immediately instead of fading it in after loading, because\n        // the interim tile is in place already\n        this.transition_ = 0;\n        return tile;\n      }\n      tile = tile.interimTile;\n    } while (tile);\n\n    // we can not find a better tile\n    return this;\n  }\n\n  /**\n   * Goes through the chain of interim tiles and discards sections of the chain\n   * that are no longer relevant.\n   */\n  refreshInterimChain() {\n    let tile = this.interimTile;\n    if (!tile) {\n      return;\n    }\n\n    /** @type {Tile} */\n    let prev = this;\n    do {\n      if (tile.getState() == TileState.LOADED) {\n        //we have a loaded tile, we can discard the rest of the list\n        //we would could abort any LOADING tile request\n        //older than this tile (i.e. any LOADING tile following this entry in the chain)\n        tile.interimTile = null;\n        break;\n      }\n      if (tile.getState() == TileState.LOADING) {\n        //keep this LOADING tile any loaded tiles later in the chain are\n        //older than this tile, so we're still interested in the request\n        prev = tile;\n      } else if (tile.getState() == TileState.IDLE) {\n        //the head of the list is the most current tile, we don't need\n        //to start any other requests for this chain\n        prev.interimTile = tile.interimTile;\n      } else {\n        prev = tile;\n      }\n      tile = prev.interimTile;\n    } while (tile);\n  }\n\n  /**\n   * Get the tile coordinate for this tile.\n   * @return {import(\"./tilecoord.js\").TileCoord} The tile coordinate.\n   * @api\n   */\n  getTileCoord() {\n    return this.tileCoord;\n  }\n\n  /**\n   * @return {import(\"./TileState.js\").default} State.\n   */\n  getState() {\n    return this.state;\n  }\n\n  /**\n   * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,\n   * it is important to set the state correctly to {@link module:ol/TileState~ERROR}\n   * when the tile cannot be loaded. Otherwise the tile cannot be removed from\n   * the tile queue and will block other requests.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @api\n   */\n  setState(state) {\n    if (this.state !== TileState.ERROR && this.state > state) {\n      throw new Error('Tile load sequence violation');\n    }\n    this.state = state;\n    this.changed();\n  }\n\n  /**\n   * Load the image or retry if loading previously failed.\n   * Loading is taken care of by the tile queue, and calling this method is\n   * only needed for preloading or for reloading in case of an error.\n   * @abstract\n   * @api\n   */\n  load() {\n    abstract();\n  }\n\n  /**\n   * Get the alpha value for rendering.\n   * @param {string} id An id for the renderer.\n   * @param {number} time The render frame time.\n   * @return {number} A number between 0 and 1.\n   */\n  getAlpha(id, time) {\n    if (!this.transition_) {\n      return 1;\n    }\n\n    let start = this.transitionStarts_[id];\n    if (!start) {\n      start = time;\n      this.transitionStarts_[id] = start;\n    } else if (start === -1) {\n      return 1;\n    }\n\n    const delta = time - start + 1000 / 60; // avoid rendering at 0\n    if (delta >= this.transition_) {\n      return 1;\n    }\n    return easeIn(delta / this.transition_);\n  }\n\n  /**\n   * Determine if a tile is in an alpha transition.  A tile is considered in\n   * transition if tile.getAlpha() has not yet been called or has been called\n   * and returned 1.\n   * @param {string} id An id for the renderer.\n   * @return {boolean} The tile is in transition.\n   */\n  inTransition(id) {\n    if (!this.transition_) {\n      return false;\n    }\n    return this.transitionStarts_[id] !== -1;\n  }\n\n  /**\n   * Mark a transition as complete.\n   * @param {string} id An id for the renderer.\n   */\n  endTransition(id) {\n    if (this.transition_) {\n      this.transitionStarts_[id] = -1;\n    }\n  }\n}\n\nexport default Tile;\n","/**\n * @module ol/TileCache\n */\nimport LRUCache from './structs/LRUCache.js';\nimport {fromKey, getKey} from './tilecoord.js';\n\nclass TileCache extends LRUCache {\n  clear() {\n    while (this.getCount() > 0) {\n      this.pop().release();\n    }\n    super.clear();\n  }\n\n  /**\n   * @param {!Object<string, boolean>} usedTiles Used tiles.\n   */\n  expireCache(usedTiles) {\n    while (this.canExpireCache()) {\n      const tile = this.peekLast();\n      if (tile.getKey() in usedTiles) {\n        break;\n      } else {\n        this.pop().release();\n      }\n    }\n  }\n\n  /**\n   * Prune all tiles from the cache that don't have the same z as the newest tile.\n   */\n  pruneExceptNewestZ() {\n    if (this.getCount() === 0) {\n      return;\n    }\n    const key = this.peekFirstKey();\n    const tileCoord = fromKey(key);\n    const z = tileCoord[0];\n    this.forEach((tile) => {\n      if (tile.tileCoord[0] !== z) {\n        this.remove(getKey(tile.tileCoord));\n        tile.release();\n      }\n    });\n  }\n}\n\nexport default TileCache;\n","/**\n * @module ol/TileRange\n */\n\n/**\n * A representation of a contiguous block of tiles.  A tile range is specified\n * by its min/max tile coordinates and is inclusive of coordinates.\n */\nclass TileRange {\n  /**\n   * @param {number} minX Minimum X.\n   * @param {number} maxX Maximum X.\n   * @param {number} minY Minimum Y.\n   * @param {number} maxY Maximum Y.\n   */\n  constructor(minX, maxX, minY, maxY) {\n    /**\n     * @type {number}\n     */\n    this.minX = minX;\n\n    /**\n     * @type {number}\n     */\n    this.maxX = maxX;\n\n    /**\n     * @type {number}\n     */\n    this.minY = minY;\n\n    /**\n     * @type {number}\n     */\n    this.maxY = maxY;\n  }\n\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @return {boolean} Contains tile coordinate.\n   */\n  contains(tileCoord) {\n    return this.containsXY(tileCoord[1], tileCoord[2]);\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   * @return {boolean} Contains.\n   */\n  containsTileRange(tileRange) {\n    return (\n      this.minX <= tileRange.minX &&\n      tileRange.maxX <= this.maxX &&\n      this.minY <= tileRange.minY &&\n      tileRange.maxY <= this.maxY\n    );\n  }\n\n  /**\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @return {boolean} Contains coordinate.\n   */\n  containsXY(x, y) {\n    return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   * @return {boolean} Equals.\n   */\n  equals(tileRange) {\n    return (\n      this.minX == tileRange.minX &&\n      this.minY == tileRange.minY &&\n      this.maxX == tileRange.maxX &&\n      this.maxY == tileRange.maxY\n    );\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   */\n  extend(tileRange) {\n    if (tileRange.minX < this.minX) {\n      this.minX = tileRange.minX;\n    }\n    if (tileRange.maxX > this.maxX) {\n      this.maxX = tileRange.maxX;\n    }\n    if (tileRange.minY < this.minY) {\n      this.minY = tileRange.minY;\n    }\n    if (tileRange.maxY > this.maxY) {\n      this.maxY = tileRange.maxY;\n    }\n  }\n\n  /**\n   * @return {number} Height.\n   */\n  getHeight() {\n    return this.maxY - this.minY + 1;\n  }\n\n  /**\n   * @return {import(\"./size.js\").Size} Size.\n   */\n  getSize() {\n    return [this.getWidth(), this.getHeight()];\n  }\n\n  /**\n   * @return {number} Width.\n   */\n  getWidth() {\n    return this.maxX - this.minX + 1;\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   * @return {boolean} Intersects.\n   */\n  intersects(tileRange) {\n    return (\n      this.minX <= tileRange.maxX &&\n      this.maxX >= tileRange.minX &&\n      this.minY <= tileRange.maxY &&\n      this.maxY >= tileRange.minY\n    );\n  }\n}\n\n/**\n * @param {number} minX Minimum X.\n * @param {number} maxX Maximum X.\n * @param {number} minY Minimum Y.\n * @param {number} maxY Maximum Y.\n * @param {TileRange} [tileRange] TileRange.\n * @return {TileRange} Tile range.\n */\nexport function createOrUpdate(minX, maxX, minY, maxY, tileRange) {\n  if (tileRange !== undefined) {\n    tileRange.minX = minX;\n    tileRange.maxX = maxX;\n    tileRange.minY = minY;\n    tileRange.maxY = maxY;\n    return tileRange;\n  }\n  return new TileRange(minX, maxX, minY, maxY);\n}\n\nexport default TileRange;\n","/**\n * @module ol/TileState\n */\n\n/**\n * @enum {number}\n */\nexport default {\n  IDLE: 0,\n  LOADING: 1,\n  LOADED: 2,\n  /**\n   * Indicates that tile loading failed\n   * @type {number}\n   */\n  ERROR: 3,\n  EMPTY: 4,\n};\n","/**\n * @module ol/ViewProperty\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  CENTER: 'center',\n  RESOLUTION: 'resolution',\n  ROTATION: 'rotation',\n};\n","/**\n * @module ol/View\n */\nimport BaseObject from './Object.js';\nimport ViewHint from './ViewHint.js';\nimport ViewProperty from './ViewProperty.js';\nimport {DEFAULT_TILE_SIZE} from './tilegrid/common.js';\nimport {\n  METERS_PER_UNIT,\n  createProjection,\n  disableCoordinateWarning,\n  fromUserCoordinate,\n  fromUserExtent,\n  getUserProjection,\n  toUserCoordinate,\n  toUserExtent,\n} from './proj.js';\nimport {VOID} from './functions.js';\nimport {\n  add as addCoordinate,\n  equals as coordinatesEqual,\n  equals,\n  rotate as rotateCoordinate,\n} from './coordinate.js';\nimport {assert} from './asserts.js';\nimport {none as centerNone, createExtent} from './centerconstraint.js';\nimport {clamp, modulo} from './math.js';\nimport {\n  createMinMaxResolution,\n  createSnapToPower,\n  createSnapToResolutions,\n} from './resolutionconstraint.js';\nimport {\n  createSnapToN,\n  createSnapToZero,\n  disable,\n  none as rotationNone,\n} from './rotationconstraint.js';\nimport {easeOut, inAndOut} from './easing.js';\nimport {\n  getCenter,\n  getForViewAndSize,\n  getHeight,\n  getWidth,\n  isEmpty,\n} from './extent.js';\nimport {linearFindNearest} from './array.js';\nimport {fromExtent as polygonFromExtent} from './geom/Polygon.js';\n\n/**\n * An animation configuration\n *\n * @typedef {Object} Animation\n * @property {import(\"./coordinate.js\").Coordinate} [sourceCenter] Source center.\n * @property {import(\"./coordinate.js\").Coordinate} [targetCenter] Target center.\n * @property {number} [sourceResolution] Source resolution.\n * @property {number} [targetResolution] Target resolution.\n * @property {number} [sourceRotation] Source rotation.\n * @property {number} [targetRotation] Target rotation.\n * @property {import(\"./coordinate.js\").Coordinate} [anchor] Anchor.\n * @property {number} start Start.\n * @property {number} duration Duration.\n * @property {boolean} complete Complete.\n * @property {function(number):number} easing Easing.\n * @property {function(boolean):void} callback Callback.\n */\n\n/**\n * @typedef {Object} Constraints\n * @property {import(\"./centerconstraint.js\").Type} center Center.\n * @property {import(\"./resolutionconstraint.js\").Type} resolution Resolution.\n * @property {import(\"./rotationconstraint.js\").Type} rotation Rotation.\n */\n\n/**\n * @typedef {Object} FitOptions\n * @property {import(\"./size.js\").Size} [size] The size in pixels of the box to\n * fit the extent into. Defaults to the size of the map the view is associated with.\n * If no map or multiple maps are connected to the view, provide the desired box size\n * (e.g. `map.getSize()`).\n * @property {!Array<number>} [padding=[0, 0, 0, 0]] Padding (in pixels) to be\n * cleared inside the view. Values in the array are top, right, bottom and left\n * padding.\n * @property {boolean} [nearest=false] If the view `constrainResolution` option is `true`,\n * get the nearest extent instead of the closest that actually fits the view.\n * @property {number} [minResolution=0] Minimum resolution that we zoom to.\n * @property {number} [maxZoom] Maximum zoom level that we zoom to. If\n * `minResolution` is given, this property is ignored.\n * @property {number} [duration] The duration of the animation in milliseconds.\n * By default, there is no animation to the target extent.\n * @property {function(number):number} [easing] The easing function used during\n * the animation (defaults to {@link module:ol/easing.inAndOut}).\n * The function will be called for each frame with a number representing a\n * fraction of the animation's duration.  The function should return a number\n * between 0 and 1 representing the progress toward the destination state.\n * @property {function(boolean):void} [callback] Function called when the view is in\n * its final position. The callback will be called with `true` if the animation\n * series completed on its own or `false` if it was cancelled.\n */\n\n/**\n * @typedef {Object} ViewOptions\n * @property {import(\"./coordinate.js\").Coordinate} [center] The initial center for\n * the view. If a user projection is not set, the coordinate system for the center is\n * specified with the `projection` option. Layer sources will not be fetched if this\n * is not set, but the center can be set later with {@link #setCenter}.\n * @property {boolean|number} [constrainRotation=true] Rotation constraint.\n * `false` means no constraint. `true` means no constraint, but snap to zero\n * near zero. A number constrains the rotation to that number of values. For\n * example, `4` will constrain the rotation to 0, 90, 180, and 270 degrees.\n * @property {boolean} [enableRotation=true] Enable rotation.\n * If `false`, a rotation constraint that always sets the rotation to zero is\n * used. The `constrainRotation` option has no effect if `enableRotation` is\n * `false`.\n * @property {import(\"./extent.js\").Extent} [extent] The extent that constrains the\n * view, in other words, nothing outside of this extent can be visible on the map.\n * @property {boolean} [constrainOnlyCenter=false] If true, the extent\n * constraint will only apply to the view center and not the whole extent.\n * @property {boolean} [smoothExtentConstraint=true] If true, the extent\n * constraint will be applied smoothly, i.e. allow the view to go slightly outside\n * of the given `extent`.\n * @property {number} [maxResolution] The maximum resolution used to determine\n * the resolution constraint. It is used together with `minResolution` (or\n * `maxZoom`) and `zoomFactor`. If unspecified it is calculated in such a way\n * that the projection's validity extent fits in a 256x256 px tile. If the\n * projection is Spherical Mercator (the default) then `maxResolution` defaults\n * to `40075016.68557849 / 256 = 156543.03392804097`.\n * @property {number} [minResolution] The minimum resolution used to determine\n * the resolution constraint.  It is used together with `maxResolution` (or\n * `minZoom`) and `zoomFactor`.  If unspecified it is calculated assuming 29\n * zoom levels (with a factor of 2). If the projection is Spherical Mercator\n * (the default) then `minResolution` defaults to\n * `40075016.68557849 / 256 / Math.pow(2, 28) = 0.0005831682455839253`.\n * @property {number} [maxZoom=28] The maximum zoom level used to determine the\n * resolution constraint. It is used together with `minZoom` (or\n * `maxResolution`) and `zoomFactor`.  Note that if `minResolution` is also\n * provided, it is given precedence over `maxZoom`.\n * @property {number} [minZoom=0] The minimum zoom level used to determine the\n * resolution constraint. It is used together with `maxZoom` (or\n * `minResolution`) and `zoomFactor`.  Note that if `maxResolution` is also\n * provided, it is given precedence over `minZoom`.\n * @property {boolean} [multiWorld=false] If `false` the view is constrained so\n * only one world is visible, and you cannot pan off the edge.  If `true` the map\n * may show multiple worlds at low zoom levels.  Only used if the `projection` is\n * global.  Note that if `extent` is also provided it is given precedence.\n * @property {boolean} [constrainResolution=false] If true, the view will always\n * animate to the closest zoom level after an interaction; false means\n * intermediary zoom levels are allowed.\n * @property {boolean} [smoothResolutionConstraint=true] If true, the resolution\n * min/max values will be applied smoothly, i. e. allow the view to exceed slightly\n * the given resolution or zoom bounds.\n * @property {boolean} [showFullExtent=false] Allow the view to be zoomed out to\n * show the full configured extent. By default, when a view is configured with an\n * extent, users will not be able to zoom out so the viewport exceeds the extent in\n * either dimension. This means the full extent may not be visible if the viewport\n * is taller or wider than the aspect ratio of the configured extent. If\n * showFullExtent is true, the user will be able to zoom out so that the viewport\n * exceeds the height or width of the configured extent, but not both, allowing the\n * full extent to be shown.\n * @property {import(\"./proj.js\").ProjectionLike} [projection='EPSG:3857'] The\n * projection. The default is Spherical Mercator.\n * @property {number} [resolution] The initial resolution for the view. The\n * units are `projection` units per pixel (e.g. meters per pixel). An\n * alternative to setting this is to set `zoom`. Layer sources will not be\n * fetched if neither this nor `zoom` are defined, but they can be set later\n * with {@link #setZoom} or {@link #setResolution}.\n * @property {Array<number>} [resolutions] Resolutions that determine the\n * zoom levels if specified. The index in the array corresponds to the zoom level,\n * therefore the resolution values have to be in descending order. It also constrains\n * the resolution by the minimum and maximum value. If set the `maxResolution`,\n * `minResolution`, `minZoom`, `maxZoom`, and `zoomFactor` options are ignored.\n * @property {number} [rotation=0] The initial rotation for the view in radians\n * (positive rotation clockwise, 0 means North).\n * @property {number} [zoom] Only used if `resolution` is not defined. Zoom\n * level used to calculate the initial resolution for the view.\n * @property {number} [zoomFactor=2] The zoom factor used to compute the\n * corresponding resolution.\n * @property {!Array<number>} [padding=[0, 0, 0, 0]] Padding (in css pixels).\n * If the map viewport is partially covered with other content (overlays) along\n * its edges, this setting allows to shift the center of the viewport away from\n * that content. The order of the values is top, right, bottom, left.\n */\n\n/**\n * @typedef {Object} AnimationOptions\n * @property {import(\"./coordinate.js\").Coordinate} [center] The center of the view at the end of\n * the animation.\n * @property {number} [zoom] The zoom level of the view at the end of the\n * animation. This takes precedence over `resolution`.\n * @property {number} [resolution] The resolution of the view at the end\n * of the animation.  If `zoom` is also provided, this option will be ignored.\n * @property {number} [rotation] The rotation of the view at the end of\n * the animation.\n * @property {import(\"./coordinate.js\").Coordinate} [anchor] Optional anchor to remain fixed\n * during a rotation or resolution animation.\n * @property {number} [duration=1000] The duration of the animation in milliseconds.\n * @property {function(number):number} [easing] The easing function used\n * during the animation (defaults to {@link module:ol/easing.inAndOut}).\n * The function will be called for each frame with a number representing a\n * fraction of the animation's duration.  The function should return a number\n * between 0 and 1 representing the progress toward the destination state.\n */\n\n/**\n * @typedef {Object} State\n * @property {import(\"./coordinate.js\").Coordinate} center Center (in view projection coordinates).\n * @property {import(\"./proj/Projection.js\").default} projection Projection.\n * @property {number} resolution Resolution.\n * @property {import(\"./coordinate.js\").Coordinate} [nextCenter] The next center during an animation series.\n * @property {number} [nextResolution] The next resolution during an animation series.\n * @property {number} [nextRotation] The next rotation during an animation series.\n * @property {number} rotation Rotation.\n * @property {number} zoom Zoom.\n */\n\n/**\n * Like {@link import(\"./Map.js\").FrameState}, but just `viewState` and `extent`.\n * @typedef {Object} ViewStateLayerStateExtent\n * @property {State} viewState View state.\n * @property {import(\"./extent.js\").Extent} extent Extent (in user projection coordinates).\n * @property {Array<import(\"./layer/Layer.js\").State>} [layerStatesArray] Layer states.\n */\n\n/**\n * Default min zoom level for the map view.\n * @type {number}\n */\nconst DEFAULT_MIN_ZOOM = 0;\n\n/**\n * @typedef {import(\"./ObjectEventType\").Types|'change:center'|'change:resolution'|'change:rotation'} ViewObjectEventTypes\n */\n\n/***\n * @template Return\n * @typedef {import(\"./Observable\").OnSignature<import(\"./Observable\").EventTypes, import(\"./events/Event.js\").default, Return> &\n *   import(\"./Observable\").OnSignature<ViewObjectEventTypes, import(\"./Object\").ObjectEvent, Return> &\n *   import(\"./Observable\").CombinedOnSignature<import(\"./Observable\").EventTypes|ViewObjectEventTypes, Return>} ViewOnSignature\n */\n\n/**\n * @classdesc\n * A View object represents a simple 2D view of the map.\n *\n * This is the object to act upon to change the center, resolution,\n * and rotation of the map.\n *\n * A View has a `projection`. The projection determines the\n * coordinate system of the center, and its units determine the units of the\n * resolution (projection units per pixel). The default projection is\n * Web Mercator (EPSG:3857).\n *\n * ### The view states\n *\n * A View is determined by three states: `center`, `resolution`,\n * and `rotation`. Each state has a corresponding getter and setter, e.g.\n * `getCenter` and `setCenter` for the `center` state.\n *\n * The `zoom` state is actually not saved on the view: all computations\n * internally use the `resolution` state. Still, the `setZoom` and `getZoom`\n * methods are available, as well as `getResolutionForZoom` and\n * `getZoomForResolution` to switch from one system to the other.\n *\n * ### The constraints\n *\n * `setCenter`, `setResolution` and `setRotation` can be used to change the\n * states of the view, but any constraint defined in the constructor will\n * be applied along the way.\n *\n * A View object can have a *resolution constraint*, a *rotation constraint*\n * and a *center constraint*.\n *\n * The *resolution constraint* typically restricts min/max values and\n * snaps to specific resolutions. It is determined by the following\n * options: `resolutions`, `maxResolution`, `maxZoom` and `zoomFactor`.\n * If `resolutions` is set, the other three options are ignored. See\n * documentation for each option for more information. By default, the view\n * only has a min/max restriction and allow intermediary zoom levels when\n * pinch-zooming for example.\n *\n * The *rotation constraint* snaps to specific angles. It is determined\n * by the following options: `enableRotation` and `constrainRotation`.\n * By default rotation is allowed and its value is snapped to zero when approaching the\n * horizontal.\n *\n * The *center constraint* is determined by the `extent` option. By\n * default the view center is not constrained at all.\n *\n * ### Changing the view state\n *\n * It is important to note that `setZoom`, `setResolution`, `setCenter` and\n * `setRotation` are subject to the above mentioned constraints. As such, it\n * may sometimes not be possible to know in advance the resulting state of the\n * View. For example, calling `setResolution(10)` does not guarantee that\n * `getResolution()` will return `10`.\n *\n * A consequence of this is that, when applying a delta on the view state, one\n * should use `adjustCenter`, `adjustRotation`, `adjustZoom` and `adjustResolution`\n * rather than the corresponding setters. This will let view do its internal\n * computations. Besides, the `adjust*` methods also take an `anchor`\n * argument which allows specifying an origin for the transformation.\n *\n * ### Interacting with the view\n *\n * View constraints are usually only applied when the view is *at rest*, meaning that\n * no interaction or animation is ongoing. As such, if the user puts the view in a\n * state that is not equivalent to a constrained one (e.g. rotating the view when\n * the snap angle is 0), an animation will be triggered at the interaction end to\n * put back the view to a stable state;\n *\n * @api\n */\nclass View extends BaseObject {\n  /**\n   * @param {ViewOptions} [options] View options.\n   */\n  constructor(options) {\n    super();\n\n    /***\n     * @type {ViewOnSignature<import(\"./events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {ViewOnSignature<import(\"./events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {ViewOnSignature<void>}\n     */\n    this.un;\n\n    options = Object.assign({}, options);\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.hints_ = [0, 0];\n\n    /**\n     * @private\n     * @type {Array<Array<Animation>>}\n     */\n    this.animations_ = [];\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.updateAnimationKey_;\n\n    /**\n     * @private\n     * @const\n     * @type {import(\"./proj/Projection.js\").default}\n     */\n    this.projection_ = createProjection(options.projection, 'EPSG:3857');\n\n    /**\n     * @private\n     * @type {import(\"./size.js\").Size}\n     */\n    this.viewportSize_ = [100, 100];\n\n    /**\n     * @private\n     * @type {import(\"./coordinate.js\").Coordinate|undefined}\n     */\n    this.targetCenter_ = null;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.targetResolution_;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.targetRotation_;\n\n    /**\n     * @private\n     * @type {import(\"./coordinate.js\").Coordinate}\n     */\n    this.nextCenter_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.nextResolution_;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.nextRotation_;\n\n    /**\n     * @private\n     * @type {import(\"./coordinate.js\").Coordinate|undefined}\n     */\n    this.cancelAnchor_ = undefined;\n\n    if (options.projection) {\n      disableCoordinateWarning();\n    }\n    if (options.center) {\n      options.center = fromUserCoordinate(options.center, this.projection_);\n    }\n    if (options.extent) {\n      options.extent = fromUserExtent(options.extent, this.projection_);\n    }\n\n    this.applyOptions_(options);\n  }\n\n  /**\n   * Set up the view with the given options.\n   * @param {ViewOptions} options View options.\n   */\n  applyOptions_(options) {\n    const properties = Object.assign({}, options);\n    for (const key in ViewProperty) {\n      delete properties[key];\n    }\n    this.setProperties(properties, true);\n\n    const resolutionConstraintInfo = createResolutionConstraint(options);\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxResolution_ = resolutionConstraintInfo.maxResolution;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.minResolution_ = resolutionConstraintInfo.minResolution;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;\n\n    /**\n     * @private\n     * @type {Array<number>|undefined}\n     */\n    this.resolutions_ = options.resolutions;\n\n    /**\n     * @type {Array<number>|undefined}\n     * @private\n     */\n    this.padding_ = options.padding;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.minZoom_ = resolutionConstraintInfo.minZoom;\n\n    const centerConstraint = createCenterConstraint(options);\n    const resolutionConstraint = resolutionConstraintInfo.constraint;\n    const rotationConstraint = createRotationConstraint(options);\n\n    /**\n     * @private\n     * @type {Constraints}\n     */\n    this.constraints_ = {\n      center: centerConstraint,\n      resolution: resolutionConstraint,\n      rotation: rotationConstraint,\n    };\n\n    this.setRotation(options.rotation !== undefined ? options.rotation : 0);\n    this.setCenterInternal(\n      options.center !== undefined ? options.center : null,\n    );\n    if (options.resolution !== undefined) {\n      this.setResolution(options.resolution);\n    } else if (options.zoom !== undefined) {\n      this.setZoom(options.zoom);\n    }\n  }\n\n  /**\n   * Padding (in css pixels).\n   * If the map viewport is partially covered with other content (overlays) along\n   * its edges, this setting allows to shift the center of the viewport away from that\n   * content. The order of the values in the array is top, right, bottom, left.\n   * The default is no padding, which is equivalent to `[0, 0, 0, 0]`.\n   * @type {Array<number>|undefined}\n   * @api\n   */\n  get padding() {\n    return this.padding_;\n  }\n  set padding(padding) {\n    let oldPadding = this.padding_;\n    this.padding_ = padding;\n    const center = this.getCenterInternal();\n    if (center) {\n      const newPadding = padding || [0, 0, 0, 0];\n      oldPadding = oldPadding || [0, 0, 0, 0];\n      const resolution = this.getResolution();\n      const offsetX =\n        (resolution / 2) *\n        (newPadding[3] - oldPadding[3] + oldPadding[1] - newPadding[1]);\n      const offsetY =\n        (resolution / 2) *\n        (newPadding[0] - oldPadding[0] + oldPadding[2] - newPadding[2]);\n      this.setCenterInternal([center[0] + offsetX, center[1] - offsetY]);\n    }\n  }\n\n  /**\n   * Get an updated version of the view options used to construct the view.  The\n   * current resolution (or zoom), center, and rotation are applied to any stored\n   * options.  The provided options can be used to apply new min/max zoom or\n   * resolution limits.\n   * @param {ViewOptions} newOptions New options to be applied.\n   * @return {ViewOptions} New options updated with the current view state.\n   */\n  getUpdatedOptions_(newOptions) {\n    const options = this.getProperties();\n\n    // preserve resolution (or zoom)\n    if (options.resolution !== undefined) {\n      options.resolution = this.getResolution();\n    } else {\n      options.zoom = this.getZoom();\n    }\n\n    // preserve center\n    options.center = this.getCenterInternal();\n\n    // preserve rotation\n    options.rotation = this.getRotation();\n\n    return Object.assign({}, options, newOptions);\n  }\n\n  /**\n   * Animate the view.  The view's center, zoom (or resolution), and rotation\n   * can be animated for smooth transitions between view states.  For example,\n   * to animate the view to a new zoom level:\n   *\n   *     view.animate({zoom: view.getZoom() + 1});\n   *\n   * By default, the animation lasts one second and uses in-and-out easing.  You\n   * can customize this behavior by including `duration` (in milliseconds) and\n   * `easing` options (see {@link module:ol/easing}).\n   *\n   * To chain together multiple animations, call the method with multiple\n   * animation objects.  For example, to first zoom and then pan:\n   *\n   *     view.animate({zoom: 10}, {center: [0, 0]});\n   *\n   * If you provide a function as the last argument to the animate method, it\n   * will get called at the end of an animation series.  The callback will be\n   * called with `true` if the animation series completed on its own or `false`\n   * if it was cancelled.\n   *\n   * Animations are cancelled by user interactions (e.g. dragging the map) or by\n   * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`\n   * (or another method that calls one of these).\n   *\n   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation\n   *     options.  Multiple animations can be run in series by passing multiple\n   *     options objects.  To run multiple animations in parallel, call the method\n   *     multiple times.  An optional callback can be provided as a final\n   *     argument.  The callback will be called with a boolean indicating whether\n   *     the animation completed without being cancelled.\n   * @api\n   */\n  animate(var_args) {\n    if (this.isDef() && !this.getAnimating()) {\n      this.resolveConstraints(0);\n    }\n    const args = new Array(arguments.length);\n    for (let i = 0; i < args.length; ++i) {\n      let options = arguments[i];\n      if (options.center) {\n        options = Object.assign({}, options);\n        options.center = fromUserCoordinate(\n          options.center,\n          this.getProjection(),\n        );\n      }\n      if (options.anchor) {\n        options = Object.assign({}, options);\n        options.anchor = fromUserCoordinate(\n          options.anchor,\n          this.getProjection(),\n        );\n      }\n      args[i] = options;\n    }\n    this.animateInternal.apply(this, args);\n  }\n\n  /**\n   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation options.\n   */\n  animateInternal(var_args) {\n    let animationCount = arguments.length;\n    let callback;\n    if (\n      animationCount > 1 &&\n      typeof arguments[animationCount - 1] === 'function'\n    ) {\n      callback = arguments[animationCount - 1];\n      --animationCount;\n    }\n\n    let i = 0;\n    for (; i < animationCount && !this.isDef(); ++i) {\n      // if view properties are not yet set, shortcut to the final state\n      const state = arguments[i];\n      if (state.center) {\n        this.setCenterInternal(state.center);\n      }\n      if (state.zoom !== undefined) {\n        this.setZoom(state.zoom);\n      } else if (state.resolution) {\n        this.setResolution(state.resolution);\n      }\n      if (state.rotation !== undefined) {\n        this.setRotation(state.rotation);\n      }\n    }\n    if (i === animationCount) {\n      if (callback) {\n        animationCallback(callback, true);\n      }\n      return;\n    }\n\n    let start = Date.now();\n    let center = this.targetCenter_.slice();\n    let resolution = this.targetResolution_;\n    let rotation = this.targetRotation_;\n    const series = [];\n    for (; i < animationCount; ++i) {\n      const options = /** @type {AnimationOptions} */ (arguments[i]);\n\n      const animation = {\n        start: start,\n        complete: false,\n        anchor: options.anchor,\n        duration: options.duration !== undefined ? options.duration : 1000,\n        easing: options.easing || inAndOut,\n        callback: callback,\n      };\n\n      if (options.center) {\n        animation.sourceCenter = center;\n        animation.targetCenter = options.center.slice();\n        center = animation.targetCenter;\n      }\n\n      if (options.zoom !== undefined) {\n        animation.sourceResolution = resolution;\n        animation.targetResolution = this.getResolutionForZoom(options.zoom);\n        resolution = animation.targetResolution;\n      } else if (options.resolution) {\n        animation.sourceResolution = resolution;\n        animation.targetResolution = options.resolution;\n        resolution = animation.targetResolution;\n      }\n\n      if (options.rotation !== undefined) {\n        animation.sourceRotation = rotation;\n        const delta =\n          modulo(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;\n        animation.targetRotation = rotation + delta;\n        rotation = animation.targetRotation;\n      }\n\n      // check if animation is a no-op\n      if (isNoopAnimation(animation)) {\n        animation.complete = true;\n        // we still push it onto the series for callback handling\n      } else {\n        start += animation.duration;\n      }\n      series.push(animation);\n    }\n    this.animations_.push(series);\n    this.setHint(ViewHint.ANIMATING, 1);\n    this.updateAnimations_();\n  }\n\n  /**\n   * Determine if the view is being animated.\n   * @return {boolean} The view is being animated.\n   * @api\n   */\n  getAnimating() {\n    return this.hints_[ViewHint.ANIMATING] > 0;\n  }\n\n  /**\n   * Determine if the user is interacting with the view, such as panning or zooming.\n   * @return {boolean} The view is being interacted with.\n   * @api\n   */\n  getInteracting() {\n    return this.hints_[ViewHint.INTERACTING] > 0;\n  }\n\n  /**\n   * Cancel any ongoing animations.\n   * @api\n   */\n  cancelAnimations() {\n    this.setHint(ViewHint.ANIMATING, -this.hints_[ViewHint.ANIMATING]);\n    let anchor;\n    for (let i = 0, ii = this.animations_.length; i < ii; ++i) {\n      const series = this.animations_[i];\n      if (series[0].callback) {\n        animationCallback(series[0].callback, false);\n      }\n      if (!anchor) {\n        for (let j = 0, jj = series.length; j < jj; ++j) {\n          const animation = series[j];\n          if (!animation.complete) {\n            anchor = animation.anchor;\n            break;\n          }\n        }\n      }\n    }\n    this.animations_.length = 0;\n    this.cancelAnchor_ = anchor;\n    this.nextCenter_ = null;\n    this.nextResolution_ = NaN;\n    this.nextRotation_ = NaN;\n  }\n\n  /**\n   * Update all animations.\n   */\n  updateAnimations_() {\n    if (this.updateAnimationKey_ !== undefined) {\n      cancelAnimationFrame(this.updateAnimationKey_);\n      this.updateAnimationKey_ = undefined;\n    }\n    if (!this.getAnimating()) {\n      return;\n    }\n    const now = Date.now();\n    let more = false;\n    for (let i = this.animations_.length - 1; i >= 0; --i) {\n      const series = this.animations_[i];\n      let seriesComplete = true;\n      for (let j = 0, jj = series.length; j < jj; ++j) {\n        const animation = series[j];\n        if (animation.complete) {\n          continue;\n        }\n        const elapsed = now - animation.start;\n        let fraction =\n          animation.duration > 0 ? elapsed / animation.duration : 1;\n        if (fraction >= 1) {\n          animation.complete = true;\n          fraction = 1;\n        } else {\n          seriesComplete = false;\n        }\n        const progress = animation.easing(fraction);\n        if (animation.sourceCenter) {\n          const x0 = animation.sourceCenter[0];\n          const y0 = animation.sourceCenter[1];\n          const x1 = animation.targetCenter[0];\n          const y1 = animation.targetCenter[1];\n          this.nextCenter_ = animation.targetCenter;\n          const x = x0 + progress * (x1 - x0);\n          const y = y0 + progress * (y1 - y0);\n          this.targetCenter_ = [x, y];\n        }\n        if (animation.sourceResolution && animation.targetResolution) {\n          const resolution =\n            progress === 1\n              ? animation.targetResolution\n              : animation.sourceResolution +\n                progress *\n                  (animation.targetResolution - animation.sourceResolution);\n          if (animation.anchor) {\n            const size = this.getViewportSize_(this.getRotation());\n            const constrainedResolution = this.constraints_.resolution(\n              resolution,\n              0,\n              size,\n              true,\n            );\n            this.targetCenter_ = this.calculateCenterZoom(\n              constrainedResolution,\n              animation.anchor,\n            );\n          }\n          this.nextResolution_ = animation.targetResolution;\n          this.targetResolution_ = resolution;\n          this.applyTargetState_(true);\n        }\n        if (\n          animation.sourceRotation !== undefined &&\n          animation.targetRotation !== undefined\n        ) {\n          const rotation =\n            progress === 1\n              ? modulo(animation.targetRotation + Math.PI, 2 * Math.PI) -\n                Math.PI\n              : animation.sourceRotation +\n                progress *\n                  (animation.targetRotation - animation.sourceRotation);\n          if (animation.anchor) {\n            const constrainedRotation = this.constraints_.rotation(\n              rotation,\n              true,\n            );\n            this.targetCenter_ = this.calculateCenterRotate(\n              constrainedRotation,\n              animation.anchor,\n            );\n          }\n          this.nextRotation_ = animation.targetRotation;\n          this.targetRotation_ = rotation;\n        }\n        this.applyTargetState_(true);\n        more = true;\n        if (!animation.complete) {\n          break;\n        }\n      }\n      if (seriesComplete) {\n        this.animations_[i] = null;\n        this.setHint(ViewHint.ANIMATING, -1);\n        this.nextCenter_ = null;\n        this.nextResolution_ = NaN;\n        this.nextRotation_ = NaN;\n        const callback = series[0].callback;\n        if (callback) {\n          animationCallback(callback, true);\n        }\n      }\n    }\n    // prune completed series\n    this.animations_ = this.animations_.filter(Boolean);\n    if (more && this.updateAnimationKey_ === undefined) {\n      this.updateAnimationKey_ = requestAnimationFrame(\n        this.updateAnimations_.bind(this),\n      );\n    }\n  }\n\n  /**\n   * @param {number} rotation Target rotation.\n   * @param {import(\"./coordinate.js\").Coordinate} anchor Rotation anchor.\n   * @return {import(\"./coordinate.js\").Coordinate|undefined} Center for rotation and anchor.\n   */\n  calculateCenterRotate(rotation, anchor) {\n    let center;\n    const currentCenter = this.getCenterInternal();\n    if (currentCenter !== undefined) {\n      center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];\n      rotateCoordinate(center, rotation - this.getRotation());\n      addCoordinate(center, anchor);\n    }\n    return center;\n  }\n\n  /**\n   * @param {number} resolution Target resolution.\n   * @param {import(\"./coordinate.js\").Coordinate} anchor Zoom anchor.\n   * @return {import(\"./coordinate.js\").Coordinate|undefined} Center for resolution and anchor.\n   */\n  calculateCenterZoom(resolution, anchor) {\n    let center;\n    const currentCenter = this.getCenterInternal();\n    const currentResolution = this.getResolution();\n    if (currentCenter !== undefined && currentResolution !== undefined) {\n      const x =\n        anchor[0] -\n        (resolution * (anchor[0] - currentCenter[0])) / currentResolution;\n      const y =\n        anchor[1] -\n        (resolution * (anchor[1] - currentCenter[1])) / currentResolution;\n      center = [x, y];\n    }\n    return center;\n  }\n\n  /**\n   * Returns the current viewport size.\n   * @private\n   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size\n   * @return {import(\"./size.js\").Size} Viewport size or `[100, 100]` when no viewport is found.\n   */\n  getViewportSize_(rotation) {\n    const size = this.viewportSize_;\n    if (rotation) {\n      const w = size[0];\n      const h = size[1];\n      return [\n        Math.abs(w * Math.cos(rotation)) + Math.abs(h * Math.sin(rotation)),\n        Math.abs(w * Math.sin(rotation)) + Math.abs(h * Math.cos(rotation)),\n      ];\n    }\n    return size;\n  }\n\n  /**\n   * Stores the viewport size on the view. The viewport size is not read every time from the DOM\n   * to avoid performance hit and layout reflow.\n   * This should be done on map size change.\n   * Note: the constraints are not resolved during an animation to avoid stopping it\n   * @param {import(\"./size.js\").Size} [size] Viewport size; if undefined, [100, 100] is assumed\n   */\n  setViewportSize(size) {\n    this.viewportSize_ = Array.isArray(size) ? size.slice() : [100, 100];\n    if (!this.getAnimating()) {\n      this.resolveConstraints(0);\n    }\n  }\n\n  /**\n   * Get the view center.\n   * @return {import(\"./coordinate.js\").Coordinate|undefined} The center of the view.\n   * @observable\n   * @api\n   */\n  getCenter() {\n    const center = this.getCenterInternal();\n    if (!center) {\n      return center;\n    }\n    return toUserCoordinate(center, this.getProjection());\n  }\n\n  /**\n   * Get the view center without transforming to user projection.\n   * @return {import(\"./coordinate.js\").Coordinate|undefined} The center of the view.\n   */\n  getCenterInternal() {\n    return /** @type {import(\"./coordinate.js\").Coordinate|undefined} */ (\n      this.get(ViewProperty.CENTER)\n    );\n  }\n\n  /**\n   * @return {Constraints} Constraints.\n   */\n  getConstraints() {\n    return this.constraints_;\n  }\n\n  /**\n   * @return {boolean} Resolution constraint is set\n   */\n  getConstrainResolution() {\n    return this.get('constrainResolution');\n  }\n\n  /**\n   * @param {Array<number>} [hints] Destination array.\n   * @return {Array<number>} Hint.\n   */\n  getHints(hints) {\n    if (hints !== undefined) {\n      hints[0] = this.hints_[0];\n      hints[1] = this.hints_[1];\n      return hints;\n    }\n    return this.hints_.slice();\n  }\n\n  /**\n   * Calculate the extent for the current view state and the passed box size.\n   * @param {import(\"./size.js\").Size} [size] The pixel dimensions of the box\n   * into which the calculated extent should fit. Defaults to the size of the\n   * map the view is associated with.\n   * If no map or multiple maps are connected to the view, provide the desired\n   * box size (e.g. `map.getSize()`).\n   * @return {import(\"./extent.js\").Extent} Extent.\n   * @api\n   */\n  calculateExtent(size) {\n    const extent = this.calculateExtentInternal(size);\n    return toUserExtent(extent, this.getProjection());\n  }\n\n  /**\n   * @param {import(\"./size.js\").Size} [size] Box pixel size. If not provided,\n   * the map's last known viewport size will be used.\n   * @return {import(\"./extent.js\").Extent} Extent.\n   */\n  calculateExtentInternal(size) {\n    size = size || this.getViewportSizeMinusPadding_();\n    const center = /** @type {!import(\"./coordinate.js\").Coordinate} */ (\n      this.getCenterInternal()\n    );\n    assert(center, 'The view center is not defined');\n    const resolution = /** @type {!number} */ (this.getResolution());\n    assert(resolution !== undefined, 'The view resolution is not defined');\n    const rotation = /** @type {!number} */ (this.getRotation());\n    assert(rotation !== undefined, 'The view rotation is not defined');\n\n    return getForViewAndSize(center, resolution, rotation, size);\n  }\n\n  /**\n   * Get the maximum resolution of the view.\n   * @return {number} The maximum resolution of the view.\n   * @api\n   */\n  getMaxResolution() {\n    return this.maxResolution_;\n  }\n\n  /**\n   * Get the minimum resolution of the view.\n   * @return {number} The minimum resolution of the view.\n   * @api\n   */\n  getMinResolution() {\n    return this.minResolution_;\n  }\n\n  /**\n   * Get the maximum zoom level for the view.\n   * @return {number} The maximum zoom level.\n   * @api\n   */\n  getMaxZoom() {\n    return /** @type {number} */ (\n      this.getZoomForResolution(this.minResolution_)\n    );\n  }\n\n  /**\n   * Set a new maximum zoom level for the view.\n   * @param {number} zoom The maximum zoom level.\n   * @api\n   */\n  setMaxZoom(zoom) {\n    this.applyOptions_(this.getUpdatedOptions_({maxZoom: zoom}));\n  }\n\n  /**\n   * Get the minimum zoom level for the view.\n   * @return {number} The minimum zoom level.\n   * @api\n   */\n  getMinZoom() {\n    return /** @type {number} */ (\n      this.getZoomForResolution(this.maxResolution_)\n    );\n  }\n\n  /**\n   * Set a new minimum zoom level for the view.\n   * @param {number} zoom The minimum zoom level.\n   * @api\n   */\n  setMinZoom(zoom) {\n    this.applyOptions_(this.getUpdatedOptions_({minZoom: zoom}));\n  }\n\n  /**\n   * Set whether the view should allow intermediary zoom levels.\n   * @param {boolean} enabled Whether the resolution is constrained.\n   * @api\n   */\n  setConstrainResolution(enabled) {\n    this.applyOptions_(this.getUpdatedOptions_({constrainResolution: enabled}));\n  }\n\n  /**\n   * Get the view projection.\n   * @return {import(\"./proj/Projection.js\").default} The projection of the view.\n   * @api\n   */\n  getProjection() {\n    return this.projection_;\n  }\n\n  /**\n   * Get the view resolution.\n   * @return {number|undefined} The resolution of the view.\n   * @observable\n   * @api\n   */\n  getResolution() {\n    return /** @type {number|undefined} */ (this.get(ViewProperty.RESOLUTION));\n  }\n\n  /**\n   * Get the resolutions for the view. This returns the array of resolutions\n   * passed to the constructor of the View, or undefined if none were given.\n   * @return {Array<number>|undefined} The resolutions of the view.\n   * @api\n   */\n  getResolutions() {\n    return this.resolutions_;\n  }\n\n  /**\n   * Get the resolution for a provided extent (in map units) and size (in pixels).\n   * @param {import(\"./extent.js\").Extent} extent Extent.\n   * @param {import(\"./size.js\").Size} [size] Box pixel size.\n   * @return {number} The resolution at which the provided extent will render at\n   *     the given size.\n   * @api\n   */\n  getResolutionForExtent(extent, size) {\n    return this.getResolutionForExtentInternal(\n      fromUserExtent(extent, this.getProjection()),\n      size,\n    );\n  }\n\n  /**\n   * Get the resolution for a provided extent (in map units) and size (in pixels).\n   * @param {import(\"./extent.js\").Extent} extent Extent.\n   * @param {import(\"./size.js\").Size} [size] Box pixel size.\n   * @return {number} The resolution at which the provided extent will render at\n   *     the given size.\n   */\n  getResolutionForExtentInternal(extent, size) {\n    size = size || this.getViewportSizeMinusPadding_();\n    const xResolution = getWidth(extent) / size[0];\n    const yResolution = getHeight(extent) / size[1];\n    return Math.max(xResolution, yResolution);\n  }\n\n  /**\n   * Return a function that returns a value between 0 and 1 for a\n   * resolution. Exponential scaling is assumed.\n   * @param {number} [power] Power.\n   * @return {function(number): number} Resolution for value function.\n   */\n  getResolutionForValueFunction(power) {\n    power = power || 2;\n    const maxResolution = this.getConstrainedResolution(this.maxResolution_);\n    const minResolution = this.minResolution_;\n    const max = Math.log(maxResolution / minResolution) / Math.log(power);\n    return (\n      /**\n       * @param {number} value Value.\n       * @return {number} Resolution.\n       */\n      function (value) {\n        const resolution = maxResolution / Math.pow(power, value * max);\n        return resolution;\n      }\n    );\n  }\n\n  /**\n   * Get the view rotation.\n   * @return {number} The rotation of the view in radians.\n   * @observable\n   * @api\n   */\n  getRotation() {\n    return /** @type {number} */ (this.get(ViewProperty.ROTATION));\n  }\n\n  /**\n   * Return a function that returns a resolution for a value between\n   * 0 and 1. Exponential scaling is assumed.\n   * @param {number} [power] Power.\n   * @return {function(number): number} Value for resolution function.\n   */\n  getValueForResolutionFunction(power) {\n    const logPower = Math.log(power || 2);\n    const maxResolution = this.getConstrainedResolution(this.maxResolution_);\n    const minResolution = this.minResolution_;\n    const max = Math.log(maxResolution / minResolution) / logPower;\n    return (\n      /**\n       * @param {number} resolution Resolution.\n       * @return {number} Value.\n       */\n      function (resolution) {\n        const value = Math.log(maxResolution / resolution) / logPower / max;\n        return value;\n      }\n    );\n  }\n\n  /**\n   * Returns the size of the viewport minus padding.\n   * @private\n   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size\n   * @return {import(\"./size.js\").Size} Viewport size reduced by the padding.\n   */\n  getViewportSizeMinusPadding_(rotation) {\n    let size = this.getViewportSize_(rotation);\n    const padding = this.padding_;\n    if (padding) {\n      size = [\n        size[0] - padding[1] - padding[3],\n        size[1] - padding[0] - padding[2],\n      ];\n    }\n    return size;\n  }\n\n  /**\n   * @return {State} View state.\n   */\n  getState() {\n    const projection = this.getProjection();\n    const resolution = this.getResolution();\n    const rotation = this.getRotation();\n    let center = /** @type {import(\"./coordinate.js\").Coordinate} */ (\n      this.getCenterInternal()\n    );\n    const padding = this.padding_;\n    if (padding) {\n      const reducedSize = this.getViewportSizeMinusPadding_();\n      center = calculateCenterOn(\n        center,\n        this.getViewportSize_(),\n        [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]],\n        resolution,\n        rotation,\n      );\n    }\n    return {\n      center: center.slice(0),\n      projection: projection !== undefined ? projection : null,\n      resolution: resolution,\n      nextCenter: this.nextCenter_,\n      nextResolution: this.nextResolution_,\n      nextRotation: this.nextRotation_,\n      rotation: rotation,\n      zoom: this.getZoom(),\n    };\n  }\n\n  /**\n   * @return {ViewStateLayerStateExtent} Like `FrameState`, but just `viewState` and `extent`.\n   */\n  getViewStateAndExtent() {\n    return {\n      viewState: this.getState(),\n      extent: this.calculateExtent(),\n    };\n  }\n\n  /**\n   * Get the current zoom level. This method may return non-integer zoom levels\n   * if the view does not constrain the resolution, or if an interaction or\n   * animation is underway.\n   * @return {number|undefined} Zoom.\n   * @api\n   */\n  getZoom() {\n    let zoom;\n    const resolution = this.getResolution();\n    if (resolution !== undefined) {\n      zoom = this.getZoomForResolution(resolution);\n    }\n    return zoom;\n  }\n\n  /**\n   * Get the zoom level for a resolution.\n   * @param {number} resolution The resolution.\n   * @return {number|undefined} The zoom level for the provided resolution.\n   * @api\n   */\n  getZoomForResolution(resolution) {\n    let offset = this.minZoom_ || 0;\n    let max, zoomFactor;\n    if (this.resolutions_) {\n      const nearest = linearFindNearest(this.resolutions_, resolution, 1);\n      offset = nearest;\n      max = this.resolutions_[nearest];\n      if (nearest == this.resolutions_.length - 1) {\n        zoomFactor = 2;\n      } else {\n        zoomFactor = max / this.resolutions_[nearest + 1];\n      }\n    } else {\n      max = this.maxResolution_;\n      zoomFactor = this.zoomFactor_;\n    }\n    return offset + Math.log(max / resolution) / Math.log(zoomFactor);\n  }\n\n  /**\n   * Get the resolution for a zoom level.\n   * @param {number} zoom Zoom level.\n   * @return {number} The view resolution for the provided zoom level.\n   * @api\n   */\n  getResolutionForZoom(zoom) {\n    if (this.resolutions_) {\n      if (this.resolutions_.length <= 1) {\n        return 0;\n      }\n      const baseLevel = clamp(\n        Math.floor(zoom),\n        0,\n        this.resolutions_.length - 2,\n      );\n      const zoomFactor =\n        this.resolutions_[baseLevel] / this.resolutions_[baseLevel + 1];\n      return (\n        this.resolutions_[baseLevel] /\n        Math.pow(zoomFactor, clamp(zoom - baseLevel, 0, 1))\n      );\n    }\n    return (\n      this.maxResolution_ / Math.pow(this.zoomFactor_, zoom - this.minZoom_)\n    );\n  }\n\n  /**\n   * Fit the given geometry or extent based on the given map size and border.\n   * The size is pixel dimensions of the box to fit the extent into.\n   * In most cases you will want to use the map size, that is `map.getSize()`.\n   * Takes care of the map angle.\n   * @param {import(\"./geom/SimpleGeometry.js\").default|import(\"./extent.js\").Extent} geometryOrExtent The geometry or\n   *     extent to fit the view to.\n   * @param {FitOptions} [options] Options.\n   * @api\n   */\n  fit(geometryOrExtent, options) {\n    /** @type {import(\"./geom/SimpleGeometry.js\").default} */\n    let geometry;\n    assert(\n      Array.isArray(geometryOrExtent) ||\n        typeof (/** @type {?} */ (geometryOrExtent).getSimplifiedGeometry) ===\n          'function',\n      'Invalid extent or geometry provided as `geometry`',\n    );\n    if (Array.isArray(geometryOrExtent)) {\n      assert(\n        !isEmpty(geometryOrExtent),\n        'Cannot fit empty extent provided as `geometry`',\n      );\n      const extent = fromUserExtent(geometryOrExtent, this.getProjection());\n      geometry = polygonFromExtent(extent);\n    } else if (geometryOrExtent.getType() === 'Circle') {\n      const extent = fromUserExtent(\n        geometryOrExtent.getExtent(),\n        this.getProjection(),\n      );\n      geometry = polygonFromExtent(extent);\n      geometry.rotate(this.getRotation(), getCenter(extent));\n    } else {\n      const userProjection = getUserProjection();\n      if (userProjection) {\n        geometry = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (\n          geometryOrExtent\n            .clone()\n            .transform(userProjection, this.getProjection())\n        );\n      } else {\n        geometry = geometryOrExtent;\n      }\n    }\n\n    this.fitInternal(geometry, options);\n  }\n\n  /**\n   * Calculate rotated extent\n   * @param {import(\"./geom/SimpleGeometry.js\").default} geometry The geometry.\n   * @return {import(\"./extent\").Extent} The rotated extent for the geometry.\n   */\n  rotatedExtentForGeometry(geometry) {\n    const rotation = this.getRotation();\n    const cosAngle = Math.cos(rotation);\n    const sinAngle = Math.sin(-rotation);\n    const coords = geometry.getFlatCoordinates();\n    const stride = geometry.getStride();\n    let minRotX = +Infinity;\n    let minRotY = +Infinity;\n    let maxRotX = -Infinity;\n    let maxRotY = -Infinity;\n    for (let i = 0, ii = coords.length; i < ii; i += stride) {\n      const rotX = coords[i] * cosAngle - coords[i + 1] * sinAngle;\n      const rotY = coords[i] * sinAngle + coords[i + 1] * cosAngle;\n      minRotX = Math.min(minRotX, rotX);\n      minRotY = Math.min(minRotY, rotY);\n      maxRotX = Math.max(maxRotX, rotX);\n      maxRotY = Math.max(maxRotY, rotY);\n    }\n    return [minRotX, minRotY, maxRotX, maxRotY];\n  }\n\n  /**\n   * @param {import(\"./geom/SimpleGeometry.js\").default} geometry The geometry.\n   * @param {FitOptions} [options] Options.\n   */\n  fitInternal(geometry, options) {\n    options = options || {};\n    let size = options.size;\n    if (!size) {\n      size = this.getViewportSizeMinusPadding_();\n    }\n    const padding =\n      options.padding !== undefined ? options.padding : [0, 0, 0, 0];\n    const nearest = options.nearest !== undefined ? options.nearest : false;\n    let minResolution;\n    if (options.minResolution !== undefined) {\n      minResolution = options.minResolution;\n    } else if (options.maxZoom !== undefined) {\n      minResolution = this.getResolutionForZoom(options.maxZoom);\n    } else {\n      minResolution = 0;\n    }\n\n    const rotatedExtent = this.rotatedExtentForGeometry(geometry);\n\n    // calculate resolution\n    let resolution = this.getResolutionForExtentInternal(rotatedExtent, [\n      size[0] - padding[1] - padding[3],\n      size[1] - padding[0] - padding[2],\n    ]);\n    resolution = isNaN(resolution)\n      ? minResolution\n      : Math.max(resolution, minResolution);\n    resolution = this.getConstrainedResolution(resolution, nearest ? 0 : 1);\n\n    // calculate center\n    const rotation = this.getRotation();\n    const sinAngle = Math.sin(rotation);\n    const cosAngle = Math.cos(rotation);\n    const centerRot = getCenter(rotatedExtent);\n    centerRot[0] += ((padding[1] - padding[3]) / 2) * resolution;\n    centerRot[1] += ((padding[0] - padding[2]) / 2) * resolution;\n    const centerX = centerRot[0] * cosAngle - centerRot[1] * sinAngle;\n    const centerY = centerRot[1] * cosAngle + centerRot[0] * sinAngle;\n    const center = this.getConstrainedCenter([centerX, centerY], resolution);\n    const callback = options.callback ? options.callback : VOID;\n\n    if (options.duration !== undefined) {\n      this.animateInternal(\n        {\n          resolution: resolution,\n          center: center,\n          duration: options.duration,\n          easing: options.easing,\n        },\n        callback,\n      );\n    } else {\n      this.targetResolution_ = resolution;\n      this.targetCenter_ = center;\n      this.applyTargetState_(false, true);\n      animationCallback(callback, true);\n    }\n  }\n\n  /**\n   * Center on coordinate and view position.\n   * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"./size.js\").Size} size Box pixel size.\n   * @param {import(\"./pixel.js\").Pixel} position Position on the view to center on.\n   * @api\n   */\n  centerOn(coordinate, size, position) {\n    this.centerOnInternal(\n      fromUserCoordinate(coordinate, this.getProjection()),\n      size,\n      position,\n    );\n  }\n\n  /**\n   * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"./size.js\").Size} size Box pixel size.\n   * @param {import(\"./pixel.js\").Pixel} position Position on the view to center on.\n   */\n  centerOnInternal(coordinate, size, position) {\n    this.setCenterInternal(\n      calculateCenterOn(\n        coordinate,\n        size,\n        position,\n        this.getResolution(),\n        this.getRotation(),\n      ),\n    );\n  }\n\n  /**\n   * Calculates the shift between map and viewport center.\n   * @param {import(\"./coordinate.js\").Coordinate} center Center.\n   * @param {number} resolution Resolution.\n   * @param {number} rotation Rotation.\n   * @param {import(\"./size.js\").Size} size Size.\n   * @return {Array<number>|undefined} Center shift.\n   */\n  calculateCenterShift(center, resolution, rotation, size) {\n    let centerShift;\n    const padding = this.padding_;\n    if (padding && center) {\n      const reducedSize = this.getViewportSizeMinusPadding_(-rotation);\n      const shiftedCenter = calculateCenterOn(\n        center,\n        size,\n        [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]],\n        resolution,\n        rotation,\n      );\n      centerShift = [\n        center[0] - shiftedCenter[0],\n        center[1] - shiftedCenter[1],\n      ];\n    }\n    return centerShift;\n  }\n\n  /**\n   * @return {boolean} Is defined.\n   */\n  isDef() {\n    return !!this.getCenterInternal() && this.getResolution() !== undefined;\n  }\n\n  /**\n   * Adds relative coordinates to the center of the view. Any extent constraint will apply.\n   * @param {import(\"./coordinate.js\").Coordinate} deltaCoordinates Relative value to add.\n   * @api\n   */\n  adjustCenter(deltaCoordinates) {\n    const center = toUserCoordinate(this.targetCenter_, this.getProjection());\n    this.setCenter([\n      center[0] + deltaCoordinates[0],\n      center[1] + deltaCoordinates[1],\n    ]);\n  }\n\n  /**\n   * Adds relative coordinates to the center of the view. Any extent constraint will apply.\n   * @param {import(\"./coordinate.js\").Coordinate} deltaCoordinates Relative value to add.\n   */\n  adjustCenterInternal(deltaCoordinates) {\n    const center = this.targetCenter_;\n    this.setCenterInternal([\n      center[0] + deltaCoordinates[0],\n      center[1] + deltaCoordinates[1],\n    ]);\n  }\n\n  /**\n   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution\n   * constraint will apply.\n   * @param {number} ratio The ratio to apply on the view resolution.\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The origin of the transformation.\n   * @api\n   */\n  adjustResolution(ratio, anchor) {\n    anchor = anchor && fromUserCoordinate(anchor, this.getProjection());\n    this.adjustResolutionInternal(ratio, anchor);\n  }\n\n  /**\n   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution\n   * constraint will apply.\n   * @param {number} ratio The ratio to apply on the view resolution.\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The origin of the transformation.\n   */\n  adjustResolutionInternal(ratio, anchor) {\n    const isMoving = this.getAnimating() || this.getInteracting();\n    const size = this.getViewportSize_(this.getRotation());\n    const newResolution = this.constraints_.resolution(\n      this.targetResolution_ * ratio,\n      0,\n      size,\n      isMoving,\n    );\n\n    if (anchor) {\n      this.targetCenter_ = this.calculateCenterZoom(newResolution, anchor);\n    }\n\n    this.targetResolution_ *= ratio;\n    this.applyTargetState_();\n  }\n\n  /**\n   * Adds a value to the view zoom level, optionally using an anchor. Any resolution\n   * constraint will apply.\n   * @param {number} delta Relative value to add to the zoom level.\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The origin of the transformation.\n   * @api\n   */\n  adjustZoom(delta, anchor) {\n    this.adjustResolution(Math.pow(this.zoomFactor_, -delta), anchor);\n  }\n\n  /**\n   * Adds a value to the view rotation, optionally using an anchor. Any rotation\n   * constraint will apply.\n   * @param {number} delta Relative value to add to the zoom rotation, in radians.\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The rotation center.\n   * @api\n   */\n  adjustRotation(delta, anchor) {\n    if (anchor) {\n      anchor = fromUserCoordinate(anchor, this.getProjection());\n    }\n    this.adjustRotationInternal(delta, anchor);\n  }\n\n  /**\n   * @param {number} delta Relative value to add to the zoom rotation, in radians.\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The rotation center.\n   */\n  adjustRotationInternal(delta, anchor) {\n    const isMoving = this.getAnimating() || this.getInteracting();\n    const newRotation = this.constraints_.rotation(\n      this.targetRotation_ + delta,\n      isMoving,\n    );\n    if (anchor) {\n      this.targetCenter_ = this.calculateCenterRotate(newRotation, anchor);\n    }\n    this.targetRotation_ += delta;\n    this.applyTargetState_();\n  }\n\n  /**\n   * Set the center of the current view. Any extent constraint will apply.\n   * @param {import(\"./coordinate.js\").Coordinate|undefined} center The center of the view.\n   * @observable\n   * @api\n   */\n  setCenter(center) {\n    this.setCenterInternal(\n      center ? fromUserCoordinate(center, this.getProjection()) : center,\n    );\n  }\n\n  /**\n   * Set the center using the view projection (not the user projection).\n   * @param {import(\"./coordinate.js\").Coordinate|undefined} center The center of the view.\n   */\n  setCenterInternal(center) {\n    this.targetCenter_ = center;\n    this.applyTargetState_();\n  }\n\n  /**\n   * @param {import(\"./ViewHint.js\").default} hint Hint.\n   * @param {number} delta Delta.\n   * @return {number} New value.\n   */\n  setHint(hint, delta) {\n    this.hints_[hint] += delta;\n    this.changed();\n    return this.hints_[hint];\n  }\n\n  /**\n   * Set the resolution for this view. Any resolution constraint will apply.\n   * @param {number|undefined} resolution The resolution of the view.\n   * @observable\n   * @api\n   */\n  setResolution(resolution) {\n    this.targetResolution_ = resolution;\n    this.applyTargetState_();\n  }\n\n  /**\n   * Set the rotation for this view. Any rotation constraint will apply.\n   * @param {number} rotation The rotation of the view in radians.\n   * @observable\n   * @api\n   */\n  setRotation(rotation) {\n    this.targetRotation_ = rotation;\n    this.applyTargetState_();\n  }\n\n  /**\n   * Zoom to a specific zoom level. Any resolution constrain will apply.\n   * @param {number} zoom Zoom level.\n   * @api\n   */\n  setZoom(zoom) {\n    this.setResolution(this.getResolutionForZoom(zoom));\n  }\n\n  /**\n   * Recompute rotation/resolution/center based on target values.\n   * Note: we have to compute rotation first, then resolution and center considering that\n   * parameters can influence one another in case a view extent constraint is present.\n   * @param {boolean} [doNotCancelAnims] Do not cancel animations.\n   * @param {boolean} [forceMoving] Apply constraints as if the view is moving.\n   * @private\n   */\n  applyTargetState_(doNotCancelAnims, forceMoving) {\n    const isMoving =\n      this.getAnimating() || this.getInteracting() || forceMoving;\n\n    // compute rotation\n    const newRotation = this.constraints_.rotation(\n      this.targetRotation_,\n      isMoving,\n    );\n    const size = this.getViewportSize_(newRotation);\n    const newResolution = this.constraints_.resolution(\n      this.targetResolution_,\n      0,\n      size,\n      isMoving,\n    );\n    const newCenter = this.constraints_.center(\n      this.targetCenter_,\n      newResolution,\n      size,\n      isMoving,\n      this.calculateCenterShift(\n        this.targetCenter_,\n        newResolution,\n        newRotation,\n        size,\n      ),\n    );\n\n    if (this.get(ViewProperty.ROTATION) !== newRotation) {\n      this.set(ViewProperty.ROTATION, newRotation);\n    }\n    if (this.get(ViewProperty.RESOLUTION) !== newResolution) {\n      this.set(ViewProperty.RESOLUTION, newResolution);\n      this.set('zoom', this.getZoom(), true);\n    }\n    if (\n      !newCenter ||\n      !this.get(ViewProperty.CENTER) ||\n      !equals(this.get(ViewProperty.CENTER), newCenter)\n    ) {\n      this.set(ViewProperty.CENTER, newCenter);\n    }\n\n    if (this.getAnimating() && !doNotCancelAnims) {\n      this.cancelAnimations();\n    }\n    this.cancelAnchor_ = undefined;\n  }\n\n  /**\n   * If any constraints need to be applied, an animation will be triggered.\n   * This is typically done on interaction end.\n   * Note: calling this with a duration of 0 will apply the constrained values straight away,\n   * without animation.\n   * @param {number} [duration] The animation duration in ms.\n   * @param {number} [resolutionDirection] Which direction to zoom.\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The origin of the transformation.\n   */\n  resolveConstraints(duration, resolutionDirection, anchor) {\n    duration = duration !== undefined ? duration : 200;\n    const direction = resolutionDirection || 0;\n\n    const newRotation = this.constraints_.rotation(this.targetRotation_);\n    const size = this.getViewportSize_(newRotation);\n    const newResolution = this.constraints_.resolution(\n      this.targetResolution_,\n      direction,\n      size,\n    );\n    const newCenter = this.constraints_.center(\n      this.targetCenter_,\n      newResolution,\n      size,\n      false,\n      this.calculateCenterShift(\n        this.targetCenter_,\n        newResolution,\n        newRotation,\n        size,\n      ),\n    );\n\n    if (duration === 0 && !this.cancelAnchor_) {\n      this.targetResolution_ = newResolution;\n      this.targetRotation_ = newRotation;\n      this.targetCenter_ = newCenter;\n      this.applyTargetState_();\n      return;\n    }\n\n    anchor = anchor || (duration === 0 ? this.cancelAnchor_ : undefined);\n    this.cancelAnchor_ = undefined;\n\n    if (\n      this.getResolution() !== newResolution ||\n      this.getRotation() !== newRotation ||\n      !this.getCenterInternal() ||\n      !equals(this.getCenterInternal(), newCenter)\n    ) {\n      if (this.getAnimating()) {\n        this.cancelAnimations();\n      }\n\n      this.animateInternal({\n        rotation: newRotation,\n        center: newCenter,\n        resolution: newResolution,\n        duration: duration,\n        easing: easeOut,\n        anchor: anchor,\n      });\n    }\n  }\n\n  /**\n   * Notify the View that an interaction has started.\n   * The view state will be resolved to a stable one if needed\n   * (depending on its constraints).\n   * @api\n   */\n  beginInteraction() {\n    this.resolveConstraints(0);\n\n    this.setHint(ViewHint.INTERACTING, 1);\n  }\n\n  /**\n   * Notify the View that an interaction has ended. The view state will be resolved\n   * to a stable one if needed (depending on its constraints).\n   * @param {number} [duration] Animation duration in ms.\n   * @param {number} [resolutionDirection] Which direction to zoom.\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The origin of the transformation.\n   * @api\n   */\n  endInteraction(duration, resolutionDirection, anchor) {\n    anchor = anchor && fromUserCoordinate(anchor, this.getProjection());\n    this.endInteractionInternal(duration, resolutionDirection, anchor);\n  }\n\n  /**\n   * Notify the View that an interaction has ended. The view state will be resolved\n   * to a stable one if needed (depending on its constraints).\n   * @param {number} [duration] Animation duration in ms.\n   * @param {number} [resolutionDirection] Which direction to zoom.\n   * @param {import(\"./coordinate.js\").Coordinate} [anchor] The origin of the transformation.\n   */\n  endInteractionInternal(duration, resolutionDirection, anchor) {\n    if (!this.getInteracting()) {\n      return;\n    }\n    this.setHint(ViewHint.INTERACTING, -1);\n    this.resolveConstraints(duration, resolutionDirection, anchor);\n  }\n\n  /**\n   * Get a valid position for the view center according to the current constraints.\n   * @param {import(\"./coordinate.js\").Coordinate|undefined} targetCenter Target center position.\n   * @param {number} [targetResolution] Target resolution. If not supplied, the current one will be used.\n   * This is useful to guess a valid center position at a different zoom level.\n   * @return {import(\"./coordinate.js\").Coordinate|undefined} Valid center position.\n   */\n  getConstrainedCenter(targetCenter, targetResolution) {\n    const size = this.getViewportSize_(this.getRotation());\n    return this.constraints_.center(\n      targetCenter,\n      targetResolution || this.getResolution(),\n      size,\n    );\n  }\n\n  /**\n   * Get a valid zoom level according to the current view constraints.\n   * @param {number|undefined} targetZoom Target zoom.\n   * @param {number} [direction=0] Indicate which resolution should be used\n   * by a renderer if the view resolution does not match any resolution of the tile source.\n   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution\n   * will be used. If -1, the nearest higher resolution will be used.\n   * @return {number|undefined} Valid zoom level.\n   */\n  getConstrainedZoom(targetZoom, direction) {\n    const targetRes = this.getResolutionForZoom(targetZoom);\n    return this.getZoomForResolution(\n      this.getConstrainedResolution(targetRes, direction),\n    );\n  }\n\n  /**\n   * Get a valid resolution according to the current view constraints.\n   * @param {number|undefined} targetResolution Target resolution.\n   * @param {number} [direction=0] Indicate which resolution should be used\n   * by a renderer if the view resolution does not match any resolution of the tile source.\n   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution\n   * will be used. If -1, the nearest higher resolution will be used.\n   * @return {number|undefined} Valid resolution.\n   */\n  getConstrainedResolution(targetResolution, direction) {\n    direction = direction || 0;\n    const size = this.getViewportSize_(this.getRotation());\n\n    return this.constraints_.resolution(targetResolution, direction, size);\n  }\n}\n\n/**\n * @param {Function} callback Callback.\n * @param {*} returnValue Return value.\n */\nfunction animationCallback(callback, returnValue) {\n  setTimeout(function () {\n    callback(returnValue);\n  }, 0);\n}\n\n/**\n * @param {ViewOptions} options View options.\n * @return {import(\"./centerconstraint.js\").Type} The constraint.\n */\nexport function createCenterConstraint(options) {\n  if (options.extent !== undefined) {\n    const smooth =\n      options.smoothExtentConstraint !== undefined\n        ? options.smoothExtentConstraint\n        : true;\n    return createExtent(options.extent, options.constrainOnlyCenter, smooth);\n  }\n\n  const projection = createProjection(options.projection, 'EPSG:3857');\n  if (options.multiWorld !== true && projection.isGlobal()) {\n    const extent = projection.getExtent().slice();\n    extent[0] = -Infinity;\n    extent[2] = Infinity;\n    return createExtent(extent, false, false);\n  }\n\n  return centerNone;\n}\n\n/**\n * @param {ViewOptions} options View options.\n * @return {{constraint: import(\"./resolutionconstraint.js\").Type, maxResolution: number,\n *     minResolution: number, minZoom: number, zoomFactor: number}} The constraint.\n */\nexport function createResolutionConstraint(options) {\n  let resolutionConstraint;\n  let maxResolution;\n  let minResolution;\n\n  // TODO: move these to be ol constants\n  // see https://github.com/openlayers/openlayers/issues/2076\n  const defaultMaxZoom = 28;\n  const defaultZoomFactor = 2;\n\n  let minZoom =\n    options.minZoom !== undefined ? options.minZoom : DEFAULT_MIN_ZOOM;\n\n  let maxZoom =\n    options.maxZoom !== undefined ? options.maxZoom : defaultMaxZoom;\n\n  const zoomFactor =\n    options.zoomFactor !== undefined ? options.zoomFactor : defaultZoomFactor;\n\n  const multiWorld =\n    options.multiWorld !== undefined ? options.multiWorld : false;\n\n  const smooth =\n    options.smoothResolutionConstraint !== undefined\n      ? options.smoothResolutionConstraint\n      : true;\n\n  const showFullExtent =\n    options.showFullExtent !== undefined ? options.showFullExtent : false;\n\n  const projection = createProjection(options.projection, 'EPSG:3857');\n  const projExtent = projection.getExtent();\n  let constrainOnlyCenter = options.constrainOnlyCenter;\n  let extent = options.extent;\n  if (!multiWorld && !extent && projection.isGlobal()) {\n    constrainOnlyCenter = false;\n    extent = projExtent;\n  }\n\n  if (options.resolutions !== undefined) {\n    const resolutions = options.resolutions;\n    maxResolution = resolutions[minZoom];\n    minResolution =\n      resolutions[maxZoom] !== undefined\n        ? resolutions[maxZoom]\n        : resolutions[resolutions.length - 1];\n\n    if (options.constrainResolution) {\n      resolutionConstraint = createSnapToResolutions(\n        resolutions,\n        smooth,\n        !constrainOnlyCenter && extent,\n        showFullExtent,\n      );\n    } else {\n      resolutionConstraint = createMinMaxResolution(\n        maxResolution,\n        minResolution,\n        smooth,\n        !constrainOnlyCenter && extent,\n        showFullExtent,\n      );\n    }\n  } else {\n    // calculate the default min and max resolution\n    const size = !projExtent\n      ? // use an extent that can fit the whole world if need be\n        (360 * METERS_PER_UNIT.degrees) / projection.getMetersPerUnit()\n      : Math.max(getWidth(projExtent), getHeight(projExtent));\n\n    const defaultMaxResolution =\n      size / DEFAULT_TILE_SIZE / Math.pow(defaultZoomFactor, DEFAULT_MIN_ZOOM);\n\n    const defaultMinResolution =\n      defaultMaxResolution /\n      Math.pow(defaultZoomFactor, defaultMaxZoom - DEFAULT_MIN_ZOOM);\n\n    // user provided maxResolution takes precedence\n    maxResolution = options.maxResolution;\n    if (maxResolution !== undefined) {\n      minZoom = 0;\n    } else {\n      maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);\n    }\n\n    // user provided minResolution takes precedence\n    minResolution = options.minResolution;\n    if (minResolution === undefined) {\n      if (options.maxZoom !== undefined) {\n        if (options.maxResolution !== undefined) {\n          minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);\n        } else {\n          minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);\n        }\n      } else {\n        minResolution = defaultMinResolution;\n      }\n    }\n\n    // given discrete zoom levels, minResolution may be different than provided\n    maxZoom =\n      minZoom +\n      Math.floor(\n        Math.log(maxResolution / minResolution) / Math.log(zoomFactor),\n      );\n    minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);\n\n    if (options.constrainResolution) {\n      resolutionConstraint = createSnapToPower(\n        zoomFactor,\n        maxResolution,\n        minResolution,\n        smooth,\n        !constrainOnlyCenter && extent,\n        showFullExtent,\n      );\n    } else {\n      resolutionConstraint = createMinMaxResolution(\n        maxResolution,\n        minResolution,\n        smooth,\n        !constrainOnlyCenter && extent,\n        showFullExtent,\n      );\n    }\n  }\n  return {\n    constraint: resolutionConstraint,\n    maxResolution: maxResolution,\n    minResolution: minResolution,\n    minZoom: minZoom,\n    zoomFactor: zoomFactor,\n  };\n}\n\n/**\n * @param {ViewOptions} options View options.\n * @return {import(\"./rotationconstraint.js\").Type} Rotation constraint.\n */\nexport function createRotationConstraint(options) {\n  const enableRotation =\n    options.enableRotation !== undefined ? options.enableRotation : true;\n  if (enableRotation) {\n    const constrainRotation = options.constrainRotation;\n    if (constrainRotation === undefined || constrainRotation === true) {\n      return createSnapToZero();\n    }\n    if (constrainRotation === false) {\n      return rotationNone;\n    }\n    if (typeof constrainRotation === 'number') {\n      return createSnapToN(constrainRotation);\n    }\n    return rotationNone;\n  }\n  return disable;\n}\n\n/**\n * Determine if an animation involves no view change.\n * @param {Animation} animation The animation.\n * @return {boolean} The animation involves no view change.\n */\nexport function isNoopAnimation(animation) {\n  if (animation.sourceCenter && animation.targetCenter) {\n    if (!coordinatesEqual(animation.sourceCenter, animation.targetCenter)) {\n      return false;\n    }\n  }\n  if (animation.sourceResolution !== animation.targetResolution) {\n    return false;\n  }\n  if (animation.sourceRotation !== animation.targetRotation) {\n    return false;\n  }\n  return true;\n}\n\n/**\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n * @param {import(\"./size.js\").Size} size Box pixel size.\n * @param {import(\"./pixel.js\").Pixel} position Position on the view to center on.\n * @param {number} resolution Resolution.\n * @param {number} rotation Rotation.\n * @return {import(\"./coordinate.js\").Coordinate} Shifted center.\n */\nfunction calculateCenterOn(coordinate, size, position, resolution, rotation) {\n  // calculate rotated position\n  const cosAngle = Math.cos(-rotation);\n  let sinAngle = Math.sin(-rotation);\n  let rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;\n  let rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;\n  rotX += (size[0] / 2 - position[0]) * resolution;\n  rotY += (position[1] - size[1] / 2) * resolution;\n\n  // go back to original angle\n  sinAngle = -sinAngle; // go back to original rotation\n  const centerX = rotX * cosAngle - rotY * sinAngle;\n  const centerY = rotY * cosAngle + rotX * sinAngle;\n\n  return [centerX, centerY];\n}\n\nexport default View;\n","/**\n * @module ol/ViewHint\n */\n\n/**\n * @enum {number}\n */\nexport default {\n  ANIMATING: 0,\n  INTERACTING: 1,\n};\n"],"names":["TileQueue","PriorityQueue","constructor","tilePriorityFunction","tileChangeCallback","super","element","apply","getKey","this","boundHandleTileChange_","handleTileChange","bind","tileChangeCallback_","tilesLoading_","tilesLoadingKeys_","enqueue","added","tile","addEventListener","EventType","CHANGE","getTilesLoading","event","state","getState","TileState","LOADED","ERROR","EMPTY","removeEventListener","tileKey","loadMoreTiles","maxTotalLoading","maxNewLoads","newLoads","getCount","dequeue","IDLE","load","getTilePriority","frameState","tileSourceKey","tileCenter","tileResolution","wantedTiles","center","viewState","deltaX","deltaY","Math","log","sqrt","removeLayerMapProperty","layer","Layer","setMapInternal","getLayers","forEach","setLayerMapProperty","map","layers","getArray","i","ii","length","Map","options","on","once","un","optionsInternal","createOptionsInternal","renderComplete_","loaded_","boundHandleBrowserEvent_","handleBrowserEvent","maxTilesLoading_","undefined","maxTilesLoading","pixelRatio_","pixelRatio","postRenderTimeoutHandle_","animationDelayKey_","animationDelay_","coordinateToPixelTransform_","pixelToCoordinateTransform_","frameIndex_","frameState_","previousExtent_","viewPropertyListenerKey_","viewChangeListenerKey_","layerGroupPropertyListenerKeys_","viewport_","document","createElement","className","window","style","position","overflow","width","height","overlayContainer_","zIndex","pointerEvents","appendChild","overlayContainerStopEvent_","mapBrowserEventHandler_","moveTolerance_","moveTolerance","keyboardEventTarget_","keyboardEventTarget","targetChangeHandlerKeys_","targetElement_","resizeObserver_","ResizeObserver","updateSize","controls","interactions","onFocusOnly","overlays_","overlays","overlayIdIndex_","renderer_","postRenderFunctions_","tileQueue_","handleTileChange_","addChangeListener","MapProperty","LAYERGROUP","handleLayerGroupChanged_","VIEW","handleViewChanged_","SIZE","handleSizeChanged_","TARGET","handleTargetChanged_","setProperties","values","view","View","then","viewOptions","setView","CollectionEventType","ADD","setMap","REMOVE","addOverlayInternal_","id","getId","toString","control","interaction","addControl","getControls","push","addInteraction","getInteractions","addLayer","getLayerGroup","handleLayerAdd_","addOverlay","overlay","getOverlays","disposeInternal","clear","disconnect","setTarget","forEachFeatureAtPixel","pixel","callback","coordinate","getCoordinateFromPixelInternal","hitTolerance","layerFilter","checkWrapped","forEachFeatureAtCoordinate","getFeaturesAtPixel","features","feature","getAllLayers","addLayersFrom","layerGroup","hasFeatureAtPixel","hasFeatureAtCoordinate","getEventCoordinate","getCoordinateFromPixel","getEventPixel","getEventCoordinateInternal","viewport","viewportPosition","getBoundingClientRect","viewportSize","getSize","scaleX","scaleY","eventPosition","changedTouches","clientX","left","clientY","top","getTarget","get","getTargetElement","toUserCoordinate","getView","getProjection","pixelToCoordinateTransform","slice","getOverlayById","setLayers","group","Collection","collection","extend","getLoadingOrNotReady","layerStatesArray","getLayerStatesArray","visible","renderer","getRenderer","ready","source","getSource","loading","getPixelFromCoordinate","viewCoordinate","fromUserCoordinate","getPixelFromCoordinateInternal","coordinateToPixelTransform","getViewport","getOverlayContainer","getOverlayContainerStopEvent","getOwnerDocument","targetElement","ownerDocument","browserEvent","type","mapBrowserEvent","MapBrowserEvent","handleMapBrowserEvent","originalEvent","eventType","POINTERDOWN","WHEEL","KEYDOWN","doc","rootNode","getRootNode","target","contains","documentElement","dispatchEvent","interactionsArray","getMap","getActive","cont","handleEvent","propagationStopped","handlePostRender","tileQueue","isEmpty","hints","viewHints","ViewHint","ANIMATING","INTERACTING","lowOnFrameBudget","Date","now","time","reprioritize","animate","hasListener","RENDERCOMPLETE","dispatchRenderEvent","MapEvent","MapEventType","LOADEND","LOADSTART","postRenderFunctions","getAnimating","resolveConstraints","render","CONTEXTMENU","dispose","unobserve","ShadowRoot","host","setSize","getElementById","Composite","MapBrowserEventHandler","key","MapBrowserEventType","passive","KEYPRESS","observe","clearTimeout","cancelAnimationFrame","handleViewPropertyChanged_","updateViewportSize_","ObjectEventType","PROPERTYCHANGE","Group","handleLayerRemove_","isRendered","renderFrame_","renderSync","redrawText","layerStates","hasRenderer","handleFontsChanged","requestAnimationFrame","removeControl","remove","removeInteraction","removeLayer","removeOverlay","size","previousFrameState","isDef","getHints","declutter","extent","resolution","rotation","index","layerIndex","usedTiles","mapId","renderTargets","nextCenter","nextResolution","isNaN","nextRotation","nextExtent","renderFrame","Array","prototype","moveStart","MOVESTART","idle","MOVEEND","POSTRENDER","setTimeout","setLayerGroup","oldLayerGroup","set","computedStyle","getComputedStyle","offsetWidth","parseFloat","offsetHeight","getClientRects","oldSize","setViewportSize","isArray","ObjectEvent","oldValue","BaseObject","values_","value","hasOwnProperty","getKeys","Object","keys","getProperties","assign","getPropertiesInternal","hasProperties","notify","listener","removeChangeListener","silent","applyProperties","unset","Observable","revision_","changed","getRevision","onInternal","len","onceInternal","ol_key","unInternal","unByKey","Tile","tileCoord","interimTile","transition_","transition","transitionStarts_","interpolate","release","setState","getInterimTile","refreshInterimChain","prev","LOADING","getTileCoord","Error","getAlpha","start","delta","inTransition","endTransition","TileCache","pop","expireCache","canExpireCache","peekLast","pruneExceptNewestZ","peekFirstKey","z","TileRange","minX","maxX","minY","maxY","containsXY","containsTileRange","tileRange","x","y","equals","getHeight","getWidth","intersects","createOrUpdate","CENTER","RESOLUTION","ROTATION","DEFAULT_MIN_ZOOM","hints_","animations_","updateAnimationKey_","projection_","createProjection","projection","viewportSize_","targetCenter_","targetResolution_","targetRotation_","nextCenter_","nextResolution_","nextRotation_","cancelAnchor_","disableCoordinateWarning","fromUserExtent","applyOptions_","properties","ViewProperty","resolutionConstraintInfo","createResolutionConstraint","maxResolution_","maxResolution","minResolution_","minResolution","zoomFactor_","zoomFactor","resolutions_","resolutions","padding_","padding","minZoom_","minZoom","centerConstraint","createCenterConstraint","resolutionConstraint","constraint","rotationConstraint","createRotationConstraint","constraints_","setRotation","setCenterInternal","setResolution","zoom","setZoom","oldPadding","getCenterInternal","newPadding","getResolution","offsetX","offsetY","getUpdatedOptions_","newOptions","getZoom","getRotation","var_args","args","arguments","anchor","animateInternal","animationCount","animationCallback","series","animation","complete","duration","easing","sourceCenter","targetCenter","sourceResolution","targetResolution","getResolutionForZoom","sourceRotation","PI","targetRotation","isNoopAnimation","setHint","updateAnimations_","getInteracting","cancelAnimations","j","jj","NaN","more","seriesComplete","elapsed","fraction","progress","x0","y0","x1","y1","getViewportSize_","constrainedResolution","calculateCenterZoom","applyTargetState_","constrainedRotation","calculateCenterRotate","filter","Boolean","currentCenter","currentResolution","w","h","abs","cos","sin","getCenter","getConstraints","getConstrainResolution","calculateExtent","calculateExtentInternal","toUserExtent","getViewportSizeMinusPadding_","getMaxResolution","getMinResolution","getMaxZoom","getZoomForResolution","setMaxZoom","maxZoom","getMinZoom","setMinZoom","setConstrainResolution","enabled","constrainResolution","getResolutions","getResolutionForExtent","getResolutionForExtentInternal","xResolution","yResolution","max","getResolutionForValueFunction","power","getConstrainedResolution","pow","getValueForResolutionFunction","logPower","reducedSize","calculateCenterOn","getViewStateAndExtent","offset","nearest","baseLevel","floor","fit","geometryOrExtent","geometry","getType","getExtent","rotate","userProjection","getUserProjection","clone","transform","fitInternal","rotatedExtentForGeometry","cosAngle","sinAngle","coords","getFlatCoordinates","stride","getStride","minRotX","Infinity","minRotY","maxRotX","maxRotY","rotX","rotY","min","rotatedExtent","centerRot","centerX","centerY","getConstrainedCenter","centerOn","centerOnInternal","calculateCenterShift","centerShift","shiftedCenter","adjustCenter","deltaCoordinates","setCenter","adjustCenterInternal","adjustResolution","ratio","adjustResolutionInternal","isMoving","newResolution","adjustZoom","adjustRotation","adjustRotationInternal","newRotation","hint","doNotCancelAnims","forceMoving","newCenter","resolutionDirection","direction","beginInteraction","endInteraction","endInteractionInternal","getConstrainedZoom","targetZoom","targetRes","returnValue","smooth","smoothExtentConstraint","constrainOnlyCenter","multiWorld","isGlobal","defaultMaxZoom","defaultZoomFactor","smoothResolutionConstraint","showFullExtent","projExtent","METERS_PER_UNIT","degrees","getMetersPerUnit","defaultMaxResolution","defaultMinResolution","enableRotation","constrainRotation"],"sourceRoot":""}
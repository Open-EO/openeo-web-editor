{"version":3,"file":"js/6327.b1b6c7d9.js","mappings":"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","sources":["webpack://@openeo/web-editor/./node_modules/@openeo/vue-components/components/Collections.vue?e321","webpack://@openeo/web-editor/node_modules/@openeo/vue-components/components/Collections.vue","webpack://@openeo/web-editor/./node_modules/@openeo/vue-components/components/Collections.vue?934d","webpack://@openeo/web-editor/./node_modules/@openeo/vue-components/components/Collections.vue","webpack://@openeo/web-editor/./node_modules/@openeo/vue-components/components/DataTable.vue?76b4","webpack://@openeo/web-editor/node_modules/@openeo/vue-components/components/DataTable.vue","webpack://@openeo/web-editor/./node_modules/@openeo/vue-components/components/DataTable.vue?fc7a","webpack://@openeo/web-editor/./node_modules/@openeo/vue-components/components/DataTable.vue","webpack://@openeo/web-editor/./node_modules/@openeo/vue-components/components/FileFormats.vue?7afc","webpack://@openeo/web-editor/node_modules/@openeo/vue-components/components/FileFormats.vue","webpack://@openeo/web-editor/./node_modules/@openeo/vue-components/components/FileFormats.vue?9759","webpack://@openeo/web-editor/./node_modules/@openeo/vue-components/components/FileFormats.vue","webpack://@openeo/web-editor/./node_modules/@openeo/vue-components/components/Processes.vue?86dc","webpack://@openeo/web-editor/node_modules/@openeo/vue-components/components/Processes.vue","webpack://@openeo/web-editor/./node_modules/@openeo/vue-components/components/Processes.vue?bab8","webpack://@openeo/web-editor/./node_modules/@openeo/vue-components/components/Processes.vue","webpack://@openeo/web-editor/./node_modules/@openeo/vue-components/components/SearchBox.vue?98bf","webpack://@openeo/web-editor/node_modules/@openeo/vue-components/components/SearchBox.vue","webpack://@openeo/web-editor/./node_modules/@openeo/vue-components/components/SearchBox.vue?3182","webpack://@openeo/web-editor/./node_modules/@openeo/vue-components/components/SearchBox.vue","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/compression/index.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/dataview64.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/dataslice.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/source/httputils.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/source/basesource.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/utils.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/source/blockedsource.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/source/client/base.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/source/client/fetch.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/source/client/xhr.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/source/client/http.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/source/remote.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/source/filereader.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/geotiff.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/rgb.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/resample.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/geotiffimage.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/globals.js"],"sourcesContent":["var render = function render(){var _vm=this,_c=_vm._self._c;return _c('div',{staticClass:\"vue-component collections\"},[_c('SearchableList',{attrs:{\"data\":_vm.collections,\"identifierKey\":\"id\",\"summaryKey\":\"title\",\"keywordsKey\":\"keywords\",\"showKeywords\":_vm.showKeywords,\"showSummaryOnExpand\":false,\"externalSearchTerm\":_vm.searchTerm,\"externalHideDeprecated\":_vm.hideDeprecated,\"deprecatedFilter\":_vm.deprecatedFilter,\"sort\":_vm.sort,\"offerDetails\":_vm.offerDetails,\"heading\":_vm.heading,\"collapsed\":_vm.collapsed,\"loadAdditionalData\":_vm.loadAdditionalData,\"allowCopy\":\"\"},on:{\"detailsToggled\":_vm.detailsToggled},scopedSlots:_vm._u([{key:\"heading\",fn:function(scope){return [_vm._t(\"heading\",null,null,scope)]}},(_vm.missing)?{key:\"content-start\",fn:function(){return [_c('FederationMissingNotice',{attrs:{\"missing\":_vm.missing,\"federation\":_vm.federation}})]},proxy:true}:null,{key:\"summary\",fn:function(scope){return [_vm._t(\"summary\",null,null,scope)]}},{key:\"details\",fn:function(slot){return [_c('Collection',{attrs:{\"data\":slot.item,\"mapOptions\":_vm.mapOptions,\"federation\":_vm.federation},scopedSlots:_vm._u([{key:\"title\",fn:function(){return [_c('span',{staticClass:\"hidden\"})]},proxy:true},{key:\"before-description\",fn:function(scope){return [_vm._t(\"collection-before-description\",null,null,scope)]}},{key:\"end\",fn:function(scope){return [_vm._t(\"collection-end\",null,null,scope)]}},{key:\"spatial-extents\",fn:function(scope){return [_vm._t(\"collection-spatial-extents\",null,null,scope)]}},{key:\"temporal-extents\",fn:function(scope){return [_vm._t(\"collection-temporal-extents\",null,null,scope)]}}],null,true)})]}}],null,true)})],1)\n}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\n\t<div class=\"vue-component collections\">\n\t\t<SearchableList :data=\"collections\" identifierKey=\"id\" summaryKey=\"title\" keywordsKey=\"keywords\" :showKeywords=\"showKeywords\"  :showSummaryOnExpand=\"false\" :externalSearchTerm=\"searchTerm\" :externalHideDeprecated=\"hideDeprecated\" :deprecatedFilter=\"deprecatedFilter\" :sort=\"sort\" :offerDetails=\"offerDetails\" :heading=\"heading\" :collapsed=\"collapsed\" :loadAdditionalData=\"loadAdditionalData\" @detailsToggled=\"detailsToggled\" allowCopy>\n\t\t\t<template #heading=\"scope\"><slot name=\"heading\" v-bind=\"scope\" /></template>\n\t\t\t<template v-if=\"missing\" #content-start><FederationMissingNotice :missing=\"missing\" :federation=\"federation\" /></template>\n\t\t\t<template #summary=\"scope\"><slot name=\"summary\" v-bind=\"scope\" /></template>\n\t\t\t<template #details=\"slot\">\n\t\t\t\t<Collection :data=\"slot.item\" :mapOptions=\"mapOptions\" :federation=\"federation\">\n\t\t\t\t\t<template #title><span class=\"hidden\" /></template>\n\t\t\t\t\t<template #before-description=\"scope\"><slot name=\"collection-before-description\" v-bind=\"scope\" /></template>\n\t\t\t\t\t<template #end=\"scope\"><slot name=\"collection-end\" v-bind=\"scope\" /></template>\n\t\t\t\t\t<template #spatial-extents=\"scope\"><slot name=\"collection-spatial-extents\" v-bind=\"scope\" /></template>\n\t\t\t\t\t<template #temporal-extents=\"scope\"><slot name=\"collection-temporal-extents\" v-bind=\"scope\" /></template>\n\t\t\t\t</Collection>\n\t\t\t</template>\n\t\t</SearchableList>\n\t</div>\n</template>\n\n<script>\nimport Utils from '../utils';\nimport FederationMixin from './internal/FederationMixin.js';\n\nexport default {\n\tname: 'Collections',\n\tcomponents: {\n\t\tCollection: () => Utils.loadAsyncComponent(import('./Collection.vue')),\n\t\tSearchableList: () => Utils.loadAsyncComponent(import('./SearchableList.vue'))\n\t},\n\tmixins: [\n\t\tFederationMixin\n\t],\n\tprops: {\n\t\tcollections: {\n\t\t\ttype: Array,\n\t\t\tdefault: () => ([])\n\t\t},\n\t\tmapOptions: {\n\t\t\ttype: Object,\n\t\t\tdefault: () => ({})\n\t\t},\n\t\tsearchTerm: {\n\t\t\ttype: String,\n\t\t\tdefault: null\n\t\t},\n\t\tsort: {\n\t\t\ttype: Boolean,\n\t\t\tdefault: true\n\t\t},\n\t\tofferDetails: {\n\t\t\ttype: Boolean,\n\t\t\tdefault: true\n\t\t},\n\t\theading: {\n\t\t\ttype: String,\n\t\t\tdefault: 'Collections'\n\t\t},\n\t\tcollapsed: {\n\t\t\ttype: Boolean,\n\t\t\tdefault: null\n\t\t},\n\t\tloadAdditionalData: {\n\t\t\ttype: Function,\n\t\t\tdefault: null\n\t\t},\n\t\tshowKeywords: {\n\t\t\ttype: Boolean,\n\t\t\tdefault: false\n\t\t},\n\t\thideDeprecated: {\n\t\t\ttype: Boolean,\n\t\t\tdefault: false\n\t\t},\n\t\tdeprecatedFilter: {\n\t\t\ttype: Boolean,\n\t\t\tdefault: false\n\t\t},\n\t\tmissing: {\n\t\t\ttype: Array,\n\t\t\tdefault: null\n\t\t},\n\t\t...FederationMixin.props\n\t},\n\tbeforeCreate() {\n\t\tUtils.enableHtmlProps(this);\n\t},\n\tmethods: {\n\t\tdetailsToggled(...args) {\n\t\t\tthis.$emit('detailsToggled', ...args);\n\t\t}\n\t}\n}\n</script>\n\n<style lang=\"scss\">\n@import './base.scss';\n</style>","import mod from \"-!../../../@vue/vue-loader-v15/lib/index.js??vue-loader-options!./Collections.vue?vue&type=script&lang=js\"; export default mod; export * from \"-!../../../@vue/vue-loader-v15/lib/index.js??vue-loader-options!./Collections.vue?vue&type=script&lang=js\"","import { render, staticRenderFns } from \"./Collections.vue?vue&type=template&id=32864357\"\nimport script from \"./Collections.vue?vue&type=script&lang=js\"\nexport * from \"./Collections.vue?vue&type=script&lang=js\"\nimport style0 from \"./Collections.vue?vue&type=style&index=0&id=32864357&prod&lang=scss\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","var render = function render(){var _vm=this,_c=_vm._self._c;return _c('div',{staticClass:\"vue-component data-table\"},[_c('div',{staticClass:\"menu\"},[_c('div',{staticClass:\"toolbar\"},[_vm._t(\"toolbar\")],2),(_vm.hasData)?_c('div',{staticClass:\"filter\"},[_c('SearchBox',{attrs:{\"compact\":true},model:{value:(_vm.filterValue),callback:function ($$v) {_vm.filterValue=$$v},expression:\"filterValue\"}})],1):_vm._e()]),(_vm.hasData)?_c('table',[_c('thead',[_c('tr',_vm._l((_vm.columns),function(col,id){return _c('th',{directives:[{name:\"show\",rawName:\"v-show\",value:(!col.hide),expression:\"!col.hide\"}],key:col.name,class:_vm.thClasses(id),attrs:{\"title\":_vm.thTitle(id)},on:{\"click\":function($event){return _vm.enableSort(id)}}},[_vm._v(_vm._s(col.name))])}),0)]),_c('tbody',[_vm._l((_vm.view),function(row,i){return _c('tr',{key:i},_vm._l((_vm.columns),function(col,id){return _c('td',{directives:[{name:\"show\",rawName:\"v-show\",value:(!col.hide),expression:\"!col.hide\"}],key:`${col.name}_${i}`,class:[id, {'edit': _vm.canEdit(col)}],attrs:{\"title\":_vm.canEdit(col) ? 'Double-click to change the value' : false,\"data-value\":col.stylable ? _vm.value(row, col, id) : false},on:{\"dblclick\":function($event){return _vm.onDblClick($event, row, col, id)}}},[_vm._t(id,function(){return [(_vm.showEditField(row, col, id))?[_c('form',{on:{\"submit\":function($event){$event.preventDefault();$event.stopPropagation();return _vm.saveEditField($event, row, col, id)}}},[_c('input',{ref:\"editField\",refInFor:true,attrs:{\"type\":\"text\"},domProps:{\"value\":_vm.value(row, col, id)},on:{\"blur\":function($event){return _vm.saveEditField($event, row, col, id)},\"keyup\":function($event){return _vm.resetEditFieldEsc($event, row, col, id)}}})])]:_c('span',{domProps:{\"innerHTML\":_vm._s(_vm.formattedValue(row, col, id))}})]},{\"row\":row,\"col\":col,\"id\":id})],2)}),0)}),(_vm.hasData && _vm.view.length == 0)?_c('tr',{staticClass:\"no-results\"},[_c('td',{attrs:{\"colspan\":_vm.columnCount}},[_vm._v(\"No element matches your search criteria.\")])]):_vm._e()],2)]):_c('div',{staticClass:\"no-data\"},[_vm._v(_vm._s(_vm.noDataMessage))])])\n}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\n\t<div class=\"vue-component data-table\">\n\t\t<div class=\"menu\">\n\t\t\t<div class=\"toolbar\">\n\t\t\t\t<slot name=\"toolbar\"></slot>\n\t\t\t</div>\n\t\t\t<div class=\"filter\" v-if=\"hasData\">\n\t\t\t\t<SearchBox v-model=\"filterValue\" :compact=\"true\" />\n\t\t\t</div>\n\t\t</div>\n\t\t<table v-if=\"hasData\">\n\t\t\t<thead>\n\t\t\t\t<tr>\n\t\t\t\t\t<th v-for=\"(col, id) in columns\" v-show=\"!col.hide\" :key=\"col.name\" :class=\"thClasses(id)\" @click=\"enableSort(id)\" :title=\"thTitle(id)\">{{ col.name }}</th>\n\t\t\t\t</tr>\n\t\t\t</thead>\n\t\t\t<tbody>\n\t\t\t\t<tr v-for=\"(row, i) in view\" :key=\"i\">\n\t\t\t\t\t<td v-for=\"(col, id) in columns\" v-show=\"!col.hide\" :key=\"`${col.name}_${i}`\" \n\t\t\t\t\t\t:class=\"[id, {'edit': canEdit(col)}]\"\n\t\t\t\t\t\t:title=\"canEdit(col) ? 'Double-click to change the value' : false\"\n\t\t\t\t\t\t@dblclick=\"onDblClick($event, row, col, id)\"\n\t\t\t\t\t\t:data-value=\"col.stylable ? value(row, col, id) : false\">\n\t\t\t\t\t\t<slot :name=\"id\" :row=\"row\" :col=\"col\" :id=\"id\">\n\t\t\t\t\t\t\t<template v-if=\"showEditField(row, col, id)\">\n\t\t\t\t\t\t\t\t<form @submit.prevent.stop=\"saveEditField($event, row, col, id)\">\n\t\t\t\t\t\t\t\t\t<input type=\"text\" ref=\"editField\" :value=\"value(row, col, id)\" @blur=\"saveEditField($event, row, col, id)\" @keyup=\"resetEditFieldEsc($event, row, col, id)\" />\n\t\t\t\t\t\t\t\t</form>\n\t\t\t\t\t\t\t</template>\n\t\t\t\t\t\t\t<span v-else v-html=\"formattedValue(row, col, id)\" />\n\t\t\t\t\t\t</slot>\n\t\t\t\t\t</td>\n\t\t\t\t</tr>\n\t\t\t\t<tr v-if=\"hasData && view.length == 0\" class=\"no-results\">\n\t\t\t\t\t<td :colspan=\"columnCount\">No element matches your search criteria.</td>\n\t\t\t\t</tr>\n\t\t\t</tbody>\n\t\t</table>\n\t\t<div class=\"no-data\" v-else>{{ noDataMessage }}</div>\n\t</div>\n</template>\n\n<script>\nimport Utils from '../utils.js';\nimport { DataTypes, Formatters } from '@radiantearth/stac-fields';\n\nexport default {\n\tname: 'DataTable',\n\tcomponents: {\n\t\tSearchBox: () => import('./SearchBox.vue')\n\t},\n\tprops: {\n\t\tcolumns: {\n\t\t\ttype: Object,\n\t\t\tdefault: () => ({})\n\t\t},\n\t\tdata: {\n\t\t\ttype: Array,\n\t\t\tdefault: () => ([])\n\t\t}\n\t},\n\tdata() {\n\t\treturn {\n\t\t\tview: [],\n\t\t\tfilterValue: null,\n\t\t\tprimaryKey: null,\n\t\t\tnoDataMessage: 'No data available.',\n\t\t\teditField: null,\n\t\t\tsortState: {\n\t\t\t\tid: null,\n\t\t\t\tdirection: null\n\t\t\t}\n\t\t};\n\t},\n\twatch: {\n\t\tdata() {\n\t\t\tthis.updateView();\n\t\t},\n\t\tfilterValue() {\n\t\t\tthis.updateView();\n\t\t},\n\t\tsortState() {\n\t\t\tthis.updateView();\n\t\t},\n\t\tcolumns: {\n\t\t\timmediate: true,\n\t\t\thandler() {\n\t\t\t\tfor(let id in this.columns) {\n\t\t\t\t\tlet direction = this.columns[id].sort;\n\t\t\t\t\tif (['asc', 'desc'].includes(direction)) {\n\t\t\t\t\t\tthis.enableSort(id, direction);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tcomputed: {\n\t\tcolumnCount() {\n\t\t\treturn Object.keys(this.columns).length;\n\t\t},\n\t\thasData() {\n\t\t\treturn this.data.length > 0;\n\t\t},\n\t\thasFilter() {\n\t\t\treturn (typeof this.filterValue === 'string' && this.filterValue.length > 0) ? true : false;\n\t\t}\n\t},\n\tbeforeCreate() {\n\t\tUtils.enableHtmlProps(this);\n\t},\n\tcreated() {\n\t\tthis.determinePrimaryKey();\n\t},\n\tmethods: {\n\t\tcanEdit(col) {\n\t\t\treturn (typeof col.edit === 'function');\n\t\t},\n\t\tshowEditField(row, col, id) {\n\t\t\treturn this.canEdit(col) && this.editField != null && this.editField[0] == row && this.editField[1] == id;\n\t\t},\n\t\tonDblClick(event, row, col, id) {\n\t\t\tif (!this.canEdit(col)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar value = this.value(row, col, id);\n\t\t\tif (typeof value === 'boolean') {\n\t\t\t\tvar action = this.columns[id].edit;\n\t\t\t\taction(row);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.editField = [row, id];\n\t\t\t\tthis.$nextTick(() => this.$refs.editField[0].focus());\n\t\t\t}\n\t\t\tevent.preventDefault();\n\t\t\tevent.stopPropagation();\n\t\t},\n\t\tsaveEditField(event, row, col, id) {\n\t\t\tif (this.editField !== null && this.canEdit(col)) {\n\t\t\t\tvar action = this.columns[id].edit;\n\t\t\t\taction(row, this.$refs.editField[0].value);\n\n\t\t\t\tthis.editField = null;\n\t\t\t\tevent.preventDefault();\n\t\t\t\tevent.stopPropagation();\n\t\t\t}\n\t\t},\n\t\tresetEditFieldEsc(event, row, col, id) {\n\t\t\tif (event.key == \"Escape\") {\n\t\t\t\tthis.editField = null;\n\t\t\t}\n\t\t},\n\t\tdeterminePrimaryKey() {\n\t\t\tfor(var col in this.columns) {\n\t\t\t\tif (this.columns[col].primaryKey) {\n\t\t\t\t\tthis.primaryKey = col;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tsetNoData(error) {\n\t\t\tif (typeof error == 'string') {\n\t\t\t\tthis.noDataMessage = error;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse if (Utils.isObject(error)) {\n\t\t\t\tif (typeof error.data === 'object' && typeof error.config === 'object' && typeof error.headers === 'object') {\n\t\t\t\t\t// Axios response, handle the data only.\n\t\t\t\t\terror = error.data;\n\t\t\t\t}\n\t\t\t\tif (Utils.isObject(error) && typeof error.message === 'string') {\n\t\t\t\t\tthis.noDataMessage = error.message;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconsole.warn(error);\n\t\t\tthis.noDataMessage = \"Sorry, an unknown error has occured.\";\n\t\t},\n\t\tvalue(row, col, id) {\n\t\t\tvar data;\n\t\t\tif (typeof row === 'object') {\n\t\t\t\tdata = row[id];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdata = row;\n\t\t\t}\n\t\t\tif (Utils.isObject(col) && typeof col.computedValue === 'function') {\n\t\t\t\tdata = col.computedValue(row, data);\n\t\t\t}\n\t\t\treturn data;\n\t\t},\n\t\tformattedValue(row, col, id) {\n\t\t\treturn this.format(this.value(row, col, id), col);\n\t\t},\n\t\tthClasses(id) {\n\t\t\tlet col = this.columns[id];\n\t\t\tlet classes = [id];\n\t\t\tif (col.sort !== false) {\n\t\t\t\tclasses.push('sortable');\n\t\t\t\tif (this.sortState.id === id) {\n\t\t\t\t\tclasses.push('sort-' + this.sortState.direction);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn classes;\n\t\t},\n\t\tthTitle(id) {\n\t\t\tlet col = this.columns[id];\n\t\t\tif (col.sort !== false) {\n\t\t\t\tif (this.sortState.id === id && this.sortState.direction === 'asc') {\n\t\t\t\t\treturn \"Click to sort column in descending order\";\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn \"Click to sort column in ascending order\";\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\tenableSort(id, direction = null) {\n\t\t\tif (this.columns[id].sort === false) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (direction === null) {\n\t\t\t\tdirection = this.sortState.id === id && this.sortState.direction === 'asc' ? 'desc' : 'asc';\n\t\t\t}\n\t\t\tthis.sortState = {id, direction};\n\t\t},\n\t\tsort(data) {\n\t\t\tlet colId = this.sortState.id;\n\t\t\tif (colId === null || !this.columns[colId]) {\n\t\t\t\treturn data;\n\t\t\t}\n\t\t\tlet col = this.columns[colId];\n\t\t\tif (col.sort === false) {\n\t\t\t\treturn data;\n\t\t\t}\n\n\t\t\treturn data.slice(0).sort((a,b) => {\n\t\t\t\tlet fn = typeof col.sortFn === 'function' ? col.sortFn : Utils.compareStringCaseInsensitive;\n\t\t\t\tlet result = fn(a[colId], b[colId]);\n\t\t\t\treturn this.sortState.direction === 'desc' ? result * -1 : result;\n\t\t\t});\n\t\t},\n\t\tfilter(data) {\n\t\t\tif (!this.hasFilter) {\n\t\t\t\treturn data;\n\t\t\t}\n\t\t\tvar searchTerm = this.filterValue.toLowerCase();\n\n\t\t\treturn data.filter(row => {\n\t\t\t\tlet values = [];\n\t\t\t\tfor(var key in row) {\n\t\t\t\t\tvar col = this.columns[key];\n\t\t\t\t\tif (typeof col === 'undefined' || col.hasOwnProperty('filterable') && col.filterable === false) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tvar value = this.value(row, col, key);\n\t\t\t\t\tif (typeof value === 'number' || typeof value === 'string' || typeof value === 'boolean') {\n\t\t\t\t\t\tvalue = value.toString();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tvalues.push(value);\n\t\t\t\t}\n\t\t\t\treturn Utils.search(searchTerm, values);\n\t\t\t});\n\t\t},\n\t\tclearFilter() {\n\t\t\tthis.filterValue = '';\n\t\t\tthis.updateView();\n\t\t},\n\t\tupdateView() {\n\t\t\tif (!Array.isArray(this.data)) {\n\t\t\t\tthis.view = [];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.view = this.sort(this.filter(this.data));\n\t\t},\n\t\tformat(value, col) {\n\t\t\tif (typeof col.format === 'string') {\n\t\t\t\tif (typeof Formatters['format' + col.format] === 'function') {\n\t\t\t\t\treturn Formatters['format' + col.format](value, col);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconsole.warn(col.format + ' is an invalid formatter.');\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (typeof col.format === 'function') {\n\t\t\t\treturn col.format.call(this, value, col);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn DataTypes.format(value);\n\t\t\t}\n\t\t}\n\t}\n}\n</script>\n\n<style lang=\"scss\">\n.vue-component.data-table {\n\ttable {\n\t\twidth: 100%;\n\t\tborder-collapse: collapse;\n\t\ttd, th {\n\t\t\tborder: 1px solid #ddd;\n\t\t\tpadding: 0.2em;\n\t\t}\n\t\tth {\n\t\t\ttext-align: left !important;\n\t\t\t\n\t\t\t&.sortable {\n\t\t\t\tcursor: pointer;\n\n\t\t\t\t&:hover {\n\t\t\t\t\tbackground-color: #eee;\n\t\t\t\t}\n\t\t\t}\n\t\t\t&.sort-asc:after,\n\t\t\t&.sortable:after {\n\t\t\t\tvisibility: hidden;\n\t\t\t\tmargin-left: 5px;\n\t\t\t\tfont-weight: 100;\n\t\t\t\tcontent: \"⇑\";\n\t\t\t}\n\t\t\t&.sort-asc:after,\n\t\t\t&.sortable:hover:after {\n\t\t\t\tvisibility: visible;\n\t\t\t}\n\t\t\t&.sort-desc:after {\n\t\t\t\tvisibility: visible;\n\t\t\t\tmargin-left: 5px;\n\t\t\t\tfont-weight: 100;\n\t\t\t\tcontent: \"⇓\";\n\t\t\t}\n\t\t\t&.sort-asc:hover:after,\n\t\t\t&.sort-desc:hover:after {\n\t\t\t\tvisibility: visible;\n\t\t\t\tmargin-left: 5px;\n\t\t\t\tfont-weight: 100;\n\t\t\t\tcontent: \"⇕\";\n\t\t\t}\n\t\t}\n\t}\n\t.filter-icon {\n\t\tmargin-right: 3px;\n\t}\n\t.no-results td {\n\t\ttext-align: center;\n\t}\n\t.menu {\n\t\tmargin-bottom: 5px;\n\t\tdisplay: flex;\n\t\tjustify-content: space-between;\n\t}\n\t.filter {\n\t\tflex-grow: 1;\n\t\ttext-align: right;\n\t\tpadding-left: 1em;\n\t\tmin-width: 4em;\n\t\tmax-width: 20em;\n\t\t.edit {\n\t\t\tcursor: pointer;\n\t\t}\n\t}\n}\n</style>","import mod from \"-!../../../@vue/vue-loader-v15/lib/index.js??vue-loader-options!./DataTable.vue?vue&type=script&lang=js\"; export default mod; export * from \"-!../../../@vue/vue-loader-v15/lib/index.js??vue-loader-options!./DataTable.vue?vue&type=script&lang=js\"","import { render, staticRenderFns } from \"./DataTable.vue?vue&type=template&id=aed041f4\"\nimport script from \"./DataTable.vue?vue&type=script&lang=js\"\nexport * from \"./DataTable.vue?vue&type=script&lang=js\"\nimport style0 from \"./DataTable.vue?vue&type=style&index=0&id=aed041f4&prod&lang=scss\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","var render = function render(){var _vm=this,_c=_vm._self._c;return _c('div',{staticClass:\"vue-component file-formats\"},[_c('SearchableList',{attrs:{\"data\":_vm.fileFormats,\"summaryKey\":\"title\",\"keywordsKey\":\"gis_data_types\",\"showSummaryOnExpand\":false,\"externalSearchTerm\":_vm.searchTerm,\"externalHideDeprecated\":_vm.hideDeprecated,\"deprecatedFilter\":_vm.deprecatedFilter,\"sort\":_vm.sort,\"offerDetails\":_vm.offerDetails,\"heading\":_vm.heading,\"collapsed\":_vm.collapsed},on:{\"detailsToggled\":_vm.detailsToggled},scopedSlots:_vm._u([{key:\"heading\",fn:function(scope){return [_vm._t(\"heading\",null,null,scope)]}},(_vm.missing)?{key:\"content-start\",fn:function(){return [_c('FederationMissingNotice',{attrs:{\"missing\":_vm.missing,\"federation\":_vm.federation}})]},proxy:true}:null,{key:\"summary\",fn:function(slot){return [_vm._t(\"summary\",function(){return [_c('strong',{staticClass:\"inline\"},[_vm._v(_vm._s(slot.item.name))]),_c('ul',{staticClass:\"badges small inline\"},[(_vm.showAll && slot.item.type === 'input')?_c('li',{staticClass:\"badge option1\"},[_vm._v(\"Import\")]):_vm._e(),(_vm.showAll && slot.item.type === 'output')?_c('li',{staticClass:\"badge option2\"},[_vm._v(\"Export\")]):_vm._e(),(Array.isArray(slot.item.gis_data_types))?_vm._l((slot.item.gis_data_types),function(type){return _c('li',{key:type,staticClass:\"badge gis\"},[_vm._v(_vm._s(type))])}):_vm._e()],2),_c('br'),_c('small',[_vm._v(_vm._s(slot.summary.summary))])]},null,slot)]}},{key:\"details\",fn:function(slot){return [_c('FileFormat',{attrs:{\"id\":slot.summary.identifier,\"format\":slot.item,\"type\":slot.item.type,\"federation\":_vm.federation},scopedSlots:_vm._u([{key:\"title\",fn:function(){return [_c('span',{staticClass:\"hidden\"})]},proxy:true},{key:\"badges\",fn:function(){return [_c('span',{staticClass:\"hidden\"})]},proxy:true},{key:\"before-description\",fn:function(scope){return [_vm._t(\"file-format-before-description\",null,null,scope)]}},{key:\"end\",fn:function(scope){return [_vm._t(\"file-format-end\",null,null,scope)]}}],null,true)})]}}],null,true)})],1)\n}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\n\t<div class=\"vue-component file-formats\">\n\t\t<SearchableList :data=\"fileFormats\" summaryKey=\"title\" keywordsKey=\"gis_data_types\" :showSummaryOnExpand=\"false\" :externalSearchTerm=\"searchTerm\" :externalHideDeprecated=\"hideDeprecated\" :deprecatedFilter=\"deprecatedFilter\" :sort=\"sort\" :offerDetails=\"offerDetails\" :heading=\"heading\" :collapsed=\"collapsed\" @detailsToggled=\"detailsToggled\">\n\t\t\t<template #heading=\"scope\"><slot name=\"heading\" v-bind=\"scope\" /></template>\n\t\t\t<template v-if=\"missing\" #content-start><FederationMissingNotice :missing=\"missing\" :federation=\"federation\" /></template>\n\t\t\t<template #summary=\"slot\">\n\t\t\t\t<slot name=\"summary\" v-bind=\"slot\">\n\t\t\t\t\t<strong class=\"inline\">{{ slot.item.name }}</strong>\n\t\t\t\t\t<ul class=\"badges small inline\">\n\t\t\t\t\t\t<li class=\"badge option1\" v-if=\"showAll && slot.item.type === 'input'\">Import</li>\n\t\t\t\t\t\t<li class=\"badge option2\" v-if=\"showAll && slot.item.type === 'output'\">Export</li>\n\t\t\t\t\t\t<template v-if=\"Array.isArray(slot.item.gis_data_types)\">\n\t\t\t\t\t\t\t<li class=\"badge gis\" v-for=\"type in slot.item.gis_data_types\" :key=\"type\">{{ type }}</li>\n\t\t\t\t\t\t</template>\n\t\t\t\t\t</ul><br />\n\t\t\t\t\t<small>{{ slot.summary.summary }}</small>\n\t\t\t\t</slot>\n\t\t\t</template>\n\t\t\t<template #details=\"slot\">\n\t\t\t\t<FileFormat :id=\"slot.summary.identifier\" :format=\"slot.item\" :type=\"slot.item.type\" :federation=\"federation\">\n\t\t\t\t\t<template #title><span class=\"hidden\" /></template>\n\t\t\t\t\t<template #badges><span class=\"hidden\" /></template>\n\t\t\t\t\t<template #before-description=\"scope\"><slot name=\"file-format-before-description\" v-bind=\"scope\" /></template>\n\t\t\t\t\t<template #end=\"scope\"><slot name=\"file-format-end\" v-bind=\"scope\" /></template>\n\t\t\t\t</FileFormat>\n\t\t\t</template>\n\t\t</SearchableList>\n\t</div>\n</template>\n\n<script>\nimport Utils from '../utils.js';\nimport FederationMixin from './internal/FederationMixin.js';\n\nexport default {\n\tname: 'FileFormats',\n\tcomponents: {\n\t\tSearchableList: () => Utils.loadAsyncComponent(import('./SearchableList.vue')),\n\t\tFileFormat: () => Utils.loadAsyncComponent(import('./FileFormat.vue'))\n\t},\n\tmixins: [\n\t\tFederationMixin\n\t],\n\tprops: {\n\t\tformats: {\n\t\t\ttype: Object,\n\t\t\tdefault: () => ({})\n\t\t},\n\t\tshowInput: {\n\t\t\ttype: Boolean,\n\t\t\tdefault: true\n\t\t},\n\t\tshowOutput: {\n\t\t\ttype: Boolean,\n\t\t\tdefault: true\n\t\t},\n\t\tsearchTerm: {\n\t\t\ttype: String,\n\t\t\tdefault: null\n\t\t},\n\t\tsort: {\n\t\t\ttype: Boolean,\n\t\t\tdefault: true\n\t\t},\n\t\tofferDetails: {\n\t\t\ttype: Boolean,\n\t\t\tdefault: true\n\t\t},\n\t\theading: {\n\t\t\ttype: String,\n\t\t\tdefault: 'File Formats'\n\t\t},\n\t\tcollapsed: {\n\t\t\ttype: Boolean,\n\t\t\tdefault: null\n\t\t},\n\t\thideDeprecated: {\n\t\t\ttype: Boolean,\n\t\t\tdefault: false\n\t\t},\n\t\tdeprecatedFilter: {\n\t\t\ttype: Boolean,\n\t\t\tdefault: false\n\t\t},\n\t\tmissing: {\n\t\t\ttype: Array,\n\t\t\tdefault: null\n\t\t},\n\t\t...FederationMixin.props\n\t},\n\tcomputed: {\n\t\tshowAll() {\n\t\t\treturn this.showInput && this.showOutput;\n\t\t},\n\t\ttypesToShow() {\n\t\t\tlet types = [];\n\t\t\tif (this.showInput) {\n\t\t\t\ttypes.push('input');\n\t\t\t}\n\t\t\tif (this.showOutput) {\n\t\t\t\ttypes.push('output');\n\t\t\t}\n\t\t\treturn types;\n\t\t},\n\t\tfileFormats() {\n\t\t\tlet data = [];\n\t\t\tfor(let type of this.typesToShow) {\n\t\t\t\tfor(var name in this.formats[type]) {\n\t\t\t\t\tlet format = Object.assign({id: `${name}-${type}`, name, type}, this.formats[type][name]);\n\t\t\t\t\tdata.push(format);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn data;\n\t\t}\n\t},\n\tbeforeCreate() {\n\t\tUtils.enableHtmlProps(this);\n\t},\n\tmethods: {\n\t\tdetailsToggled(...args) {\n\t\t\tthis.$emit('detailsToggled', ...args);\n\t\t}\n\t}\n}\n</script>\n\n<style lang=\"scss\">\n@import './base.scss';\n</style>","import mod from \"-!../../../@vue/vue-loader-v15/lib/index.js??vue-loader-options!./FileFormats.vue?vue&type=script&lang=js\"; export default mod; export * from \"-!../../../@vue/vue-loader-v15/lib/index.js??vue-loader-options!./FileFormats.vue?vue&type=script&lang=js\"","import { render, staticRenderFns } from \"./FileFormats.vue?vue&type=template&id=6a97a60d\"\nimport script from \"./FileFormats.vue?vue&type=script&lang=js\"\nexport * from \"./FileFormats.vue?vue&type=script&lang=js\"\nimport style0 from \"./FileFormats.vue?vue&type=style&index=0&id=6a97a60d&prod&lang=scss\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","var render = function render(){var _vm=this,_c=_vm._self._c;return _c('div',{staticClass:\"vue-component processes\"},[_c('SearchableList',{attrs:{\"data\":_vm.processes,\"keywordsKey\":\"categories\",\"showKeywords\":_vm.showCategories,\"showSummaryOnExpand\":false,\"externalSearchTerm\":_vm.searchTerm,\"externalHideDeprecated\":_vm.hideDeprecated,\"deprecatedFilter\":_vm.deprecatedFilter,\"sort\":_vm.sort,\"offerDetails\":_vm.offerDetails,\"heading\":_vm.heading,\"collapsed\":_vm.collapsed,\"loadAdditionalData\":_vm.loadAdditionalData,\"allowCopy\":\"\"},on:{\"detailsToggled\":_vm.detailsToggled},scopedSlots:_vm._u([{key:\"heading\",fn:function(scope){return [_vm._t(\"heading\",null,null,scope)]}},(_vm.missing)?{key:\"content-start\",fn:function(){return [_c('FederationMissingNotice',{attrs:{\"missing\":_vm.missing,\"federation\":_vm.federation}})]},proxy:true}:null,{key:\"summary\",fn:function(scope){return [_vm._t(\"summary\",null,null,scope)]}},{key:\"details\",fn:function(slot){return [_c('Process',{attrs:{\"process\":slot.item,\"provideDownload\":_vm.provideDownload,\"processUrl\":_vm.processUrl,\"showGraph\":_vm.showGraph,\"federation\":_vm.federation},scopedSlots:_vm._u([{key:\"title\",fn:function(){return [_c('span',{staticClass:\"hidden\"})]},proxy:true},{key:\"before-description\",fn:function(scope){return [_vm._t(\"process-before-description\",null,null,scope)]}},{key:\"end\",fn:function(scope){return [_vm._t(\"process-end\",null,null,scope)]}}],null,true)})]}}],null,true)})],1)\n}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\n\t<div class=\"vue-component processes\">\n\t\t<SearchableList :data=\"processes\" keywordsKey=\"categories\" :showKeywords=\"showCategories\" :showSummaryOnExpand=\"false\" :externalSearchTerm=\"searchTerm\" :externalHideDeprecated=\"hideDeprecated\" :deprecatedFilter=\"deprecatedFilter\" :sort=\"sort\" :offerDetails=\"offerDetails\" :heading=\"heading\" :collapsed=\"collapsed\" :loadAdditionalData=\"loadAdditionalData\" @detailsToggled=\"detailsToggled\" allowCopy>\n\t\t\t<template #heading=\"scope\"><slot name=\"heading\" v-bind=\"scope\" /></template>\n\t\t\t<template #content-start v-if=\"missing\"><FederationMissingNotice :missing=\"missing\" :federation=\"federation\" /></template>\n\t\t\t<template #summary=\"scope\"><slot name=\"summary\" v-bind=\"scope\" /></template>\n\t\t\t<template #details=\"slot\">\n\t\t\t\t<Process :process=\"slot.item\" :provideDownload=\"provideDownload\" :processUrl=\"processUrl\" :showGraph=\"showGraph\" :federation=\"federation\">\n\t\t\t\t\t<template #title><span class=\"hidden\" /></template>\n\t\t\t\t\t<template #before-description=\"scope\"><slot name=\"process-before-description\" v-bind=\"scope\" /></template>\n\t\t\t\t\t<template #end=\"scope\"><slot name=\"process-end\" v-bind=\"scope\" /></template>\n\t\t\t\t</Process>\n\t\t\t</template>\n\t\t</SearchableList>\n\t</div>\n</template>\n\n<script>\nimport Utils from '../utils';\nimport FederationMixin from './internal/FederationMixin.js';\n\nexport default {\n\tname: 'Processes',\n\tcomponents: {\n\t\tProcess: () => Utils.loadAsyncComponent(import('./Process.vue')),\n\t\tSearchableList: () => Utils.loadAsyncComponent(import('./SearchableList.vue'))\n\t},\n\tmixins: [\n\t\tFederationMixin\n\t],\n\tprops: {\n\t\tprocesses: {\n\t\t\ttype: Array,\n\t\t\tdefault: () => ([])\n\t\t},\n\t\tprovideDownload: {\n\t\t\ttype: Boolean,\n\t\t\tdefault: true\n\t\t},\n\t\tprocessUrl: String,\n\t\tsearchTerm: {\n\t\t\ttype: String,\n\t\t\tdefault: null\n\t\t},\n\t\tsort: {\n\t\t\ttype: Boolean,\n\t\t\tdefault: true\n\t\t},\n\t\tofferDetails: {\n\t\t\ttype: Boolean,\n\t\t\tdefault: true\n\t\t},\n\t\theading: {\n\t\t\ttype: String,\n\t\t\tdefault: 'Processes'\n\t\t},\n\t\tcollapsed: {\n\t\t\ttype: Boolean,\n\t\t\tdefault: null\n\t\t},\n\t\tshowCategories: {\n\t\t\ttype: Boolean,\n\t\t\tdefault: false\n\t\t},\n\t\tshowGraph: {\n\t\t\ttype: Boolean,\n\t\t\tdefault: false\n\t\t},\n\t\thideDeprecated: {\n\t\t\ttype: Boolean,\n\t\t\tdefault: false\n\t\t},\n\t\tdeprecatedFilter: {\n\t\t\ttype: Boolean,\n\t\t\tdefault: false\n\t\t},\n\t\tloadAdditionalData: {\n\t\t\ttype: Function,\n\t\t\tdefault: null\n\t\t},\n\t\tmissing: {\n\t\t\ttype: Array,\n\t\t\tdefault: null\n\t\t},\n\t\t...FederationMixin.props\n\t},\n\tbeforeCreate() {\n\t\tUtils.enableHtmlProps(this);\n\t},\n\tmethods: {\n\t\tdetailsToggled(...args) {\n\t\t\tthis.$emit('detailsToggled', ...args);\n\t\t}\n\t}\n}\n</script>\n\n<style lang=\"scss\">\n@import './base.scss';\n</style>","import mod from \"-!../../../@vue/vue-loader-v15/lib/index.js??vue-loader-options!./Processes.vue?vue&type=script&lang=js\"; export default mod; export * from \"-!../../../@vue/vue-loader-v15/lib/index.js??vue-loader-options!./Processes.vue?vue&type=script&lang=js\"","import { render, staticRenderFns } from \"./Processes.vue?vue&type=template&id=ff76f002\"\nimport script from \"./Processes.vue?vue&type=script&lang=js\"\nexport * from \"./Processes.vue?vue&type=script&lang=js\"\nimport style0 from \"./Processes.vue?vue&type=style&index=0&id=ff76f002&prod&lang=scss\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","var render = function render(){var _vm=this,_c=_vm._self._c;return _c('div',{staticClass:\"vue-component search-box\",class:{compact: _vm.compact}},[_c('span',{staticClass:\"icon\"},[_vm._v(\"🔎\")]),_c('input',{directives:[{name:\"model\",rawName:\"v-model\",value:(_vm.searchTerm),expression:\"searchTerm\"}],attrs:{\"type\":\"search\",\"placeholder\":_vm.placeholder,\"minlength\":_vm.minLength,\"title\":_vm.searchHint},domProps:{\"value\":(_vm.searchTerm)},on:{\"input\":function($event){if($event.target.composing)return;_vm.searchTerm=$event.target.value}}})])\n}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\n\t<div class=\"vue-component search-box\" :class=\"{compact}\">\n\t\t<span class=\"icon\">🔎</span>\n\t\t<input type=\"search\" v-model=\"searchTerm\" :placeholder=\"placeholder\" :minlength=\"minLength\" :title=\"searchHint\" />\n\t</div>\n</template>\n\n<script>\nexport default {\n\tname: 'SearchBox',\n\tprops: {\n\t\tvalue: {\n\t\t\ttype: String,\n\t\t\tdefault: ''\n\t\t},\n\t\tplaceholder: {\n\t\t\ttype: String,\n\t\t\tdefault: 'Search'\n\t\t},\n\t\tminLength: {\n\t\t\ttype: Number,\n\t\t\tdefault: 1\n\t\t},\n\t\tcompact: {\n\t\t\ttype: Boolean,\n\t\t\tdefault: false\n\t\t}\n\t},\n\tdata() {\n\t\treturn {\n\t\t\tsearchTerm: this.value\n\t\t};\n\t},\n\twatch: {\n\t\tsearchTerm(newValue, oldValue) {\n\t\t\tif (newValue.length < this.minLength) {\n\t\t\t\tnewValue = '';\n\t\t\t}\n\t\t\tthis.$emit('input', newValue);\n\t\t}\n\t},\n\tcomputed: {\n\t\tsearchHint() {\n\t\t\tif (this.minLength > 1) {\n\t\t\t\treturn `Searching requires at least ${this.minLength} characters.`;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}\n}\n</script>\n\n<style lang=\"scss\">\n@import './base.scss';\n\n.vue-component.search-box {\n    margin: 0 1px 1em 0;\n\tdisplay: flex;\n\talign-items: stretch;\n\n\tinput, .icon {\n\t\tfont-size: 1em;\n\t\tmargin: 0;\n\t}\n\tinput {\n\t\tflex-grow: 1;\n\t\tpadding: 0.3em;\n\t\tpadding-left: 1.9em;\n\t\tz-index: 1;\n\t\tborder: 1px solid #ccc;\n\t\tbox-sizing: content-box;\n\t\tbackground-color: #fff;\n\t\tbox-sizing: border-box;\n\t\twidth: 100%;\n\t\tmargin-left: -1.3em;\n\t}\n\t.icon {\n\t\tdisplay: flex;\n\t\talign-items: center;\n\t\tuser-select: none;\n\t\tmargin-left: 0.3em;\n\t\twidth: 1em;\n\t\tz-index: 2;\n\t}\n\t&.compact {\n\t\tfont-size: 0.9em;\n\t\tmargin-bottom: 0;\n\n\t\tinput {\n\t\t\tpadding-top: 0;\n\t\t\tpadding-bottom: 0;\n\t\t}\n\t\t.icon {\n\t\t\tmargin-top: 0.1em;\n\t\t\tmargin-left: 0.3em;\n\t\t}\n\t}\n}\n</style>","import mod from \"-!../../../@vue/vue-loader-v15/lib/index.js??vue-loader-options!./SearchBox.vue?vue&type=script&lang=js\"; export default mod; export * from \"-!../../../@vue/vue-loader-v15/lib/index.js??vue-loader-options!./SearchBox.vue?vue&type=script&lang=js\"","import { render, staticRenderFns } from \"./SearchBox.vue?vue&type=template&id=84942a5a\"\nimport script from \"./SearchBox.vue?vue&type=script&lang=js\"\nexport * from \"./SearchBox.vue?vue&type=script&lang=js\"\nimport style0 from \"./SearchBox.vue?vue&type=style&index=0&id=84942a5a&prod&lang=scss\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","const registry = new Map();\n\nexport function addDecoder(cases, importFn) {\n  if (!Array.isArray(cases)) {\n    cases = [cases]; // eslint-disable-line no-param-reassign\n  }\n  cases.forEach((c) => registry.set(c, importFn));\n}\n\nexport async function getDecoder(fileDirectory) {\n  const importFn = registry.get(fileDirectory.Compression);\n  if (!importFn) {\n    throw new Error(`Unknown compression method identifier: ${fileDirectory.Compression}`);\n  }\n  const Decoder = await importFn();\n  return new Decoder(fileDirectory);\n}\n\n// Add default decoders to registry (end-user may override with other implementations)\naddDecoder([undefined, 1], () => import('./raw.js').then((m) => m.default));\naddDecoder(5, () => import('./lzw.js').then((m) => m.default));\naddDecoder(6, () => {\n  throw new Error('old style JPEG compression is not supported.');\n});\naddDecoder(7, () => import('./jpeg.js').then((m) => m.default));\naddDecoder([8, 32946], () => import('./deflate.js').then((m) => m.default));\naddDecoder(32773, () => import('./packbits.js').then((m) => m.default));\naddDecoder(34887, () => import('./lerc.js')\n  .then(async (m) => {\n    await m.zstd.init();\n    return m;\n  })\n  .then((m) => m.default),\n);\naddDecoder(50001, () => import('./webimage.js').then((m) => m.default));\n","import { getFloat16 } from '@petamoriken/float16';\n\nexport default class DataView64 {\n  constructor(arrayBuffer) {\n    this._dataView = new DataView(arrayBuffer);\n  }\n\n  get buffer() {\n    return this._dataView.buffer;\n  }\n\n  getUint64(offset, littleEndian) {\n    const left = this.getUint32(offset, littleEndian);\n    const right = this.getUint32(offset + 4, littleEndian);\n    let combined;\n    if (littleEndian) {\n      combined = left + ((2 ** 32) * right);\n      if (!Number.isSafeInteger(combined)) {\n        throw new Error(\n          `${combined} exceeds MAX_SAFE_INTEGER. `\n          + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n        );\n      }\n      return combined;\n    }\n    combined = ((2 ** 32) * left) + right;\n    if (!Number.isSafeInteger(combined)) {\n      throw new Error(\n        `${combined} exceeds MAX_SAFE_INTEGER. `\n        + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n      );\n    }\n\n    return combined;\n  }\n\n  // adapted from https://stackoverflow.com/a/55338384/8060591\n  getInt64(offset, littleEndian) {\n    let value = 0;\n    const isNegative = (this._dataView.getUint8(offset + (littleEndian ? 7 : 0)) & 0x80) > 0;\n    let carrying = true;\n    for (let i = 0; i < 8; i++) {\n      let byte = this._dataView.getUint8(offset + (littleEndian ? i : 7 - i));\n      if (isNegative) {\n        if (carrying) {\n          if (byte !== 0x00) {\n            byte = ~(byte - 1) & 0xff;\n            carrying = false;\n          }\n        } else {\n          byte = ~byte & 0xff;\n        }\n      }\n      value += byte * (256 ** i);\n    }\n    if (isNegative) {\n      value = -value;\n    }\n    return value;\n  }\n\n  getUint8(offset, littleEndian) {\n    return this._dataView.getUint8(offset, littleEndian);\n  }\n\n  getInt8(offset, littleEndian) {\n    return this._dataView.getInt8(offset, littleEndian);\n  }\n\n  getUint16(offset, littleEndian) {\n    return this._dataView.getUint16(offset, littleEndian);\n  }\n\n  getInt16(offset, littleEndian) {\n    return this._dataView.getInt16(offset, littleEndian);\n  }\n\n  getUint32(offset, littleEndian) {\n    return this._dataView.getUint32(offset, littleEndian);\n  }\n\n  getInt32(offset, littleEndian) {\n    return this._dataView.getInt32(offset, littleEndian);\n  }\n\n  getFloat16(offset, littleEndian) {\n    return getFloat16(this._dataView, offset, littleEndian);\n  }\n\n  getFloat32(offset, littleEndian) {\n    return this._dataView.getFloat32(offset, littleEndian);\n  }\n\n  getFloat64(offset, littleEndian) {\n    return this._dataView.getFloat64(offset, littleEndian);\n  }\n}\n","export default class DataSlice {\n  constructor(arrayBuffer, sliceOffset, littleEndian, bigTiff) {\n    this._dataView = new DataView(arrayBuffer);\n    this._sliceOffset = sliceOffset;\n    this._littleEndian = littleEndian;\n    this._bigTiff = bigTiff;\n  }\n\n  get sliceOffset() {\n    return this._sliceOffset;\n  }\n\n  get sliceTop() {\n    return this._sliceOffset + this.buffer.byteLength;\n  }\n\n  get littleEndian() {\n    return this._littleEndian;\n  }\n\n  get bigTiff() {\n    return this._bigTiff;\n  }\n\n  get buffer() {\n    return this._dataView.buffer;\n  }\n\n  covers(offset, length) {\n    return this.sliceOffset <= offset && this.sliceTop >= offset + length;\n  }\n\n  readUint8(offset) {\n    return this._dataView.getUint8(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt8(offset) {\n    return this._dataView.getInt8(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint16(offset) {\n    return this._dataView.getUint16(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt16(offset) {\n    return this._dataView.getInt16(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint32(offset) {\n    return this._dataView.getUint32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt32(offset) {\n    return this._dataView.getInt32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readFloat32(offset) {\n    return this._dataView.getFloat32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readFloat64(offset) {\n    return this._dataView.getFloat64(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint64(offset) {\n    const left = this.readUint32(offset);\n    const right = this.readUint32(offset + 4);\n    let combined;\n    if (this._littleEndian) {\n      combined = left + ((2 ** 32) * right);\n      if (!Number.isSafeInteger(combined)) {\n        throw new Error(\n          `${combined} exceeds MAX_SAFE_INTEGER. `\n          + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n        );\n      }\n      return combined;\n    }\n    combined = ((2 ** 32) * left) + right;\n    if (!Number.isSafeInteger(combined)) {\n      throw new Error(\n        `${combined} exceeds MAX_SAFE_INTEGER. `\n        + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n      );\n    }\n\n    return combined;\n  }\n\n  // adapted from https://stackoverflow.com/a/55338384/8060591\n  readInt64(offset) {\n    let value = 0;\n    const isNegative = (this._dataView.getUint8(offset + (this._littleEndian ? 7 : 0)) & 0x80)\n      > 0;\n    let carrying = true;\n    for (let i = 0; i < 8; i++) {\n      let byte = this._dataView.getUint8(\n        offset + (this._littleEndian ? i : 7 - i),\n      );\n      if (isNegative) {\n        if (carrying) {\n          if (byte !== 0x00) {\n            byte = ~(byte - 1) & 0xff;\n            carrying = false;\n          }\n        } else {\n          byte = ~byte & 0xff;\n        }\n      }\n      value += byte * (256 ** i);\n    }\n    if (isNegative) {\n      value = -value;\n    }\n    return value;\n  }\n\n  readOffset(offset) {\n    if (this._bigTiff) {\n      return this.readUint64(offset);\n    }\n    return this.readUint32(offset);\n  }\n}\n","const CRLFCRLF = '\\r\\n\\r\\n';\n\n/*\n * Shim for 'Object.fromEntries'\n */\nfunction itemsToObject(items) {\n  if (typeof Object.fromEntries !== 'undefined') {\n    return Object.fromEntries(items);\n  }\n  const obj = {};\n  for (const [key, value] of items) {\n    obj[key.toLowerCase()] = value;\n  }\n  return obj;\n}\n\n/**\n * Parse HTTP headers from a given string.\n * @param {String} text the text to parse the headers from\n * @returns {Object} the parsed headers with lowercase keys\n */\nfunction parseHeaders(text) {\n  const items = text\n    .split('\\r\\n')\n    .map((line) => {\n      const kv = line.split(':').map((str) => str.trim());\n      kv[0] = kv[0].toLowerCase();\n      return kv;\n    });\n\n  return itemsToObject(items);\n}\n\n/**\n * Parse a 'Content-Type' header value to the content-type and parameters\n * @param {String} rawContentType the raw string to parse from\n * @returns {Object} the parsed content type with the fields: type and params\n */\nexport function parseContentType(rawContentType) {\n  const [type, ...rawParams] = rawContentType.split(';').map((s) => s.trim());\n  const paramsItems = rawParams.map((param) => param.split('='));\n  return { type, params: itemsToObject(paramsItems) };\n}\n\n/**\n * Parse a 'Content-Range' header value to its start, end, and total parts\n * @param {String} rawContentRange the raw string to parse from\n * @returns {Object} the parsed parts\n */\nexport function parseContentRange(rawContentRange) {\n  let start;\n  let end;\n  let total;\n\n  if (rawContentRange) {\n    [, start, end, total] = rawContentRange.match(/bytes (\\d+)-(\\d+)\\/(\\d+)/);\n    start = parseInt(start, 10);\n    end = parseInt(end, 10);\n    total = parseInt(total, 10);\n  }\n\n  return { start, end, total };\n}\n\n/**\n * Parses a list of byteranges from the given 'multipart/byteranges' HTTP response.\n * Each item in the list has the following properties:\n * - headers: the HTTP headers\n * - data: the sliced ArrayBuffer for that specific part\n * - offset: the offset of the byterange within its originating file\n * - length: the length of the byterange\n * @param {ArrayBuffer} responseArrayBuffer the response to be parsed and split\n * @param {String} boundary the boundary string used to split the sections\n * @returns {Object[]} the parsed byteranges\n */\nexport function parseByteRanges(responseArrayBuffer, boundary) {\n  let offset = null;\n  const decoder = new TextDecoder('ascii');\n  const out = [];\n\n  const startBoundary = `--${boundary}`;\n  const endBoundary = `${startBoundary}--`;\n\n  // search for the initial boundary, may be offset by some bytes\n  // TODO: more efficient to check for `--` in bytes directly\n  for (let i = 0; i < 10; ++i) {\n    const text = decoder.decode(\n      new Uint8Array(responseArrayBuffer, i, startBoundary.length),\n    );\n    if (text === startBoundary) {\n      offset = i;\n    }\n  }\n\n  if (offset === null) {\n    throw new Error('Could not find initial boundary');\n  }\n\n  while (offset < responseArrayBuffer.byteLength) {\n    const text = decoder.decode(\n      new Uint8Array(responseArrayBuffer, offset,\n        Math.min(startBoundary.length + 1024, responseArrayBuffer.byteLength - offset),\n      ),\n    );\n\n    // break if we arrived at the end\n    if (text.length === 0 || text.startsWith(endBoundary)) {\n      break;\n    }\n\n    // assert that we are actually dealing with a byterange and are at the correct offset\n    if (!text.startsWith(startBoundary)) {\n      throw new Error('Part does not start with boundary');\n    }\n\n    // get a substring from where we read the headers\n    const innerText = text.substr(startBoundary.length + 2);\n\n    if (innerText.length === 0) {\n      break;\n    }\n\n    // find the double linebreak that denotes the end of the headers\n    const endOfHeaders = innerText.indexOf(CRLFCRLF);\n\n    // parse the headers to get the content range size\n    const headers = parseHeaders(innerText.substr(0, endOfHeaders));\n    const { start, end, total } = parseContentRange(headers['content-range']);\n\n    // calculate the length of the slice and the next offset\n    const startOfData = offset + startBoundary.length + endOfHeaders + CRLFCRLF.length;\n    const length = parseInt(end, 10) + 1 - parseInt(start, 10);\n    out.push({\n      headers,\n      data: responseArrayBuffer.slice(startOfData, startOfData + length),\n      offset: start,\n      length,\n      fileSize: total,\n    });\n\n    offset = startOfData + length + 4;\n  }\n\n  return out;\n}\n","/**\n * @typedef Slice\n * @property {number} offset\n * @property {number} length\n */\n\nexport class BaseSource {\n  /**\n   *\n   * @param {Slice[]} slices\n   * @returns {ArrayBuffer[]}\n   */\n  async fetch(slices, signal = undefined) {\n    return Promise.all(\n      slices.map((slice) => this.fetchSlice(slice, signal)),\n    );\n  }\n\n  /**\n   *\n   * @param {Slice} slice\n   * @returns {ArrayBuffer}\n   */\n  async fetchSlice(slice) {\n    throw new Error(`fetching of slice ${slice} not possible, not implemented`);\n  }\n\n  /**\n   * Returns the filesize if already determined and null otherwise\n   */\n  get fileSize() {\n    return null;\n  }\n\n  async close() {\n    // no-op by default\n  }\n}\n","export function assign(target, source) {\n  for (const key in source) {\n    if (source.hasOwnProperty(key)) {\n      target[key] = source[key];\n    }\n  }\n}\n\nexport function chunk(iterable, length) {\n  const results = [];\n  const lengthOfIterable = iterable.length;\n  for (let i = 0; i < lengthOfIterable; i += length) {\n    const chunked = [];\n    for (let ci = i; ci < i + length; ci++) {\n      chunked.push(iterable[ci]);\n    }\n    results.push(chunked);\n  }\n  return results;\n}\n\nexport function endsWith(string, expectedEnding) {\n  if (string.length < expectedEnding.length) {\n    return false;\n  }\n  const actualEnding = string.substr(string.length - expectedEnding.length);\n  return actualEnding === expectedEnding;\n}\n\nexport function forEach(iterable, func) {\n  const { length } = iterable;\n  for (let i = 0; i < length; i++) {\n    func(iterable[i], i);\n  }\n}\n\nexport function invert(oldObj) {\n  const newObj = {};\n  for (const key in oldObj) {\n    if (oldObj.hasOwnProperty(key)) {\n      const value = oldObj[key];\n      newObj[value] = key;\n    }\n  }\n  return newObj;\n}\n\nexport function range(n) {\n  const results = [];\n  for (let i = 0; i < n; i++) {\n    results.push(i);\n  }\n  return results;\n}\n\nexport function times(numTimes, func) {\n  const results = [];\n  for (let i = 0; i < numTimes; i++) {\n    results.push(func(i));\n  }\n  return results;\n}\n\nexport function toArray(iterable) {\n  const results = [];\n  const { length } = iterable;\n  for (let i = 0; i < length; i++) {\n    results.push(iterable[i]);\n  }\n  return results;\n}\n\nexport function toArrayRecursively(input) {\n  if (input.length) {\n    return toArray(input).map(toArrayRecursively);\n  }\n  return input;\n}\n\n// copied from https://github.com/academia-de-codigo/parse-content-range-header/blob/master/index.js\nexport function parseContentRange(headerValue) {\n  if (!headerValue) {\n    return null;\n  }\n\n  if (typeof headerValue !== 'string') {\n    throw new Error('invalid argument');\n  }\n\n  const parseInt = (number) => Number.parseInt(number, 10);\n\n  // Check for presence of unit\n  let matches = headerValue.match(/^(\\w*) /);\n  const unit = matches && matches[1];\n\n  // check for start-end/size header format\n  matches = headerValue.match(/(\\d+)-(\\d+)\\/(\\d+|\\*)/);\n  if (matches) {\n    return {\n      unit,\n      first: parseInt(matches[1]),\n      last: parseInt(matches[2]),\n      length: matches[3] === '*' ? null : parseInt(matches[3]),\n    };\n  }\n\n  // check for size header format\n  matches = headerValue.match(/(\\d+|\\*)/);\n  if (matches) {\n    return {\n      unit,\n      first: null,\n      last: null,\n      length: matches[1] === '*' ? null : parseInt(matches[1]),\n    };\n  }\n\n  return null;\n}\n\n/*\n * Promisified wrapper around 'setTimeout' to allow 'await'\n */\nexport async function wait(milliseconds) {\n  return new Promise((resolve) => setTimeout(resolve, milliseconds));\n}\n\nexport function zip(a, b) {\n  const A = Array.isArray(a) ? a : Array.from(a);\n  const B = Array.isArray(b) ? b : Array.from(b);\n  return A.map((k, i) => [k, B[i]]);\n}\n\n// Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error\nexport class AbortError extends Error {\n  constructor(params) {\n    // Pass remaining arguments (including vendor specific ones) to parent constructor\n    super(params);\n\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AbortError);\n    }\n\n    this.name = 'AbortError';\n  }\n}\n\nexport class CustomAggregateError extends Error {\n  constructor(errors, message) {\n    super(message);\n    this.errors = errors;\n    this.message = message;\n    this.name = 'AggregateError';\n  }\n}\n\nexport const AggregateError = CustomAggregateError;\n","import QuickLRU from 'quick-lru';\nimport { BaseSource } from './basesource.js';\nimport { AbortError, AggregateError, wait, zip } from '../utils.js';\n\nclass Block {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {ArrayBuffer} [data]\n   */\n  constructor(offset, length, data = null) {\n    this.offset = offset;\n    this.length = length;\n    this.data = data;\n  }\n\n  /**\n   * @returns {number} the top byte border\n   */\n  get top() {\n    return this.offset + this.length;\n  }\n}\n\nclass BlockGroup {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {number[]} blockIds\n   */\n  constructor(offset, length, blockIds) {\n    this.offset = offset;\n    this.length = length;\n    this.blockIds = blockIds;\n  }\n}\n\nexport class BlockedSource extends BaseSource {\n  /**\n   *\n   * @param {BaseSource} source The underlying source that shall be blocked and cached\n   * @param {object} options\n   * @param {number} [options.blockSize]\n   * @param {number} [options.cacheSize]\n   */\n  constructor(source, { blockSize = 65536, cacheSize = 100 } = {}) {\n    super();\n    this.source = source;\n    this.blockSize = blockSize;\n\n    this.blockCache = new QuickLRU({\n      maxSize: cacheSize,\n      onEviction: (blockId, block) => {\n        this.evictedBlocks.set(blockId, block);\n      },\n    });\n\n    /** @type {Map<number, Block>} */\n    this.evictedBlocks = new Map();\n\n    // mapping blockId -> Block instance\n    this.blockRequests = new Map();\n\n    // set of blockIds missing for the current requests\n    this.blockIdsToFetch = new Set();\n\n    this.abortedBlockIds = new Set();\n  }\n\n  get fileSize() {\n    return this.source.fileSize;\n  }\n\n  /**\n   *\n   * @param {import(\"./basesource\").Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    const blockRequests = [];\n    const missingBlockIds = [];\n    const allBlockIds = [];\n    this.evictedBlocks.clear();\n\n    for (const { offset, length } of slices) {\n      let top = offset + length;\n\n      const { fileSize } = this;\n      if (fileSize !== null) {\n        top = Math.min(top, fileSize);\n      }\n\n      const firstBlockOffset = Math.floor(offset / this.blockSize) * this.blockSize;\n\n      for (let current = firstBlockOffset; current < top; current += this.blockSize) {\n        const blockId = Math.floor(current / this.blockSize);\n        if (!this.blockCache.has(blockId) && !this.blockRequests.has(blockId)) {\n          this.blockIdsToFetch.add(blockId);\n          missingBlockIds.push(blockId);\n        }\n        if (this.blockRequests.has(blockId)) {\n          blockRequests.push(this.blockRequests.get(blockId));\n        }\n        allBlockIds.push(blockId);\n      }\n    }\n\n    // allow additional block requests to accumulate\n    await wait();\n    this.fetchBlocks(signal);\n\n    // Gather all of the new requests that this fetch call is contributing to `fetch`.\n    const missingRequests = [];\n    for (const blockId of missingBlockIds) {\n      // The requested missing block could already be in the cache\n      // instead of having its request still be outstanding.\n      if (this.blockRequests.has(blockId)) {\n        missingRequests.push(this.blockRequests.get(blockId));\n      }\n    }\n\n    // Actually await all pending requests that are needed for this `fetch`.\n    await Promise.allSettled(blockRequests);\n    await Promise.allSettled(missingRequests);\n\n    // Perform retries if a block was interrupted by a previous signal\n    const abortedBlockRequests = [];\n    const abortedBlockIds = allBlockIds\n      .filter((id) => this.abortedBlockIds.has(id) || !this.blockCache.has(id));\n    abortedBlockIds.forEach((id) => this.blockIdsToFetch.add(id));\n    // start the retry of some blocks if required\n    if (abortedBlockIds.length > 0 && signal && !signal.aborted) {\n      this.fetchBlocks(null);\n      for (const blockId of abortedBlockIds) {\n        const block = this.blockRequests.get(blockId);\n        if (!block) {\n          throw new Error(`Block ${blockId} is not in the block requests`);\n        }\n        abortedBlockRequests.push(block);\n      }\n      await Promise.allSettled(abortedBlockRequests);\n    }\n\n    // throw an  abort error\n    if (signal && signal.aborted) {\n      throw new AbortError('Request was aborted');\n    }\n\n    const blocks = allBlockIds.map((id) => this.blockCache.get(id) || this.evictedBlocks.get(id));\n    const failedBlocks = blocks.filter((i) => !i);\n    if (failedBlocks.length) {\n      throw new AggregateError(failedBlocks, 'Request failed');\n    }\n\n    // create a final Map, with all required blocks for this request to satisfy\n    const requiredBlocks = new Map(zip(allBlockIds, blocks));\n\n    // TODO: satisfy each slice\n    return this.readSliceData(slices, requiredBlocks);\n  }\n\n  /**\n   *\n   * @param {AbortSignal} signal\n   */\n  fetchBlocks(signal) {\n    // check if we still need to\n    if (this.blockIdsToFetch.size > 0) {\n      const groups = this.groupBlocks(this.blockIdsToFetch);\n\n      // start requesting slices of data\n      const groupRequests = this.source.fetch(groups, signal);\n\n      for (let groupIndex = 0; groupIndex < groups.length; ++groupIndex) {\n        const group = groups[groupIndex];\n\n        for (const blockId of group.blockIds) {\n          // make an async IIFE for each block\n          this.blockRequests.set(blockId, (async () => {\n            try {\n              const response = (await groupRequests)[groupIndex];\n              const blockOffset = blockId * this.blockSize;\n              const o = blockOffset - response.offset;\n              const t = Math.min(o + this.blockSize, response.data.byteLength);\n              const data = response.data.slice(o, t);\n              const block = new Block(\n                blockOffset,\n                data.byteLength,\n                data,\n                blockId,\n              );\n              this.blockCache.set(blockId, block);\n              this.abortedBlockIds.delete(blockId);\n            } catch (err) {\n              if (err.name === 'AbortError') {\n                // store the signal here, we need it to determine later if an\n                // error was caused by this signal\n                err.signal = signal;\n                this.blockCache.delete(blockId);\n                this.abortedBlockIds.add(blockId);\n              } else {\n                throw err;\n              }\n            } finally {\n              this.blockRequests.delete(blockId);\n            }\n          })());\n        }\n      }\n      this.blockIdsToFetch.clear();\n    }\n  }\n\n  /**\n   *\n   * @param {Set} blockIds\n   * @returns {BlockGroup[]}\n   */\n  groupBlocks(blockIds) {\n    const sortedBlockIds = Array.from(blockIds).sort((a, b) => a - b);\n    if (sortedBlockIds.length === 0) {\n      return [];\n    }\n    let current = [];\n    let lastBlockId = null;\n    const groups = [];\n\n    for (const blockId of sortedBlockIds) {\n      if (lastBlockId === null || lastBlockId + 1 === blockId) {\n        current.push(blockId);\n        lastBlockId = blockId;\n      } else {\n        groups.push(new BlockGroup(\n          current[0] * this.blockSize,\n          current.length * this.blockSize,\n          current,\n        ));\n        current = [blockId];\n        lastBlockId = blockId;\n      }\n    }\n\n    groups.push(new BlockGroup(\n      current[0] * this.blockSize,\n      current.length * this.blockSize,\n      current,\n    ));\n\n    return groups;\n  }\n\n  /**\n   *\n   * @param {import(\"./basesource\").Slice[]} slices\n   * @param {Map} blocks\n   */\n  readSliceData(slices, blocks) {\n    return slices.map((slice) => {\n      let top = slice.offset + slice.length;\n      if (this.fileSize !== null) {\n        top = Math.min(this.fileSize, top);\n      }\n      const blockIdLow = Math.floor(slice.offset / this.blockSize);\n      const blockIdHigh = Math.floor(top / this.blockSize);\n      const sliceData = new ArrayBuffer(slice.length);\n      const sliceView = new Uint8Array(sliceData);\n\n      for (let blockId = blockIdLow; blockId <= blockIdHigh; ++blockId) {\n        const block = blocks.get(blockId);\n        const delta = block.offset - slice.offset;\n        const topDelta = block.top - top;\n        let blockInnerOffset = 0;\n        let rangeInnerOffset = 0;\n        let usedBlockLength;\n\n        if (delta < 0) {\n          blockInnerOffset = -delta;\n        } else if (delta > 0) {\n          rangeInnerOffset = delta;\n        }\n\n        if (topDelta < 0) {\n          usedBlockLength = block.length - blockInnerOffset;\n        } else {\n          usedBlockLength = top - block.offset - blockInnerOffset;\n        }\n\n        const blockView = new Uint8Array(block.data, blockInnerOffset, usedBlockLength);\n        sliceView.set(blockView, rangeInnerOffset);\n      }\n\n      return sliceData;\n    });\n  }\n}\n","export class BaseResponse {\n  /**\n   * Returns whether the response has an ok'ish status code\n   */\n  get ok() {\n    return this.status >= 200 && this.status <= 299;\n  }\n\n  /**\n   * Returns the status code of the response\n   */\n  get status() {\n    throw new Error('not implemented');\n  }\n\n  /**\n   * Returns the value of the specified header\n   * @param {string} headerName the header name\n   * @returns {string} the header value\n   */\n  getHeader(headerName) { // eslint-disable-line no-unused-vars\n    throw new Error('not implemented');\n  }\n\n  /**\n   * @returns {ArrayBuffer} the response data of the request\n   */\n  async getData() {\n    throw new Error('not implemented');\n  }\n}\n\nexport class BaseClient {\n  constructor(url) {\n    this.url = url;\n  }\n\n  /**\n   * Send a request with the options\n   * @param {{headers: HeadersInit, signal: AbortSignal}} [options={}]\n   * @returns {Promise<BaseResponse>}\n   */\n  async request({ headers, signal } = {}) { // eslint-disable-line no-unused-vars\n    throw new Error('request is not implemented');\n  }\n}\n","import { BaseClient, BaseResponse } from './base.js';\n\nclass FetchResponse extends BaseResponse {\n  /**\n   * BaseResponse facade for fetch API Response\n   * @param {Response} response\n   */\n  constructor(response) {\n    super();\n    this.response = response;\n  }\n\n  get status() {\n    return this.response.status;\n  }\n\n  getHeader(name) {\n    return this.response.headers.get(name);\n  }\n\n  async getData() {\n    const data = this.response.arrayBuffer\n      ? await this.response.arrayBuffer()\n      : (await this.response.buffer()).buffer;\n    return data;\n  }\n}\n\nexport class FetchClient extends BaseClient {\n  constructor(url, credentials) {\n    super(url);\n    this.credentials = credentials;\n  }\n\n  /**\n   * @param {{headers: HeadersInit, signal: AbortSignal}} [options={}]\n   * @returns {Promise<FetchResponse>}\n   */\n  async request({ headers, signal } = {}) {\n    const response = await fetch(this.url, {\n      headers, credentials: this.credentials, signal,\n    });\n    return new FetchResponse(response);\n  }\n}\n","import { BaseClient, BaseResponse } from './base.js';\nimport { AbortError } from '../../utils.js';\n\nclass XHRResponse extends BaseResponse {\n  /**\n   * BaseResponse facade for XMLHttpRequest\n   * @param {XMLHttpRequest} xhr\n   * @param {ArrayBuffer} data\n   */\n  constructor(xhr, data) {\n    super();\n    this.xhr = xhr;\n    this.data = data;\n  }\n\n  get status() {\n    return this.xhr.status;\n  }\n\n  getHeader(name) {\n    return this.xhr.getResponseHeader(name);\n  }\n\n  async getData() {\n    return this.data;\n  }\n}\n\nexport class XHRClient extends BaseClient {\n  constructRequest(headers, signal) {\n    return new Promise((resolve, reject) => {\n      const xhr = new XMLHttpRequest();\n      xhr.open('GET', this.url);\n      xhr.responseType = 'arraybuffer';\n      for (const [key, value] of Object.entries(headers)) {\n        xhr.setRequestHeader(key, value);\n      }\n\n      // hook signals\n      xhr.onload = () => {\n        const data = xhr.response;\n        resolve(new XHRResponse(xhr, data));\n      };\n      xhr.onerror = reject;\n      xhr.onabort = () => reject(new AbortError('Request aborted'));\n      xhr.send();\n\n      if (signal) {\n        if (signal.aborted) {\n          xhr.abort();\n        }\n        signal.addEventListener('abort', () => xhr.abort());\n      }\n    });\n  }\n\n  async request({ headers, signal } = {}) {\n    const response = await this.constructRequest(headers, signal);\n    return response;\n  }\n}\n","import http from 'http';\nimport https from 'https';\nimport urlMod from 'url';\n\nimport { BaseClient, BaseResponse } from './base.js';\nimport { AbortError } from '../../utils.js';\n\nclass HttpResponse extends BaseResponse {\n  /**\n   * BaseResponse facade for node HTTP/HTTPS API Response\n   * @param {http.ServerResponse} response\n   */\n  constructor(response, dataPromise) {\n    super();\n    this.response = response;\n    this.dataPromise = dataPromise;\n  }\n\n  get status() {\n    return this.response.statusCode;\n  }\n\n  getHeader(name) {\n    return this.response.headers[name];\n  }\n\n  async getData() {\n    const data = await this.dataPromise;\n    return data;\n  }\n}\n\nexport class HttpClient extends BaseClient {\n  constructor(url) {\n    super(url);\n    this.parsedUrl = urlMod.parse(this.url);\n    this.httpApi = (this.parsedUrl.protocol === 'http:' ? http : https);\n  }\n\n  constructRequest(headers, signal) {\n    return new Promise((resolve, reject) => {\n      const request = this.httpApi.get(\n        {\n          ...this.parsedUrl,\n          headers,\n        },\n        (response) => {\n          const dataPromise = new Promise((resolveData) => {\n            const chunks = [];\n\n            // collect chunks\n            response.on('data', (chunk) => {\n              chunks.push(chunk);\n            });\n\n            // concatenate all chunks and resolve the promise with the resulting buffer\n            response.on('end', () => {\n              const data = Buffer.concat(chunks).buffer;\n              resolveData(data);\n            });\n            response.on('error', reject);\n          });\n          resolve(new HttpResponse(response, dataPromise));\n        },\n      );\n      request.on('error', reject);\n\n      if (signal) {\n        if (signal.aborted) {\n          request.destroy(new AbortError('Request aborted'));\n        }\n        signal.addEventListener('abort', () => request.destroy(new AbortError('Request aborted')));\n      }\n    });\n  }\n\n  async request({ headers, signal } = {}) {\n    const response = await this.constructRequest(headers, signal);\n    return response;\n  }\n}\n","import { parseByteRanges, parseContentRange, parseContentType } from './httputils.js';\nimport { BaseSource } from './basesource.js';\nimport { BlockedSource } from './blockedsource.js';\n\nimport { FetchClient } from './client/fetch.js';\nimport { XHRClient } from './client/xhr.js';\nimport { HttpClient } from './client/http.js';\n\nclass RemoteSource extends BaseSource {\n  /**\n   *\n   * @param {BaseClient} client\n   * @param {object} headers\n   * @param {numbers} maxRanges\n   * @param {boolean} allowFullFile\n   */\n  constructor(client, headers, maxRanges, allowFullFile) {\n    super();\n    this.client = client;\n    this.headers = headers;\n    this.maxRanges = maxRanges;\n    this.allowFullFile = allowFullFile;\n    this._fileSize = null;\n  }\n\n  /**\n   *\n   * @param {Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    // if we allow multi-ranges, split the incoming request into that many sub-requests\n    // and join them afterwards\n    if (this.maxRanges >= slices.length) {\n      return this.fetchSlices(slices, signal);\n    } else if (this.maxRanges > 0 && slices.length > 1) {\n      // TODO: split into multiple multi-range requests\n\n      // const subSlicesRequests = [];\n      // for (let i = 0; i < slices.length; i += this.maxRanges) {\n      //   subSlicesRequests.push(\n      //     this.fetchSlices(slices.slice(i, i + this.maxRanges), signal),\n      //   );\n      // }\n      // return (await Promise.all(subSlicesRequests)).flat();\n    }\n\n    // otherwise make a single request for each slice\n    return Promise.all(\n      slices.map((slice) => this.fetchSlice(slice, signal)),\n    );\n  }\n\n  async fetchSlices(slices, signal) {\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${slices\n          .map(({ offset, length }) => `${offset}-${offset + length}`)\n          .join(',')\n        }`,\n      },\n      signal,\n    });\n\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const { type, params } = parseContentType(response.getHeader('content-type'));\n      if (type === 'multipart/byteranges') {\n        const byteRanges = parseByteRanges(await response.getData(), params.boundary);\n        this._fileSize = byteRanges[0].fileSize || null;\n        return byteRanges;\n      }\n\n      const data = await response.getData();\n\n      const { start, end, total } = parseContentRange(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      const first = [{\n        data,\n        offset: start,\n        length: end - start,\n      }];\n\n      if (slices.length > 1) {\n        // we requested more than one slice, but got only the first\n        // unfortunately, some HTTP Servers don't support multi-ranges\n        // and return only the first\n\n        // get the rest of the slices and fetch them iteratively\n        const others = await Promise.all(slices.slice(1).map((slice) => this.fetchSlice(slice, signal)));\n        return first.concat(others);\n      }\n      return first;\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n      const data = await response.getData();\n      this._fileSize = data.byteLength;\n      return [{\n        data,\n        offset: 0,\n        length: data.byteLength,\n      }];\n    }\n  }\n\n  async fetchSlice(slice, signal) {\n    const { offset, length } = slice;\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${offset}-${offset + length}`,\n      },\n      signal,\n    });\n\n    // check the response was okay and if the server actually understands range requests\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const data = await response.getData();\n\n      const { total } = parseContentRange(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      return {\n        data,\n        offset,\n        length,\n      };\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n\n      const data = await response.getData();\n\n      this._fileSize = data.byteLength;\n      return {\n        data,\n        offset: 0,\n        length: data.byteLength,\n      };\n    }\n  }\n\n  get fileSize() {\n    return this._fileSize;\n  }\n}\n\nfunction maybeWrapInBlockedSource(source, { blockSize, cacheSize }) {\n  if (blockSize === null) {\n    return source;\n  }\n  return new BlockedSource(source, { blockSize, cacheSize });\n}\n\nexport function makeFetchSource(url, { headers = {}, credentials, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new FetchClient(url, credentials);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nexport function makeXHRSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new XHRClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nexport function makeHttpSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new HttpClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nexport function makeCustomSource(client, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\n/**\n *\n * @param {string} url\n * @param {object} options\n */\nexport function makeRemoteSource(url, { forceXHR = false, ...clientOptions } = {}) {\n  if (typeof fetch === 'function' && !forceXHR) {\n    return makeFetchSource(url, clientOptions);\n  }\n  if (typeof XMLHttpRequest !== 'undefined') {\n    return makeXHRSource(url, clientOptions);\n  }\n  return makeHttpSource(url, clientOptions);\n}\n","import { BaseSource } from './basesource.js';\n\nclass FileReaderSource extends BaseSource {\n  constructor(file) {\n    super();\n    this.file = file;\n  }\n\n  async fetchSlice(slice, signal) {\n    return new Promise((resolve, reject) => {\n      const blob = this.file.slice(slice.offset, slice.offset + slice.length);\n      const reader = new FileReader();\n      reader.onload = (event) => resolve(event.target.result);\n      reader.onerror = reject;\n      reader.onabort = reject;\n      reader.readAsArrayBuffer(blob);\n\n      if (signal) {\n        signal.addEventListener('abort', () => reader.abort());\n      }\n    });\n  }\n}\n\n/**\n * Create a new source from a given file/blob.\n * @param {Blob} file The file or blob to read from.\n * @returns The constructed source\n */\nexport function makeFileReaderSource(file) {\n  return new FileReaderSource(file);\n}\n","/** @module geotiff */\nimport GeoTIFFImage from './geotiffimage.js';\nimport DataView64 from './dataview64.js';\nimport DataSlice from './dataslice.js';\nimport Pool from './pool.js';\n\nimport { makeRemoteSource, makeCustomSource } from './source/remote.js';\nimport { makeBufferSource } from './source/arraybuffer.js';\nimport { makeFileReaderSource } from './source/filereader.js';\nimport { makeFileSource } from './source/file.js';\nimport { BaseClient, BaseResponse } from './source/client/base.js';\n\nimport { fieldTypes, fieldTagNames, arrayFields, geoKeyNames } from './globals.js';\nimport { writeGeotiff } from './geotiffwriter.js';\nimport * as globals from './globals.js';\nimport * as rgb from './rgb.js';\nimport { getDecoder, addDecoder } from './compression/index.js';\nimport { setLogger } from './logging.js';\n\nexport { globals };\nexport { rgb };\nexport { default as BaseDecoder } from './compression/basedecoder.js';\nexport { getDecoder, addDecoder };\nexport { setLogger };\n\n/**\n * @typedef {Uint8Array | Int8Array | Uint16Array | Int16Array | Uint32Array | Int32Array | Float32Array | Float64Array}\n * TypedArray\n */\n\n/**\n * @typedef {{ height:number, width: number }} Dimensions\n */\n\n/**\n * The autogenerated docs are a little confusing here. The effective type is:\n *\n * `TypedArray & { height: number; width: number}`\n * @typedef {TypedArray & Dimensions} TypedArrayWithDimensions\n */\n\n/**\n * The autogenerated docs are a little confusing here. The effective type is:\n *\n * `TypedArray[] & { height: number; width: number}`\n * @typedef {TypedArray[] & Dimensions} TypedArrayArrayWithDimensions\n */\n\n/**\n *  The autogenerated docs are a little confusing here. The effective type is:\n *\n * `(TypedArray | TypedArray[]) & { height: number; width: number}`\n * @typedef {TypedArrayWithDimensions | TypedArrayArrayWithDimensions} ReadRasterResult\n */\n\nfunction getFieldTypeLength(fieldType) {\n  switch (fieldType) {\n    case fieldTypes.BYTE: case fieldTypes.ASCII: case fieldTypes.SBYTE: case fieldTypes.UNDEFINED:\n      return 1;\n    case fieldTypes.SHORT: case fieldTypes.SSHORT:\n      return 2;\n    case fieldTypes.LONG: case fieldTypes.SLONG: case fieldTypes.FLOAT: case fieldTypes.IFD:\n      return 4;\n    case fieldTypes.RATIONAL: case fieldTypes.SRATIONAL: case fieldTypes.DOUBLE:\n    case fieldTypes.LONG8: case fieldTypes.SLONG8: case fieldTypes.IFD8:\n      return 8;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n}\n\nfunction parseGeoKeyDirectory(fileDirectory) {\n  const rawGeoKeyDirectory = fileDirectory.GeoKeyDirectory;\n  if (!rawGeoKeyDirectory) {\n    return null;\n  }\n\n  const geoKeyDirectory = {};\n  for (let i = 4; i <= rawGeoKeyDirectory[3] * 4; i += 4) {\n    const key = geoKeyNames[rawGeoKeyDirectory[i]];\n    const location = (rawGeoKeyDirectory[i + 1])\n      ? (fieldTagNames[rawGeoKeyDirectory[i + 1]]) : null;\n    const count = rawGeoKeyDirectory[i + 2];\n    const offset = rawGeoKeyDirectory[i + 3];\n\n    let value = null;\n    if (!location) {\n      value = offset;\n    } else {\n      value = fileDirectory[location];\n      if (typeof value === 'undefined' || value === null) {\n        throw new Error(`Could not get value of geoKey '${key}'.`);\n      } else if (typeof value === 'string') {\n        value = value.substring(offset, offset + count - 1);\n      } else if (value.subarray) {\n        value = value.subarray(offset, offset + count);\n        if (count === 1) {\n          value = value[0];\n        }\n      }\n    }\n    geoKeyDirectory[key] = value;\n  }\n  return geoKeyDirectory;\n}\n\nfunction getValues(dataSlice, fieldType, count, offset) {\n  let values = null;\n  let readMethod = null;\n  const fieldTypeLength = getFieldTypeLength(fieldType);\n\n  switch (fieldType) {\n    case fieldTypes.BYTE: case fieldTypes.ASCII: case fieldTypes.UNDEFINED:\n      values = new Uint8Array(count); readMethod = dataSlice.readUint8;\n      break;\n    case fieldTypes.SBYTE:\n      values = new Int8Array(count); readMethod = dataSlice.readInt8;\n      break;\n    case fieldTypes.SHORT:\n      values = new Uint16Array(count); readMethod = dataSlice.readUint16;\n      break;\n    case fieldTypes.SSHORT:\n      values = new Int16Array(count); readMethod = dataSlice.readInt16;\n      break;\n    case fieldTypes.LONG: case fieldTypes.IFD:\n      values = new Uint32Array(count); readMethod = dataSlice.readUint32;\n      break;\n    case fieldTypes.SLONG:\n      values = new Int32Array(count); readMethod = dataSlice.readInt32;\n      break;\n    case fieldTypes.LONG8: case fieldTypes.IFD8:\n      values = new Array(count); readMethod = dataSlice.readUint64;\n      break;\n    case fieldTypes.SLONG8:\n      values = new Array(count); readMethod = dataSlice.readInt64;\n      break;\n    case fieldTypes.RATIONAL:\n      values = new Uint32Array(count * 2); readMethod = dataSlice.readUint32;\n      break;\n    case fieldTypes.SRATIONAL:\n      values = new Int32Array(count * 2); readMethod = dataSlice.readInt32;\n      break;\n    case fieldTypes.FLOAT:\n      values = new Float32Array(count); readMethod = dataSlice.readFloat32;\n      break;\n    case fieldTypes.DOUBLE:\n      values = new Float64Array(count); readMethod = dataSlice.readFloat64;\n      break;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n\n  // normal fields\n  if (!(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {\n    for (let i = 0; i < count; ++i) {\n      values[i] = readMethod.call(\n        dataSlice, offset + (i * fieldTypeLength),\n      );\n    }\n  } else { // RATIONAL or SRATIONAL\n    for (let i = 0; i < count; i += 2) {\n      values[i] = readMethod.call(\n        dataSlice, offset + (i * fieldTypeLength),\n      );\n      values[i + 1] = readMethod.call(\n        dataSlice, offset + ((i * fieldTypeLength) + 4),\n      );\n    }\n  }\n\n  if (fieldType === fieldTypes.ASCII) {\n    return new TextDecoder('utf-8').decode(values);\n  }\n  return values;\n}\n\n/**\n * Data class to store the parsed file directory, geo key directory and\n * offset to the next IFD\n */\nclass ImageFileDirectory {\n  constructor(fileDirectory, geoKeyDirectory, nextIFDByteOffset) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeyDirectory = geoKeyDirectory;\n    this.nextIFDByteOffset = nextIFDByteOffset;\n  }\n}\n\n/**\n * Error class for cases when an IFD index was requested, that does not exist\n * in the file.\n */\nclass GeoTIFFImageIndexError extends Error {\n  constructor(index) {\n    super(`No image at index ${index}`);\n    this.index = index;\n  }\n}\n\nclass GeoTIFFBase {\n  /**\n   * (experimental) Reads raster data from the best fitting image. This function uses\n   * the image with the lowest resolution that is still a higher resolution than the\n   * requested resolution.\n   * When specified, the `bbox` option is translated to the `window` option and the\n   * `resX` and `resY` to `width` and `height` respectively.\n   * Then, the [readRasters]{@link GeoTIFFImage#readRasters} method of the selected\n   * image is called and the result returned.\n   * @see GeoTIFFImage.readRasters\n   * @param {import('./geotiffimage').ReadRasterOptions} [options={}] optional parameters\n   * @returns {Promise<ReadRasterResult>} the decoded array(s), with `height` and `width`, as a promise\n   */\n  async readRasters(options = {}) {\n    const { window: imageWindow, width, height } = options;\n    let { resX, resY, bbox } = options;\n\n    const firstImage = await this.getImage();\n    let usedImage = firstImage;\n    const imageCount = await this.getImageCount();\n    const imgBBox = firstImage.getBoundingBox();\n\n    if (imageWindow && bbox) {\n      throw new Error('Both \"bbox\" and \"window\" passed.');\n    }\n\n    // if width/height is passed, transform it to resolution\n    if (width || height) {\n      // if we have an image window (pixel coordinates), transform it to a BBox\n      // using the origin/resolution of the first image.\n      if (imageWindow) {\n        const [oX, oY] = firstImage.getOrigin();\n        const [rX, rY] = firstImage.getResolution();\n\n        bbox = [\n          oX + (imageWindow[0] * rX),\n          oY + (imageWindow[1] * rY),\n          oX + (imageWindow[2] * rX),\n          oY + (imageWindow[3] * rY),\n        ];\n      }\n\n      // if we have a bbox (or calculated one)\n\n      const usedBBox = bbox || imgBBox;\n\n      if (width) {\n        if (resX) {\n          throw new Error('Both width and resX passed');\n        }\n        resX = (usedBBox[2] - usedBBox[0]) / width;\n      }\n      if (height) {\n        if (resY) {\n          throw new Error('Both width and resY passed');\n        }\n        resY = (usedBBox[3] - usedBBox[1]) / height;\n      }\n    }\n\n    // if resolution is set or calculated, try to get the image with the worst acceptable resolution\n    if (resX || resY) {\n      const allImages = [];\n      for (let i = 0; i < imageCount; ++i) {\n        const image = await this.getImage(i);\n        const { SubfileType: subfileType, NewSubfileType: newSubfileType } = image.fileDirectory;\n        if (i === 0 || subfileType === 2 || newSubfileType & 1) {\n          allImages.push(image);\n        }\n      }\n\n      allImages.sort((a, b) => a.getWidth() - b.getWidth());\n      for (let i = 0; i < allImages.length; ++i) {\n        const image = allImages[i];\n        const imgResX = (imgBBox[2] - imgBBox[0]) / image.getWidth();\n        const imgResY = (imgBBox[3] - imgBBox[1]) / image.getHeight();\n\n        usedImage = image;\n        if ((resX && resX > imgResX) || (resY && resY > imgResY)) {\n          break;\n        }\n      }\n    }\n\n    let wnd = imageWindow;\n    if (bbox) {\n      const [oX, oY] = firstImage.getOrigin();\n      const [imageResX, imageResY] = usedImage.getResolution(firstImage);\n\n      wnd = [\n        Math.round((bbox[0] - oX) / imageResX),\n        Math.round((bbox[1] - oY) / imageResY),\n        Math.round((bbox[2] - oX) / imageResX),\n        Math.round((bbox[3] - oY) / imageResY),\n      ];\n      wnd = [\n        Math.min(wnd[0], wnd[2]),\n        Math.min(wnd[1], wnd[3]),\n        Math.max(wnd[0], wnd[2]),\n        Math.max(wnd[1], wnd[3]),\n      ];\n    }\n\n    return usedImage.readRasters({ ...options, window: wnd });\n  }\n}\n\n/**\n * @typedef {Object} GeoTIFFOptions\n * @property {boolean} [cache=false] whether or not decoded tiles shall be cached.\n */\n\n/**\n * The abstraction for a whole GeoTIFF file.\n * @augments GeoTIFFBase\n */\nclass GeoTIFF extends GeoTIFFBase {\n  /**\n   * @constructor\n   * @param {*} source The datasource to read from.\n   * @param {boolean} littleEndian Whether the image uses little endian.\n   * @param {boolean} bigTiff Whether the image uses bigTIFF conventions.\n   * @param {number} firstIFDOffset The numeric byte-offset from the start of the image\n   *                                to the first IFD.\n   * @param {GeoTIFFOptions} [options] further options.\n   */\n  constructor(source, littleEndian, bigTiff, firstIFDOffset, options = {}) {\n    super();\n    this.source = source;\n    this.littleEndian = littleEndian;\n    this.bigTiff = bigTiff;\n    this.firstIFDOffset = firstIFDOffset;\n    this.cache = options.cache || false;\n    this.ifdRequests = [];\n    this.ghostValues = null;\n  }\n\n  async getSlice(offset, size) {\n    const fallbackSize = this.bigTiff ? 4048 : 1024;\n    return new DataSlice(\n      (await this.source.fetch([{\n        offset,\n        length: typeof size !== 'undefined' ? size : fallbackSize,\n      }]))[0],\n      offset,\n      this.littleEndian,\n      this.bigTiff,\n    );\n  }\n\n  /**\n   * Instructs to parse an image file directory at the given file offset.\n   * As there is no way to ensure that a location is indeed the start of an IFD,\n   * this function must be called with caution (e.g only using the IFD offsets from\n   * the headers or other IFDs).\n   * @param {number} offset the offset to parse the IFD at\n   * @returns {Promise<ImageFileDirectory>} the parsed IFD\n   */\n  async parseFileDirectoryAt(offset) {\n    const entrySize = this.bigTiff ? 20 : 12;\n    const offsetSize = this.bigTiff ? 8 : 2;\n\n    let dataSlice = await this.getSlice(offset);\n    const numDirEntries = this.bigTiff\n      ? dataSlice.readUint64(offset)\n      : dataSlice.readUint16(offset);\n\n    // if the slice does not cover the whole IFD, request a bigger slice, where the\n    // whole IFD fits: num of entries + n x tag length + offset to next IFD\n    const byteSize = (numDirEntries * entrySize) + (this.bigTiff ? 16 : 6);\n    if (!dataSlice.covers(offset, byteSize)) {\n      dataSlice = await this.getSlice(offset, byteSize);\n    }\n\n    const fileDirectory = {};\n\n    // loop over the IFD and create a file directory object\n    let i = offset + (this.bigTiff ? 8 : 2);\n    for (let entryCount = 0; entryCount < numDirEntries; i += entrySize, ++entryCount) {\n      const fieldTag = dataSlice.readUint16(i);\n      const fieldType = dataSlice.readUint16(i + 2);\n      const typeCount = this.bigTiff\n        ? dataSlice.readUint64(i + 4)\n        : dataSlice.readUint32(i + 4);\n\n      let fieldValues;\n      let value;\n      const fieldTypeLength = getFieldTypeLength(fieldType);\n      const valueOffset = i + (this.bigTiff ? 12 : 8);\n\n      // check whether the value is directly encoded in the tag or refers to a\n      // different external byte range\n      if (fieldTypeLength * typeCount <= (this.bigTiff ? 8 : 4)) {\n        fieldValues = getValues(dataSlice, fieldType, typeCount, valueOffset);\n      } else {\n        // resolve the reference to the actual byte range\n        const actualOffset = dataSlice.readOffset(valueOffset);\n        const length = getFieldTypeLength(fieldType) * typeCount;\n\n        // check, whether we actually cover the referenced byte range; if not,\n        // request a new slice of bytes to read from it\n        if (dataSlice.covers(actualOffset, length)) {\n          fieldValues = getValues(dataSlice, fieldType, typeCount, actualOffset);\n        } else {\n          const fieldDataSlice = await this.getSlice(actualOffset, length);\n          fieldValues = getValues(fieldDataSlice, fieldType, typeCount, actualOffset);\n        }\n      }\n\n      // unpack single values from the array\n      if (typeCount === 1 && arrayFields.indexOf(fieldTag) === -1\n        && !(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {\n        value = fieldValues[0];\n      } else {\n        value = fieldValues;\n      }\n\n      // write the tags value to the file directly\n      fileDirectory[fieldTagNames[fieldTag]] = value;\n    }\n    const geoKeyDirectory = parseGeoKeyDirectory(fileDirectory);\n    const nextIFDByteOffset = dataSlice.readOffset(\n      offset + offsetSize + (entrySize * numDirEntries),\n    );\n\n    return new ImageFileDirectory(\n      fileDirectory,\n      geoKeyDirectory,\n      nextIFDByteOffset,\n    );\n  }\n\n  async requestIFD(index) {\n    // see if we already have that IFD index requested.\n    if (this.ifdRequests[index]) {\n      // attach to an already requested IFD\n      return this.ifdRequests[index];\n    } else if (index === 0) {\n      // special case for index 0\n      this.ifdRequests[index] = this.parseFileDirectoryAt(this.firstIFDOffset);\n      return this.ifdRequests[index];\n    } else if (!this.ifdRequests[index - 1]) {\n      // if the previous IFD was not yet loaded, load that one first\n      // this is the recursive call.\n      try {\n        this.ifdRequests[index - 1] = this.requestIFD(index - 1);\n      } catch (e) {\n        // if the previous one already was an index error, rethrow\n        // with the current index\n        if (e instanceof GeoTIFFImageIndexError) {\n          throw new GeoTIFFImageIndexError(index);\n        }\n        // rethrow anything else\n        throw e;\n      }\n    }\n    // if the previous IFD was loaded, we can finally fetch the one we are interested in.\n    // we need to wrap this in an IIFE, otherwise this.ifdRequests[index] would be delayed\n    this.ifdRequests[index] = (async () => {\n      const previousIfd = await this.ifdRequests[index - 1];\n      if (previousIfd.nextIFDByteOffset === 0) {\n        throw new GeoTIFFImageIndexError(index);\n      }\n      return this.parseFileDirectoryAt(previousIfd.nextIFDByteOffset);\n    })();\n    return this.ifdRequests[index];\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {number} [index=0] the index of the image to return.\n   * @returns {Promise<GeoTIFFImage>} the image at the given index\n   */\n  async getImage(index = 0) {\n    const ifd = await this.requestIFD(index);\n    return new GeoTIFFImage(\n      ifd.fileDirectory, ifd.geoKeyDirectory,\n      this.dataView, this.littleEndian, this.cache, this.source,\n    );\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Promise<number>} the number of internal subfile images\n   */\n  async getImageCount() {\n    let index = 0;\n    // loop until we run out of IFDs\n    let hasNext = true;\n    while (hasNext) {\n      try {\n        await this.requestIFD(index);\n        ++index;\n      } catch (e) {\n        if (e instanceof GeoTIFFImageIndexError) {\n          hasNext = false;\n        } else {\n          throw e;\n        }\n      }\n    }\n    return index;\n  }\n\n  /**\n   * Get the values of the COG ghost area as a parsed map.\n   * See https://gdal.org/drivers/raster/cog.html#header-ghost-area for reference\n   * @returns {Promise<Object>} the parsed ghost area or null, if no such area was found\n   */\n  async getGhostValues() {\n    const offset = this.bigTiff ? 16 : 8;\n    if (this.ghostValues) {\n      return this.ghostValues;\n    }\n    const detectionString = 'GDAL_STRUCTURAL_METADATA_SIZE=';\n    const heuristicAreaSize = detectionString.length + 100;\n    let slice = await this.getSlice(offset, heuristicAreaSize);\n    if (detectionString === getValues(slice, fieldTypes.ASCII, detectionString.length, offset)) {\n      const valuesString = getValues(slice, fieldTypes.ASCII, heuristicAreaSize, offset);\n      const firstLine = valuesString.split('\\n')[0];\n      const metadataSize = Number(firstLine.split('=')[1].split(' ')[0]) + firstLine.length;\n      if (metadataSize > heuristicAreaSize) {\n        slice = await this.getSlice(offset, metadataSize);\n      }\n      const fullString = getValues(slice, fieldTypes.ASCII, metadataSize, offset);\n      this.ghostValues = {};\n      fullString\n        .split('\\n')\n        .filter((line) => line.length > 0)\n        .map((line) => line.split('='))\n        .forEach(([key, value]) => {\n          this.ghostValues[key] = value;\n        });\n    }\n    return this.ghostValues;\n  }\n\n  /**\n   * Parse a (Geo)TIFF file from the given source.\n   *\n   * @param {*} source The source of data to parse from.\n   * @param {GeoTIFFOptions} [options] Additional options.\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   */\n  static async fromSource(source, options, signal) {\n    const headerData = (await source.fetch([{ offset: 0, length: 1024 }], signal))[0];\n    const dataView = new DataView64(headerData);\n\n    const BOM = dataView.getUint16(0, 0);\n    let littleEndian;\n    if (BOM === 0x4949) {\n      littleEndian = true;\n    } else if (BOM === 0x4D4D) {\n      littleEndian = false;\n    } else {\n      throw new TypeError('Invalid byte order value.');\n    }\n\n    const magicNumber = dataView.getUint16(2, littleEndian);\n    let bigTiff;\n    if (magicNumber === 42) {\n      bigTiff = false;\n    } else if (magicNumber === 43) {\n      bigTiff = true;\n      const offsetByteSize = dataView.getUint16(4, littleEndian);\n      if (offsetByteSize !== 8) {\n        throw new Error('Unsupported offset byte-size.');\n      }\n    } else {\n      throw new TypeError('Invalid magic number.');\n    }\n\n    const firstIFDOffset = bigTiff\n      ? dataView.getUint64(8, littleEndian)\n      : dataView.getUint32(4, littleEndian);\n    return new GeoTIFF(source, littleEndian, bigTiff, firstIFDOffset, options);\n  }\n\n  /**\n   * Closes the underlying file buffer\n   * N.B. After the GeoTIFF has been completely processed it needs\n   * to be closed but only if it has been constructed from a file.\n   */\n  close() {\n    if (typeof this.source.close === 'function') {\n      return this.source.close();\n    }\n    return false;\n  }\n}\n\nexport { GeoTIFF };\nexport default GeoTIFF;\n\n/**\n * Wrapper for GeoTIFF files that have external overviews.\n * @augments GeoTIFFBase\n */\nclass MultiGeoTIFF extends GeoTIFFBase {\n  /**\n   * Construct a new MultiGeoTIFF from a main and several overview files.\n   * @param {GeoTIFF} mainFile The main GeoTIFF file.\n   * @param {GeoTIFF[]} overviewFiles An array of overview files.\n   */\n  constructor(mainFile, overviewFiles) {\n    super();\n    this.mainFile = mainFile;\n    this.overviewFiles = overviewFiles;\n    this.imageFiles = [mainFile].concat(overviewFiles);\n\n    this.fileDirectoriesPerFile = null;\n    this.fileDirectoriesPerFileParsing = null;\n    this.imageCount = null;\n  }\n\n  async parseFileDirectoriesPerFile() {\n    const requests = [this.mainFile.parseFileDirectoryAt(this.mainFile.firstIFDOffset)]\n      .concat(this.overviewFiles.map((file) => file.parseFileDirectoryAt(file.firstIFDOffset)));\n\n    this.fileDirectoriesPerFile = await Promise.all(requests);\n    return this.fileDirectoriesPerFile;\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {number} [index=0] the index of the image to return.\n   * @returns {Promise<GeoTIFFImage>} the image at the given index\n   */\n  async getImage(index = 0) {\n    await this.getImageCount();\n    await this.parseFileDirectoriesPerFile();\n    let visited = 0;\n    let relativeIndex = 0;\n    for (let i = 0; i < this.imageFiles.length; i++) {\n      const imageFile = this.imageFiles[i];\n      for (let ii = 0; ii < this.imageCounts[i]; ii++) {\n        if (index === visited) {\n          const ifd = await imageFile.requestIFD(relativeIndex);\n          return new GeoTIFFImage(\n            ifd.fileDirectory, ifd.geoKeyDirectory,\n            imageFile.dataView, imageFile.littleEndian, imageFile.cache, imageFile.source,\n          );\n        }\n        visited++;\n        relativeIndex++;\n      }\n      relativeIndex = 0;\n    }\n\n    throw new RangeError('Invalid image index');\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Promise<number>} the number of internal subfile images\n   */\n  async getImageCount() {\n    if (this.imageCount !== null) {\n      return this.imageCount;\n    }\n    const requests = [this.mainFile.getImageCount()]\n      .concat(this.overviewFiles.map((file) => file.getImageCount()));\n    this.imageCounts = await Promise.all(requests);\n    this.imageCount = this.imageCounts.reduce((count, ifds) => count + ifds, 0);\n    return this.imageCount;\n  }\n}\n\nexport { MultiGeoTIFF };\n\n/**\n * Creates a new GeoTIFF from a remote URL.\n * @param {string} url The URL to access the image from\n * @param {object} [options] Additional options to pass to the source.\n *                           See {@link makeRemoteSource} for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromUrl(url, options = {}, signal) {\n  return GeoTIFF.fromSource(makeRemoteSource(url, options), signal);\n}\n\n/**\n * Creates a new GeoTIFF from a custom {@link BaseClient}.\n * @param {BaseClient} client The client.\n * @param {object} [options] Additional options to pass to the source.\n *                           See {@link makeRemoteSource} for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromCustomClient(client, options = {}, signal) {\n  return GeoTIFF.fromSource(makeCustomSource(client, options), signal);\n}\n\n/**\n * Construct a new GeoTIFF from an\n * [ArrayBuffer]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer}.\n * @param {ArrayBuffer} arrayBuffer The data to read the file from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromArrayBuffer(arrayBuffer, signal) {\n  return GeoTIFF.fromSource(makeBufferSource(arrayBuffer), signal);\n}\n\n/**\n * Construct a GeoTIFF from a local file path. This uses the node\n * [filesystem API]{@link https://nodejs.org/api/fs.html} and is\n * not available on browsers.\n *\n * N.B. After the GeoTIFF has been completely processed it needs\n * to be closed but only if it has been constructed from a file.\n * @param {string} path The file path to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromFile(path, signal) {\n  return GeoTIFF.fromSource(makeFileSource(path), signal);\n}\n\n/**\n * Construct a GeoTIFF from an HTML\n * [Blob]{@link https://developer.mozilla.org/en-US/docs/Web/API/Blob} or\n * [File]{@link https://developer.mozilla.org/en-US/docs/Web/API/File}\n * object.\n * @param {Blob|File} blob The Blob or File object to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromBlob(blob, signal) {\n  return GeoTIFF.fromSource(makeFileReaderSource(blob), signal);\n}\n\n/**\n * Construct a MultiGeoTIFF from the given URLs.\n * @param {string} mainUrl The URL for the main file.\n * @param {string[]} overviewUrls An array of URLs for the overview images.\n * @param {Object} [options] Additional options to pass to the source.\n *                           See [makeRemoteSource]{@link module:source.makeRemoteSource}\n *                           for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<MultiGeoTIFF>} The resulting MultiGeoTIFF file.\n */\nexport async function fromUrls(mainUrl, overviewUrls = [], options = {}, signal) {\n  const mainFile = await GeoTIFF.fromSource(makeRemoteSource(mainUrl, options), signal);\n  const overviewFiles = await Promise.all(\n    overviewUrls.map((url) => GeoTIFF.fromSource(makeRemoteSource(url, options))),\n  );\n\n  return new MultiGeoTIFF(mainFile, overviewFiles);\n}\n\n/**\n * Main creating function for GeoTIFF files.\n * @param {(Array)} array of pixel values\n * @returns {metadata} metadata\n */\nexport function writeArrayBuffer(values, metadata) {\n  return writeGeotiff(values, metadata);\n}\n\nexport { Pool };\nexport { GeoTIFFImage };\nexport { BaseClient, BaseResponse };\n","export function fromWhiteIsZero(raster, max) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  let value;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    value = 256 - (raster[i] / max * 256);\n    rgbRaster[j] = value;\n    rgbRaster[j + 1] = value;\n    rgbRaster[j + 2] = value;\n  }\n  return rgbRaster;\n}\n\nexport function fromBlackIsZero(raster, max) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  let value;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    value = raster[i] / max * 256;\n    rgbRaster[j] = value;\n    rgbRaster[j + 1] = value;\n    rgbRaster[j + 2] = value;\n  }\n  return rgbRaster;\n}\n\nexport function fromPalette(raster, colorMap) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  const greenOffset = colorMap.length / 3;\n  const blueOffset = colorMap.length / 3 * 2;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    const mapIndex = raster[i];\n    rgbRaster[j] = colorMap[mapIndex] / 65536 * 256;\n    rgbRaster[j + 1] = colorMap[mapIndex + greenOffset] / 65536 * 256;\n    rgbRaster[j + 2] = colorMap[mapIndex + blueOffset] / 65536 * 256;\n  }\n  return rgbRaster;\n}\n\nexport function fromCMYK(cmykRaster) {\n  const { width, height } = cmykRaster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  for (let i = 0, j = 0; i < cmykRaster.length; i += 4, j += 3) {\n    const c = cmykRaster[i];\n    const m = cmykRaster[i + 1];\n    const y = cmykRaster[i + 2];\n    const k = cmykRaster[i + 3];\n\n    rgbRaster[j] = 255 * ((255 - c) / 256) * ((255 - k) / 256);\n    rgbRaster[j + 1] = 255 * ((255 - m) / 256) * ((255 - k) / 256);\n    rgbRaster[j + 2] = 255 * ((255 - y) / 256) * ((255 - k) / 256);\n  }\n  return rgbRaster;\n}\n\nexport function fromYCbCr(yCbCrRaster) {\n  const { width, height } = yCbCrRaster;\n  const rgbRaster = new Uint8ClampedArray(width * height * 3);\n  for (let i = 0, j = 0; i < yCbCrRaster.length; i += 3, j += 3) {\n    const y = yCbCrRaster[i];\n    const cb = yCbCrRaster[i + 1];\n    const cr = yCbCrRaster[i + 2];\n\n    rgbRaster[j] = (y + (1.40200 * (cr - 0x80)));\n    rgbRaster[j + 1] = (y - (0.34414 * (cb - 0x80)) - (0.71414 * (cr - 0x80)));\n    rgbRaster[j + 2] = (y + (1.77200 * (cb - 0x80)));\n  }\n  return rgbRaster;\n}\n\nconst Xn = 0.95047;\nconst Yn = 1.00000;\nconst Zn = 1.08883;\n\n// from https://github.com/antimatter15/rgb-lab/blob/master/color.js\n\nexport function fromCIELab(cieLabRaster) {\n  const { width, height } = cieLabRaster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n\n  for (let i = 0, j = 0; i < cieLabRaster.length; i += 3, j += 3) {\n    const L = cieLabRaster[i + 0];\n    const a_ = cieLabRaster[i + 1] << 24 >> 24; // conversion from uint8 to int8\n    const b_ = cieLabRaster[i + 2] << 24 >> 24; // same\n\n    let y = (L + 16) / 116;\n    let x = (a_ / 500) + y;\n    let z = y - (b_ / 200);\n    let r;\n    let g;\n    let b;\n\n    x = Xn * ((x * x * x > 0.008856) ? x * x * x : (x - (16 / 116)) / 7.787);\n    y = Yn * ((y * y * y > 0.008856) ? y * y * y : (y - (16 / 116)) / 7.787);\n    z = Zn * ((z * z * z > 0.008856) ? z * z * z : (z - (16 / 116)) / 7.787);\n\n    r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n    g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n    b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\n    r = (r > 0.0031308) ? ((1.055 * (r ** (1 / 2.4))) - 0.055) : 12.92 * r;\n    g = (g > 0.0031308) ? ((1.055 * (g ** (1 / 2.4))) - 0.055) : 12.92 * g;\n    b = (b > 0.0031308) ? ((1.055 * (b ** (1 / 2.4))) - 0.055) : 12.92 * b;\n\n    rgbRaster[j] = Math.max(0, Math.min(1, r)) * 255;\n    rgbRaster[j + 1] = Math.max(0, Math.min(1, g)) * 255;\n    rgbRaster[j + 2] = Math.max(0, Math.min(1, b)) * 255;\n  }\n  return rgbRaster;\n}\n","/**\n * @module resample\n */\n\nfunction copyNewSize(array, width, height, samplesPerPixel = 1) {\n  return new (Object.getPrototypeOf(array).constructor)(width * height * samplesPerPixel);\n}\n\n/**\n * Resample the input arrays using nearest neighbor value selection.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  return valueArrays.map((array) => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n    for (let y = 0; y < outHeight; ++y) {\n      const cy = Math.min(Math.round(relY * y), inHeight - 1);\n      for (let x = 0; x < outWidth; ++x) {\n        const cx = Math.min(Math.round(relX * x), inWidth - 1);\n        const value = array[(cy * inWidth) + cx];\n        newArray[(y * outWidth) + x] = value;\n      }\n    }\n    return newArray;\n  });\n}\n\n// simple linear interpolation, code from:\n// https://en.wikipedia.org/wiki/Linear_interpolation#Programming_language_support\nfunction lerp(v0, v1, t) {\n  return ((1 - t) * v0) + (t * v1);\n}\n\n/**\n * Resample the input arrays using bilinear interpolation.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n\n  return valueArrays.map((array) => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n    for (let y = 0; y < outHeight; ++y) {\n      const rawY = relY * y;\n\n      const yl = Math.floor(rawY);\n      const yh = Math.min(Math.ceil(rawY), (inHeight - 1));\n\n      for (let x = 0; x < outWidth; ++x) {\n        const rawX = relX * x;\n        const tx = rawX % 1;\n\n        const xl = Math.floor(rawX);\n        const xh = Math.min(Math.ceil(rawX), (inWidth - 1));\n\n        const ll = array[(yl * inWidth) + xl];\n        const hl = array[(yl * inWidth) + xh];\n        const lh = array[(yh * inWidth) + xl];\n        const hh = array[(yh * inWidth) + xh];\n\n        const value = lerp(\n          lerp(ll, hl, tx),\n          lerp(lh, hh, tx),\n          rawY % 1,\n        );\n        newArray[(y * outWidth) + x] = value;\n      }\n    }\n    return newArray;\n  });\n}\n\n/**\n * Resample the input arrays using the selected resampling method.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resample(valueArrays, inWidth, inHeight, outWidth, outHeight, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight);\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight);\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n\n/**\n * Resample the pixel interleaved input array using nearest neighbor value selection.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\nexport function resampleNearestInterleaved(\n  valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n  for (let y = 0; y < outHeight; ++y) {\n    const cy = Math.min(Math.round(relY * y), inHeight - 1);\n    for (let x = 0; x < outWidth; ++x) {\n      const cx = Math.min(Math.round(relX * x), inWidth - 1);\n      for (let i = 0; i < samples; ++i) {\n        const value = valueArray[(cy * inWidth * samples) + (cx * samples) + i];\n        newArray[(y * outWidth * samples) + (x * samples) + i] = value;\n      }\n    }\n  }\n  return newArray;\n}\n\n/**\n * Resample the pixel interleaved input array using bilinear interpolation.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\nexport function resampleBilinearInterleaved(\n  valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n  for (let y = 0; y < outHeight; ++y) {\n    const rawY = relY * y;\n\n    const yl = Math.floor(rawY);\n    const yh = Math.min(Math.ceil(rawY), (inHeight - 1));\n\n    for (let x = 0; x < outWidth; ++x) {\n      const rawX = relX * x;\n      const tx = rawX % 1;\n\n      const xl = Math.floor(rawX);\n      const xh = Math.min(Math.ceil(rawX), (inWidth - 1));\n\n      for (let i = 0; i < samples; ++i) {\n        const ll = valueArray[(yl * inWidth * samples) + (xl * samples) + i];\n        const hl = valueArray[(yl * inWidth * samples) + (xh * samples) + i];\n        const lh = valueArray[(yh * inWidth * samples) + (xl * samples) + i];\n        const hh = valueArray[(yh * inWidth * samples) + (xh * samples) + i];\n\n        const value = lerp(\n          lerp(ll, hl, tx),\n          lerp(lh, hh, tx),\n          rawY % 1,\n        );\n        newArray[(y * outWidth * samples) + (x * samples) + i] = value;\n      }\n    }\n  }\n  return newArray;\n}\n\n/**\n * Resample the pixel interleaved input array using the selected resampling method.\n * @param {TypedArray} valueArray The input array to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                                 interleaved data\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray} The resampled rasters\n */\nexport function resampleInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearestInterleaved(\n        valueArray, inWidth, inHeight, outWidth, outHeight, samples,\n      );\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinearInterleaved(\n        valueArray, inWidth, inHeight, outWidth, outHeight, samples,\n      );\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n","/** @module geotiffimage */\nimport { getFloat16 } from '@petamoriken/float16';\nimport getAttribute from 'xml-utils/get-attribute.js';\nimport findTagsByName from 'xml-utils/find-tags-by-name.js';\n\nimport { photometricInterpretations, ExtraSamplesValues } from './globals.js';\nimport { fromWhiteIsZero, fromBlackIsZero, fromPalette, fromCMYK, fromYCbCr, fromCIELab } from './rgb.js';\nimport { getDecoder } from './compression/index.js';\nimport { resample, resampleInterleaved } from './resample.js';\n\n/**\n * @typedef {Object} ReadRasterOptions\n * @property {Array<number>} [window=whole window] the subset to read data from in pixels.\n * @property {Array<number>} [bbox=whole image] the subset to read data from in\n *                                           geographical coordinates.\n * @property {Array<number>} [samples=all samples] the selection of samples to read from. Default is all samples.\n * @property {boolean} [interleave=false] whether the data shall be read\n *                                             in one single array or separate\n *                                             arrays.\n * @property {Pool} [pool=null] The optional decoder pool to use.\n * @property {number} [width] The desired width of the output. When the width is not the\n *                                 same as the images, resampling will be performed.\n * @property {number} [height] The desired height of the output. When the width is not the\n *                                  same as the images, resampling will be performed.\n * @property {string} [resampleMethod='nearest'] The desired resampling method.\n * @property {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                                       to be aborted\n * @property {number|number[]} [fillValue] The value to use for parts of the image\n *                                              outside of the images extent. When multiple\n *                                              samples are requested, an array of fill values\n *                                              can be passed.\n */\n\n/** @typedef {import(\"./geotiff.js\").TypedArray} TypedArray */\n/** @typedef {import(\"./geotiff.js\").ReadRasterResult} ReadRasterResult */\n\nfunction sum(array, start, end) {\n  let s = 0;\n  for (let i = start; i < end; ++i) {\n    s += array[i];\n  }\n  return s;\n}\n\nfunction arrayForType(format, bitsPerSample, size) {\n  switch (format) {\n    case 1: // unsigned integer data\n      if (bitsPerSample <= 8) {\n        return new Uint8Array(size);\n      } else if (bitsPerSample <= 16) {\n        return new Uint16Array(size);\n      } else if (bitsPerSample <= 32) {\n        return new Uint32Array(size);\n      }\n      break;\n    case 2: // twos complement signed integer data\n      if (bitsPerSample === 8) {\n        return new Int8Array(size);\n      } else if (bitsPerSample === 16) {\n        return new Int16Array(size);\n      } else if (bitsPerSample === 32) {\n        return new Int32Array(size);\n      }\n      break;\n    case 3: // floating point data\n      switch (bitsPerSample) {\n        case 16:\n        case 32:\n          return new Float32Array(size);\n        case 64:\n          return new Float64Array(size);\n        default:\n          break;\n      }\n      break;\n    default:\n      break;\n  }\n  throw Error('Unsupported data format/bitsPerSample');\n}\n\nfunction needsNormalization(format, bitsPerSample) {\n  if ((format === 1 || format === 2) && bitsPerSample <= 32 && bitsPerSample % 8 === 0) {\n    return false;\n  } else if (format === 3 && (bitsPerSample === 16 || bitsPerSample === 32 || bitsPerSample === 64)) {\n    return false;\n  }\n  return true;\n}\n\nfunction normalizeArray(inBuffer, format, planarConfiguration, samplesPerPixel, bitsPerSample, tileWidth, tileHeight) {\n  // const inByteArray = new Uint8Array(inBuffer);\n  const view = new DataView(inBuffer);\n  const outSize = planarConfiguration === 2\n    ? tileHeight * tileWidth\n    : tileHeight * tileWidth * samplesPerPixel;\n  const samplesToTransfer = planarConfiguration === 2\n    ? 1 : samplesPerPixel;\n  const outArray = arrayForType(format, bitsPerSample, outSize);\n  // let pixel = 0;\n\n  const bitMask = parseInt('1'.repeat(bitsPerSample), 2);\n\n  if (format === 1) { // unsigned integer\n    // translation of https://github.com/OSGeo/gdal/blob/master/gdal/frmts/gtiff/geotiff.cpp#L7337\n    let pixelBitSkip;\n    // let sampleBitOffset = 0;\n    if (planarConfiguration === 1) {\n      pixelBitSkip = samplesPerPixel * bitsPerSample;\n      // sampleBitOffset = (samplesPerPixel - 1) * bitsPerSample;\n    } else {\n      pixelBitSkip = bitsPerSample;\n    }\n\n    // Bits per line rounds up to next byte boundary.\n    let bitsPerLine = tileWidth * pixelBitSkip;\n    if ((bitsPerLine & 7) !== 0) {\n      bitsPerLine = (bitsPerLine + 7) & (~7);\n    }\n\n    for (let y = 0; y < tileHeight; ++y) {\n      const lineBitOffset = y * bitsPerLine;\n      for (let x = 0; x < tileWidth; ++x) {\n        const pixelBitOffset = lineBitOffset + (x * samplesToTransfer * bitsPerSample);\n        for (let i = 0; i < samplesToTransfer; ++i) {\n          const bitOffset = pixelBitOffset + (i * bitsPerSample);\n          const outIndex = (((y * tileWidth) + x) * samplesToTransfer) + i;\n\n          const byteOffset = Math.floor(bitOffset / 8);\n          const innerBitOffset = bitOffset % 8;\n          if (innerBitOffset + bitsPerSample <= 8) {\n            outArray[outIndex] = (view.getUint8(byteOffset) >> (8 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 16) {\n            outArray[outIndex] = (view.getUint16(byteOffset) >> (16 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 24) {\n            const raw = (view.getUint16(byteOffset) << 8) | (view.getUint8(byteOffset + 2));\n            outArray[outIndex] = (raw >> (24 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else {\n            outArray[outIndex] = (view.getUint32(byteOffset) >> (32 - bitsPerSample) - innerBitOffset) & bitMask;\n          }\n\n          // let outWord = 0;\n          // for (let bit = 0; bit < bitsPerSample; ++bit) {\n          //   if (inByteArray[bitOffset >> 3]\n          //     & (0x80 >> (bitOffset & 7))) {\n          //     outWord |= (1 << (bitsPerSample - 1 - bit));\n          //   }\n          //   ++bitOffset;\n          // }\n\n          // outArray[outIndex] = outWord;\n          // outArray[pixel] = outWord;\n          // pixel += 1;\n        }\n        // bitOffset = bitOffset + pixelBitSkip - bitsPerSample;\n      }\n    }\n  } else if (format === 3) { // floating point\n    // Float16 is handled elsewhere\n    // normalize 16/24 bit floats to 32 bit floats in the array\n    // console.time();\n    // if (bitsPerSample === 16) {\n    //   for (let byte = 0, outIndex = 0; byte < inBuffer.byteLength; byte += 2, ++outIndex) {\n    //     outArray[outIndex] = getFloat16(view, byte);\n    //   }\n    // }\n    // console.timeEnd()\n  }\n\n  return outArray.buffer;\n}\n\n/**\n * GeoTIFF sub-file image.\n */\nclass GeoTIFFImage {\n  /**\n   * @constructor\n   * @param {Object} fileDirectory The parsed file directory\n   * @param {Object} geoKeys The parsed geo-keys\n   * @param {DataView} dataView The DataView for the underlying file.\n   * @param {Boolean} littleEndian Whether the file is encoded in little or big endian\n   * @param {Boolean} cache Whether or not decoded tiles shall be cached\n   * @param {import('./source/basesource').BaseSource} source The datasource to read from\n   */\n  constructor(fileDirectory, geoKeys, dataView, littleEndian, cache, source) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeys = geoKeys;\n    this.dataView = dataView;\n    this.littleEndian = littleEndian;\n    this.tiles = cache ? {} : null;\n    this.isTiled = !fileDirectory.StripOffsets;\n    const planarConfiguration = fileDirectory.PlanarConfiguration;\n    this.planarConfiguration = (typeof planarConfiguration === 'undefined') ? 1 : planarConfiguration;\n    if (this.planarConfiguration !== 1 && this.planarConfiguration !== 2) {\n      throw new Error('Invalid planar configuration.');\n    }\n\n    this.source = source;\n  }\n\n  /**\n   * Returns the associated parsed file directory.\n   * @returns {Object} the parsed file directory\n   */\n  getFileDirectory() {\n    return this.fileDirectory;\n  }\n\n  /**\n   * Returns the associated parsed geo keys.\n   * @returns {Object} the parsed geo keys\n   */\n  getGeoKeys() {\n    return this.geoKeys;\n  }\n\n  /**\n   * Returns the width of the image.\n   * @returns {Number} the width of the image\n   */\n  getWidth() {\n    return this.fileDirectory.ImageWidth;\n  }\n\n  /**\n   * Returns the height of the image.\n   * @returns {Number} the height of the image\n   */\n  getHeight() {\n    return this.fileDirectory.ImageLength;\n  }\n\n  /**\n   * Returns the number of samples per pixel.\n   * @returns {Number} the number of samples per pixel\n   */\n  getSamplesPerPixel() {\n    return typeof this.fileDirectory.SamplesPerPixel !== 'undefined'\n      ? this.fileDirectory.SamplesPerPixel : 1;\n  }\n\n  /**\n   * Returns the width of each tile.\n   * @returns {Number} the width of each tile\n   */\n  getTileWidth() {\n    return this.isTiled ? this.fileDirectory.TileWidth : this.getWidth();\n  }\n\n  /**\n   * Returns the height of each tile.\n   * @returns {Number} the height of each tile\n   */\n  getTileHeight() {\n    if (this.isTiled) {\n      return this.fileDirectory.TileLength;\n    }\n    if (typeof this.fileDirectory.RowsPerStrip !== 'undefined') {\n      return Math.min(this.fileDirectory.RowsPerStrip, this.getHeight());\n    }\n    return this.getHeight();\n  }\n\n  getBlockWidth() {\n    return this.getTileWidth();\n  }\n\n  getBlockHeight(y) {\n    if (this.isTiled || (y + 1) * this.getTileHeight() <= this.getHeight()) {\n      return this.getTileHeight();\n    } else {\n      return this.getHeight() - (y * this.getTileHeight());\n    }\n  }\n\n  /**\n   * Calculates the number of bytes for each pixel across all samples. Only full\n   * bytes are supported, an exception is thrown when this is not the case.\n   * @returns {Number} the bytes per pixel\n   */\n  getBytesPerPixel() {\n    let bytes = 0;\n    for (let i = 0; i < this.fileDirectory.BitsPerSample.length; ++i) {\n      bytes += this.getSampleByteSize(i);\n    }\n    return bytes;\n  }\n\n  getSampleByteSize(i) {\n    if (i >= this.fileDirectory.BitsPerSample.length) {\n      throw new RangeError(`Sample index ${i} is out of range.`);\n    }\n    return Math.ceil(this.fileDirectory.BitsPerSample[i] / 8);\n  }\n\n  getReaderForSample(sampleIndex) {\n    const format = this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n    const bitsPerSample = this.fileDirectory.BitsPerSample[sampleIndex];\n    switch (format) {\n      case 1: // unsigned integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getUint8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getUint16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getUint32;\n        }\n        break;\n      case 2: // twos complement signed integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getInt8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getInt16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getInt32;\n        }\n        break;\n      case 3:\n        switch (bitsPerSample) {\n          case 16:\n            return function (offset, littleEndian) {\n              return getFloat16(this, offset, littleEndian);\n            };\n          case 32:\n            return DataView.prototype.getFloat32;\n          case 64:\n            return DataView.prototype.getFloat64;\n          default:\n            break;\n        }\n        break;\n      default:\n        break;\n    }\n    throw Error('Unsupported data format/bitsPerSample');\n  }\n\n  getSampleFormat(sampleIndex = 0) {\n    return this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n  }\n\n  getBitsPerSample(sampleIndex = 0) {\n    return this.fileDirectory.BitsPerSample[sampleIndex];\n  }\n\n  getArrayForSample(sampleIndex, size) {\n    const format = this.getSampleFormat(sampleIndex);\n    const bitsPerSample = this.getBitsPerSample(sampleIndex);\n    return arrayForType(format, bitsPerSample, size);\n  }\n\n  /**\n   * Returns the decoded strip or tile.\n   * @param {Number} x the strip or tile x-offset\n   * @param {Number} y the tile y-offset (0 for stripped images)\n   * @param {Number} sample the sample to get for separated samples\n   * @param {import(\"./geotiff\").Pool|import(\"./geotiff\").BaseDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise.<ArrayBuffer>}\n   */\n  async getTileOrStrip(x, y, sample, poolOrDecoder, signal) {\n    const numTilesPerRow = Math.ceil(this.getWidth() / this.getTileWidth());\n    const numTilesPerCol = Math.ceil(this.getHeight() / this.getTileHeight());\n    let index;\n    const { tiles } = this;\n    if (this.planarConfiguration === 1) {\n      index = (y * numTilesPerRow) + x;\n    } else if (this.planarConfiguration === 2) {\n      index = (sample * numTilesPerRow * numTilesPerCol) + (y * numTilesPerRow) + x;\n    }\n\n    let offset;\n    let byteCount;\n    if (this.isTiled) {\n      offset = this.fileDirectory.TileOffsets[index];\n      byteCount = this.fileDirectory.TileByteCounts[index];\n    } else {\n      offset = this.fileDirectory.StripOffsets[index];\n      byteCount = this.fileDirectory.StripByteCounts[index];\n    }\n    const slice = (await this.source.fetch([{ offset, length: byteCount }], signal))[0];\n\n    let request;\n    if (tiles === null || !tiles[index]) {\n    // resolve each request by potentially applying array normalization\n      request = (async () => {\n        let data = await poolOrDecoder.decode(this.fileDirectory, slice);\n        const sampleFormat = this.getSampleFormat();\n        const bitsPerSample = this.getBitsPerSample();\n        if (needsNormalization(sampleFormat, bitsPerSample)) {\n          data = normalizeArray(\n            data,\n            sampleFormat,\n            this.planarConfiguration,\n            this.getSamplesPerPixel(),\n            bitsPerSample,\n            this.getTileWidth(),\n            this.getBlockHeight(y),\n          );\n        }\n        return data;\n      })();\n\n      // set the cache\n      if (tiles !== null) {\n        tiles[index] = request;\n      }\n    } else {\n      // get from the cache\n      request = tiles[index];\n    }\n\n    // cache the tile request\n    return { x, y, sample, data: await request };\n  }\n\n  /**\n   * Internal read function.\n   * @private\n   * @param {Array} imageWindow The image window in pixel coordinates\n   * @param {Array} samples The selected samples (0-based indices)\n   * @param {TypedArray|TypedArray[]} valueArrays The array(s) to write into\n   * @param {Boolean} interleave Whether or not to write in an interleaved manner\n   * @param {import(\"./geotiff\").Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {number} width the width of window to be read into\n   * @param {number} height the height of window to be read into\n   * @param {number} resampleMethod the resampling method to be used when interpolating\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise<ReadRasterResult>}\n   */\n  async _readRaster(imageWindow, samples, valueArrays, interleave, poolOrDecoder, width,\n    height, resampleMethod, signal) {\n    const tileWidth = this.getTileWidth();\n    const tileHeight = this.getTileHeight();\n    const imageWidth = this.getWidth();\n    const imageHeight = this.getHeight();\n\n    const minXTile = Math.max(Math.floor(imageWindow[0] / tileWidth), 0);\n    const maxXTile = Math.min(\n      Math.ceil(imageWindow[2] / tileWidth),\n      Math.ceil(imageWidth / tileWidth),\n    );\n    const minYTile = Math.max(Math.floor(imageWindow[1] / tileHeight), 0);\n    const maxYTile = Math.min(\n      Math.ceil(imageWindow[3] / tileHeight),\n      Math.ceil(imageHeight / tileHeight),\n    );\n    const windowWidth = imageWindow[2] - imageWindow[0];\n\n    let bytesPerPixel = this.getBytesPerPixel();\n\n    const srcSampleOffsets = [];\n    const sampleReaders = [];\n    for (let i = 0; i < samples.length; ++i) {\n      if (this.planarConfiguration === 1) {\n        srcSampleOffsets.push(sum(this.fileDirectory.BitsPerSample, 0, samples[i]) / 8);\n      } else {\n        srcSampleOffsets.push(0);\n      }\n      sampleReaders.push(this.getReaderForSample(samples[i]));\n    }\n\n    const promises = [];\n    const { littleEndian } = this;\n\n    for (let yTile = minYTile; yTile < maxYTile; ++yTile) {\n      for (let xTile = minXTile; xTile < maxXTile; ++xTile) {\n        let getPromise;\n        if (this.planarConfiguration === 1) {\n          getPromise = this.getTileOrStrip(xTile, yTile, 0, poolOrDecoder, signal);\n        }\n        for (let sampleIndex = 0; sampleIndex < samples.length; ++sampleIndex) {\n          const si = sampleIndex;\n          const sample = samples[sampleIndex];\n          if (this.planarConfiguration === 2) {\n            bytesPerPixel = this.getSampleByteSize(sample);\n            getPromise = this.getTileOrStrip(xTile, yTile, sample, poolOrDecoder, signal);\n          }\n          const promise = getPromise.then((tile) => {\n            const buffer = tile.data;\n            const dataView = new DataView(buffer);\n            const blockHeight = this.getBlockHeight(tile.y);\n            const firstLine = tile.y * tileHeight;\n            const firstCol = tile.x * tileWidth;\n            const lastLine = firstLine + blockHeight;\n            const lastCol = (tile.x + 1) * tileWidth;\n            const reader = sampleReaders[si];\n\n            const ymax = Math.min(blockHeight, blockHeight - (lastLine - imageWindow[3]), imageHeight - firstLine);\n            const xmax = Math.min(tileWidth, tileWidth - (lastCol - imageWindow[2]), imageWidth - firstCol);\n\n            for (let y = Math.max(0, imageWindow[1] - firstLine); y < ymax; ++y) {\n              for (let x = Math.max(0, imageWindow[0] - firstCol); x < xmax; ++x) {\n                const pixelOffset = ((y * tileWidth) + x) * bytesPerPixel;\n                const value = reader.call(\n                  dataView, pixelOffset + srcSampleOffsets[si], littleEndian,\n                );\n                let windowCoordinate;\n                if (interleave) {\n                  windowCoordinate = ((y + firstLine - imageWindow[1]) * windowWidth * samples.length)\n                    + ((x + firstCol - imageWindow[0]) * samples.length)\n                    + si;\n                  valueArrays[windowCoordinate] = value;\n                } else {\n                  windowCoordinate = (\n                    (y + firstLine - imageWindow[1]) * windowWidth\n                  ) + x + firstCol - imageWindow[0];\n                  valueArrays[si][windowCoordinate] = value;\n                }\n              }\n            }\n          });\n          promises.push(promise);\n        }\n      }\n    }\n    await Promise.all(promises);\n\n    if ((width && (imageWindow[2] - imageWindow[0]) !== width)\n        || (height && (imageWindow[3] - imageWindow[1]) !== height)) {\n      let resampled;\n      if (interleave) {\n        resampled = resampleInterleaved(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          samples.length,\n          resampleMethod,\n        );\n      } else {\n        resampled = resample(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          resampleMethod,\n        );\n      }\n      resampled.width = width;\n      resampled.height = height;\n      return resampled;\n    }\n\n    valueArrays.width = width || imageWindow[2] - imageWindow[0];\n    valueArrays.height = height || imageWindow[3] - imageWindow[1];\n\n    return valueArrays;\n  }\n\n  /**\n   * Reads raster data from the image. This function reads all selected samples\n   * into separate arrays of the correct type for that sample or into a single\n   * combined array when `interleave` is set. When provided, only a subset\n   * of the raster is read for each sample.\n   *\n   * @param {ReadRasterOptions} [options={}] optional parameters\n   * @returns {Promise<ReadRasterResult>} the decoded arrays as a promise\n   */\n  async readRasters({\n    window: wnd, samples = [], interleave, pool = null,\n    width, height, resampleMethod, fillValue, signal,\n  } = {}) {\n    const imageWindow = wnd || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const imageWindowWidth = imageWindow[2] - imageWindow[0];\n    const imageWindowHeight = imageWindow[3] - imageWindow[1];\n    const numPixels = imageWindowWidth * imageWindowHeight;\n    const samplesPerPixel = this.getSamplesPerPixel();\n\n    if (!samples || !samples.length) {\n      for (let i = 0; i < samplesPerPixel; ++i) {\n        samples.push(i);\n      }\n    } else {\n      for (let i = 0; i < samples.length; ++i) {\n        if (samples[i] >= samplesPerPixel) {\n          return Promise.reject(new RangeError(`Invalid sample index '${samples[i]}'.`));\n        }\n      }\n    }\n    let valueArrays;\n    if (interleave) {\n      const format = this.fileDirectory.SampleFormat\n        ? Math.max.apply(null, this.fileDirectory.SampleFormat) : 1;\n      const bitsPerSample = Math.max.apply(null, this.fileDirectory.BitsPerSample);\n      valueArrays = arrayForType(format, bitsPerSample, numPixels * samples.length);\n      if (fillValue) {\n        valueArrays.fill(fillValue);\n      }\n    } else {\n      valueArrays = [];\n      for (let i = 0; i < samples.length; ++i) {\n        const valueArray = this.getArrayForSample(samples[i], numPixels);\n        if (Array.isArray(fillValue) && i < fillValue.length) {\n          valueArray.fill(fillValue[i]);\n        } else if (fillValue && !Array.isArray(fillValue)) {\n          valueArray.fill(fillValue);\n        }\n        valueArrays.push(valueArray);\n      }\n    }\n\n    const poolOrDecoder = pool || await getDecoder(this.fileDirectory);\n\n    const result = await this._readRaster(\n      imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod, signal,\n    );\n    return result;\n  }\n\n  /**\n   * Reads raster data from the image as RGB. The result is always an\n   * interleaved typed array.\n   * Colorspaces other than RGB will be transformed to RGB, color maps expanded.\n   * When no other method is applicable, the first sample is used to produce a\n   * grayscale image.\n   * When provided, only a subset of the raster is read for each sample.\n   *\n   * @param {Object} [options] optional parameters\n   * @param {Array<number>} [options.window] the subset to read data from in pixels.\n   * @param {boolean} [options.interleave=true] whether the data shall be read\n   *                                             in one single array or separate\n   *                                             arrays.\n   * @param {import(\"./geotiff\").Pool} [options.pool=null] The optional decoder pool to use.\n   * @param {number} [options.width] The desired width of the output. When the width is no the\n   *                                 same as the images, resampling will be performed.\n   * @param {number} [options.height] The desired height of the output. When the width is no the\n   *                                  same as the images, resampling will be performed.\n   * @param {string} [options.resampleMethod='nearest'] The desired resampling method.\n   * @param {boolean} [options.enableAlpha=false] Enable reading alpha channel if present.\n   * @param {AbortSignal} [options.signal] An AbortSignal that may be signalled if the request is\n   *                                       to be aborted\n   * @returns {Promise<ReadRasterResult>} the RGB array as a Promise\n   */\n  async readRGB({ window, interleave = true, pool = null, width, height,\n    resampleMethod, enableAlpha = false, signal } = {}) {\n    const imageWindow = window || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const pi = this.fileDirectory.PhotometricInterpretation;\n\n    if (pi === photometricInterpretations.RGB) {\n      let s = [0, 1, 2];\n      if ((!(this.fileDirectory.ExtraSamples === ExtraSamplesValues.Unspecified)) && enableAlpha) {\n        s = [];\n        for (let i = 0; i < this.fileDirectory.BitsPerSample.length; i += 1) {\n          s.push(i);\n        }\n      }\n      return this.readRasters({\n        window,\n        interleave,\n        samples: s,\n        pool,\n        width,\n        height,\n        resampleMethod,\n        signal,\n      });\n    }\n\n    let samples;\n    switch (pi) {\n      case photometricInterpretations.WhiteIsZero:\n      case photometricInterpretations.BlackIsZero:\n      case photometricInterpretations.Palette:\n        samples = [0];\n        break;\n      case photometricInterpretations.CMYK:\n        samples = [0, 1, 2, 3];\n        break;\n      case photometricInterpretations.YCbCr:\n      case photometricInterpretations.CIELab:\n        samples = [0, 1, 2];\n        break;\n      default:\n        throw new Error('Invalid or unsupported photometric interpretation.');\n    }\n\n    const subOptions = {\n      window: imageWindow,\n      interleave: true,\n      samples,\n      pool,\n      width,\n      height,\n      resampleMethod,\n      signal,\n    };\n    const { fileDirectory } = this;\n    const raster = await this.readRasters(subOptions);\n\n    const max = 2 ** this.fileDirectory.BitsPerSample[0];\n    let data;\n    switch (pi) {\n      case photometricInterpretations.WhiteIsZero:\n        data = fromWhiteIsZero(raster, max);\n        break;\n      case photometricInterpretations.BlackIsZero:\n        data = fromBlackIsZero(raster, max);\n        break;\n      case photometricInterpretations.Palette:\n        data = fromPalette(raster, fileDirectory.ColorMap);\n        break;\n      case photometricInterpretations.CMYK:\n        data = fromCMYK(raster);\n        break;\n      case photometricInterpretations.YCbCr:\n        data = fromYCbCr(raster);\n        break;\n      case photometricInterpretations.CIELab:\n        data = fromCIELab(raster);\n        break;\n      default:\n        throw new Error('Unsupported photometric interpretation.');\n    }\n\n    // if non-interleaved data is requested, we must split the channels\n    // into their respective arrays\n    if (!interleave) {\n      const red = new Uint8Array(data.length / 3);\n      const green = new Uint8Array(data.length / 3);\n      const blue = new Uint8Array(data.length / 3);\n      for (let i = 0, j = 0; i < data.length; i += 3, ++j) {\n        red[j] = data[i];\n        green[j] = data[i + 1];\n        blue[j] = data[i + 2];\n      }\n      data = [red, green, blue];\n    }\n\n    data.width = raster.width;\n    data.height = raster.height;\n    return data;\n  }\n\n  /**\n   * Returns an array of tiepoints.\n   * @returns {Object[]}\n   */\n  getTiePoints() {\n    if (!this.fileDirectory.ModelTiepoint) {\n      return [];\n    }\n\n    const tiePoints = [];\n    for (let i = 0; i < this.fileDirectory.ModelTiepoint.length; i += 6) {\n      tiePoints.push({\n        i: this.fileDirectory.ModelTiepoint[i],\n        j: this.fileDirectory.ModelTiepoint[i + 1],\n        k: this.fileDirectory.ModelTiepoint[i + 2],\n        x: this.fileDirectory.ModelTiepoint[i + 3],\n        y: this.fileDirectory.ModelTiepoint[i + 4],\n        z: this.fileDirectory.ModelTiepoint[i + 5],\n      });\n    }\n    return tiePoints;\n  }\n\n  /**\n   * Returns the parsed GDAL metadata items.\n   *\n   * If sample is passed to null, dataset-level metadata will be returned.\n   * Otherwise only metadata specific to the provided sample will be returned.\n   *\n   * @param {number} [sample=null] The sample index.\n   * @returns {Object}\n   */\n  getGDALMetadata(sample = null) {\n    const metadata = {};\n    if (!this.fileDirectory.GDAL_METADATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_METADATA;\n\n    let items = findTagsByName(string, 'Item');\n\n    if (sample === null) {\n      items = items.filter((item) => getAttribute(item, 'sample') === undefined);\n    } else {\n      items = items.filter((item) => Number(getAttribute(item, 'sample')) === sample);\n    }\n\n    for (let i = 0; i < items.length; ++i) {\n      const item = items[i];\n      metadata[getAttribute(item, 'name')] = item.inner;\n    }\n    return metadata;\n  }\n\n  /**\n   * Returns the GDAL nodata value\n   * @returns {number|null}\n   */\n  getGDALNoData() {\n    if (!this.fileDirectory.GDAL_NODATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_NODATA;\n    return Number(string.substring(0, string.length - 1));\n  }\n\n  /**\n   * Returns the image origin as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @returns {Array<number>} The origin as a vector\n   */\n  getOrigin() {\n    const tiePoints = this.fileDirectory.ModelTiepoint;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n    if (tiePoints && tiePoints.length === 6) {\n      return [\n        tiePoints[3],\n        tiePoints[4],\n        tiePoints[5],\n      ];\n    }\n    if (modelTransformation) {\n      return [\n        modelTransformation[3],\n        modelTransformation[7],\n        modelTransformation[11],\n      ];\n    }\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns the image resolution as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @param {GeoTIFFImage} [referenceImage=null] A reference image to calculate the resolution from\n   *                                             in cases when the current image does not have the\n   *                                             required tags on its own.\n   * @returns {Array<number>} The resolution as a vector\n   */\n  getResolution(referenceImage = null) {\n    const modelPixelScale = this.fileDirectory.ModelPixelScale;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n\n    if (modelPixelScale) {\n      return [\n        modelPixelScale[0],\n        -modelPixelScale[1],\n        modelPixelScale[2],\n      ];\n    }\n    if (modelTransformation) {\n      if (modelTransformation[1] === 0 && modelTransformation[4] === 0) {\n        return [\n          modelTransformation[0],\n          -modelTransformation[5],\n          modelTransformation[10],\n        ];\n      }\n      return [\n        Math.sqrt((modelTransformation[0] * modelTransformation[0])\n          + (modelTransformation[4] * modelTransformation[4])),\n        -Math.sqrt((modelTransformation[1] * modelTransformation[1])\n          + (modelTransformation[5] * modelTransformation[5])),\n        modelTransformation[10]];\n    }\n\n    if (referenceImage) {\n      const [refResX, refResY, refResZ] = referenceImage.getResolution();\n      return [\n        refResX * referenceImage.getWidth() / this.getWidth(),\n        refResY * referenceImage.getHeight() / this.getHeight(),\n        refResZ * referenceImage.getWidth() / this.getWidth(),\n      ];\n    }\n\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns whether or not the pixels of the image depict an area (or point).\n   * @returns {Boolean} Whether the pixels are a point\n   */\n  pixelIsArea() {\n    return this.geoKeys.GTRasterTypeGeoKey === 1;\n  }\n\n  /**\n   * Returns the image bounding box as an array of 4 values: min-x, min-y,\n   * max-x and max-y. When the image has no affine transformation, then an\n   * exception is thrown.\n   * @param {boolean} [tilegrid=false] If true return extent for a tilegrid\n   *                                   without adjustment for ModelTransformation.\n   * @returns {Array<number>} The bounding box\n   */\n  getBoundingBox(tilegrid = false) {\n    const height = this.getHeight();\n    const width = this.getWidth();\n\n    if (this.fileDirectory.ModelTransformation && !tilegrid) {\n      // eslint-disable-next-line no-unused-vars\n      const [a, b, c, d, e, f, g, h] = this.fileDirectory.ModelTransformation;\n\n      const corners = [\n        [0, 0],\n        [0, height],\n        [width, 0],\n        [width, height],\n      ];\n\n      const projected = corners.map(([I, J]) => [\n        d + (a * I) + (b * J),\n        h + (e * I) + (f * J),\n      ]);\n\n      const xs = projected.map((pt) => pt[0]);\n      const ys = projected.map((pt) => pt[1]);\n\n      return [\n        Math.min(...xs),\n        Math.min(...ys),\n        Math.max(...xs),\n        Math.max(...ys),\n      ];\n    } else {\n      const origin = this.getOrigin();\n      const resolution = this.getResolution();\n\n      const x1 = origin[0];\n      const y1 = origin[1];\n\n      const x2 = x1 + (resolution[0] * width);\n      const y2 = y1 + (resolution[1] * height);\n\n      return [\n        Math.min(x1, x2),\n        Math.min(y1, y2),\n        Math.max(x1, x2),\n        Math.max(y1, y2),\n      ];\n    }\n  }\n}\n\nexport default GeoTIFFImage;\n","export const fieldTagNames = {\n  // TIFF Baseline\n  0x013B: 'Artist',\n  0x0102: 'BitsPerSample',\n  0x0109: 'CellLength',\n  0x0108: 'CellWidth',\n  0x0140: 'ColorMap',\n  0x0103: 'Compression',\n  0x8298: 'Copyright',\n  0x0132: 'DateTime',\n  0x0152: 'ExtraSamples',\n  0x010A: 'FillOrder',\n  0x0121: 'FreeByteCounts',\n  0x0120: 'FreeOffsets',\n  0x0123: 'GrayResponseCurve',\n  0x0122: 'GrayResponseUnit',\n  0x013C: 'HostComputer',\n  0x010E: 'ImageDescription',\n  0x0101: 'ImageLength',\n  0x0100: 'ImageWidth',\n  0x010F: 'Make',\n  0x0119: 'MaxSampleValue',\n  0x0118: 'MinSampleValue',\n  0x0110: 'Model',\n  0x00FE: 'NewSubfileType',\n  0x0112: 'Orientation',\n  0x0106: 'PhotometricInterpretation',\n  0x011C: 'PlanarConfiguration',\n  0x0128: 'ResolutionUnit',\n  0x0116: 'RowsPerStrip',\n  0x0115: 'SamplesPerPixel',\n  0x0131: 'Software',\n  0x0117: 'StripByteCounts',\n  0x0111: 'StripOffsets',\n  0x00FF: 'SubfileType',\n  0x0107: 'Threshholding',\n  0x011A: 'XResolution',\n  0x011B: 'YResolution',\n\n  // TIFF Extended\n  0x0146: 'BadFaxLines',\n  0x0147: 'CleanFaxData',\n  0x0157: 'ClipPath',\n  0x0148: 'ConsecutiveBadFaxLines',\n  0x01B1: 'Decode',\n  0x01B2: 'DefaultImageColor',\n  0x010D: 'DocumentName',\n  0x0150: 'DotRange',\n  0x0141: 'HalftoneHints',\n  0x015A: 'Indexed',\n  0x015B: 'JPEGTables',\n  0x011D: 'PageName',\n  0x0129: 'PageNumber',\n  0x013D: 'Predictor',\n  0x013F: 'PrimaryChromaticities',\n  0x0214: 'ReferenceBlackWhite',\n  0x0153: 'SampleFormat',\n  0x0154: 'SMinSampleValue',\n  0x0155: 'SMaxSampleValue',\n  0x022F: 'StripRowCounts',\n  0x014A: 'SubIFDs',\n  0x0124: 'T4Options',\n  0x0125: 'T6Options',\n  0x0145: 'TileByteCounts',\n  0x0143: 'TileLength',\n  0x0144: 'TileOffsets',\n  0x0142: 'TileWidth',\n  0x012D: 'TransferFunction',\n  0x013E: 'WhitePoint',\n  0x0158: 'XClipPathUnits',\n  0x011E: 'XPosition',\n  0x0211: 'YCbCrCoefficients',\n  0x0213: 'YCbCrPositioning',\n  0x0212: 'YCbCrSubSampling',\n  0x0159: 'YClipPathUnits',\n  0x011F: 'YPosition',\n\n  // EXIF\n  0x9202: 'ApertureValue',\n  0xA001: 'ColorSpace',\n  0x9004: 'DateTimeDigitized',\n  0x9003: 'DateTimeOriginal',\n  0x8769: 'Exif IFD',\n  0x9000: 'ExifVersion',\n  0x829A: 'ExposureTime',\n  0xA300: 'FileSource',\n  0x9209: 'Flash',\n  0xA000: 'FlashpixVersion',\n  0x829D: 'FNumber',\n  0xA420: 'ImageUniqueID',\n  0x9208: 'LightSource',\n  0x927C: 'MakerNote',\n  0x9201: 'ShutterSpeedValue',\n  0x9286: 'UserComment',\n\n  // IPTC\n  0x83BB: 'IPTC',\n\n  // ICC\n  0x8773: 'ICC Profile',\n\n  // XMP\n  0x02BC: 'XMP',\n\n  // GDAL\n  0xA480: 'GDAL_METADATA',\n  0xA481: 'GDAL_NODATA',\n\n  // Photoshop\n  0x8649: 'Photoshop',\n\n  // GeoTiff\n  0x830E: 'ModelPixelScale',\n  0x8482: 'ModelTiepoint',\n  0x85D8: 'ModelTransformation',\n  0x87AF: 'GeoKeyDirectory',\n  0x87B0: 'GeoDoubleParams',\n  0x87B1: 'GeoAsciiParams',\n\n  // LERC\n  0xC5F2: 'LercParameters',\n};\n\nexport const fieldTags = {};\nfor (const key in fieldTagNames) {\n  if (fieldTagNames.hasOwnProperty(key)) {\n    fieldTags[fieldTagNames[key]] = parseInt(key, 10);\n  }\n}\n\nexport const fieldTagTypes = {\n  256: 'SHORT',\n  257: 'SHORT',\n  258: 'SHORT',\n  259: 'SHORT',\n  262: 'SHORT',\n  273: 'LONG',\n  274: 'SHORT',\n  277: 'SHORT',\n  278: 'LONG',\n  279: 'LONG',\n  282: 'RATIONAL',\n  283: 'RATIONAL',\n  284: 'SHORT',\n  286: 'SHORT',\n  287: 'RATIONAL',\n  296: 'SHORT',\n  297: 'SHORT',\n  305: 'ASCII',\n  306: 'ASCII',\n  338: 'SHORT',\n  339: 'SHORT',\n  513: 'LONG',\n  514: 'LONG',\n  1024: 'SHORT',\n  1025: 'SHORT',\n  2048: 'SHORT',\n  2049: 'ASCII',\n  3072: 'SHORT',\n  3073: 'ASCII',\n  33550: 'DOUBLE',\n  33922: 'DOUBLE',\n  34264: 'DOUBLE',\n  34665: 'LONG',\n  34735: 'SHORT',\n  34736: 'DOUBLE',\n  34737: 'ASCII',\n  42113: 'ASCII',\n};\n\nexport const arrayFields = [\n  fieldTags.BitsPerSample,\n  fieldTags.ExtraSamples,\n  fieldTags.SampleFormat,\n  fieldTags.StripByteCounts,\n  fieldTags.StripOffsets,\n  fieldTags.StripRowCounts,\n  fieldTags.TileByteCounts,\n  fieldTags.TileOffsets,\n  fieldTags.SubIFDs,\n];\n\nexport const fieldTypeNames = {\n  0x0001: 'BYTE',\n  0x0002: 'ASCII',\n  0x0003: 'SHORT',\n  0x0004: 'LONG',\n  0x0005: 'RATIONAL',\n  0x0006: 'SBYTE',\n  0x0007: 'UNDEFINED',\n  0x0008: 'SSHORT',\n  0x0009: 'SLONG',\n  0x000A: 'SRATIONAL',\n  0x000B: 'FLOAT',\n  0x000C: 'DOUBLE',\n  // IFD offset, suggested by https://owl.phy.queensu.ca/~phil/exiftool/standards.html\n  0x000D: 'IFD',\n  // introduced by BigTIFF\n  0x0010: 'LONG8',\n  0x0011: 'SLONG8',\n  0x0012: 'IFD8',\n};\n\nexport const fieldTypes = {};\nfor (const key in fieldTypeNames) {\n  if (fieldTypeNames.hasOwnProperty(key)) {\n    fieldTypes[fieldTypeNames[key]] = parseInt(key, 10);\n  }\n}\n\nexport const photometricInterpretations = {\n  WhiteIsZero: 0,\n  BlackIsZero: 1,\n  RGB: 2,\n  Palette: 3,\n  TransparencyMask: 4,\n  CMYK: 5,\n  YCbCr: 6,\n\n  CIELab: 8,\n  ICCLab: 9,\n};\n\nexport const ExtraSamplesValues = {\n  Unspecified: 0,\n  Assocalpha: 1,\n  Unassalpha: 2,\n};\n\nexport const LercParameters = {\n  Version: 0,\n  AddCompression: 1,\n};\n\nexport const LercAddCompression = {\n  None: 0,\n  Deflate: 1,\n  Zstandard: 2,\n};\n\nexport const geoKeyNames = {\n  1024: 'GTModelTypeGeoKey',\n  1025: 'GTRasterTypeGeoKey',\n  1026: 'GTCitationGeoKey',\n  2048: 'GeographicTypeGeoKey',\n  2049: 'GeogCitationGeoKey',\n  2050: 'GeogGeodeticDatumGeoKey',\n  2051: 'GeogPrimeMeridianGeoKey',\n  2052: 'GeogLinearUnitsGeoKey',\n  2053: 'GeogLinearUnitSizeGeoKey',\n  2054: 'GeogAngularUnitsGeoKey',\n  2055: 'GeogAngularUnitSizeGeoKey',\n  2056: 'GeogEllipsoidGeoKey',\n  2057: 'GeogSemiMajorAxisGeoKey',\n  2058: 'GeogSemiMinorAxisGeoKey',\n  2059: 'GeogInvFlatteningGeoKey',\n  2060: 'GeogAzimuthUnitsGeoKey',\n  2061: 'GeogPrimeMeridianLongGeoKey',\n  2062: 'GeogTOWGS84GeoKey',\n  3072: 'ProjectedCSTypeGeoKey',\n  3073: 'PCSCitationGeoKey',\n  3074: 'ProjectionGeoKey',\n  3075: 'ProjCoordTransGeoKey',\n  3076: 'ProjLinearUnitsGeoKey',\n  3077: 'ProjLinearUnitSizeGeoKey',\n  3078: 'ProjStdParallel1GeoKey',\n  3079: 'ProjStdParallel2GeoKey',\n  3080: 'ProjNatOriginLongGeoKey',\n  3081: 'ProjNatOriginLatGeoKey',\n  3082: 'ProjFalseEastingGeoKey',\n  3083: 'ProjFalseNorthingGeoKey',\n  3084: 'ProjFalseOriginLongGeoKey',\n  3085: 'ProjFalseOriginLatGeoKey',\n  3086: 'ProjFalseOriginEastingGeoKey',\n  3087: 'ProjFalseOriginNorthingGeoKey',\n  3088: 'ProjCenterLongGeoKey',\n  3089: 'ProjCenterLatGeoKey',\n  3090: 'ProjCenterEastingGeoKey',\n  3091: 'ProjCenterNorthingGeoKey',\n  3092: 'ProjScaleAtNatOriginGeoKey',\n  3093: 'ProjScaleAtCenterGeoKey',\n  3094: 'ProjAzimuthAngleGeoKey',\n  3095: 'ProjStraightVertPoleLongGeoKey',\n  3096: 'ProjRectifiedGridAngleGeoKey',\n  4096: 'VerticalCSTypeGeoKey',\n  4097: 'VerticalCitationGeoKey',\n  4098: 'VerticalDatumGeoKey',\n  4099: 'VerticalUnitsGeoKey',\n};\n\nexport const geoKeys = {};\nfor (const key in geoKeyNames) {\n  if (geoKeyNames.hasOwnProperty(key)) {\n    geoKeys[geoKeyNames[key]] = parseInt(key, 10);\n  }\n}\n"],"names":["render","_vm","this","_c","_self","staticClass","attrs","collections","showKeywords","searchTerm","hideDeprecated","deprecatedFilter","sort","offerDetails","heading","collapsed","loadAdditionalData","on","detailsToggled","scopedSlots","_u","key","fn","scope","_t","missing","federation","proxy","slot","item","mapOptions","staticRenderFns","name","components","Collection","loadAsyncComponent","SearchableList","mixins","FederationMixin","props","type","Array","default","Object","String","Boolean","Function","beforeCreate","enableHtmlProps","methods","args","$emit","component","model","value","callback","$$v","filterValue","expression","_e","_l","col","id","directives","rawName","hide","class","thClasses","thTitle","$event","enableSort","_v","_s","row","i","canEdit","stylable","onDblClick","showEditField","preventDefault","stopPropagation","saveEditField","ref","refInFor","domProps","resetEditFieldEsc","formattedValue","hasData","view","length","columnCount","noDataMessage","SearchBox","columns","data","primaryKey","editField","sortState","direction","watch","updateView","immediate","handler","includes","computed","keys","hasFilter","created","determinePrimaryKey","edit","event","action","$nextTick","$refs","focus","setNoData","error","isObject","config","headers","message","console","warn","computedValue","format","classes","push","colId","slice","a","b","sortFn","compareStringCaseInsensitive","result","filter","toLowerCase","values","hasOwnProperty","filterable","toString","search","clearFilter","isArray","call","DataTypes","Formatters","fileFormats","showAll","gis_data_types","summary","identifier","FileFormat","formats","showInput","showOutput","typesToShow","types","assign","processes","showCategories","provideDownload","processUrl","showGraph","Process","compact","placeholder","minLength","searchHint","target","composing","Number","newValue","oldValue","registry","Map","addDecoder","cases","importFn","forEach","c","set","async","getDecoder","fileDirectory","get","Compression","Error","Decoder","undefined","then","m","zstd","init","DataView64","constructor","arrayBuffer","_dataView","DataView","buffer","getUint64","offset","littleEndian","left","getUint32","right","combined","isSafeInteger","getInt64","isNegative","getUint8","carrying","byte","getInt8","getUint16","getInt16","getInt32","getFloat16","getFloat32","getFloat64","DataSlice","sliceOffset","bigTiff","_sliceOffset","_littleEndian","_bigTiff","sliceTop","byteLength","covers","readUint8","readInt8","readUint16","readInt16","readUint32","readInt32","readFloat32","readFloat64","readUint64","readInt64","readOffset","CRLFCRLF","itemsToObject","items","fromEntries","obj","parseHeaders","text","split","map","line","kv","str","trim","parseContentType","rawContentType","rawParams","s","paramsItems","param","params","parseContentRange","rawContentRange","start","end","total","match","parseInt","parseByteRanges","responseArrayBuffer","boundary","decoder","TextDecoder","out","startBoundary","endBoundary","decode","Uint8Array","Math","min","startsWith","innerText","substr","endOfHeaders","indexOf","startOfData","fileSize","BaseSource","fetch","slices","signal","Promise","all","fetchSlice","close","wait","milliseconds","resolve","setTimeout","zip","A","from","B","k","AbortError","super","captureStackTrace","CustomAggregateError","errors","AggregateError","Block","top","BlockGroup","blockIds","BlockedSource","source","blockSize","cacheSize","blockCache","maxSize","onEviction","blockId","block","evictedBlocks","blockRequests","blockIdsToFetch","Set","abortedBlockIds","missingBlockIds","allBlockIds","clear","firstBlockOffset","floor","current","has","add","fetchBlocks","missingRequests","allSettled","abortedBlockRequests","aborted","blocks","failedBlocks","requiredBlocks","readSliceData","size","groups","groupBlocks","groupRequests","groupIndex","group","response","blockOffset","o","t","delete","err","sortedBlockIds","lastBlockId","blockIdLow","blockIdHigh","sliceData","ArrayBuffer","sliceView","delta","topDelta","usedBlockLength","blockInnerOffset","rangeInnerOffset","blockView","BaseResponse","ok","status","getHeader","headerName","getData","BaseClient","url","request","FetchResponse","FetchClient","credentials","XHRResponse","xhr","getResponseHeader","XHRClient","constructRequest","reject","XMLHttpRequest","open","responseType","entries","setRequestHeader","onload","onerror","onabort","send","abort","addEventListener","HttpResponse","dataPromise","statusCode","HttpClient","parsedUrl","httpApi","protocol","resolveData","chunks","chunk","Buffer","concat","destroy","RemoteSource","client","maxRanges","allowFullFile","_fileSize","fetchSlices","Range","join","byteRanges","first","others","maybeWrapInBlockedSource","makeFetchSource","blockOptions","makeXHRSource","makeHttpSource","makeRemoteSource","forceXHR","clientOptions","FileReaderSource","file","blob","reader","FileReader","readAsArrayBuffer","makeFileReaderSource","getFieldTypeLength","fieldType","BYTE","ASCII","SBYTE","UNDEFINED","SHORT","SSHORT","LONG","SLONG","FLOAT","IFD","RATIONAL","SRATIONAL","DOUBLE","LONG8","SLONG8","IFD8","RangeError","parseGeoKeyDirectory","rawGeoKeyDirectory","GeoKeyDirectory","geoKeyDirectory","location","count","substring","subarray","getValues","dataSlice","readMethod","fieldTypeLength","Int8Array","Uint16Array","Int16Array","Uint32Array","Int32Array","Float32Array","Float64Array","ImageFileDirectory","nextIFDByteOffset","GeoTIFFImageIndexError","index","GeoTIFFBase","readRasters","options","window","imageWindow","width","height","resX","resY","bbox","firstImage","getImage","usedImage","imageCount","getImageCount","imgBBox","getBoundingBox","oX","oY","getOrigin","rX","rY","getResolution","usedBBox","allImages","image","SubfileType","subfileType","NewSubfileType","newSubfileType","getWidth","imgResX","imgResY","getHeight","wnd","imageResX","imageResY","round","max","GeoTIFF","firstIFDOffset","cache","ifdRequests","ghostValues","getSlice","fallbackSize","parseFileDirectoryAt","entrySize","offsetSize","numDirEntries","byteSize","entryCount","fieldTag","typeCount","fieldValues","valueOffset","actualOffset","fieldDataSlice","requestIFD","e","previousIfd","ifd","dataView","hasNext","getGhostValues","detectionString","heuristicAreaSize","valuesString","firstLine","metadataSize","fullString","fromSource","headerData","BOM","TypeError","magicNumber","offsetByteSize","MultiGeoTIFF","mainFile","overviewFiles","imageFiles","fileDirectoriesPerFile","fileDirectoriesPerFileParsing","parseFileDirectoriesPerFile","requests","visited","relativeIndex","imageFile","ii","imageCounts","reduce","ifds","fromUrl","fromBlob","fromUrls","mainUrl","overviewUrls","fromWhiteIsZero","raster","rgbRaster","j","fromBlackIsZero","fromPalette","colorMap","greenOffset","blueOffset","mapIndex","fromCMYK","cmykRaster","y","fromYCbCr","yCbCrRaster","Uint8ClampedArray","cb","cr","Xn","Yn","Zn","fromCIELab","cieLabRaster","L","a_","b_","r","g","x","z","copyNewSize","array","samplesPerPixel","getPrototypeOf","resampleNearest","valueArrays","inWidth","inHeight","outWidth","outHeight","relX","relY","newArray","cy","cx","lerp","v0","v1","resampleBilinear","rawY","yl","yh","ceil","rawX","tx","xl","xh","ll","hl","lh","hh","resample","method","resampleNearestInterleaved","valueArray","samples","resampleBilinearInterleaved","resampleInterleaved","sum","arrayForType","bitsPerSample","needsNormalization","normalizeArray","inBuffer","planarConfiguration","tileWidth","tileHeight","outSize","samplesToTransfer","outArray","bitMask","repeat","pixelBitSkip","bitsPerLine","lineBitOffset","pixelBitOffset","bitOffset","outIndex","byteOffset","innerBitOffset","raw","GeoTIFFImage","geoKeys","tiles","isTiled","StripOffsets","PlanarConfiguration","getFileDirectory","getGeoKeys","ImageWidth","ImageLength","getSamplesPerPixel","SamplesPerPixel","getTileWidth","TileWidth","getTileHeight","TileLength","RowsPerStrip","getBlockWidth","getBlockHeight","getBytesPerPixel","bytes","BitsPerSample","getSampleByteSize","getReaderForSample","sampleIndex","SampleFormat","prototype","getSampleFormat","getBitsPerSample","getArrayForSample","getTileOrStrip","sample","poolOrDecoder","numTilesPerRow","numTilesPerCol","byteCount","TileOffsets","TileByteCounts","StripByteCounts","sampleFormat","_readRaster","interleave","resampleMethod","imageWidth","imageHeight","minXTile","maxXTile","minYTile","maxYTile","windowWidth","bytesPerPixel","srcSampleOffsets","sampleReaders","promises","yTile","xTile","getPromise","si","promise","tile","blockHeight","firstCol","lastLine","lastCol","ymax","xmax","pixelOffset","windowCoordinate","resampled","pool","fillValue","imageWindowWidth","imageWindowHeight","numPixels","apply","fill","readRGB","enableAlpha","pi","PhotometricInterpretation","RGB","ExtraSamples","Unspecified","WhiteIsZero","BlackIsZero","Palette","CMYK","YCbCr","CIELab","subOptions","ColorMap","red","green","blue","getTiePoints","ModelTiepoint","tiePoints","getGDALMetadata","metadata","GDAL_METADATA","string","inner","getGDALNoData","GDAL_NODATA","modelTransformation","ModelTransformation","referenceImage","modelPixelScale","ModelPixelScale","sqrt","refResX","refResY","refResZ","pixelIsArea","GTRasterTypeGeoKey","tilegrid","d","f","h","corners","projected","I","J","xs","pt","ys","origin","resolution","x1","y1","x2","y2","fieldTagNames","fieldTags","arrayFields","StripRowCounts","SubIFDs","fieldTypeNames","fieldTypes","photometricInterpretations","TransparencyMask","ICCLab","ExtraSamplesValues","Assocalpha","Unassalpha","LercParameters","Version","AddCompression","LercAddCompression","None","Deflate","Zstandard","geoKeyNames"],"sourceRoot":""}
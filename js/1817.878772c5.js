"use strict";(globalThis["webpackChunk_openeo_web_editor"]=globalThis["webpackChunk_openeo_web_editor"]||[]).push([[1817],{35316:(e,t,i)=>{i.d(t,{A:()=>f,t:()=>g});var r=i(21483);function n(e,t){const i=[];Object.keys(t).forEach(function(e){null!==t[e]&&void 0!==t[e]&&i.push(e+"="+encodeURIComponent(t[e]))});const r=i.join("&");return e=e.replace(/[?&]$/,""),e+=e.includes("?")?"&":"?",e+r}var s=i(70915),o=i(56758),a=i(89718);class l extends o.A{constructor(e){super({extent:e.extent,origin:e.origin,origins:e.origins,resolutions:e.resolutions,tileSize:e.tileSize,tileSizes:e.tileSizes,sizes:e.sizes}),this.matrixIds_=e.matrixIds}getMatrixId(e){return this.matrixIds_[e]}getMatrixIds(){return this.matrixIds_}}function h(e,t,i){const r=[],n=[],s=[],o=[],h=[];i=void 0!==i?i:[];const c="SupportedCRS",u="TileMatrix",f="Identifier",g="ScaleDenominator",d="TopLeftCorner",p="TileWidth",m="TileHeight",y=e[c],w=(0,a.get)(y),S=w.getMetersPerUnit(),T="ne"==w.getAxisOrientation().substr(0,2);return e[u].sort(function(e,t){return t[g]-e[g]}),e[u].forEach(function(t){let a;if(a=!(i.length>0)||i.find(function(i){return t[f]==i[u]||!t[f].includes(":")&&e[f]+":"+t[f]===i[u]}),a){n.push(t[f]);const e=28e-5*t[g]/S,i=t[p],a=t[m];T?s.push([t[d][1],t[d][0]]):s.push(t[d]),r.push(e),o.push(i==a?i:[i,a]),h.push([t["MatrixWidth"],t["MatrixHeight"]])}}),new l({extent:t,origins:s,resolutions:r,matrixIds:n,tileSizes:o,sizes:h})}var c=i(42654);class u extends r.A{constructor(e){const t=void 0!==e.requestEncoding?e.requestEncoding:"KVP",i=e.tileGrid;let r=e.urls;void 0===r&&void 0!==e.url&&(r=(0,c.Uu)(e.url)),super({attributions:e.attributions,attributionsCollapsible:e.attributionsCollapsible,cacheSize:e.cacheSize,crossOrigin:e.crossOrigin,interpolate:e.interpolate,projection:e.projection,reprojectionErrorThreshold:e.reprojectionErrorThreshold,tileClass:e.tileClass,tileGrid:i,tileLoadFunction:e.tileLoadFunction,tilePixelRatio:e.tilePixelRatio,urls:r,wrapX:void 0!==e.wrapX&&e.wrapX,transition:e.transition,zDirection:e.zDirection}),this.version_=void 0!==e.version?e.version:"1.0.0",this.format_=void 0!==e.format?e.format:"image/jpeg",this.dimensions_=void 0!==e.dimensions?e.dimensions:{},this.layer_=e.layer,this.matrixSet_=e.matrixSet,this.style_=e.style,this.requestEncoding_=t,this.setKey(this.getKeyForDimensions_()),r&&r.length>0&&(this.tileUrlFunction=(0,c.FD)(r.map(this.createFromWMTSTemplate.bind(this))))}setUrls(e){this.urls=e;const t=e.join("\n");this.setTileUrlFunction((0,c.FD)(e.map(this.createFromWMTSTemplate.bind(this))),t)}getDimensions(){return this.dimensions_}getFormat(){return this.format_}getLayer(){return this.layer_}getMatrixSet(){return this.matrixSet_}getRequestEncoding(){return this.requestEncoding_}getStyle(){return this.style_}getVersion(){return this.version_}getKeyForDimensions_(){const e=this.urls?this.urls.slice(0):[];for(const t in this.dimensions_)e.push(t+"-"+this.dimensions_[t]);return e.join("/")}updateDimensions(e){Object.assign(this.dimensions_,e),this.setKey(this.getKeyForDimensions_())}createFromWMTSTemplate(e){const t=this.requestEncoding_,i={layer:this.layer_,style:this.style_,tilematrixset:this.matrixSet_};"KVP"==t&&Object.assign(i,{Service:"WMTS",Request:"GetTile",Version:this.version_,Format:this.format_}),e="KVP"==t?n(e,i):e.replace(/\{(\w+?)\}/g,function(e,t){return t.toLowerCase()in i?i[t.toLowerCase()]:e});const r=this.tileGrid,s=this.dimensions_;return function(i,o,a){if(!i)return;const l={TileMatrix:r.getMatrixId(i[0]),TileCol:i[1],TileRow:i[2]};Object.assign(l,s);let h=e;return h="KVP"==t?n(h,l):h.replace(/\{(\w+?)\}/g,function(e,t){return l[t]}),h}}}const f=u;function g(e,t){const i=e["Contents"]["Layer"],r=i?.find(function(e){return e["Identifier"]==t["layer"]});if(!r)return null;const n=e["Contents"]["TileMatrixSet"];let o;o=r["TileMatrixSetLink"].length>1?"projection"in t?r["TileMatrixSetLink"].findIndex(function(e){const i=n.find(function(t){return t["Identifier"]==e["TileMatrixSet"]}),r=i["SupportedCRS"],s=(0,a.get)(r),o=(0,a.get)(t["projection"]);return s&&o?(0,a.equivalent)(s,o):r==t["projection"]}):r["TileMatrixSetLink"].findIndex(function(e){return e["TileMatrixSet"]==t["matrixSet"]}):0,o<0&&(o=0);const l=r["TileMatrixSetLink"][o]["TileMatrixSet"],c=r["TileMatrixSetLink"][o]["TileMatrixSetLimits"];let u=r["Format"][0];"format"in t&&(u=t["format"]),o=r["Style"].findIndex(function(e){return"style"in t?e["Title"]==t["style"]:e["isDefault"]}),o<0&&(o=0);const f=r["Style"][o]["Identifier"],g={};"Dimension"in r&&r["Dimension"].forEach(function(e,t,i){const r=e["Identifier"];let n=e["Default"];void 0===n&&(n=e["Value"][0]),g[r]=n});const d=e["Contents"]["TileMatrixSet"],p=d.find(function(e){return e["Identifier"]==l});let m;const y=p["SupportedCRS"];if(y&&(m=(0,a.get)(y)),"projection"in t){const e=(0,a.get)(t["projection"]);e&&(m&&!(0,a.equivalent)(e,m)||(m=e))}let w=!1;const S="ne"==m.getAxisOrientation().substr(0,2);let T=p.TileMatrix[0],b={MinTileCol:0,MinTileRow:0,MaxTileCol:T.MatrixWidth-1,MaxTileRow:T.MatrixHeight-1};if(c){b=c[c.length-1];const e=p.TileMatrix.find(e=>e.Identifier===b.TileMatrix||p.Identifier+":"+e.Identifier===b.TileMatrix);e&&(T=e)}const _=28e-5*T.ScaleDenominator/m.getMetersPerUnit(),E=S?[T.TopLeftCorner[1],T.TopLeftCorner[0]]:T.TopLeftCorner,I=T.TileWidth*_,A=T.TileHeight*_;let C=p["BoundingBox"];C&&S&&(C=[C[1],C[0],C[3],C[2]]);let P=[E[0]+I*b.MinTileCol,E[1]-A*(1+b.MaxTileRow),E[0]+I*(1+b.MaxTileCol),E[1]-A*b.MinTileRow];if(void 0!==C&&!(0,s.ms)(C,P)){const e=r["WGS84BoundingBox"],t=(0,a.get)("EPSG:4326").getExtent();if(P=C,e)w=e[0]===t[0]&&e[2]===t[2];else{const e=(0,a.transformExtent)(C,p["SupportedCRS"],"EPSG:4326");w=e[0]-1e-10<=t[0]&&e[2]+1e-10>=t[2]}}const F=h(p,P,c),D=[];let R=t["requestEncoding"];if(R=void 0!==R?R:"","OperationsMetadata"in e&&"GetTile"in e["OperationsMetadata"]){const t=e["OperationsMetadata"]["GetTile"]["DCP"]["HTTP"]["Get"];for(let e=0,i=t.length;e<i;++e)if(t[e]["Constraint"]){const i=t[e]["Constraint"].find(function(e){return"GetEncoding"==e["name"]}),r=i["AllowedValues"]["Value"];if(""===R&&(R=r[0]),"KVP"!==R)break;r.includes("KVP")&&D.push(t[e]["href"])}else t[e]["href"]&&(R="KVP",D.push(t[e]["href"]))}return 0===D.length&&(R="REST",r["ResourceURL"].forEach(function(e){"tile"===e["resourceType"]&&(u=e["format"],D.push(e["template"]))})),{urls:D,layer:t["layer"],matrixSet:l,format:u,projection:m,requestEncoding:R,tileGrid:F,style:f,dimensions:g,wrapX:w,crossOrigin:t["crossOrigin"]}}},66922:(e,t,i)=>{i.d(t,{A:()=>u});var r=i(22808),n=i(75332),s=i(566),o=i(49825),a=i(15477);function l(e,t,i){const r=(0,o.SR)();return r.style=e.style,(0,a.nR)(t,i,r,e)}function h(e,t){const i=`\n    attribute vec2 ${s.eS.TEXTURE_COORD};\n    uniform mat4 ${s.gF.TILE_TRANSFORM};\n    uniform float ${s.gF.TEXTURE_PIXEL_WIDTH};\n    uniform float ${s.gF.TEXTURE_PIXEL_HEIGHT};\n    uniform float ${s.gF.TEXTURE_RESOLUTION};\n    uniform float ${s.gF.TEXTURE_ORIGIN_X};\n    uniform float ${s.gF.TEXTURE_ORIGIN_Y};\n    uniform float ${s.gF.DEPTH};\n\n    varying vec2 v_textureCoord;\n    varying vec2 v_mapCoord;\n\n    void main() {\n      v_textureCoord = ${s.eS.TEXTURE_COORD};\n      v_mapCoord = vec2(\n        ${s.gF.TEXTURE_ORIGIN_X} + ${s.gF.TEXTURE_RESOLUTION} * ${s.gF.TEXTURE_PIXEL_WIDTH} * v_textureCoord[0],\n        ${s.gF.TEXTURE_ORIGIN_Y} - ${s.gF.TEXTURE_RESOLUTION} * ${s.gF.TEXTURE_PIXEL_HEIGHT} * v_textureCoord[1]\n      );\n      gl_Position = ${s.gF.TILE_TRANSFORM} * vec4(${s.eS.TEXTURE_COORD}, ${s.gF.DEPTH}, 1.0);\n    }\n  `,r={...(0,a.z0)(),inFragmentShader:!0,bandCount:t,style:e},n=[];if(void 0!==e.color){const t=l(r,e.color,o.mE);n.push(`color = ${t};`)}if(void 0!==e.contrast){const t=l(r,e.contrast,o.wl);n.push(`color.rgb = clamp((${t} + 1.0) * color.rgb - (${t} / 2.0), vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));`)}if(void 0!==e.exposure){const t=l(r,e.exposure,o.wl);n.push(`color.rgb = clamp((${t} + 1.0) * color.rgb, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));`)}if(void 0!==e.saturation){const t=l(r,e.saturation,o.wl);n.push(`\n      float saturation = ${t} + 1.0;\n      float sr = (1.0 - saturation) * 0.2126;\n      float sg = (1.0 - saturation) * 0.7152;\n      float sb = (1.0 - saturation) * 0.0722;\n      mat3 saturationMatrix = mat3(\n        sr + saturation, sr, sr,\n        sg, sg + saturation, sg,\n        sb, sb, sb + saturation\n      );\n      color.rgb = clamp(saturationMatrix * color.rgb, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    `)}if(void 0!==e.gamma){const t=l(r,e.gamma,o.wl);n.push(`color.rgb = pow(color.rgb, vec3(1.0 / ${t}));`)}if(void 0!==e.brightness){const t=l(r,e.brightness,o.wl);n.push(`color.rgb = clamp(color.rgb + ${t}, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));`)}const h={},c=Object.keys(r.variables).length;if(c>1&&!e.variables)throw new Error(`Missing variables in style (expected ${r.variables})`);for(let s=0;s<c;++s){const t=r.variables[Object.keys(r.variables)[s]];if(!(t.name in e.variables))throw new Error(`Missing '${t.name}' in style variables`);const i=(0,a.Sl)(t.name);h[i]=function(){let i=e.variables[t.name];return"string"===typeof i&&(i=(0,a.Lm)(i)),void 0!==i?i:-9999999}}const u=Object.keys(h).map(function(e){return`uniform float ${e};`}),f=Math.ceil(t/4);u.push(`uniform sampler2D ${s.gF.TILE_TEXTURE_ARRAY}[${f}];`),r.paletteTextures&&u.push(`uniform sampler2D ${a.uZ}[${r.paletteTextures.length}];`);const g=Object.keys(r.functions).map(function(e){return r.functions[e]}),d=`\n    #ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n    #else\n    precision mediump float;\n    #endif\n\n    varying vec2 v_textureCoord;\n    varying vec2 v_mapCoord;\n    uniform vec4 ${s.gF.RENDER_EXTENT};\n    uniform float ${s.gF.TRANSITION_ALPHA};\n    uniform float ${s.gF.TEXTURE_PIXEL_WIDTH};\n    uniform float ${s.gF.TEXTURE_PIXEL_HEIGHT};\n    uniform float ${s.gF.RESOLUTION};\n    uniform float ${s.gF.ZOOM};\n\n    ${u.join("\n")}\n\n    ${g.join("\n")}\n\n    void main() {\n      if (\n        v_mapCoord[0] < ${s.gF.RENDER_EXTENT}[0] ||\n        v_mapCoord[1] < ${s.gF.RENDER_EXTENT}[1] ||\n        v_mapCoord[0] > ${s.gF.RENDER_EXTENT}[2] ||\n        v_mapCoord[1] > ${s.gF.RENDER_EXTENT}[3]\n      ) {\n        discard;\n      }\n\n      vec4 color = texture2D(${s.gF.TILE_TEXTURE_ARRAY}[0],  v_textureCoord);\n\n      ${n.join("\n")}\n\n      gl_FragColor = color;\n      gl_FragColor.rgb *= gl_FragColor.a;\n      gl_FragColor *= ${s.gF.TRANSITION_ALPHA};\n    }`;return{vertexShader:i,fragmentShader:d,uniforms:h,paletteTextures:r.paletteTextures}}class c extends r.A{constructor(e){e=e?Object.assign({},e):{};const t=e.style||{};delete e.style;const i=e.cacheSize;delete e.cacheSize,super(e),this.sources_=e.sources,this.renderedSource_=null,this.renderedResolution_=NaN,this.style_=t,this.cacheSize_=i,this.styleVariables_=this.style_.variables||{},this.addChangeListener(n.A.SOURCE,this.handleSourceUpdate_)}getSources(e,t){const i=this.getSource();return this.sources_?"function"===typeof this.sources_?this.sources_(e,t):this.sources_:i?[i]:[]}getRenderSource(){return this.renderedSource_||this.getSource()}getSourceState(){const e=this.getRenderSource();return e?e.getState():"undefined"}handleSourceUpdate_(){this.hasRenderer()&&this.getRenderer().clearCache(),this.getSource()&&this.setStyle(this.style_)}getSourceBandCount_(){const e=Number.MAX_SAFE_INTEGER,t=this.getSources([-e,-e,e,e],e);return t&&t.length&&"bandCount"in t[0]?t[0].bandCount:4}createRenderer(){const e=h(this.style_,this.getSourceBandCount_());return new s.Ay(this,{vertexShader:e.vertexShader,fragmentShader:e.fragmentShader,uniforms:e.uniforms,cacheSize:this.cacheSize_,paletteTextures:e.paletteTextures})}renderSources(e,t){const i=this.getRenderer();let r;for(let n=0,s=t.length;n<s;++n)this.renderedSource_=t[n],i.prepareFrame(e)&&(r=i.renderFrame(e));return r}render(e,t){this.rendered=!0;const i=e.viewState,r=this.getSources(e.extent,i.resolution);let n=!0;for(let o=0,a=r.length;o<a;++o){const e=r[o],t=e.getState();if("loading"==t){const t=()=>{"ready"==e.getState()&&(e.removeEventListener("change",t),this.changed())};e.addEventListener("change",t)}n=n&&"ready"==t}const s=this.renderSources(e,r);if(this.getRenderer().renderComplete&&n)return this.renderedResolution_=i.resolution,s;if(this.renderedResolution_>.5*i.resolution){const t=this.getSources(e.extent,this.renderedResolution_).filter(e=>!r.includes(e));if(t.length>0)return this.renderSources(e,t)}return s}setStyle(e){this.styleVariables_=e.variables||{},this.style_=e;const t=h(this.style_,this.getSourceBandCount_()),i=this.getRenderer();i.reset({vertexShader:t.vertexShader,fragmentShader:t.fragmentShader,uniforms:t.uniforms,paletteTextures:t.paletteTextures}),this.changed()}updateStyleVariables(e){Object.assign(this.styleVariables_,e),this.changed()}}c.prototype.dispose;const u=c},84777:(e,t,i)=>{i.d(t,{A:()=>dt});var r=i(27607),n=i(6837),s=i(98596),o=i(70061),a=i(18469),l=i(66017),h=i(11078),c=i(4863),u=i(89718),f=i(40186),g=i(4087),d=i(74238),p=i(6782);class m extends l.A{constructor(e){const t=void 0===e.projection?"EPSG:3857":e.projection;let i=e.tileGrid;void 0===i&&t&&(i=(0,c.EN)({extent:(0,c.kZ)(t),maxResolution:e.maxResolution,maxZoom:e.maxZoom,minZoom:e.minZoom,tileSize:e.tileSize})),super({cacheSize:.1,attributions:e.attributions,attributionsCollapsible:e.attributionsCollapsible,projection:t,tileGrid:i,opaque:e.opaque,state:e.state,wrapX:e.wrapX,transition:e.transition,interpolate:e.interpolate}),this.gutter_=void 0!==e.gutter?e.gutter:0,this.tileSize_=e.tileSize?(0,p.xq)(e.tileSize):null,this.tileSizes_=null,this.tileLoadingKeys_={},this.loader_=e.loader,this.handleTileChange_=this.handleTileChange_.bind(this),this.bandCount=void 0===e.bandCount?4:e.bandCount,this.tileGridForProjection_={},this.tileCacheForProjection_={}}setTileSizes(e){this.tileSizes_=e}getTileSize(e){if(this.tileSizes_)return this.tileSizes_[e];if(this.tileSize_)return this.tileSize_;const t=this.getTileGrid();return t?(0,p.xq)(t.getTileSize(e)):[256,256]}getGutterForProjection(e){const t=this.getProjection();return!t||(0,u.equivalent)(t,e)?this.gutter_:0}setLoader(e){this.loader_=e}getReprojTile_(e,t,i,r,n){const o=this.getTileCacheForProjection(r),a=(0,f.dp)(e,t,i);if(o.containsKey(a)){const e=o.get(a);if(e&&e.key==this.getKey())return e}const l=this.getTileGrid(),h=Math.max.apply(null,l.getResolutions().map((e,t)=>{const i=(0,p.xq)(l.getTileSize(t)),r=this.getTileSize(t);return Math.max(r[0]/i[0],r[1]/i[1])})),c=this.getTileGridForProjection(n),u=this.getTileGridForProjection(r),g=[e,t,i],d=this.getTileCoordForTileUrlFunction(g,r),m=Object.assign({sourceProj:n,sourceTileGrid:c,targetProj:r,targetTileGrid:u,tileCoord:g,wrappedTileCoord:d,pixelRatio:h,gutter:this.getGutterForProjection(n),getTileFunction:(e,t,i,r)=>this.getTile(e,t,i,r,n)},this.tileOptions),y=new s.A(m);return y.key=this.getKey(),y}getTile(e,t,i,s,o){const a=this.getProjection();if(a&&o&&!(0,u.equivalent)(a,o))return this.getReprojTile_(e,t,i,o,a);const l=this.getTileSize(e),h=(0,f.dp)(e,t,i);if(this.tileCache.containsKey(h))return this.tileCache.get(h);const c=this.loader_;function g(){return(0,d.hq)(function(){return c(e,t,i)})}const p=Object.assign({tileCoord:[e,t,i],loader:g,size:l},this.tileOptions),m=new r.Ay(p);return m.key=this.getKey(),m.addEventListener(n.A.CHANGE,this.handleTileChange_),this.tileCache.set(h,m),m}handleTileChange_(e){const t=e.target,i=(0,g.v6)(t),r=t.getState();let n;r==h.A.LOADING?(this.tileLoadingKeys_[i]=!0,n=a.A.TILELOADSTART):i in this.tileLoadingKeys_&&(delete this.tileLoadingKeys_[i],n=r==h.A.ERROR?a.A.TILELOADERROR:r==h.A.LOADED?a.A.TILELOADEND:void 0),n&&this.dispatchEvent(new l.c(n,t))}getTileGridForProjection(e){const t=this.getProjection();if(this.tileGrid&&(!t||(0,u.equivalent)(t,e)))return this.tileGrid;const i=(0,g.v6)(e);return i in this.tileGridForProjection_||(this.tileGridForProjection_[i]=(0,c.pr)(e)),this.tileGridForProjection_[i]}setTileGridForProjection(e,t){const i=(0,u.get)(e);if(i){const e=(0,g.v6)(i);e in this.tileGridForProjection_||(this.tileGridForProjection_[e]=t)}}getTileCacheForProjection(e){const t=this.getProjection();if(!t||(0,u.equivalent)(t,e))return this.tileCache;const i=(0,g.v6)(e);return i in this.tileCacheForProjection_||(this.tileCacheForProjection_[i]=new o.A(.1)),this.tileCacheForProjection_[i]}expireCache(e,t){const i=this.getTileCacheForProjection(e);this.tileCache.expireCache(this.tileCache==i?t:{});for(const r in this.tileCacheForProjection_){const e=this.tileCacheForProjection_[r];e.expireCache(e==i?t:{})}}clear(){super.clear();for(const e in this.tileCacheForProjection_)this.tileCacheForProjection_[e].clear()}}const y=m;var w=i(56758),S=i(86895);const T=new Map;function b(e,t){Array.isArray(e)||(e=[e]),e.forEach(e=>T.set(e,t))}async function _(e){const t=T.get(e.Compression);if(!t)throw new Error(`Unknown compression method identifier: ${e.Compression}`);const i=await t();return new i(e)}b([void 0,1],()=>i.e(6584).then(i.bind(i,6584)).then(e=>e.default)),b(5,()=>i.e(8998).then(i.bind(i,56617)).then(e=>e.default)),b(6,()=>{throw new Error("old style JPEG compression is not supported.")}),b(7,()=>i.e(5066).then(i.bind(i,95066)).then(e=>e.default)),b([8,32946],()=>Promise.all([i.e(3075),i.e(8177)]).then(i.bind(i,68177)).then(e=>e.default)),b(32773,()=>i.e(7585).then(i.bind(i,37585)).then(e=>e.default)),b(34887,()=>Promise.all([i.e(3075),i.e(4827),i.e(2624)]).then(i.bind(i,2624)).then(async e=>(await e.zstd.init(),e)).then(e=>e.default)),b(50001,()=>i.e(1255).then(i.bind(i,11255)).then(e=>e.default));const E="undefined"!==typeof navigator&&navigator.hardwareConcurrency||2;class I{constructor(e=E,t){this.workers=null,this._awaitingDecoder=null,this.size=e,this.messageId=0,e&&(this._awaitingDecoder=t?Promise.resolve(t):new Promise(e=>{i.e(1574).then(i.bind(i,31574)).then(t=>{e(t.create)})}),this._awaitingDecoder.then(t=>{this._awaitingDecoder=null,this.workers=[];for(let i=0;i<e;i++)this.workers.push({worker:t(),idle:!0})}))}async decode(e,t){return this._awaitingDecoder&&await this._awaitingDecoder,0===this.size?_(e).then(i=>i.decode(e,t)):new Promise(i=>{const r=this.workers.find(e=>e.idle)||this.workers[Math.floor(Math.random()*this.size)];r.idle=!1;const n=this.messageId++,s=e=>{e.data.id===n&&(r.idle=!0,i(e.data.decoded),r.worker.removeEventListener("message",s))};r.worker.addEventListener("message",s),r.worker.postMessage({fileDirectory:e,buffer:t,id:n},[t])})}destroy(){this.workers&&(this.workers.forEach(e=>{e.worker.terminate()}),this.workers=null)}}const A=I;var C=i(85326),P=i(27379),F=i(60563);function D(e,t){const{width:i,height:r}=e,n=new Uint8Array(i*r*3);let s;for(let o=0,a=0;o<e.length;++o,a+=3)s=256-e[o]/t*256,n[a]=s,n[a+1]=s,n[a+2]=s;return n}function R(e,t){const{width:i,height:r}=e,n=new Uint8Array(i*r*3);let s;for(let o=0,a=0;o<e.length;++o,a+=3)s=e[o]/t*256,n[a]=s,n[a+1]=s,n[a+2]=s;return n}function x(e,t){const{width:i,height:r}=e,n=new Uint8Array(i*r*3),s=t.length/3,o=t.length/3*2;for(let a=0,l=0;a<e.length;++a,l+=3){const i=e[a];n[l]=t[i]/65536*256,n[l+1]=t[i+s]/65536*256,n[l+2]=t[i+o]/65536*256}return n}function M(e){const{width:t,height:i}=e,r=new Uint8Array(t*i*3);for(let n=0,s=0;n<e.length;n+=4,s+=3){const t=e[n],i=e[n+1],o=e[n+2],a=e[n+3];r[s]=(255-t)/256*255*((255-a)/256),r[s+1]=(255-i)/256*255*((255-a)/256),r[s+2]=(255-o)/256*255*((255-a)/256)}return r}function v(e){const{width:t,height:i}=e,r=new Uint8ClampedArray(t*i*3);for(let n=0,s=0;n<e.length;n+=3,s+=3){const t=e[n],i=e[n+1],o=e[n+2];r[s]=t+1.402*(o-128),r[s+1]=t-.34414*(i-128)-.71414*(o-128),r[s+2]=t+1.772*(i-128)}return r}const G=.95047,O=1,k=1.08883;function U(e){const{width:t,height:i}=e,r=new Uint8Array(t*i*3);for(let n=0,s=0;n<e.length;n+=3,s+=3){const t=e[n+0],i=e[n+1]<<24>>24,o=e[n+2]<<24>>24;let a,l,h,c=(t+16)/116,u=i/500+c,f=c-o/200;u=G*(u*u*u>.008856?u*u*u:(u-16/116)/7.787),c=O*(c*c*c>.008856?c*c*c:(c-16/116)/7.787),f=k*(f*f*f>.008856?f*f*f:(f-16/116)/7.787),a=3.2406*u+-1.5372*c+-.4986*f,l=-.9689*u+1.8758*c+.0415*f,h=.0557*u+-.204*c+1.057*f,a=a>.0031308?1.055*a**(1/2.4)-.055:12.92*a,l=l>.0031308?1.055*l**(1/2.4)-.055:12.92*l,h=h>.0031308?1.055*h**(1/2.4)-.055:12.92*h,r[s]=255*Math.max(0,Math.min(1,a)),r[s+1]=255*Math.max(0,Math.min(1,l)),r[s+2]=255*Math.max(0,Math.min(1,h))}return r}function L(e,t,i,r=1){return new(Object.getPrototypeOf(e).constructor)(t*i*r)}function j(e,t,i,r,n){const s=t/r,o=i/n;return e.map(e=>{const a=L(e,r,n);for(let l=0;l<n;++l){const n=Math.min(Math.round(o*l),i-1);for(let i=0;i<r;++i){const o=Math.min(Math.round(s*i),t-1),h=e[n*t+o];a[l*r+i]=h}}return a})}function $(e,t,i){return(1-i)*e+i*t}function N(e,t,i,r,n){const s=t/r,o=i/n;return e.map(e=>{const a=L(e,r,n);for(let l=0;l<n;++l){const n=o*l,h=Math.floor(n),c=Math.min(Math.ceil(n),i-1);for(let i=0;i<r;++i){const o=s*i,u=o%1,f=Math.floor(o),g=Math.min(Math.ceil(o),t-1),d=e[h*t+f],p=e[h*t+g],m=e[c*t+f],y=e[c*t+g],w=$($(d,p,u),$(m,y,u),n%1);a[l*r+i]=w}}return a})}function z(e,t,i,r,n,s="nearest"){switch(s.toLowerCase()){case"nearest":return j(e,t,i,r,n);case"bilinear":case"linear":return N(e,t,i,r,n);default:throw new Error(`Unsupported resampling method: '${s}'`)}}function K(e,t,i,r,n,s){const o=t/r,a=i/n,l=L(e,r,n,s);for(let h=0;h<n;++h){const n=Math.min(Math.round(a*h),i-1);for(let i=0;i<r;++i){const a=Math.min(Math.round(o*i),t-1);for(let o=0;o<s;++o){const c=e[n*t*s+a*s+o];l[h*r*s+i*s+o]=c}}}return l}function B(e,t,i,r,n,s){const o=t/r,a=i/n,l=L(e,r,n,s);for(let h=0;h<n;++h){const n=a*h,c=Math.floor(n),u=Math.min(Math.ceil(n),i-1);for(let i=0;i<r;++i){const a=o*i,f=a%1,g=Math.floor(a),d=Math.min(Math.ceil(a),t-1);for(let o=0;o<s;++o){const a=e[c*t*s+g*s+o],p=e[c*t*s+d*s+o],m=e[u*t*s+g*s+o],y=e[u*t*s+d*s+o],w=$($(a,p,f),$(m,y,f),n%1);l[h*r*s+i*s+o]=w}}}return l}function V(e,t,i,r,n,s,o="nearest"){switch(o.toLowerCase()){case"nearest":return K(e,t,i,r,n,s);case"bilinear":case"linear":return B(e,t,i,r,n,s);default:throw new Error(`Unsupported resampling method: '${o}'`)}}function q(e,t,i){let r=0;for(let n=t;n<i;++n)r+=e[n];return r}function H(e,t,i){switch(e){case 1:if(t<=8)return new Uint8Array(i);if(t<=16)return new Uint16Array(i);if(t<=32)return new Uint32Array(i);break;case 2:if(8===t)return new Int8Array(i);if(16===t)return new Int16Array(i);if(32===t)return new Int32Array(i);break;case 3:switch(t){case 16:case 32:return new Float32Array(i);case 64:return new Float64Array(i);default:break}break;default:break}throw Error("Unsupported data format/bitsPerSample")}function X(e,t){return(1!==e&&2!==e||!(t<=32)||t%8!==0)&&(3!==e||16!==t&&32!==t&&64!==t)}function W(e,t,i,r,n,s,o){const a=new DataView(e),l=2===i?o*s:o*s*r,h=2===i?1:r,c=H(t,n,l),u=parseInt("1".repeat(n),2);if(1===t){let e;e=1===i?r*n:n;let t=s*e;0!==(7&t)&&(t=t+7&-8);for(let i=0;i<o;++i){const e=i*t;for(let t=0;t<s;++t){const r=e+t*h*n;for(let e=0;e<h;++e){const o=r+e*n,l=(i*s+t)*h+e,f=Math.floor(o/8),g=o%8;if(g+n<=8)c[l]=a.getUint8(f)>>8-n-g&u;else if(g+n<=16)c[l]=a.getUint16(f)>>16-n-g&u;else if(g+n<=24){const e=a.getUint16(f)<<8|a.getUint8(f+2);c[l]=e>>24-n-g&u}else c[l]=a.getUint32(f)>>32-n-g&u}}}}return c.buffer}class Y{constructor(e,t,i,r,n,s){this.fileDirectory=e,this.geoKeys=t,this.dataView=i,this.littleEndian=r,this.tiles=n?{}:null,this.isTiled=!e.StripOffsets;const o=e.PlanarConfiguration;if(this.planarConfiguration="undefined"===typeof o?1:o,1!==this.planarConfiguration&&2!==this.planarConfiguration)throw new Error("Invalid planar configuration.");this.source=s}getFileDirectory(){return this.fileDirectory}getGeoKeys(){return this.geoKeys}getWidth(){return this.fileDirectory.ImageWidth}getHeight(){return this.fileDirectory.ImageLength}getSamplesPerPixel(){return"undefined"!==typeof this.fileDirectory.SamplesPerPixel?this.fileDirectory.SamplesPerPixel:1}getTileWidth(){return this.isTiled?this.fileDirectory.TileWidth:this.getWidth()}getTileHeight(){return this.isTiled?this.fileDirectory.TileLength:"undefined"!==typeof this.fileDirectory.RowsPerStrip?Math.min(this.fileDirectory.RowsPerStrip,this.getHeight()):this.getHeight()}getBlockWidth(){return this.getTileWidth()}getBlockHeight(e){return this.isTiled||(e+1)*this.getTileHeight()<=this.getHeight()?this.getTileHeight():this.getHeight()-e*this.getTileHeight()}getBytesPerPixel(){let e=0;for(let t=0;t<this.fileDirectory.BitsPerSample.length;++t)e+=this.getSampleByteSize(t);return e}getSampleByteSize(e){if(e>=this.fileDirectory.BitsPerSample.length)throw new RangeError(`Sample index ${e} is out of range.`);return Math.ceil(this.fileDirectory.BitsPerSample[e]/8)}getReaderForSample(e){const t=this.fileDirectory.SampleFormat?this.fileDirectory.SampleFormat[e]:1,i=this.fileDirectory.BitsPerSample[e];switch(t){case 1:if(i<=8)return DataView.prototype.getUint8;if(i<=16)return DataView.prototype.getUint16;if(i<=32)return DataView.prototype.getUint32;break;case 2:if(i<=8)return DataView.prototype.getInt8;if(i<=16)return DataView.prototype.getInt16;if(i<=32)return DataView.prototype.getInt32;break;case 3:switch(i){case 16:return function(e,t){return(0,C.O)(this,e,t)};case 32:return DataView.prototype.getFloat32;case 64:return DataView.prototype.getFloat64;default:break}break;default:break}throw Error("Unsupported data format/bitsPerSample")}getSampleFormat(e=0){return this.fileDirectory.SampleFormat?this.fileDirectory.SampleFormat[e]:1}getBitsPerSample(e=0){return this.fileDirectory.BitsPerSample[e]}getArrayForSample(e,t){const i=this.getSampleFormat(e),r=this.getBitsPerSample(e);return H(i,r,t)}async getTileOrStrip(e,t,i,r,n){const s=Math.ceil(this.getWidth()/this.getTileWidth()),o=Math.ceil(this.getHeight()/this.getTileHeight());let a;const{tiles:l}=this;let h,c;1===this.planarConfiguration?a=t*s+e:2===this.planarConfiguration&&(a=i*s*o+t*s+e),this.isTiled?(h=this.fileDirectory.TileOffsets[a],c=this.fileDirectory.TileByteCounts[a]):(h=this.fileDirectory.StripOffsets[a],c=this.fileDirectory.StripByteCounts[a]);const u=(await this.source.fetch([{offset:h,length:c}],n))[0];let f;return null!==l&&l[a]?f=l[a]:(f=(async()=>{let e=await r.decode(this.fileDirectory,u);const i=this.getSampleFormat(),n=this.getBitsPerSample();return X(i,n)&&(e=W(e,i,this.planarConfiguration,this.getSamplesPerPixel(),n,this.getTileWidth(),this.getBlockHeight(t))),e})(),null!==l&&(l[a]=f)),{x:e,y:t,sample:i,data:await f}}async _readRaster(e,t,i,r,n,s,o,a,l){const h=this.getTileWidth(),c=this.getTileHeight(),u=this.getWidth(),f=this.getHeight(),g=Math.max(Math.floor(e[0]/h),0),d=Math.min(Math.ceil(e[2]/h),Math.ceil(u/h)),p=Math.max(Math.floor(e[1]/c),0),m=Math.min(Math.ceil(e[3]/c),Math.ceil(f/c)),y=e[2]-e[0];let w=this.getBytesPerPixel();const S=[],T=[];for(let E=0;E<t.length;++E)1===this.planarConfiguration?S.push(q(this.fileDirectory.BitsPerSample,0,t[E])/8):S.push(0),T.push(this.getReaderForSample(t[E]));const b=[],{littleEndian:_}=this;for(let E=p;E<m;++E)for(let s=g;s<d;++s){let o;1===this.planarConfiguration&&(o=this.getTileOrStrip(s,E,0,n,l));for(let a=0;a<t.length;++a){const g=a,d=t[a];2===this.planarConfiguration&&(w=this.getSampleByteSize(d),o=this.getTileOrStrip(s,E,d,n,l));const p=o.then(n=>{const s=n.data,o=new DataView(s),a=this.getBlockHeight(n.y),l=n.y*c,d=n.x*h,p=l+a,m=(n.x+1)*h,b=T[g],E=Math.min(a,a-(p-e[3]),f-l),I=Math.min(h,h-(m-e[2]),u-d);for(let c=Math.max(0,e[1]-l);c<E;++c)for(let n=Math.max(0,e[0]-d);n<I;++n){const s=(c*h+n)*w,a=b.call(o,s+S[g],_);let u;r?(u=(c+l-e[1])*y*t.length+(n+d-e[0])*t.length+g,i[u]=a):(u=(c+l-e[1])*y+n+d-e[0],i[g][u]=a)}});b.push(p)}}if(await Promise.all(b),s&&e[2]-e[0]!==s||o&&e[3]-e[1]!==o){let n;return n=r?V(i,e[2]-e[0],e[3]-e[1],s,o,t.length,a):z(i,e[2]-e[0],e[3]-e[1],s,o,a),n.width=s,n.height=o,n}return i.width=s||e[2]-e[0],i.height=o||e[3]-e[1],i}async readRasters({window:e,samples:t=[],interleave:i,pool:r=null,width:n,height:s,resampleMethod:o,fillValue:a,signal:l}={}){const h=e||[0,0,this.getWidth(),this.getHeight()];if(h[0]>h[2]||h[1]>h[3])throw new Error("Invalid subsets");const c=h[2]-h[0],u=h[3]-h[1],f=c*u,g=this.getSamplesPerPixel();if(t&&t.length){for(let y=0;y<t.length;++y)if(t[y]>=g)return Promise.reject(new RangeError(`Invalid sample index '${t[y]}'.`))}else for(let y=0;y<g;++y)t.push(y);let d;if(i){const e=this.fileDirectory.SampleFormat?Math.max.apply(null,this.fileDirectory.SampleFormat):1,i=Math.max.apply(null,this.fileDirectory.BitsPerSample);d=H(e,i,f*t.length),a&&d.fill(a)}else{d=[];for(let e=0;e<t.length;++e){const i=this.getArrayForSample(t[e],f);Array.isArray(a)&&e<a.length?i.fill(a[e]):a&&!Array.isArray(a)&&i.fill(a),d.push(i)}}const p=r||await _(this.fileDirectory),m=await this._readRaster(h,t,d,i,p,n,s,o,l);return m}async readRGB({window:e,interleave:t=!0,pool:i=null,width:r,height:n,resampleMethod:s,enableAlpha:o=!1,signal:a}={}){const l=e||[0,0,this.getWidth(),this.getHeight()];if(l[0]>l[2]||l[1]>l[3])throw new Error("Invalid subsets");const h=this.fileDirectory.PhotometricInterpretation;if(h===S.ub.RGB){let l=[0,1,2];if(this.fileDirectory.ExtraSamples!==S.AC.Unspecified&&o){l=[];for(let e=0;e<this.fileDirectory.BitsPerSample.length;e+=1)l.push(e)}return this.readRasters({window:e,interleave:t,samples:l,pool:i,width:r,height:n,resampleMethod:s,signal:a})}let c;switch(h){case S.ub.WhiteIsZero:case S.ub.BlackIsZero:case S.ub.Palette:c=[0];break;case S.ub.CMYK:c=[0,1,2,3];break;case S.ub.YCbCr:case S.ub.CIELab:c=[0,1,2];break;default:throw new Error("Invalid or unsupported photometric interpretation.")}const u={window:l,interleave:!0,samples:c,pool:i,width:r,height:n,resampleMethod:s,signal:a},{fileDirectory:f}=this,g=await this.readRasters(u),d=2**this.fileDirectory.BitsPerSample[0];let p;switch(h){case S.ub.WhiteIsZero:p=D(g,d);break;case S.ub.BlackIsZero:p=R(g,d);break;case S.ub.Palette:p=x(g,f.ColorMap);break;case S.ub.CMYK:p=M(g);break;case S.ub.YCbCr:p=v(g);break;case S.ub.CIELab:p=U(g);break;default:throw new Error("Unsupported photometric interpretation.")}if(!t){const e=new Uint8Array(p.length/3),t=new Uint8Array(p.length/3),i=new Uint8Array(p.length/3);for(let r=0,n=0;r<p.length;r+=3,++n)e[n]=p[r],t[n]=p[r+1],i[n]=p[r+2];p=[e,t,i]}return p.width=g.width,p.height=g.height,p}getTiePoints(){if(!this.fileDirectory.ModelTiepoint)return[];const e=[];for(let t=0;t<this.fileDirectory.ModelTiepoint.length;t+=6)e.push({i:this.fileDirectory.ModelTiepoint[t],j:this.fileDirectory.ModelTiepoint[t+1],k:this.fileDirectory.ModelTiepoint[t+2],x:this.fileDirectory.ModelTiepoint[t+3],y:this.fileDirectory.ModelTiepoint[t+4],z:this.fileDirectory.ModelTiepoint[t+5]});return e}getGDALMetadata(e=null){const t={};if(!this.fileDirectory.GDAL_METADATA)return null;const i=this.fileDirectory.GDAL_METADATA;let r=F(i,"Item");r=null===e?r.filter(e=>void 0===P(e,"sample")):r.filter(t=>Number(P(t,"sample"))===e);for(let n=0;n<r.length;++n){const e=r[n];t[P(e,"name")]=e.inner}return t}getGDALNoData(){if(!this.fileDirectory.GDAL_NODATA)return null;const e=this.fileDirectory.GDAL_NODATA;return Number(e.substring(0,e.length-1))}getOrigin(){const e=this.fileDirectory.ModelTiepoint,t=this.fileDirectory.ModelTransformation;if(e&&6===e.length)return[e[3],e[4],e[5]];if(t)return[t[3],t[7],t[11]];throw new Error("The image does not have an affine transformation.")}getResolution(e=null){const t=this.fileDirectory.ModelPixelScale,i=this.fileDirectory.ModelTransformation;if(t)return[t[0],-t[1],t[2]];if(i)return 0===i[1]&&0===i[4]?[i[0],-i[5],i[10]]:[Math.sqrt(i[0]*i[0]+i[4]*i[4]),-Math.sqrt(i[1]*i[1]+i[5]*i[5]),i[10]];if(e){const[t,i,r]=e.getResolution();return[t*e.getWidth()/this.getWidth(),i*e.getHeight()/this.getHeight(),r*e.getWidth()/this.getWidth()]}throw new Error("The image does not have an affine transformation.")}pixelIsArea(){return 1===this.geoKeys.GTRasterTypeGeoKey}getBoundingBox(e=!1){const t=this.getHeight(),i=this.getWidth();if(this.fileDirectory.ModelTransformation&&!e){const[e,r,n,s,o,a,l,h]=this.fileDirectory.ModelTransformation,c=[[0,0],[0,t],[i,0],[i,t]],u=c.map(([t,i])=>[s+e*t+r*i,h+o*t+a*i]),f=u.map(e=>e[0]),g=u.map(e=>e[1]);return[Math.min(...f),Math.min(...g),Math.max(...f),Math.max(...g)]}{const e=this.getOrigin(),r=this.getResolution(),n=e[0],s=e[1],o=n+r[0]*i,a=s+r[1]*t;return[Math.min(n,o),Math.min(s,a),Math.max(n,o),Math.max(s,a)]}}}const Z=Y;class J{constructor(e){this._dataView=new DataView(e)}get buffer(){return this._dataView.buffer}getUint64(e,t){const i=this.getUint32(e,t),r=this.getUint32(e+4,t);let n;if(t){if(n=i+2**32*r,!Number.isSafeInteger(n))throw new Error(`${n} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);return n}if(n=2**32*i+r,!Number.isSafeInteger(n))throw new Error(`${n} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);return n}getInt64(e,t){let i=0;const r=(128&this._dataView.getUint8(e+(t?7:0)))>0;let n=!0;for(let s=0;s<8;s++){let o=this._dataView.getUint8(e+(t?s:7-s));r&&(n?0!==o&&(o=255&~(o-1),n=!1):o=255&~o),i+=o*256**s}return r&&(i=-i),i}getUint8(e,t){return this._dataView.getUint8(e,t)}getInt8(e,t){return this._dataView.getInt8(e,t)}getUint16(e,t){return this._dataView.getUint16(e,t)}getInt16(e,t){return this._dataView.getInt16(e,t)}getUint32(e,t){return this._dataView.getUint32(e,t)}getInt32(e,t){return this._dataView.getInt32(e,t)}getFloat16(e,t){return(0,C.O)(this._dataView,e,t)}getFloat32(e,t){return this._dataView.getFloat32(e,t)}getFloat64(e,t){return this._dataView.getFloat64(e,t)}}class Q{constructor(e,t,i,r){this._dataView=new DataView(e),this._sliceOffset=t,this._littleEndian=i,this._bigTiff=r}get sliceOffset(){return this._sliceOffset}get sliceTop(){return this._sliceOffset+this.buffer.byteLength}get littleEndian(){return this._littleEndian}get bigTiff(){return this._bigTiff}get buffer(){return this._dataView.buffer}covers(e,t){return this.sliceOffset<=e&&this.sliceTop>=e+t}readUint8(e){return this._dataView.getUint8(e-this._sliceOffset,this._littleEndian)}readInt8(e){return this._dataView.getInt8(e-this._sliceOffset,this._littleEndian)}readUint16(e){return this._dataView.getUint16(e-this._sliceOffset,this._littleEndian)}readInt16(e){return this._dataView.getInt16(e-this._sliceOffset,this._littleEndian)}readUint32(e){return this._dataView.getUint32(e-this._sliceOffset,this._littleEndian)}readInt32(e){return this._dataView.getInt32(e-this._sliceOffset,this._littleEndian)}readFloat32(e){return this._dataView.getFloat32(e-this._sliceOffset,this._littleEndian)}readFloat64(e){return this._dataView.getFloat64(e-this._sliceOffset,this._littleEndian)}readUint64(e){const t=this.readUint32(e),i=this.readUint32(e+4);let r;if(this._littleEndian){if(r=t+2**32*i,!Number.isSafeInteger(r))throw new Error(`${r} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);return r}if(r=2**32*t+i,!Number.isSafeInteger(r))throw new Error(`${r} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);return r}readInt64(e){let t=0;const i=(128&this._dataView.getUint8(e+(this._littleEndian?7:0)))>0;let r=!0;for(let n=0;n<8;n++){let s=this._dataView.getUint8(e+(this._littleEndian?n:7-n));i&&(r?0!==s&&(s=255&~(s-1),r=!1):s=255&~s),t+=s*256**n}return i&&(t=-t),t}readOffset(e){return this._bigTiff?this.readUint64(e):this.readUint32(e)}}const ee="\r\n\r\n";function te(e){if("undefined"!==typeof Object.fromEntries)return Object.fromEntries(e);const t={};for(const[i,r]of e)t[i.toLowerCase()]=r;return t}function ie(e){const t=e.split("\r\n").map(e=>{const t=e.split(":").map(e=>e.trim());return t[0]=t[0].toLowerCase(),t});return te(t)}function re(e){const[t,...i]=e.split(";").map(e=>e.trim()),r=i.map(e=>e.split("="));return{type:t,params:te(r)}}function ne(e){let t,i,r;return e&&([,t,i,r]=e.match(/bytes (\d+)-(\d+)\/(\d+)/),t=parseInt(t,10),i=parseInt(i,10),r=parseInt(r,10)),{start:t,end:i,total:r}}function se(e,t){let i=null;const r=new TextDecoder("ascii"),n=[],s=`--${t}`,o=`${s}--`;for(let a=0;a<10;++a){const t=r.decode(new Uint8Array(e,a,s.length));t===s&&(i=a)}if(null===i)throw new Error("Could not find initial boundary");while(i<e.byteLength){const t=r.decode(new Uint8Array(e,i,Math.min(s.length+1024,e.byteLength-i)));if(0===t.length||t.startsWith(o))break;if(!t.startsWith(s))throw new Error("Part does not start with boundary");const a=t.substr(s.length+2);if(0===a.length)break;const l=a.indexOf(ee),h=ie(a.substr(0,l)),{start:c,end:u,total:f}=ne(h["content-range"]),g=i+s.length+l+ee.length,d=parseInt(u,10)+1-parseInt(c,10);n.push({headers:h,data:e.slice(g,g+d),offset:c,length:d,fileSize:f}),i=g+d+4}return n}class oe{async fetch(e,t=void 0){return Promise.all(e.map(e=>this.fetchSlice(e,t)))}async fetchSlice(e){throw new Error(`fetching of slice ${e} not possible, not implemented`)}get fileSize(){return null}async close(){}}var ae=i(82807);async function le(e){return new Promise(t=>setTimeout(t,e))}function he(e,t){const i=Array.isArray(e)?e:Array.from(e),r=Array.isArray(t)?t:Array.from(t);return i.map((e,t)=>[e,r[t]])}class ce extends Error{constructor(e){super(e),Error.captureStackTrace&&Error.captureStackTrace(this,ce),this.name="AbortError"}}class ue extends Error{constructor(e,t){super(t),this.errors=e,this.message=t,this.name="AggregateError"}}const fe=ue;class ge{constructor(e,t,i=null){this.offset=e,this.length=t,this.data=i}get top(){return this.offset+this.length}}class de{constructor(e,t,i){this.offset=e,this.length=t,this.blockIds=i}}class pe extends oe{constructor(e,{blockSize:t=65536,cacheSize:i=100}={}){super(),this.source=e,this.blockSize=t,this.blockCache=new ae.A({maxSize:i,onEviction:(e,t)=>{this.evictedBlocks.set(e,t)}}),this.evictedBlocks=new Map,this.blockRequests=new Map,this.blockIdsToFetch=new Set,this.abortedBlockIds=new Set}get fileSize(){return this.source.fileSize}async fetch(e,t){const i=[],r=[],n=[];this.evictedBlocks.clear();for(const{offset:u,length:f}of e){let e=u+f;const{fileSize:t}=this;null!==t&&(e=Math.min(e,t));const s=Math.floor(u/this.blockSize)*this.blockSize;for(let o=s;o<e;o+=this.blockSize){const e=Math.floor(o/this.blockSize);this.blockCache.has(e)||this.blockRequests.has(e)||(this.blockIdsToFetch.add(e),r.push(e)),this.blockRequests.has(e)&&i.push(this.blockRequests.get(e)),n.push(e)}}await le(),this.fetchBlocks(t);const s=[];for(const u of r)this.blockRequests.has(u)&&s.push(this.blockRequests.get(u));await Promise.allSettled(i),await Promise.allSettled(s);const o=[],a=n.filter(e=>this.abortedBlockIds.has(e)||!this.blockCache.has(e));if(a.forEach(e=>this.blockIdsToFetch.add(e)),a.length>0&&t&&!t.aborted){this.fetchBlocks(null);for(const e of a){const t=this.blockRequests.get(e);if(!t)throw new Error(`Block ${e} is not in the block requests`);o.push(t)}await Promise.allSettled(o)}if(t&&t.aborted)throw new ce("Request was aborted");const l=n.map(e=>this.blockCache.get(e)||this.evictedBlocks.get(e)),h=l.filter(e=>!e);if(h.length)throw new fe(h,"Request failed");const c=new Map(he(n,l));return this.readSliceData(e,c)}fetchBlocks(e){if(this.blockIdsToFetch.size>0){const t=this.groupBlocks(this.blockIdsToFetch),i=this.source.fetch(t,e);for(let r=0;r<t.length;++r){const n=t[r];for(const t of n.blockIds)this.blockRequests.set(t,(async()=>{try{const e=(await i)[r],n=t*this.blockSize,s=n-e.offset,o=Math.min(s+this.blockSize,e.data.byteLength),a=e.data.slice(s,o),l=new ge(n,a.byteLength,a,t);this.blockCache.set(t,l),this.abortedBlockIds.delete(t)}catch(n){if("AbortError"!==n.name)throw n;n.signal=e,this.blockCache.delete(t),this.abortedBlockIds.add(t)}finally{this.blockRequests.delete(t)}})())}this.blockIdsToFetch.clear()}}groupBlocks(e){const t=Array.from(e).sort((e,t)=>e-t);if(0===t.length)return[];let i=[],r=null;const n=[];for(const s of t)null===r||r+1===s?(i.push(s),r=s):(n.push(new de(i[0]*this.blockSize,i.length*this.blockSize,i)),i=[s],r=s);return n.push(new de(i[0]*this.blockSize,i.length*this.blockSize,i)),n}readSliceData(e,t){return e.map(e=>{let i=e.offset+e.length;null!==this.fileSize&&(i=Math.min(this.fileSize,i));const r=Math.floor(e.offset/this.blockSize),n=Math.floor(i/this.blockSize),s=new ArrayBuffer(e.length),o=new Uint8Array(s);for(let a=r;a<=n;++a){const r=t.get(a),n=r.offset-e.offset,s=r.top-i;let l,h=0,c=0;n<0?h=-n:n>0&&(c=n),l=s<0?r.length-h:i-r.offset-h;const u=new Uint8Array(r.data,h,l);o.set(u,c)}return s})}}class me{get ok(){return this.status>=200&&this.status<=299}get status(){throw new Error("not implemented")}getHeader(e){throw new Error("not implemented")}async getData(){throw new Error("not implemented")}}class ye{constructor(e){this.url=e}async request({headers:e,signal:t}={}){throw new Error("request is not implemented")}}class we extends me{constructor(e){super(),this.response=e}get status(){return this.response.status}getHeader(e){return this.response.headers.get(e)}async getData(){const e=this.response.arrayBuffer?await this.response.arrayBuffer():(await this.response.buffer()).buffer;return e}}class Se extends ye{constructor(e,t){super(e),this.credentials=t}async request({headers:e,signal:t}={}){const i=await fetch(this.url,{headers:e,credentials:this.credentials,signal:t});return new we(i)}}class Te extends me{constructor(e,t){super(),this.xhr=e,this.data=t}get status(){return this.xhr.status}getHeader(e){return this.xhr.getResponseHeader(e)}async getData(){return this.data}}class be extends ye{constructRequest(e,t){return new Promise((i,r)=>{const n=new XMLHttpRequest;n.open("GET",this.url),n.responseType="arraybuffer";for(const[t,s]of Object.entries(e))n.setRequestHeader(t,s);n.onload=()=>{const e=n.response;i(new Te(n,e))},n.onerror=r,n.onabort=()=>r(new ce("Request aborted")),n.send(),t&&(t.aborted&&n.abort(),t.addEventListener("abort",()=>n.abort()))})}async request({headers:e,signal:t}={}){const i=await this.constructRequest(e,t);return i}}var _e=i(2736),Ee=i(34043),Ie=i(62611),Ae=i(48287)["Buffer"];class Ce extends me{constructor(e,t){super(),this.response=e,this.dataPromise=t}get status(){return this.response.statusCode}getHeader(e){return this.response.headers[e]}async getData(){const e=await this.dataPromise;return e}}class Pe extends ye{constructor(e){super(e),this.parsedUrl=Ie.parse(this.url),this.httpApi="http:"===this.parsedUrl.protocol?_e:Ee}constructRequest(e,t){return new Promise((i,r)=>{const n=this.httpApi.get({...this.parsedUrl,headers:e},e=>{const t=new Promise(t=>{const i=[];e.on("data",e=>{i.push(e)}),e.on("end",()=>{const e=Ae.concat(i).buffer;t(e)}),e.on("error",r)});i(new Ce(e,t))});n.on("error",r),t&&(t.aborted&&n.destroy(new ce("Request aborted")),t.addEventListener("abort",()=>n.destroy(new ce("Request aborted"))))})}async request({headers:e,signal:t}={}){const i=await this.constructRequest(e,t);return i}}class Fe extends oe{constructor(e,t,i,r){super(),this.client=e,this.headers=t,this.maxRanges=i,this.allowFullFile=r,this._fileSize=null}async fetch(e,t){return this.maxRanges>=e.length?this.fetchSlices(e,t):(this.maxRanges>0&&e.length,Promise.all(e.map(e=>this.fetchSlice(e,t))))}async fetchSlices(e,t){const i=await this.client.request({headers:{...this.headers,Range:`bytes=${e.map(({offset:e,length:t})=>`${e}-${e+t}`).join(",")}`},signal:t});if(i.ok){if(206===i.status){const{type:r,params:n}=re(i.getHeader("content-type"));if("multipart/byteranges"===r){const e=se(await i.getData(),n.boundary);return this._fileSize=e[0].fileSize||null,e}const s=await i.getData(),{start:o,end:a,total:l}=ne(i.getHeader("content-range"));this._fileSize=l||null;const h=[{data:s,offset:o,length:a-o}];if(e.length>1){const i=await Promise.all(e.slice(1).map(e=>this.fetchSlice(e,t)));return h.concat(i)}return h}{if(!this.allowFullFile)throw new Error("Server responded with full file");const e=await i.getData();return this._fileSize=e.byteLength,[{data:e,offset:0,length:e.byteLength}]}}throw new Error("Error fetching data.")}async fetchSlice(e,t){const{offset:i,length:r}=e,n=await this.client.request({headers:{...this.headers,Range:`bytes=${i}-${i+r}`},signal:t});if(n.ok){if(206===n.status){const e=await n.getData(),{total:t}=ne(n.getHeader("content-range"));return this._fileSize=t||null,{data:e,offset:i,length:r}}{if(!this.allowFullFile)throw new Error("Server responded with full file");const e=await n.getData();return this._fileSize=e.byteLength,{data:e,offset:0,length:e.byteLength}}}throw new Error("Error fetching data.")}get fileSize(){return this._fileSize}}function De(e,{blockSize:t,cacheSize:i}){return null===t?e:new pe(e,{blockSize:t,cacheSize:i})}function Re(e,{headers:t={},credentials:i,maxRanges:r=0,allowFullFile:n=!1,...s}={}){const o=new Se(e,i),a=new Fe(o,t,r,n);return De(a,s)}function xe(e,{headers:t={},maxRanges:i=0,allowFullFile:r=!1,...n}={}){const s=new be(e),o=new Fe(s,t,i,r);return De(o,n)}function Me(e,{headers:t={},maxRanges:i=0,allowFullFile:r=!1,...n}={}){const s=new Pe(e),o=new Fe(s,t,i,r);return De(o,n)}function ve(e,{forceXHR:t=!1,...i}={}){return"function"!==typeof fetch||t?"undefined"!==typeof XMLHttpRequest?xe(e,i):Me(e,i):Re(e,i)}class Ge extends oe{constructor(e){super(),this.file=e}async fetchSlice(e,t){return new Promise((i,r)=>{const n=this.file.slice(e.offset,e.offset+e.length),s=new FileReader;s.onload=e=>i(e.target.result),s.onerror=r,s.onabort=r,s.readAsArrayBuffer(n),t&&t.addEventListener("abort",()=>s.abort())})}}function Oe(e){return new Ge(e)}function ke(e){switch(e){case S.s$.BYTE:case S.s$.ASCII:case S.s$.SBYTE:case S.s$.UNDEFINED:return 1;case S.s$.SHORT:case S.s$.SSHORT:return 2;case S.s$.LONG:case S.s$.SLONG:case S.s$.FLOAT:case S.s$.IFD:return 4;case S.s$.RATIONAL:case S.s$.SRATIONAL:case S.s$.DOUBLE:case S.s$.LONG8:case S.s$.SLONG8:case S.s$.IFD8:return 8;default:throw new RangeError(`Invalid field type: ${e}`)}}function Ue(e){const t=e.GeoKeyDirectory;if(!t)return null;const i={};for(let r=4;r<=4*t[3];r+=4){const n=S.Hm[t[r]],s=t[r+1]?S.$[t[r+1]]:null,o=t[r+2],a=t[r+3];let l=null;if(s){if(l=e[s],"undefined"===typeof l||null===l)throw new Error(`Could not get value of geoKey '${n}'.`);"string"===typeof l?l=l.substring(a,a+o-1):l.subarray&&(l=l.subarray(a,a+o),1===o&&(l=l[0]))}else l=a;i[n]=l}return i}function Le(e,t,i,r){let n=null,s=null;const o=ke(t);switch(t){case S.s$.BYTE:case S.s$.ASCII:case S.s$.UNDEFINED:n=new Uint8Array(i),s=e.readUint8;break;case S.s$.SBYTE:n=new Int8Array(i),s=e.readInt8;break;case S.s$.SHORT:n=new Uint16Array(i),s=e.readUint16;break;case S.s$.SSHORT:n=new Int16Array(i),s=e.readInt16;break;case S.s$.LONG:case S.s$.IFD:n=new Uint32Array(i),s=e.readUint32;break;case S.s$.SLONG:n=new Int32Array(i),s=e.readInt32;break;case S.s$.LONG8:case S.s$.IFD8:n=new Array(i),s=e.readUint64;break;case S.s$.SLONG8:n=new Array(i),s=e.readInt64;break;case S.s$.RATIONAL:n=new Uint32Array(2*i),s=e.readUint32;break;case S.s$.SRATIONAL:n=new Int32Array(2*i),s=e.readInt32;break;case S.s$.FLOAT:n=new Float32Array(i),s=e.readFloat32;break;case S.s$.DOUBLE:n=new Float64Array(i),s=e.readFloat64;break;default:throw new RangeError(`Invalid field type: ${t}`)}if(t!==S.s$.RATIONAL&&t!==S.s$.SRATIONAL)for(let a=0;a<i;++a)n[a]=s.call(e,r+a*o);else for(let a=0;a<i;a+=2)n[a]=s.call(e,r+a*o),n[a+1]=s.call(e,r+(a*o+4));return t===S.s$.ASCII?new TextDecoder("utf-8").decode(n):n}class je{constructor(e,t,i){this.fileDirectory=e,this.geoKeyDirectory=t,this.nextIFDByteOffset=i}}class $e extends Error{constructor(e){super(`No image at index ${e}`),this.index=e}}class Ne{async readRasters(e={}){const{window:t,width:i,height:r}=e;let{resX:n,resY:s,bbox:o}=e;const a=await this.getImage();let l=a;const h=await this.getImageCount(),c=a.getBoundingBox();if(t&&o)throw new Error('Both "bbox" and "window" passed.');if(i||r){if(t){const[e,i]=a.getOrigin(),[r,n]=a.getResolution();o=[e+t[0]*r,i+t[1]*n,e+t[2]*r,i+t[3]*n]}const e=o||c;if(i){if(n)throw new Error("Both width and resX passed");n=(e[2]-e[0])/i}if(r){if(s)throw new Error("Both width and resY passed");s=(e[3]-e[1])/r}}if(n||s){const e=[];for(let t=0;t<h;++t){const i=await this.getImage(t),{SubfileType:r,NewSubfileType:n}=i.fileDirectory;(0===t||2===r||1&n)&&e.push(i)}e.sort((e,t)=>e.getWidth()-t.getWidth());for(let t=0;t<e.length;++t){const i=e[t],r=(c[2]-c[0])/i.getWidth(),o=(c[3]-c[1])/i.getHeight();if(l=i,n&&n>r||s&&s>o)break}}let u=t;if(o){const[e,t]=a.getOrigin(),[i,r]=l.getResolution(a);u=[Math.round((o[0]-e)/i),Math.round((o[1]-t)/r),Math.round((o[2]-e)/i),Math.round((o[3]-t)/r)],u=[Math.min(u[0],u[2]),Math.min(u[1],u[3]),Math.max(u[0],u[2]),Math.max(u[1],u[3])]}return l.readRasters({...e,window:u})}}class ze extends Ne{constructor(e,t,i,r,n={}){super(),this.source=e,this.littleEndian=t,this.bigTiff=i,this.firstIFDOffset=r,this.cache=n.cache||!1,this.ifdRequests=[],this.ghostValues=null}async getSlice(e,t){const i=this.bigTiff?4048:1024;return new Q((await this.source.fetch([{offset:e,length:"undefined"!==typeof t?t:i}]))[0],e,this.littleEndian,this.bigTiff)}async parseFileDirectoryAt(e){const t=this.bigTiff?20:12,i=this.bigTiff?8:2;let r=await this.getSlice(e);const n=this.bigTiff?r.readUint64(e):r.readUint16(e),s=n*t+(this.bigTiff?16:6);r.covers(e,s)||(r=await this.getSlice(e,s));const o={};let a=e+(this.bigTiff?8:2);for(let c=0;c<n;a+=t,++c){const e=r.readUint16(a),t=r.readUint16(a+2),i=this.bigTiff?r.readUint64(a+4):r.readUint32(a+4);let n,s;const l=ke(t),h=a+(this.bigTiff?12:8);if(l*i<=(this.bigTiff?8:4))n=Le(r,t,i,h);else{const e=r.readOffset(h),s=ke(t)*i;if(r.covers(e,s))n=Le(r,t,i,e);else{const r=await this.getSlice(e,s);n=Le(r,t,i,e)}}s=1===i&&-1===S.NZ.indexOf(e)&&t!==S.s$.RATIONAL&&t!==S.s$.SRATIONAL?n[0]:n,o[S.$[e]]=s}const l=Ue(o),h=r.readOffset(e+i+t*n);return new je(o,l,h)}async requestIFD(e){if(this.ifdRequests[e])return this.ifdRequests[e];if(0===e)return this.ifdRequests[e]=this.parseFileDirectoryAt(this.firstIFDOffset),this.ifdRequests[e];if(!this.ifdRequests[e-1])try{this.ifdRequests[e-1]=this.requestIFD(e-1)}catch(t){if(t instanceof $e)throw new $e(e);throw t}return this.ifdRequests[e]=(async()=>{const t=await this.ifdRequests[e-1];if(0===t.nextIFDByteOffset)throw new $e(e);return this.parseFileDirectoryAt(t.nextIFDByteOffset)})(),this.ifdRequests[e]}async getImage(e=0){const t=await this.requestIFD(e);return new Z(t.fileDirectory,t.geoKeyDirectory,this.dataView,this.littleEndian,this.cache,this.source)}async getImageCount(){let e=0,t=!0;while(t)try{await this.requestIFD(e),++e}catch(i){if(!(i instanceof $e))throw i;t=!1}return e}async getGhostValues(){const e=this.bigTiff?16:8;if(this.ghostValues)return this.ghostValues;const t="GDAL_STRUCTURAL_METADATA_SIZE=",i=t.length+100;let r=await this.getSlice(e,i);if(t===Le(r,S.s$.ASCII,t.length,e)){const t=Le(r,S.s$.ASCII,i,e),n=t.split("\n")[0],s=Number(n.split("=")[1].split(" ")[0])+n.length;s>i&&(r=await this.getSlice(e,s));const o=Le(r,S.s$.ASCII,s,e);this.ghostValues={},o.split("\n").filter(e=>e.length>0).map(e=>e.split("=")).forEach(([e,t])=>{this.ghostValues[e]=t})}return this.ghostValues}static async fromSource(e,t,i){const r=(await e.fetch([{offset:0,length:1024}],i))[0],n=new J(r),s=n.getUint16(0,0);let o;if(18761===s)o=!0;else{if(19789!==s)throw new TypeError("Invalid byte order value.");o=!1}const a=n.getUint16(2,o);let l;if(42===a)l=!1;else{if(43!==a)throw new TypeError("Invalid magic number.");{l=!0;const e=n.getUint16(4,o);if(8!==e)throw new Error("Unsupported offset byte-size.")}}const h=l?n.getUint64(8,o):n.getUint32(4,o);return new ze(e,o,l,h,t)}close(){return"function"===typeof this.source.close&&this.source.close()}}class Ke extends Ne{constructor(e,t){super(),this.mainFile=e,this.overviewFiles=t,this.imageFiles=[e].concat(t),this.fileDirectoriesPerFile=null,this.fileDirectoriesPerFileParsing=null,this.imageCount=null}async parseFileDirectoriesPerFile(){const e=[this.mainFile.parseFileDirectoryAt(this.mainFile.firstIFDOffset)].concat(this.overviewFiles.map(e=>e.parseFileDirectoryAt(e.firstIFDOffset)));return this.fileDirectoriesPerFile=await Promise.all(e),this.fileDirectoriesPerFile}async getImage(e=0){await this.getImageCount(),await this.parseFileDirectoriesPerFile();let t=0,i=0;for(let r=0;r<this.imageFiles.length;r++){const n=this.imageFiles[r];for(let s=0;s<this.imageCounts[r];s++){if(e===t){const e=await n.requestIFD(i);return new Z(e.fileDirectory,e.geoKeyDirectory,n.dataView,n.littleEndian,n.cache,n.source)}t++,i++}i=0}throw new RangeError("Invalid image index")}async getImageCount(){if(null!==this.imageCount)return this.imageCount;const e=[this.mainFile.getImageCount()].concat(this.overviewFiles.map(e=>e.getImageCount()));return this.imageCounts=await Promise.all(e),this.imageCount=this.imageCounts.reduce((e,t)=>e+t,0),this.imageCount}}async function Be(e,t={},i){return ze.fromSource(ve(e,t),i)}async function Ve(e,t){return ze.fromSource(Oe(e),t)}async function qe(e,t=[],i={},r){const n=await ze.fromSource(ve(e,i),r),s=await Promise.all(t.map(e=>ze.fromSource(ve(e,i))));return new Ke(n,s)}var He=i(61597),Xe=i(70915),We=i(54422),Ye=i(8100);function Ze(e){const t=e.fileDirectory,i=t.NewSubfileType||0;return 4===(4&i)}function Je(e,t){if(!e)return!1;if(!0===e)return!0;if(3!==t.getSamplesPerPixel())return!1;const i=t.fileDirectory.PhotometricInterpretation,r=S.ub;return i===r.CMYK||i===r.YCbCr||i===r.CIELab||i===r.ICCLab}const Qe="STATISTICS_MAXIMUM",et="STATISTICS_MINIMUM",tt=256;let it;function rt(){return it||(it=new A),it}function nt(e){try{return e.getBoundingBox()}catch(t){return[0,0,e.getWidth(),e.getHeight()]}}function st(e){try{return e.getOrigin().slice(0,2)}catch(t){return[0,e.getHeight()]}}function ot(e,t){try{return e.getResolution(t)}catch(i){return[t.getWidth()/e.getWidth(),t.getHeight()/e.getHeight()]}}function at(e){const t=e.geoKeys;if(!t)return null;if(t.ProjectedCSTypeGeoKey&&32767!==t.ProjectedCSTypeGeoKey){const e="EPSG:"+t.ProjectedCSTypeGeoKey;let i=(0,u.get)(e);if(!i){const r=(0,Ye.q)(t.ProjLinearUnitsGeoKey);r&&(i=new u.Projection({code:e,units:r}))}return i}if(t.GeographicTypeGeoKey&&32767!==t.GeographicTypeGeoKey){const e="EPSG:"+t.GeographicTypeGeoKey;let i=(0,u.get)(e);if(!i){const r=(0,Ye.q)(t.GeogAngularUnitsGeoKey);r&&(i=new u.Projection({code:e,units:r}))}return i}return null}function lt(e){return e.getImageCount().then(function(t){const i=new Array(t);for(let r=0;r<t;++r)i[r]=e.getImage(r);return Promise.all(i)})}function ht(e,t){let i;return i=e.blob?Ve(e.blob):e.overviews?qe(e.url,e.overviews,t):Be(e.url,t),i.then(lt)}function ct(e,t,i,r,n){if(Array.isArray(e)){const s=e.length;if(!Array.isArray(t)||s!=t.length){const e=new Error(r);throw n(e),e}for(let o=0;o<s;++o)ct(e[o],t[o],i,r,n);return}if(Math.abs(e-t)>i*e)throw new Error(r)}function ut(e){return e instanceof Int8Array?-128:e instanceof Int16Array?-32768:e instanceof Int32Array?-2147483648:e instanceof Float32Array?12e-39:0}function ft(e){return e instanceof Int8Array?127:e instanceof Uint8Array||e instanceof Uint8ClampedArray?255:e instanceof Int16Array?32767:e instanceof Uint16Array?65535:e instanceof Int32Array?2147483647:e instanceof Uint32Array?4294967295:e instanceof Float32Array?34e37:255}class gt extends y{constructor(e){super({state:"loading",tileGrid:null,projection:e.projection||null,opaque:e.opaque,transition:e.transition,interpolate:!1!==e.interpolate,wrapX:e.wrapX}),this.sourceInfo_=e.sources;const t=this.sourceInfo_.length;this.sourceOptions_=e.sourceOptions,this.sourceImagery_=new Array(t),this.sourceMasks_=new Array(t),this.resolutionFactors_=new Array(t),this.samplesPerPixel_,this.nodataValues_,this.metadata_,this.normalize_=!1!==e.normalize,this.addAlpha_=!1,this.error_=null,this.convertToRGB_=e.convertToRGB||!1,this.setKey(this.sourceInfo_.map(e=>e.url).join(","));const i=this,r=new Array(t);for(let n=0;n<t;++n)r[n]=ht(this.sourceInfo_[n],this.sourceOptions_);Promise.all(r).then(function(e){i.configure_(e)}).catch(function(e){(0,We.z3)(e),i.error_=e,i.setState("error")})}getError(){return this.error_}determineProjection(e){const t=e[0];for(let i=t.length-1;i>=0;--i){const e=t[i],r=at(e);if(r){this.projection=r;break}}}configure_(e){let t,i,r,n,s;const o=new Array(e.length),a=new Array(e.length),l=new Array(e.length);let h=0;const c=e.length;for(let u=0;u<c;++u){const c=[],f=[];e[u].forEach(e=>{Ze(e)?f.push(e):c.push(e)});const g=c.length;if(f.length>0&&f.length!==g)throw new Error(`Expected one mask per image found ${f.length} masks and ${g} images`);let d,p;const m=new Array(g),y=new Array(g),w=new Array(g);a[u]=new Array(g),l[u]=new Array(g);for(let e=0;e<g;++e){const t=c[e],i=t.getGDALNoData();l[u][e]=t.getGDALMetadata(0),a[u][e]=i;const r=this.sourceInfo_[u].bands;o[u]=r?r.length:t.getSamplesPerPixel();const n=g-(e+1);d||(d=nt(t)),p||(p=st(t));const s=ot(t,c[0]);w[n]=s[0];const h=[t.getTileWidth(),t.getTileHeight()];h[0]!==h[1]&&h[1]<tt&&(h[0]=tt,h[1]=tt),m[n]=h;const f=s[0]/Math.abs(s[1]);y[n]=[h[0],h[1]/f]}if(t?(0,Xe._N)(t,d,t):t=d,i){const e=`Origin mismatch for source ${u}, got [${p}] but expected [${i}]`;ct(i,p,0,e,this.viewRejector)}else i=p;if(s){s.length-h>w.length&&(h=s.length-w.length);const e=s[s.length-1]/w[w.length-1];this.resolutionFactors_[u]=e;const t=w.map(t=>t*e),i=`Resolution mismatch for source ${u}, got [${t}] but expected [${s}]`;ct(s.slice(h,s.length),t,.02,i,this.viewRejector)}else s=w,this.resolutionFactors_[u]=1;r?ct(r.slice(h,r.length),y,.01,`Tile size mismatch for source ${u}`,this.viewRejector):r=y,n?ct(n.slice(h,n.length),m,0,`Tile size mismatch for source ${u}`,this.viewRejector):n=m,this.sourceImagery_[u]=c.reverse(),this.sourceMasks_[u]=f.reverse()}for(let u=0,p=this.sourceImagery_.length;u<p;++u){const e=this.sourceImagery_[u];while(e.length<s.length)e.unshift(void 0)}this.getProjection()||this.determineProjection(e),this.samplesPerPixel_=o,this.nodataValues_=a,this.metadata_=l;e:for(let u=0;u<c;++u){if(void 0!==this.sourceInfo_[u].nodata){this.addAlpha_=!0;break}if(this.sourceMasks_[u].length){this.addAlpha_=!0;break}const e=a[u],t=this.sourceInfo_[u].bands;if(t){for(let i=0;i<t.length;++i)if(null!==e[t[i]-1]){this.addAlpha_=!0;break e}}else for(let i=0;i<e.length;++i)if(null!==e[i]){this.addAlpha_=!0;break e}}let f=this.addAlpha_?1:0;for(let u=0;u<c;++u)f+=o[u];this.bandCount=f;const g=new w.A({extent:t,minZoom:h,origin:i,resolutions:s,tileSizes:r});this.tileGrid=g,this.setTileSizes(n),this.setLoader(this.loadTile_.bind(this)),this.setState("ready");const d=1;2===s.length?s=[s[0],s[1],s[1]/2]:1===s.length&&(s=[2*s[0],s[0],s[0]/2]),this.viewResolver({showFullExtent:!0,projection:this.projection,resolutions:s,center:(0,u.toUserCoordinate)((0,Xe.q1)(t),this.projection),extent:(0,u.toUserExtent)(t,this.projection),zoom:d})}loadTile_(e,t,i){const r=this.getTileSize(e),n=this.sourceImagery_.length,s=new Array(2*n),o=this.nodataValues_,a=this.sourceInfo_,l=rt();for(let h=0;h<n;++h){const c=a[h],u=this.resolutionFactors_[h],f=[Math.round(t*(r[0]*u)),Math.round(i*(r[1]*u)),Math.round((t+1)*(r[0]*u)),Math.round((i+1)*(r[1]*u))],g=this.sourceImagery_[h][e];let d,p;c.bands&&(d=c.bands.map(function(e){return e-1})),p="nodata"in c&&null!==c.nodata?c.nodata:d?d.map(function(e){return o[h][e]}):o[h];const m={window:f,width:r[0],height:r[1],samples:d,fillValue:p,pool:l,interleave:!1};Je(this.convertToRGB_,g)?s[h]=g.readRGB(m):s[h]=g.readRasters(m);const y=n+h,w=this.sourceMasks_[h][e];w?s[y]=w.readRasters({window:f,width:r[0],height:r[1],samples:[0],pool:l,interleave:!1}):s[y]=Promise.resolve(null)}return Promise.all(s).then(this.composeTile_.bind(this,r)).catch(function(e){throw(0,We.z3)(e),e})}composeTile_(e,t){const i=this.metadata_,r=this.sourceInfo_,n=this.sourceImagery_.length,s=this.bandCount,o=this.samplesPerPixel_,a=this.nodataValues_,l=this.normalize_,h=this.addAlpha_,c=e[0]*e[1],u=c*s;let f;f=l?new Uint8Array(u):new Float32Array(u);let g=0;for(let d=0;d<c;++d){let e=h;for(let s=0;s<n;++s){const c=r[s];let u,p,m=c.min,y=c.max;if(l){const e=i[s][0];void 0===m&&(m=e&&et in e?parseFloat(e[et]):ut(t[s][0])),void 0===y&&(y=e&&Qe in e?parseFloat(e[Qe]):ft(t[s][0])),u=255/(y-m),p=-m*u}for(let i=0;i<o[s];++i){const r=t[s][i][d];let n;if(n=l?(0,He.qE)(u*r+p,0,255):r,h){let t=c.nodata;if(void 0===t){let e;e=c.bands?c.bands[i]-1:i,t=a[s][e]}const o=isNaN(t);(!o&&r!==t||o&&!isNaN(r))&&(e=!1,f[g]=n)}else f[g]=n;g++}if(!e){const i=n+s,r=t[i];r&&!r[0][d]&&(e=!0)}}h&&(e||(f[g]=255),g++)}return f}}gt.prototype.getView;const dt=gt},86895:(e,t,i)=>{i.d(t,{$:()=>r,AC:()=>h,Hm:()=>f,NZ:()=>s,S3:()=>u,TZ:()=>c,s$:()=>a,ub:()=>l});const r={315:"Artist",258:"BitsPerSample",265:"CellLength",264:"CellWidth",320:"ColorMap",259:"Compression",33432:"Copyright",306:"DateTime",338:"ExtraSamples",266:"FillOrder",289:"FreeByteCounts",288:"FreeOffsets",291:"GrayResponseCurve",290:"GrayResponseUnit",316:"HostComputer",270:"ImageDescription",257:"ImageLength",256:"ImageWidth",271:"Make",281:"MaxSampleValue",280:"MinSampleValue",272:"Model",254:"NewSubfileType",274:"Orientation",262:"PhotometricInterpretation",284:"PlanarConfiguration",296:"ResolutionUnit",278:"RowsPerStrip",277:"SamplesPerPixel",305:"Software",279:"StripByteCounts",273:"StripOffsets",255:"SubfileType",263:"Threshholding",282:"XResolution",283:"YResolution",326:"BadFaxLines",327:"CleanFaxData",343:"ClipPath",328:"ConsecutiveBadFaxLines",433:"Decode",434:"DefaultImageColor",269:"DocumentName",336:"DotRange",321:"HalftoneHints",346:"Indexed",347:"JPEGTables",285:"PageName",297:"PageNumber",317:"Predictor",319:"PrimaryChromaticities",532:"ReferenceBlackWhite",339:"SampleFormat",340:"SMinSampleValue",341:"SMaxSampleValue",559:"StripRowCounts",330:"SubIFDs",292:"T4Options",293:"T6Options",325:"TileByteCounts",323:"TileLength",324:"TileOffsets",322:"TileWidth",301:"TransferFunction",318:"WhitePoint",344:"XClipPathUnits",286:"XPosition",529:"YCbCrCoefficients",531:"YCbCrPositioning",530:"YCbCrSubSampling",345:"YClipPathUnits",287:"YPosition",37378:"ApertureValue",40961:"ColorSpace",36868:"DateTimeDigitized",36867:"DateTimeOriginal",34665:"Exif IFD",36864:"ExifVersion",33434:"ExposureTime",41728:"FileSource",37385:"Flash",40960:"FlashpixVersion",33437:"FNumber",42016:"ImageUniqueID",37384:"LightSource",37500:"MakerNote",37377:"ShutterSpeedValue",37510:"UserComment",33723:"IPTC",34675:"ICC Profile",700:"XMP",42112:"GDAL_METADATA",42113:"GDAL_NODATA",34377:"Photoshop",33550:"ModelPixelScale",33922:"ModelTiepoint",34264:"ModelTransformation",34735:"GeoKeyDirectory",34736:"GeoDoubleParams",34737:"GeoAsciiParams",50674:"LercParameters"},n={};for(const d in r)r.hasOwnProperty(d)&&(n[r[d]]=parseInt(d,10));const s=[n.BitsPerSample,n.ExtraSamples,n.SampleFormat,n.StripByteCounts,n.StripOffsets,n.StripRowCounts,n.TileByteCounts,n.TileOffsets,n.SubIFDs],o={1:"BYTE",2:"ASCII",3:"SHORT",4:"LONG",5:"RATIONAL",6:"SBYTE",7:"UNDEFINED",8:"SSHORT",9:"SLONG",10:"SRATIONAL",11:"FLOAT",12:"DOUBLE",13:"IFD",16:"LONG8",17:"SLONG8",18:"IFD8"},a={};for(const d in o)o.hasOwnProperty(d)&&(a[o[d]]=parseInt(d,10));const l={WhiteIsZero:0,BlackIsZero:1,RGB:2,Palette:3,TransparencyMask:4,CMYK:5,YCbCr:6,CIELab:8,ICCLab:9},h={Unspecified:0,Assocalpha:1,Unassalpha:2},c={Version:0,AddCompression:1},u={None:0,Deflate:1,Zstandard:2},f={1024:"GTModelTypeGeoKey",1025:"GTRasterTypeGeoKey",1026:"GTCitationGeoKey",2048:"GeographicTypeGeoKey",2049:"GeogCitationGeoKey",2050:"GeogGeodeticDatumGeoKey",2051:"GeogPrimeMeridianGeoKey",2052:"GeogLinearUnitsGeoKey",2053:"GeogLinearUnitSizeGeoKey",2054:"GeogAngularUnitsGeoKey",2055:"GeogAngularUnitSizeGeoKey",2056:"GeogEllipsoidGeoKey",2057:"GeogSemiMajorAxisGeoKey",2058:"GeogSemiMinorAxisGeoKey",2059:"GeogInvFlatteningGeoKey",2060:"GeogAzimuthUnitsGeoKey",2061:"GeogPrimeMeridianLongGeoKey",2062:"GeogTOWGS84GeoKey",3072:"ProjectedCSTypeGeoKey",3073:"PCSCitationGeoKey",3074:"ProjectionGeoKey",3075:"ProjCoordTransGeoKey",3076:"ProjLinearUnitsGeoKey",3077:"ProjLinearUnitSizeGeoKey",3078:"ProjStdParallel1GeoKey",3079:"ProjStdParallel2GeoKey",3080:"ProjNatOriginLongGeoKey",3081:"ProjNatOriginLatGeoKey",3082:"ProjFalseEastingGeoKey",3083:"ProjFalseNorthingGeoKey",3084:"ProjFalseOriginLongGeoKey",3085:"ProjFalseOriginLatGeoKey",3086:"ProjFalseOriginEastingGeoKey",3087:"ProjFalseOriginNorthingGeoKey",3088:"ProjCenterLongGeoKey",3089:"ProjCenterLatGeoKey",3090:"ProjCenterEastingGeoKey",3091:"ProjCenterNorthingGeoKey",3092:"ProjScaleAtNatOriginGeoKey",3093:"ProjScaleAtCenterGeoKey",3094:"ProjAzimuthAngleGeoKey",3095:"ProjStraightVertPoleLongGeoKey",3096:"ProjRectifiedGridAngleGeoKey",4096:"VerticalCSTypeGeoKey",4097:"VerticalCitationGeoKey",4098:"VerticalDatumGeoKey",4099:"VerticalUnitsGeoKey"},g={};for(const d in f)f.hasOwnProperty(d)&&(g[f[d]]=parseInt(d,10))}}]);
//# sourceMappingURL=1817.878772c5.js.map
{"version":3,"file":"js/chunk-vendors-be93acbf.44be9276.js","mappings":"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","sources":["webpack://@openeo/web-editor/./node_modules/path-browserify/index.js","webpack://@openeo/web-editor/./node_modules/@petamoriken/float16/src/_util/messages.mjs","webpack://@openeo/web-editor/./node_modules/@petamoriken/float16/src/_util/primordials.mjs","webpack://@openeo/web-editor/./node_modules/@petamoriken/float16/src/_util/arrayIterator.mjs","webpack://@openeo/web-editor/./node_modules/@petamoriken/float16/src/_util/converter.mjs","webpack://@openeo/web-editor/./node_modules/@petamoriken/float16/src/DataView.mjs"],"sourcesContent":["// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          if (!matchedSlash) {\n            end = i;\n            break;\n          }\n        } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1)\n            startDot = i;\n          else if (preDotState !== 1)\n            preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n","export const THIS_IS_NOT_AN_OBJECT = \"This is not an object\";\nexport const THIS_IS_NOT_A_FLOAT16ARRAY_OBJECT = \"This is not a Float16Array object\";\nexport const THIS_CONSTRUCTOR_IS_NOT_A_SUBCLASS_OF_FLOAT16ARRAY =\n  \"This constructor is not a subclass of Float16Array\";\nexport const THE_CONSTRUCTOR_PROPERTY_VALUE_IS_NOT_AN_OBJECT =\n  \"The constructor property value is not an object\";\nexport const SPECIES_CONSTRUCTOR_DIDNT_RETURN_TYPEDARRAY_OBJECT =\n  \"Species constructor didn't return TypedArray object\";\nexport const DERIVED_CONSTRUCTOR_CREATED_TYPEDARRAY_OBJECT_WHICH_WAS_TOO_SMALL_LENGTH =\n  \"Derived constructor created TypedArray object which was too small length\";\nexport const ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER =\n  \"Attempting to access detached ArrayBuffer\";\nexport const CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT =\n  \"Cannot convert undefined or null to object\";\nexport const CANNOT_MIX_BIGINT_AND_OTHER_TYPES =\n  \"Cannot mix BigInt and other types, use explicit conversions\";\nexport const ITERATOR_PROPERTY_IS_NOT_CALLABLE = \"@@iterator property is not callable\";\nexport const REDUCE_OF_EMPTY_ARRAY_WITH_NO_INITIAL_VALUE =\n  \"Reduce of empty array with no initial value\";\nexport const THE_COMPARISON_FUNCTION_MUST_BE_EITHER_A_FUNCTION_OR_UNDEFINED =\n  \"The comparison function must be either a function or undefined\";\nexport const OFFSET_IS_OUT_OF_BOUNDS = \"Offset is out of bounds\";\n","/* eslint-disable no-restricted-globals, no-restricted-syntax */\n/* global SharedArrayBuffer */\n\nimport { CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT } from \"./messages.mjs\";\n\n/** @type {<T extends (...args: any) => any>(target: T) => (thisArg: ThisType<T>, ...args: any[]) => any} */\nfunction uncurryThis(target) {\n  return (thisArg, ...args) => {\n    return ReflectApply(target, thisArg, args);\n  };\n}\n\n/** @type {(target: any, key: string | symbol) => (thisArg: any, ...args: any[]) => any} */\nfunction uncurryThisGetter(target, key) {\n  return uncurryThis(\n    ReflectGetOwnPropertyDescriptor(\n      target,\n      key\n    ).get\n  );\n}\n\n// Reflect\nexport const {\n  apply: ReflectApply,\n  construct: ReflectConstruct,\n  defineProperty: ReflectDefineProperty,\n  get: ReflectGet,\n  getOwnPropertyDescriptor: ReflectGetOwnPropertyDescriptor,\n  getPrototypeOf: ReflectGetPrototypeOf,\n  has: ReflectHas,\n  ownKeys: ReflectOwnKeys,\n  set: ReflectSet,\n  setPrototypeOf: ReflectSetPrototypeOf,\n} = Reflect;\n\n// Proxy\nexport const NativeProxy = Proxy;\n\n// Number\nexport const {\n  EPSILON,\n  MAX_SAFE_INTEGER,\n  isFinite: NumberIsFinite,\n  isNaN: NumberIsNaN,\n} = Number;\n\n// Symbol\nexport const {\n  iterator: SymbolIterator,\n  species: SymbolSpecies,\n  toStringTag: SymbolToStringTag,\n  for: SymbolFor,\n} = Symbol;\n\n// Object\nexport const NativeObject = Object;\nexport const {\n  create: ObjectCreate,\n  defineProperty: ObjectDefineProperty,\n  freeze: ObjectFreeze,\n  is: ObjectIs,\n} = NativeObject;\nconst ObjectPrototype = NativeObject.prototype;\n/** @type {(object: object, key: PropertyKey) => Function | undefined} */\nexport const ObjectPrototype__lookupGetter__ = /** @type {any} */ (ObjectPrototype).__lookupGetter__\n  ? uncurryThis(/** @type {any} */ (ObjectPrototype).__lookupGetter__)\n  : (object, key) => {\n    if (object == null) {\n      throw NativeTypeError(\n        CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT\n      );\n    }\n\n    let target = NativeObject(object);\n    do {\n      const descriptor = ReflectGetOwnPropertyDescriptor(target, key);\n      if (descriptor !== undefined) {\n        if (ObjectHasOwn(descriptor, \"get\")) {\n          return descriptor.get;\n        }\n\n        return;\n      }\n    } while ((target = ReflectGetPrototypeOf(target)) !== null);\n  };\n/** @type {(object: object, key: PropertyKey) => boolean} */\nexport const ObjectHasOwn = /** @type {any} */ (NativeObject).hasOwn ||\n  uncurryThis(ObjectPrototype.hasOwnProperty);\n\n// Array\nconst NativeArray = Array;\nexport const ArrayIsArray = NativeArray.isArray;\nconst ArrayPrototype = NativeArray.prototype;\n/** @type {(array: ArrayLike<unknown>, separator?: string) => string} */\nexport const ArrayPrototypeJoin = uncurryThis(ArrayPrototype.join);\n/** @type {<T>(array: T[], ...items: T[]) => number} */\nexport const ArrayPrototypePush = uncurryThis(ArrayPrototype.push);\n/** @type {(array: ArrayLike<unknown>, ...opts: any[]) => string} */\nexport const ArrayPrototypeToLocaleString = uncurryThis(\n  ArrayPrototype.toLocaleString\n);\nexport const NativeArrayPrototypeSymbolIterator = ArrayPrototype[SymbolIterator];\n/** @type {<T>(array: T[]) => IterableIterator<T>} */\nexport const ArrayPrototypeSymbolIterator = uncurryThis(NativeArrayPrototypeSymbolIterator);\n\n// Math\nexport const {\n  abs: MathAbs,\n  trunc: MathTrunc,\n} = Math;\n\n// ArrayBuffer\nexport const NativeArrayBuffer = ArrayBuffer;\nexport const ArrayBufferIsView = NativeArrayBuffer.isView;\nconst ArrayBufferPrototype = NativeArrayBuffer.prototype;\n/** @type {(buffer: ArrayBuffer, begin?: number, end?: number) => number} */\nexport const ArrayBufferPrototypeSlice = uncurryThis(ArrayBufferPrototype.slice);\n/** @type {(buffer: ArrayBuffer) => ArrayBuffer} */\nexport const ArrayBufferPrototypeGetByteLength = uncurryThisGetter(ArrayBufferPrototype, \"byteLength\");\n\n// SharedArrayBuffer\nexport const NativeSharedArrayBuffer = typeof SharedArrayBuffer !== \"undefined\" ? SharedArrayBuffer : null;\n/** @type {(buffer: SharedArrayBuffer) => SharedArrayBuffer} */\nexport const SharedArrayBufferPrototypeGetByteLength = NativeSharedArrayBuffer\n  && uncurryThisGetter(NativeSharedArrayBuffer.prototype, \"byteLength\");\n\n// TypedArray\n/** @typedef {Uint8Array|Uint8ClampedArray|Uint16Array|Uint32Array|Int8Array|Int16Array|Int32Array|Float32Array|Float64Array|BigUint64Array|BigInt64Array} TypedArray */\n/** @type {any} */\nexport const TypedArray = ReflectGetPrototypeOf(Uint8Array);\nconst TypedArrayFrom = TypedArray.from;\nexport const TypedArrayPrototype = TypedArray.prototype;\nexport const NativeTypedArrayPrototypeSymbolIterator = TypedArrayPrototype[SymbolIterator];\n/** @type {(typedArray: TypedArray) => IterableIterator<number>} */\nexport const TypedArrayPrototypeKeys = uncurryThis(TypedArrayPrototype.keys);\n/** @type {(typedArray: TypedArray) => IterableIterator<number>} */\nexport const TypedArrayPrototypeValues = uncurryThis(\n  TypedArrayPrototype.values\n);\n/** @type {(typedArray: TypedArray) => IterableIterator<[number, number]>} */\nexport const TypedArrayPrototypeEntries = uncurryThis(\n  TypedArrayPrototype.entries\n);\n/** @type {(typedArray: TypedArray, array: ArrayLike<number>, offset?: number) => void} */\nexport const TypedArrayPrototypeSet = uncurryThis(TypedArrayPrototype.set);\n/** @type {<T extends TypedArray>(typedArray: T) => T} */\nexport const TypedArrayPrototypeReverse = uncurryThis(\n  TypedArrayPrototype.reverse\n);\n/** @type {<T extends TypedArray>(typedArray: T, value: number, start?: number, end?: number) => T} */\nexport const TypedArrayPrototypeFill = uncurryThis(TypedArrayPrototype.fill);\n/** @type {<T extends TypedArray>(typedArray: T, target: number, start: number, end?: number) => T} */\nexport const TypedArrayPrototypeCopyWithin = uncurryThis(\n  TypedArrayPrototype.copyWithin\n);\n/** @type {<T extends TypedArray>(typedArray: T, compareFn?: (a: number, b: number) => number) => T} */\nexport const TypedArrayPrototypeSort = uncurryThis(TypedArrayPrototype.sort);\n/** @type {<T extends TypedArray>(typedArray: T, start?: number, end?: number) => T} */\nexport const TypedArrayPrototypeSlice = uncurryThis(TypedArrayPrototype.slice);\n/** @type {<T extends TypedArray>(typedArray: T, start?: number, end?: number) => T} */\nexport const TypedArrayPrototypeSubarray = uncurryThis(\n  TypedArrayPrototype.subarray\n);\n/** @type {((typedArray: TypedArray) => ArrayBuffer)} */\nexport const TypedArrayPrototypeGetBuffer = uncurryThisGetter(\n  TypedArrayPrototype,\n  \"buffer\"\n);\n/** @type {((typedArray: TypedArray) => number)} */\nexport const TypedArrayPrototypeGetByteOffset = uncurryThisGetter(\n  TypedArrayPrototype,\n  \"byteOffset\"\n);\n/** @type {((typedArray: TypedArray) => number)} */\nexport const TypedArrayPrototypeGetLength = uncurryThisGetter(\n  TypedArrayPrototype,\n  \"length\"\n);\n/** @type {(target: unknown) => string} */\nexport const TypedArrayPrototypeGetSymbolToStringTag = uncurryThisGetter(\n  TypedArrayPrototype,\n  SymbolToStringTag\n);\n\n// Uint8Array\nexport const NativeUint8Array = Uint8Array;\n\n// Uint16Array\nexport const NativeUint16Array = Uint16Array;\n/** @type {Uint16ArrayConstructor[\"from\"]} */\nexport const Uint16ArrayFrom = (...args) => {\n  return ReflectApply(TypedArrayFrom, NativeUint16Array, args);\n};\n\n// Uint32Array\nexport const NativeUint32Array = Uint32Array;\n\n// Float32Array\nexport const NativeFloat32Array = Float32Array;\n\n// ArrayIterator\n/** @type {any} */\nexport const ArrayIteratorPrototype = ReflectGetPrototypeOf([][SymbolIterator]());\n/** @type {<T>(arrayIterator: IterableIterator<T>) => IteratorResult<T>} */\nexport const ArrayIteratorPrototypeNext = uncurryThis(ArrayIteratorPrototype.next);\n\n// Generator\n/** @type {<T = unknown, TReturn = any, TNext = unknown>(generator: Generator<T, TReturn, TNext>, value?: TNext) => T} */\nexport const GeneratorPrototypeNext = uncurryThis((function* () {})().next);\n\n// Iterator\nexport const IteratorPrototype = ReflectGetPrototypeOf(ArrayIteratorPrototype);\n\n// DataView\nconst DataViewPrototype = DataView.prototype;\n/** @type {(dataView: DataView, byteOffset: number, littleEndian?: boolean) => number} */\nexport const DataViewPrototypeGetUint16 = uncurryThis(\n  DataViewPrototype.getUint16\n);\n/** @type {(dataView: DataView, byteOffset: number, value: number, littleEndian?: boolean) => void} */\nexport const DataViewPrototypeSetUint16 = uncurryThis(\n  DataViewPrototype.setUint16\n);\n\n// Error\nexport const NativeTypeError = TypeError;\nexport const NativeRangeError = RangeError;\n\n// WeakSet\n/**\n * Do not construct with arguments to avoid calling the \"add\" method\n * @type {{new <T extends {}>(): WeakSet<T>}}\n */\nexport const NativeWeakSet = WeakSet;\nconst WeakSetPrototype = NativeWeakSet.prototype;\n/** @type {<T extends {}>(set: WeakSet<T>, value: T) => Set<T>} */\nexport const WeakSetPrototypeAdd = uncurryThis(WeakSetPrototype.add);\n/** @type {<T extends {}>(set: WeakSet<T>, value: T) => boolean} */\nexport const WeakSetPrototypeHas = uncurryThis(WeakSetPrototype.has);\n\n// WeakMap\n/**\n * Do not construct with arguments to avoid calling the \"set\" method\n * @type {{new <K extends {}, V>(): WeakMap<K, V>}}\n */\nexport const NativeWeakMap = WeakMap;\nconst WeakMapPrototype = NativeWeakMap.prototype;\n/** @type {<K extends {}, V>(weakMap: WeakMap<K, V>, key: K) => V} */\nexport const WeakMapPrototypeGet = uncurryThis(WeakMapPrototype.get);\n/** @type {<K extends {}, V>(weakMap: WeakMap<K, V>, key: K) => boolean} */\nexport const WeakMapPrototypeHas = uncurryThis(WeakMapPrototype.has);\n/** @type {<K extends {}, V>(weakMap: WeakMap<K, V>, key: K, value: V) => WeakMap} */\nexport const WeakMapPrototypeSet = uncurryThis(WeakMapPrototype.set);\n","import {\n  ArrayIteratorPrototype,\n  ArrayIteratorPrototypeNext,\n  ArrayPrototypeSymbolIterator,\n  GeneratorPrototypeNext,\n  IteratorPrototype,\n  NativeArrayPrototypeSymbolIterator,\n  NativeWeakMap,\n  ObjectCreate,\n  ObjectDefineProperty,\n  ReflectGetOwnPropertyDescriptor,\n  ReflectOwnKeys,\n  SymbolIterator,\n  WeakMapPrototypeGet,\n  WeakMapPrototypeSet,\n} from \"./primordials.mjs\";\n\n/** @type {WeakMap<{}, IterableIterator<any>>} */\nconst arrayIterators = new NativeWeakMap();\n\nconst SafeIteratorPrototype = ObjectCreate(null, {\n  next: {\n    value: function next() {\n      const arrayIterator = WeakMapPrototypeGet(arrayIterators, this);\n      return ArrayIteratorPrototypeNext(arrayIterator);\n    },\n  },\n\n  [SymbolIterator]: {\n    value: function values() {\n      return this;\n    },\n  },\n});\n\n/**\n * Wrap the Array around the SafeIterator If Array.prototype [@@iterator] has been modified\n * @type {<T>(array: T[]) => Iterable<T>}\n */\nexport function safeIfNeeded(array) {\n  if (\n    array[SymbolIterator] === NativeArrayPrototypeSymbolIterator &&\n    ArrayIteratorPrototype.next === ArrayIteratorPrototypeNext\n  ) {\n    return array;\n  }\n\n  const safe = ObjectCreate(SafeIteratorPrototype);\n  WeakMapPrototypeSet(arrayIterators, safe, ArrayPrototypeSymbolIterator(array));\n  return safe;\n}\n\n/** @type {WeakMap<{}, Generator<any>>} */\nconst generators = new NativeWeakMap();\n\n/** @see https://tc39.es/ecma262/#sec-%arrayiteratorprototype%-object */\nconst DummyArrayIteratorPrototype = ObjectCreate(IteratorPrototype, {\n  next: {\n    value: function next() {\n      const generator = WeakMapPrototypeGet(generators, this);\n      return GeneratorPrototypeNext(generator);\n    },\n    writable: true,\n    configurable: true,\n  },\n});\n\nfor (const key of ReflectOwnKeys(ArrayIteratorPrototype)) {\n  // next method has already defined\n  if (key === \"next\") {\n    continue;\n  }\n\n  // Copy ArrayIteratorPrototype descriptors to DummyArrayIteratorPrototype\n  ObjectDefineProperty(DummyArrayIteratorPrototype, key, ReflectGetOwnPropertyDescriptor(ArrayIteratorPrototype, key));\n}\n\n/**\n * Wrap the Generator around the dummy ArrayIterator\n * @type {<T>(generator: Generator<T>) => IterableIterator<T>}\n */\nexport function wrap(generator) {\n  const dummy = ObjectCreate(DummyArrayIteratorPrototype);\n  WeakMapPrototypeSet(generators, dummy, generator);\n  return dummy;\n}\n","import {\n  EPSILON,\n  MathAbs,\n  NativeArrayBuffer,\n  NativeFloat32Array,\n  NativeUint16Array,\n  NativeUint32Array,\n  NativeUint8Array,\n  NumberIsFinite,\n  NumberIsNaN,\n} from \"./primordials.mjs\";\n\nconst INVERSE_OF_EPSILON = 1 / EPSILON;\n\n/**\n * rounds to the nearest value;\n * if the number falls midway, it is rounded to the nearest value with an even least significant digit\n * @param {number} num\n * @returns {number}\n */\nfunction roundTiesToEven(num) {\n  return (num + INVERSE_OF_EPSILON) - INVERSE_OF_EPSILON;\n}\n\nconst FLOAT16_MIN_VALUE = 6.103515625e-05;\nconst FLOAT16_MAX_VALUE = 65504;\nconst FLOAT16_EPSILON = 0.0009765625;\n\nconst FLOAT16_EPSILON_MULTIPLIED_BY_FLOAT16_MIN_VALUE = FLOAT16_EPSILON * FLOAT16_MIN_VALUE;\nconst FLOAT16_EPSILON_DEVIDED_BY_EPSILON = FLOAT16_EPSILON * INVERSE_OF_EPSILON;\n\n/**\n * round a number to a half float number\n * @param {unknown} num - double float\n * @returns {number} half float number\n */\nexport function roundToFloat16(num) {\n  const number = +num;\n\n  // NaN, Infinity, -Infinity, 0, -0\n  if (!NumberIsFinite(number) || number === 0) {\n    return number;\n  }\n\n  // finite except 0, -0\n  const sign = number > 0 ? 1 : -1;\n  const absolute = MathAbs(number);\n\n  // small number\n  if (absolute < FLOAT16_MIN_VALUE) {\n    return sign * roundTiesToEven(absolute / FLOAT16_EPSILON_MULTIPLIED_BY_FLOAT16_MIN_VALUE) * FLOAT16_EPSILON_MULTIPLIED_BY_FLOAT16_MIN_VALUE;\n  }\n\n  const temp = (1 + FLOAT16_EPSILON_DEVIDED_BY_EPSILON) * absolute;\n  const result = temp - (temp - absolute);\n\n  // large number\n  if (result > FLOAT16_MAX_VALUE || NumberIsNaN(result)) {\n    return sign * Infinity;\n  }\n\n  return sign * result;\n}\n\n// base algorithm: http://fox-toolkit.org/ftp/fasthalffloatconversion.pdf\n\nconst buffer = new NativeArrayBuffer(4);\nconst floatView = new NativeFloat32Array(buffer);\nconst uint32View = new NativeUint32Array(buffer);\n\nconst baseTable = new NativeUint16Array(512);\nconst shiftTable = new NativeUint8Array(512);\n\nfor (let i = 0; i < 256; ++i) {\n  const e = i - 127;\n\n  // very small number (0, -0)\n  if (e < -24) {\n    baseTable[i]         = 0x0000;\n    baseTable[i | 0x100] = 0x8000;\n    shiftTable[i]         = 24;\n    shiftTable[i | 0x100] = 24;\n\n  // small number (denorm)\n  } else if (e < -14) {\n    baseTable[i]         =  0x0400 >> (-e - 14);\n    baseTable[i | 0x100] = (0x0400 >> (-e - 14)) | 0x8000;\n    shiftTable[i]         = -e - 1;\n    shiftTable[i | 0x100] = -e - 1;\n\n  // normal number\n  } else if (e <= 15) {\n    baseTable[i]         =  (e + 15) << 10;\n    baseTable[i | 0x100] = ((e + 15) << 10) | 0x8000;\n    shiftTable[i]         = 13;\n    shiftTable[i | 0x100] = 13;\n\n  // large number (Infinity, -Infinity)\n  } else if (e < 128) {\n    baseTable[i]         = 0x7c00;\n    baseTable[i | 0x100] = 0xfc00;\n    shiftTable[i]         = 24;\n    shiftTable[i | 0x100] = 24;\n\n  // stay (NaN, Infinity, -Infinity)\n  } else {\n    baseTable[i]         = 0x7c00;\n    baseTable[i | 0x100] = 0xfc00;\n    shiftTable[i]         = 13;\n    shiftTable[i | 0x100] = 13;\n  }\n}\n\n/**\n * round a number to a half float number bits\n * @param {unknown} num - double float\n * @returns {number} half float number bits\n */\nexport function roundToFloat16Bits(num) {\n  floatView[0] = roundToFloat16(num);\n  const f = uint32View[0];\n  const e = (f >> 23) & 0x1ff;\n  return baseTable[e] + ((f & 0x007fffff) >> shiftTable[e]);\n}\n\nconst mantissaTable = new NativeUint32Array(2048);\nfor (let i = 1; i < 1024; ++i) {\n  let m = i << 13; // zero pad mantissa bits\n  let e = 0; // zero exponent\n\n  // normalized\n  while ((m & 0x00800000) === 0) {\n    m <<= 1;\n    e -= 0x00800000; // decrement exponent\n  }\n\n  m &= ~0x00800000; // clear leading 1 bit\n  e += 0x38800000; // adjust bias\n\n  mantissaTable[i] = m | e;\n}\nfor (let i = 1024; i < 2048; ++i) {\n  mantissaTable[i] = 0x38000000 + ((i - 1024) << 13);\n}\n\nconst exponentTable = new NativeUint32Array(64);\nfor (let i = 1; i < 31; ++i) {\n  exponentTable[i] = i << 23;\n}\nexponentTable[31] = 0x47800000;\nexponentTable[32] = 0x80000000;\nfor (let i = 33; i < 63; ++i) {\n  exponentTable[i] = 0x80000000 + ((i - 32) << 23);\n}\nexponentTable[63] = 0xc7800000;\n\nconst offsetTable = new NativeUint16Array(64);\nfor (let i = 1; i < 64; ++i) {\n  if (i !== 32) {\n    offsetTable[i] = 1024;\n  }\n}\n\n/**\n * convert a half float number bits to a number\n * @param {number} float16bits - half float number bits\n * @returns {number} double float\n */\nexport function convertToNumber(float16bits) {\n  const i = float16bits >> 10;\n  uint32View[0] = mantissaTable[offsetTable[i] + (float16bits & 0x3ff)] + exponentTable[i];\n  return floatView[0];\n}\n","import { safeIfNeeded } from \"./_util/arrayIterator.mjs\";\nimport { convertToNumber, roundToFloat16Bits } from \"./_util/converter.mjs\";\nimport {\n  DataViewPrototypeGetUint16,\n  DataViewPrototypeSetUint16,\n} from \"./_util/primordials.mjs\";\n\n/**\n * returns an unsigned 16-bit float at the specified byte offset from the start of the DataView\n * @param {DataView} dataView\n * @param {number} byteOffset\n * @param {[boolean]} opts\n * @returns {number}\n */\nexport function getFloat16(dataView, byteOffset, ...opts) {\n  return convertToNumber(\n    DataViewPrototypeGetUint16(dataView, byteOffset, ...safeIfNeeded(opts))\n  );\n}\n\n/**\n * stores an unsigned 16-bit float value at the specified byte offset from the start of the DataView\n * @param {DataView} dataView\n * @param {number} byteOffset\n * @param {number} value\n * @param {[boolean]} opts\n */\nexport function setFloat16(dataView, byteOffset, value, ...opts) {\n  return DataViewPrototypeSetUint16(\n    dataView,\n    byteOffset,\n    roundToFloat16Bits(value),\n    ...safeIfNeeded(opts)\n  );\n}\n"],"names":["assertPath","path","TypeError","JSON","stringify","normalizeStringPosix","allowAboveRoot","code","res","lastSegmentLength","lastSlash","dots","i","length","charCodeAt","lastSlashIndex","lastIndexOf","slice","_format","sep","pathObject","dir","root","base","name","ext","posix","resolve","cwd","resolvedPath","resolvedAbsolute","arguments","undefined","process","normalize","isAbsolute","trailingSeparator","join","joined","arg","relative","from","to","fromStart","fromEnd","fromLen","toStart","toEnd","toLen","lastCommonSep","fromCode","toCode","out","_makeLong","dirname","hasRoot","end","matchedSlash","basename","start","extIdx","firstNonSlashEnd","extname","startDot","startPart","preDotState","format","parse","ret","delimiter","win32","module","exports","CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT","uncurryThis","target","thisArg","args","ReflectApply","uncurryThisGetter","key","ReflectGetOwnPropertyDescriptor","get","apply","construct","ReflectConstruct","defineProperty","ReflectDefineProperty","ReflectGet","getOwnPropertyDescriptor","getPrototypeOf","ReflectGetPrototypeOf","has","ReflectHas","ownKeys","ReflectOwnKeys","set","ReflectSet","setPrototypeOf","ReflectSetPrototypeOf","Reflect","EPSILON","MAX_SAFE_INTEGER","isFinite","isNaN","Number","iterator","SymbolIterator","species","SymbolSpecies","toStringTag","SymbolToStringTag","for","SymbolFor","Symbol","NativeObject","Object","create","ObjectDefineProperty","freeze","ObjectFreeze","is","ObjectIs","ObjectPrototype","prototype","ObjectHasOwn","__lookupGetter__","hasOwn","hasOwnProperty","NativeArray","Array","ArrayPrototype","isArray","NativeArrayPrototypeSymbolIterator","push","toLocaleString","ArrayPrototypeSymbolIterator","abs","trunc","MathTrunc","Math","NativeArrayBuffer","ArrayBuffer","ArrayBufferPrototype","isView","NativeSharedArrayBuffer","SharedArrayBuffer","TypedArray","Uint8Array","TypedArrayPrototype","NativeUint8Array","keys","values","entries","reverse","fill","copyWithin","sort","subarray","NativeUint16Array","Uint16Array","NativeUint32Array","Uint32Array","NativeFloat32Array","Float32Array","ArrayIteratorPrototype","ArrayIteratorPrototypeNext","next","GeneratorPrototypeNext","IteratorPrototype","DataViewPrototype","DataView","DataViewPrototypeGetUint16","getUint16","NativeTypeError","setUint16","NativeWeakSet","WeakSet","WeakSetPrototype","NativeWeakMap","add","WeakMap","WeakMapPrototype","WeakMapPrototypeGet","arrayIterators","SafeIteratorPrototype","value","arrayIterator","this","array","safe","generators","DummyArrayIteratorPrototype","generator","writable","configurable","buffer","floatView","uint32View","baseTable","shiftTable","e","mantissaTable","m","exponentTable","offsetTable","convertToNumber","float16bits","getFloat16","dataView","byteOffset","opts"],"sourceRoot":""}
{"version":3,"file":"js/chunk-vendors-bc050c32.5b36d189.js","mappings":"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","sources":["webpack://@openeo/web-editor/./node_modules/define-data-property/index.js","webpack://@openeo/web-editor/./node_modules/define-properties/index.js","webpack://@openeo/web-editor/./node_modules/es-define-property/index.js","webpack://@openeo/web-editor/./node_modules/es-errors/eval.js","webpack://@openeo/web-editor/./node_modules/es-errors/index.js","webpack://@openeo/web-editor/./node_modules/es-errors/range.js","webpack://@openeo/web-editor/./node_modules/es-errors/ref.js","webpack://@openeo/web-editor/./node_modules/es-errors/syntax.js","webpack://@openeo/web-editor/./node_modules/es-errors/type.js","webpack://@openeo/web-editor/./node_modules/es-errors/uri.js","webpack://@openeo/web-editor/./node_modules/events/events.js","webpack://@openeo/web-editor/./node_modules/fast-deep-equal/es6/index.js","webpack://@openeo/web-editor/./node_modules/fast-deep-equal/index.js","webpack://@openeo/web-editor/./node_modules/fast-json-stable-stringify/index.js","webpack://@openeo/web-editor/./node_modules/for-each/index.js","webpack://@openeo/web-editor/./node_modules/function-bind/implementation.js","webpack://@openeo/web-editor/./node_modules/function-bind/index.js","webpack://@openeo/web-editor/./node_modules/get-intrinsic/index.js","webpack://@openeo/web-editor/./node_modules/gopd/index.js","webpack://@openeo/web-editor/./node_modules/has-property-descriptors/index.js","webpack://@openeo/web-editor/./node_modules/has-proto/index.js","webpack://@openeo/web-editor/./node_modules/has-symbols/index.js","webpack://@openeo/web-editor/./node_modules/has-symbols/shams.js","webpack://@openeo/web-editor/./node_modules/has-tostringtag/shams.js","webpack://@openeo/web-editor/./node_modules/hasown/index.js","webpack://@openeo/web-editor/./node_modules/ieee754/index.js","webpack://@openeo/web-editor/./node_modules/inherits/inherits_browser.js","webpack://@openeo/web-editor/./node_modules/is-arguments/index.js","webpack://@openeo/web-editor/./node_modules/is-callable/index.js","webpack://@openeo/web-editor/./node_modules/is-generator-function/index.js","webpack://@openeo/web-editor/./node_modules/is-nan/implementation.js","webpack://@openeo/web-editor/./node_modules/is-nan/index.js","webpack://@openeo/web-editor/./node_modules/is-nan/polyfill.js","webpack://@openeo/web-editor/./node_modules/is-nan/shim.js","webpack://@openeo/web-editor/./node_modules/is-typed-array/index.js","webpack://@openeo/web-editor/./node_modules/json-schema-traverse/index.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/compression/index.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/dataview64.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/dataslice.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/source/httputils.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/source/basesource.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/utils.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/source/blockedsource.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/source/client/base.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/source/client/fetch.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/source/client/xhr.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/source/client/http.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/source/remote.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/source/filereader.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/geotiff.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/rgb.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/resample.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/geotiffimage.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/globals.js"],"sourcesContent":["'use strict';\n\nvar $defineProperty = require('es-define-property');\n\nvar $SyntaxError = require('es-errors/syntax');\nvar $TypeError = require('es-errors/type');\n\nvar gopd = require('gopd');\n\n/** @type {import('.')} */\nmodule.exports = function defineDataProperty(\n\tobj,\n\tproperty,\n\tvalue\n) {\n\tif (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) {\n\t\tthrow new $TypeError('`obj` must be an object or a function`');\n\t}\n\tif (typeof property !== 'string' && typeof property !== 'symbol') {\n\t\tthrow new $TypeError('`property` must be a string or a symbol`');\n\t}\n\tif (arguments.length > 3 && typeof arguments[3] !== 'boolean' && arguments[3] !== null) {\n\t\tthrow new $TypeError('`nonEnumerable`, if provided, must be a boolean or null');\n\t}\n\tif (arguments.length > 4 && typeof arguments[4] !== 'boolean' && arguments[4] !== null) {\n\t\tthrow new $TypeError('`nonWritable`, if provided, must be a boolean or null');\n\t}\n\tif (arguments.length > 5 && typeof arguments[5] !== 'boolean' && arguments[5] !== null) {\n\t\tthrow new $TypeError('`nonConfigurable`, if provided, must be a boolean or null');\n\t}\n\tif (arguments.length > 6 && typeof arguments[6] !== 'boolean') {\n\t\tthrow new $TypeError('`loose`, if provided, must be a boolean');\n\t}\n\n\tvar nonEnumerable = arguments.length > 3 ? arguments[3] : null;\n\tvar nonWritable = arguments.length > 4 ? arguments[4] : null;\n\tvar nonConfigurable = arguments.length > 5 ? arguments[5] : null;\n\tvar loose = arguments.length > 6 ? arguments[6] : false;\n\n\t/* @type {false | TypedPropertyDescriptor<unknown>} */\n\tvar desc = !!gopd && gopd(obj, property);\n\n\tif ($defineProperty) {\n\t\t$defineProperty(obj, property, {\n\t\t\tconfigurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,\n\t\t\tenumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,\n\t\t\tvalue: value,\n\t\t\twritable: nonWritable === null && desc ? desc.writable : !nonWritable\n\t\t});\n\t} else if (loose || (!nonEnumerable && !nonWritable && !nonConfigurable)) {\n\t\t// must fall back to [[Set]], and was not explicitly asked to make non-enumerable, non-writable, or non-configurable\n\t\tobj[property] = value; // eslint-disable-line no-param-reassign\n\t} else {\n\t\tthrow new $SyntaxError('This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.');\n\t}\n};\n","'use strict';\n\nvar keys = require('object-keys');\nvar hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';\n\nvar toStr = Object.prototype.toString;\nvar concat = Array.prototype.concat;\nvar defineDataProperty = require('define-data-property');\n\nvar isFunction = function (fn) {\n\treturn typeof fn === 'function' && toStr.call(fn) === '[object Function]';\n};\n\nvar supportsDescriptors = require('has-property-descriptors')();\n\nvar defineProperty = function (object, name, value, predicate) {\n\tif (name in object) {\n\t\tif (predicate === true) {\n\t\t\tif (object[name] === value) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else if (!isFunction(predicate) || !predicate()) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (supportsDescriptors) {\n\t\tdefineDataProperty(object, name, value, true);\n\t} else {\n\t\tdefineDataProperty(object, name, value);\n\t}\n};\n\nvar defineProperties = function (object, map) {\n\tvar predicates = arguments.length > 2 ? arguments[2] : {};\n\tvar props = keys(map);\n\tif (hasSymbols) {\n\t\tprops = concat.call(props, Object.getOwnPropertySymbols(map));\n\t}\n\tfor (var i = 0; i < props.length; i += 1) {\n\t\tdefineProperty(object, props[i], map[props[i]], predicates[props[i]]);\n\t}\n};\n\ndefineProperties.supportsDescriptors = !!supportsDescriptors;\n\nmodule.exports = defineProperties;\n","'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\n/** @type {import('.')} */\nvar $defineProperty = GetIntrinsic('%Object.defineProperty%', true) || false;\nif ($defineProperty) {\n\ttry {\n\t\t$defineProperty({}, 'a', { value: 1 });\n\t} catch (e) {\n\t\t// IE 8 has a broken defineProperty\n\t\t$defineProperty = false;\n\t}\n}\n\nmodule.exports = $defineProperty;\n","'use strict';\n\n/** @type {import('./eval')} */\nmodule.exports = EvalError;\n","'use strict';\n\n/** @type {import('.')} */\nmodule.exports = Error;\n","'use strict';\n\n/** @type {import('./range')} */\nmodule.exports = RangeError;\n","'use strict';\n\n/** @type {import('./ref')} */\nmodule.exports = ReferenceError;\n","'use strict';\n\n/** @type {import('./syntax')} */\nmodule.exports = SyntaxError;\n","'use strict';\n\n/** @type {import('./type')} */\nmodule.exports = TypeError;\n","'use strict';\n\n/** @type {import('./uri')} */\nmodule.exports = URIError;\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n  var envHasBigInt64Array = typeof BigInt64Array !== 'undefined';\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n    if ((a instanceof Map) && (b instanceof Map)) {\n      if (a.size !== b.size) return false;\n      for (i of a.entries())\n        if (!b.has(i[0])) return false;\n      for (i of a.entries())\n        if (!equal(i[1], b.get(i[0]))) return false;\n      return true;\n    }\n\n    if ((a instanceof Set) && (b instanceof Set)) {\n      if (a.size !== b.size) return false;\n      for (i of a.entries())\n        if (!b.has(i[0])) return false;\n      return true;\n    }\n\n    if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (a[i] !== b[i]) return false;\n      return true;\n    }\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n","'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n","'use strict';\n\nmodule.exports = function (data, opts) {\n    if (!opts) opts = {};\n    if (typeof opts === 'function') opts = { cmp: opts };\n    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;\n\n    var cmp = opts.cmp && (function (f) {\n        return function (node) {\n            return function (a, b) {\n                var aobj = { key: a, value: node[a] };\n                var bobj = { key: b, value: node[b] };\n                return f(aobj, bobj);\n            };\n        };\n    })(opts.cmp);\n\n    var seen = [];\n    return (function stringify (node) {\n        if (node && node.toJSON && typeof node.toJSON === 'function') {\n            node = node.toJSON();\n        }\n\n        if (node === undefined) return;\n        if (typeof node == 'number') return isFinite(node) ? '' + node : 'null';\n        if (typeof node !== 'object') return JSON.stringify(node);\n\n        var i, out;\n        if (Array.isArray(node)) {\n            out = '[';\n            for (i = 0; i < node.length; i++) {\n                if (i) out += ',';\n                out += stringify(node[i]) || 'null';\n            }\n            return out + ']';\n        }\n\n        if (node === null) return 'null';\n\n        if (seen.indexOf(node) !== -1) {\n            if (cycles) return JSON.stringify('__cycle__');\n            throw new TypeError('Converting circular structure to JSON');\n        }\n\n        var seenIndex = seen.push(node) - 1;\n        var keys = Object.keys(node).sort(cmp && cmp(node));\n        out = '';\n        for (i = 0; i < keys.length; i++) {\n            var key = keys[i];\n            var value = stringify(node[key]);\n\n            if (!value) continue;\n            if (out) out += ',';\n            out += JSON.stringify(key) + ':' + value;\n        }\n        seen.splice(seenIndex, 1);\n        return '{' + out + '}';\n    })(data);\n};\n","'use strict';\n\nvar isCallable = require('is-callable');\n\nvar toStr = Object.prototype.toString;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar forEachArray = function forEachArray(array, iterator, receiver) {\n    for (var i = 0, len = array.length; i < len; i++) {\n        if (hasOwnProperty.call(array, i)) {\n            if (receiver == null) {\n                iterator(array[i], i, array);\n            } else {\n                iterator.call(receiver, array[i], i, array);\n            }\n        }\n    }\n};\n\nvar forEachString = function forEachString(string, iterator, receiver) {\n    for (var i = 0, len = string.length; i < len; i++) {\n        // no such thing as a sparse string.\n        if (receiver == null) {\n            iterator(string.charAt(i), i, string);\n        } else {\n            iterator.call(receiver, string.charAt(i), i, string);\n        }\n    }\n};\n\nvar forEachObject = function forEachObject(object, iterator, receiver) {\n    for (var k in object) {\n        if (hasOwnProperty.call(object, k)) {\n            if (receiver == null) {\n                iterator(object[k], k, object);\n            } else {\n                iterator.call(receiver, object[k], k, object);\n            }\n        }\n    }\n};\n\nvar forEach = function forEach(list, iterator, thisArg) {\n    if (!isCallable(iterator)) {\n        throw new TypeError('iterator must be a function');\n    }\n\n    var receiver;\n    if (arguments.length >= 3) {\n        receiver = thisArg;\n    }\n\n    if (toStr.call(list) === '[object Array]') {\n        forEachArray(list, iterator, receiver);\n    } else if (typeof list === 'string') {\n        forEachString(list, iterator, receiver);\n    } else {\n        forEachObject(list, iterator, receiver);\n    }\n};\n\nmodule.exports = forEach;\n","'use strict';\n\n/* eslint no-invalid-this: 1 */\n\nvar ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';\nvar toStr = Object.prototype.toString;\nvar max = Math.max;\nvar funcType = '[object Function]';\n\nvar concatty = function concatty(a, b) {\n    var arr = [];\n\n    for (var i = 0; i < a.length; i += 1) {\n        arr[i] = a[i];\n    }\n    for (var j = 0; j < b.length; j += 1) {\n        arr[j + a.length] = b[j];\n    }\n\n    return arr;\n};\n\nvar slicy = function slicy(arrLike, offset) {\n    var arr = [];\n    for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {\n        arr[j] = arrLike[i];\n    }\n    return arr;\n};\n\nvar joiny = function (arr, joiner) {\n    var str = '';\n    for (var i = 0; i < arr.length; i += 1) {\n        str += arr[i];\n        if (i + 1 < arr.length) {\n            str += joiner;\n        }\n    }\n    return str;\n};\n\nmodule.exports = function bind(that) {\n    var target = this;\n    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {\n        throw new TypeError(ERROR_MESSAGE + target);\n    }\n    var args = slicy(arguments, 1);\n\n    var bound;\n    var binder = function () {\n        if (this instanceof bound) {\n            var result = target.apply(\n                this,\n                concatty(args, arguments)\n            );\n            if (Object(result) === result) {\n                return result;\n            }\n            return this;\n        }\n        return target.apply(\n            that,\n            concatty(args, arguments)\n        );\n\n    };\n\n    var boundLength = max(0, target.length - args.length);\n    var boundArgs = [];\n    for (var i = 0; i < boundLength; i++) {\n        boundArgs[i] = '$' + i;\n    }\n\n    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);\n\n    if (target.prototype) {\n        var Empty = function Empty() {};\n        Empty.prototype = target.prototype;\n        bound.prototype = new Empty();\n        Empty.prototype = null;\n    }\n\n    return bound;\n};\n","'use strict';\n\nvar implementation = require('./implementation');\n\nmodule.exports = Function.prototype.bind || implementation;\n","'use strict';\n\nvar undefined;\n\nvar $Error = require('es-errors');\nvar $EvalError = require('es-errors/eval');\nvar $RangeError = require('es-errors/range');\nvar $ReferenceError = require('es-errors/ref');\nvar $SyntaxError = require('es-errors/syntax');\nvar $TypeError = require('es-errors/type');\nvar $URIError = require('es-errors/uri');\n\nvar $Function = Function;\n\n// eslint-disable-next-line consistent-return\nvar getEvalledConstructor = function (expressionSyntax) {\n\ttry {\n\t\treturn $Function('\"use strict\"; return (' + expressionSyntax + ').constructor;')();\n\t} catch (e) {}\n};\n\nvar $gOPD = Object.getOwnPropertyDescriptor;\nif ($gOPD) {\n\ttry {\n\t\t$gOPD({}, '');\n\t} catch (e) {\n\t\t$gOPD = null; // this is IE 8, which has a broken gOPD\n\t}\n}\n\nvar throwTypeError = function () {\n\tthrow new $TypeError();\n};\nvar ThrowTypeError = $gOPD\n\t? (function () {\n\t\ttry {\n\t\t\t// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties\n\t\t\targuments.callee; // IE 8 does not throw here\n\t\t\treturn throwTypeError;\n\t\t} catch (calleeThrows) {\n\t\t\ttry {\n\t\t\t\t// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')\n\t\t\t\treturn $gOPD(arguments, 'callee').get;\n\t\t\t} catch (gOPDthrows) {\n\t\t\t\treturn throwTypeError;\n\t\t\t}\n\t\t}\n\t}())\n\t: throwTypeError;\n\nvar hasSymbols = require('has-symbols')();\nvar hasProto = require('has-proto')();\n\nvar getProto = Object.getPrototypeOf || (\n\thasProto\n\t\t? function (x) { return x.__proto__; } // eslint-disable-line no-proto\n\t\t: null\n);\n\nvar needsEval = {};\n\nvar TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);\n\nvar INTRINSICS = {\n\t__proto__: null,\n\t'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,\n\t'%Array%': Array,\n\t'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,\n\t'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,\n\t'%AsyncFromSyncIteratorPrototype%': undefined,\n\t'%AsyncFunction%': needsEval,\n\t'%AsyncGenerator%': needsEval,\n\t'%AsyncGeneratorFunction%': needsEval,\n\t'%AsyncIteratorPrototype%': needsEval,\n\t'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,\n\t'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,\n\t'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,\n\t'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,\n\t'%Boolean%': Boolean,\n\t'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,\n\t'%Date%': Date,\n\t'%decodeURI%': decodeURI,\n\t'%decodeURIComponent%': decodeURIComponent,\n\t'%encodeURI%': encodeURI,\n\t'%encodeURIComponent%': encodeURIComponent,\n\t'%Error%': $Error,\n\t'%eval%': eval, // eslint-disable-line no-eval\n\t'%EvalError%': $EvalError,\n\t'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,\n\t'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,\n\t'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,\n\t'%Function%': $Function,\n\t'%GeneratorFunction%': needsEval,\n\t'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,\n\t'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,\n\t'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,\n\t'%isFinite%': isFinite,\n\t'%isNaN%': isNaN,\n\t'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,\n\t'%JSON%': typeof JSON === 'object' ? JSON : undefined,\n\t'%Map%': typeof Map === 'undefined' ? undefined : Map,\n\t'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),\n\t'%Math%': Math,\n\t'%Number%': Number,\n\t'%Object%': Object,\n\t'%parseFloat%': parseFloat,\n\t'%parseInt%': parseInt,\n\t'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,\n\t'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,\n\t'%RangeError%': $RangeError,\n\t'%ReferenceError%': $ReferenceError,\n\t'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,\n\t'%RegExp%': RegExp,\n\t'%Set%': typeof Set === 'undefined' ? undefined : Set,\n\t'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),\n\t'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,\n\t'%String%': String,\n\t'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,\n\t'%Symbol%': hasSymbols ? Symbol : undefined,\n\t'%SyntaxError%': $SyntaxError,\n\t'%ThrowTypeError%': ThrowTypeError,\n\t'%TypedArray%': TypedArray,\n\t'%TypeError%': $TypeError,\n\t'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,\n\t'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,\n\t'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,\n\t'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,\n\t'%URIError%': $URIError,\n\t'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,\n\t'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,\n\t'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet\n};\n\nif (getProto) {\n\ttry {\n\t\tnull.error; // eslint-disable-line no-unused-expressions\n\t} catch (e) {\n\t\t// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229\n\t\tvar errorProto = getProto(getProto(e));\n\t\tINTRINSICS['%Error.prototype%'] = errorProto;\n\t}\n}\n\nvar doEval = function doEval(name) {\n\tvar value;\n\tif (name === '%AsyncFunction%') {\n\t\tvalue = getEvalledConstructor('async function () {}');\n\t} else if (name === '%GeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('function* () {}');\n\t} else if (name === '%AsyncGeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('async function* () {}');\n\t} else if (name === '%AsyncGenerator%') {\n\t\tvar fn = doEval('%AsyncGeneratorFunction%');\n\t\tif (fn) {\n\t\t\tvalue = fn.prototype;\n\t\t}\n\t} else if (name === '%AsyncIteratorPrototype%') {\n\t\tvar gen = doEval('%AsyncGenerator%');\n\t\tif (gen && getProto) {\n\t\t\tvalue = getProto(gen.prototype);\n\t\t}\n\t}\n\n\tINTRINSICS[name] = value;\n\n\treturn value;\n};\n\nvar LEGACY_ALIASES = {\n\t__proto__: null,\n\t'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],\n\t'%ArrayPrototype%': ['Array', 'prototype'],\n\t'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],\n\t'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],\n\t'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],\n\t'%ArrayProto_values%': ['Array', 'prototype', 'values'],\n\t'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],\n\t'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],\n\t'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],\n\t'%BooleanPrototype%': ['Boolean', 'prototype'],\n\t'%DataViewPrototype%': ['DataView', 'prototype'],\n\t'%DatePrototype%': ['Date', 'prototype'],\n\t'%ErrorPrototype%': ['Error', 'prototype'],\n\t'%EvalErrorPrototype%': ['EvalError', 'prototype'],\n\t'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],\n\t'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],\n\t'%FunctionPrototype%': ['Function', 'prototype'],\n\t'%Generator%': ['GeneratorFunction', 'prototype'],\n\t'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],\n\t'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],\n\t'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],\n\t'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],\n\t'%JSONParse%': ['JSON', 'parse'],\n\t'%JSONStringify%': ['JSON', 'stringify'],\n\t'%MapPrototype%': ['Map', 'prototype'],\n\t'%NumberPrototype%': ['Number', 'prototype'],\n\t'%ObjectPrototype%': ['Object', 'prototype'],\n\t'%ObjProto_toString%': ['Object', 'prototype', 'toString'],\n\t'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],\n\t'%PromisePrototype%': ['Promise', 'prototype'],\n\t'%PromiseProto_then%': ['Promise', 'prototype', 'then'],\n\t'%Promise_all%': ['Promise', 'all'],\n\t'%Promise_reject%': ['Promise', 'reject'],\n\t'%Promise_resolve%': ['Promise', 'resolve'],\n\t'%RangeErrorPrototype%': ['RangeError', 'prototype'],\n\t'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],\n\t'%RegExpPrototype%': ['RegExp', 'prototype'],\n\t'%SetPrototype%': ['Set', 'prototype'],\n\t'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],\n\t'%StringPrototype%': ['String', 'prototype'],\n\t'%SymbolPrototype%': ['Symbol', 'prototype'],\n\t'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],\n\t'%TypedArrayPrototype%': ['TypedArray', 'prototype'],\n\t'%TypeErrorPrototype%': ['TypeError', 'prototype'],\n\t'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],\n\t'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],\n\t'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],\n\t'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],\n\t'%URIErrorPrototype%': ['URIError', 'prototype'],\n\t'%WeakMapPrototype%': ['WeakMap', 'prototype'],\n\t'%WeakSetPrototype%': ['WeakSet', 'prototype']\n};\n\nvar bind = require('function-bind');\nvar hasOwn = require('hasown');\nvar $concat = bind.call(Function.call, Array.prototype.concat);\nvar $spliceApply = bind.call(Function.apply, Array.prototype.splice);\nvar $replace = bind.call(Function.call, String.prototype.replace);\nvar $strSlice = bind.call(Function.call, String.prototype.slice);\nvar $exec = bind.call(Function.call, RegExp.prototype.exec);\n\n/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */\nvar rePropName = /[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g;\nvar reEscapeChar = /\\\\(\\\\)?/g; /** Used to match backslashes in property paths. */\nvar stringToPath = function stringToPath(string) {\n\tvar first = $strSlice(string, 0, 1);\n\tvar last = $strSlice(string, -1);\n\tif (first === '%' && last !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected closing `%`');\n\t} else if (last === '%' && first !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected opening `%`');\n\t}\n\tvar result = [];\n\t$replace(string, rePropName, function (match, number, quote, subString) {\n\t\tresult[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;\n\t});\n\treturn result;\n};\n/* end adaptation */\n\nvar getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {\n\tvar intrinsicName = name;\n\tvar alias;\n\tif (hasOwn(LEGACY_ALIASES, intrinsicName)) {\n\t\talias = LEGACY_ALIASES[intrinsicName];\n\t\tintrinsicName = '%' + alias[0] + '%';\n\t}\n\n\tif (hasOwn(INTRINSICS, intrinsicName)) {\n\t\tvar value = INTRINSICS[intrinsicName];\n\t\tif (value === needsEval) {\n\t\t\tvalue = doEval(intrinsicName);\n\t\t}\n\t\tif (typeof value === 'undefined' && !allowMissing) {\n\t\t\tthrow new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');\n\t\t}\n\n\t\treturn {\n\t\t\talias: alias,\n\t\t\tname: intrinsicName,\n\t\t\tvalue: value\n\t\t};\n\t}\n\n\tthrow new $SyntaxError('intrinsic ' + name + ' does not exist!');\n};\n\nmodule.exports = function GetIntrinsic(name, allowMissing) {\n\tif (typeof name !== 'string' || name.length === 0) {\n\t\tthrow new $TypeError('intrinsic name must be a non-empty string');\n\t}\n\tif (arguments.length > 1 && typeof allowMissing !== 'boolean') {\n\t\tthrow new $TypeError('\"allowMissing\" argument must be a boolean');\n\t}\n\n\tif ($exec(/^%?[^%]*%?$/, name) === null) {\n\t\tthrow new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');\n\t}\n\tvar parts = stringToPath(name);\n\tvar intrinsicBaseName = parts.length > 0 ? parts[0] : '';\n\n\tvar intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);\n\tvar intrinsicRealName = intrinsic.name;\n\tvar value = intrinsic.value;\n\tvar skipFurtherCaching = false;\n\n\tvar alias = intrinsic.alias;\n\tif (alias) {\n\t\tintrinsicBaseName = alias[0];\n\t\t$spliceApply(parts, $concat([0, 1], alias));\n\t}\n\n\tfor (var i = 1, isOwn = true; i < parts.length; i += 1) {\n\t\tvar part = parts[i];\n\t\tvar first = $strSlice(part, 0, 1);\n\t\tvar last = $strSlice(part, -1);\n\t\tif (\n\t\t\t(\n\t\t\t\t(first === '\"' || first === \"'\" || first === '`')\n\t\t\t\t|| (last === '\"' || last === \"'\" || last === '`')\n\t\t\t)\n\t\t\t&& first !== last\n\t\t) {\n\t\t\tthrow new $SyntaxError('property names with quotes must have matching quotes');\n\t\t}\n\t\tif (part === 'constructor' || !isOwn) {\n\t\t\tskipFurtherCaching = true;\n\t\t}\n\n\t\tintrinsicBaseName += '.' + part;\n\t\tintrinsicRealName = '%' + intrinsicBaseName + '%';\n\n\t\tif (hasOwn(INTRINSICS, intrinsicRealName)) {\n\t\t\tvalue = INTRINSICS[intrinsicRealName];\n\t\t} else if (value != null) {\n\t\t\tif (!(part in value)) {\n\t\t\t\tif (!allowMissing) {\n\t\t\t\t\tthrow new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');\n\t\t\t\t}\n\t\t\t\treturn void undefined;\n\t\t\t}\n\t\t\tif ($gOPD && (i + 1) >= parts.length) {\n\t\t\t\tvar desc = $gOPD(value, part);\n\t\t\t\tisOwn = !!desc;\n\n\t\t\t\t// By convention, when a data property is converted to an accessor\n\t\t\t\t// property to emulate a data property that does not suffer from\n\t\t\t\t// the override mistake, that accessor's getter is marked with\n\t\t\t\t// an `originalValue` property. Here, when we detect this, we\n\t\t\t\t// uphold the illusion by pretending to see that original data\n\t\t\t\t// property, i.e., returning the value rather than the getter\n\t\t\t\t// itself.\n\t\t\t\tif (isOwn && 'get' in desc && !('originalValue' in desc.get)) {\n\t\t\t\t\tvalue = desc.get;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = value[part];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tisOwn = hasOwn(value, part);\n\t\t\t\tvalue = value[part];\n\t\t\t}\n\n\t\t\tif (isOwn && !skipFurtherCaching) {\n\t\t\t\tINTRINSICS[intrinsicRealName] = value;\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n};\n","'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);\n\nif ($gOPD) {\n\ttry {\n\t\t$gOPD([], 'length');\n\t} catch (e) {\n\t\t// IE 8 has a broken gOPD\n\t\t$gOPD = null;\n\t}\n}\n\nmodule.exports = $gOPD;\n","'use strict';\n\nvar $defineProperty = require('es-define-property');\n\nvar hasPropertyDescriptors = function hasPropertyDescriptors() {\n\treturn !!$defineProperty;\n};\n\nhasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {\n\t// node v0.6 has a bug where array lengths can be Set but not Defined\n\tif (!$defineProperty) {\n\t\treturn null;\n\t}\n\ttry {\n\t\treturn $defineProperty([], 'length', { value: 1 }).length !== 1;\n\t} catch (e) {\n\t\t// In Firefox 4-22, defining length on an array throws an exception.\n\t\treturn true;\n\t}\n};\n\nmodule.exports = hasPropertyDescriptors;\n","'use strict';\n\nvar test = {\n\t__proto__: null,\n\tfoo: {}\n};\n\nvar $Object = Object;\n\n/** @type {import('.')} */\nmodule.exports = function hasProto() {\n\t// @ts-expect-error: TS errors on an inherited property for some reason\n\treturn { __proto__: test }.foo === test.foo\n\t\t&& !(test instanceof $Object);\n};\n","'use strict';\n\nvar origSymbol = typeof Symbol !== 'undefined' && Symbol;\nvar hasSymbolSham = require('./shams');\n\nmodule.exports = function hasNativeSymbols() {\n\tif (typeof origSymbol !== 'function') { return false; }\n\tif (typeof Symbol !== 'function') { return false; }\n\tif (typeof origSymbol('foo') !== 'symbol') { return false; }\n\tif (typeof Symbol('bar') !== 'symbol') { return false; }\n\n\treturn hasSymbolSham();\n};\n","'use strict';\n\n/* eslint complexity: [2, 18], max-statements: [2, 33] */\nmodule.exports = function hasSymbols() {\n\tif (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }\n\tif (typeof Symbol.iterator === 'symbol') { return true; }\n\n\tvar obj = {};\n\tvar sym = Symbol('test');\n\tvar symObj = Object(sym);\n\tif (typeof sym === 'string') { return false; }\n\n\tif (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }\n\tif (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }\n\n\t// temp disabled per https://github.com/ljharb/object.assign/issues/17\n\t// if (sym instanceof Symbol) { return false; }\n\t// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4\n\t// if (!(symObj instanceof Symbol)) { return false; }\n\n\t// if (typeof Symbol.prototype.toString !== 'function') { return false; }\n\t// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }\n\n\tvar symVal = 42;\n\tobj[sym] = symVal;\n\tfor (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop\n\tif (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }\n\n\tif (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }\n\n\tvar syms = Object.getOwnPropertySymbols(obj);\n\tif (syms.length !== 1 || syms[0] !== sym) { return false; }\n\n\tif (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }\n\n\tif (typeof Object.getOwnPropertyDescriptor === 'function') {\n\t\tvar descriptor = Object.getOwnPropertyDescriptor(obj, sym);\n\t\tif (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }\n\t}\n\n\treturn true;\n};\n","'use strict';\n\nvar hasSymbols = require('has-symbols/shams');\n\n/** @type {import('.')} */\nmodule.exports = function hasToStringTagShams() {\n\treturn hasSymbols() && !!Symbol.toStringTag;\n};\n","'use strict';\n\nvar call = Function.prototype.call;\nvar $hasOwn = Object.prototype.hasOwnProperty;\nvar bind = require('function-bind');\n\n/** @type {import('.')} */\nmodule.exports = bind.call(call, $hasOwn);\n","/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n","'use strict';\n\nvar hasToStringTag = require('has-tostringtag/shams')();\nvar callBound = require('call-bind/callBound');\n\nvar $toString = callBound('Object.prototype.toString');\n\nvar isStandardArguments = function isArguments(value) {\n\tif (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {\n\t\treturn false;\n\t}\n\treturn $toString(value) === '[object Arguments]';\n};\n\nvar isLegacyArguments = function isArguments(value) {\n\tif (isStandardArguments(value)) {\n\t\treturn true;\n\t}\n\treturn value !== null &&\n\t\ttypeof value === 'object' &&\n\t\ttypeof value.length === 'number' &&\n\t\tvalue.length >= 0 &&\n\t\t$toString(value) !== '[object Array]' &&\n\t\t$toString(value.callee) === '[object Function]';\n};\n\nvar supportsStandardArguments = (function () {\n\treturn isStandardArguments(arguments);\n}());\n\nisStandardArguments.isLegacyArguments = isLegacyArguments; // for tests\n\nmodule.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;\n","'use strict';\n\nvar fnToStr = Function.prototype.toString;\nvar reflectApply = typeof Reflect === 'object' && Reflect !== null && Reflect.apply;\nvar badArrayLike;\nvar isCallableMarker;\nif (typeof reflectApply === 'function' && typeof Object.defineProperty === 'function') {\n\ttry {\n\t\tbadArrayLike = Object.defineProperty({}, 'length', {\n\t\t\tget: function () {\n\t\t\t\tthrow isCallableMarker;\n\t\t\t}\n\t\t});\n\t\tisCallableMarker = {};\n\t\t// eslint-disable-next-line no-throw-literal\n\t\treflectApply(function () { throw 42; }, null, badArrayLike);\n\t} catch (_) {\n\t\tif (_ !== isCallableMarker) {\n\t\t\treflectApply = null;\n\t\t}\n\t}\n} else {\n\treflectApply = null;\n}\n\nvar constructorRegex = /^\\s*class\\b/;\nvar isES6ClassFn = function isES6ClassFunction(value) {\n\ttry {\n\t\tvar fnStr = fnToStr.call(value);\n\t\treturn constructorRegex.test(fnStr);\n\t} catch (e) {\n\t\treturn false; // not a function\n\t}\n};\n\nvar tryFunctionObject = function tryFunctionToStr(value) {\n\ttry {\n\t\tif (isES6ClassFn(value)) { return false; }\n\t\tfnToStr.call(value);\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\nvar toStr = Object.prototype.toString;\nvar objectClass = '[object Object]';\nvar fnClass = '[object Function]';\nvar genClass = '[object GeneratorFunction]';\nvar ddaClass = '[object HTMLAllCollection]'; // IE 11\nvar ddaClass2 = '[object HTML document.all class]';\nvar ddaClass3 = '[object HTMLCollection]'; // IE 9-10\nvar hasToStringTag = typeof Symbol === 'function' && !!Symbol.toStringTag; // better: use `has-tostringtag`\n\nvar isIE68 = !(0 in [,]); // eslint-disable-line no-sparse-arrays, comma-spacing\n\nvar isDDA = function isDocumentDotAll() { return false; };\nif (typeof document === 'object') {\n\t// Firefox 3 canonicalizes DDA to undefined when it's not accessed directly\n\tvar all = document.all;\n\tif (toStr.call(all) === toStr.call(document.all)) {\n\t\tisDDA = function isDocumentDotAll(value) {\n\t\t\t/* globals document: false */\n\t\t\t// in IE 6-8, typeof document.all is \"object\" and it's truthy\n\t\t\tif ((isIE68 || !value) && (typeof value === 'undefined' || typeof value === 'object')) {\n\t\t\t\ttry {\n\t\t\t\t\tvar str = toStr.call(value);\n\t\t\t\t\treturn (\n\t\t\t\t\t\tstr === ddaClass\n\t\t\t\t\t\t|| str === ddaClass2\n\t\t\t\t\t\t|| str === ddaClass3 // opera 12.16\n\t\t\t\t\t\t|| str === objectClass // IE 6-8\n\t\t\t\t\t) && value('') == null; // eslint-disable-line eqeqeq\n\t\t\t\t} catch (e) { /**/ }\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t}\n}\n\nmodule.exports = reflectApply\n\t? function isCallable(value) {\n\t\tif (isDDA(value)) { return true; }\n\t\tif (!value) { return false; }\n\t\tif (typeof value !== 'function' && typeof value !== 'object') { return false; }\n\t\ttry {\n\t\t\treflectApply(value, null, badArrayLike);\n\t\t} catch (e) {\n\t\t\tif (e !== isCallableMarker) { return false; }\n\t\t}\n\t\treturn !isES6ClassFn(value) && tryFunctionObject(value);\n\t}\n\t: function isCallable(value) {\n\t\tif (isDDA(value)) { return true; }\n\t\tif (!value) { return false; }\n\t\tif (typeof value !== 'function' && typeof value !== 'object') { return false; }\n\t\tif (hasToStringTag) { return tryFunctionObject(value); }\n\t\tif (isES6ClassFn(value)) { return false; }\n\t\tvar strClass = toStr.call(value);\n\t\tif (strClass !== fnClass && strClass !== genClass && !(/^\\[object HTML/).test(strClass)) { return false; }\n\t\treturn tryFunctionObject(value);\n\t};\n","'use strict';\n\nvar toStr = Object.prototype.toString;\nvar fnToStr = Function.prototype.toString;\nvar isFnRegex = /^\\s*(?:function)?\\*/;\nvar hasToStringTag = require('has-tostringtag/shams')();\nvar getProto = Object.getPrototypeOf;\nvar getGeneratorFunc = function () { // eslint-disable-line consistent-return\n\tif (!hasToStringTag) {\n\t\treturn false;\n\t}\n\ttry {\n\t\treturn Function('return function*() {}')();\n\t} catch (e) {\n\t}\n};\nvar GeneratorFunction;\n\nmodule.exports = function isGeneratorFunction(fn) {\n\tif (typeof fn !== 'function') {\n\t\treturn false;\n\t}\n\tif (isFnRegex.test(fnToStr.call(fn))) {\n\t\treturn true;\n\t}\n\tif (!hasToStringTag) {\n\t\tvar str = toStr.call(fn);\n\t\treturn str === '[object GeneratorFunction]';\n\t}\n\tif (!getProto) {\n\t\treturn false;\n\t}\n\tif (typeof GeneratorFunction === 'undefined') {\n\t\tvar generatorFunc = getGeneratorFunc();\n\t\tGeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;\n\t}\n\treturn getProto(fn) === GeneratorFunction;\n};\n","'use strict';\n\n/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */\n\nmodule.exports = function isNaN(value) {\n\treturn value !== value;\n};\n","'use strict';\n\nvar callBind = require('call-bind');\nvar define = require('define-properties');\n\nvar implementation = require('./implementation');\nvar getPolyfill = require('./polyfill');\nvar shim = require('./shim');\n\nvar polyfill = callBind(getPolyfill(), Number);\n\n/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */\n\ndefine(polyfill, {\n\tgetPolyfill: getPolyfill,\n\timplementation: implementation,\n\tshim: shim\n});\n\nmodule.exports = polyfill;\n","'use strict';\n\nvar implementation = require('./implementation');\n\nmodule.exports = function getPolyfill() {\n\tif (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN('a')) {\n\t\treturn Number.isNaN;\n\t}\n\treturn implementation;\n};\n","'use strict';\n\nvar define = require('define-properties');\nvar getPolyfill = require('./polyfill');\n\n/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */\n\nmodule.exports = function shimNumberIsNaN() {\n\tvar polyfill = getPolyfill();\n\tdefine(Number, { isNaN: polyfill }, {\n\t\tisNaN: function testIsNaN() {\n\t\t\treturn Number.isNaN !== polyfill;\n\t\t}\n\t});\n\treturn polyfill;\n};\n","'use strict';\n\nvar whichTypedArray = require('which-typed-array');\n\n/** @type {import('.')} */\nmodule.exports = function isTypedArray(value) {\n\treturn !!whichTypedArray(value);\n};\n","'use strict';\n\nvar traverse = module.exports = function (schema, opts, cb) {\n  // Legacy support for v0.3.1 and earlier.\n  if (typeof opts == 'function') {\n    cb = opts;\n    opts = {};\n  }\n\n  cb = opts.cb || cb;\n  var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};\n  var post = cb.post || function() {};\n\n  _traverse(opts, pre, post, schema, '', schema);\n};\n\n\ntraverse.keywords = {\n  additionalItems: true,\n  items: true,\n  contains: true,\n  additionalProperties: true,\n  propertyNames: true,\n  not: true\n};\n\ntraverse.arrayKeywords = {\n  items: true,\n  allOf: true,\n  anyOf: true,\n  oneOf: true\n};\n\ntraverse.propsKeywords = {\n  definitions: true,\n  properties: true,\n  patternProperties: true,\n  dependencies: true\n};\n\ntraverse.skipKeywords = {\n  default: true,\n  enum: true,\n  const: true,\n  required: true,\n  maximum: true,\n  minimum: true,\n  exclusiveMaximum: true,\n  exclusiveMinimum: true,\n  multipleOf: true,\n  maxLength: true,\n  minLength: true,\n  pattern: true,\n  format: true,\n  maxItems: true,\n  minItems: true,\n  uniqueItems: true,\n  maxProperties: true,\n  minProperties: true\n};\n\n\nfunction _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {\n  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {\n    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n    for (var key in schema) {\n      var sch = schema[key];\n      if (Array.isArray(sch)) {\n        if (key in traverse.arrayKeywords) {\n          for (var i=0; i<sch.length; i++)\n            _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);\n        }\n      } else if (key in traverse.propsKeywords) {\n        if (sch && typeof sch == 'object') {\n          for (var prop in sch)\n            _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);\n        }\n      } else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {\n        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);\n      }\n    }\n    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n  }\n}\n\n\nfunction escapeJsonPtr(str) {\n  return str.replace(/~/g, '~0').replace(/\\//g, '~1');\n}\n","const registry = new Map();\n\nexport function addDecoder(cases, importFn) {\n  if (!Array.isArray(cases)) {\n    cases = [cases]; // eslint-disable-line no-param-reassign\n  }\n  cases.forEach((c) => registry.set(c, importFn));\n}\n\nexport async function getDecoder(fileDirectory) {\n  const importFn = registry.get(fileDirectory.Compression);\n  if (!importFn) {\n    throw new Error(`Unknown compression method identifier: ${fileDirectory.Compression}`);\n  }\n  const Decoder = await importFn();\n  return new Decoder(fileDirectory);\n}\n\n// Add default decoders to registry (end-user may override with other implementations)\naddDecoder([undefined, 1], () => import('./raw.js').then((m) => m.default));\naddDecoder(5, () => import('./lzw.js').then((m) => m.default));\naddDecoder(6, () => {\n  throw new Error('old style JPEG compression is not supported.');\n});\naddDecoder(7, () => import('./jpeg.js').then((m) => m.default));\naddDecoder([8, 32946], () => import('./deflate.js').then((m) => m.default));\naddDecoder(32773, () => import('./packbits.js').then((m) => m.default));\naddDecoder(34887, () => import('./lerc.js')\n  .then(async (m) => {\n    await m.zstd.init();\n    return m;\n  })\n  .then((m) => m.default),\n);\naddDecoder(50001, () => import('./webimage.js').then((m) => m.default));\n","import { getFloat16 } from '@petamoriken/float16';\n\nexport default class DataView64 {\n  constructor(arrayBuffer) {\n    this._dataView = new DataView(arrayBuffer);\n  }\n\n  get buffer() {\n    return this._dataView.buffer;\n  }\n\n  getUint64(offset, littleEndian) {\n    const left = this.getUint32(offset, littleEndian);\n    const right = this.getUint32(offset + 4, littleEndian);\n    let combined;\n    if (littleEndian) {\n      combined = left + ((2 ** 32) * right);\n      if (!Number.isSafeInteger(combined)) {\n        throw new Error(\n          `${combined} exceeds MAX_SAFE_INTEGER. `\n          + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n        );\n      }\n      return combined;\n    }\n    combined = ((2 ** 32) * left) + right;\n    if (!Number.isSafeInteger(combined)) {\n      throw new Error(\n        `${combined} exceeds MAX_SAFE_INTEGER. `\n        + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n      );\n    }\n\n    return combined;\n  }\n\n  // adapted from https://stackoverflow.com/a/55338384/8060591\n  getInt64(offset, littleEndian) {\n    let value = 0;\n    const isNegative = (this._dataView.getUint8(offset + (littleEndian ? 7 : 0)) & 0x80) > 0;\n    let carrying = true;\n    for (let i = 0; i < 8; i++) {\n      let byte = this._dataView.getUint8(offset + (littleEndian ? i : 7 - i));\n      if (isNegative) {\n        if (carrying) {\n          if (byte !== 0x00) {\n            byte = ~(byte - 1) & 0xff;\n            carrying = false;\n          }\n        } else {\n          byte = ~byte & 0xff;\n        }\n      }\n      value += byte * (256 ** i);\n    }\n    if (isNegative) {\n      value = -value;\n    }\n    return value;\n  }\n\n  getUint8(offset, littleEndian) {\n    return this._dataView.getUint8(offset, littleEndian);\n  }\n\n  getInt8(offset, littleEndian) {\n    return this._dataView.getInt8(offset, littleEndian);\n  }\n\n  getUint16(offset, littleEndian) {\n    return this._dataView.getUint16(offset, littleEndian);\n  }\n\n  getInt16(offset, littleEndian) {\n    return this._dataView.getInt16(offset, littleEndian);\n  }\n\n  getUint32(offset, littleEndian) {\n    return this._dataView.getUint32(offset, littleEndian);\n  }\n\n  getInt32(offset, littleEndian) {\n    return this._dataView.getInt32(offset, littleEndian);\n  }\n\n  getFloat16(offset, littleEndian) {\n    return getFloat16(this._dataView, offset, littleEndian);\n  }\n\n  getFloat32(offset, littleEndian) {\n    return this._dataView.getFloat32(offset, littleEndian);\n  }\n\n  getFloat64(offset, littleEndian) {\n    return this._dataView.getFloat64(offset, littleEndian);\n  }\n}\n","export default class DataSlice {\n  constructor(arrayBuffer, sliceOffset, littleEndian, bigTiff) {\n    this._dataView = new DataView(arrayBuffer);\n    this._sliceOffset = sliceOffset;\n    this._littleEndian = littleEndian;\n    this._bigTiff = bigTiff;\n  }\n\n  get sliceOffset() {\n    return this._sliceOffset;\n  }\n\n  get sliceTop() {\n    return this._sliceOffset + this.buffer.byteLength;\n  }\n\n  get littleEndian() {\n    return this._littleEndian;\n  }\n\n  get bigTiff() {\n    return this._bigTiff;\n  }\n\n  get buffer() {\n    return this._dataView.buffer;\n  }\n\n  covers(offset, length) {\n    return this.sliceOffset <= offset && this.sliceTop >= offset + length;\n  }\n\n  readUint8(offset) {\n    return this._dataView.getUint8(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt8(offset) {\n    return this._dataView.getInt8(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint16(offset) {\n    return this._dataView.getUint16(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt16(offset) {\n    return this._dataView.getInt16(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint32(offset) {\n    return this._dataView.getUint32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt32(offset) {\n    return this._dataView.getInt32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readFloat32(offset) {\n    return this._dataView.getFloat32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readFloat64(offset) {\n    return this._dataView.getFloat64(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint64(offset) {\n    const left = this.readUint32(offset);\n    const right = this.readUint32(offset + 4);\n    let combined;\n    if (this._littleEndian) {\n      combined = left + ((2 ** 32) * right);\n      if (!Number.isSafeInteger(combined)) {\n        throw new Error(\n          `${combined} exceeds MAX_SAFE_INTEGER. `\n          + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n        );\n      }\n      return combined;\n    }\n    combined = ((2 ** 32) * left) + right;\n    if (!Number.isSafeInteger(combined)) {\n      throw new Error(\n        `${combined} exceeds MAX_SAFE_INTEGER. `\n        + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n      );\n    }\n\n    return combined;\n  }\n\n  // adapted from https://stackoverflow.com/a/55338384/8060591\n  readInt64(offset) {\n    let value = 0;\n    const isNegative = (this._dataView.getUint8(offset + (this._littleEndian ? 7 : 0)) & 0x80)\n      > 0;\n    let carrying = true;\n    for (let i = 0; i < 8; i++) {\n      let byte = this._dataView.getUint8(\n        offset + (this._littleEndian ? i : 7 - i),\n      );\n      if (isNegative) {\n        if (carrying) {\n          if (byte !== 0x00) {\n            byte = ~(byte - 1) & 0xff;\n            carrying = false;\n          }\n        } else {\n          byte = ~byte & 0xff;\n        }\n      }\n      value += byte * (256 ** i);\n    }\n    if (isNegative) {\n      value = -value;\n    }\n    return value;\n  }\n\n  readOffset(offset) {\n    if (this._bigTiff) {\n      return this.readUint64(offset);\n    }\n    return this.readUint32(offset);\n  }\n}\n","const CRLFCRLF = '\\r\\n\\r\\n';\n\n/*\n * Shim for 'Object.fromEntries'\n */\nfunction itemsToObject(items) {\n  if (typeof Object.fromEntries !== 'undefined') {\n    return Object.fromEntries(items);\n  }\n  const obj = {};\n  for (const [key, value] of items) {\n    obj[key.toLowerCase()] = value;\n  }\n  return obj;\n}\n\n/**\n * Parse HTTP headers from a given string.\n * @param {String} text the text to parse the headers from\n * @returns {Object} the parsed headers with lowercase keys\n */\nfunction parseHeaders(text) {\n  const items = text\n    .split('\\r\\n')\n    .map((line) => {\n      const kv = line.split(':').map((str) => str.trim());\n      kv[0] = kv[0].toLowerCase();\n      return kv;\n    });\n\n  return itemsToObject(items);\n}\n\n/**\n * Parse a 'Content-Type' header value to the content-type and parameters\n * @param {String} rawContentType the raw string to parse from\n * @returns {Object} the parsed content type with the fields: type and params\n */\nexport function parseContentType(rawContentType) {\n  const [type, ...rawParams] = rawContentType.split(';').map((s) => s.trim());\n  const paramsItems = rawParams.map((param) => param.split('='));\n  return { type, params: itemsToObject(paramsItems) };\n}\n\n/**\n * Parse a 'Content-Range' header value to its start, end, and total parts\n * @param {String} rawContentRange the raw string to parse from\n * @returns {Object} the parsed parts\n */\nexport function parseContentRange(rawContentRange) {\n  let start;\n  let end;\n  let total;\n\n  if (rawContentRange) {\n    [, start, end, total] = rawContentRange.match(/bytes (\\d+)-(\\d+)\\/(\\d+)/);\n    start = parseInt(start, 10);\n    end = parseInt(end, 10);\n    total = parseInt(total, 10);\n  }\n\n  return { start, end, total };\n}\n\n/**\n * Parses a list of byteranges from the given 'multipart/byteranges' HTTP response.\n * Each item in the list has the following properties:\n * - headers: the HTTP headers\n * - data: the sliced ArrayBuffer for that specific part\n * - offset: the offset of the byterange within its originating file\n * - length: the length of the byterange\n * @param {ArrayBuffer} responseArrayBuffer the response to be parsed and split\n * @param {String} boundary the boundary string used to split the sections\n * @returns {Object[]} the parsed byteranges\n */\nexport function parseByteRanges(responseArrayBuffer, boundary) {\n  let offset = null;\n  const decoder = new TextDecoder('ascii');\n  const out = [];\n\n  const startBoundary = `--${boundary}`;\n  const endBoundary = `${startBoundary}--`;\n\n  // search for the initial boundary, may be offset by some bytes\n  // TODO: more efficient to check for `--` in bytes directly\n  for (let i = 0; i < 10; ++i) {\n    const text = decoder.decode(\n      new Uint8Array(responseArrayBuffer, i, startBoundary.length),\n    );\n    if (text === startBoundary) {\n      offset = i;\n    }\n  }\n\n  if (offset === null) {\n    throw new Error('Could not find initial boundary');\n  }\n\n  while (offset < responseArrayBuffer.byteLength) {\n    const text = decoder.decode(\n      new Uint8Array(responseArrayBuffer, offset,\n        Math.min(startBoundary.length + 1024, responseArrayBuffer.byteLength - offset),\n      ),\n    );\n\n    // break if we arrived at the end\n    if (text.length === 0 || text.startsWith(endBoundary)) {\n      break;\n    }\n\n    // assert that we are actually dealing with a byterange and are at the correct offset\n    if (!text.startsWith(startBoundary)) {\n      throw new Error('Part does not start with boundary');\n    }\n\n    // get a substring from where we read the headers\n    const innerText = text.substr(startBoundary.length + 2);\n\n    if (innerText.length === 0) {\n      break;\n    }\n\n    // find the double linebreak that denotes the end of the headers\n    const endOfHeaders = innerText.indexOf(CRLFCRLF);\n\n    // parse the headers to get the content range size\n    const headers = parseHeaders(innerText.substr(0, endOfHeaders));\n    const { start, end, total } = parseContentRange(headers['content-range']);\n\n    // calculate the length of the slice and the next offset\n    const startOfData = offset + startBoundary.length + endOfHeaders + CRLFCRLF.length;\n    const length = parseInt(end, 10) + 1 - parseInt(start, 10);\n    out.push({\n      headers,\n      data: responseArrayBuffer.slice(startOfData, startOfData + length),\n      offset: start,\n      length,\n      fileSize: total,\n    });\n\n    offset = startOfData + length + 4;\n  }\n\n  return out;\n}\n","/**\n * @typedef Slice\n * @property {number} offset\n * @property {number} length\n */\n\nexport class BaseSource {\n  /**\n   *\n   * @param {Slice[]} slices\n   * @returns {ArrayBuffer[]}\n   */\n  async fetch(slices, signal = undefined) {\n    return Promise.all(\n      slices.map((slice) => this.fetchSlice(slice, signal)),\n    );\n  }\n\n  /**\n   *\n   * @param {Slice} slice\n   * @returns {ArrayBuffer}\n   */\n  async fetchSlice(slice) {\n    throw new Error(`fetching of slice ${slice} not possible, not implemented`);\n  }\n\n  /**\n   * Returns the filesize if already determined and null otherwise\n   */\n  get fileSize() {\n    return null;\n  }\n\n  async close() {\n    // no-op by default\n  }\n}\n","export function assign(target, source) {\n  for (const key in source) {\n    if (source.hasOwnProperty(key)) {\n      target[key] = source[key];\n    }\n  }\n}\n\nexport function chunk(iterable, length) {\n  const results = [];\n  const lengthOfIterable = iterable.length;\n  for (let i = 0; i < lengthOfIterable; i += length) {\n    const chunked = [];\n    for (let ci = i; ci < i + length; ci++) {\n      chunked.push(iterable[ci]);\n    }\n    results.push(chunked);\n  }\n  return results;\n}\n\nexport function endsWith(string, expectedEnding) {\n  if (string.length < expectedEnding.length) {\n    return false;\n  }\n  const actualEnding = string.substr(string.length - expectedEnding.length);\n  return actualEnding === expectedEnding;\n}\n\nexport function forEach(iterable, func) {\n  const { length } = iterable;\n  for (let i = 0; i < length; i++) {\n    func(iterable[i], i);\n  }\n}\n\nexport function invert(oldObj) {\n  const newObj = {};\n  for (const key in oldObj) {\n    if (oldObj.hasOwnProperty(key)) {\n      const value = oldObj[key];\n      newObj[value] = key;\n    }\n  }\n  return newObj;\n}\n\nexport function range(n) {\n  const results = [];\n  for (let i = 0; i < n; i++) {\n    results.push(i);\n  }\n  return results;\n}\n\nexport function times(numTimes, func) {\n  const results = [];\n  for (let i = 0; i < numTimes; i++) {\n    results.push(func(i));\n  }\n  return results;\n}\n\nexport function toArray(iterable) {\n  const results = [];\n  const { length } = iterable;\n  for (let i = 0; i < length; i++) {\n    results.push(iterable[i]);\n  }\n  return results;\n}\n\nexport function toArrayRecursively(input) {\n  if (input.length) {\n    return toArray(input).map(toArrayRecursively);\n  }\n  return input;\n}\n\n// copied from https://github.com/academia-de-codigo/parse-content-range-header/blob/master/index.js\nexport function parseContentRange(headerValue) {\n  if (!headerValue) {\n    return null;\n  }\n\n  if (typeof headerValue !== 'string') {\n    throw new Error('invalid argument');\n  }\n\n  const parseInt = (number) => Number.parseInt(number, 10);\n\n  // Check for presence of unit\n  let matches = headerValue.match(/^(\\w*) /);\n  const unit = matches && matches[1];\n\n  // check for start-end/size header format\n  matches = headerValue.match(/(\\d+)-(\\d+)\\/(\\d+|\\*)/);\n  if (matches) {\n    return {\n      unit,\n      first: parseInt(matches[1]),\n      last: parseInt(matches[2]),\n      length: matches[3] === '*' ? null : parseInt(matches[3]),\n    };\n  }\n\n  // check for size header format\n  matches = headerValue.match(/(\\d+|\\*)/);\n  if (matches) {\n    return {\n      unit,\n      first: null,\n      last: null,\n      length: matches[1] === '*' ? null : parseInt(matches[1]),\n    };\n  }\n\n  return null;\n}\n\n/*\n * Promisified wrapper around 'setTimeout' to allow 'await'\n */\nexport async function wait(milliseconds) {\n  return new Promise((resolve) => setTimeout(resolve, milliseconds));\n}\n\nexport function zip(a, b) {\n  const A = Array.isArray(a) ? a : Array.from(a);\n  const B = Array.isArray(b) ? b : Array.from(b);\n  return A.map((k, i) => [k, B[i]]);\n}\n\n// Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error\nexport class AbortError extends Error {\n  constructor(params) {\n    // Pass remaining arguments (including vendor specific ones) to parent constructor\n    super(params);\n\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AbortError);\n    }\n\n    this.name = 'AbortError';\n  }\n}\n\nexport class CustomAggregateError extends Error {\n  constructor(errors, message) {\n    super(message);\n    this.errors = errors;\n    this.message = message;\n    this.name = 'AggregateError';\n  }\n}\n\nexport const AggregateError = CustomAggregateError;\n","import QuickLRU from 'quick-lru';\nimport { BaseSource } from './basesource.js';\nimport { AbortError, AggregateError, wait, zip } from '../utils.js';\n\nclass Block {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {ArrayBuffer} [data]\n   */\n  constructor(offset, length, data = null) {\n    this.offset = offset;\n    this.length = length;\n    this.data = data;\n  }\n\n  /**\n   * @returns {number} the top byte border\n   */\n  get top() {\n    return this.offset + this.length;\n  }\n}\n\nclass BlockGroup {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {number[]} blockIds\n   */\n  constructor(offset, length, blockIds) {\n    this.offset = offset;\n    this.length = length;\n    this.blockIds = blockIds;\n  }\n}\n\nexport class BlockedSource extends BaseSource {\n  /**\n   *\n   * @param {BaseSource} source The underlying source that shall be blocked and cached\n   * @param {object} options\n   * @param {number} [options.blockSize]\n   * @param {number} [options.cacheSize]\n   */\n  constructor(source, { blockSize = 65536, cacheSize = 100 } = {}) {\n    super();\n    this.source = source;\n    this.blockSize = blockSize;\n\n    this.blockCache = new QuickLRU({\n      maxSize: cacheSize,\n      onEviction: (blockId, block) => {\n        this.evictedBlocks.set(blockId, block);\n      },\n    });\n\n    /** @type {Map<number, Block>} */\n    this.evictedBlocks = new Map();\n\n    // mapping blockId -> Block instance\n    this.blockRequests = new Map();\n\n    // set of blockIds missing for the current requests\n    this.blockIdsToFetch = new Set();\n\n    this.abortedBlockIds = new Set();\n  }\n\n  get fileSize() {\n    return this.source.fileSize;\n  }\n\n  /**\n   *\n   * @param {import(\"./basesource\").Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    const blockRequests = [];\n    const missingBlockIds = [];\n    const allBlockIds = [];\n    this.evictedBlocks.clear();\n\n    for (const { offset, length } of slices) {\n      let top = offset + length;\n\n      const { fileSize } = this;\n      if (fileSize !== null) {\n        top = Math.min(top, fileSize);\n      }\n\n      const firstBlockOffset = Math.floor(offset / this.blockSize) * this.blockSize;\n\n      for (let current = firstBlockOffset; current < top; current += this.blockSize) {\n        const blockId = Math.floor(current / this.blockSize);\n        if (!this.blockCache.has(blockId) && !this.blockRequests.has(blockId)) {\n          this.blockIdsToFetch.add(blockId);\n          missingBlockIds.push(blockId);\n        }\n        if (this.blockRequests.has(blockId)) {\n          blockRequests.push(this.blockRequests.get(blockId));\n        }\n        allBlockIds.push(blockId);\n      }\n    }\n\n    // allow additional block requests to accumulate\n    await wait();\n    this.fetchBlocks(signal);\n\n    // Gather all of the new requests that this fetch call is contributing to `fetch`.\n    const missingRequests = [];\n    for (const blockId of missingBlockIds) {\n      // The requested missing block could already be in the cache\n      // instead of having its request still be outstanding.\n      if (this.blockRequests.has(blockId)) {\n        missingRequests.push(this.blockRequests.get(blockId));\n      }\n    }\n\n    // Actually await all pending requests that are needed for this `fetch`.\n    await Promise.allSettled(blockRequests);\n    await Promise.allSettled(missingRequests);\n\n    // Perform retries if a block was interrupted by a previous signal\n    const abortedBlockRequests = [];\n    const abortedBlockIds = allBlockIds\n      .filter((id) => this.abortedBlockIds.has(id) || !this.blockCache.has(id));\n    abortedBlockIds.forEach((id) => this.blockIdsToFetch.add(id));\n    // start the retry of some blocks if required\n    if (abortedBlockIds.length > 0 && signal && !signal.aborted) {\n      this.fetchBlocks(null);\n      for (const blockId of abortedBlockIds) {\n        const block = this.blockRequests.get(blockId);\n        if (!block) {\n          throw new Error(`Block ${blockId} is not in the block requests`);\n        }\n        abortedBlockRequests.push(block);\n      }\n      await Promise.allSettled(abortedBlockRequests);\n    }\n\n    // throw an  abort error\n    if (signal && signal.aborted) {\n      throw new AbortError('Request was aborted');\n    }\n\n    const blocks = allBlockIds.map((id) => this.blockCache.get(id) || this.evictedBlocks.get(id));\n    const failedBlocks = blocks.filter((i) => !i);\n    if (failedBlocks.length) {\n      throw new AggregateError(failedBlocks, 'Request failed');\n    }\n\n    // create a final Map, with all required blocks for this request to satisfy\n    const requiredBlocks = new Map(zip(allBlockIds, blocks));\n\n    // TODO: satisfy each slice\n    return this.readSliceData(slices, requiredBlocks);\n  }\n\n  /**\n   *\n   * @param {AbortSignal} signal\n   */\n  fetchBlocks(signal) {\n    // check if we still need to\n    if (this.blockIdsToFetch.size > 0) {\n      const groups = this.groupBlocks(this.blockIdsToFetch);\n\n      // start requesting slices of data\n      const groupRequests = this.source.fetch(groups, signal);\n\n      for (let groupIndex = 0; groupIndex < groups.length; ++groupIndex) {\n        const group = groups[groupIndex];\n\n        for (const blockId of group.blockIds) {\n          // make an async IIFE for each block\n          this.blockRequests.set(blockId, (async () => {\n            try {\n              const response = (await groupRequests)[groupIndex];\n              const blockOffset = blockId * this.blockSize;\n              const o = blockOffset - response.offset;\n              const t = Math.min(o + this.blockSize, response.data.byteLength);\n              const data = response.data.slice(o, t);\n              const block = new Block(\n                blockOffset,\n                data.byteLength,\n                data,\n                blockId,\n              );\n              this.blockCache.set(blockId, block);\n              this.abortedBlockIds.delete(blockId);\n            } catch (err) {\n              if (err.name === 'AbortError') {\n                // store the signal here, we need it to determine later if an\n                // error was caused by this signal\n                err.signal = signal;\n                this.blockCache.delete(blockId);\n                this.abortedBlockIds.add(blockId);\n              } else {\n                throw err;\n              }\n            } finally {\n              this.blockRequests.delete(blockId);\n            }\n          })());\n        }\n      }\n      this.blockIdsToFetch.clear();\n    }\n  }\n\n  /**\n   *\n   * @param {Set} blockIds\n   * @returns {BlockGroup[]}\n   */\n  groupBlocks(blockIds) {\n    const sortedBlockIds = Array.from(blockIds).sort((a, b) => a - b);\n    if (sortedBlockIds.length === 0) {\n      return [];\n    }\n    let current = [];\n    let lastBlockId = null;\n    const groups = [];\n\n    for (const blockId of sortedBlockIds) {\n      if (lastBlockId === null || lastBlockId + 1 === blockId) {\n        current.push(blockId);\n        lastBlockId = blockId;\n      } else {\n        groups.push(new BlockGroup(\n          current[0] * this.blockSize,\n          current.length * this.blockSize,\n          current,\n        ));\n        current = [blockId];\n        lastBlockId = blockId;\n      }\n    }\n\n    groups.push(new BlockGroup(\n      current[0] * this.blockSize,\n      current.length * this.blockSize,\n      current,\n    ));\n\n    return groups;\n  }\n\n  /**\n   *\n   * @param {import(\"./basesource\").Slice[]} slices\n   * @param {Map} blocks\n   */\n  readSliceData(slices, blocks) {\n    return slices.map((slice) => {\n      let top = slice.offset + slice.length;\n      if (this.fileSize !== null) {\n        top = Math.min(this.fileSize, top);\n      }\n      const blockIdLow = Math.floor(slice.offset / this.blockSize);\n      const blockIdHigh = Math.floor(top / this.blockSize);\n      const sliceData = new ArrayBuffer(slice.length);\n      const sliceView = new Uint8Array(sliceData);\n\n      for (let blockId = blockIdLow; blockId <= blockIdHigh; ++blockId) {\n        const block = blocks.get(blockId);\n        const delta = block.offset - slice.offset;\n        const topDelta = block.top - top;\n        let blockInnerOffset = 0;\n        let rangeInnerOffset = 0;\n        let usedBlockLength;\n\n        if (delta < 0) {\n          blockInnerOffset = -delta;\n        } else if (delta > 0) {\n          rangeInnerOffset = delta;\n        }\n\n        if (topDelta < 0) {\n          usedBlockLength = block.length - blockInnerOffset;\n        } else {\n          usedBlockLength = top - block.offset - blockInnerOffset;\n        }\n\n        const blockView = new Uint8Array(block.data, blockInnerOffset, usedBlockLength);\n        sliceView.set(blockView, rangeInnerOffset);\n      }\n\n      return sliceData;\n    });\n  }\n}\n","export class BaseResponse {\n  /**\n   * Returns whether the response has an ok'ish status code\n   */\n  get ok() {\n    return this.status >= 200 && this.status <= 299;\n  }\n\n  /**\n   * Returns the status code of the response\n   */\n  get status() {\n    throw new Error('not implemented');\n  }\n\n  /**\n   * Returns the value of the specified header\n   * @param {string} headerName the header name\n   * @returns {string} the header value\n   */\n  getHeader(headerName) { // eslint-disable-line no-unused-vars\n    throw new Error('not implemented');\n  }\n\n  /**\n   * @returns {ArrayBuffer} the response data of the request\n   */\n  async getData() {\n    throw new Error('not implemented');\n  }\n}\n\nexport class BaseClient {\n  constructor(url) {\n    this.url = url;\n  }\n\n  /**\n   * Send a request with the options\n   * @param {{headers: HeadersInit, signal: AbortSignal}} [options={}]\n   * @returns {Promise<BaseResponse>}\n   */\n  async request({ headers, signal } = {}) { // eslint-disable-line no-unused-vars\n    throw new Error('request is not implemented');\n  }\n}\n","import { BaseClient, BaseResponse } from './base.js';\n\nclass FetchResponse extends BaseResponse {\n  /**\n   * BaseResponse facade for fetch API Response\n   * @param {Response} response\n   */\n  constructor(response) {\n    super();\n    this.response = response;\n  }\n\n  get status() {\n    return this.response.status;\n  }\n\n  getHeader(name) {\n    return this.response.headers.get(name);\n  }\n\n  async getData() {\n    const data = this.response.arrayBuffer\n      ? await this.response.arrayBuffer()\n      : (await this.response.buffer()).buffer;\n    return data;\n  }\n}\n\nexport class FetchClient extends BaseClient {\n  constructor(url, credentials) {\n    super(url);\n    this.credentials = credentials;\n  }\n\n  /**\n   * @param {{headers: HeadersInit, signal: AbortSignal}} [options={}]\n   * @returns {Promise<FetchResponse>}\n   */\n  async request({ headers, signal } = {}) {\n    const response = await fetch(this.url, {\n      headers, credentials: this.credentials, signal,\n    });\n    return new FetchResponse(response);\n  }\n}\n","import { BaseClient, BaseResponse } from './base.js';\nimport { AbortError } from '../../utils.js';\n\nclass XHRResponse extends BaseResponse {\n  /**\n   * BaseResponse facade for XMLHttpRequest\n   * @param {XMLHttpRequest} xhr\n   * @param {ArrayBuffer} data\n   */\n  constructor(xhr, data) {\n    super();\n    this.xhr = xhr;\n    this.data = data;\n  }\n\n  get status() {\n    return this.xhr.status;\n  }\n\n  getHeader(name) {\n    return this.xhr.getResponseHeader(name);\n  }\n\n  async getData() {\n    return this.data;\n  }\n}\n\nexport class XHRClient extends BaseClient {\n  constructRequest(headers, signal) {\n    return new Promise((resolve, reject) => {\n      const xhr = new XMLHttpRequest();\n      xhr.open('GET', this.url);\n      xhr.responseType = 'arraybuffer';\n      for (const [key, value] of Object.entries(headers)) {\n        xhr.setRequestHeader(key, value);\n      }\n\n      // hook signals\n      xhr.onload = () => {\n        const data = xhr.response;\n        resolve(new XHRResponse(xhr, data));\n      };\n      xhr.onerror = reject;\n      xhr.onabort = () => reject(new AbortError('Request aborted'));\n      xhr.send();\n\n      if (signal) {\n        if (signal.aborted) {\n          xhr.abort();\n        }\n        signal.addEventListener('abort', () => xhr.abort());\n      }\n    });\n  }\n\n  async request({ headers, signal } = {}) {\n    const response = await this.constructRequest(headers, signal);\n    return response;\n  }\n}\n","import http from 'http';\nimport https from 'https';\nimport urlMod from 'url';\n\nimport { BaseClient, BaseResponse } from './base.js';\nimport { AbortError } from '../../utils.js';\n\nclass HttpResponse extends BaseResponse {\n  /**\n   * BaseResponse facade for node HTTP/HTTPS API Response\n   * @param {http.ServerResponse} response\n   */\n  constructor(response, dataPromise) {\n    super();\n    this.response = response;\n    this.dataPromise = dataPromise;\n  }\n\n  get status() {\n    return this.response.statusCode;\n  }\n\n  getHeader(name) {\n    return this.response.headers[name];\n  }\n\n  async getData() {\n    const data = await this.dataPromise;\n    return data;\n  }\n}\n\nexport class HttpClient extends BaseClient {\n  constructor(url) {\n    super(url);\n    this.parsedUrl = urlMod.parse(this.url);\n    this.httpApi = (this.parsedUrl.protocol === 'http:' ? http : https);\n  }\n\n  constructRequest(headers, signal) {\n    return new Promise((resolve, reject) => {\n      const request = this.httpApi.get(\n        {\n          ...this.parsedUrl,\n          headers,\n        },\n        (response) => {\n          const dataPromise = new Promise((resolveData) => {\n            const chunks = [];\n\n            // collect chunks\n            response.on('data', (chunk) => {\n              chunks.push(chunk);\n            });\n\n            // concatenate all chunks and resolve the promise with the resulting buffer\n            response.on('end', () => {\n              const data = Buffer.concat(chunks).buffer;\n              resolveData(data);\n            });\n            response.on('error', reject);\n          });\n          resolve(new HttpResponse(response, dataPromise));\n        },\n      );\n      request.on('error', reject);\n\n      if (signal) {\n        if (signal.aborted) {\n          request.destroy(new AbortError('Request aborted'));\n        }\n        signal.addEventListener('abort', () => request.destroy(new AbortError('Request aborted')));\n      }\n    });\n  }\n\n  async request({ headers, signal } = {}) {\n    const response = await this.constructRequest(headers, signal);\n    return response;\n  }\n}\n","import { parseByteRanges, parseContentRange, parseContentType } from './httputils.js';\nimport { BaseSource } from './basesource.js';\nimport { BlockedSource } from './blockedsource.js';\n\nimport { FetchClient } from './client/fetch.js';\nimport { XHRClient } from './client/xhr.js';\nimport { HttpClient } from './client/http.js';\n\nclass RemoteSource extends BaseSource {\n  /**\n   *\n   * @param {BaseClient} client\n   * @param {object} headers\n   * @param {numbers} maxRanges\n   * @param {boolean} allowFullFile\n   */\n  constructor(client, headers, maxRanges, allowFullFile) {\n    super();\n    this.client = client;\n    this.headers = headers;\n    this.maxRanges = maxRanges;\n    this.allowFullFile = allowFullFile;\n    this._fileSize = null;\n  }\n\n  /**\n   *\n   * @param {Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    // if we allow multi-ranges, split the incoming request into that many sub-requests\n    // and join them afterwards\n    if (this.maxRanges >= slices.length) {\n      return this.fetchSlices(slices, signal);\n    } else if (this.maxRanges > 0 && slices.length > 1) {\n      // TODO: split into multiple multi-range requests\n\n      // const subSlicesRequests = [];\n      // for (let i = 0; i < slices.length; i += this.maxRanges) {\n      //   subSlicesRequests.push(\n      //     this.fetchSlices(slices.slice(i, i + this.maxRanges), signal),\n      //   );\n      // }\n      // return (await Promise.all(subSlicesRequests)).flat();\n    }\n\n    // otherwise make a single request for each slice\n    return Promise.all(\n      slices.map((slice) => this.fetchSlice(slice, signal)),\n    );\n  }\n\n  async fetchSlices(slices, signal) {\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${slices\n          .map(({ offset, length }) => `${offset}-${offset + length}`)\n          .join(',')\n        }`,\n      },\n      signal,\n    });\n\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const { type, params } = parseContentType(response.getHeader('content-type'));\n      if (type === 'multipart/byteranges') {\n        const byteRanges = parseByteRanges(await response.getData(), params.boundary);\n        this._fileSize = byteRanges[0].fileSize || null;\n        return byteRanges;\n      }\n\n      const data = await response.getData();\n\n      const { start, end, total } = parseContentRange(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      const first = [{\n        data,\n        offset: start,\n        length: end - start,\n      }];\n\n      if (slices.length > 1) {\n        // we requested more than one slice, but got only the first\n        // unfortunately, some HTTP Servers don't support multi-ranges\n        // and return only the first\n\n        // get the rest of the slices and fetch them iteratively\n        const others = await Promise.all(slices.slice(1).map((slice) => this.fetchSlice(slice, signal)));\n        return first.concat(others);\n      }\n      return first;\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n      const data = await response.getData();\n      this._fileSize = data.byteLength;\n      return [{\n        data,\n        offset: 0,\n        length: data.byteLength,\n      }];\n    }\n  }\n\n  async fetchSlice(slice, signal) {\n    const { offset, length } = slice;\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${offset}-${offset + length}`,\n      },\n      signal,\n    });\n\n    // check the response was okay and if the server actually understands range requests\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const data = await response.getData();\n\n      const { total } = parseContentRange(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      return {\n        data,\n        offset,\n        length,\n      };\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n\n      const data = await response.getData();\n\n      this._fileSize = data.byteLength;\n      return {\n        data,\n        offset: 0,\n        length: data.byteLength,\n      };\n    }\n  }\n\n  get fileSize() {\n    return this._fileSize;\n  }\n}\n\nfunction maybeWrapInBlockedSource(source, { blockSize, cacheSize }) {\n  if (blockSize === null) {\n    return source;\n  }\n  return new BlockedSource(source, { blockSize, cacheSize });\n}\n\nexport function makeFetchSource(url, { headers = {}, credentials, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new FetchClient(url, credentials);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nexport function makeXHRSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new XHRClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nexport function makeHttpSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new HttpClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nexport function makeCustomSource(client, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\n/**\n *\n * @param {string} url\n * @param {object} options\n */\nexport function makeRemoteSource(url, { forceXHR = false, ...clientOptions } = {}) {\n  if (typeof fetch === 'function' && !forceXHR) {\n    return makeFetchSource(url, clientOptions);\n  }\n  if (typeof XMLHttpRequest !== 'undefined') {\n    return makeXHRSource(url, clientOptions);\n  }\n  return makeHttpSource(url, clientOptions);\n}\n","import { BaseSource } from './basesource.js';\n\nclass FileReaderSource extends BaseSource {\n  constructor(file) {\n    super();\n    this.file = file;\n  }\n\n  async fetchSlice(slice, signal) {\n    return new Promise((resolve, reject) => {\n      const blob = this.file.slice(slice.offset, slice.offset + slice.length);\n      const reader = new FileReader();\n      reader.onload = (event) => resolve(event.target.result);\n      reader.onerror = reject;\n      reader.onabort = reject;\n      reader.readAsArrayBuffer(blob);\n\n      if (signal) {\n        signal.addEventListener('abort', () => reader.abort());\n      }\n    });\n  }\n}\n\n/**\n * Create a new source from a given file/blob.\n * @param {Blob} file The file or blob to read from.\n * @returns The constructed source\n */\nexport function makeFileReaderSource(file) {\n  return new FileReaderSource(file);\n}\n","/** @module geotiff */\nimport GeoTIFFImage from './geotiffimage.js';\nimport DataView64 from './dataview64.js';\nimport DataSlice from './dataslice.js';\nimport Pool from './pool.js';\n\nimport { makeRemoteSource, makeCustomSource } from './source/remote.js';\nimport { makeBufferSource } from './source/arraybuffer.js';\nimport { makeFileReaderSource } from './source/filereader.js';\nimport { makeFileSource } from './source/file.js';\nimport { BaseClient, BaseResponse } from './source/client/base.js';\n\nimport { fieldTypes, fieldTagNames, arrayFields, geoKeyNames } from './globals.js';\nimport { writeGeotiff } from './geotiffwriter.js';\nimport * as globals from './globals.js';\nimport * as rgb from './rgb.js';\nimport { getDecoder, addDecoder } from './compression/index.js';\nimport { setLogger } from './logging.js';\n\nexport { globals };\nexport { rgb };\nexport { default as BaseDecoder } from './compression/basedecoder.js';\nexport { getDecoder, addDecoder };\nexport { setLogger };\n\n/**\n * @typedef {Uint8Array | Int8Array | Uint16Array | Int16Array | Uint32Array | Int32Array | Float32Array | Float64Array}\n * TypedArray\n */\n\n/**\n * @typedef {{ height:number, width: number }} Dimensions\n */\n\n/**\n * The autogenerated docs are a little confusing here. The effective type is:\n *\n * `TypedArray & { height: number; width: number}`\n * @typedef {TypedArray & Dimensions} TypedArrayWithDimensions\n */\n\n/**\n * The autogenerated docs are a little confusing here. The effective type is:\n *\n * `TypedArray[] & { height: number; width: number}`\n * @typedef {TypedArray[] & Dimensions} TypedArrayArrayWithDimensions\n */\n\n/**\n *  The autogenerated docs are a little confusing here. The effective type is:\n *\n * `(TypedArray | TypedArray[]) & { height: number; width: number}`\n * @typedef {TypedArrayWithDimensions | TypedArrayArrayWithDimensions} ReadRasterResult\n */\n\nfunction getFieldTypeLength(fieldType) {\n  switch (fieldType) {\n    case fieldTypes.BYTE: case fieldTypes.ASCII: case fieldTypes.SBYTE: case fieldTypes.UNDEFINED:\n      return 1;\n    case fieldTypes.SHORT: case fieldTypes.SSHORT:\n      return 2;\n    case fieldTypes.LONG: case fieldTypes.SLONG: case fieldTypes.FLOAT: case fieldTypes.IFD:\n      return 4;\n    case fieldTypes.RATIONAL: case fieldTypes.SRATIONAL: case fieldTypes.DOUBLE:\n    case fieldTypes.LONG8: case fieldTypes.SLONG8: case fieldTypes.IFD8:\n      return 8;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n}\n\nfunction parseGeoKeyDirectory(fileDirectory) {\n  const rawGeoKeyDirectory = fileDirectory.GeoKeyDirectory;\n  if (!rawGeoKeyDirectory) {\n    return null;\n  }\n\n  const geoKeyDirectory = {};\n  for (let i = 4; i <= rawGeoKeyDirectory[3] * 4; i += 4) {\n    const key = geoKeyNames[rawGeoKeyDirectory[i]];\n    const location = (rawGeoKeyDirectory[i + 1])\n      ? (fieldTagNames[rawGeoKeyDirectory[i + 1]]) : null;\n    const count = rawGeoKeyDirectory[i + 2];\n    const offset = rawGeoKeyDirectory[i + 3];\n\n    let value = null;\n    if (!location) {\n      value = offset;\n    } else {\n      value = fileDirectory[location];\n      if (typeof value === 'undefined' || value === null) {\n        throw new Error(`Could not get value of geoKey '${key}'.`);\n      } else if (typeof value === 'string') {\n        value = value.substring(offset, offset + count - 1);\n      } else if (value.subarray) {\n        value = value.subarray(offset, offset + count);\n        if (count === 1) {\n          value = value[0];\n        }\n      }\n    }\n    geoKeyDirectory[key] = value;\n  }\n  return geoKeyDirectory;\n}\n\nfunction getValues(dataSlice, fieldType, count, offset) {\n  let values = null;\n  let readMethod = null;\n  const fieldTypeLength = getFieldTypeLength(fieldType);\n\n  switch (fieldType) {\n    case fieldTypes.BYTE: case fieldTypes.ASCII: case fieldTypes.UNDEFINED:\n      values = new Uint8Array(count); readMethod = dataSlice.readUint8;\n      break;\n    case fieldTypes.SBYTE:\n      values = new Int8Array(count); readMethod = dataSlice.readInt8;\n      break;\n    case fieldTypes.SHORT:\n      values = new Uint16Array(count); readMethod = dataSlice.readUint16;\n      break;\n    case fieldTypes.SSHORT:\n      values = new Int16Array(count); readMethod = dataSlice.readInt16;\n      break;\n    case fieldTypes.LONG: case fieldTypes.IFD:\n      values = new Uint32Array(count); readMethod = dataSlice.readUint32;\n      break;\n    case fieldTypes.SLONG:\n      values = new Int32Array(count); readMethod = dataSlice.readInt32;\n      break;\n    case fieldTypes.LONG8: case fieldTypes.IFD8:\n      values = new Array(count); readMethod = dataSlice.readUint64;\n      break;\n    case fieldTypes.SLONG8:\n      values = new Array(count); readMethod = dataSlice.readInt64;\n      break;\n    case fieldTypes.RATIONAL:\n      values = new Uint32Array(count * 2); readMethod = dataSlice.readUint32;\n      break;\n    case fieldTypes.SRATIONAL:\n      values = new Int32Array(count * 2); readMethod = dataSlice.readInt32;\n      break;\n    case fieldTypes.FLOAT:\n      values = new Float32Array(count); readMethod = dataSlice.readFloat32;\n      break;\n    case fieldTypes.DOUBLE:\n      values = new Float64Array(count); readMethod = dataSlice.readFloat64;\n      break;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n\n  // normal fields\n  if (!(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {\n    for (let i = 0; i < count; ++i) {\n      values[i] = readMethod.call(\n        dataSlice, offset + (i * fieldTypeLength),\n      );\n    }\n  } else { // RATIONAL or SRATIONAL\n    for (let i = 0; i < count; i += 2) {\n      values[i] = readMethod.call(\n        dataSlice, offset + (i * fieldTypeLength),\n      );\n      values[i + 1] = readMethod.call(\n        dataSlice, offset + ((i * fieldTypeLength) + 4),\n      );\n    }\n  }\n\n  if (fieldType === fieldTypes.ASCII) {\n    return new TextDecoder('utf-8').decode(values);\n  }\n  return values;\n}\n\n/**\n * Data class to store the parsed file directory, geo key directory and\n * offset to the next IFD\n */\nclass ImageFileDirectory {\n  constructor(fileDirectory, geoKeyDirectory, nextIFDByteOffset) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeyDirectory = geoKeyDirectory;\n    this.nextIFDByteOffset = nextIFDByteOffset;\n  }\n}\n\n/**\n * Error class for cases when an IFD index was requested, that does not exist\n * in the file.\n */\nclass GeoTIFFImageIndexError extends Error {\n  constructor(index) {\n    super(`No image at index ${index}`);\n    this.index = index;\n  }\n}\n\nclass GeoTIFFBase {\n  /**\n   * (experimental) Reads raster data from the best fitting image. This function uses\n   * the image with the lowest resolution that is still a higher resolution than the\n   * requested resolution.\n   * When specified, the `bbox` option is translated to the `window` option and the\n   * `resX` and `resY` to `width` and `height` respectively.\n   * Then, the [readRasters]{@link GeoTIFFImage#readRasters} method of the selected\n   * image is called and the result returned.\n   * @see GeoTIFFImage.readRasters\n   * @param {import('./geotiffimage').ReadRasterOptions} [options={}] optional parameters\n   * @returns {Promise<ReadRasterResult>} the decoded array(s), with `height` and `width`, as a promise\n   */\n  async readRasters(options = {}) {\n    const { window: imageWindow, width, height } = options;\n    let { resX, resY, bbox } = options;\n\n    const firstImage = await this.getImage();\n    let usedImage = firstImage;\n    const imageCount = await this.getImageCount();\n    const imgBBox = firstImage.getBoundingBox();\n\n    if (imageWindow && bbox) {\n      throw new Error('Both \"bbox\" and \"window\" passed.');\n    }\n\n    // if width/height is passed, transform it to resolution\n    if (width || height) {\n      // if we have an image window (pixel coordinates), transform it to a BBox\n      // using the origin/resolution of the first image.\n      if (imageWindow) {\n        const [oX, oY] = firstImage.getOrigin();\n        const [rX, rY] = firstImage.getResolution();\n\n        bbox = [\n          oX + (imageWindow[0] * rX),\n          oY + (imageWindow[1] * rY),\n          oX + (imageWindow[2] * rX),\n          oY + (imageWindow[3] * rY),\n        ];\n      }\n\n      // if we have a bbox (or calculated one)\n\n      const usedBBox = bbox || imgBBox;\n\n      if (width) {\n        if (resX) {\n          throw new Error('Both width and resX passed');\n        }\n        resX = (usedBBox[2] - usedBBox[0]) / width;\n      }\n      if (height) {\n        if (resY) {\n          throw new Error('Both width and resY passed');\n        }\n        resY = (usedBBox[3] - usedBBox[1]) / height;\n      }\n    }\n\n    // if resolution is set or calculated, try to get the image with the worst acceptable resolution\n    if (resX || resY) {\n      const allImages = [];\n      for (let i = 0; i < imageCount; ++i) {\n        const image = await this.getImage(i);\n        const { SubfileType: subfileType, NewSubfileType: newSubfileType } = image.fileDirectory;\n        if (i === 0 || subfileType === 2 || newSubfileType & 1) {\n          allImages.push(image);\n        }\n      }\n\n      allImages.sort((a, b) => a.getWidth() - b.getWidth());\n      for (let i = 0; i < allImages.length; ++i) {\n        const image = allImages[i];\n        const imgResX = (imgBBox[2] - imgBBox[0]) / image.getWidth();\n        const imgResY = (imgBBox[3] - imgBBox[1]) / image.getHeight();\n\n        usedImage = image;\n        if ((resX && resX > imgResX) || (resY && resY > imgResY)) {\n          break;\n        }\n      }\n    }\n\n    let wnd = imageWindow;\n    if (bbox) {\n      const [oX, oY] = firstImage.getOrigin();\n      const [imageResX, imageResY] = usedImage.getResolution(firstImage);\n\n      wnd = [\n        Math.round((bbox[0] - oX) / imageResX),\n        Math.round((bbox[1] - oY) / imageResY),\n        Math.round((bbox[2] - oX) / imageResX),\n        Math.round((bbox[3] - oY) / imageResY),\n      ];\n      wnd = [\n        Math.min(wnd[0], wnd[2]),\n        Math.min(wnd[1], wnd[3]),\n        Math.max(wnd[0], wnd[2]),\n        Math.max(wnd[1], wnd[3]),\n      ];\n    }\n\n    return usedImage.readRasters({ ...options, window: wnd });\n  }\n}\n\n/**\n * @typedef {Object} GeoTIFFOptions\n * @property {boolean} [cache=false] whether or not decoded tiles shall be cached.\n */\n\n/**\n * The abstraction for a whole GeoTIFF file.\n * @augments GeoTIFFBase\n */\nclass GeoTIFF extends GeoTIFFBase {\n  /**\n   * @constructor\n   * @param {*} source The datasource to read from.\n   * @param {boolean} littleEndian Whether the image uses little endian.\n   * @param {boolean} bigTiff Whether the image uses bigTIFF conventions.\n   * @param {number} firstIFDOffset The numeric byte-offset from the start of the image\n   *                                to the first IFD.\n   * @param {GeoTIFFOptions} [options] further options.\n   */\n  constructor(source, littleEndian, bigTiff, firstIFDOffset, options = {}) {\n    super();\n    this.source = source;\n    this.littleEndian = littleEndian;\n    this.bigTiff = bigTiff;\n    this.firstIFDOffset = firstIFDOffset;\n    this.cache = options.cache || false;\n    this.ifdRequests = [];\n    this.ghostValues = null;\n  }\n\n  async getSlice(offset, size) {\n    const fallbackSize = this.bigTiff ? 4048 : 1024;\n    return new DataSlice(\n      (await this.source.fetch([{\n        offset,\n        length: typeof size !== 'undefined' ? size : fallbackSize,\n      }]))[0],\n      offset,\n      this.littleEndian,\n      this.bigTiff,\n    );\n  }\n\n  /**\n   * Instructs to parse an image file directory at the given file offset.\n   * As there is no way to ensure that a location is indeed the start of an IFD,\n   * this function must be called with caution (e.g only using the IFD offsets from\n   * the headers or other IFDs).\n   * @param {number} offset the offset to parse the IFD at\n   * @returns {Promise<ImageFileDirectory>} the parsed IFD\n   */\n  async parseFileDirectoryAt(offset) {\n    const entrySize = this.bigTiff ? 20 : 12;\n    const offsetSize = this.bigTiff ? 8 : 2;\n\n    let dataSlice = await this.getSlice(offset);\n    const numDirEntries = this.bigTiff\n      ? dataSlice.readUint64(offset)\n      : dataSlice.readUint16(offset);\n\n    // if the slice does not cover the whole IFD, request a bigger slice, where the\n    // whole IFD fits: num of entries + n x tag length + offset to next IFD\n    const byteSize = (numDirEntries * entrySize) + (this.bigTiff ? 16 : 6);\n    if (!dataSlice.covers(offset, byteSize)) {\n      dataSlice = await this.getSlice(offset, byteSize);\n    }\n\n    const fileDirectory = {};\n\n    // loop over the IFD and create a file directory object\n    let i = offset + (this.bigTiff ? 8 : 2);\n    for (let entryCount = 0; entryCount < numDirEntries; i += entrySize, ++entryCount) {\n      const fieldTag = dataSlice.readUint16(i);\n      const fieldType = dataSlice.readUint16(i + 2);\n      const typeCount = this.bigTiff\n        ? dataSlice.readUint64(i + 4)\n        : dataSlice.readUint32(i + 4);\n\n      let fieldValues;\n      let value;\n      const fieldTypeLength = getFieldTypeLength(fieldType);\n      const valueOffset = i + (this.bigTiff ? 12 : 8);\n\n      // check whether the value is directly encoded in the tag or refers to a\n      // different external byte range\n      if (fieldTypeLength * typeCount <= (this.bigTiff ? 8 : 4)) {\n        fieldValues = getValues(dataSlice, fieldType, typeCount, valueOffset);\n      } else {\n        // resolve the reference to the actual byte range\n        const actualOffset = dataSlice.readOffset(valueOffset);\n        const length = getFieldTypeLength(fieldType) * typeCount;\n\n        // check, whether we actually cover the referenced byte range; if not,\n        // request a new slice of bytes to read from it\n        if (dataSlice.covers(actualOffset, length)) {\n          fieldValues = getValues(dataSlice, fieldType, typeCount, actualOffset);\n        } else {\n          const fieldDataSlice = await this.getSlice(actualOffset, length);\n          fieldValues = getValues(fieldDataSlice, fieldType, typeCount, actualOffset);\n        }\n      }\n\n      // unpack single values from the array\n      if (typeCount === 1 && arrayFields.indexOf(fieldTag) === -1\n        && !(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {\n        value = fieldValues[0];\n      } else {\n        value = fieldValues;\n      }\n\n      // write the tags value to the file directly\n      fileDirectory[fieldTagNames[fieldTag]] = value;\n    }\n    const geoKeyDirectory = parseGeoKeyDirectory(fileDirectory);\n    const nextIFDByteOffset = dataSlice.readOffset(\n      offset + offsetSize + (entrySize * numDirEntries),\n    );\n\n    return new ImageFileDirectory(\n      fileDirectory,\n      geoKeyDirectory,\n      nextIFDByteOffset,\n    );\n  }\n\n  async requestIFD(index) {\n    // see if we already have that IFD index requested.\n    if (this.ifdRequests[index]) {\n      // attach to an already requested IFD\n      return this.ifdRequests[index];\n    } else if (index === 0) {\n      // special case for index 0\n      this.ifdRequests[index] = this.parseFileDirectoryAt(this.firstIFDOffset);\n      return this.ifdRequests[index];\n    } else if (!this.ifdRequests[index - 1]) {\n      // if the previous IFD was not yet loaded, load that one first\n      // this is the recursive call.\n      try {\n        this.ifdRequests[index - 1] = this.requestIFD(index - 1);\n      } catch (e) {\n        // if the previous one already was an index error, rethrow\n        // with the current index\n        if (e instanceof GeoTIFFImageIndexError) {\n          throw new GeoTIFFImageIndexError(index);\n        }\n        // rethrow anything else\n        throw e;\n      }\n    }\n    // if the previous IFD was loaded, we can finally fetch the one we are interested in.\n    // we need to wrap this in an IIFE, otherwise this.ifdRequests[index] would be delayed\n    this.ifdRequests[index] = (async () => {\n      const previousIfd = await this.ifdRequests[index - 1];\n      if (previousIfd.nextIFDByteOffset === 0) {\n        throw new GeoTIFFImageIndexError(index);\n      }\n      return this.parseFileDirectoryAt(previousIfd.nextIFDByteOffset);\n    })();\n    return this.ifdRequests[index];\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {number} [index=0] the index of the image to return.\n   * @returns {Promise<GeoTIFFImage>} the image at the given index\n   */\n  async getImage(index = 0) {\n    const ifd = await this.requestIFD(index);\n    return new GeoTIFFImage(\n      ifd.fileDirectory, ifd.geoKeyDirectory,\n      this.dataView, this.littleEndian, this.cache, this.source,\n    );\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Promise<number>} the number of internal subfile images\n   */\n  async getImageCount() {\n    let index = 0;\n    // loop until we run out of IFDs\n    let hasNext = true;\n    while (hasNext) {\n      try {\n        await this.requestIFD(index);\n        ++index;\n      } catch (e) {\n        if (e instanceof GeoTIFFImageIndexError) {\n          hasNext = false;\n        } else {\n          throw e;\n        }\n      }\n    }\n    return index;\n  }\n\n  /**\n   * Get the values of the COG ghost area as a parsed map.\n   * See https://gdal.org/drivers/raster/cog.html#header-ghost-area for reference\n   * @returns {Promise<Object>} the parsed ghost area or null, if no such area was found\n   */\n  async getGhostValues() {\n    const offset = this.bigTiff ? 16 : 8;\n    if (this.ghostValues) {\n      return this.ghostValues;\n    }\n    const detectionString = 'GDAL_STRUCTURAL_METADATA_SIZE=';\n    const heuristicAreaSize = detectionString.length + 100;\n    let slice = await this.getSlice(offset, heuristicAreaSize);\n    if (detectionString === getValues(slice, fieldTypes.ASCII, detectionString.length, offset)) {\n      const valuesString = getValues(slice, fieldTypes.ASCII, heuristicAreaSize, offset);\n      const firstLine = valuesString.split('\\n')[0];\n      const metadataSize = Number(firstLine.split('=')[1].split(' ')[0]) + firstLine.length;\n      if (metadataSize > heuristicAreaSize) {\n        slice = await this.getSlice(offset, metadataSize);\n      }\n      const fullString = getValues(slice, fieldTypes.ASCII, metadataSize, offset);\n      this.ghostValues = {};\n      fullString\n        .split('\\n')\n        .filter((line) => line.length > 0)\n        .map((line) => line.split('='))\n        .forEach(([key, value]) => {\n          this.ghostValues[key] = value;\n        });\n    }\n    return this.ghostValues;\n  }\n\n  /**\n   * Parse a (Geo)TIFF file from the given source.\n   *\n   * @param {*} source The source of data to parse from.\n   * @param {GeoTIFFOptions} [options] Additional options.\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   */\n  static async fromSource(source, options, signal) {\n    const headerData = (await source.fetch([{ offset: 0, length: 1024 }], signal))[0];\n    const dataView = new DataView64(headerData);\n\n    const BOM = dataView.getUint16(0, 0);\n    let littleEndian;\n    if (BOM === 0x4949) {\n      littleEndian = true;\n    } else if (BOM === 0x4D4D) {\n      littleEndian = false;\n    } else {\n      throw new TypeError('Invalid byte order value.');\n    }\n\n    const magicNumber = dataView.getUint16(2, littleEndian);\n    let bigTiff;\n    if (magicNumber === 42) {\n      bigTiff = false;\n    } else if (magicNumber === 43) {\n      bigTiff = true;\n      const offsetByteSize = dataView.getUint16(4, littleEndian);\n      if (offsetByteSize !== 8) {\n        throw new Error('Unsupported offset byte-size.');\n      }\n    } else {\n      throw new TypeError('Invalid magic number.');\n    }\n\n    const firstIFDOffset = bigTiff\n      ? dataView.getUint64(8, littleEndian)\n      : dataView.getUint32(4, littleEndian);\n    return new GeoTIFF(source, littleEndian, bigTiff, firstIFDOffset, options);\n  }\n\n  /**\n   * Closes the underlying file buffer\n   * N.B. After the GeoTIFF has been completely processed it needs\n   * to be closed but only if it has been constructed from a file.\n   */\n  close() {\n    if (typeof this.source.close === 'function') {\n      return this.source.close();\n    }\n    return false;\n  }\n}\n\nexport { GeoTIFF };\nexport default GeoTIFF;\n\n/**\n * Wrapper for GeoTIFF files that have external overviews.\n * @augments GeoTIFFBase\n */\nclass MultiGeoTIFF extends GeoTIFFBase {\n  /**\n   * Construct a new MultiGeoTIFF from a main and several overview files.\n   * @param {GeoTIFF} mainFile The main GeoTIFF file.\n   * @param {GeoTIFF[]} overviewFiles An array of overview files.\n   */\n  constructor(mainFile, overviewFiles) {\n    super();\n    this.mainFile = mainFile;\n    this.overviewFiles = overviewFiles;\n    this.imageFiles = [mainFile].concat(overviewFiles);\n\n    this.fileDirectoriesPerFile = null;\n    this.fileDirectoriesPerFileParsing = null;\n    this.imageCount = null;\n  }\n\n  async parseFileDirectoriesPerFile() {\n    const requests = [this.mainFile.parseFileDirectoryAt(this.mainFile.firstIFDOffset)]\n      .concat(this.overviewFiles.map((file) => file.parseFileDirectoryAt(file.firstIFDOffset)));\n\n    this.fileDirectoriesPerFile = await Promise.all(requests);\n    return this.fileDirectoriesPerFile;\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {number} [index=0] the index of the image to return.\n   * @returns {Promise<GeoTIFFImage>} the image at the given index\n   */\n  async getImage(index = 0) {\n    await this.getImageCount();\n    await this.parseFileDirectoriesPerFile();\n    let visited = 0;\n    let relativeIndex = 0;\n    for (let i = 0; i < this.imageFiles.length; i++) {\n      const imageFile = this.imageFiles[i];\n      for (let ii = 0; ii < this.imageCounts[i]; ii++) {\n        if (index === visited) {\n          const ifd = await imageFile.requestIFD(relativeIndex);\n          return new GeoTIFFImage(\n            ifd.fileDirectory, ifd.geoKeyDirectory,\n            imageFile.dataView, imageFile.littleEndian, imageFile.cache, imageFile.source,\n          );\n        }\n        visited++;\n        relativeIndex++;\n      }\n      relativeIndex = 0;\n    }\n\n    throw new RangeError('Invalid image index');\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Promise<number>} the number of internal subfile images\n   */\n  async getImageCount() {\n    if (this.imageCount !== null) {\n      return this.imageCount;\n    }\n    const requests = [this.mainFile.getImageCount()]\n      .concat(this.overviewFiles.map((file) => file.getImageCount()));\n    this.imageCounts = await Promise.all(requests);\n    this.imageCount = this.imageCounts.reduce((count, ifds) => count + ifds, 0);\n    return this.imageCount;\n  }\n}\n\nexport { MultiGeoTIFF };\n\n/**\n * Creates a new GeoTIFF from a remote URL.\n * @param {string} url The URL to access the image from\n * @param {object} [options] Additional options to pass to the source.\n *                           See {@link makeRemoteSource} for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromUrl(url, options = {}, signal) {\n  return GeoTIFF.fromSource(makeRemoteSource(url, options), signal);\n}\n\n/**\n * Creates a new GeoTIFF from a custom {@link BaseClient}.\n * @param {BaseClient} client The client.\n * @param {object} [options] Additional options to pass to the source.\n *                           See {@link makeRemoteSource} for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromCustomClient(client, options = {}, signal) {\n  return GeoTIFF.fromSource(makeCustomSource(client, options), signal);\n}\n\n/**\n * Construct a new GeoTIFF from an\n * [ArrayBuffer]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer}.\n * @param {ArrayBuffer} arrayBuffer The data to read the file from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromArrayBuffer(arrayBuffer, signal) {\n  return GeoTIFF.fromSource(makeBufferSource(arrayBuffer), signal);\n}\n\n/**\n * Construct a GeoTIFF from a local file path. This uses the node\n * [filesystem API]{@link https://nodejs.org/api/fs.html} and is\n * not available on browsers.\n *\n * N.B. After the GeoTIFF has been completely processed it needs\n * to be closed but only if it has been constructed from a file.\n * @param {string} path The file path to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromFile(path, signal) {\n  return GeoTIFF.fromSource(makeFileSource(path), signal);\n}\n\n/**\n * Construct a GeoTIFF from an HTML\n * [Blob]{@link https://developer.mozilla.org/en-US/docs/Web/API/Blob} or\n * [File]{@link https://developer.mozilla.org/en-US/docs/Web/API/File}\n * object.\n * @param {Blob|File} blob The Blob or File object to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromBlob(blob, signal) {\n  return GeoTIFF.fromSource(makeFileReaderSource(blob), signal);\n}\n\n/**\n * Construct a MultiGeoTIFF from the given URLs.\n * @param {string} mainUrl The URL for the main file.\n * @param {string[]} overviewUrls An array of URLs for the overview images.\n * @param {Object} [options] Additional options to pass to the source.\n *                           See [makeRemoteSource]{@link module:source.makeRemoteSource}\n *                           for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<MultiGeoTIFF>} The resulting MultiGeoTIFF file.\n */\nexport async function fromUrls(mainUrl, overviewUrls = [], options = {}, signal) {\n  const mainFile = await GeoTIFF.fromSource(makeRemoteSource(mainUrl, options), signal);\n  const overviewFiles = await Promise.all(\n    overviewUrls.map((url) => GeoTIFF.fromSource(makeRemoteSource(url, options))),\n  );\n\n  return new MultiGeoTIFF(mainFile, overviewFiles);\n}\n\n/**\n * Main creating function for GeoTIFF files.\n * @param {(Array)} array of pixel values\n * @returns {metadata} metadata\n */\nexport function writeArrayBuffer(values, metadata) {\n  return writeGeotiff(values, metadata);\n}\n\nexport { Pool };\nexport { GeoTIFFImage };\nexport { BaseClient, BaseResponse };\n","export function fromWhiteIsZero(raster, max) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  let value;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    value = 256 - (raster[i] / max * 256);\n    rgbRaster[j] = value;\n    rgbRaster[j + 1] = value;\n    rgbRaster[j + 2] = value;\n  }\n  return rgbRaster;\n}\n\nexport function fromBlackIsZero(raster, max) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  let value;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    value = raster[i] / max * 256;\n    rgbRaster[j] = value;\n    rgbRaster[j + 1] = value;\n    rgbRaster[j + 2] = value;\n  }\n  return rgbRaster;\n}\n\nexport function fromPalette(raster, colorMap) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  const greenOffset = colorMap.length / 3;\n  const blueOffset = colorMap.length / 3 * 2;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    const mapIndex = raster[i];\n    rgbRaster[j] = colorMap[mapIndex] / 65536 * 256;\n    rgbRaster[j + 1] = colorMap[mapIndex + greenOffset] / 65536 * 256;\n    rgbRaster[j + 2] = colorMap[mapIndex + blueOffset] / 65536 * 256;\n  }\n  return rgbRaster;\n}\n\nexport function fromCMYK(cmykRaster) {\n  const { width, height } = cmykRaster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  for (let i = 0, j = 0; i < cmykRaster.length; i += 4, j += 3) {\n    const c = cmykRaster[i];\n    const m = cmykRaster[i + 1];\n    const y = cmykRaster[i + 2];\n    const k = cmykRaster[i + 3];\n\n    rgbRaster[j] = 255 * ((255 - c) / 256) * ((255 - k) / 256);\n    rgbRaster[j + 1] = 255 * ((255 - m) / 256) * ((255 - k) / 256);\n    rgbRaster[j + 2] = 255 * ((255 - y) / 256) * ((255 - k) / 256);\n  }\n  return rgbRaster;\n}\n\nexport function fromYCbCr(yCbCrRaster) {\n  const { width, height } = yCbCrRaster;\n  const rgbRaster = new Uint8ClampedArray(width * height * 3);\n  for (let i = 0, j = 0; i < yCbCrRaster.length; i += 3, j += 3) {\n    const y = yCbCrRaster[i];\n    const cb = yCbCrRaster[i + 1];\n    const cr = yCbCrRaster[i + 2];\n\n    rgbRaster[j] = (y + (1.40200 * (cr - 0x80)));\n    rgbRaster[j + 1] = (y - (0.34414 * (cb - 0x80)) - (0.71414 * (cr - 0x80)));\n    rgbRaster[j + 2] = (y + (1.77200 * (cb - 0x80)));\n  }\n  return rgbRaster;\n}\n\nconst Xn = 0.95047;\nconst Yn = 1.00000;\nconst Zn = 1.08883;\n\n// from https://github.com/antimatter15/rgb-lab/blob/master/color.js\n\nexport function fromCIELab(cieLabRaster) {\n  const { width, height } = cieLabRaster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n\n  for (let i = 0, j = 0; i < cieLabRaster.length; i += 3, j += 3) {\n    const L = cieLabRaster[i + 0];\n    const a_ = cieLabRaster[i + 1] << 24 >> 24; // conversion from uint8 to int8\n    const b_ = cieLabRaster[i + 2] << 24 >> 24; // same\n\n    let y = (L + 16) / 116;\n    let x = (a_ / 500) + y;\n    let z = y - (b_ / 200);\n    let r;\n    let g;\n    let b;\n\n    x = Xn * ((x * x * x > 0.008856) ? x * x * x : (x - (16 / 116)) / 7.787);\n    y = Yn * ((y * y * y > 0.008856) ? y * y * y : (y - (16 / 116)) / 7.787);\n    z = Zn * ((z * z * z > 0.008856) ? z * z * z : (z - (16 / 116)) / 7.787);\n\n    r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n    g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n    b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\n    r = (r > 0.0031308) ? ((1.055 * (r ** (1 / 2.4))) - 0.055) : 12.92 * r;\n    g = (g > 0.0031308) ? ((1.055 * (g ** (1 / 2.4))) - 0.055) : 12.92 * g;\n    b = (b > 0.0031308) ? ((1.055 * (b ** (1 / 2.4))) - 0.055) : 12.92 * b;\n\n    rgbRaster[j] = Math.max(0, Math.min(1, r)) * 255;\n    rgbRaster[j + 1] = Math.max(0, Math.min(1, g)) * 255;\n    rgbRaster[j + 2] = Math.max(0, Math.min(1, b)) * 255;\n  }\n  return rgbRaster;\n}\n","/**\n * @module resample\n */\n\nfunction copyNewSize(array, width, height, samplesPerPixel = 1) {\n  return new (Object.getPrototypeOf(array).constructor)(width * height * samplesPerPixel);\n}\n\n/**\n * Resample the input arrays using nearest neighbor value selection.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  return valueArrays.map((array) => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n    for (let y = 0; y < outHeight; ++y) {\n      const cy = Math.min(Math.round(relY * y), inHeight - 1);\n      for (let x = 0; x < outWidth; ++x) {\n        const cx = Math.min(Math.round(relX * x), inWidth - 1);\n        const value = array[(cy * inWidth) + cx];\n        newArray[(y * outWidth) + x] = value;\n      }\n    }\n    return newArray;\n  });\n}\n\n// simple linear interpolation, code from:\n// https://en.wikipedia.org/wiki/Linear_interpolation#Programming_language_support\nfunction lerp(v0, v1, t) {\n  return ((1 - t) * v0) + (t * v1);\n}\n\n/**\n * Resample the input arrays using bilinear interpolation.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n\n  return valueArrays.map((array) => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n    for (let y = 0; y < outHeight; ++y) {\n      const rawY = relY * y;\n\n      const yl = Math.floor(rawY);\n      const yh = Math.min(Math.ceil(rawY), (inHeight - 1));\n\n      for (let x = 0; x < outWidth; ++x) {\n        const rawX = relX * x;\n        const tx = rawX % 1;\n\n        const xl = Math.floor(rawX);\n        const xh = Math.min(Math.ceil(rawX), (inWidth - 1));\n\n        const ll = array[(yl * inWidth) + xl];\n        const hl = array[(yl * inWidth) + xh];\n        const lh = array[(yh * inWidth) + xl];\n        const hh = array[(yh * inWidth) + xh];\n\n        const value = lerp(\n          lerp(ll, hl, tx),\n          lerp(lh, hh, tx),\n          rawY % 1,\n        );\n        newArray[(y * outWidth) + x] = value;\n      }\n    }\n    return newArray;\n  });\n}\n\n/**\n * Resample the input arrays using the selected resampling method.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resample(valueArrays, inWidth, inHeight, outWidth, outHeight, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight);\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight);\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n\n/**\n * Resample the pixel interleaved input array using nearest neighbor value selection.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\nexport function resampleNearestInterleaved(\n  valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n  for (let y = 0; y < outHeight; ++y) {\n    const cy = Math.min(Math.round(relY * y), inHeight - 1);\n    for (let x = 0; x < outWidth; ++x) {\n      const cx = Math.min(Math.round(relX * x), inWidth - 1);\n      for (let i = 0; i < samples; ++i) {\n        const value = valueArray[(cy * inWidth * samples) + (cx * samples) + i];\n        newArray[(y * outWidth * samples) + (x * samples) + i] = value;\n      }\n    }\n  }\n  return newArray;\n}\n\n/**\n * Resample the pixel interleaved input array using bilinear interpolation.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\nexport function resampleBilinearInterleaved(\n  valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n  for (let y = 0; y < outHeight; ++y) {\n    const rawY = relY * y;\n\n    const yl = Math.floor(rawY);\n    const yh = Math.min(Math.ceil(rawY), (inHeight - 1));\n\n    for (let x = 0; x < outWidth; ++x) {\n      const rawX = relX * x;\n      const tx = rawX % 1;\n\n      const xl = Math.floor(rawX);\n      const xh = Math.min(Math.ceil(rawX), (inWidth - 1));\n\n      for (let i = 0; i < samples; ++i) {\n        const ll = valueArray[(yl * inWidth * samples) + (xl * samples) + i];\n        const hl = valueArray[(yl * inWidth * samples) + (xh * samples) + i];\n        const lh = valueArray[(yh * inWidth * samples) + (xl * samples) + i];\n        const hh = valueArray[(yh * inWidth * samples) + (xh * samples) + i];\n\n        const value = lerp(\n          lerp(ll, hl, tx),\n          lerp(lh, hh, tx),\n          rawY % 1,\n        );\n        newArray[(y * outWidth * samples) + (x * samples) + i] = value;\n      }\n    }\n  }\n  return newArray;\n}\n\n/**\n * Resample the pixel interleaved input array using the selected resampling method.\n * @param {TypedArray} valueArray The input array to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                                 interleaved data\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray} The resampled rasters\n */\nexport function resampleInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearestInterleaved(\n        valueArray, inWidth, inHeight, outWidth, outHeight, samples,\n      );\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinearInterleaved(\n        valueArray, inWidth, inHeight, outWidth, outHeight, samples,\n      );\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n","/** @module geotiffimage */\nimport { getFloat16 } from '@petamoriken/float16';\nimport getAttribute from 'xml-utils/get-attribute.js';\nimport findTagsByName from 'xml-utils/find-tags-by-name.js';\n\nimport { photometricInterpretations, ExtraSamplesValues } from './globals.js';\nimport { fromWhiteIsZero, fromBlackIsZero, fromPalette, fromCMYK, fromYCbCr, fromCIELab } from './rgb.js';\nimport { getDecoder } from './compression/index.js';\nimport { resample, resampleInterleaved } from './resample.js';\n\n/**\n * @typedef {Object} ReadRasterOptions\n * @property {Array<number>} [window=whole window] the subset to read data from in pixels.\n * @property {Array<number>} [bbox=whole image] the subset to read data from in\n *                                           geographical coordinates.\n * @property {Array<number>} [samples=all samples] the selection of samples to read from. Default is all samples.\n * @property {boolean} [interleave=false] whether the data shall be read\n *                                             in one single array or separate\n *                                             arrays.\n * @property {Pool} [pool=null] The optional decoder pool to use.\n * @property {number} [width] The desired width of the output. When the width is not the\n *                                 same as the images, resampling will be performed.\n * @property {number} [height] The desired height of the output. When the width is not the\n *                                  same as the images, resampling will be performed.\n * @property {string} [resampleMethod='nearest'] The desired resampling method.\n * @property {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                                       to be aborted\n * @property {number|number[]} [fillValue] The value to use for parts of the image\n *                                              outside of the images extent. When multiple\n *                                              samples are requested, an array of fill values\n *                                              can be passed.\n */\n\n/** @typedef {import(\"./geotiff.js\").TypedArray} TypedArray */\n/** @typedef {import(\"./geotiff.js\").ReadRasterResult} ReadRasterResult */\n\nfunction sum(array, start, end) {\n  let s = 0;\n  for (let i = start; i < end; ++i) {\n    s += array[i];\n  }\n  return s;\n}\n\nfunction arrayForType(format, bitsPerSample, size) {\n  switch (format) {\n    case 1: // unsigned integer data\n      if (bitsPerSample <= 8) {\n        return new Uint8Array(size);\n      } else if (bitsPerSample <= 16) {\n        return new Uint16Array(size);\n      } else if (bitsPerSample <= 32) {\n        return new Uint32Array(size);\n      }\n      break;\n    case 2: // twos complement signed integer data\n      if (bitsPerSample === 8) {\n        return new Int8Array(size);\n      } else if (bitsPerSample === 16) {\n        return new Int16Array(size);\n      } else if (bitsPerSample === 32) {\n        return new Int32Array(size);\n      }\n      break;\n    case 3: // floating point data\n      switch (bitsPerSample) {\n        case 16:\n        case 32:\n          return new Float32Array(size);\n        case 64:\n          return new Float64Array(size);\n        default:\n          break;\n      }\n      break;\n    default:\n      break;\n  }\n  throw Error('Unsupported data format/bitsPerSample');\n}\n\nfunction needsNormalization(format, bitsPerSample) {\n  if ((format === 1 || format === 2) && bitsPerSample <= 32 && bitsPerSample % 8 === 0) {\n    return false;\n  } else if (format === 3 && (bitsPerSample === 16 || bitsPerSample === 32 || bitsPerSample === 64)) {\n    return false;\n  }\n  return true;\n}\n\nfunction normalizeArray(inBuffer, format, planarConfiguration, samplesPerPixel, bitsPerSample, tileWidth, tileHeight) {\n  // const inByteArray = new Uint8Array(inBuffer);\n  const view = new DataView(inBuffer);\n  const outSize = planarConfiguration === 2\n    ? tileHeight * tileWidth\n    : tileHeight * tileWidth * samplesPerPixel;\n  const samplesToTransfer = planarConfiguration === 2\n    ? 1 : samplesPerPixel;\n  const outArray = arrayForType(format, bitsPerSample, outSize);\n  // let pixel = 0;\n\n  const bitMask = parseInt('1'.repeat(bitsPerSample), 2);\n\n  if (format === 1) { // unsigned integer\n    // translation of https://github.com/OSGeo/gdal/blob/master/gdal/frmts/gtiff/geotiff.cpp#L7337\n    let pixelBitSkip;\n    // let sampleBitOffset = 0;\n    if (planarConfiguration === 1) {\n      pixelBitSkip = samplesPerPixel * bitsPerSample;\n      // sampleBitOffset = (samplesPerPixel - 1) * bitsPerSample;\n    } else {\n      pixelBitSkip = bitsPerSample;\n    }\n\n    // Bits per line rounds up to next byte boundary.\n    let bitsPerLine = tileWidth * pixelBitSkip;\n    if ((bitsPerLine & 7) !== 0) {\n      bitsPerLine = (bitsPerLine + 7) & (~7);\n    }\n\n    for (let y = 0; y < tileHeight; ++y) {\n      const lineBitOffset = y * bitsPerLine;\n      for (let x = 0; x < tileWidth; ++x) {\n        const pixelBitOffset = lineBitOffset + (x * samplesToTransfer * bitsPerSample);\n        for (let i = 0; i < samplesToTransfer; ++i) {\n          const bitOffset = pixelBitOffset + (i * bitsPerSample);\n          const outIndex = (((y * tileWidth) + x) * samplesToTransfer) + i;\n\n          const byteOffset = Math.floor(bitOffset / 8);\n          const innerBitOffset = bitOffset % 8;\n          if (innerBitOffset + bitsPerSample <= 8) {\n            outArray[outIndex] = (view.getUint8(byteOffset) >> (8 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 16) {\n            outArray[outIndex] = (view.getUint16(byteOffset) >> (16 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 24) {\n            const raw = (view.getUint16(byteOffset) << 8) | (view.getUint8(byteOffset + 2));\n            outArray[outIndex] = (raw >> (24 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else {\n            outArray[outIndex] = (view.getUint32(byteOffset) >> (32 - bitsPerSample) - innerBitOffset) & bitMask;\n          }\n\n          // let outWord = 0;\n          // for (let bit = 0; bit < bitsPerSample; ++bit) {\n          //   if (inByteArray[bitOffset >> 3]\n          //     & (0x80 >> (bitOffset & 7))) {\n          //     outWord |= (1 << (bitsPerSample - 1 - bit));\n          //   }\n          //   ++bitOffset;\n          // }\n\n          // outArray[outIndex] = outWord;\n          // outArray[pixel] = outWord;\n          // pixel += 1;\n        }\n        // bitOffset = bitOffset + pixelBitSkip - bitsPerSample;\n      }\n    }\n  } else if (format === 3) { // floating point\n    // Float16 is handled elsewhere\n    // normalize 16/24 bit floats to 32 bit floats in the array\n    // console.time();\n    // if (bitsPerSample === 16) {\n    //   for (let byte = 0, outIndex = 0; byte < inBuffer.byteLength; byte += 2, ++outIndex) {\n    //     outArray[outIndex] = getFloat16(view, byte);\n    //   }\n    // }\n    // console.timeEnd()\n  }\n\n  return outArray.buffer;\n}\n\n/**\n * GeoTIFF sub-file image.\n */\nclass GeoTIFFImage {\n  /**\n   * @constructor\n   * @param {Object} fileDirectory The parsed file directory\n   * @param {Object} geoKeys The parsed geo-keys\n   * @param {DataView} dataView The DataView for the underlying file.\n   * @param {Boolean} littleEndian Whether the file is encoded in little or big endian\n   * @param {Boolean} cache Whether or not decoded tiles shall be cached\n   * @param {import('./source/basesource').BaseSource} source The datasource to read from\n   */\n  constructor(fileDirectory, geoKeys, dataView, littleEndian, cache, source) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeys = geoKeys;\n    this.dataView = dataView;\n    this.littleEndian = littleEndian;\n    this.tiles = cache ? {} : null;\n    this.isTiled = !fileDirectory.StripOffsets;\n    const planarConfiguration = fileDirectory.PlanarConfiguration;\n    this.planarConfiguration = (typeof planarConfiguration === 'undefined') ? 1 : planarConfiguration;\n    if (this.planarConfiguration !== 1 && this.planarConfiguration !== 2) {\n      throw new Error('Invalid planar configuration.');\n    }\n\n    this.source = source;\n  }\n\n  /**\n   * Returns the associated parsed file directory.\n   * @returns {Object} the parsed file directory\n   */\n  getFileDirectory() {\n    return this.fileDirectory;\n  }\n\n  /**\n   * Returns the associated parsed geo keys.\n   * @returns {Object} the parsed geo keys\n   */\n  getGeoKeys() {\n    return this.geoKeys;\n  }\n\n  /**\n   * Returns the width of the image.\n   * @returns {Number} the width of the image\n   */\n  getWidth() {\n    return this.fileDirectory.ImageWidth;\n  }\n\n  /**\n   * Returns the height of the image.\n   * @returns {Number} the height of the image\n   */\n  getHeight() {\n    return this.fileDirectory.ImageLength;\n  }\n\n  /**\n   * Returns the number of samples per pixel.\n   * @returns {Number} the number of samples per pixel\n   */\n  getSamplesPerPixel() {\n    return typeof this.fileDirectory.SamplesPerPixel !== 'undefined'\n      ? this.fileDirectory.SamplesPerPixel : 1;\n  }\n\n  /**\n   * Returns the width of each tile.\n   * @returns {Number} the width of each tile\n   */\n  getTileWidth() {\n    return this.isTiled ? this.fileDirectory.TileWidth : this.getWidth();\n  }\n\n  /**\n   * Returns the height of each tile.\n   * @returns {Number} the height of each tile\n   */\n  getTileHeight() {\n    if (this.isTiled) {\n      return this.fileDirectory.TileLength;\n    }\n    if (typeof this.fileDirectory.RowsPerStrip !== 'undefined') {\n      return Math.min(this.fileDirectory.RowsPerStrip, this.getHeight());\n    }\n    return this.getHeight();\n  }\n\n  getBlockWidth() {\n    return this.getTileWidth();\n  }\n\n  getBlockHeight(y) {\n    if (this.isTiled || (y + 1) * this.getTileHeight() <= this.getHeight()) {\n      return this.getTileHeight();\n    } else {\n      return this.getHeight() - (y * this.getTileHeight());\n    }\n  }\n\n  /**\n   * Calculates the number of bytes for each pixel across all samples. Only full\n   * bytes are supported, an exception is thrown when this is not the case.\n   * @returns {Number} the bytes per pixel\n   */\n  getBytesPerPixel() {\n    let bytes = 0;\n    for (let i = 0; i < this.fileDirectory.BitsPerSample.length; ++i) {\n      bytes += this.getSampleByteSize(i);\n    }\n    return bytes;\n  }\n\n  getSampleByteSize(i) {\n    if (i >= this.fileDirectory.BitsPerSample.length) {\n      throw new RangeError(`Sample index ${i} is out of range.`);\n    }\n    return Math.ceil(this.fileDirectory.BitsPerSample[i] / 8);\n  }\n\n  getReaderForSample(sampleIndex) {\n    const format = this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n    const bitsPerSample = this.fileDirectory.BitsPerSample[sampleIndex];\n    switch (format) {\n      case 1: // unsigned integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getUint8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getUint16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getUint32;\n        }\n        break;\n      case 2: // twos complement signed integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getInt8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getInt16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getInt32;\n        }\n        break;\n      case 3:\n        switch (bitsPerSample) {\n          case 16:\n            return function (offset, littleEndian) {\n              return getFloat16(this, offset, littleEndian);\n            };\n          case 32:\n            return DataView.prototype.getFloat32;\n          case 64:\n            return DataView.prototype.getFloat64;\n          default:\n            break;\n        }\n        break;\n      default:\n        break;\n    }\n    throw Error('Unsupported data format/bitsPerSample');\n  }\n\n  getSampleFormat(sampleIndex = 0) {\n    return this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n  }\n\n  getBitsPerSample(sampleIndex = 0) {\n    return this.fileDirectory.BitsPerSample[sampleIndex];\n  }\n\n  getArrayForSample(sampleIndex, size) {\n    const format = this.getSampleFormat(sampleIndex);\n    const bitsPerSample = this.getBitsPerSample(sampleIndex);\n    return arrayForType(format, bitsPerSample, size);\n  }\n\n  /**\n   * Returns the decoded strip or tile.\n   * @param {Number} x the strip or tile x-offset\n   * @param {Number} y the tile y-offset (0 for stripped images)\n   * @param {Number} sample the sample to get for separated samples\n   * @param {import(\"./geotiff\").Pool|import(\"./geotiff\").BaseDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise.<ArrayBuffer>}\n   */\n  async getTileOrStrip(x, y, sample, poolOrDecoder, signal) {\n    const numTilesPerRow = Math.ceil(this.getWidth() / this.getTileWidth());\n    const numTilesPerCol = Math.ceil(this.getHeight() / this.getTileHeight());\n    let index;\n    const { tiles } = this;\n    if (this.planarConfiguration === 1) {\n      index = (y * numTilesPerRow) + x;\n    } else if (this.planarConfiguration === 2) {\n      index = (sample * numTilesPerRow * numTilesPerCol) + (y * numTilesPerRow) + x;\n    }\n\n    let offset;\n    let byteCount;\n    if (this.isTiled) {\n      offset = this.fileDirectory.TileOffsets[index];\n      byteCount = this.fileDirectory.TileByteCounts[index];\n    } else {\n      offset = this.fileDirectory.StripOffsets[index];\n      byteCount = this.fileDirectory.StripByteCounts[index];\n    }\n    const slice = (await this.source.fetch([{ offset, length: byteCount }], signal))[0];\n\n    let request;\n    if (tiles === null || !tiles[index]) {\n    // resolve each request by potentially applying array normalization\n      request = (async () => {\n        let data = await poolOrDecoder.decode(this.fileDirectory, slice);\n        const sampleFormat = this.getSampleFormat();\n        const bitsPerSample = this.getBitsPerSample();\n        if (needsNormalization(sampleFormat, bitsPerSample)) {\n          data = normalizeArray(\n            data,\n            sampleFormat,\n            this.planarConfiguration,\n            this.getSamplesPerPixel(),\n            bitsPerSample,\n            this.getTileWidth(),\n            this.getBlockHeight(y),\n          );\n        }\n        return data;\n      })();\n\n      // set the cache\n      if (tiles !== null) {\n        tiles[index] = request;\n      }\n    } else {\n      // get from the cache\n      request = tiles[index];\n    }\n\n    // cache the tile request\n    return { x, y, sample, data: await request };\n  }\n\n  /**\n   * Internal read function.\n   * @private\n   * @param {Array} imageWindow The image window in pixel coordinates\n   * @param {Array} samples The selected samples (0-based indices)\n   * @param {TypedArray|TypedArray[]} valueArrays The array(s) to write into\n   * @param {Boolean} interleave Whether or not to write in an interleaved manner\n   * @param {import(\"./geotiff\").Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {number} width the width of window to be read into\n   * @param {number} height the height of window to be read into\n   * @param {number} resampleMethod the resampling method to be used when interpolating\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise<ReadRasterResult>}\n   */\n  async _readRaster(imageWindow, samples, valueArrays, interleave, poolOrDecoder, width,\n    height, resampleMethod, signal) {\n    const tileWidth = this.getTileWidth();\n    const tileHeight = this.getTileHeight();\n    const imageWidth = this.getWidth();\n    const imageHeight = this.getHeight();\n\n    const minXTile = Math.max(Math.floor(imageWindow[0] / tileWidth), 0);\n    const maxXTile = Math.min(\n      Math.ceil(imageWindow[2] / tileWidth),\n      Math.ceil(imageWidth / tileWidth),\n    );\n    const minYTile = Math.max(Math.floor(imageWindow[1] / tileHeight), 0);\n    const maxYTile = Math.min(\n      Math.ceil(imageWindow[3] / tileHeight),\n      Math.ceil(imageHeight / tileHeight),\n    );\n    const windowWidth = imageWindow[2] - imageWindow[0];\n\n    let bytesPerPixel = this.getBytesPerPixel();\n\n    const srcSampleOffsets = [];\n    const sampleReaders = [];\n    for (let i = 0; i < samples.length; ++i) {\n      if (this.planarConfiguration === 1) {\n        srcSampleOffsets.push(sum(this.fileDirectory.BitsPerSample, 0, samples[i]) / 8);\n      } else {\n        srcSampleOffsets.push(0);\n      }\n      sampleReaders.push(this.getReaderForSample(samples[i]));\n    }\n\n    const promises = [];\n    const { littleEndian } = this;\n\n    for (let yTile = minYTile; yTile < maxYTile; ++yTile) {\n      for (let xTile = minXTile; xTile < maxXTile; ++xTile) {\n        let getPromise;\n        if (this.planarConfiguration === 1) {\n          getPromise = this.getTileOrStrip(xTile, yTile, 0, poolOrDecoder, signal);\n        }\n        for (let sampleIndex = 0; sampleIndex < samples.length; ++sampleIndex) {\n          const si = sampleIndex;\n          const sample = samples[sampleIndex];\n          if (this.planarConfiguration === 2) {\n            bytesPerPixel = this.getSampleByteSize(sample);\n            getPromise = this.getTileOrStrip(xTile, yTile, sample, poolOrDecoder, signal);\n          }\n          const promise = getPromise.then((tile) => {\n            const buffer = tile.data;\n            const dataView = new DataView(buffer);\n            const blockHeight = this.getBlockHeight(tile.y);\n            const firstLine = tile.y * tileHeight;\n            const firstCol = tile.x * tileWidth;\n            const lastLine = firstLine + blockHeight;\n            const lastCol = (tile.x + 1) * tileWidth;\n            const reader = sampleReaders[si];\n\n            const ymax = Math.min(blockHeight, blockHeight - (lastLine - imageWindow[3]), imageHeight - firstLine);\n            const xmax = Math.min(tileWidth, tileWidth - (lastCol - imageWindow[2]), imageWidth - firstCol);\n\n            for (let y = Math.max(0, imageWindow[1] - firstLine); y < ymax; ++y) {\n              for (let x = Math.max(0, imageWindow[0] - firstCol); x < xmax; ++x) {\n                const pixelOffset = ((y * tileWidth) + x) * bytesPerPixel;\n                const value = reader.call(\n                  dataView, pixelOffset + srcSampleOffsets[si], littleEndian,\n                );\n                let windowCoordinate;\n                if (interleave) {\n                  windowCoordinate = ((y + firstLine - imageWindow[1]) * windowWidth * samples.length)\n                    + ((x + firstCol - imageWindow[0]) * samples.length)\n                    + si;\n                  valueArrays[windowCoordinate] = value;\n                } else {\n                  windowCoordinate = (\n                    (y + firstLine - imageWindow[1]) * windowWidth\n                  ) + x + firstCol - imageWindow[0];\n                  valueArrays[si][windowCoordinate] = value;\n                }\n              }\n            }\n          });\n          promises.push(promise);\n        }\n      }\n    }\n    await Promise.all(promises);\n\n    if ((width && (imageWindow[2] - imageWindow[0]) !== width)\n        || (height && (imageWindow[3] - imageWindow[1]) !== height)) {\n      let resampled;\n      if (interleave) {\n        resampled = resampleInterleaved(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          samples.length,\n          resampleMethod,\n        );\n      } else {\n        resampled = resample(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          resampleMethod,\n        );\n      }\n      resampled.width = width;\n      resampled.height = height;\n      return resampled;\n    }\n\n    valueArrays.width = width || imageWindow[2] - imageWindow[0];\n    valueArrays.height = height || imageWindow[3] - imageWindow[1];\n\n    return valueArrays;\n  }\n\n  /**\n   * Reads raster data from the image. This function reads all selected samples\n   * into separate arrays of the correct type for that sample or into a single\n   * combined array when `interleave` is set. When provided, only a subset\n   * of the raster is read for each sample.\n   *\n   * @param {ReadRasterOptions} [options={}] optional parameters\n   * @returns {Promise<ReadRasterResult>} the decoded arrays as a promise\n   */\n  async readRasters({\n    window: wnd, samples = [], interleave, pool = null,\n    width, height, resampleMethod, fillValue, signal,\n  } = {}) {\n    const imageWindow = wnd || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const imageWindowWidth = imageWindow[2] - imageWindow[0];\n    const imageWindowHeight = imageWindow[3] - imageWindow[1];\n    const numPixels = imageWindowWidth * imageWindowHeight;\n    const samplesPerPixel = this.getSamplesPerPixel();\n\n    if (!samples || !samples.length) {\n      for (let i = 0; i < samplesPerPixel; ++i) {\n        samples.push(i);\n      }\n    } else {\n      for (let i = 0; i < samples.length; ++i) {\n        if (samples[i] >= samplesPerPixel) {\n          return Promise.reject(new RangeError(`Invalid sample index '${samples[i]}'.`));\n        }\n      }\n    }\n    let valueArrays;\n    if (interleave) {\n      const format = this.fileDirectory.SampleFormat\n        ? Math.max.apply(null, this.fileDirectory.SampleFormat) : 1;\n      const bitsPerSample = Math.max.apply(null, this.fileDirectory.BitsPerSample);\n      valueArrays = arrayForType(format, bitsPerSample, numPixels * samples.length);\n      if (fillValue) {\n        valueArrays.fill(fillValue);\n      }\n    } else {\n      valueArrays = [];\n      for (let i = 0; i < samples.length; ++i) {\n        const valueArray = this.getArrayForSample(samples[i], numPixels);\n        if (Array.isArray(fillValue) && i < fillValue.length) {\n          valueArray.fill(fillValue[i]);\n        } else if (fillValue && !Array.isArray(fillValue)) {\n          valueArray.fill(fillValue);\n        }\n        valueArrays.push(valueArray);\n      }\n    }\n\n    const poolOrDecoder = pool || await getDecoder(this.fileDirectory);\n\n    const result = await this._readRaster(\n      imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod, signal,\n    );\n    return result;\n  }\n\n  /**\n   * Reads raster data from the image as RGB. The result is always an\n   * interleaved typed array.\n   * Colorspaces other than RGB will be transformed to RGB, color maps expanded.\n   * When no other method is applicable, the first sample is used to produce a\n   * grayscale image.\n   * When provided, only a subset of the raster is read for each sample.\n   *\n   * @param {Object} [options] optional parameters\n   * @param {Array<number>} [options.window] the subset to read data from in pixels.\n   * @param {boolean} [options.interleave=true] whether the data shall be read\n   *                                             in one single array or separate\n   *                                             arrays.\n   * @param {import(\"./geotiff\").Pool} [options.pool=null] The optional decoder pool to use.\n   * @param {number} [options.width] The desired width of the output. When the width is no the\n   *                                 same as the images, resampling will be performed.\n   * @param {number} [options.height] The desired height of the output. When the width is no the\n   *                                  same as the images, resampling will be performed.\n   * @param {string} [options.resampleMethod='nearest'] The desired resampling method.\n   * @param {boolean} [options.enableAlpha=false] Enable reading alpha channel if present.\n   * @param {AbortSignal} [options.signal] An AbortSignal that may be signalled if the request is\n   *                                       to be aborted\n   * @returns {Promise<ReadRasterResult>} the RGB array as a Promise\n   */\n  async readRGB({ window, interleave = true, pool = null, width, height,\n    resampleMethod, enableAlpha = false, signal } = {}) {\n    const imageWindow = window || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const pi = this.fileDirectory.PhotometricInterpretation;\n\n    if (pi === photometricInterpretations.RGB) {\n      let s = [0, 1, 2];\n      if ((!(this.fileDirectory.ExtraSamples === ExtraSamplesValues.Unspecified)) && enableAlpha) {\n        s = [];\n        for (let i = 0; i < this.fileDirectory.BitsPerSample.length; i += 1) {\n          s.push(i);\n        }\n      }\n      return this.readRasters({\n        window,\n        interleave,\n        samples: s,\n        pool,\n        width,\n        height,\n        resampleMethod,\n        signal,\n      });\n    }\n\n    let samples;\n    switch (pi) {\n      case photometricInterpretations.WhiteIsZero:\n      case photometricInterpretations.BlackIsZero:\n      case photometricInterpretations.Palette:\n        samples = [0];\n        break;\n      case photometricInterpretations.CMYK:\n        samples = [0, 1, 2, 3];\n        break;\n      case photometricInterpretations.YCbCr:\n      case photometricInterpretations.CIELab:\n        samples = [0, 1, 2];\n        break;\n      default:\n        throw new Error('Invalid or unsupported photometric interpretation.');\n    }\n\n    const subOptions = {\n      window: imageWindow,\n      interleave: true,\n      samples,\n      pool,\n      width,\n      height,\n      resampleMethod,\n      signal,\n    };\n    const { fileDirectory } = this;\n    const raster = await this.readRasters(subOptions);\n\n    const max = 2 ** this.fileDirectory.BitsPerSample[0];\n    let data;\n    switch (pi) {\n      case photometricInterpretations.WhiteIsZero:\n        data = fromWhiteIsZero(raster, max);\n        break;\n      case photometricInterpretations.BlackIsZero:\n        data = fromBlackIsZero(raster, max);\n        break;\n      case photometricInterpretations.Palette:\n        data = fromPalette(raster, fileDirectory.ColorMap);\n        break;\n      case photometricInterpretations.CMYK:\n        data = fromCMYK(raster);\n        break;\n      case photometricInterpretations.YCbCr:\n        data = fromYCbCr(raster);\n        break;\n      case photometricInterpretations.CIELab:\n        data = fromCIELab(raster);\n        break;\n      default:\n        throw new Error('Unsupported photometric interpretation.');\n    }\n\n    // if non-interleaved data is requested, we must split the channels\n    // into their respective arrays\n    if (!interleave) {\n      const red = new Uint8Array(data.length / 3);\n      const green = new Uint8Array(data.length / 3);\n      const blue = new Uint8Array(data.length / 3);\n      for (let i = 0, j = 0; i < data.length; i += 3, ++j) {\n        red[j] = data[i];\n        green[j] = data[i + 1];\n        blue[j] = data[i + 2];\n      }\n      data = [red, green, blue];\n    }\n\n    data.width = raster.width;\n    data.height = raster.height;\n    return data;\n  }\n\n  /**\n   * Returns an array of tiepoints.\n   * @returns {Object[]}\n   */\n  getTiePoints() {\n    if (!this.fileDirectory.ModelTiepoint) {\n      return [];\n    }\n\n    const tiePoints = [];\n    for (let i = 0; i < this.fileDirectory.ModelTiepoint.length; i += 6) {\n      tiePoints.push({\n        i: this.fileDirectory.ModelTiepoint[i],\n        j: this.fileDirectory.ModelTiepoint[i + 1],\n        k: this.fileDirectory.ModelTiepoint[i + 2],\n        x: this.fileDirectory.ModelTiepoint[i + 3],\n        y: this.fileDirectory.ModelTiepoint[i + 4],\n        z: this.fileDirectory.ModelTiepoint[i + 5],\n      });\n    }\n    return tiePoints;\n  }\n\n  /**\n   * Returns the parsed GDAL metadata items.\n   *\n   * If sample is passed to null, dataset-level metadata will be returned.\n   * Otherwise only metadata specific to the provided sample will be returned.\n   *\n   * @param {number} [sample=null] The sample index.\n   * @returns {Object}\n   */\n  getGDALMetadata(sample = null) {\n    const metadata = {};\n    if (!this.fileDirectory.GDAL_METADATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_METADATA;\n\n    let items = findTagsByName(string, 'Item');\n\n    if (sample === null) {\n      items = items.filter((item) => getAttribute(item, 'sample') === undefined);\n    } else {\n      items = items.filter((item) => Number(getAttribute(item, 'sample')) === sample);\n    }\n\n    for (let i = 0; i < items.length; ++i) {\n      const item = items[i];\n      metadata[getAttribute(item, 'name')] = item.inner;\n    }\n    return metadata;\n  }\n\n  /**\n   * Returns the GDAL nodata value\n   * @returns {number|null}\n   */\n  getGDALNoData() {\n    if (!this.fileDirectory.GDAL_NODATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_NODATA;\n    return Number(string.substring(0, string.length - 1));\n  }\n\n  /**\n   * Returns the image origin as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @returns {Array<number>} The origin as a vector\n   */\n  getOrigin() {\n    const tiePoints = this.fileDirectory.ModelTiepoint;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n    if (tiePoints && tiePoints.length === 6) {\n      return [\n        tiePoints[3],\n        tiePoints[4],\n        tiePoints[5],\n      ];\n    }\n    if (modelTransformation) {\n      return [\n        modelTransformation[3],\n        modelTransformation[7],\n        modelTransformation[11],\n      ];\n    }\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns the image resolution as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @param {GeoTIFFImage} [referenceImage=null] A reference image to calculate the resolution from\n   *                                             in cases when the current image does not have the\n   *                                             required tags on its own.\n   * @returns {Array<number>} The resolution as a vector\n   */\n  getResolution(referenceImage = null) {\n    const modelPixelScale = this.fileDirectory.ModelPixelScale;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n\n    if (modelPixelScale) {\n      return [\n        modelPixelScale[0],\n        -modelPixelScale[1],\n        modelPixelScale[2],\n      ];\n    }\n    if (modelTransformation) {\n      if (modelTransformation[1] === 0 && modelTransformation[4] === 0) {\n        return [\n          modelTransformation[0],\n          -modelTransformation[5],\n          modelTransformation[10],\n        ];\n      }\n      return [\n        Math.sqrt((modelTransformation[0] * modelTransformation[0])\n          + (modelTransformation[4] * modelTransformation[4])),\n        -Math.sqrt((modelTransformation[1] * modelTransformation[1])\n          + (modelTransformation[5] * modelTransformation[5])),\n        modelTransformation[10]];\n    }\n\n    if (referenceImage) {\n      const [refResX, refResY, refResZ] = referenceImage.getResolution();\n      return [\n        refResX * referenceImage.getWidth() / this.getWidth(),\n        refResY * referenceImage.getHeight() / this.getHeight(),\n        refResZ * referenceImage.getWidth() / this.getWidth(),\n      ];\n    }\n\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns whether or not the pixels of the image depict an area (or point).\n   * @returns {Boolean} Whether the pixels are a point\n   */\n  pixelIsArea() {\n    return this.geoKeys.GTRasterTypeGeoKey === 1;\n  }\n\n  /**\n   * Returns the image bounding box as an array of 4 values: min-x, min-y,\n   * max-x and max-y. When the image has no affine transformation, then an\n   * exception is thrown.\n   * @param {boolean} [tilegrid=false] If true return extent for a tilegrid\n   *                                   without adjustment for ModelTransformation.\n   * @returns {Array<number>} The bounding box\n   */\n  getBoundingBox(tilegrid = false) {\n    const height = this.getHeight();\n    const width = this.getWidth();\n\n    if (this.fileDirectory.ModelTransformation && !tilegrid) {\n      // eslint-disable-next-line no-unused-vars\n      const [a, b, c, d, e, f, g, h] = this.fileDirectory.ModelTransformation;\n\n      const corners = [\n        [0, 0],\n        [0, height],\n        [width, 0],\n        [width, height],\n      ];\n\n      const projected = corners.map(([I, J]) => [\n        d + (a * I) + (b * J),\n        h + (e * I) + (f * J),\n      ]);\n\n      const xs = projected.map((pt) => pt[0]);\n      const ys = projected.map((pt) => pt[1]);\n\n      return [\n        Math.min(...xs),\n        Math.min(...ys),\n        Math.max(...xs),\n        Math.max(...ys),\n      ];\n    } else {\n      const origin = this.getOrigin();\n      const resolution = this.getResolution();\n\n      const x1 = origin[0];\n      const y1 = origin[1];\n\n      const x2 = x1 + (resolution[0] * width);\n      const y2 = y1 + (resolution[1] * height);\n\n      return [\n        Math.min(x1, x2),\n        Math.min(y1, y2),\n        Math.max(x1, x2),\n        Math.max(y1, y2),\n      ];\n    }\n  }\n}\n\nexport default GeoTIFFImage;\n","export const fieldTagNames = {\n  // TIFF Baseline\n  0x013B: 'Artist',\n  0x0102: 'BitsPerSample',\n  0x0109: 'CellLength',\n  0x0108: 'CellWidth',\n  0x0140: 'ColorMap',\n  0x0103: 'Compression',\n  0x8298: 'Copyright',\n  0x0132: 'DateTime',\n  0x0152: 'ExtraSamples',\n  0x010A: 'FillOrder',\n  0x0121: 'FreeByteCounts',\n  0x0120: 'FreeOffsets',\n  0x0123: 'GrayResponseCurve',\n  0x0122: 'GrayResponseUnit',\n  0x013C: 'HostComputer',\n  0x010E: 'ImageDescription',\n  0x0101: 'ImageLength',\n  0x0100: 'ImageWidth',\n  0x010F: 'Make',\n  0x0119: 'MaxSampleValue',\n  0x0118: 'MinSampleValue',\n  0x0110: 'Model',\n  0x00FE: 'NewSubfileType',\n  0x0112: 'Orientation',\n  0x0106: 'PhotometricInterpretation',\n  0x011C: 'PlanarConfiguration',\n  0x0128: 'ResolutionUnit',\n  0x0116: 'RowsPerStrip',\n  0x0115: 'SamplesPerPixel',\n  0x0131: 'Software',\n  0x0117: 'StripByteCounts',\n  0x0111: 'StripOffsets',\n  0x00FF: 'SubfileType',\n  0x0107: 'Threshholding',\n  0x011A: 'XResolution',\n  0x011B: 'YResolution',\n\n  // TIFF Extended\n  0x0146: 'BadFaxLines',\n  0x0147: 'CleanFaxData',\n  0x0157: 'ClipPath',\n  0x0148: 'ConsecutiveBadFaxLines',\n  0x01B1: 'Decode',\n  0x01B2: 'DefaultImageColor',\n  0x010D: 'DocumentName',\n  0x0150: 'DotRange',\n  0x0141: 'HalftoneHints',\n  0x015A: 'Indexed',\n  0x015B: 'JPEGTables',\n  0x011D: 'PageName',\n  0x0129: 'PageNumber',\n  0x013D: 'Predictor',\n  0x013F: 'PrimaryChromaticities',\n  0x0214: 'ReferenceBlackWhite',\n  0x0153: 'SampleFormat',\n  0x0154: 'SMinSampleValue',\n  0x0155: 'SMaxSampleValue',\n  0x022F: 'StripRowCounts',\n  0x014A: 'SubIFDs',\n  0x0124: 'T4Options',\n  0x0125: 'T6Options',\n  0x0145: 'TileByteCounts',\n  0x0143: 'TileLength',\n  0x0144: 'TileOffsets',\n  0x0142: 'TileWidth',\n  0x012D: 'TransferFunction',\n  0x013E: 'WhitePoint',\n  0x0158: 'XClipPathUnits',\n  0x011E: 'XPosition',\n  0x0211: 'YCbCrCoefficients',\n  0x0213: 'YCbCrPositioning',\n  0x0212: 'YCbCrSubSampling',\n  0x0159: 'YClipPathUnits',\n  0x011F: 'YPosition',\n\n  // EXIF\n  0x9202: 'ApertureValue',\n  0xA001: 'ColorSpace',\n  0x9004: 'DateTimeDigitized',\n  0x9003: 'DateTimeOriginal',\n  0x8769: 'Exif IFD',\n  0x9000: 'ExifVersion',\n  0x829A: 'ExposureTime',\n  0xA300: 'FileSource',\n  0x9209: 'Flash',\n  0xA000: 'FlashpixVersion',\n  0x829D: 'FNumber',\n  0xA420: 'ImageUniqueID',\n  0x9208: 'LightSource',\n  0x927C: 'MakerNote',\n  0x9201: 'ShutterSpeedValue',\n  0x9286: 'UserComment',\n\n  // IPTC\n  0x83BB: 'IPTC',\n\n  // ICC\n  0x8773: 'ICC Profile',\n\n  // XMP\n  0x02BC: 'XMP',\n\n  // GDAL\n  0xA480: 'GDAL_METADATA',\n  0xA481: 'GDAL_NODATA',\n\n  // Photoshop\n  0x8649: 'Photoshop',\n\n  // GeoTiff\n  0x830E: 'ModelPixelScale',\n  0x8482: 'ModelTiepoint',\n  0x85D8: 'ModelTransformation',\n  0x87AF: 'GeoKeyDirectory',\n  0x87B0: 'GeoDoubleParams',\n  0x87B1: 'GeoAsciiParams',\n\n  // LERC\n  0xC5F2: 'LercParameters',\n};\n\nexport const fieldTags = {};\nfor (const key in fieldTagNames) {\n  if (fieldTagNames.hasOwnProperty(key)) {\n    fieldTags[fieldTagNames[key]] = parseInt(key, 10);\n  }\n}\n\nexport const fieldTagTypes = {\n  256: 'SHORT',\n  257: 'SHORT',\n  258: 'SHORT',\n  259: 'SHORT',\n  262: 'SHORT',\n  273: 'LONG',\n  274: 'SHORT',\n  277: 'SHORT',\n  278: 'LONG',\n  279: 'LONG',\n  282: 'RATIONAL',\n  283: 'RATIONAL',\n  284: 'SHORT',\n  286: 'SHORT',\n  287: 'RATIONAL',\n  296: 'SHORT',\n  297: 'SHORT',\n  305: 'ASCII',\n  306: 'ASCII',\n  338: 'SHORT',\n  339: 'SHORT',\n  513: 'LONG',\n  514: 'LONG',\n  1024: 'SHORT',\n  1025: 'SHORT',\n  2048: 'SHORT',\n  2049: 'ASCII',\n  3072: 'SHORT',\n  3073: 'ASCII',\n  33550: 'DOUBLE',\n  33922: 'DOUBLE',\n  34264: 'DOUBLE',\n  34665: 'LONG',\n  34735: 'SHORT',\n  34736: 'DOUBLE',\n  34737: 'ASCII',\n  42113: 'ASCII',\n};\n\nexport const arrayFields = [\n  fieldTags.BitsPerSample,\n  fieldTags.ExtraSamples,\n  fieldTags.SampleFormat,\n  fieldTags.StripByteCounts,\n  fieldTags.StripOffsets,\n  fieldTags.StripRowCounts,\n  fieldTags.TileByteCounts,\n  fieldTags.TileOffsets,\n  fieldTags.SubIFDs,\n];\n\nexport const fieldTypeNames = {\n  0x0001: 'BYTE',\n  0x0002: 'ASCII',\n  0x0003: 'SHORT',\n  0x0004: 'LONG',\n  0x0005: 'RATIONAL',\n  0x0006: 'SBYTE',\n  0x0007: 'UNDEFINED',\n  0x0008: 'SSHORT',\n  0x0009: 'SLONG',\n  0x000A: 'SRATIONAL',\n  0x000B: 'FLOAT',\n  0x000C: 'DOUBLE',\n  // IFD offset, suggested by https://owl.phy.queensu.ca/~phil/exiftool/standards.html\n  0x000D: 'IFD',\n  // introduced by BigTIFF\n  0x0010: 'LONG8',\n  0x0011: 'SLONG8',\n  0x0012: 'IFD8',\n};\n\nexport const fieldTypes = {};\nfor (const key in fieldTypeNames) {\n  if (fieldTypeNames.hasOwnProperty(key)) {\n    fieldTypes[fieldTypeNames[key]] = parseInt(key, 10);\n  }\n}\n\nexport const photometricInterpretations = {\n  WhiteIsZero: 0,\n  BlackIsZero: 1,\n  RGB: 2,\n  Palette: 3,\n  TransparencyMask: 4,\n  CMYK: 5,\n  YCbCr: 6,\n\n  CIELab: 8,\n  ICCLab: 9,\n};\n\nexport const ExtraSamplesValues = {\n  Unspecified: 0,\n  Assocalpha: 1,\n  Unassalpha: 2,\n};\n\nexport const LercParameters = {\n  Version: 0,\n  AddCompression: 1,\n};\n\nexport const LercAddCompression = {\n  None: 0,\n  Deflate: 1,\n  Zstandard: 2,\n};\n\nexport const geoKeyNames = {\n  1024: 'GTModelTypeGeoKey',\n  1025: 'GTRasterTypeGeoKey',\n  1026: 'GTCitationGeoKey',\n  2048: 'GeographicTypeGeoKey',\n  2049: 'GeogCitationGeoKey',\n  2050: 'GeogGeodeticDatumGeoKey',\n  2051: 'GeogPrimeMeridianGeoKey',\n  2052: 'GeogLinearUnitsGeoKey',\n  2053: 'GeogLinearUnitSizeGeoKey',\n  2054: 'GeogAngularUnitsGeoKey',\n  2055: 'GeogAngularUnitSizeGeoKey',\n  2056: 'GeogEllipsoidGeoKey',\n  2057: 'GeogSemiMajorAxisGeoKey',\n  2058: 'GeogSemiMinorAxisGeoKey',\n  2059: 'GeogInvFlatteningGeoKey',\n  2060: 'GeogAzimuthUnitsGeoKey',\n  2061: 'GeogPrimeMeridianLongGeoKey',\n  2062: 'GeogTOWGS84GeoKey',\n  3072: 'ProjectedCSTypeGeoKey',\n  3073: 'PCSCitationGeoKey',\n  3074: 'ProjectionGeoKey',\n  3075: 'ProjCoordTransGeoKey',\n  3076: 'ProjLinearUnitsGeoKey',\n  3077: 'ProjLinearUnitSizeGeoKey',\n  3078: 'ProjStdParallel1GeoKey',\n  3079: 'ProjStdParallel2GeoKey',\n  3080: 'ProjNatOriginLongGeoKey',\n  3081: 'ProjNatOriginLatGeoKey',\n  3082: 'ProjFalseEastingGeoKey',\n  3083: 'ProjFalseNorthingGeoKey',\n  3084: 'ProjFalseOriginLongGeoKey',\n  3085: 'ProjFalseOriginLatGeoKey',\n  3086: 'ProjFalseOriginEastingGeoKey',\n  3087: 'ProjFalseOriginNorthingGeoKey',\n  3088: 'ProjCenterLongGeoKey',\n  3089: 'ProjCenterLatGeoKey',\n  3090: 'ProjCenterEastingGeoKey',\n  3091: 'ProjCenterNorthingGeoKey',\n  3092: 'ProjScaleAtNatOriginGeoKey',\n  3093: 'ProjScaleAtCenterGeoKey',\n  3094: 'ProjAzimuthAngleGeoKey',\n  3095: 'ProjStraightVertPoleLongGeoKey',\n  3096: 'ProjRectifiedGridAngleGeoKey',\n  4096: 'VerticalCSTypeGeoKey',\n  4097: 'VerticalCitationGeoKey',\n  4098: 'VerticalDatumGeoKey',\n  4099: 'VerticalUnitsGeoKey',\n};\n\nexport const geoKeys = {};\nfor (const key in geoKeyNames) {\n  if (geoKeyNames.hasOwnProperty(key)) {\n    geoKeys[geoKeyNames[key]] = parseInt(key, 10);\n  }\n}\n"],"names":["$defineProperty","$SyntaxError","$TypeError","gopd","module","exports","obj","property","value","arguments","length","nonEnumerable","nonWritable","nonConfigurable","loose","desc","configurable","enumerable","writable","keys","hasSymbols","Symbol","toStr","Object","prototype","toString","concat","Array","defineDataProperty","isFunction","fn","call","supportsDescriptors","defineProperty","object","name","predicate","defineProperties","map","predicates","props","getOwnPropertySymbols","i","GetIntrinsic","e","EvalError","Error","RangeError","ReferenceError","SyntaxError","TypeError","URIError","ReflectOwnKeys","R","Reflect","ReflectApply","apply","target","receiver","args","Function","ProcessEmitWarning","warning","console","warn","ownKeys","getOwnPropertyNames","NumberIsNaN","Number","isNaN","EventEmitter","init","this","once","_events","undefined","_eventsCount","_maxListeners","defaultMaxListeners","checkListener","listener","_getMaxListeners","that","_addListener","type","prepend","m","events","existing","create","newListener","emit","unshift","push","warned","w","String","emitter","count","onceWrapper","fired","removeListener","wrapFn","_onceWrap","state","wrapped","bind","_listeners","unwrap","evlistener","unwrapListeners","arrayClone","listenerCount","arr","n","copy","spliceOne","list","index","pop","ret","Promise","resolve","reject","errorListener","err","resolver","slice","eventTargetAgnosticAddListener","addErrorHandlerIfEventEmitter","handler","flags","on","addEventListener","wrapListener","arg","removeEventListener","get","set","getPrototypeOf","setMaxListeners","getMaxListeners","doError","error","er","message","context","len","listeners","addListener","prependListener","prependOnceListener","position","originalListener","shift","off","removeAllListeners","key","rawListeners","eventNames","equal","a","b","constructor","isArray","Map","size","entries","has","Set","ArrayBuffer","isView","RegExp","source","valueOf","hasOwnProperty","data","opts","cmp","cycles","f","node","aobj","bobj","seen","stringify","toJSON","isFinite","JSON","out","indexOf","seenIndex","sort","splice","isCallable","forEachArray","array","iterator","forEachString","string","charAt","forEachObject","k","forEach","thisArg","ERROR_MESSAGE","max","Math","funcType","concatty","j","slicy","arrLike","offset","joiny","joiner","str","bound","binder","result","boundLength","boundArgs","Empty","implementation","$Error","$EvalError","$RangeError","$ReferenceError","$URIError","$Function","getEvalledConstructor","expressionSyntax","$gOPD","getOwnPropertyDescriptor","throwTypeError","ThrowTypeError","calleeThrows","gOPDthrows","hasProto","getProto","x","__proto__","needsEval","TypedArray","Uint8Array","INTRINSICS","AggregateError","Atomics","BigInt","BigInt64Array","BigUint64Array","Boolean","DataView","Date","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","eval","Float32Array","Float64Array","FinalizationRegistry","Int8Array","Int16Array","Int32Array","parseFloat","parseInt","Proxy","SharedArrayBuffer","Uint8ClampedArray","Uint16Array","Uint32Array","WeakMap","WeakRef","WeakSet","errorProto","doEval","gen","LEGACY_ALIASES","hasOwn","$concat","$spliceApply","$replace","replace","$strSlice","$exec","exec","rePropName","reEscapeChar","stringToPath","first","last","match","number","quote","subString","getBaseIntrinsic","allowMissing","alias","intrinsicName","parts","intrinsicBaseName","intrinsic","intrinsicRealName","skipFurtherCaching","isOwn","part","hasPropertyDescriptors","hasArrayLengthDefineBug","test","foo","$Object","origSymbol","hasSymbolSham","sym","symObj","symVal","syms","propertyIsEnumerable","descriptor","toStringTag","$hasOwn","read","buffer","isLE","mLen","nBytes","eLen","eMax","eBias","nBits","d","s","NaN","Infinity","pow","write","c","rt","abs","floor","log","LN2","ctor","superCtor","super_","TempCtor","hasToStringTag","callBound","$toString","isStandardArguments","isLegacyArguments","callee","supportsStandardArguments","badArrayLike","isCallableMarker","fnToStr","reflectApply","_","constructorRegex","isES6ClassFn","fnStr","tryFunctionObject","objectClass","fnClass","genClass","ddaClass","ddaClass2","ddaClass3","isIE68","isDDA","document","all","strClass","GeneratorFunction","isFnRegex","getGeneratorFunc","generatorFunc","callBind","define","getPolyfill","shim","polyfill","whichTypedArray","traverse","schema","cb","pre","post","_traverse","jsonPtr","rootSchema","parentJsonPtr","parentKeyword","parentSchema","keyIndex","sch","arrayKeywords","propsKeywords","prop","escapeJsonPtr","keywords","allKeys","skipKeywords","additionalItems","items","contains","additionalProperties","propertyNames","not","allOf","anyOf","oneOf","definitions","properties","patternProperties","dependencies","default","enum","const","required","maximum","minimum","exclusiveMaximum","exclusiveMinimum","multipleOf","maxLength","minLength","pattern","format","maxItems","minItems","uniqueItems","maxProperties","minProperties","registry","addDecoder","cases","importFn","async","getDecoder","fileDirectory","Compression","Decoder","then","zstd","DataView64","arrayBuffer","_dataView","getUint64","littleEndian","left","getUint32","right","combined","isSafeInteger","getInt64","isNegative","getUint8","carrying","byte","getInt8","getUint16","getInt16","getInt32","getFloat16","getFloat32","getFloat64","DataSlice","sliceOffset","bigTiff","_sliceOffset","_littleEndian","_bigTiff","sliceTop","byteLength","covers","readUint8","readInt8","readUint16","readInt16","readUint32","readInt32","readFloat32","readFloat64","readUint64","readInt64","readOffset","CRLFCRLF","itemsToObject","fromEntries","toLowerCase","parseHeaders","text","split","line","kv","trim","parseContentType","rawContentType","rawParams","paramsItems","param","params","parseContentRange","rawContentRange","start","end","total","parseByteRanges","responseArrayBuffer","boundary","decoder","TextDecoder","startBoundary","endBoundary","decode","min","startsWith","innerText","substr","endOfHeaders","headers","startOfData","fileSize","BaseSource","fetch","slices","signal","fetchSlice","close","wait","milliseconds","setTimeout","zip","A","from","B","AbortError","super","captureStackTrace","CustomAggregateError","errors","Block","top","BlockGroup","blockIds","BlockedSource","blockSize","cacheSize","blockCache","maxSize","onEviction","blockId","block","evictedBlocks","blockRequests","blockIdsToFetch","abortedBlockIds","missingBlockIds","allBlockIds","clear","firstBlockOffset","current","add","fetchBlocks","missingRequests","allSettled","abortedBlockRequests","filter","id","aborted","blocks","failedBlocks","requiredBlocks","readSliceData","groups","groupBlocks","groupRequests","groupIndex","group","response","blockOffset","o","t","delete","sortedBlockIds","lastBlockId","blockIdLow","blockIdHigh","sliceData","sliceView","delta","topDelta","usedBlockLength","blockInnerOffset","rangeInnerOffset","blockView","BaseResponse","ok","status","getHeader","headerName","getData","BaseClient","url","request","FetchResponse","FetchClient","credentials","XHRResponse","xhr","getResponseHeader","XHRClient","constructRequest","XMLHttpRequest","open","responseType","setRequestHeader","onload","onerror","onabort","send","abort","HttpResponse","dataPromise","statusCode","HttpClient","parsedUrl","httpApi","protocol","resolveData","chunks","chunk","Buffer","destroy","RemoteSource","client","maxRanges","allowFullFile","_fileSize","fetchSlices","Range","join","byteRanges","others","maybeWrapInBlockedSource","makeFetchSource","blockOptions","makeXHRSource","makeHttpSource","makeRemoteSource","forceXHR","clientOptions","FileReaderSource","file","blob","reader","FileReader","event","readAsArrayBuffer","makeFileReaderSource","getFieldTypeLength","fieldType","BYTE","ASCII","SBYTE","UNDEFINED","SHORT","SSHORT","LONG","SLONG","FLOAT","IFD","RATIONAL","SRATIONAL","DOUBLE","LONG8","SLONG8","IFD8","parseGeoKeyDirectory","rawGeoKeyDirectory","GeoKeyDirectory","geoKeyDirectory","location","substring","subarray","getValues","dataSlice","values","readMethod","fieldTypeLength","ImageFileDirectory","nextIFDByteOffset","GeoTIFFImageIndexError","GeoTIFFBase","readRasters","options","window","imageWindow","width","height","resX","resY","bbox","firstImage","getImage","usedImage","imageCount","getImageCount","imgBBox","getBoundingBox","oX","oY","getOrigin","rX","rY","getResolution","usedBBox","allImages","image","SubfileType","subfileType","NewSubfileType","newSubfileType","getWidth","imgResX","imgResY","getHeight","wnd","imageResX","imageResY","round","GeoTIFF","firstIFDOffset","cache","ifdRequests","ghostValues","getSlice","fallbackSize","parseFileDirectoryAt","entrySize","offsetSize","numDirEntries","byteSize","entryCount","fieldTag","typeCount","fieldValues","valueOffset","actualOffset","fieldDataSlice","requestIFD","previousIfd","ifd","dataView","hasNext","getGhostValues","detectionString","heuristicAreaSize","valuesString","firstLine","metadataSize","fullString","fromSource","headerData","BOM","magicNumber","offsetByteSize","MultiGeoTIFF","mainFile","overviewFiles","imageFiles","fileDirectoriesPerFile","fileDirectoriesPerFileParsing","parseFileDirectoriesPerFile","requests","visited","relativeIndex","imageFile","ii","imageCounts","reduce","ifds","fromUrl","fromBlob","fromUrls","mainUrl","overviewUrls","fromWhiteIsZero","raster","rgbRaster","fromBlackIsZero","fromPalette","colorMap","greenOffset","blueOffset","mapIndex","fromCMYK","cmykRaster","y","fromYCbCr","yCbCrRaster","cr","Xn","Yn","Zn","fromCIELab","cieLabRaster","L","a_","b_","r","g","z","copyNewSize","samplesPerPixel","resampleNearest","valueArrays","inWidth","inHeight","outWidth","outHeight","relX","relY","newArray","cy","cx","lerp","v0","v1","resampleBilinear","rawY","yl","yh","ceil","rawX","tx","xl","xh","ll","hl","lh","hh","resample","method","resampleNearestInterleaved","valueArray","samples","resampleBilinearInterleaved","resampleInterleaved","sum","arrayForType","bitsPerSample","needsNormalization","normalizeArray","inBuffer","planarConfiguration","tileWidth","tileHeight","view","outSize","samplesToTransfer","outArray","bitMask","repeat","pixelBitSkip","bitsPerLine","lineBitOffset","pixelBitOffset","bitOffset","outIndex","byteOffset","innerBitOffset","raw","GeoTIFFImage","geoKeys","tiles","isTiled","StripOffsets","PlanarConfiguration","getFileDirectory","getGeoKeys","ImageWidth","ImageLength","getSamplesPerPixel","SamplesPerPixel","getTileWidth","TileWidth","getTileHeight","TileLength","RowsPerStrip","getBlockWidth","getBlockHeight","getBytesPerPixel","bytes","BitsPerSample","getSampleByteSize","getReaderForSample","sampleIndex","SampleFormat","getSampleFormat","getBitsPerSample","getArrayForSample","getTileOrStrip","sample","poolOrDecoder","numTilesPerRow","numTilesPerCol","byteCount","TileOffsets","TileByteCounts","StripByteCounts","sampleFormat","_readRaster","interleave","resampleMethod","imageWidth","imageHeight","minXTile","maxXTile","minYTile","maxYTile","windowWidth","bytesPerPixel","srcSampleOffsets","sampleReaders","promises","yTile","xTile","getPromise","si","promise","tile","blockHeight","firstCol","lastLine","lastCol","ymax","xmax","pixelOffset","windowCoordinate","resampled","pool","fillValue","imageWindowWidth","imageWindowHeight","numPixels","fill","readRGB","enableAlpha","pi","PhotometricInterpretation","RGB","ExtraSamples","Unspecified","WhiteIsZero","BlackIsZero","Palette","CMYK","YCbCr","CIELab","subOptions","ColorMap","red","green","blue","getTiePoints","ModelTiepoint","tiePoints","getGDALMetadata","metadata","GDAL_METADATA","item","inner","getGDALNoData","GDAL_NODATA","modelTransformation","ModelTransformation","referenceImage","modelPixelScale","ModelPixelScale","sqrt","refResX","refResY","refResZ","pixelIsArea","GTRasterTypeGeoKey","tilegrid","h","corners","projected","I","J","xs","pt","ys","origin","resolution","x1","y1","x2","y2","fieldTagNames","fieldTags","arrayFields","StripRowCounts","SubIFDs","fieldTypeNames","fieldTypes","photometricInterpretations","TransparencyMask","ICCLab","ExtraSamplesValues","Assocalpha","Unassalpha","LercParameters","Version","AddCompression","LercAddCompression","None","Deflate","Zstandard","geoKeyNames"],"sourceRoot":""}